
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[18:04:54.663] plan(): Setting new future strategy stack:
[18:04:54.664] List of future strategies:
[18:04:54.664] 1. sequential:
[18:04:54.664]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:54.664]    - tweaked: FALSE
[18:04:54.664]    - call: future::plan("sequential")
[18:04:54.688] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[18:04:54.880] plan(): Setting new future strategy stack:
[18:04:54.880] List of future strategies:
[18:04:54.880] 1. sequential:
[18:04:54.880]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:54.880]    - tweaked: FALSE
[18:04:54.880]    - call: plan(strategy)
[18:04:54.909] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:54.913] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:54.913] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:54.925] - globals found: [3] ‘{’, ‘<-’, ‘*’
[18:04:54.925] Searching for globals ... DONE
[18:04:54.926] Resolving globals: TRUE
[18:04:54.926] Resolving any globals that are futures ...
[18:04:54.926] - globals: [3] ‘{’, ‘<-’, ‘*’
[18:04:54.926] Resolving any globals that are futures ... DONE
[18:04:54.927] 
[18:04:54.927] 
[18:04:54.928] getGlobalsAndPackages() ... DONE
[18:04:54.929] run() for ‘Future’ ...
[18:04:54.929] - state: ‘created’
[18:04:54.929] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:54.930] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:54.930] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:54.930]   - Field: ‘label’
[18:04:54.931]   - Field: ‘local’
[18:04:54.931]   - Field: ‘owner’
[18:04:54.931]   - Field: ‘envir’
[18:04:54.931]   - Field: ‘packages’
[18:04:54.931]   - Field: ‘gc’
[18:04:54.932]   - Field: ‘conditions’
[18:04:54.932]   - Field: ‘expr’
[18:04:54.932]   - Field: ‘uuid’
[18:04:54.932]   - Field: ‘seed’
[18:04:54.932]   - Field: ‘version’
[18:04:54.933]   - Field: ‘result’
[18:04:54.933]   - Field: ‘asynchronous’
[18:04:54.933]   - Field: ‘calls’
[18:04:54.933]   - Field: ‘globals’
[18:04:54.933]   - Field: ‘stdout’
[18:04:54.934]   - Field: ‘earlySignal’
[18:04:54.934]   - Field: ‘lazy’
[18:04:54.934]   - Field: ‘state’
[18:04:54.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:54.934] - Launch lazy future ...
[18:04:54.936] Packages needed by the future expression (n = 0): <none>
[18:04:54.936] Packages needed by future strategies (n = 0): <none>
[18:04:54.937] {
[18:04:54.937]     {
[18:04:54.937]         {
[18:04:54.937]             ...future.startTime <- base::Sys.time()
[18:04:54.937]             {
[18:04:54.937]                 {
[18:04:54.937]                   {
[18:04:54.937]                     base::local({
[18:04:54.937]                       has_future <- base::requireNamespace("future", 
[18:04:54.937]                         quietly = TRUE)
[18:04:54.937]                       if (has_future) {
[18:04:54.937]                         ns <- base::getNamespace("future")
[18:04:54.937]                         version <- ns[[".package"]][["version"]]
[18:04:54.937]                         if (is.null(version)) 
[18:04:54.937]                           version <- utils::packageVersion("future")
[18:04:54.937]                       }
[18:04:54.937]                       else {
[18:04:54.937]                         version <- NULL
[18:04:54.937]                       }
[18:04:54.937]                       if (!has_future || version < "1.8.0") {
[18:04:54.937]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:54.937]                           "", base::R.version$version.string), 
[18:04:54.937]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:54.937]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:54.937]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:54.937]                             "release", "version")], collapse = " "), 
[18:04:54.937]                           hostname = base::Sys.info()[["nodename"]])
[18:04:54.937]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:54.937]                           info)
[18:04:54.937]                         info <- base::paste(info, collapse = "; ")
[18:04:54.937]                         if (!has_future) {
[18:04:54.937]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:54.937]                             info)
[18:04:54.937]                         }
[18:04:54.937]                         else {
[18:04:54.937]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:54.937]                             info, version)
[18:04:54.937]                         }
[18:04:54.937]                         base::stop(msg)
[18:04:54.937]                       }
[18:04:54.937]                     })
[18:04:54.937]                   }
[18:04:54.937]                   ...future.strategy.old <- future::plan("list")
[18:04:54.937]                   options(future.plan = NULL)
[18:04:54.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:54.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:54.937]                 }
[18:04:54.937]                 ...future.workdir <- getwd()
[18:04:54.937]             }
[18:04:54.937]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:54.937]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:54.937]         }
[18:04:54.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:54.937]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:54.937]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:54.937]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:54.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:54.937]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:54.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:54.937]             base::names(...future.oldOptions))
[18:04:54.937]     }
[18:04:54.937]     if (FALSE) {
[18:04:54.937]     }
[18:04:54.937]     else {
[18:04:54.937]         if (TRUE) {
[18:04:54.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:54.937]                 open = "w")
[18:04:54.937]         }
[18:04:54.937]         else {
[18:04:54.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:54.937]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:54.937]         }
[18:04:54.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:54.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:54.937]             base::sink(type = "output", split = FALSE)
[18:04:54.937]             base::close(...future.stdout)
[18:04:54.937]         }, add = TRUE)
[18:04:54.937]     }
[18:04:54.937]     ...future.frame <- base::sys.nframe()
[18:04:54.937]     ...future.conditions <- base::list()
[18:04:54.937]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:54.937]     if (FALSE) {
[18:04:54.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:54.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:54.937]     }
[18:04:54.937]     ...future.result <- base::tryCatch({
[18:04:54.937]         base::withCallingHandlers({
[18:04:54.937]             ...future.value <- base::withVisible(base::local({
[18:04:54.937]                 b <- a
[18:04:54.937]                 a <- 2
[18:04:54.937]                 a * b
[18:04:54.937]             }))
[18:04:54.937]             future::FutureResult(value = ...future.value$value, 
[18:04:54.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:54.937]                   ...future.rng), globalenv = if (FALSE) 
[18:04:54.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:54.937]                     ...future.globalenv.names))
[18:04:54.937]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:54.937]         }, condition = base::local({
[18:04:54.937]             c <- base::c
[18:04:54.937]             inherits <- base::inherits
[18:04:54.937]             invokeRestart <- base::invokeRestart
[18:04:54.937]             length <- base::length
[18:04:54.937]             list <- base::list
[18:04:54.937]             seq.int <- base::seq.int
[18:04:54.937]             signalCondition <- base::signalCondition
[18:04:54.937]             sys.calls <- base::sys.calls
[18:04:54.937]             `[[` <- base::`[[`
[18:04:54.937]             `+` <- base::`+`
[18:04:54.937]             `<<-` <- base::`<<-`
[18:04:54.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:54.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:54.937]                   3L)]
[18:04:54.937]             }
[18:04:54.937]             function(cond) {
[18:04:54.937]                 is_error <- inherits(cond, "error")
[18:04:54.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:54.937]                   NULL)
[18:04:54.937]                 if (is_error) {
[18:04:54.937]                   sessionInformation <- function() {
[18:04:54.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:54.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:54.937]                       search = base::search(), system = base::Sys.info())
[18:04:54.937]                   }
[18:04:54.937]                   ...future.conditions[[length(...future.conditions) + 
[18:04:54.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:54.937]                     cond$call), session = sessionInformation(), 
[18:04:54.937]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:54.937]                   signalCondition(cond)
[18:04:54.937]                 }
[18:04:54.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:54.937]                 "immediateCondition"))) {
[18:04:54.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:54.937]                   ...future.conditions[[length(...future.conditions) + 
[18:04:54.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:54.937]                   if (TRUE && !signal) {
[18:04:54.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:54.937]                     {
[18:04:54.937]                       inherits <- base::inherits
[18:04:54.937]                       invokeRestart <- base::invokeRestart
[18:04:54.937]                       is.null <- base::is.null
[18:04:54.937]                       muffled <- FALSE
[18:04:54.937]                       if (inherits(cond, "message")) {
[18:04:54.937]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:54.937]                         if (muffled) 
[18:04:54.937]                           invokeRestart("muffleMessage")
[18:04:54.937]                       }
[18:04:54.937]                       else if (inherits(cond, "warning")) {
[18:04:54.937]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:54.937]                         if (muffled) 
[18:04:54.937]                           invokeRestart("muffleWarning")
[18:04:54.937]                       }
[18:04:54.937]                       else if (inherits(cond, "condition")) {
[18:04:54.937]                         if (!is.null(pattern)) {
[18:04:54.937]                           computeRestarts <- base::computeRestarts
[18:04:54.937]                           grepl <- base::grepl
[18:04:54.937]                           restarts <- computeRestarts(cond)
[18:04:54.937]                           for (restart in restarts) {
[18:04:54.937]                             name <- restart$name
[18:04:54.937]                             if (is.null(name)) 
[18:04:54.937]                               next
[18:04:54.937]                             if (!grepl(pattern, name)) 
[18:04:54.937]                               next
[18:04:54.937]                             invokeRestart(restart)
[18:04:54.937]                             muffled <- TRUE
[18:04:54.937]                             break
[18:04:54.937]                           }
[18:04:54.937]                         }
[18:04:54.937]                       }
[18:04:54.937]                       invisible(muffled)
[18:04:54.937]                     }
[18:04:54.937]                     muffleCondition(cond, pattern = "^muffle")
[18:04:54.937]                   }
[18:04:54.937]                 }
[18:04:54.937]                 else {
[18:04:54.937]                   if (TRUE) {
[18:04:54.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:54.937]                     {
[18:04:54.937]                       inherits <- base::inherits
[18:04:54.937]                       invokeRestart <- base::invokeRestart
[18:04:54.937]                       is.null <- base::is.null
[18:04:54.937]                       muffled <- FALSE
[18:04:54.937]                       if (inherits(cond, "message")) {
[18:04:54.937]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:54.937]                         if (muffled) 
[18:04:54.937]                           invokeRestart("muffleMessage")
[18:04:54.937]                       }
[18:04:54.937]                       else if (inherits(cond, "warning")) {
[18:04:54.937]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:54.937]                         if (muffled) 
[18:04:54.937]                           invokeRestart("muffleWarning")
[18:04:54.937]                       }
[18:04:54.937]                       else if (inherits(cond, "condition")) {
[18:04:54.937]                         if (!is.null(pattern)) {
[18:04:54.937]                           computeRestarts <- base::computeRestarts
[18:04:54.937]                           grepl <- base::grepl
[18:04:54.937]                           restarts <- computeRestarts(cond)
[18:04:54.937]                           for (restart in restarts) {
[18:04:54.937]                             name <- restart$name
[18:04:54.937]                             if (is.null(name)) 
[18:04:54.937]                               next
[18:04:54.937]                             if (!grepl(pattern, name)) 
[18:04:54.937]                               next
[18:04:54.937]                             invokeRestart(restart)
[18:04:54.937]                             muffled <- TRUE
[18:04:54.937]                             break
[18:04:54.937]                           }
[18:04:54.937]                         }
[18:04:54.937]                       }
[18:04:54.937]                       invisible(muffled)
[18:04:54.937]                     }
[18:04:54.937]                     muffleCondition(cond, pattern = "^muffle")
[18:04:54.937]                   }
[18:04:54.937]                 }
[18:04:54.937]             }
[18:04:54.937]         }))
[18:04:54.937]     }, error = function(ex) {
[18:04:54.937]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:54.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:54.937]                 ...future.rng), started = ...future.startTime, 
[18:04:54.937]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:54.937]             version = "1.8"), class = "FutureResult")
[18:04:54.937]     }, finally = {
[18:04:54.937]         if (!identical(...future.workdir, getwd())) 
[18:04:54.937]             setwd(...future.workdir)
[18:04:54.937]         {
[18:04:54.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:54.937]                 ...future.oldOptions$nwarnings <- NULL
[18:04:54.937]             }
[18:04:54.937]             base::options(...future.oldOptions)
[18:04:54.937]             if (.Platform$OS.type == "windows") {
[18:04:54.937]                 old_names <- names(...future.oldEnvVars)
[18:04:54.937]                 envs <- base::Sys.getenv()
[18:04:54.937]                 names <- names(envs)
[18:04:54.937]                 common <- intersect(names, old_names)
[18:04:54.937]                 added <- setdiff(names, old_names)
[18:04:54.937]                 removed <- setdiff(old_names, names)
[18:04:54.937]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:54.937]                   envs[common]]
[18:04:54.937]                 NAMES <- toupper(changed)
[18:04:54.937]                 args <- list()
[18:04:54.937]                 for (kk in seq_along(NAMES)) {
[18:04:54.937]                   name <- changed[[kk]]
[18:04:54.937]                   NAME <- NAMES[[kk]]
[18:04:54.937]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:54.937]                     next
[18:04:54.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:54.937]                 }
[18:04:54.937]                 NAMES <- toupper(added)
[18:04:54.937]                 for (kk in seq_along(NAMES)) {
[18:04:54.937]                   name <- added[[kk]]
[18:04:54.937]                   NAME <- NAMES[[kk]]
[18:04:54.937]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:54.937]                     next
[18:04:54.937]                   args[[name]] <- ""
[18:04:54.937]                 }
[18:04:54.937]                 NAMES <- toupper(removed)
[18:04:54.937]                 for (kk in seq_along(NAMES)) {
[18:04:54.937]                   name <- removed[[kk]]
[18:04:54.937]                   NAME <- NAMES[[kk]]
[18:04:54.937]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:54.937]                     next
[18:04:54.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:54.937]                 }
[18:04:54.937]                 if (length(args) > 0) 
[18:04:54.937]                   base::do.call(base::Sys.setenv, args = args)
[18:04:54.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:54.937]             }
[18:04:54.937]             else {
[18:04:54.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:54.937]             }
[18:04:54.937]             {
[18:04:54.937]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:54.937]                   0L) {
[18:04:54.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:54.937]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:54.937]                   base::options(opts)
[18:04:54.937]                 }
[18:04:54.937]                 {
[18:04:54.937]                   {
[18:04:54.937]                     NULL
[18:04:54.937]                     RNGkind("Mersenne-Twister")
[18:04:54.937]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:54.937]                       inherits = FALSE)
[18:04:54.937]                   }
[18:04:54.937]                   options(future.plan = NULL)
[18:04:54.937]                   if (is.na(NA_character_)) 
[18:04:54.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:54.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:54.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:54.937]                     .init = FALSE)
[18:04:54.937]                 }
[18:04:54.937]             }
[18:04:54.937]         }
[18:04:54.937]     })
[18:04:54.937]     if (TRUE) {
[18:04:54.937]         base::sink(type = "output", split = FALSE)
[18:04:54.937]         if (TRUE) {
[18:04:54.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:54.937]         }
[18:04:54.937]         else {
[18:04:54.937]             ...future.result["stdout"] <- base::list(NULL)
[18:04:54.937]         }
[18:04:54.937]         base::close(...future.stdout)
[18:04:54.937]         ...future.stdout <- NULL
[18:04:54.937]     }
[18:04:54.937]     ...future.result$conditions <- ...future.conditions
[18:04:54.937]     ...future.result$finished <- base::Sys.time()
[18:04:54.937]     ...future.result
[18:04:54.937] }
[18:04:54.941] plan(): Setting new future strategy stack:
[18:04:54.941] List of future strategies:
[18:04:54.941] 1. sequential:
[18:04:54.941]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:54.941]    - tweaked: FALSE
[18:04:54.941]    - call: NULL
[18:04:54.942] plan(): nbrOfWorkers() = 1
[18:04:54.944] plan(): Setting new future strategy stack:
[18:04:54.944] List of future strategies:
[18:04:54.944] 1. sequential:
[18:04:54.944]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:54.944]    - tweaked: FALSE
[18:04:54.944]    - call: plan(strategy)
[18:04:54.945] plan(): nbrOfWorkers() = 1
[18:04:54.946] SequentialFuture started (and completed)
[18:04:54.946] - Launch lazy future ... done
[18:04:54.947] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:54.948] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:54.949] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:54.951] - globals found: [3] ‘{’, ‘<-’, ‘*’
[18:04:54.951] Searching for globals ... DONE
[18:04:54.952] Resolving globals: TRUE
[18:04:54.952] Resolving any globals that are futures ...
[18:04:54.952] - globals: [3] ‘{’, ‘<-’, ‘*’
[18:04:54.952] Resolving any globals that are futures ... DONE
[18:04:54.953] 
[18:04:54.953] 
[18:04:54.953] getGlobalsAndPackages() ... DONE
[18:04:54.954] run() for ‘Future’ ...
[18:04:54.954] - state: ‘created’
[18:04:54.954] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:54.955] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:54.955] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:54.955]   - Field: ‘label’
[18:04:54.955]   - Field: ‘local’
[18:04:54.956]   - Field: ‘owner’
[18:04:54.956]   - Field: ‘envir’
[18:04:54.956]   - Field: ‘packages’
[18:04:54.956]   - Field: ‘gc’
[18:04:54.956]   - Field: ‘conditions’
[18:04:54.957]   - Field: ‘expr’
[18:04:54.957]   - Field: ‘uuid’
[18:04:54.957]   - Field: ‘seed’
[18:04:54.957]   - Field: ‘version’
[18:04:54.957]   - Field: ‘result’
[18:04:54.958]   - Field: ‘asynchronous’
[18:04:54.958]   - Field: ‘calls’
[18:04:54.958]   - Field: ‘globals’
[18:04:54.958]   - Field: ‘stdout’
[18:04:54.958]   - Field: ‘earlySignal’
[18:04:54.959]   - Field: ‘lazy’
[18:04:54.959]   - Field: ‘state’
[18:04:54.959] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:54.959] - Launch lazy future ...
[18:04:54.960] Packages needed by the future expression (n = 0): <none>
[18:04:54.960] Packages needed by future strategies (n = 0): <none>
[18:04:54.961] {
[18:04:54.961]     {
[18:04:54.961]         {
[18:04:54.961]             ...future.startTime <- base::Sys.time()
[18:04:54.961]             {
[18:04:54.961]                 {
[18:04:54.961]                   {
[18:04:54.961]                     base::local({
[18:04:54.961]                       has_future <- base::requireNamespace("future", 
[18:04:54.961]                         quietly = TRUE)
[18:04:54.961]                       if (has_future) {
[18:04:54.961]                         ns <- base::getNamespace("future")
[18:04:54.961]                         version <- ns[[".package"]][["version"]]
[18:04:54.961]                         if (is.null(version)) 
[18:04:54.961]                           version <- utils::packageVersion("future")
[18:04:54.961]                       }
[18:04:54.961]                       else {
[18:04:54.961]                         version <- NULL
[18:04:54.961]                       }
[18:04:54.961]                       if (!has_future || version < "1.8.0") {
[18:04:54.961]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:54.961]                           "", base::R.version$version.string), 
[18:04:54.961]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:54.961]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:54.961]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:54.961]                             "release", "version")], collapse = " "), 
[18:04:54.961]                           hostname = base::Sys.info()[["nodename"]])
[18:04:54.961]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:54.961]                           info)
[18:04:54.961]                         info <- base::paste(info, collapse = "; ")
[18:04:54.961]                         if (!has_future) {
[18:04:54.961]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:54.961]                             info)
[18:04:54.961]                         }
[18:04:54.961]                         else {
[18:04:54.961]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:54.961]                             info, version)
[18:04:54.961]                         }
[18:04:54.961]                         base::stop(msg)
[18:04:54.961]                       }
[18:04:54.961]                     })
[18:04:54.961]                   }
[18:04:54.961]                   ...future.strategy.old <- future::plan("list")
[18:04:54.961]                   options(future.plan = NULL)
[18:04:54.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:54.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:54.961]                 }
[18:04:54.961]                 ...future.workdir <- getwd()
[18:04:54.961]             }
[18:04:54.961]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:54.961]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:54.961]         }
[18:04:54.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:54.961]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:54.961]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:54.961]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:54.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:54.961]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:54.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:54.961]             base::names(...future.oldOptions))
[18:04:54.961]     }
[18:04:54.961]     if (FALSE) {
[18:04:54.961]     }
[18:04:54.961]     else {
[18:04:54.961]         if (TRUE) {
[18:04:54.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:54.961]                 open = "w")
[18:04:54.961]         }
[18:04:54.961]         else {
[18:04:54.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:54.961]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:54.961]         }
[18:04:54.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:54.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:54.961]             base::sink(type = "output", split = FALSE)
[18:04:54.961]             base::close(...future.stdout)
[18:04:54.961]         }, add = TRUE)
[18:04:54.961]     }
[18:04:54.961]     ...future.frame <- base::sys.nframe()
[18:04:54.961]     ...future.conditions <- base::list()
[18:04:54.961]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:54.961]     if (FALSE) {
[18:04:54.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:54.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:54.961]     }
[18:04:54.961]     ...future.result <- base::tryCatch({
[18:04:54.961]         base::withCallingHandlers({
[18:04:54.961]             ...future.value <- base::withVisible(base::local({
[18:04:54.961]                 b <- a
[18:04:54.961]                 a <- 2
[18:04:54.961]                 a * b
[18:04:54.961]             }))
[18:04:54.961]             future::FutureResult(value = ...future.value$value, 
[18:04:54.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:54.961]                   ...future.rng), globalenv = if (FALSE) 
[18:04:54.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:54.961]                     ...future.globalenv.names))
[18:04:54.961]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:54.961]         }, condition = base::local({
[18:04:54.961]             c <- base::c
[18:04:54.961]             inherits <- base::inherits
[18:04:54.961]             invokeRestart <- base::invokeRestart
[18:04:54.961]             length <- base::length
[18:04:54.961]             list <- base::list
[18:04:54.961]             seq.int <- base::seq.int
[18:04:54.961]             signalCondition <- base::signalCondition
[18:04:54.961]             sys.calls <- base::sys.calls
[18:04:54.961]             `[[` <- base::`[[`
[18:04:54.961]             `+` <- base::`+`
[18:04:54.961]             `<<-` <- base::`<<-`
[18:04:54.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:54.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:54.961]                   3L)]
[18:04:54.961]             }
[18:04:54.961]             function(cond) {
[18:04:54.961]                 is_error <- inherits(cond, "error")
[18:04:54.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:54.961]                   NULL)
[18:04:54.961]                 if (is_error) {
[18:04:54.961]                   sessionInformation <- function() {
[18:04:54.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:54.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:54.961]                       search = base::search(), system = base::Sys.info())
[18:04:54.961]                   }
[18:04:54.961]                   ...future.conditions[[length(...future.conditions) + 
[18:04:54.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:54.961]                     cond$call), session = sessionInformation(), 
[18:04:54.961]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:54.961]                   signalCondition(cond)
[18:04:54.961]                 }
[18:04:54.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:54.961]                 "immediateCondition"))) {
[18:04:54.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:54.961]                   ...future.conditions[[length(...future.conditions) + 
[18:04:54.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:54.961]                   if (TRUE && !signal) {
[18:04:54.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:54.961]                     {
[18:04:54.961]                       inherits <- base::inherits
[18:04:54.961]                       invokeRestart <- base::invokeRestart
[18:04:54.961]                       is.null <- base::is.null
[18:04:54.961]                       muffled <- FALSE
[18:04:54.961]                       if (inherits(cond, "message")) {
[18:04:54.961]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:54.961]                         if (muffled) 
[18:04:54.961]                           invokeRestart("muffleMessage")
[18:04:54.961]                       }
[18:04:54.961]                       else if (inherits(cond, "warning")) {
[18:04:54.961]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:54.961]                         if (muffled) 
[18:04:54.961]                           invokeRestart("muffleWarning")
[18:04:54.961]                       }
[18:04:54.961]                       else if (inherits(cond, "condition")) {
[18:04:54.961]                         if (!is.null(pattern)) {
[18:04:54.961]                           computeRestarts <- base::computeRestarts
[18:04:54.961]                           grepl <- base::grepl
[18:04:54.961]                           restarts <- computeRestarts(cond)
[18:04:54.961]                           for (restart in restarts) {
[18:04:54.961]                             name <- restart$name
[18:04:54.961]                             if (is.null(name)) 
[18:04:54.961]                               next
[18:04:54.961]                             if (!grepl(pattern, name)) 
[18:04:54.961]                               next
[18:04:54.961]                             invokeRestart(restart)
[18:04:54.961]                             muffled <- TRUE
[18:04:54.961]                             break
[18:04:54.961]                           }
[18:04:54.961]                         }
[18:04:54.961]                       }
[18:04:54.961]                       invisible(muffled)
[18:04:54.961]                     }
[18:04:54.961]                     muffleCondition(cond, pattern = "^muffle")
[18:04:54.961]                   }
[18:04:54.961]                 }
[18:04:54.961]                 else {
[18:04:54.961]                   if (TRUE) {
[18:04:54.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:54.961]                     {
[18:04:54.961]                       inherits <- base::inherits
[18:04:54.961]                       invokeRestart <- base::invokeRestart
[18:04:54.961]                       is.null <- base::is.null
[18:04:54.961]                       muffled <- FALSE
[18:04:54.961]                       if (inherits(cond, "message")) {
[18:04:54.961]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:54.961]                         if (muffled) 
[18:04:54.961]                           invokeRestart("muffleMessage")
[18:04:54.961]                       }
[18:04:54.961]                       else if (inherits(cond, "warning")) {
[18:04:54.961]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:54.961]                         if (muffled) 
[18:04:54.961]                           invokeRestart("muffleWarning")
[18:04:54.961]                       }
[18:04:54.961]                       else if (inherits(cond, "condition")) {
[18:04:54.961]                         if (!is.null(pattern)) {
[18:04:54.961]                           computeRestarts <- base::computeRestarts
[18:04:54.961]                           grepl <- base::grepl
[18:04:54.961]                           restarts <- computeRestarts(cond)
[18:04:54.961]                           for (restart in restarts) {
[18:04:54.961]                             name <- restart$name
[18:04:54.961]                             if (is.null(name)) 
[18:04:54.961]                               next
[18:04:54.961]                             if (!grepl(pattern, name)) 
[18:04:54.961]                               next
[18:04:54.961]                             invokeRestart(restart)
[18:04:54.961]                             muffled <- TRUE
[18:04:54.961]                             break
[18:04:54.961]                           }
[18:04:54.961]                         }
[18:04:54.961]                       }
[18:04:54.961]                       invisible(muffled)
[18:04:54.961]                     }
[18:04:54.961]                     muffleCondition(cond, pattern = "^muffle")
[18:04:54.961]                   }
[18:04:54.961]                 }
[18:04:54.961]             }
[18:04:54.961]         }))
[18:04:54.961]     }, error = function(ex) {
[18:04:54.961]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:54.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:54.961]                 ...future.rng), started = ...future.startTime, 
[18:04:54.961]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:54.961]             version = "1.8"), class = "FutureResult")
[18:04:54.961]     }, finally = {
[18:04:54.961]         if (!identical(...future.workdir, getwd())) 
[18:04:54.961]             setwd(...future.workdir)
[18:04:54.961]         {
[18:04:54.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:54.961]                 ...future.oldOptions$nwarnings <- NULL
[18:04:54.961]             }
[18:04:54.961]             base::options(...future.oldOptions)
[18:04:54.961]             if (.Platform$OS.type == "windows") {
[18:04:54.961]                 old_names <- names(...future.oldEnvVars)
[18:04:54.961]                 envs <- base::Sys.getenv()
[18:04:54.961]                 names <- names(envs)
[18:04:54.961]                 common <- intersect(names, old_names)
[18:04:54.961]                 added <- setdiff(names, old_names)
[18:04:54.961]                 removed <- setdiff(old_names, names)
[18:04:54.961]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:54.961]                   envs[common]]
[18:04:54.961]                 NAMES <- toupper(changed)
[18:04:54.961]                 args <- list()
[18:04:54.961]                 for (kk in seq_along(NAMES)) {
[18:04:54.961]                   name <- changed[[kk]]
[18:04:54.961]                   NAME <- NAMES[[kk]]
[18:04:54.961]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:54.961]                     next
[18:04:54.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:54.961]                 }
[18:04:54.961]                 NAMES <- toupper(added)
[18:04:54.961]                 for (kk in seq_along(NAMES)) {
[18:04:54.961]                   name <- added[[kk]]
[18:04:54.961]                   NAME <- NAMES[[kk]]
[18:04:54.961]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:54.961]                     next
[18:04:54.961]                   args[[name]] <- ""
[18:04:54.961]                 }
[18:04:54.961]                 NAMES <- toupper(removed)
[18:04:54.961]                 for (kk in seq_along(NAMES)) {
[18:04:54.961]                   name <- removed[[kk]]
[18:04:54.961]                   NAME <- NAMES[[kk]]
[18:04:54.961]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:54.961]                     next
[18:04:54.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:54.961]                 }
[18:04:54.961]                 if (length(args) > 0) 
[18:04:54.961]                   base::do.call(base::Sys.setenv, args = args)
[18:04:54.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:54.961]             }
[18:04:54.961]             else {
[18:04:54.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:54.961]             }
[18:04:54.961]             {
[18:04:54.961]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:54.961]                   0L) {
[18:04:54.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:54.961]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:54.961]                   base::options(opts)
[18:04:54.961]                 }
[18:04:54.961]                 {
[18:04:54.961]                   {
[18:04:54.961]                     NULL
[18:04:54.961]                     RNGkind("Mersenne-Twister")
[18:04:54.961]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:54.961]                       inherits = FALSE)
[18:04:54.961]                   }
[18:04:54.961]                   options(future.plan = NULL)
[18:04:54.961]                   if (is.na(NA_character_)) 
[18:04:54.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:54.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:54.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:54.961]                     .init = FALSE)
[18:04:54.961]                 }
[18:04:54.961]             }
[18:04:54.961]         }
[18:04:54.961]     })
[18:04:54.961]     if (TRUE) {
[18:04:54.961]         base::sink(type = "output", split = FALSE)
[18:04:54.961]         if (TRUE) {
[18:04:54.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:54.961]         }
[18:04:54.961]         else {
[18:04:54.961]             ...future.result["stdout"] <- base::list(NULL)
[18:04:54.961]         }
[18:04:54.961]         base::close(...future.stdout)
[18:04:54.961]         ...future.stdout <- NULL
[18:04:54.961]     }
[18:04:54.961]     ...future.result$conditions <- ...future.conditions
[18:04:54.961]     ...future.result$finished <- base::Sys.time()
[18:04:54.961]     ...future.result
[18:04:54.961] }
[18:04:54.964] plan(): Setting new future strategy stack:
[18:04:54.964] List of future strategies:
[18:04:54.964] 1. sequential:
[18:04:54.964]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:54.964]    - tweaked: FALSE
[18:04:54.964]    - call: NULL
[18:04:54.965] plan(): nbrOfWorkers() = 1
[18:04:54.967] plan(): Setting new future strategy stack:
[18:04:54.967] List of future strategies:
[18:04:54.967] 1. sequential:
[18:04:54.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:54.967]    - tweaked: FALSE
[18:04:54.967]    - call: plan(strategy)
[18:04:54.968] plan(): nbrOfWorkers() = 1
[18:04:54.968] SequentialFuture started (and completed)
[18:04:54.969] signalConditions() ...
[18:04:54.969]  - include = ‘immediateCondition’
[18:04:54.969]  - exclude = 
[18:04:54.969]  - resignal = FALSE
[18:04:54.969]  - Number of conditions: 1
[18:04:54.969] signalConditions() ... done
[18:04:54.970] - Launch lazy future ... done
[18:04:54.970] run() for ‘SequentialFuture’ ... done
[18:04:54.970] signalConditions() ...
[18:04:54.970]  - include = ‘immediateCondition’
[18:04:54.970]  - exclude = 
[18:04:54.971]  - resignal = FALSE
[18:04:54.971]  - Number of conditions: 1
[18:04:54.971] signalConditions() ... done
[18:04:54.971] Future state: ‘finished’
[18:04:54.971] signalConditions() ...
[18:04:54.972]  - include = ‘condition’
[18:04:54.975]  - exclude = ‘immediateCondition’
[18:04:54.976]  - resignal = TRUE
[18:04:54.976]  - Number of conditions: 1
[18:04:54.976]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:54.976] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.8.0-48-generic" "#48-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 14:04:52 UTC 2024" "99adafdbb12a" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-21 18:04:54"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.007] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.008] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.010] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.011] Searching for globals ... DONE
[18:04:55.011] Resolving globals: TRUE
[18:04:55.011] Resolving any globals that are futures ...
[18:04:55.011] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.012] Resolving any globals that are futures ... DONE
[18:04:55.012] Resolving futures part of globals (recursively) ...
[18:04:55.013] resolve() on list ...
[18:04:55.014]  recursive: 99
[18:04:55.014]  length: 1
[18:04:55.014]  elements: ‘ii’
[18:04:55.015]  length: 0 (resolved future 1)
[18:04:55.015] resolve() on list ... DONE
[18:04:55.015] - globals: [1] ‘ii’
[18:04:55.015] Resolving futures part of globals (recursively) ... DONE
[18:04:55.016] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:55.017] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.017] - globals: [1] ‘ii’
[18:04:55.017] 
[18:04:55.018] getGlobalsAndPackages() ... DONE
[18:04:55.018] run() for ‘Future’ ...
[18:04:55.018] - state: ‘created’
[18:04:55.019] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.019] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.019] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.019]   - Field: ‘label’
[18:04:55.020]   - Field: ‘local’
[18:04:55.020]   - Field: ‘owner’
[18:04:55.020]   - Field: ‘envir’
[18:04:55.020]   - Field: ‘packages’
[18:04:55.020]   - Field: ‘gc’
[18:04:55.021]   - Field: ‘conditions’
[18:04:55.021]   - Field: ‘expr’
[18:04:55.021]   - Field: ‘uuid’
[18:04:55.021]   - Field: ‘seed’
[18:04:55.021]   - Field: ‘version’
[18:04:55.022]   - Field: ‘result’
[18:04:55.022]   - Field: ‘asynchronous’
[18:04:55.022]   - Field: ‘calls’
[18:04:55.022]   - Field: ‘globals’
[18:04:55.022]   - Field: ‘stdout’
[18:04:55.023]   - Field: ‘earlySignal’
[18:04:55.023]   - Field: ‘lazy’
[18:04:55.023]   - Field: ‘state’
[18:04:55.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.023] - Launch lazy future ...
[18:04:55.024] Packages needed by the future expression (n = 0): <none>
[18:04:55.024] Packages needed by future strategies (n = 0): <none>
[18:04:55.025] {
[18:04:55.025]     {
[18:04:55.025]         {
[18:04:55.025]             ...future.startTime <- base::Sys.time()
[18:04:55.025]             {
[18:04:55.025]                 {
[18:04:55.025]                   {
[18:04:55.025]                     base::local({
[18:04:55.025]                       has_future <- base::requireNamespace("future", 
[18:04:55.025]                         quietly = TRUE)
[18:04:55.025]                       if (has_future) {
[18:04:55.025]                         ns <- base::getNamespace("future")
[18:04:55.025]                         version <- ns[[".package"]][["version"]]
[18:04:55.025]                         if (is.null(version)) 
[18:04:55.025]                           version <- utils::packageVersion("future")
[18:04:55.025]                       }
[18:04:55.025]                       else {
[18:04:55.025]                         version <- NULL
[18:04:55.025]                       }
[18:04:55.025]                       if (!has_future || version < "1.8.0") {
[18:04:55.025]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.025]                           "", base::R.version$version.string), 
[18:04:55.025]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.025]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.025]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.025]                             "release", "version")], collapse = " "), 
[18:04:55.025]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.025]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.025]                           info)
[18:04:55.025]                         info <- base::paste(info, collapse = "; ")
[18:04:55.025]                         if (!has_future) {
[18:04:55.025]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.025]                             info)
[18:04:55.025]                         }
[18:04:55.025]                         else {
[18:04:55.025]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.025]                             info, version)
[18:04:55.025]                         }
[18:04:55.025]                         base::stop(msg)
[18:04:55.025]                       }
[18:04:55.025]                     })
[18:04:55.025]                   }
[18:04:55.025]                   ...future.strategy.old <- future::plan("list")
[18:04:55.025]                   options(future.plan = NULL)
[18:04:55.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.025]                 }
[18:04:55.025]                 ...future.workdir <- getwd()
[18:04:55.025]             }
[18:04:55.025]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.025]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.025]         }
[18:04:55.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.025]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.025]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.025]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.025]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.025]             base::names(...future.oldOptions))
[18:04:55.025]     }
[18:04:55.025]     if (FALSE) {
[18:04:55.025]     }
[18:04:55.025]     else {
[18:04:55.025]         if (TRUE) {
[18:04:55.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.025]                 open = "w")
[18:04:55.025]         }
[18:04:55.025]         else {
[18:04:55.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.025]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.025]         }
[18:04:55.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.025]             base::sink(type = "output", split = FALSE)
[18:04:55.025]             base::close(...future.stdout)
[18:04:55.025]         }, add = TRUE)
[18:04:55.025]     }
[18:04:55.025]     ...future.frame <- base::sys.nframe()
[18:04:55.025]     ...future.conditions <- base::list()
[18:04:55.025]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.025]     if (FALSE) {
[18:04:55.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.025]     }
[18:04:55.025]     ...future.result <- base::tryCatch({
[18:04:55.025]         base::withCallingHandlers({
[18:04:55.025]             ...future.value <- base::withVisible(base::local({
[18:04:55.025]                 b <- a * ii
[18:04:55.025]                 a <- 0
[18:04:55.025]                 b
[18:04:55.025]             }))
[18:04:55.025]             future::FutureResult(value = ...future.value$value, 
[18:04:55.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.025]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.025]                     ...future.globalenv.names))
[18:04:55.025]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.025]         }, condition = base::local({
[18:04:55.025]             c <- base::c
[18:04:55.025]             inherits <- base::inherits
[18:04:55.025]             invokeRestart <- base::invokeRestart
[18:04:55.025]             length <- base::length
[18:04:55.025]             list <- base::list
[18:04:55.025]             seq.int <- base::seq.int
[18:04:55.025]             signalCondition <- base::signalCondition
[18:04:55.025]             sys.calls <- base::sys.calls
[18:04:55.025]             `[[` <- base::`[[`
[18:04:55.025]             `+` <- base::`+`
[18:04:55.025]             `<<-` <- base::`<<-`
[18:04:55.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.025]                   3L)]
[18:04:55.025]             }
[18:04:55.025]             function(cond) {
[18:04:55.025]                 is_error <- inherits(cond, "error")
[18:04:55.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.025]                   NULL)
[18:04:55.025]                 if (is_error) {
[18:04:55.025]                   sessionInformation <- function() {
[18:04:55.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.025]                       search = base::search(), system = base::Sys.info())
[18:04:55.025]                   }
[18:04:55.025]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.025]                     cond$call), session = sessionInformation(), 
[18:04:55.025]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.025]                   signalCondition(cond)
[18:04:55.025]                 }
[18:04:55.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.025]                 "immediateCondition"))) {
[18:04:55.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.025]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.025]                   if (TRUE && !signal) {
[18:04:55.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.025]                     {
[18:04:55.025]                       inherits <- base::inherits
[18:04:55.025]                       invokeRestart <- base::invokeRestart
[18:04:55.025]                       is.null <- base::is.null
[18:04:55.025]                       muffled <- FALSE
[18:04:55.025]                       if (inherits(cond, "message")) {
[18:04:55.025]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.025]                         if (muffled) 
[18:04:55.025]                           invokeRestart("muffleMessage")
[18:04:55.025]                       }
[18:04:55.025]                       else if (inherits(cond, "warning")) {
[18:04:55.025]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.025]                         if (muffled) 
[18:04:55.025]                           invokeRestart("muffleWarning")
[18:04:55.025]                       }
[18:04:55.025]                       else if (inherits(cond, "condition")) {
[18:04:55.025]                         if (!is.null(pattern)) {
[18:04:55.025]                           computeRestarts <- base::computeRestarts
[18:04:55.025]                           grepl <- base::grepl
[18:04:55.025]                           restarts <- computeRestarts(cond)
[18:04:55.025]                           for (restart in restarts) {
[18:04:55.025]                             name <- restart$name
[18:04:55.025]                             if (is.null(name)) 
[18:04:55.025]                               next
[18:04:55.025]                             if (!grepl(pattern, name)) 
[18:04:55.025]                               next
[18:04:55.025]                             invokeRestart(restart)
[18:04:55.025]                             muffled <- TRUE
[18:04:55.025]                             break
[18:04:55.025]                           }
[18:04:55.025]                         }
[18:04:55.025]                       }
[18:04:55.025]                       invisible(muffled)
[18:04:55.025]                     }
[18:04:55.025]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.025]                   }
[18:04:55.025]                 }
[18:04:55.025]                 else {
[18:04:55.025]                   if (TRUE) {
[18:04:55.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.025]                     {
[18:04:55.025]                       inherits <- base::inherits
[18:04:55.025]                       invokeRestart <- base::invokeRestart
[18:04:55.025]                       is.null <- base::is.null
[18:04:55.025]                       muffled <- FALSE
[18:04:55.025]                       if (inherits(cond, "message")) {
[18:04:55.025]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.025]                         if (muffled) 
[18:04:55.025]                           invokeRestart("muffleMessage")
[18:04:55.025]                       }
[18:04:55.025]                       else if (inherits(cond, "warning")) {
[18:04:55.025]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.025]                         if (muffled) 
[18:04:55.025]                           invokeRestart("muffleWarning")
[18:04:55.025]                       }
[18:04:55.025]                       else if (inherits(cond, "condition")) {
[18:04:55.025]                         if (!is.null(pattern)) {
[18:04:55.025]                           computeRestarts <- base::computeRestarts
[18:04:55.025]                           grepl <- base::grepl
[18:04:55.025]                           restarts <- computeRestarts(cond)
[18:04:55.025]                           for (restart in restarts) {
[18:04:55.025]                             name <- restart$name
[18:04:55.025]                             if (is.null(name)) 
[18:04:55.025]                               next
[18:04:55.025]                             if (!grepl(pattern, name)) 
[18:04:55.025]                               next
[18:04:55.025]                             invokeRestart(restart)
[18:04:55.025]                             muffled <- TRUE
[18:04:55.025]                             break
[18:04:55.025]                           }
[18:04:55.025]                         }
[18:04:55.025]                       }
[18:04:55.025]                       invisible(muffled)
[18:04:55.025]                     }
[18:04:55.025]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.025]                   }
[18:04:55.025]                 }
[18:04:55.025]             }
[18:04:55.025]         }))
[18:04:55.025]     }, error = function(ex) {
[18:04:55.025]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.025]                 ...future.rng), started = ...future.startTime, 
[18:04:55.025]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.025]             version = "1.8"), class = "FutureResult")
[18:04:55.025]     }, finally = {
[18:04:55.025]         if (!identical(...future.workdir, getwd())) 
[18:04:55.025]             setwd(...future.workdir)
[18:04:55.025]         {
[18:04:55.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.025]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.025]             }
[18:04:55.025]             base::options(...future.oldOptions)
[18:04:55.025]             if (.Platform$OS.type == "windows") {
[18:04:55.025]                 old_names <- names(...future.oldEnvVars)
[18:04:55.025]                 envs <- base::Sys.getenv()
[18:04:55.025]                 names <- names(envs)
[18:04:55.025]                 common <- intersect(names, old_names)
[18:04:55.025]                 added <- setdiff(names, old_names)
[18:04:55.025]                 removed <- setdiff(old_names, names)
[18:04:55.025]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.025]                   envs[common]]
[18:04:55.025]                 NAMES <- toupper(changed)
[18:04:55.025]                 args <- list()
[18:04:55.025]                 for (kk in seq_along(NAMES)) {
[18:04:55.025]                   name <- changed[[kk]]
[18:04:55.025]                   NAME <- NAMES[[kk]]
[18:04:55.025]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.025]                     next
[18:04:55.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.025]                 }
[18:04:55.025]                 NAMES <- toupper(added)
[18:04:55.025]                 for (kk in seq_along(NAMES)) {
[18:04:55.025]                   name <- added[[kk]]
[18:04:55.025]                   NAME <- NAMES[[kk]]
[18:04:55.025]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.025]                     next
[18:04:55.025]                   args[[name]] <- ""
[18:04:55.025]                 }
[18:04:55.025]                 NAMES <- toupper(removed)
[18:04:55.025]                 for (kk in seq_along(NAMES)) {
[18:04:55.025]                   name <- removed[[kk]]
[18:04:55.025]                   NAME <- NAMES[[kk]]
[18:04:55.025]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.025]                     next
[18:04:55.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.025]                 }
[18:04:55.025]                 if (length(args) > 0) 
[18:04:55.025]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.025]             }
[18:04:55.025]             else {
[18:04:55.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.025]             }
[18:04:55.025]             {
[18:04:55.025]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.025]                   0L) {
[18:04:55.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.025]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.025]                   base::options(opts)
[18:04:55.025]                 }
[18:04:55.025]                 {
[18:04:55.025]                   {
[18:04:55.025]                     NULL
[18:04:55.025]                     RNGkind("Mersenne-Twister")
[18:04:55.025]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.025]                       inherits = FALSE)
[18:04:55.025]                   }
[18:04:55.025]                   options(future.plan = NULL)
[18:04:55.025]                   if (is.na(NA_character_)) 
[18:04:55.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.025]                     .init = FALSE)
[18:04:55.025]                 }
[18:04:55.025]             }
[18:04:55.025]         }
[18:04:55.025]     })
[18:04:55.025]     if (TRUE) {
[18:04:55.025]         base::sink(type = "output", split = FALSE)
[18:04:55.025]         if (TRUE) {
[18:04:55.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.025]         }
[18:04:55.025]         else {
[18:04:55.025]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.025]         }
[18:04:55.025]         base::close(...future.stdout)
[18:04:55.025]         ...future.stdout <- NULL
[18:04:55.025]     }
[18:04:55.025]     ...future.result$conditions <- ...future.conditions
[18:04:55.025]     ...future.result$finished <- base::Sys.time()
[18:04:55.025]     ...future.result
[18:04:55.025] }
[18:04:55.028] assign_globals() ...
[18:04:55.028] List of 1
[18:04:55.028]  $ ii: int 1
[18:04:55.028]  - attr(*, "where")=List of 1
[18:04:55.028]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.028]  - attr(*, "resolved")= logi TRUE
[18:04:55.028]  - attr(*, "total_size")= num 56
[18:04:55.028]  - attr(*, "already-done")= logi TRUE
[18:04:55.033] - copied ‘ii’ to environment
[18:04:55.033] assign_globals() ... done
[18:04:55.034] plan(): Setting new future strategy stack:
[18:04:55.034] List of future strategies:
[18:04:55.034] 1. sequential:
[18:04:55.034]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.034]    - tweaked: FALSE
[18:04:55.034]    - call: NULL
[18:04:55.038] plan(): nbrOfWorkers() = 1
[18:04:55.039] plan(): Setting new future strategy stack:
[18:04:55.040] List of future strategies:
[18:04:55.040] 1. sequential:
[18:04:55.040]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.040]    - tweaked: FALSE
[18:04:55.040]    - call: plan(strategy)
[18:04:55.040] plan(): nbrOfWorkers() = 1
[18:04:55.041] SequentialFuture started (and completed)
[18:04:55.041] - Launch lazy future ... done
[18:04:55.041] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.042] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.043] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.045] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.046] Searching for globals ... DONE
[18:04:55.046] Resolving globals: TRUE
[18:04:55.046] Resolving any globals that are futures ...
[18:04:55.046] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.046] Resolving any globals that are futures ... DONE
[18:04:55.047] Resolving futures part of globals (recursively) ...
[18:04:55.047] resolve() on list ...
[18:04:55.048]  recursive: 99
[18:04:55.048]  length: 1
[18:04:55.048]  elements: ‘ii’
[18:04:55.048]  length: 0 (resolved future 1)
[18:04:55.048] resolve() on list ... DONE
[18:04:55.049] - globals: [1] ‘ii’
[18:04:55.049] Resolving futures part of globals (recursively) ... DONE
[18:04:55.049] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:55.050] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.050] - globals: [1] ‘ii’
[18:04:55.050] 
[18:04:55.050] getGlobalsAndPackages() ... DONE
[18:04:55.051] run() for ‘Future’ ...
[18:04:55.051] - state: ‘created’
[18:04:55.051] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.052] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.052]   - Field: ‘label’
[18:04:55.053]   - Field: ‘local’
[18:04:55.053]   - Field: ‘owner’
[18:04:55.053]   - Field: ‘envir’
[18:04:55.053]   - Field: ‘packages’
[18:04:55.053]   - Field: ‘gc’
[18:04:55.053]   - Field: ‘conditions’
[18:04:55.054]   - Field: ‘expr’
[18:04:55.054]   - Field: ‘uuid’
[18:04:55.054]   - Field: ‘seed’
[18:04:55.054]   - Field: ‘version’
[18:04:55.054]   - Field: ‘result’
[18:04:55.055]   - Field: ‘asynchronous’
[18:04:55.055]   - Field: ‘calls’
[18:04:55.055]   - Field: ‘globals’
[18:04:55.055]   - Field: ‘stdout’
[18:04:55.055]   - Field: ‘earlySignal’
[18:04:55.056]   - Field: ‘lazy’
[18:04:55.056]   - Field: ‘state’
[18:04:55.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.056] - Launch lazy future ...
[18:04:55.057] Packages needed by the future expression (n = 0): <none>
[18:04:55.057] Packages needed by future strategies (n = 0): <none>
[18:04:55.058] {
[18:04:55.058]     {
[18:04:55.058]         {
[18:04:55.058]             ...future.startTime <- base::Sys.time()
[18:04:55.058]             {
[18:04:55.058]                 {
[18:04:55.058]                   {
[18:04:55.058]                     base::local({
[18:04:55.058]                       has_future <- base::requireNamespace("future", 
[18:04:55.058]                         quietly = TRUE)
[18:04:55.058]                       if (has_future) {
[18:04:55.058]                         ns <- base::getNamespace("future")
[18:04:55.058]                         version <- ns[[".package"]][["version"]]
[18:04:55.058]                         if (is.null(version)) 
[18:04:55.058]                           version <- utils::packageVersion("future")
[18:04:55.058]                       }
[18:04:55.058]                       else {
[18:04:55.058]                         version <- NULL
[18:04:55.058]                       }
[18:04:55.058]                       if (!has_future || version < "1.8.0") {
[18:04:55.058]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.058]                           "", base::R.version$version.string), 
[18:04:55.058]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.058]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.058]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.058]                             "release", "version")], collapse = " "), 
[18:04:55.058]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.058]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.058]                           info)
[18:04:55.058]                         info <- base::paste(info, collapse = "; ")
[18:04:55.058]                         if (!has_future) {
[18:04:55.058]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.058]                             info)
[18:04:55.058]                         }
[18:04:55.058]                         else {
[18:04:55.058]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.058]                             info, version)
[18:04:55.058]                         }
[18:04:55.058]                         base::stop(msg)
[18:04:55.058]                       }
[18:04:55.058]                     })
[18:04:55.058]                   }
[18:04:55.058]                   ...future.strategy.old <- future::plan("list")
[18:04:55.058]                   options(future.plan = NULL)
[18:04:55.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.058]                 }
[18:04:55.058]                 ...future.workdir <- getwd()
[18:04:55.058]             }
[18:04:55.058]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.058]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.058]         }
[18:04:55.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.058]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.058]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.058]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.058]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.058]             base::names(...future.oldOptions))
[18:04:55.058]     }
[18:04:55.058]     if (FALSE) {
[18:04:55.058]     }
[18:04:55.058]     else {
[18:04:55.058]         if (TRUE) {
[18:04:55.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.058]                 open = "w")
[18:04:55.058]         }
[18:04:55.058]         else {
[18:04:55.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.058]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.058]         }
[18:04:55.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.058]             base::sink(type = "output", split = FALSE)
[18:04:55.058]             base::close(...future.stdout)
[18:04:55.058]         }, add = TRUE)
[18:04:55.058]     }
[18:04:55.058]     ...future.frame <- base::sys.nframe()
[18:04:55.058]     ...future.conditions <- base::list()
[18:04:55.058]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.058]     if (FALSE) {
[18:04:55.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.058]     }
[18:04:55.058]     ...future.result <- base::tryCatch({
[18:04:55.058]         base::withCallingHandlers({
[18:04:55.058]             ...future.value <- base::withVisible(base::local({
[18:04:55.058]                 b <- a * ii
[18:04:55.058]                 a <- 0
[18:04:55.058]                 b
[18:04:55.058]             }))
[18:04:55.058]             future::FutureResult(value = ...future.value$value, 
[18:04:55.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.058]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.058]                     ...future.globalenv.names))
[18:04:55.058]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.058]         }, condition = base::local({
[18:04:55.058]             c <- base::c
[18:04:55.058]             inherits <- base::inherits
[18:04:55.058]             invokeRestart <- base::invokeRestart
[18:04:55.058]             length <- base::length
[18:04:55.058]             list <- base::list
[18:04:55.058]             seq.int <- base::seq.int
[18:04:55.058]             signalCondition <- base::signalCondition
[18:04:55.058]             sys.calls <- base::sys.calls
[18:04:55.058]             `[[` <- base::`[[`
[18:04:55.058]             `+` <- base::`+`
[18:04:55.058]             `<<-` <- base::`<<-`
[18:04:55.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.058]                   3L)]
[18:04:55.058]             }
[18:04:55.058]             function(cond) {
[18:04:55.058]                 is_error <- inherits(cond, "error")
[18:04:55.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.058]                   NULL)
[18:04:55.058]                 if (is_error) {
[18:04:55.058]                   sessionInformation <- function() {
[18:04:55.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.058]                       search = base::search(), system = base::Sys.info())
[18:04:55.058]                   }
[18:04:55.058]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.058]                     cond$call), session = sessionInformation(), 
[18:04:55.058]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.058]                   signalCondition(cond)
[18:04:55.058]                 }
[18:04:55.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.058]                 "immediateCondition"))) {
[18:04:55.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.058]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.058]                   if (TRUE && !signal) {
[18:04:55.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.058]                     {
[18:04:55.058]                       inherits <- base::inherits
[18:04:55.058]                       invokeRestart <- base::invokeRestart
[18:04:55.058]                       is.null <- base::is.null
[18:04:55.058]                       muffled <- FALSE
[18:04:55.058]                       if (inherits(cond, "message")) {
[18:04:55.058]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.058]                         if (muffled) 
[18:04:55.058]                           invokeRestart("muffleMessage")
[18:04:55.058]                       }
[18:04:55.058]                       else if (inherits(cond, "warning")) {
[18:04:55.058]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.058]                         if (muffled) 
[18:04:55.058]                           invokeRestart("muffleWarning")
[18:04:55.058]                       }
[18:04:55.058]                       else if (inherits(cond, "condition")) {
[18:04:55.058]                         if (!is.null(pattern)) {
[18:04:55.058]                           computeRestarts <- base::computeRestarts
[18:04:55.058]                           grepl <- base::grepl
[18:04:55.058]                           restarts <- computeRestarts(cond)
[18:04:55.058]                           for (restart in restarts) {
[18:04:55.058]                             name <- restart$name
[18:04:55.058]                             if (is.null(name)) 
[18:04:55.058]                               next
[18:04:55.058]                             if (!grepl(pattern, name)) 
[18:04:55.058]                               next
[18:04:55.058]                             invokeRestart(restart)
[18:04:55.058]                             muffled <- TRUE
[18:04:55.058]                             break
[18:04:55.058]                           }
[18:04:55.058]                         }
[18:04:55.058]                       }
[18:04:55.058]                       invisible(muffled)
[18:04:55.058]                     }
[18:04:55.058]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.058]                   }
[18:04:55.058]                 }
[18:04:55.058]                 else {
[18:04:55.058]                   if (TRUE) {
[18:04:55.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.058]                     {
[18:04:55.058]                       inherits <- base::inherits
[18:04:55.058]                       invokeRestart <- base::invokeRestart
[18:04:55.058]                       is.null <- base::is.null
[18:04:55.058]                       muffled <- FALSE
[18:04:55.058]                       if (inherits(cond, "message")) {
[18:04:55.058]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.058]                         if (muffled) 
[18:04:55.058]                           invokeRestart("muffleMessage")
[18:04:55.058]                       }
[18:04:55.058]                       else if (inherits(cond, "warning")) {
[18:04:55.058]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.058]                         if (muffled) 
[18:04:55.058]                           invokeRestart("muffleWarning")
[18:04:55.058]                       }
[18:04:55.058]                       else if (inherits(cond, "condition")) {
[18:04:55.058]                         if (!is.null(pattern)) {
[18:04:55.058]                           computeRestarts <- base::computeRestarts
[18:04:55.058]                           grepl <- base::grepl
[18:04:55.058]                           restarts <- computeRestarts(cond)
[18:04:55.058]                           for (restart in restarts) {
[18:04:55.058]                             name <- restart$name
[18:04:55.058]                             if (is.null(name)) 
[18:04:55.058]                               next
[18:04:55.058]                             if (!grepl(pattern, name)) 
[18:04:55.058]                               next
[18:04:55.058]                             invokeRestart(restart)
[18:04:55.058]                             muffled <- TRUE
[18:04:55.058]                             break
[18:04:55.058]                           }
[18:04:55.058]                         }
[18:04:55.058]                       }
[18:04:55.058]                       invisible(muffled)
[18:04:55.058]                     }
[18:04:55.058]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.058]                   }
[18:04:55.058]                 }
[18:04:55.058]             }
[18:04:55.058]         }))
[18:04:55.058]     }, error = function(ex) {
[18:04:55.058]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.058]                 ...future.rng), started = ...future.startTime, 
[18:04:55.058]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.058]             version = "1.8"), class = "FutureResult")
[18:04:55.058]     }, finally = {
[18:04:55.058]         if (!identical(...future.workdir, getwd())) 
[18:04:55.058]             setwd(...future.workdir)
[18:04:55.058]         {
[18:04:55.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.058]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.058]             }
[18:04:55.058]             base::options(...future.oldOptions)
[18:04:55.058]             if (.Platform$OS.type == "windows") {
[18:04:55.058]                 old_names <- names(...future.oldEnvVars)
[18:04:55.058]                 envs <- base::Sys.getenv()
[18:04:55.058]                 names <- names(envs)
[18:04:55.058]                 common <- intersect(names, old_names)
[18:04:55.058]                 added <- setdiff(names, old_names)
[18:04:55.058]                 removed <- setdiff(old_names, names)
[18:04:55.058]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.058]                   envs[common]]
[18:04:55.058]                 NAMES <- toupper(changed)
[18:04:55.058]                 args <- list()
[18:04:55.058]                 for (kk in seq_along(NAMES)) {
[18:04:55.058]                   name <- changed[[kk]]
[18:04:55.058]                   NAME <- NAMES[[kk]]
[18:04:55.058]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.058]                     next
[18:04:55.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.058]                 }
[18:04:55.058]                 NAMES <- toupper(added)
[18:04:55.058]                 for (kk in seq_along(NAMES)) {
[18:04:55.058]                   name <- added[[kk]]
[18:04:55.058]                   NAME <- NAMES[[kk]]
[18:04:55.058]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.058]                     next
[18:04:55.058]                   args[[name]] <- ""
[18:04:55.058]                 }
[18:04:55.058]                 NAMES <- toupper(removed)
[18:04:55.058]                 for (kk in seq_along(NAMES)) {
[18:04:55.058]                   name <- removed[[kk]]
[18:04:55.058]                   NAME <- NAMES[[kk]]
[18:04:55.058]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.058]                     next
[18:04:55.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.058]                 }
[18:04:55.058]                 if (length(args) > 0) 
[18:04:55.058]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.058]             }
[18:04:55.058]             else {
[18:04:55.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.058]             }
[18:04:55.058]             {
[18:04:55.058]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.058]                   0L) {
[18:04:55.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.058]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.058]                   base::options(opts)
[18:04:55.058]                 }
[18:04:55.058]                 {
[18:04:55.058]                   {
[18:04:55.058]                     NULL
[18:04:55.058]                     RNGkind("Mersenne-Twister")
[18:04:55.058]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.058]                       inherits = FALSE)
[18:04:55.058]                   }
[18:04:55.058]                   options(future.plan = NULL)
[18:04:55.058]                   if (is.na(NA_character_)) 
[18:04:55.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.058]                     .init = FALSE)
[18:04:55.058]                 }
[18:04:55.058]             }
[18:04:55.058]         }
[18:04:55.058]     })
[18:04:55.058]     if (TRUE) {
[18:04:55.058]         base::sink(type = "output", split = FALSE)
[18:04:55.058]         if (TRUE) {
[18:04:55.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.058]         }
[18:04:55.058]         else {
[18:04:55.058]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.058]         }
[18:04:55.058]         base::close(...future.stdout)
[18:04:55.058]         ...future.stdout <- NULL
[18:04:55.058]     }
[18:04:55.058]     ...future.result$conditions <- ...future.conditions
[18:04:55.058]     ...future.result$finished <- base::Sys.time()
[18:04:55.058]     ...future.result
[18:04:55.058] }
[18:04:55.061] assign_globals() ...
[18:04:55.061] List of 1
[18:04:55.061]  $ ii: int 2
[18:04:55.061]  - attr(*, "where")=List of 1
[18:04:55.061]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.061]  - attr(*, "resolved")= logi TRUE
[18:04:55.061]  - attr(*, "total_size")= num 56
[18:04:55.061]  - attr(*, "already-done")= logi TRUE
[18:04:55.066] - copied ‘ii’ to environment
[18:04:55.066] assign_globals() ... done
[18:04:55.066] plan(): Setting new future strategy stack:
[18:04:55.067] List of future strategies:
[18:04:55.067] 1. sequential:
[18:04:55.067]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.067]    - tweaked: FALSE
[18:04:55.067]    - call: NULL
[18:04:55.068] plan(): nbrOfWorkers() = 1
[18:04:55.069] plan(): Setting new future strategy stack:
[18:04:55.069] List of future strategies:
[18:04:55.069] 1. sequential:
[18:04:55.069]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.069]    - tweaked: FALSE
[18:04:55.069]    - call: plan(strategy)
[18:04:55.070] plan(): nbrOfWorkers() = 1
[18:04:55.070] SequentialFuture started (and completed)
[18:04:55.071] - Launch lazy future ... done
[18:04:55.071] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.072] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.072] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.075] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.075] Searching for globals ... DONE
[18:04:55.075] Resolving globals: TRUE
[18:04:55.076] Resolving any globals that are futures ...
[18:04:55.076] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.076] Resolving any globals that are futures ... DONE
[18:04:55.077] Resolving futures part of globals (recursively) ...
[18:04:55.077] resolve() on list ...
[18:04:55.077]  recursive: 99
[18:04:55.077]  length: 1
[18:04:55.078]  elements: ‘ii’
[18:04:55.078]  length: 0 (resolved future 1)
[18:04:55.078] resolve() on list ... DONE
[18:04:55.078] - globals: [1] ‘ii’
[18:04:55.078] Resolving futures part of globals (recursively) ... DONE
[18:04:55.079] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:55.079] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.080] - globals: [1] ‘ii’
[18:04:55.080] 
[18:04:55.080] getGlobalsAndPackages() ... DONE
[18:04:55.080] run() for ‘Future’ ...
[18:04:55.081] - state: ‘created’
[18:04:55.081] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.081] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.082]   - Field: ‘label’
[18:04:55.082]   - Field: ‘local’
[18:04:55.082]   - Field: ‘owner’
[18:04:55.082]   - Field: ‘envir’
[18:04:55.083]   - Field: ‘packages’
[18:04:55.083]   - Field: ‘gc’
[18:04:55.083]   - Field: ‘conditions’
[18:04:55.083]   - Field: ‘expr’
[18:04:55.083]   - Field: ‘uuid’
[18:04:55.084]   - Field: ‘seed’
[18:04:55.084]   - Field: ‘version’
[18:04:55.084]   - Field: ‘result’
[18:04:55.084]   - Field: ‘asynchronous’
[18:04:55.084]   - Field: ‘calls’
[18:04:55.085]   - Field: ‘globals’
[18:04:55.085]   - Field: ‘stdout’
[18:04:55.085]   - Field: ‘earlySignal’
[18:04:55.085]   - Field: ‘lazy’
[18:04:55.085]   - Field: ‘state’
[18:04:55.085] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.086] - Launch lazy future ...
[18:04:55.086] Packages needed by the future expression (n = 0): <none>
[18:04:55.086] Packages needed by future strategies (n = 0): <none>
[18:04:55.087] {
[18:04:55.087]     {
[18:04:55.087]         {
[18:04:55.087]             ...future.startTime <- base::Sys.time()
[18:04:55.087]             {
[18:04:55.087]                 {
[18:04:55.087]                   {
[18:04:55.087]                     base::local({
[18:04:55.087]                       has_future <- base::requireNamespace("future", 
[18:04:55.087]                         quietly = TRUE)
[18:04:55.087]                       if (has_future) {
[18:04:55.087]                         ns <- base::getNamespace("future")
[18:04:55.087]                         version <- ns[[".package"]][["version"]]
[18:04:55.087]                         if (is.null(version)) 
[18:04:55.087]                           version <- utils::packageVersion("future")
[18:04:55.087]                       }
[18:04:55.087]                       else {
[18:04:55.087]                         version <- NULL
[18:04:55.087]                       }
[18:04:55.087]                       if (!has_future || version < "1.8.0") {
[18:04:55.087]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.087]                           "", base::R.version$version.string), 
[18:04:55.087]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.087]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.087]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.087]                             "release", "version")], collapse = " "), 
[18:04:55.087]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.087]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.087]                           info)
[18:04:55.087]                         info <- base::paste(info, collapse = "; ")
[18:04:55.087]                         if (!has_future) {
[18:04:55.087]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.087]                             info)
[18:04:55.087]                         }
[18:04:55.087]                         else {
[18:04:55.087]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.087]                             info, version)
[18:04:55.087]                         }
[18:04:55.087]                         base::stop(msg)
[18:04:55.087]                       }
[18:04:55.087]                     })
[18:04:55.087]                   }
[18:04:55.087]                   ...future.strategy.old <- future::plan("list")
[18:04:55.087]                   options(future.plan = NULL)
[18:04:55.087]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.087]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.087]                 }
[18:04:55.087]                 ...future.workdir <- getwd()
[18:04:55.087]             }
[18:04:55.087]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.087]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.087]         }
[18:04:55.087]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.087]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.087]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.087]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.087]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.087]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.087]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.087]             base::names(...future.oldOptions))
[18:04:55.087]     }
[18:04:55.087]     if (FALSE) {
[18:04:55.087]     }
[18:04:55.087]     else {
[18:04:55.087]         if (TRUE) {
[18:04:55.087]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.087]                 open = "w")
[18:04:55.087]         }
[18:04:55.087]         else {
[18:04:55.087]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.087]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.087]         }
[18:04:55.087]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.087]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.087]             base::sink(type = "output", split = FALSE)
[18:04:55.087]             base::close(...future.stdout)
[18:04:55.087]         }, add = TRUE)
[18:04:55.087]     }
[18:04:55.087]     ...future.frame <- base::sys.nframe()
[18:04:55.087]     ...future.conditions <- base::list()
[18:04:55.087]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.087]     if (FALSE) {
[18:04:55.087]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.087]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.087]     }
[18:04:55.087]     ...future.result <- base::tryCatch({
[18:04:55.087]         base::withCallingHandlers({
[18:04:55.087]             ...future.value <- base::withVisible(base::local({
[18:04:55.087]                 b <- a * ii
[18:04:55.087]                 a <- 0
[18:04:55.087]                 b
[18:04:55.087]             }))
[18:04:55.087]             future::FutureResult(value = ...future.value$value, 
[18:04:55.087]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.087]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.087]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.087]                     ...future.globalenv.names))
[18:04:55.087]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.087]         }, condition = base::local({
[18:04:55.087]             c <- base::c
[18:04:55.087]             inherits <- base::inherits
[18:04:55.087]             invokeRestart <- base::invokeRestart
[18:04:55.087]             length <- base::length
[18:04:55.087]             list <- base::list
[18:04:55.087]             seq.int <- base::seq.int
[18:04:55.087]             signalCondition <- base::signalCondition
[18:04:55.087]             sys.calls <- base::sys.calls
[18:04:55.087]             `[[` <- base::`[[`
[18:04:55.087]             `+` <- base::`+`
[18:04:55.087]             `<<-` <- base::`<<-`
[18:04:55.087]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.087]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.087]                   3L)]
[18:04:55.087]             }
[18:04:55.087]             function(cond) {
[18:04:55.087]                 is_error <- inherits(cond, "error")
[18:04:55.087]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.087]                   NULL)
[18:04:55.087]                 if (is_error) {
[18:04:55.087]                   sessionInformation <- function() {
[18:04:55.087]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.087]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.087]                       search = base::search(), system = base::Sys.info())
[18:04:55.087]                   }
[18:04:55.087]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.087]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.087]                     cond$call), session = sessionInformation(), 
[18:04:55.087]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.087]                   signalCondition(cond)
[18:04:55.087]                 }
[18:04:55.087]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.087]                 "immediateCondition"))) {
[18:04:55.087]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.087]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.087]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.087]                   if (TRUE && !signal) {
[18:04:55.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.087]                     {
[18:04:55.087]                       inherits <- base::inherits
[18:04:55.087]                       invokeRestart <- base::invokeRestart
[18:04:55.087]                       is.null <- base::is.null
[18:04:55.087]                       muffled <- FALSE
[18:04:55.087]                       if (inherits(cond, "message")) {
[18:04:55.087]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.087]                         if (muffled) 
[18:04:55.087]                           invokeRestart("muffleMessage")
[18:04:55.087]                       }
[18:04:55.087]                       else if (inherits(cond, "warning")) {
[18:04:55.087]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.087]                         if (muffled) 
[18:04:55.087]                           invokeRestart("muffleWarning")
[18:04:55.087]                       }
[18:04:55.087]                       else if (inherits(cond, "condition")) {
[18:04:55.087]                         if (!is.null(pattern)) {
[18:04:55.087]                           computeRestarts <- base::computeRestarts
[18:04:55.087]                           grepl <- base::grepl
[18:04:55.087]                           restarts <- computeRestarts(cond)
[18:04:55.087]                           for (restart in restarts) {
[18:04:55.087]                             name <- restart$name
[18:04:55.087]                             if (is.null(name)) 
[18:04:55.087]                               next
[18:04:55.087]                             if (!grepl(pattern, name)) 
[18:04:55.087]                               next
[18:04:55.087]                             invokeRestart(restart)
[18:04:55.087]                             muffled <- TRUE
[18:04:55.087]                             break
[18:04:55.087]                           }
[18:04:55.087]                         }
[18:04:55.087]                       }
[18:04:55.087]                       invisible(muffled)
[18:04:55.087]                     }
[18:04:55.087]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.087]                   }
[18:04:55.087]                 }
[18:04:55.087]                 else {
[18:04:55.087]                   if (TRUE) {
[18:04:55.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.087]                     {
[18:04:55.087]                       inherits <- base::inherits
[18:04:55.087]                       invokeRestart <- base::invokeRestart
[18:04:55.087]                       is.null <- base::is.null
[18:04:55.087]                       muffled <- FALSE
[18:04:55.087]                       if (inherits(cond, "message")) {
[18:04:55.087]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.087]                         if (muffled) 
[18:04:55.087]                           invokeRestart("muffleMessage")
[18:04:55.087]                       }
[18:04:55.087]                       else if (inherits(cond, "warning")) {
[18:04:55.087]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.087]                         if (muffled) 
[18:04:55.087]                           invokeRestart("muffleWarning")
[18:04:55.087]                       }
[18:04:55.087]                       else if (inherits(cond, "condition")) {
[18:04:55.087]                         if (!is.null(pattern)) {
[18:04:55.087]                           computeRestarts <- base::computeRestarts
[18:04:55.087]                           grepl <- base::grepl
[18:04:55.087]                           restarts <- computeRestarts(cond)
[18:04:55.087]                           for (restart in restarts) {
[18:04:55.087]                             name <- restart$name
[18:04:55.087]                             if (is.null(name)) 
[18:04:55.087]                               next
[18:04:55.087]                             if (!grepl(pattern, name)) 
[18:04:55.087]                               next
[18:04:55.087]                             invokeRestart(restart)
[18:04:55.087]                             muffled <- TRUE
[18:04:55.087]                             break
[18:04:55.087]                           }
[18:04:55.087]                         }
[18:04:55.087]                       }
[18:04:55.087]                       invisible(muffled)
[18:04:55.087]                     }
[18:04:55.087]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.087]                   }
[18:04:55.087]                 }
[18:04:55.087]             }
[18:04:55.087]         }))
[18:04:55.087]     }, error = function(ex) {
[18:04:55.087]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.087]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.087]                 ...future.rng), started = ...future.startTime, 
[18:04:55.087]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.087]             version = "1.8"), class = "FutureResult")
[18:04:55.087]     }, finally = {
[18:04:55.087]         if (!identical(...future.workdir, getwd())) 
[18:04:55.087]             setwd(...future.workdir)
[18:04:55.087]         {
[18:04:55.087]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.087]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.087]             }
[18:04:55.087]             base::options(...future.oldOptions)
[18:04:55.087]             if (.Platform$OS.type == "windows") {
[18:04:55.087]                 old_names <- names(...future.oldEnvVars)
[18:04:55.087]                 envs <- base::Sys.getenv()
[18:04:55.087]                 names <- names(envs)
[18:04:55.087]                 common <- intersect(names, old_names)
[18:04:55.087]                 added <- setdiff(names, old_names)
[18:04:55.087]                 removed <- setdiff(old_names, names)
[18:04:55.087]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.087]                   envs[common]]
[18:04:55.087]                 NAMES <- toupper(changed)
[18:04:55.087]                 args <- list()
[18:04:55.087]                 for (kk in seq_along(NAMES)) {
[18:04:55.087]                   name <- changed[[kk]]
[18:04:55.087]                   NAME <- NAMES[[kk]]
[18:04:55.087]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.087]                     next
[18:04:55.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.087]                 }
[18:04:55.087]                 NAMES <- toupper(added)
[18:04:55.087]                 for (kk in seq_along(NAMES)) {
[18:04:55.087]                   name <- added[[kk]]
[18:04:55.087]                   NAME <- NAMES[[kk]]
[18:04:55.087]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.087]                     next
[18:04:55.087]                   args[[name]] <- ""
[18:04:55.087]                 }
[18:04:55.087]                 NAMES <- toupper(removed)
[18:04:55.087]                 for (kk in seq_along(NAMES)) {
[18:04:55.087]                   name <- removed[[kk]]
[18:04:55.087]                   NAME <- NAMES[[kk]]
[18:04:55.087]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.087]                     next
[18:04:55.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.087]                 }
[18:04:55.087]                 if (length(args) > 0) 
[18:04:55.087]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.087]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.087]             }
[18:04:55.087]             else {
[18:04:55.087]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.087]             }
[18:04:55.087]             {
[18:04:55.087]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.087]                   0L) {
[18:04:55.087]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.087]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.087]                   base::options(opts)
[18:04:55.087]                 }
[18:04:55.087]                 {
[18:04:55.087]                   {
[18:04:55.087]                     NULL
[18:04:55.087]                     RNGkind("Mersenne-Twister")
[18:04:55.087]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.087]                       inherits = FALSE)
[18:04:55.087]                   }
[18:04:55.087]                   options(future.plan = NULL)
[18:04:55.087]                   if (is.na(NA_character_)) 
[18:04:55.087]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.087]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.087]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.087]                     .init = FALSE)
[18:04:55.087]                 }
[18:04:55.087]             }
[18:04:55.087]         }
[18:04:55.087]     })
[18:04:55.087]     if (TRUE) {
[18:04:55.087]         base::sink(type = "output", split = FALSE)
[18:04:55.087]         if (TRUE) {
[18:04:55.087]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.087]         }
[18:04:55.087]         else {
[18:04:55.087]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.087]         }
[18:04:55.087]         base::close(...future.stdout)
[18:04:55.087]         ...future.stdout <- NULL
[18:04:55.087]     }
[18:04:55.087]     ...future.result$conditions <- ...future.conditions
[18:04:55.087]     ...future.result$finished <- base::Sys.time()
[18:04:55.087]     ...future.result
[18:04:55.087] }
[18:04:55.090] assign_globals() ...
[18:04:55.090] List of 1
[18:04:55.090]  $ ii: int 3
[18:04:55.090]  - attr(*, "where")=List of 1
[18:04:55.090]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.090]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.090]  - attr(*, "resolved")= logi TRUE
[18:04:55.090]  - attr(*, "total_size")= num 56
[18:04:55.090]  - attr(*, "already-done")= logi TRUE
[18:04:55.098] - copied ‘ii’ to environment
[18:04:55.098] assign_globals() ... done
[18:04:55.098] plan(): Setting new future strategy stack:
[18:04:55.099] List of future strategies:
[18:04:55.099] 1. sequential:
[18:04:55.099]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.099]    - tweaked: FALSE
[18:04:55.099]    - call: NULL
[18:04:55.100] plan(): nbrOfWorkers() = 1
[18:04:55.101] plan(): Setting new future strategy stack:
[18:04:55.102] List of future strategies:
[18:04:55.102] 1. sequential:
[18:04:55.102]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.102]    - tweaked: FALSE
[18:04:55.102]    - call: plan(strategy)
[18:04:55.102] plan(): nbrOfWorkers() = 1
[18:04:55.103] SequentialFuture started (and completed)
[18:04:55.103] - Launch lazy future ... done
[18:04:55.103] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.105] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.106] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.108] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.109] Searching for globals ... DONE
[18:04:55.109] Resolving globals: TRUE
[18:04:55.109] Resolving any globals that are futures ...
[18:04:55.109] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.110] Resolving any globals that are futures ... DONE
[18:04:55.110] Resolving futures part of globals (recursively) ...
[18:04:55.111] resolve() on list ...
[18:04:55.111]  recursive: 99
[18:04:55.111]  length: 1
[18:04:55.112]  elements: ‘ii’
[18:04:55.112]  length: 0 (resolved future 1)
[18:04:55.112] resolve() on list ... DONE
[18:04:55.112] - globals: [1] ‘ii’
[18:04:55.113] Resolving futures part of globals (recursively) ... DONE
[18:04:55.113] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:55.114] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.114] - globals: [1] ‘ii’
[18:04:55.114] 
[18:04:55.114] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.116] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.116] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.119] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.119] Searching for globals ... DONE
[18:04:55.120] Resolving globals: TRUE
[18:04:55.120] Resolving any globals that are futures ...
[18:04:55.120] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.120] Resolving any globals that are futures ... DONE
[18:04:55.121] Resolving futures part of globals (recursively) ...
[18:04:55.122] resolve() on list ...
[18:04:55.122]  recursive: 99
[18:04:55.122]  length: 1
[18:04:55.122]  elements: ‘ii’
[18:04:55.122]  length: 0 (resolved future 1)
[18:04:55.123] resolve() on list ... DONE
[18:04:55.123] - globals: [1] ‘ii’
[18:04:55.123] Resolving futures part of globals (recursively) ... DONE
[18:04:55.123] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:55.124] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.124] - globals: [1] ‘ii’
[18:04:55.125] 
[18:04:55.125] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.126] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.127] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.129] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.130] Searching for globals ... DONE
[18:04:55.130] Resolving globals: TRUE
[18:04:55.130] Resolving any globals that are futures ...
[18:04:55.130] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:55.131] Resolving any globals that are futures ... DONE
[18:04:55.131] Resolving futures part of globals (recursively) ...
[18:04:55.132] resolve() on list ...
[18:04:55.132]  recursive: 99
[18:04:55.132]  length: 1
[18:04:55.133]  elements: ‘ii’
[18:04:55.133]  length: 0 (resolved future 1)
[18:04:55.133] resolve() on list ... DONE
[18:04:55.133] - globals: [1] ‘ii’
[18:04:55.134] Resolving futures part of globals (recursively) ... DONE
[18:04:55.134] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:55.135] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.135] - globals: [1] ‘ii’
[18:04:55.135] 
[18:04:55.135] getGlobalsAndPackages() ... DONE
[18:04:55.136] run() for ‘Future’ ...
[18:04:55.136] - state: ‘created’
[18:04:55.136] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.137] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.138]   - Field: ‘label’
[18:04:55.139]   - Field: ‘local’
[18:04:55.139]   - Field: ‘owner’
[18:04:55.139]   - Field: ‘envir’
[18:04:55.140]   - Field: ‘packages’
[18:04:55.140]   - Field: ‘gc’
[18:04:55.140]   - Field: ‘conditions’
[18:04:55.141]   - Field: ‘expr’
[18:04:55.141]   - Field: ‘uuid’
[18:04:55.141]   - Field: ‘seed’
[18:04:55.141]   - Field: ‘version’
[18:04:55.141]   - Field: ‘result’
[18:04:55.142]   - Field: ‘asynchronous’
[18:04:55.142]   - Field: ‘calls’
[18:04:55.142]   - Field: ‘globals’
[18:04:55.142]   - Field: ‘stdout’
[18:04:55.142]   - Field: ‘earlySignal’
[18:04:55.143]   - Field: ‘lazy’
[18:04:55.143]   - Field: ‘state’
[18:04:55.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.143] - Launch lazy future ...
[18:04:55.144] Packages needed by the future expression (n = 0): <none>
[18:04:55.144] Packages needed by future strategies (n = 0): <none>
[18:04:55.145] {
[18:04:55.145]     {
[18:04:55.145]         {
[18:04:55.145]             ...future.startTime <- base::Sys.time()
[18:04:55.145]             {
[18:04:55.145]                 {
[18:04:55.145]                   {
[18:04:55.145]                     base::local({
[18:04:55.145]                       has_future <- base::requireNamespace("future", 
[18:04:55.145]                         quietly = TRUE)
[18:04:55.145]                       if (has_future) {
[18:04:55.145]                         ns <- base::getNamespace("future")
[18:04:55.145]                         version <- ns[[".package"]][["version"]]
[18:04:55.145]                         if (is.null(version)) 
[18:04:55.145]                           version <- utils::packageVersion("future")
[18:04:55.145]                       }
[18:04:55.145]                       else {
[18:04:55.145]                         version <- NULL
[18:04:55.145]                       }
[18:04:55.145]                       if (!has_future || version < "1.8.0") {
[18:04:55.145]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.145]                           "", base::R.version$version.string), 
[18:04:55.145]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.145]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.145]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.145]                             "release", "version")], collapse = " "), 
[18:04:55.145]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.145]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.145]                           info)
[18:04:55.145]                         info <- base::paste(info, collapse = "; ")
[18:04:55.145]                         if (!has_future) {
[18:04:55.145]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.145]                             info)
[18:04:55.145]                         }
[18:04:55.145]                         else {
[18:04:55.145]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.145]                             info, version)
[18:04:55.145]                         }
[18:04:55.145]                         base::stop(msg)
[18:04:55.145]                       }
[18:04:55.145]                     })
[18:04:55.145]                   }
[18:04:55.145]                   ...future.strategy.old <- future::plan("list")
[18:04:55.145]                   options(future.plan = NULL)
[18:04:55.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.145]                 }
[18:04:55.145]                 ...future.workdir <- getwd()
[18:04:55.145]             }
[18:04:55.145]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.145]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.145]         }
[18:04:55.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.145]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.145]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.145]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.145]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.145]             base::names(...future.oldOptions))
[18:04:55.145]     }
[18:04:55.145]     if (FALSE) {
[18:04:55.145]     }
[18:04:55.145]     else {
[18:04:55.145]         if (TRUE) {
[18:04:55.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.145]                 open = "w")
[18:04:55.145]         }
[18:04:55.145]         else {
[18:04:55.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.145]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.145]         }
[18:04:55.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.145]             base::sink(type = "output", split = FALSE)
[18:04:55.145]             base::close(...future.stdout)
[18:04:55.145]         }, add = TRUE)
[18:04:55.145]     }
[18:04:55.145]     ...future.frame <- base::sys.nframe()
[18:04:55.145]     ...future.conditions <- base::list()
[18:04:55.145]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.145]     if (FALSE) {
[18:04:55.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.145]     }
[18:04:55.145]     ...future.result <- base::tryCatch({
[18:04:55.145]         base::withCallingHandlers({
[18:04:55.145]             ...future.value <- base::withVisible(base::local({
[18:04:55.145]                 b <- a * ii
[18:04:55.145]                 a <- 0
[18:04:55.145]                 b
[18:04:55.145]             }))
[18:04:55.145]             future::FutureResult(value = ...future.value$value, 
[18:04:55.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.145]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.145]                     ...future.globalenv.names))
[18:04:55.145]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.145]         }, condition = base::local({
[18:04:55.145]             c <- base::c
[18:04:55.145]             inherits <- base::inherits
[18:04:55.145]             invokeRestart <- base::invokeRestart
[18:04:55.145]             length <- base::length
[18:04:55.145]             list <- base::list
[18:04:55.145]             seq.int <- base::seq.int
[18:04:55.145]             signalCondition <- base::signalCondition
[18:04:55.145]             sys.calls <- base::sys.calls
[18:04:55.145]             `[[` <- base::`[[`
[18:04:55.145]             `+` <- base::`+`
[18:04:55.145]             `<<-` <- base::`<<-`
[18:04:55.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.145]                   3L)]
[18:04:55.145]             }
[18:04:55.145]             function(cond) {
[18:04:55.145]                 is_error <- inherits(cond, "error")
[18:04:55.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.145]                   NULL)
[18:04:55.145]                 if (is_error) {
[18:04:55.145]                   sessionInformation <- function() {
[18:04:55.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.145]                       search = base::search(), system = base::Sys.info())
[18:04:55.145]                   }
[18:04:55.145]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.145]                     cond$call), session = sessionInformation(), 
[18:04:55.145]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.145]                   signalCondition(cond)
[18:04:55.145]                 }
[18:04:55.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.145]                 "immediateCondition"))) {
[18:04:55.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.145]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.145]                   if (TRUE && !signal) {
[18:04:55.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.145]                     {
[18:04:55.145]                       inherits <- base::inherits
[18:04:55.145]                       invokeRestart <- base::invokeRestart
[18:04:55.145]                       is.null <- base::is.null
[18:04:55.145]                       muffled <- FALSE
[18:04:55.145]                       if (inherits(cond, "message")) {
[18:04:55.145]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.145]                         if (muffled) 
[18:04:55.145]                           invokeRestart("muffleMessage")
[18:04:55.145]                       }
[18:04:55.145]                       else if (inherits(cond, "warning")) {
[18:04:55.145]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.145]                         if (muffled) 
[18:04:55.145]                           invokeRestart("muffleWarning")
[18:04:55.145]                       }
[18:04:55.145]                       else if (inherits(cond, "condition")) {
[18:04:55.145]                         if (!is.null(pattern)) {
[18:04:55.145]                           computeRestarts <- base::computeRestarts
[18:04:55.145]                           grepl <- base::grepl
[18:04:55.145]                           restarts <- computeRestarts(cond)
[18:04:55.145]                           for (restart in restarts) {
[18:04:55.145]                             name <- restart$name
[18:04:55.145]                             if (is.null(name)) 
[18:04:55.145]                               next
[18:04:55.145]                             if (!grepl(pattern, name)) 
[18:04:55.145]                               next
[18:04:55.145]                             invokeRestart(restart)
[18:04:55.145]                             muffled <- TRUE
[18:04:55.145]                             break
[18:04:55.145]                           }
[18:04:55.145]                         }
[18:04:55.145]                       }
[18:04:55.145]                       invisible(muffled)
[18:04:55.145]                     }
[18:04:55.145]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.145]                   }
[18:04:55.145]                 }
[18:04:55.145]                 else {
[18:04:55.145]                   if (TRUE) {
[18:04:55.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.145]                     {
[18:04:55.145]                       inherits <- base::inherits
[18:04:55.145]                       invokeRestart <- base::invokeRestart
[18:04:55.145]                       is.null <- base::is.null
[18:04:55.145]                       muffled <- FALSE
[18:04:55.145]                       if (inherits(cond, "message")) {
[18:04:55.145]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.145]                         if (muffled) 
[18:04:55.145]                           invokeRestart("muffleMessage")
[18:04:55.145]                       }
[18:04:55.145]                       else if (inherits(cond, "warning")) {
[18:04:55.145]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.145]                         if (muffled) 
[18:04:55.145]                           invokeRestart("muffleWarning")
[18:04:55.145]                       }
[18:04:55.145]                       else if (inherits(cond, "condition")) {
[18:04:55.145]                         if (!is.null(pattern)) {
[18:04:55.145]                           computeRestarts <- base::computeRestarts
[18:04:55.145]                           grepl <- base::grepl
[18:04:55.145]                           restarts <- computeRestarts(cond)
[18:04:55.145]                           for (restart in restarts) {
[18:04:55.145]                             name <- restart$name
[18:04:55.145]                             if (is.null(name)) 
[18:04:55.145]                               next
[18:04:55.145]                             if (!grepl(pattern, name)) 
[18:04:55.145]                               next
[18:04:55.145]                             invokeRestart(restart)
[18:04:55.145]                             muffled <- TRUE
[18:04:55.145]                             break
[18:04:55.145]                           }
[18:04:55.145]                         }
[18:04:55.145]                       }
[18:04:55.145]                       invisible(muffled)
[18:04:55.145]                     }
[18:04:55.145]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.145]                   }
[18:04:55.145]                 }
[18:04:55.145]             }
[18:04:55.145]         }))
[18:04:55.145]     }, error = function(ex) {
[18:04:55.145]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.145]                 ...future.rng), started = ...future.startTime, 
[18:04:55.145]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.145]             version = "1.8"), class = "FutureResult")
[18:04:55.145]     }, finally = {
[18:04:55.145]         if (!identical(...future.workdir, getwd())) 
[18:04:55.145]             setwd(...future.workdir)
[18:04:55.145]         {
[18:04:55.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.145]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.145]             }
[18:04:55.145]             base::options(...future.oldOptions)
[18:04:55.145]             if (.Platform$OS.type == "windows") {
[18:04:55.145]                 old_names <- names(...future.oldEnvVars)
[18:04:55.145]                 envs <- base::Sys.getenv()
[18:04:55.145]                 names <- names(envs)
[18:04:55.145]                 common <- intersect(names, old_names)
[18:04:55.145]                 added <- setdiff(names, old_names)
[18:04:55.145]                 removed <- setdiff(old_names, names)
[18:04:55.145]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.145]                   envs[common]]
[18:04:55.145]                 NAMES <- toupper(changed)
[18:04:55.145]                 args <- list()
[18:04:55.145]                 for (kk in seq_along(NAMES)) {
[18:04:55.145]                   name <- changed[[kk]]
[18:04:55.145]                   NAME <- NAMES[[kk]]
[18:04:55.145]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.145]                     next
[18:04:55.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.145]                 }
[18:04:55.145]                 NAMES <- toupper(added)
[18:04:55.145]                 for (kk in seq_along(NAMES)) {
[18:04:55.145]                   name <- added[[kk]]
[18:04:55.145]                   NAME <- NAMES[[kk]]
[18:04:55.145]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.145]                     next
[18:04:55.145]                   args[[name]] <- ""
[18:04:55.145]                 }
[18:04:55.145]                 NAMES <- toupper(removed)
[18:04:55.145]                 for (kk in seq_along(NAMES)) {
[18:04:55.145]                   name <- removed[[kk]]
[18:04:55.145]                   NAME <- NAMES[[kk]]
[18:04:55.145]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.145]                     next
[18:04:55.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.145]                 }
[18:04:55.145]                 if (length(args) > 0) 
[18:04:55.145]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.145]             }
[18:04:55.145]             else {
[18:04:55.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.145]             }
[18:04:55.145]             {
[18:04:55.145]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.145]                   0L) {
[18:04:55.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.145]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.145]                   base::options(opts)
[18:04:55.145]                 }
[18:04:55.145]                 {
[18:04:55.145]                   {
[18:04:55.145]                     NULL
[18:04:55.145]                     RNGkind("Mersenne-Twister")
[18:04:55.145]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.145]                       inherits = FALSE)
[18:04:55.145]                   }
[18:04:55.145]                   options(future.plan = NULL)
[18:04:55.145]                   if (is.na(NA_character_)) 
[18:04:55.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.145]                     .init = FALSE)
[18:04:55.145]                 }
[18:04:55.145]             }
[18:04:55.145]         }
[18:04:55.145]     })
[18:04:55.145]     if (TRUE) {
[18:04:55.145]         base::sink(type = "output", split = FALSE)
[18:04:55.145]         if (TRUE) {
[18:04:55.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.145]         }
[18:04:55.145]         else {
[18:04:55.145]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.145]         }
[18:04:55.145]         base::close(...future.stdout)
[18:04:55.145]         ...future.stdout <- NULL
[18:04:55.145]     }
[18:04:55.145]     ...future.result$conditions <- ...future.conditions
[18:04:55.145]     ...future.result$finished <- base::Sys.time()
[18:04:55.145]     ...future.result
[18:04:55.145] }
[18:04:55.148] assign_globals() ...
[18:04:55.148] List of 1
[18:04:55.148]  $ ii: int 1
[18:04:55.148]  - attr(*, "where")=List of 1
[18:04:55.148]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.148]  - attr(*, "resolved")= logi TRUE
[18:04:55.148]  - attr(*, "total_size")= num 56
[18:04:55.148]  - attr(*, "already-done")= logi TRUE
[18:04:55.154] - copied ‘ii’ to environment
[18:04:55.154] assign_globals() ... done
[18:04:55.155] plan(): Setting new future strategy stack:
[18:04:55.155] List of future strategies:
[18:04:55.155] 1. sequential:
[18:04:55.155]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.155]    - tweaked: FALSE
[18:04:55.155]    - call: NULL
[18:04:55.156] plan(): nbrOfWorkers() = 1
[18:04:55.161] plan(): Setting new future strategy stack:
[18:04:55.161] List of future strategies:
[18:04:55.161] 1. sequential:
[18:04:55.161]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.161]    - tweaked: FALSE
[18:04:55.161]    - call: plan(strategy)
[18:04:55.162] plan(): nbrOfWorkers() = 1
[18:04:55.163] SequentialFuture started (and completed)
[18:04:55.163] signalConditions() ...
[18:04:55.163]  - include = ‘immediateCondition’
[18:04:55.163]  - exclude = 
[18:04:55.164]  - resignal = FALSE
[18:04:55.164]  - Number of conditions: 1
[18:04:55.164] signalConditions() ... done
[18:04:55.164] - Launch lazy future ... done
[18:04:55.164] run() for ‘SequentialFuture’ ... done
[18:04:55.165] signalConditions() ...
[18:04:55.165]  - include = ‘immediateCondition’
[18:04:55.165]  - exclude = 
[18:04:55.165]  - resignal = FALSE
[18:04:55.165]  - Number of conditions: 1
[18:04:55.166] signalConditions() ... done
[18:04:55.166] Future state: ‘finished’
[18:04:55.166] signalConditions() ...
[18:04:55.166]  - include = ‘condition’
[18:04:55.167]  - exclude = ‘immediateCondition’
[18:04:55.167]  - resignal = TRUE
[18:04:55.167]  - Number of conditions: 1
[18:04:55.167]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:55.167] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.8.0-48-generic" "#48-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 14:04:52 UTC 2024" "99adafdbb12a" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-21 18:04:55"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.197] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.197] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.199] 
[18:04:55.199] Searching for globals ... DONE
[18:04:55.199] - globals: [0] <none>
[18:04:55.199] getGlobalsAndPackages() ... DONE
[18:04:55.200] run() for ‘Future’ ...
[18:04:55.200] - state: ‘created’
[18:04:55.200] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.201]   - Field: ‘label’
[18:04:55.202]   - Field: ‘local’
[18:04:55.202]   - Field: ‘owner’
[18:04:55.202]   - Field: ‘envir’
[18:04:55.202]   - Field: ‘packages’
[18:04:55.202]   - Field: ‘gc’
[18:04:55.203]   - Field: ‘conditions’
[18:04:55.203]   - Field: ‘expr’
[18:04:55.203]   - Field: ‘uuid’
[18:04:55.203]   - Field: ‘seed’
[18:04:55.203]   - Field: ‘version’
[18:04:55.204]   - Field: ‘result’
[18:04:55.204]   - Field: ‘asynchronous’
[18:04:55.204]   - Field: ‘calls’
[18:04:55.204]   - Field: ‘globals’
[18:04:55.204]   - Field: ‘stdout’
[18:04:55.205]   - Field: ‘earlySignal’
[18:04:55.205]   - Field: ‘lazy’
[18:04:55.205]   - Field: ‘state’
[18:04:55.205] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.205] - Launch lazy future ...
[18:04:55.206] Packages needed by the future expression (n = 0): <none>
[18:04:55.206] Packages needed by future strategies (n = 0): <none>
[18:04:55.207] {
[18:04:55.207]     {
[18:04:55.207]         {
[18:04:55.207]             ...future.startTime <- base::Sys.time()
[18:04:55.207]             {
[18:04:55.207]                 {
[18:04:55.207]                   {
[18:04:55.207]                     base::local({
[18:04:55.207]                       has_future <- base::requireNamespace("future", 
[18:04:55.207]                         quietly = TRUE)
[18:04:55.207]                       if (has_future) {
[18:04:55.207]                         ns <- base::getNamespace("future")
[18:04:55.207]                         version <- ns[[".package"]][["version"]]
[18:04:55.207]                         if (is.null(version)) 
[18:04:55.207]                           version <- utils::packageVersion("future")
[18:04:55.207]                       }
[18:04:55.207]                       else {
[18:04:55.207]                         version <- NULL
[18:04:55.207]                       }
[18:04:55.207]                       if (!has_future || version < "1.8.0") {
[18:04:55.207]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.207]                           "", base::R.version$version.string), 
[18:04:55.207]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.207]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.207]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.207]                             "release", "version")], collapse = " "), 
[18:04:55.207]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.207]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.207]                           info)
[18:04:55.207]                         info <- base::paste(info, collapse = "; ")
[18:04:55.207]                         if (!has_future) {
[18:04:55.207]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.207]                             info)
[18:04:55.207]                         }
[18:04:55.207]                         else {
[18:04:55.207]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.207]                             info, version)
[18:04:55.207]                         }
[18:04:55.207]                         base::stop(msg)
[18:04:55.207]                       }
[18:04:55.207]                     })
[18:04:55.207]                   }
[18:04:55.207]                   ...future.strategy.old <- future::plan("list")
[18:04:55.207]                   options(future.plan = NULL)
[18:04:55.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.207]                 }
[18:04:55.207]                 ...future.workdir <- getwd()
[18:04:55.207]             }
[18:04:55.207]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.207]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.207]         }
[18:04:55.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.207]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.207]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.207]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.207]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.207]             base::names(...future.oldOptions))
[18:04:55.207]     }
[18:04:55.207]     if (FALSE) {
[18:04:55.207]     }
[18:04:55.207]     else {
[18:04:55.207]         if (TRUE) {
[18:04:55.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.207]                 open = "w")
[18:04:55.207]         }
[18:04:55.207]         else {
[18:04:55.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.207]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.207]         }
[18:04:55.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.207]             base::sink(type = "output", split = FALSE)
[18:04:55.207]             base::close(...future.stdout)
[18:04:55.207]         }, add = TRUE)
[18:04:55.207]     }
[18:04:55.207]     ...future.frame <- base::sys.nframe()
[18:04:55.207]     ...future.conditions <- base::list()
[18:04:55.207]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.207]     if (FALSE) {
[18:04:55.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.207]     }
[18:04:55.207]     ...future.result <- base::tryCatch({
[18:04:55.207]         base::withCallingHandlers({
[18:04:55.207]             ...future.value <- base::withVisible(base::local(1))
[18:04:55.207]             future::FutureResult(value = ...future.value$value, 
[18:04:55.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.207]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.207]                     ...future.globalenv.names))
[18:04:55.207]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.207]         }, condition = base::local({
[18:04:55.207]             c <- base::c
[18:04:55.207]             inherits <- base::inherits
[18:04:55.207]             invokeRestart <- base::invokeRestart
[18:04:55.207]             length <- base::length
[18:04:55.207]             list <- base::list
[18:04:55.207]             seq.int <- base::seq.int
[18:04:55.207]             signalCondition <- base::signalCondition
[18:04:55.207]             sys.calls <- base::sys.calls
[18:04:55.207]             `[[` <- base::`[[`
[18:04:55.207]             `+` <- base::`+`
[18:04:55.207]             `<<-` <- base::`<<-`
[18:04:55.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.207]                   3L)]
[18:04:55.207]             }
[18:04:55.207]             function(cond) {
[18:04:55.207]                 is_error <- inherits(cond, "error")
[18:04:55.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.207]                   NULL)
[18:04:55.207]                 if (is_error) {
[18:04:55.207]                   sessionInformation <- function() {
[18:04:55.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.207]                       search = base::search(), system = base::Sys.info())
[18:04:55.207]                   }
[18:04:55.207]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.207]                     cond$call), session = sessionInformation(), 
[18:04:55.207]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.207]                   signalCondition(cond)
[18:04:55.207]                 }
[18:04:55.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.207]                 "immediateCondition"))) {
[18:04:55.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.207]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.207]                   if (TRUE && !signal) {
[18:04:55.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.207]                     {
[18:04:55.207]                       inherits <- base::inherits
[18:04:55.207]                       invokeRestart <- base::invokeRestart
[18:04:55.207]                       is.null <- base::is.null
[18:04:55.207]                       muffled <- FALSE
[18:04:55.207]                       if (inherits(cond, "message")) {
[18:04:55.207]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.207]                         if (muffled) 
[18:04:55.207]                           invokeRestart("muffleMessage")
[18:04:55.207]                       }
[18:04:55.207]                       else if (inherits(cond, "warning")) {
[18:04:55.207]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.207]                         if (muffled) 
[18:04:55.207]                           invokeRestart("muffleWarning")
[18:04:55.207]                       }
[18:04:55.207]                       else if (inherits(cond, "condition")) {
[18:04:55.207]                         if (!is.null(pattern)) {
[18:04:55.207]                           computeRestarts <- base::computeRestarts
[18:04:55.207]                           grepl <- base::grepl
[18:04:55.207]                           restarts <- computeRestarts(cond)
[18:04:55.207]                           for (restart in restarts) {
[18:04:55.207]                             name <- restart$name
[18:04:55.207]                             if (is.null(name)) 
[18:04:55.207]                               next
[18:04:55.207]                             if (!grepl(pattern, name)) 
[18:04:55.207]                               next
[18:04:55.207]                             invokeRestart(restart)
[18:04:55.207]                             muffled <- TRUE
[18:04:55.207]                             break
[18:04:55.207]                           }
[18:04:55.207]                         }
[18:04:55.207]                       }
[18:04:55.207]                       invisible(muffled)
[18:04:55.207]                     }
[18:04:55.207]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.207]                   }
[18:04:55.207]                 }
[18:04:55.207]                 else {
[18:04:55.207]                   if (TRUE) {
[18:04:55.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.207]                     {
[18:04:55.207]                       inherits <- base::inherits
[18:04:55.207]                       invokeRestart <- base::invokeRestart
[18:04:55.207]                       is.null <- base::is.null
[18:04:55.207]                       muffled <- FALSE
[18:04:55.207]                       if (inherits(cond, "message")) {
[18:04:55.207]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.207]                         if (muffled) 
[18:04:55.207]                           invokeRestart("muffleMessage")
[18:04:55.207]                       }
[18:04:55.207]                       else if (inherits(cond, "warning")) {
[18:04:55.207]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.207]                         if (muffled) 
[18:04:55.207]                           invokeRestart("muffleWarning")
[18:04:55.207]                       }
[18:04:55.207]                       else if (inherits(cond, "condition")) {
[18:04:55.207]                         if (!is.null(pattern)) {
[18:04:55.207]                           computeRestarts <- base::computeRestarts
[18:04:55.207]                           grepl <- base::grepl
[18:04:55.207]                           restarts <- computeRestarts(cond)
[18:04:55.207]                           for (restart in restarts) {
[18:04:55.207]                             name <- restart$name
[18:04:55.207]                             if (is.null(name)) 
[18:04:55.207]                               next
[18:04:55.207]                             if (!grepl(pattern, name)) 
[18:04:55.207]                               next
[18:04:55.207]                             invokeRestart(restart)
[18:04:55.207]                             muffled <- TRUE
[18:04:55.207]                             break
[18:04:55.207]                           }
[18:04:55.207]                         }
[18:04:55.207]                       }
[18:04:55.207]                       invisible(muffled)
[18:04:55.207]                     }
[18:04:55.207]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.207]                   }
[18:04:55.207]                 }
[18:04:55.207]             }
[18:04:55.207]         }))
[18:04:55.207]     }, error = function(ex) {
[18:04:55.207]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.207]                 ...future.rng), started = ...future.startTime, 
[18:04:55.207]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.207]             version = "1.8"), class = "FutureResult")
[18:04:55.207]     }, finally = {
[18:04:55.207]         if (!identical(...future.workdir, getwd())) 
[18:04:55.207]             setwd(...future.workdir)
[18:04:55.207]         {
[18:04:55.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.207]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.207]             }
[18:04:55.207]             base::options(...future.oldOptions)
[18:04:55.207]             if (.Platform$OS.type == "windows") {
[18:04:55.207]                 old_names <- names(...future.oldEnvVars)
[18:04:55.207]                 envs <- base::Sys.getenv()
[18:04:55.207]                 names <- names(envs)
[18:04:55.207]                 common <- intersect(names, old_names)
[18:04:55.207]                 added <- setdiff(names, old_names)
[18:04:55.207]                 removed <- setdiff(old_names, names)
[18:04:55.207]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.207]                   envs[common]]
[18:04:55.207]                 NAMES <- toupper(changed)
[18:04:55.207]                 args <- list()
[18:04:55.207]                 for (kk in seq_along(NAMES)) {
[18:04:55.207]                   name <- changed[[kk]]
[18:04:55.207]                   NAME <- NAMES[[kk]]
[18:04:55.207]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.207]                     next
[18:04:55.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.207]                 }
[18:04:55.207]                 NAMES <- toupper(added)
[18:04:55.207]                 for (kk in seq_along(NAMES)) {
[18:04:55.207]                   name <- added[[kk]]
[18:04:55.207]                   NAME <- NAMES[[kk]]
[18:04:55.207]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.207]                     next
[18:04:55.207]                   args[[name]] <- ""
[18:04:55.207]                 }
[18:04:55.207]                 NAMES <- toupper(removed)
[18:04:55.207]                 for (kk in seq_along(NAMES)) {
[18:04:55.207]                   name <- removed[[kk]]
[18:04:55.207]                   NAME <- NAMES[[kk]]
[18:04:55.207]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.207]                     next
[18:04:55.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.207]                 }
[18:04:55.207]                 if (length(args) > 0) 
[18:04:55.207]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.207]             }
[18:04:55.207]             else {
[18:04:55.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.207]             }
[18:04:55.207]             {
[18:04:55.207]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.207]                   0L) {
[18:04:55.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.207]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.207]                   base::options(opts)
[18:04:55.207]                 }
[18:04:55.207]                 {
[18:04:55.207]                   {
[18:04:55.207]                     NULL
[18:04:55.207]                     RNGkind("Mersenne-Twister")
[18:04:55.207]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.207]                       inherits = FALSE)
[18:04:55.207]                   }
[18:04:55.207]                   options(future.plan = NULL)
[18:04:55.207]                   if (is.na(NA_character_)) 
[18:04:55.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.207]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.207]                     .init = FALSE)
[18:04:55.207]                 }
[18:04:55.207]             }
[18:04:55.207]         }
[18:04:55.207]     })
[18:04:55.207]     if (TRUE) {
[18:04:55.207]         base::sink(type = "output", split = FALSE)
[18:04:55.207]         if (TRUE) {
[18:04:55.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.207]         }
[18:04:55.207]         else {
[18:04:55.207]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.207]         }
[18:04:55.207]         base::close(...future.stdout)
[18:04:55.207]         ...future.stdout <- NULL
[18:04:55.207]     }
[18:04:55.207]     ...future.result$conditions <- ...future.conditions
[18:04:55.207]     ...future.result$finished <- base::Sys.time()
[18:04:55.207]     ...future.result
[18:04:55.207] }
[18:04:55.211] plan(): Setting new future strategy stack:
[18:04:55.211] List of future strategies:
[18:04:55.211] 1. sequential:
[18:04:55.211]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.211]    - tweaked: FALSE
[18:04:55.211]    - call: NULL
[18:04:55.212] plan(): nbrOfWorkers() = 1
[18:04:55.214] plan(): Setting new future strategy stack:
[18:04:55.214] List of future strategies:
[18:04:55.214] 1. sequential:
[18:04:55.214]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.214]    - tweaked: FALSE
[18:04:55.214]    - call: plan(strategy)
[18:04:55.215] plan(): nbrOfWorkers() = 1
[18:04:55.215] SequentialFuture started (and completed)
[18:04:55.216] - Launch lazy future ... done
[18:04:55.216] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.216] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.217] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.221] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:55.221] Searching for globals ... DONE
[18:04:55.222] Resolving globals: TRUE
[18:04:55.222] Resolving any globals that are futures ...
[18:04:55.222] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:55.222] Resolving any globals that are futures ... DONE
[18:04:55.223] Resolving futures part of globals (recursively) ...
[18:04:55.224] resolve() on list ...
[18:04:55.224]  recursive: 99
[18:04:55.224]  length: 1
[18:04:55.224]  elements: ‘a’
[18:04:55.225] resolved() for ‘SequentialFuture’ ...
[18:04:55.225] - state: ‘finished’
[18:04:55.225] - run: TRUE
[18:04:55.225] - result: ‘FutureResult’
[18:04:55.226] resolved() for ‘SequentialFuture’ ... done
[18:04:55.226] Future #1
[18:04:55.226] resolved() for ‘SequentialFuture’ ...
[18:04:55.227] - state: ‘finished’
[18:04:55.227] - run: TRUE
[18:04:55.227] - result: ‘FutureResult’
[18:04:55.227] resolved() for ‘SequentialFuture’ ... done
[18:04:55.227] A SequentialFuture was resolved
[18:04:55.228]  length: 0 (resolved future 1)
[18:04:55.228] resolve() on list ... DONE
[18:04:55.228] - globals: [1] ‘a’
[18:04:55.228] Resolving futures part of globals (recursively) ... DONE
[18:04:55.230] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[18:04:55.231] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[18:04:55.231] - globals: [1] ‘a’
[18:04:55.231] - packages: [1] ‘future’
[18:04:55.232] getGlobalsAndPackages() ... DONE
[18:04:55.232] run() for ‘Future’ ...
[18:04:55.232] - state: ‘created’
[18:04:55.233] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.233] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.234]   - Field: ‘label’
[18:04:55.234]   - Field: ‘local’
[18:04:55.234]   - Field: ‘owner’
[18:04:55.234]   - Field: ‘envir’
[18:04:55.235]   - Field: ‘packages’
[18:04:55.235]   - Field: ‘gc’
[18:04:55.235]   - Field: ‘conditions’
[18:04:55.235]   - Field: ‘expr’
[18:04:55.235]   - Field: ‘uuid’
[18:04:55.236]   - Field: ‘seed’
[18:04:55.236]   - Field: ‘version’
[18:04:55.236]   - Field: ‘result’
[18:04:55.236]   - Field: ‘asynchronous’
[18:04:55.236]   - Field: ‘calls’
[18:04:55.237]   - Field: ‘globals’
[18:04:55.237]   - Field: ‘stdout’
[18:04:55.237]   - Field: ‘earlySignal’
[18:04:55.237]   - Field: ‘lazy’
[18:04:55.237]   - Field: ‘state’
[18:04:55.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.238] - Launch lazy future ...
[18:04:55.238] Packages needed by the future expression (n = 1): ‘future’
[18:04:55.238] Packages needed by future strategies (n = 0): <none>
[18:04:55.239] {
[18:04:55.239]     {
[18:04:55.239]         {
[18:04:55.239]             ...future.startTime <- base::Sys.time()
[18:04:55.239]             {
[18:04:55.239]                 {
[18:04:55.239]                   {
[18:04:55.239]                     {
[18:04:55.239]                       base::local({
[18:04:55.239]                         has_future <- base::requireNamespace("future", 
[18:04:55.239]                           quietly = TRUE)
[18:04:55.239]                         if (has_future) {
[18:04:55.239]                           ns <- base::getNamespace("future")
[18:04:55.239]                           version <- ns[[".package"]][["version"]]
[18:04:55.239]                           if (is.null(version)) 
[18:04:55.239]                             version <- utils::packageVersion("future")
[18:04:55.239]                         }
[18:04:55.239]                         else {
[18:04:55.239]                           version <- NULL
[18:04:55.239]                         }
[18:04:55.239]                         if (!has_future || version < "1.8.0") {
[18:04:55.239]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.239]                             "", base::R.version$version.string), 
[18:04:55.239]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:55.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.239]                               "release", "version")], collapse = " "), 
[18:04:55.239]                             hostname = base::Sys.info()[["nodename"]])
[18:04:55.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.239]                             info)
[18:04:55.239]                           info <- base::paste(info, collapse = "; ")
[18:04:55.239]                           if (!has_future) {
[18:04:55.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.239]                               info)
[18:04:55.239]                           }
[18:04:55.239]                           else {
[18:04:55.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.239]                               info, version)
[18:04:55.239]                           }
[18:04:55.239]                           base::stop(msg)
[18:04:55.239]                         }
[18:04:55.239]                       })
[18:04:55.239]                     }
[18:04:55.239]                     base::local({
[18:04:55.239]                       for (pkg in "future") {
[18:04:55.239]                         base::loadNamespace(pkg)
[18:04:55.239]                         base::library(pkg, character.only = TRUE)
[18:04:55.239]                       }
[18:04:55.239]                     })
[18:04:55.239]                   }
[18:04:55.239]                   ...future.strategy.old <- future::plan("list")
[18:04:55.239]                   options(future.plan = NULL)
[18:04:55.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.239]                 }
[18:04:55.239]                 ...future.workdir <- getwd()
[18:04:55.239]             }
[18:04:55.239]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.239]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.239]         }
[18:04:55.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.239]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.239]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.239]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.239]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.239]             base::names(...future.oldOptions))
[18:04:55.239]     }
[18:04:55.239]     if (FALSE) {
[18:04:55.239]     }
[18:04:55.239]     else {
[18:04:55.239]         if (TRUE) {
[18:04:55.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.239]                 open = "w")
[18:04:55.239]         }
[18:04:55.239]         else {
[18:04:55.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.239]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.239]         }
[18:04:55.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.239]             base::sink(type = "output", split = FALSE)
[18:04:55.239]             base::close(...future.stdout)
[18:04:55.239]         }, add = TRUE)
[18:04:55.239]     }
[18:04:55.239]     ...future.frame <- base::sys.nframe()
[18:04:55.239]     ...future.conditions <- base::list()
[18:04:55.239]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.239]     if (FALSE) {
[18:04:55.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.239]     }
[18:04:55.239]     ...future.result <- base::tryCatch({
[18:04:55.239]         base::withCallingHandlers({
[18:04:55.239]             ...future.value <- base::withVisible(base::local(value(a) + 
[18:04:55.239]                 1))
[18:04:55.239]             future::FutureResult(value = ...future.value$value, 
[18:04:55.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.239]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.239]                     ...future.globalenv.names))
[18:04:55.239]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.239]         }, condition = base::local({
[18:04:55.239]             c <- base::c
[18:04:55.239]             inherits <- base::inherits
[18:04:55.239]             invokeRestart <- base::invokeRestart
[18:04:55.239]             length <- base::length
[18:04:55.239]             list <- base::list
[18:04:55.239]             seq.int <- base::seq.int
[18:04:55.239]             signalCondition <- base::signalCondition
[18:04:55.239]             sys.calls <- base::sys.calls
[18:04:55.239]             `[[` <- base::`[[`
[18:04:55.239]             `+` <- base::`+`
[18:04:55.239]             `<<-` <- base::`<<-`
[18:04:55.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.239]                   3L)]
[18:04:55.239]             }
[18:04:55.239]             function(cond) {
[18:04:55.239]                 is_error <- inherits(cond, "error")
[18:04:55.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.239]                   NULL)
[18:04:55.239]                 if (is_error) {
[18:04:55.239]                   sessionInformation <- function() {
[18:04:55.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.239]                       search = base::search(), system = base::Sys.info())
[18:04:55.239]                   }
[18:04:55.239]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.239]                     cond$call), session = sessionInformation(), 
[18:04:55.239]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.239]                   signalCondition(cond)
[18:04:55.239]                 }
[18:04:55.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.239]                 "immediateCondition"))) {
[18:04:55.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.239]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.239]                   if (TRUE && !signal) {
[18:04:55.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.239]                     {
[18:04:55.239]                       inherits <- base::inherits
[18:04:55.239]                       invokeRestart <- base::invokeRestart
[18:04:55.239]                       is.null <- base::is.null
[18:04:55.239]                       muffled <- FALSE
[18:04:55.239]                       if (inherits(cond, "message")) {
[18:04:55.239]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.239]                         if (muffled) 
[18:04:55.239]                           invokeRestart("muffleMessage")
[18:04:55.239]                       }
[18:04:55.239]                       else if (inherits(cond, "warning")) {
[18:04:55.239]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.239]                         if (muffled) 
[18:04:55.239]                           invokeRestart("muffleWarning")
[18:04:55.239]                       }
[18:04:55.239]                       else if (inherits(cond, "condition")) {
[18:04:55.239]                         if (!is.null(pattern)) {
[18:04:55.239]                           computeRestarts <- base::computeRestarts
[18:04:55.239]                           grepl <- base::grepl
[18:04:55.239]                           restarts <- computeRestarts(cond)
[18:04:55.239]                           for (restart in restarts) {
[18:04:55.239]                             name <- restart$name
[18:04:55.239]                             if (is.null(name)) 
[18:04:55.239]                               next
[18:04:55.239]                             if (!grepl(pattern, name)) 
[18:04:55.239]                               next
[18:04:55.239]                             invokeRestart(restart)
[18:04:55.239]                             muffled <- TRUE
[18:04:55.239]                             break
[18:04:55.239]                           }
[18:04:55.239]                         }
[18:04:55.239]                       }
[18:04:55.239]                       invisible(muffled)
[18:04:55.239]                     }
[18:04:55.239]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.239]                   }
[18:04:55.239]                 }
[18:04:55.239]                 else {
[18:04:55.239]                   if (TRUE) {
[18:04:55.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.239]                     {
[18:04:55.239]                       inherits <- base::inherits
[18:04:55.239]                       invokeRestart <- base::invokeRestart
[18:04:55.239]                       is.null <- base::is.null
[18:04:55.239]                       muffled <- FALSE
[18:04:55.239]                       if (inherits(cond, "message")) {
[18:04:55.239]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.239]                         if (muffled) 
[18:04:55.239]                           invokeRestart("muffleMessage")
[18:04:55.239]                       }
[18:04:55.239]                       else if (inherits(cond, "warning")) {
[18:04:55.239]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.239]                         if (muffled) 
[18:04:55.239]                           invokeRestart("muffleWarning")
[18:04:55.239]                       }
[18:04:55.239]                       else if (inherits(cond, "condition")) {
[18:04:55.239]                         if (!is.null(pattern)) {
[18:04:55.239]                           computeRestarts <- base::computeRestarts
[18:04:55.239]                           grepl <- base::grepl
[18:04:55.239]                           restarts <- computeRestarts(cond)
[18:04:55.239]                           for (restart in restarts) {
[18:04:55.239]                             name <- restart$name
[18:04:55.239]                             if (is.null(name)) 
[18:04:55.239]                               next
[18:04:55.239]                             if (!grepl(pattern, name)) 
[18:04:55.239]                               next
[18:04:55.239]                             invokeRestart(restart)
[18:04:55.239]                             muffled <- TRUE
[18:04:55.239]                             break
[18:04:55.239]                           }
[18:04:55.239]                         }
[18:04:55.239]                       }
[18:04:55.239]                       invisible(muffled)
[18:04:55.239]                     }
[18:04:55.239]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.239]                   }
[18:04:55.239]                 }
[18:04:55.239]             }
[18:04:55.239]         }))
[18:04:55.239]     }, error = function(ex) {
[18:04:55.239]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.239]                 ...future.rng), started = ...future.startTime, 
[18:04:55.239]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.239]             version = "1.8"), class = "FutureResult")
[18:04:55.239]     }, finally = {
[18:04:55.239]         if (!identical(...future.workdir, getwd())) 
[18:04:55.239]             setwd(...future.workdir)
[18:04:55.239]         {
[18:04:55.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.239]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.239]             }
[18:04:55.239]             base::options(...future.oldOptions)
[18:04:55.239]             if (.Platform$OS.type == "windows") {
[18:04:55.239]                 old_names <- names(...future.oldEnvVars)
[18:04:55.239]                 envs <- base::Sys.getenv()
[18:04:55.239]                 names <- names(envs)
[18:04:55.239]                 common <- intersect(names, old_names)
[18:04:55.239]                 added <- setdiff(names, old_names)
[18:04:55.239]                 removed <- setdiff(old_names, names)
[18:04:55.239]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.239]                   envs[common]]
[18:04:55.239]                 NAMES <- toupper(changed)
[18:04:55.239]                 args <- list()
[18:04:55.239]                 for (kk in seq_along(NAMES)) {
[18:04:55.239]                   name <- changed[[kk]]
[18:04:55.239]                   NAME <- NAMES[[kk]]
[18:04:55.239]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.239]                     next
[18:04:55.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.239]                 }
[18:04:55.239]                 NAMES <- toupper(added)
[18:04:55.239]                 for (kk in seq_along(NAMES)) {
[18:04:55.239]                   name <- added[[kk]]
[18:04:55.239]                   NAME <- NAMES[[kk]]
[18:04:55.239]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.239]                     next
[18:04:55.239]                   args[[name]] <- ""
[18:04:55.239]                 }
[18:04:55.239]                 NAMES <- toupper(removed)
[18:04:55.239]                 for (kk in seq_along(NAMES)) {
[18:04:55.239]                   name <- removed[[kk]]
[18:04:55.239]                   NAME <- NAMES[[kk]]
[18:04:55.239]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.239]                     next
[18:04:55.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.239]                 }
[18:04:55.239]                 if (length(args) > 0) 
[18:04:55.239]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.239]             }
[18:04:55.239]             else {
[18:04:55.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.239]             }
[18:04:55.239]             {
[18:04:55.239]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.239]                   0L) {
[18:04:55.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.239]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.239]                   base::options(opts)
[18:04:55.239]                 }
[18:04:55.239]                 {
[18:04:55.239]                   {
[18:04:55.239]                     NULL
[18:04:55.239]                     RNGkind("Mersenne-Twister")
[18:04:55.239]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.239]                       inherits = FALSE)
[18:04:55.239]                   }
[18:04:55.239]                   options(future.plan = NULL)
[18:04:55.239]                   if (is.na(NA_character_)) 
[18:04:55.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.239]                     .init = FALSE)
[18:04:55.239]                 }
[18:04:55.239]             }
[18:04:55.239]         }
[18:04:55.239]     })
[18:04:55.239]     if (TRUE) {
[18:04:55.239]         base::sink(type = "output", split = FALSE)
[18:04:55.239]         if (TRUE) {
[18:04:55.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.239]         }
[18:04:55.239]         else {
[18:04:55.239]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.239]         }
[18:04:55.239]         base::close(...future.stdout)
[18:04:55.239]         ...future.stdout <- NULL
[18:04:55.239]     }
[18:04:55.239]     ...future.result$conditions <- ...future.conditions
[18:04:55.239]     ...future.result$finished <- base::Sys.time()
[18:04:55.239]     ...future.result
[18:04:55.239] }
[18:04:55.243] assign_globals() ...
[18:04:55.243] List of 1
[18:04:55.243]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5b9577354e58> 
[18:04:55.243]  - attr(*, "where")=List of 1
[18:04:55.243]   ..$ a:<environment: R_EmptyEnv> 
[18:04:55.243]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.243]  - attr(*, "resolved")= logi TRUE
[18:04:55.243]  - attr(*, "total_size")= num 10424
[18:04:55.243]  - attr(*, "already-done")= logi TRUE
[18:04:55.249] - copied ‘a’ to environment
[18:04:55.249] assign_globals() ... done
[18:04:55.250] plan(): Setting new future strategy stack:
[18:04:55.250] List of future strategies:
[18:04:55.250] 1. sequential:
[18:04:55.250]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.250]    - tweaked: FALSE
[18:04:55.250]    - call: NULL
[18:04:55.251] plan(): nbrOfWorkers() = 1
[18:04:55.253] plan(): Setting new future strategy stack:
[18:04:55.253] List of future strategies:
[18:04:55.253] 1. sequential:
[18:04:55.253]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.253]    - tweaked: FALSE
[18:04:55.253]    - call: plan(strategy)
[18:04:55.254] plan(): nbrOfWorkers() = 1
[18:04:55.255] SequentialFuture started (and completed)
[18:04:55.255] - Launch lazy future ... done
[18:04:55.255] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.256] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.257] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.258] 
[18:04:55.258] Searching for globals ... DONE
[18:04:55.258] - globals: [0] <none>
[18:04:55.258] getGlobalsAndPackages() ... DONE
[18:04:55.259] run() for ‘Future’ ...
[18:04:55.259] - state: ‘created’
[18:04:55.259] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.260] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.260] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.260]   - Field: ‘label’
[18:04:55.261]   - Field: ‘local’
[18:04:55.261]   - Field: ‘owner’
[18:04:55.261]   - Field: ‘envir’
[18:04:55.261]   - Field: ‘packages’
[18:04:55.261]   - Field: ‘gc’
[18:04:55.262]   - Field: ‘conditions’
[18:04:55.262]   - Field: ‘expr’
[18:04:55.262]   - Field: ‘uuid’
[18:04:55.262]   - Field: ‘seed’
[18:04:55.262]   - Field: ‘version’
[18:04:55.263]   - Field: ‘result’
[18:04:55.263]   - Field: ‘asynchronous’
[18:04:55.263]   - Field: ‘calls’
[18:04:55.263]   - Field: ‘globals’
[18:04:55.263]   - Field: ‘stdout’
[18:04:55.264]   - Field: ‘earlySignal’
[18:04:55.264]   - Field: ‘lazy’
[18:04:55.264]   - Field: ‘state’
[18:04:55.264] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.264] - Launch lazy future ...
[18:04:55.265] Packages needed by the future expression (n = 0): <none>
[18:04:55.265] Packages needed by future strategies (n = 0): <none>
[18:04:55.266] {
[18:04:55.266]     {
[18:04:55.266]         {
[18:04:55.266]             ...future.startTime <- base::Sys.time()
[18:04:55.266]             {
[18:04:55.266]                 {
[18:04:55.266]                   {
[18:04:55.266]                     base::local({
[18:04:55.266]                       has_future <- base::requireNamespace("future", 
[18:04:55.266]                         quietly = TRUE)
[18:04:55.266]                       if (has_future) {
[18:04:55.266]                         ns <- base::getNamespace("future")
[18:04:55.266]                         version <- ns[[".package"]][["version"]]
[18:04:55.266]                         if (is.null(version)) 
[18:04:55.266]                           version <- utils::packageVersion("future")
[18:04:55.266]                       }
[18:04:55.266]                       else {
[18:04:55.266]                         version <- NULL
[18:04:55.266]                       }
[18:04:55.266]                       if (!has_future || version < "1.8.0") {
[18:04:55.266]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.266]                           "", base::R.version$version.string), 
[18:04:55.266]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.266]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.266]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.266]                             "release", "version")], collapse = " "), 
[18:04:55.266]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.266]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.266]                           info)
[18:04:55.266]                         info <- base::paste(info, collapse = "; ")
[18:04:55.266]                         if (!has_future) {
[18:04:55.266]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.266]                             info)
[18:04:55.266]                         }
[18:04:55.266]                         else {
[18:04:55.266]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.266]                             info, version)
[18:04:55.266]                         }
[18:04:55.266]                         base::stop(msg)
[18:04:55.266]                       }
[18:04:55.266]                     })
[18:04:55.266]                   }
[18:04:55.266]                   ...future.strategy.old <- future::plan("list")
[18:04:55.266]                   options(future.plan = NULL)
[18:04:55.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.266]                 }
[18:04:55.266]                 ...future.workdir <- getwd()
[18:04:55.266]             }
[18:04:55.266]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.266]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.266]         }
[18:04:55.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.266]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.266]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.266]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.266]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.266]             base::names(...future.oldOptions))
[18:04:55.266]     }
[18:04:55.266]     if (FALSE) {
[18:04:55.266]     }
[18:04:55.266]     else {
[18:04:55.266]         if (TRUE) {
[18:04:55.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.266]                 open = "w")
[18:04:55.266]         }
[18:04:55.266]         else {
[18:04:55.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.266]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.266]         }
[18:04:55.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.266]             base::sink(type = "output", split = FALSE)
[18:04:55.266]             base::close(...future.stdout)
[18:04:55.266]         }, add = TRUE)
[18:04:55.266]     }
[18:04:55.266]     ...future.frame <- base::sys.nframe()
[18:04:55.266]     ...future.conditions <- base::list()
[18:04:55.266]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.266]     if (FALSE) {
[18:04:55.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.266]     }
[18:04:55.266]     ...future.result <- base::tryCatch({
[18:04:55.266]         base::withCallingHandlers({
[18:04:55.266]             ...future.value <- base::withVisible(base::local(1))
[18:04:55.266]             future::FutureResult(value = ...future.value$value, 
[18:04:55.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.266]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.266]                     ...future.globalenv.names))
[18:04:55.266]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.266]         }, condition = base::local({
[18:04:55.266]             c <- base::c
[18:04:55.266]             inherits <- base::inherits
[18:04:55.266]             invokeRestart <- base::invokeRestart
[18:04:55.266]             length <- base::length
[18:04:55.266]             list <- base::list
[18:04:55.266]             seq.int <- base::seq.int
[18:04:55.266]             signalCondition <- base::signalCondition
[18:04:55.266]             sys.calls <- base::sys.calls
[18:04:55.266]             `[[` <- base::`[[`
[18:04:55.266]             `+` <- base::`+`
[18:04:55.266]             `<<-` <- base::`<<-`
[18:04:55.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.266]                   3L)]
[18:04:55.266]             }
[18:04:55.266]             function(cond) {
[18:04:55.266]                 is_error <- inherits(cond, "error")
[18:04:55.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.266]                   NULL)
[18:04:55.266]                 if (is_error) {
[18:04:55.266]                   sessionInformation <- function() {
[18:04:55.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.266]                       search = base::search(), system = base::Sys.info())
[18:04:55.266]                   }
[18:04:55.266]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.266]                     cond$call), session = sessionInformation(), 
[18:04:55.266]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.266]                   signalCondition(cond)
[18:04:55.266]                 }
[18:04:55.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.266]                 "immediateCondition"))) {
[18:04:55.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.266]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.266]                   if (TRUE && !signal) {
[18:04:55.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.266]                     {
[18:04:55.266]                       inherits <- base::inherits
[18:04:55.266]                       invokeRestart <- base::invokeRestart
[18:04:55.266]                       is.null <- base::is.null
[18:04:55.266]                       muffled <- FALSE
[18:04:55.266]                       if (inherits(cond, "message")) {
[18:04:55.266]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.266]                         if (muffled) 
[18:04:55.266]                           invokeRestart("muffleMessage")
[18:04:55.266]                       }
[18:04:55.266]                       else if (inherits(cond, "warning")) {
[18:04:55.266]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.266]                         if (muffled) 
[18:04:55.266]                           invokeRestart("muffleWarning")
[18:04:55.266]                       }
[18:04:55.266]                       else if (inherits(cond, "condition")) {
[18:04:55.266]                         if (!is.null(pattern)) {
[18:04:55.266]                           computeRestarts <- base::computeRestarts
[18:04:55.266]                           grepl <- base::grepl
[18:04:55.266]                           restarts <- computeRestarts(cond)
[18:04:55.266]                           for (restart in restarts) {
[18:04:55.266]                             name <- restart$name
[18:04:55.266]                             if (is.null(name)) 
[18:04:55.266]                               next
[18:04:55.266]                             if (!grepl(pattern, name)) 
[18:04:55.266]                               next
[18:04:55.266]                             invokeRestart(restart)
[18:04:55.266]                             muffled <- TRUE
[18:04:55.266]                             break
[18:04:55.266]                           }
[18:04:55.266]                         }
[18:04:55.266]                       }
[18:04:55.266]                       invisible(muffled)
[18:04:55.266]                     }
[18:04:55.266]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.266]                   }
[18:04:55.266]                 }
[18:04:55.266]                 else {
[18:04:55.266]                   if (TRUE) {
[18:04:55.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.266]                     {
[18:04:55.266]                       inherits <- base::inherits
[18:04:55.266]                       invokeRestart <- base::invokeRestart
[18:04:55.266]                       is.null <- base::is.null
[18:04:55.266]                       muffled <- FALSE
[18:04:55.266]                       if (inherits(cond, "message")) {
[18:04:55.266]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.266]                         if (muffled) 
[18:04:55.266]                           invokeRestart("muffleMessage")
[18:04:55.266]                       }
[18:04:55.266]                       else if (inherits(cond, "warning")) {
[18:04:55.266]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.266]                         if (muffled) 
[18:04:55.266]                           invokeRestart("muffleWarning")
[18:04:55.266]                       }
[18:04:55.266]                       else if (inherits(cond, "condition")) {
[18:04:55.266]                         if (!is.null(pattern)) {
[18:04:55.266]                           computeRestarts <- base::computeRestarts
[18:04:55.266]                           grepl <- base::grepl
[18:04:55.266]                           restarts <- computeRestarts(cond)
[18:04:55.266]                           for (restart in restarts) {
[18:04:55.266]                             name <- restart$name
[18:04:55.266]                             if (is.null(name)) 
[18:04:55.266]                               next
[18:04:55.266]                             if (!grepl(pattern, name)) 
[18:04:55.266]                               next
[18:04:55.266]                             invokeRestart(restart)
[18:04:55.266]                             muffled <- TRUE
[18:04:55.266]                             break
[18:04:55.266]                           }
[18:04:55.266]                         }
[18:04:55.266]                       }
[18:04:55.266]                       invisible(muffled)
[18:04:55.266]                     }
[18:04:55.266]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.266]                   }
[18:04:55.266]                 }
[18:04:55.266]             }
[18:04:55.266]         }))
[18:04:55.266]     }, error = function(ex) {
[18:04:55.266]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.266]                 ...future.rng), started = ...future.startTime, 
[18:04:55.266]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.266]             version = "1.8"), class = "FutureResult")
[18:04:55.266]     }, finally = {
[18:04:55.266]         if (!identical(...future.workdir, getwd())) 
[18:04:55.266]             setwd(...future.workdir)
[18:04:55.266]         {
[18:04:55.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.266]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.266]             }
[18:04:55.266]             base::options(...future.oldOptions)
[18:04:55.266]             if (.Platform$OS.type == "windows") {
[18:04:55.266]                 old_names <- names(...future.oldEnvVars)
[18:04:55.266]                 envs <- base::Sys.getenv()
[18:04:55.266]                 names <- names(envs)
[18:04:55.266]                 common <- intersect(names, old_names)
[18:04:55.266]                 added <- setdiff(names, old_names)
[18:04:55.266]                 removed <- setdiff(old_names, names)
[18:04:55.266]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.266]                   envs[common]]
[18:04:55.266]                 NAMES <- toupper(changed)
[18:04:55.266]                 args <- list()
[18:04:55.266]                 for (kk in seq_along(NAMES)) {
[18:04:55.266]                   name <- changed[[kk]]
[18:04:55.266]                   NAME <- NAMES[[kk]]
[18:04:55.266]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.266]                     next
[18:04:55.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.266]                 }
[18:04:55.266]                 NAMES <- toupper(added)
[18:04:55.266]                 for (kk in seq_along(NAMES)) {
[18:04:55.266]                   name <- added[[kk]]
[18:04:55.266]                   NAME <- NAMES[[kk]]
[18:04:55.266]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.266]                     next
[18:04:55.266]                   args[[name]] <- ""
[18:04:55.266]                 }
[18:04:55.266]                 NAMES <- toupper(removed)
[18:04:55.266]                 for (kk in seq_along(NAMES)) {
[18:04:55.266]                   name <- removed[[kk]]
[18:04:55.266]                   NAME <- NAMES[[kk]]
[18:04:55.266]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.266]                     next
[18:04:55.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.266]                 }
[18:04:55.266]                 if (length(args) > 0) 
[18:04:55.266]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.266]             }
[18:04:55.266]             else {
[18:04:55.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.266]             }
[18:04:55.266]             {
[18:04:55.266]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.266]                   0L) {
[18:04:55.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.266]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.266]                   base::options(opts)
[18:04:55.266]                 }
[18:04:55.266]                 {
[18:04:55.266]                   {
[18:04:55.266]                     NULL
[18:04:55.266]                     RNGkind("Mersenne-Twister")
[18:04:55.266]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.266]                       inherits = FALSE)
[18:04:55.266]                   }
[18:04:55.266]                   options(future.plan = NULL)
[18:04:55.266]                   if (is.na(NA_character_)) 
[18:04:55.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.266]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.266]                     .init = FALSE)
[18:04:55.266]                 }
[18:04:55.266]             }
[18:04:55.266]         }
[18:04:55.266]     })
[18:04:55.266]     if (TRUE) {
[18:04:55.266]         base::sink(type = "output", split = FALSE)
[18:04:55.266]         if (TRUE) {
[18:04:55.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.266]         }
[18:04:55.266]         else {
[18:04:55.266]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.266]         }
[18:04:55.266]         base::close(...future.stdout)
[18:04:55.266]         ...future.stdout <- NULL
[18:04:55.266]     }
[18:04:55.266]     ...future.result$conditions <- ...future.conditions
[18:04:55.266]     ...future.result$finished <- base::Sys.time()
[18:04:55.266]     ...future.result
[18:04:55.266] }
[18:04:55.270] plan(): Setting new future strategy stack:
[18:04:55.270] List of future strategies:
[18:04:55.270] 1. sequential:
[18:04:55.270]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.270]    - tweaked: FALSE
[18:04:55.270]    - call: NULL
[18:04:55.271] plan(): nbrOfWorkers() = 1
[18:04:55.273] plan(): Setting new future strategy stack:
[18:04:55.273] List of future strategies:
[18:04:55.273] 1. sequential:
[18:04:55.273]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.273]    - tweaked: FALSE
[18:04:55.273]    - call: plan(strategy)
[18:04:55.274] plan(): nbrOfWorkers() = 1
[18:04:55.274] SequentialFuture started (and completed)
[18:04:55.274] - Launch lazy future ... done
[18:04:55.275] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.275] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.276] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.278] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:55.278] Searching for globals ... DONE
[18:04:55.278] Resolving globals: TRUE
[18:04:55.278] Resolving any globals that are futures ...
[18:04:55.279] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:55.279] Resolving any globals that are futures ... DONE
[18:04:55.279] Resolving futures part of globals (recursively) ...
[18:04:55.280] resolve() on list ...
[18:04:55.280]  recursive: 99
[18:04:55.280]  length: 1
[18:04:55.281]  elements: ‘a’
[18:04:55.281] resolved() for ‘SequentialFuture’ ...
[18:04:55.281] - state: ‘finished’
[18:04:55.281] - run: TRUE
[18:04:55.282] - result: ‘FutureResult’
[18:04:55.282] resolved() for ‘SequentialFuture’ ... done
[18:04:55.282] Future #1
[18:04:55.282] resolved() for ‘SequentialFuture’ ...
[18:04:55.283] - state: ‘finished’
[18:04:55.283] - run: TRUE
[18:04:55.283] - result: ‘FutureResult’
[18:04:55.283] resolved() for ‘SequentialFuture’ ... done
[18:04:55.283] A SequentialFuture was resolved
[18:04:55.286]  length: 0 (resolved future 1)
[18:04:55.287] resolve() on list ... DONE
[18:04:55.287] - globals: [1] ‘a’
[18:04:55.287] Resolving futures part of globals (recursively) ... DONE
[18:04:55.289] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[18:04:55.290] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[18:04:55.290] - globals: [1] ‘a’
[18:04:55.290] - packages: [1] ‘future’
[18:04:55.290] getGlobalsAndPackages() ... DONE
[18:04:55.291] run() for ‘Future’ ...
[18:04:55.291] - state: ‘created’
[18:04:55.291] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.292] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.293]   - Field: ‘label’
[18:04:55.293]   - Field: ‘local’
[18:04:55.293]   - Field: ‘owner’
[18:04:55.293]   - Field: ‘envir’
[18:04:55.293]   - Field: ‘packages’
[18:04:55.294]   - Field: ‘gc’
[18:04:55.294]   - Field: ‘conditions’
[18:04:55.294]   - Field: ‘expr’
[18:04:55.294]   - Field: ‘uuid’
[18:04:55.294]   - Field: ‘seed’
[18:04:55.295]   - Field: ‘version’
[18:04:55.295]   - Field: ‘result’
[18:04:55.295]   - Field: ‘asynchronous’
[18:04:55.295]   - Field: ‘calls’
[18:04:55.295]   - Field: ‘globals’
[18:04:55.296]   - Field: ‘stdout’
[18:04:55.296]   - Field: ‘earlySignal’
[18:04:55.296]   - Field: ‘lazy’
[18:04:55.296]   - Field: ‘state’
[18:04:55.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.297] - Launch lazy future ...
[18:04:55.297] Packages needed by the future expression (n = 1): ‘future’
[18:04:55.297] Packages needed by future strategies (n = 0): <none>
[18:04:55.298] {
[18:04:55.298]     {
[18:04:55.298]         {
[18:04:55.298]             ...future.startTime <- base::Sys.time()
[18:04:55.298]             {
[18:04:55.298]                 {
[18:04:55.298]                   {
[18:04:55.298]                     {
[18:04:55.298]                       base::local({
[18:04:55.298]                         has_future <- base::requireNamespace("future", 
[18:04:55.298]                           quietly = TRUE)
[18:04:55.298]                         if (has_future) {
[18:04:55.298]                           ns <- base::getNamespace("future")
[18:04:55.298]                           version <- ns[[".package"]][["version"]]
[18:04:55.298]                           if (is.null(version)) 
[18:04:55.298]                             version <- utils::packageVersion("future")
[18:04:55.298]                         }
[18:04:55.298]                         else {
[18:04:55.298]                           version <- NULL
[18:04:55.298]                         }
[18:04:55.298]                         if (!has_future || version < "1.8.0") {
[18:04:55.298]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.298]                             "", base::R.version$version.string), 
[18:04:55.298]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:55.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.298]                               "release", "version")], collapse = " "), 
[18:04:55.298]                             hostname = base::Sys.info()[["nodename"]])
[18:04:55.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.298]                             info)
[18:04:55.298]                           info <- base::paste(info, collapse = "; ")
[18:04:55.298]                           if (!has_future) {
[18:04:55.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.298]                               info)
[18:04:55.298]                           }
[18:04:55.298]                           else {
[18:04:55.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.298]                               info, version)
[18:04:55.298]                           }
[18:04:55.298]                           base::stop(msg)
[18:04:55.298]                         }
[18:04:55.298]                       })
[18:04:55.298]                     }
[18:04:55.298]                     base::local({
[18:04:55.298]                       for (pkg in "future") {
[18:04:55.298]                         base::loadNamespace(pkg)
[18:04:55.298]                         base::library(pkg, character.only = TRUE)
[18:04:55.298]                       }
[18:04:55.298]                     })
[18:04:55.298]                   }
[18:04:55.298]                   ...future.strategy.old <- future::plan("list")
[18:04:55.298]                   options(future.plan = NULL)
[18:04:55.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.298]                 }
[18:04:55.298]                 ...future.workdir <- getwd()
[18:04:55.298]             }
[18:04:55.298]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.298]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.298]         }
[18:04:55.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.298]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.298]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.298]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.298]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.298]             base::names(...future.oldOptions))
[18:04:55.298]     }
[18:04:55.298]     if (FALSE) {
[18:04:55.298]     }
[18:04:55.298]     else {
[18:04:55.298]         if (TRUE) {
[18:04:55.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.298]                 open = "w")
[18:04:55.298]         }
[18:04:55.298]         else {
[18:04:55.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.298]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.298]         }
[18:04:55.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.298]             base::sink(type = "output", split = FALSE)
[18:04:55.298]             base::close(...future.stdout)
[18:04:55.298]         }, add = TRUE)
[18:04:55.298]     }
[18:04:55.298]     ...future.frame <- base::sys.nframe()
[18:04:55.298]     ...future.conditions <- base::list()
[18:04:55.298]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.298]     if (FALSE) {
[18:04:55.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.298]     }
[18:04:55.298]     ...future.result <- base::tryCatch({
[18:04:55.298]         base::withCallingHandlers({
[18:04:55.298]             ...future.value <- base::withVisible(base::local(value(a) + 
[18:04:55.298]                 1))
[18:04:55.298]             future::FutureResult(value = ...future.value$value, 
[18:04:55.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.298]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.298]                     ...future.globalenv.names))
[18:04:55.298]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.298]         }, condition = base::local({
[18:04:55.298]             c <- base::c
[18:04:55.298]             inherits <- base::inherits
[18:04:55.298]             invokeRestart <- base::invokeRestart
[18:04:55.298]             length <- base::length
[18:04:55.298]             list <- base::list
[18:04:55.298]             seq.int <- base::seq.int
[18:04:55.298]             signalCondition <- base::signalCondition
[18:04:55.298]             sys.calls <- base::sys.calls
[18:04:55.298]             `[[` <- base::`[[`
[18:04:55.298]             `+` <- base::`+`
[18:04:55.298]             `<<-` <- base::`<<-`
[18:04:55.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.298]                   3L)]
[18:04:55.298]             }
[18:04:55.298]             function(cond) {
[18:04:55.298]                 is_error <- inherits(cond, "error")
[18:04:55.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.298]                   NULL)
[18:04:55.298]                 if (is_error) {
[18:04:55.298]                   sessionInformation <- function() {
[18:04:55.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.298]                       search = base::search(), system = base::Sys.info())
[18:04:55.298]                   }
[18:04:55.298]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.298]                     cond$call), session = sessionInformation(), 
[18:04:55.298]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.298]                   signalCondition(cond)
[18:04:55.298]                 }
[18:04:55.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.298]                 "immediateCondition"))) {
[18:04:55.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.298]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.298]                   if (TRUE && !signal) {
[18:04:55.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.298]                     {
[18:04:55.298]                       inherits <- base::inherits
[18:04:55.298]                       invokeRestart <- base::invokeRestart
[18:04:55.298]                       is.null <- base::is.null
[18:04:55.298]                       muffled <- FALSE
[18:04:55.298]                       if (inherits(cond, "message")) {
[18:04:55.298]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.298]                         if (muffled) 
[18:04:55.298]                           invokeRestart("muffleMessage")
[18:04:55.298]                       }
[18:04:55.298]                       else if (inherits(cond, "warning")) {
[18:04:55.298]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.298]                         if (muffled) 
[18:04:55.298]                           invokeRestart("muffleWarning")
[18:04:55.298]                       }
[18:04:55.298]                       else if (inherits(cond, "condition")) {
[18:04:55.298]                         if (!is.null(pattern)) {
[18:04:55.298]                           computeRestarts <- base::computeRestarts
[18:04:55.298]                           grepl <- base::grepl
[18:04:55.298]                           restarts <- computeRestarts(cond)
[18:04:55.298]                           for (restart in restarts) {
[18:04:55.298]                             name <- restart$name
[18:04:55.298]                             if (is.null(name)) 
[18:04:55.298]                               next
[18:04:55.298]                             if (!grepl(pattern, name)) 
[18:04:55.298]                               next
[18:04:55.298]                             invokeRestart(restart)
[18:04:55.298]                             muffled <- TRUE
[18:04:55.298]                             break
[18:04:55.298]                           }
[18:04:55.298]                         }
[18:04:55.298]                       }
[18:04:55.298]                       invisible(muffled)
[18:04:55.298]                     }
[18:04:55.298]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.298]                   }
[18:04:55.298]                 }
[18:04:55.298]                 else {
[18:04:55.298]                   if (TRUE) {
[18:04:55.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.298]                     {
[18:04:55.298]                       inherits <- base::inherits
[18:04:55.298]                       invokeRestart <- base::invokeRestart
[18:04:55.298]                       is.null <- base::is.null
[18:04:55.298]                       muffled <- FALSE
[18:04:55.298]                       if (inherits(cond, "message")) {
[18:04:55.298]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.298]                         if (muffled) 
[18:04:55.298]                           invokeRestart("muffleMessage")
[18:04:55.298]                       }
[18:04:55.298]                       else if (inherits(cond, "warning")) {
[18:04:55.298]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.298]                         if (muffled) 
[18:04:55.298]                           invokeRestart("muffleWarning")
[18:04:55.298]                       }
[18:04:55.298]                       else if (inherits(cond, "condition")) {
[18:04:55.298]                         if (!is.null(pattern)) {
[18:04:55.298]                           computeRestarts <- base::computeRestarts
[18:04:55.298]                           grepl <- base::grepl
[18:04:55.298]                           restarts <- computeRestarts(cond)
[18:04:55.298]                           for (restart in restarts) {
[18:04:55.298]                             name <- restart$name
[18:04:55.298]                             if (is.null(name)) 
[18:04:55.298]                               next
[18:04:55.298]                             if (!grepl(pattern, name)) 
[18:04:55.298]                               next
[18:04:55.298]                             invokeRestart(restart)
[18:04:55.298]                             muffled <- TRUE
[18:04:55.298]                             break
[18:04:55.298]                           }
[18:04:55.298]                         }
[18:04:55.298]                       }
[18:04:55.298]                       invisible(muffled)
[18:04:55.298]                     }
[18:04:55.298]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.298]                   }
[18:04:55.298]                 }
[18:04:55.298]             }
[18:04:55.298]         }))
[18:04:55.298]     }, error = function(ex) {
[18:04:55.298]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.298]                 ...future.rng), started = ...future.startTime, 
[18:04:55.298]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.298]             version = "1.8"), class = "FutureResult")
[18:04:55.298]     }, finally = {
[18:04:55.298]         if (!identical(...future.workdir, getwd())) 
[18:04:55.298]             setwd(...future.workdir)
[18:04:55.298]         {
[18:04:55.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.298]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.298]             }
[18:04:55.298]             base::options(...future.oldOptions)
[18:04:55.298]             if (.Platform$OS.type == "windows") {
[18:04:55.298]                 old_names <- names(...future.oldEnvVars)
[18:04:55.298]                 envs <- base::Sys.getenv()
[18:04:55.298]                 names <- names(envs)
[18:04:55.298]                 common <- intersect(names, old_names)
[18:04:55.298]                 added <- setdiff(names, old_names)
[18:04:55.298]                 removed <- setdiff(old_names, names)
[18:04:55.298]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.298]                   envs[common]]
[18:04:55.298]                 NAMES <- toupper(changed)
[18:04:55.298]                 args <- list()
[18:04:55.298]                 for (kk in seq_along(NAMES)) {
[18:04:55.298]                   name <- changed[[kk]]
[18:04:55.298]                   NAME <- NAMES[[kk]]
[18:04:55.298]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.298]                     next
[18:04:55.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.298]                 }
[18:04:55.298]                 NAMES <- toupper(added)
[18:04:55.298]                 for (kk in seq_along(NAMES)) {
[18:04:55.298]                   name <- added[[kk]]
[18:04:55.298]                   NAME <- NAMES[[kk]]
[18:04:55.298]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.298]                     next
[18:04:55.298]                   args[[name]] <- ""
[18:04:55.298]                 }
[18:04:55.298]                 NAMES <- toupper(removed)
[18:04:55.298]                 for (kk in seq_along(NAMES)) {
[18:04:55.298]                   name <- removed[[kk]]
[18:04:55.298]                   NAME <- NAMES[[kk]]
[18:04:55.298]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.298]                     next
[18:04:55.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.298]                 }
[18:04:55.298]                 if (length(args) > 0) 
[18:04:55.298]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.298]             }
[18:04:55.298]             else {
[18:04:55.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.298]             }
[18:04:55.298]             {
[18:04:55.298]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.298]                   0L) {
[18:04:55.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.298]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.298]                   base::options(opts)
[18:04:55.298]                 }
[18:04:55.298]                 {
[18:04:55.298]                   {
[18:04:55.298]                     NULL
[18:04:55.298]                     RNGkind("Mersenne-Twister")
[18:04:55.298]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.298]                       inherits = FALSE)
[18:04:55.298]                   }
[18:04:55.298]                   options(future.plan = NULL)
[18:04:55.298]                   if (is.na(NA_character_)) 
[18:04:55.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.298]                     .init = FALSE)
[18:04:55.298]                 }
[18:04:55.298]             }
[18:04:55.298]         }
[18:04:55.298]     })
[18:04:55.298]     if (TRUE) {
[18:04:55.298]         base::sink(type = "output", split = FALSE)
[18:04:55.298]         if (TRUE) {
[18:04:55.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.298]         }
[18:04:55.298]         else {
[18:04:55.298]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.298]         }
[18:04:55.298]         base::close(...future.stdout)
[18:04:55.298]         ...future.stdout <- NULL
[18:04:55.298]     }
[18:04:55.298]     ...future.result$conditions <- ...future.conditions
[18:04:55.298]     ...future.result$finished <- base::Sys.time()
[18:04:55.298]     ...future.result
[18:04:55.298] }
[18:04:55.302] assign_globals() ...
[18:04:55.302] List of 1
[18:04:55.302]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5b95770e1b08> 
[18:04:55.302]  - attr(*, "where")=List of 1
[18:04:55.302]   ..$ a:<environment: R_EmptyEnv> 
[18:04:55.302]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.302]  - attr(*, "resolved")= logi TRUE
[18:04:55.302]  - attr(*, "total_size")= num 10424
[18:04:55.302]  - attr(*, "already-done")= logi TRUE
[18:04:55.307] - copied ‘a’ to environment
[18:04:55.308] assign_globals() ... done
[18:04:55.308] plan(): Setting new future strategy stack:
[18:04:55.309] List of future strategies:
[18:04:55.309] 1. sequential:
[18:04:55.309]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.309]    - tweaked: FALSE
[18:04:55.309]    - call: NULL
[18:04:55.310] plan(): nbrOfWorkers() = 1
[18:04:55.312] plan(): Setting new future strategy stack:
[18:04:55.312] List of future strategies:
[18:04:55.312] 1. sequential:
[18:04:55.312]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.312]    - tweaked: FALSE
[18:04:55.312]    - call: plan(strategy)
[18:04:55.315] plan(): nbrOfWorkers() = 1
[18:04:55.315] SequentialFuture started (and completed)
[18:04:55.316] - Launch lazy future ... done
[18:04:55.316] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.317] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.318] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.319] 
[18:04:55.320] Searching for globals ... DONE
[18:04:55.320] - globals: [0] <none>
[18:04:55.320] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.321] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.322] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.326] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:55.326] Searching for globals ... DONE
[18:04:55.327] Resolving globals: TRUE
[18:04:55.327] Resolving any globals that are futures ...
[18:04:55.327] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:55.327] Resolving any globals that are futures ... DONE
[18:04:55.328] Resolving futures part of globals (recursively) ...
[18:04:55.329] resolve() on list ...
[18:04:55.329]  recursive: 99
[18:04:55.329]  length: 1
[18:04:55.330]  elements: ‘a’
[18:04:55.330] run() for ‘Future’ ...
[18:04:55.330] - state: ‘created’
[18:04:55.330] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.331] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.331] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.331]   - Field: ‘label’
[18:04:55.332]   - Field: ‘local’
[18:04:55.332]   - Field: ‘owner’
[18:04:55.332]   - Field: ‘envir’
[18:04:55.332]   - Field: ‘packages’
[18:04:55.333]   - Field: ‘gc’
[18:04:55.333]   - Field: ‘conditions’
[18:04:55.333]   - Field: ‘expr’
[18:04:55.333]   - Field: ‘uuid’
[18:04:55.333]   - Field: ‘seed’
[18:04:55.334]   - Field: ‘version’
[18:04:55.334]   - Field: ‘result’
[18:04:55.334]   - Field: ‘asynchronous’
[18:04:55.334]   - Field: ‘calls’
[18:04:55.334]   - Field: ‘globals’
[18:04:55.335]   - Field: ‘stdout’
[18:04:55.335]   - Field: ‘earlySignal’
[18:04:55.335]   - Field: ‘lazy’
[18:04:55.335]   - Field: ‘state’
[18:04:55.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.336] - Launch lazy future ...
[18:04:55.336] Packages needed by the future expression (n = 0): <none>
[18:04:55.336] Packages needed by future strategies (n = 0): <none>
[18:04:55.337] {
[18:04:55.337]     {
[18:04:55.337]         {
[18:04:55.337]             ...future.startTime <- base::Sys.time()
[18:04:55.337]             {
[18:04:55.337]                 {
[18:04:55.337]                   {
[18:04:55.337]                     base::local({
[18:04:55.337]                       has_future <- base::requireNamespace("future", 
[18:04:55.337]                         quietly = TRUE)
[18:04:55.337]                       if (has_future) {
[18:04:55.337]                         ns <- base::getNamespace("future")
[18:04:55.337]                         version <- ns[[".package"]][["version"]]
[18:04:55.337]                         if (is.null(version)) 
[18:04:55.337]                           version <- utils::packageVersion("future")
[18:04:55.337]                       }
[18:04:55.337]                       else {
[18:04:55.337]                         version <- NULL
[18:04:55.337]                       }
[18:04:55.337]                       if (!has_future || version < "1.8.0") {
[18:04:55.337]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.337]                           "", base::R.version$version.string), 
[18:04:55.337]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.337]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.337]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.337]                             "release", "version")], collapse = " "), 
[18:04:55.337]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.337]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.337]                           info)
[18:04:55.337]                         info <- base::paste(info, collapse = "; ")
[18:04:55.337]                         if (!has_future) {
[18:04:55.337]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.337]                             info)
[18:04:55.337]                         }
[18:04:55.337]                         else {
[18:04:55.337]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.337]                             info, version)
[18:04:55.337]                         }
[18:04:55.337]                         base::stop(msg)
[18:04:55.337]                       }
[18:04:55.337]                     })
[18:04:55.337]                   }
[18:04:55.337]                   ...future.strategy.old <- future::plan("list")
[18:04:55.337]                   options(future.plan = NULL)
[18:04:55.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.337]                 }
[18:04:55.337]                 ...future.workdir <- getwd()
[18:04:55.337]             }
[18:04:55.337]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.337]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.337]         }
[18:04:55.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.337]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.337]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.337]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.337]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.337]             base::names(...future.oldOptions))
[18:04:55.337]     }
[18:04:55.337]     if (FALSE) {
[18:04:55.337]     }
[18:04:55.337]     else {
[18:04:55.337]         if (TRUE) {
[18:04:55.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.337]                 open = "w")
[18:04:55.337]         }
[18:04:55.337]         else {
[18:04:55.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.337]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.337]         }
[18:04:55.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.337]             base::sink(type = "output", split = FALSE)
[18:04:55.337]             base::close(...future.stdout)
[18:04:55.337]         }, add = TRUE)
[18:04:55.337]     }
[18:04:55.337]     ...future.frame <- base::sys.nframe()
[18:04:55.337]     ...future.conditions <- base::list()
[18:04:55.337]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.337]     if (FALSE) {
[18:04:55.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.337]     }
[18:04:55.337]     ...future.result <- base::tryCatch({
[18:04:55.337]         base::withCallingHandlers({
[18:04:55.337]             ...future.value <- base::withVisible(base::local(1))
[18:04:55.337]             future::FutureResult(value = ...future.value$value, 
[18:04:55.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.337]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.337]                     ...future.globalenv.names))
[18:04:55.337]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.337]         }, condition = base::local({
[18:04:55.337]             c <- base::c
[18:04:55.337]             inherits <- base::inherits
[18:04:55.337]             invokeRestart <- base::invokeRestart
[18:04:55.337]             length <- base::length
[18:04:55.337]             list <- base::list
[18:04:55.337]             seq.int <- base::seq.int
[18:04:55.337]             signalCondition <- base::signalCondition
[18:04:55.337]             sys.calls <- base::sys.calls
[18:04:55.337]             `[[` <- base::`[[`
[18:04:55.337]             `+` <- base::`+`
[18:04:55.337]             `<<-` <- base::`<<-`
[18:04:55.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.337]                   3L)]
[18:04:55.337]             }
[18:04:55.337]             function(cond) {
[18:04:55.337]                 is_error <- inherits(cond, "error")
[18:04:55.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.337]                   NULL)
[18:04:55.337]                 if (is_error) {
[18:04:55.337]                   sessionInformation <- function() {
[18:04:55.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.337]                       search = base::search(), system = base::Sys.info())
[18:04:55.337]                   }
[18:04:55.337]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.337]                     cond$call), session = sessionInformation(), 
[18:04:55.337]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.337]                   signalCondition(cond)
[18:04:55.337]                 }
[18:04:55.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.337]                 "immediateCondition"))) {
[18:04:55.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.337]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.337]                   if (TRUE && !signal) {
[18:04:55.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.337]                     {
[18:04:55.337]                       inherits <- base::inherits
[18:04:55.337]                       invokeRestart <- base::invokeRestart
[18:04:55.337]                       is.null <- base::is.null
[18:04:55.337]                       muffled <- FALSE
[18:04:55.337]                       if (inherits(cond, "message")) {
[18:04:55.337]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.337]                         if (muffled) 
[18:04:55.337]                           invokeRestart("muffleMessage")
[18:04:55.337]                       }
[18:04:55.337]                       else if (inherits(cond, "warning")) {
[18:04:55.337]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.337]                         if (muffled) 
[18:04:55.337]                           invokeRestart("muffleWarning")
[18:04:55.337]                       }
[18:04:55.337]                       else if (inherits(cond, "condition")) {
[18:04:55.337]                         if (!is.null(pattern)) {
[18:04:55.337]                           computeRestarts <- base::computeRestarts
[18:04:55.337]                           grepl <- base::grepl
[18:04:55.337]                           restarts <- computeRestarts(cond)
[18:04:55.337]                           for (restart in restarts) {
[18:04:55.337]                             name <- restart$name
[18:04:55.337]                             if (is.null(name)) 
[18:04:55.337]                               next
[18:04:55.337]                             if (!grepl(pattern, name)) 
[18:04:55.337]                               next
[18:04:55.337]                             invokeRestart(restart)
[18:04:55.337]                             muffled <- TRUE
[18:04:55.337]                             break
[18:04:55.337]                           }
[18:04:55.337]                         }
[18:04:55.337]                       }
[18:04:55.337]                       invisible(muffled)
[18:04:55.337]                     }
[18:04:55.337]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.337]                   }
[18:04:55.337]                 }
[18:04:55.337]                 else {
[18:04:55.337]                   if (TRUE) {
[18:04:55.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.337]                     {
[18:04:55.337]                       inherits <- base::inherits
[18:04:55.337]                       invokeRestart <- base::invokeRestart
[18:04:55.337]                       is.null <- base::is.null
[18:04:55.337]                       muffled <- FALSE
[18:04:55.337]                       if (inherits(cond, "message")) {
[18:04:55.337]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.337]                         if (muffled) 
[18:04:55.337]                           invokeRestart("muffleMessage")
[18:04:55.337]                       }
[18:04:55.337]                       else if (inherits(cond, "warning")) {
[18:04:55.337]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.337]                         if (muffled) 
[18:04:55.337]                           invokeRestart("muffleWarning")
[18:04:55.337]                       }
[18:04:55.337]                       else if (inherits(cond, "condition")) {
[18:04:55.337]                         if (!is.null(pattern)) {
[18:04:55.337]                           computeRestarts <- base::computeRestarts
[18:04:55.337]                           grepl <- base::grepl
[18:04:55.337]                           restarts <- computeRestarts(cond)
[18:04:55.337]                           for (restart in restarts) {
[18:04:55.337]                             name <- restart$name
[18:04:55.337]                             if (is.null(name)) 
[18:04:55.337]                               next
[18:04:55.337]                             if (!grepl(pattern, name)) 
[18:04:55.337]                               next
[18:04:55.337]                             invokeRestart(restart)
[18:04:55.337]                             muffled <- TRUE
[18:04:55.337]                             break
[18:04:55.337]                           }
[18:04:55.337]                         }
[18:04:55.337]                       }
[18:04:55.337]                       invisible(muffled)
[18:04:55.337]                     }
[18:04:55.337]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.337]                   }
[18:04:55.337]                 }
[18:04:55.337]             }
[18:04:55.337]         }))
[18:04:55.337]     }, error = function(ex) {
[18:04:55.337]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.337]                 ...future.rng), started = ...future.startTime, 
[18:04:55.337]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.337]             version = "1.8"), class = "FutureResult")
[18:04:55.337]     }, finally = {
[18:04:55.337]         if (!identical(...future.workdir, getwd())) 
[18:04:55.337]             setwd(...future.workdir)
[18:04:55.337]         {
[18:04:55.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.337]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.337]             }
[18:04:55.337]             base::options(...future.oldOptions)
[18:04:55.337]             if (.Platform$OS.type == "windows") {
[18:04:55.337]                 old_names <- names(...future.oldEnvVars)
[18:04:55.337]                 envs <- base::Sys.getenv()
[18:04:55.337]                 names <- names(envs)
[18:04:55.337]                 common <- intersect(names, old_names)
[18:04:55.337]                 added <- setdiff(names, old_names)
[18:04:55.337]                 removed <- setdiff(old_names, names)
[18:04:55.337]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.337]                   envs[common]]
[18:04:55.337]                 NAMES <- toupper(changed)
[18:04:55.337]                 args <- list()
[18:04:55.337]                 for (kk in seq_along(NAMES)) {
[18:04:55.337]                   name <- changed[[kk]]
[18:04:55.337]                   NAME <- NAMES[[kk]]
[18:04:55.337]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.337]                     next
[18:04:55.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.337]                 }
[18:04:55.337]                 NAMES <- toupper(added)
[18:04:55.337]                 for (kk in seq_along(NAMES)) {
[18:04:55.337]                   name <- added[[kk]]
[18:04:55.337]                   NAME <- NAMES[[kk]]
[18:04:55.337]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.337]                     next
[18:04:55.337]                   args[[name]] <- ""
[18:04:55.337]                 }
[18:04:55.337]                 NAMES <- toupper(removed)
[18:04:55.337]                 for (kk in seq_along(NAMES)) {
[18:04:55.337]                   name <- removed[[kk]]
[18:04:55.337]                   NAME <- NAMES[[kk]]
[18:04:55.337]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.337]                     next
[18:04:55.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.337]                 }
[18:04:55.337]                 if (length(args) > 0) 
[18:04:55.337]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.337]             }
[18:04:55.337]             else {
[18:04:55.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.337]             }
[18:04:55.337]             {
[18:04:55.337]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.337]                   0L) {
[18:04:55.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.337]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.337]                   base::options(opts)
[18:04:55.337]                 }
[18:04:55.337]                 {
[18:04:55.337]                   {
[18:04:55.337]                     NULL
[18:04:55.337]                     RNGkind("Mersenne-Twister")
[18:04:55.337]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.337]                       inherits = FALSE)
[18:04:55.337]                   }
[18:04:55.337]                   options(future.plan = NULL)
[18:04:55.337]                   if (is.na(NA_character_)) 
[18:04:55.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.337]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.337]                     .init = FALSE)
[18:04:55.337]                 }
[18:04:55.337]             }
[18:04:55.337]         }
[18:04:55.337]     })
[18:04:55.337]     if (TRUE) {
[18:04:55.337]         base::sink(type = "output", split = FALSE)
[18:04:55.337]         if (TRUE) {
[18:04:55.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.337]         }
[18:04:55.337]         else {
[18:04:55.337]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.337]         }
[18:04:55.337]         base::close(...future.stdout)
[18:04:55.337]         ...future.stdout <- NULL
[18:04:55.337]     }
[18:04:55.337]     ...future.result$conditions <- ...future.conditions
[18:04:55.337]     ...future.result$finished <- base::Sys.time()
[18:04:55.337]     ...future.result
[18:04:55.337] }
[18:04:55.342] plan(): Setting new future strategy stack:
[18:04:55.342] List of future strategies:
[18:04:55.342] 1. sequential:
[18:04:55.342]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.342]    - tweaked: FALSE
[18:04:55.342]    - call: NULL
[18:04:55.343] plan(): nbrOfWorkers() = 1
[18:04:55.345] plan(): Setting new future strategy stack:
[18:04:55.345] List of future strategies:
[18:04:55.345] 1. sequential:
[18:04:55.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.345]    - tweaked: FALSE
[18:04:55.345]    - call: plan(strategy)
[18:04:55.346] plan(): nbrOfWorkers() = 1
[18:04:55.347] SequentialFuture started (and completed)
[18:04:55.348] - Launch lazy future ... done
[18:04:55.348] run() for ‘SequentialFuture’ ... done
[18:04:55.348] resolved() for ‘SequentialFuture’ ...
[18:04:55.348] - state: ‘finished’
[18:04:55.349] - run: TRUE
[18:04:55.349] - result: ‘FutureResult’
[18:04:55.349] resolved() for ‘SequentialFuture’ ... done
[18:04:55.350] Future #1
[18:04:55.350] resolved() for ‘SequentialFuture’ ...
[18:04:55.350] - state: ‘finished’
[18:04:55.351] - run: TRUE
[18:04:55.351] - result: ‘FutureResult’
[18:04:55.351] resolved() for ‘SequentialFuture’ ... done
[18:04:55.351] A SequentialFuture was resolved
[18:04:55.351]  length: 0 (resolved future 1)
[18:04:55.352] resolve() on list ... DONE
[18:04:55.352] - globals: [1] ‘a’
[18:04:55.352] Resolving futures part of globals (recursively) ... DONE
[18:04:55.354] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[18:04:55.354] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[18:04:55.355] - globals: [1] ‘a’
[18:04:55.355] - packages: [1] ‘future’
[18:04:55.355] getGlobalsAndPackages() ... DONE
[18:04:55.356] run() for ‘Future’ ...
[18:04:55.356] - state: ‘created’
[18:04:55.356] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.357] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.357]   - Field: ‘label’
[18:04:55.360]   - Field: ‘local’
[18:04:55.361]   - Field: ‘owner’
[18:04:55.361]   - Field: ‘envir’
[18:04:55.361]   - Field: ‘packages’
[18:04:55.361]   - Field: ‘gc’
[18:04:55.361]   - Field: ‘conditions’
[18:04:55.362]   - Field: ‘expr’
[18:04:55.362]   - Field: ‘uuid’
[18:04:55.362]   - Field: ‘seed’
[18:04:55.362]   - Field: ‘version’
[18:04:55.362]   - Field: ‘result’
[18:04:55.363]   - Field: ‘asynchronous’
[18:04:55.363]   - Field: ‘calls’
[18:04:55.363]   - Field: ‘globals’
[18:04:55.363]   - Field: ‘stdout’
[18:04:55.363]   - Field: ‘earlySignal’
[18:04:55.364]   - Field: ‘lazy’
[18:04:55.364]   - Field: ‘state’
[18:04:55.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.364] - Launch lazy future ...
[18:04:55.365] Packages needed by the future expression (n = 1): ‘future’
[18:04:55.365] Packages needed by future strategies (n = 0): <none>
[18:04:55.366] {
[18:04:55.366]     {
[18:04:55.366]         {
[18:04:55.366]             ...future.startTime <- base::Sys.time()
[18:04:55.366]             {
[18:04:55.366]                 {
[18:04:55.366]                   {
[18:04:55.366]                     {
[18:04:55.366]                       base::local({
[18:04:55.366]                         has_future <- base::requireNamespace("future", 
[18:04:55.366]                           quietly = TRUE)
[18:04:55.366]                         if (has_future) {
[18:04:55.366]                           ns <- base::getNamespace("future")
[18:04:55.366]                           version <- ns[[".package"]][["version"]]
[18:04:55.366]                           if (is.null(version)) 
[18:04:55.366]                             version <- utils::packageVersion("future")
[18:04:55.366]                         }
[18:04:55.366]                         else {
[18:04:55.366]                           version <- NULL
[18:04:55.366]                         }
[18:04:55.366]                         if (!has_future || version < "1.8.0") {
[18:04:55.366]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.366]                             "", base::R.version$version.string), 
[18:04:55.366]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:55.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.366]                               "release", "version")], collapse = " "), 
[18:04:55.366]                             hostname = base::Sys.info()[["nodename"]])
[18:04:55.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.366]                             info)
[18:04:55.366]                           info <- base::paste(info, collapse = "; ")
[18:04:55.366]                           if (!has_future) {
[18:04:55.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.366]                               info)
[18:04:55.366]                           }
[18:04:55.366]                           else {
[18:04:55.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.366]                               info, version)
[18:04:55.366]                           }
[18:04:55.366]                           base::stop(msg)
[18:04:55.366]                         }
[18:04:55.366]                       })
[18:04:55.366]                     }
[18:04:55.366]                     base::local({
[18:04:55.366]                       for (pkg in "future") {
[18:04:55.366]                         base::loadNamespace(pkg)
[18:04:55.366]                         base::library(pkg, character.only = TRUE)
[18:04:55.366]                       }
[18:04:55.366]                     })
[18:04:55.366]                   }
[18:04:55.366]                   ...future.strategy.old <- future::plan("list")
[18:04:55.366]                   options(future.plan = NULL)
[18:04:55.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.366]                 }
[18:04:55.366]                 ...future.workdir <- getwd()
[18:04:55.366]             }
[18:04:55.366]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.366]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.366]         }
[18:04:55.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.366]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.366]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.366]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.366]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.366]             base::names(...future.oldOptions))
[18:04:55.366]     }
[18:04:55.366]     if (FALSE) {
[18:04:55.366]     }
[18:04:55.366]     else {
[18:04:55.366]         if (TRUE) {
[18:04:55.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.366]                 open = "w")
[18:04:55.366]         }
[18:04:55.366]         else {
[18:04:55.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.366]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.366]         }
[18:04:55.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.366]             base::sink(type = "output", split = FALSE)
[18:04:55.366]             base::close(...future.stdout)
[18:04:55.366]         }, add = TRUE)
[18:04:55.366]     }
[18:04:55.366]     ...future.frame <- base::sys.nframe()
[18:04:55.366]     ...future.conditions <- base::list()
[18:04:55.366]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.366]     if (FALSE) {
[18:04:55.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.366]     }
[18:04:55.366]     ...future.result <- base::tryCatch({
[18:04:55.366]         base::withCallingHandlers({
[18:04:55.366]             ...future.value <- base::withVisible(base::local(value(a) + 
[18:04:55.366]                 1))
[18:04:55.366]             future::FutureResult(value = ...future.value$value, 
[18:04:55.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.366]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.366]                     ...future.globalenv.names))
[18:04:55.366]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.366]         }, condition = base::local({
[18:04:55.366]             c <- base::c
[18:04:55.366]             inherits <- base::inherits
[18:04:55.366]             invokeRestart <- base::invokeRestart
[18:04:55.366]             length <- base::length
[18:04:55.366]             list <- base::list
[18:04:55.366]             seq.int <- base::seq.int
[18:04:55.366]             signalCondition <- base::signalCondition
[18:04:55.366]             sys.calls <- base::sys.calls
[18:04:55.366]             `[[` <- base::`[[`
[18:04:55.366]             `+` <- base::`+`
[18:04:55.366]             `<<-` <- base::`<<-`
[18:04:55.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.366]                   3L)]
[18:04:55.366]             }
[18:04:55.366]             function(cond) {
[18:04:55.366]                 is_error <- inherits(cond, "error")
[18:04:55.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.366]                   NULL)
[18:04:55.366]                 if (is_error) {
[18:04:55.366]                   sessionInformation <- function() {
[18:04:55.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.366]                       search = base::search(), system = base::Sys.info())
[18:04:55.366]                   }
[18:04:55.366]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.366]                     cond$call), session = sessionInformation(), 
[18:04:55.366]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.366]                   signalCondition(cond)
[18:04:55.366]                 }
[18:04:55.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.366]                 "immediateCondition"))) {
[18:04:55.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.366]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.366]                   if (TRUE && !signal) {
[18:04:55.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.366]                     {
[18:04:55.366]                       inherits <- base::inherits
[18:04:55.366]                       invokeRestart <- base::invokeRestart
[18:04:55.366]                       is.null <- base::is.null
[18:04:55.366]                       muffled <- FALSE
[18:04:55.366]                       if (inherits(cond, "message")) {
[18:04:55.366]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.366]                         if (muffled) 
[18:04:55.366]                           invokeRestart("muffleMessage")
[18:04:55.366]                       }
[18:04:55.366]                       else if (inherits(cond, "warning")) {
[18:04:55.366]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.366]                         if (muffled) 
[18:04:55.366]                           invokeRestart("muffleWarning")
[18:04:55.366]                       }
[18:04:55.366]                       else if (inherits(cond, "condition")) {
[18:04:55.366]                         if (!is.null(pattern)) {
[18:04:55.366]                           computeRestarts <- base::computeRestarts
[18:04:55.366]                           grepl <- base::grepl
[18:04:55.366]                           restarts <- computeRestarts(cond)
[18:04:55.366]                           for (restart in restarts) {
[18:04:55.366]                             name <- restart$name
[18:04:55.366]                             if (is.null(name)) 
[18:04:55.366]                               next
[18:04:55.366]                             if (!grepl(pattern, name)) 
[18:04:55.366]                               next
[18:04:55.366]                             invokeRestart(restart)
[18:04:55.366]                             muffled <- TRUE
[18:04:55.366]                             break
[18:04:55.366]                           }
[18:04:55.366]                         }
[18:04:55.366]                       }
[18:04:55.366]                       invisible(muffled)
[18:04:55.366]                     }
[18:04:55.366]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.366]                   }
[18:04:55.366]                 }
[18:04:55.366]                 else {
[18:04:55.366]                   if (TRUE) {
[18:04:55.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.366]                     {
[18:04:55.366]                       inherits <- base::inherits
[18:04:55.366]                       invokeRestart <- base::invokeRestart
[18:04:55.366]                       is.null <- base::is.null
[18:04:55.366]                       muffled <- FALSE
[18:04:55.366]                       if (inherits(cond, "message")) {
[18:04:55.366]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.366]                         if (muffled) 
[18:04:55.366]                           invokeRestart("muffleMessage")
[18:04:55.366]                       }
[18:04:55.366]                       else if (inherits(cond, "warning")) {
[18:04:55.366]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.366]                         if (muffled) 
[18:04:55.366]                           invokeRestart("muffleWarning")
[18:04:55.366]                       }
[18:04:55.366]                       else if (inherits(cond, "condition")) {
[18:04:55.366]                         if (!is.null(pattern)) {
[18:04:55.366]                           computeRestarts <- base::computeRestarts
[18:04:55.366]                           grepl <- base::grepl
[18:04:55.366]                           restarts <- computeRestarts(cond)
[18:04:55.366]                           for (restart in restarts) {
[18:04:55.366]                             name <- restart$name
[18:04:55.366]                             if (is.null(name)) 
[18:04:55.366]                               next
[18:04:55.366]                             if (!grepl(pattern, name)) 
[18:04:55.366]                               next
[18:04:55.366]                             invokeRestart(restart)
[18:04:55.366]                             muffled <- TRUE
[18:04:55.366]                             break
[18:04:55.366]                           }
[18:04:55.366]                         }
[18:04:55.366]                       }
[18:04:55.366]                       invisible(muffled)
[18:04:55.366]                     }
[18:04:55.366]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.366]                   }
[18:04:55.366]                 }
[18:04:55.366]             }
[18:04:55.366]         }))
[18:04:55.366]     }, error = function(ex) {
[18:04:55.366]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.366]                 ...future.rng), started = ...future.startTime, 
[18:04:55.366]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.366]             version = "1.8"), class = "FutureResult")
[18:04:55.366]     }, finally = {
[18:04:55.366]         if (!identical(...future.workdir, getwd())) 
[18:04:55.366]             setwd(...future.workdir)
[18:04:55.366]         {
[18:04:55.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.366]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.366]             }
[18:04:55.366]             base::options(...future.oldOptions)
[18:04:55.366]             if (.Platform$OS.type == "windows") {
[18:04:55.366]                 old_names <- names(...future.oldEnvVars)
[18:04:55.366]                 envs <- base::Sys.getenv()
[18:04:55.366]                 names <- names(envs)
[18:04:55.366]                 common <- intersect(names, old_names)
[18:04:55.366]                 added <- setdiff(names, old_names)
[18:04:55.366]                 removed <- setdiff(old_names, names)
[18:04:55.366]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.366]                   envs[common]]
[18:04:55.366]                 NAMES <- toupper(changed)
[18:04:55.366]                 args <- list()
[18:04:55.366]                 for (kk in seq_along(NAMES)) {
[18:04:55.366]                   name <- changed[[kk]]
[18:04:55.366]                   NAME <- NAMES[[kk]]
[18:04:55.366]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.366]                     next
[18:04:55.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.366]                 }
[18:04:55.366]                 NAMES <- toupper(added)
[18:04:55.366]                 for (kk in seq_along(NAMES)) {
[18:04:55.366]                   name <- added[[kk]]
[18:04:55.366]                   NAME <- NAMES[[kk]]
[18:04:55.366]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.366]                     next
[18:04:55.366]                   args[[name]] <- ""
[18:04:55.366]                 }
[18:04:55.366]                 NAMES <- toupper(removed)
[18:04:55.366]                 for (kk in seq_along(NAMES)) {
[18:04:55.366]                   name <- removed[[kk]]
[18:04:55.366]                   NAME <- NAMES[[kk]]
[18:04:55.366]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.366]                     next
[18:04:55.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.366]                 }
[18:04:55.366]                 if (length(args) > 0) 
[18:04:55.366]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.366]             }
[18:04:55.366]             else {
[18:04:55.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.366]             }
[18:04:55.366]             {
[18:04:55.366]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.366]                   0L) {
[18:04:55.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.366]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.366]                   base::options(opts)
[18:04:55.366]                 }
[18:04:55.366]                 {
[18:04:55.366]                   {
[18:04:55.366]                     NULL
[18:04:55.366]                     RNGkind("Mersenne-Twister")
[18:04:55.366]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.366]                       inherits = FALSE)
[18:04:55.366]                   }
[18:04:55.366]                   options(future.plan = NULL)
[18:04:55.366]                   if (is.na(NA_character_)) 
[18:04:55.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.366]                     .init = FALSE)
[18:04:55.366]                 }
[18:04:55.366]             }
[18:04:55.366]         }
[18:04:55.366]     })
[18:04:55.366]     if (TRUE) {
[18:04:55.366]         base::sink(type = "output", split = FALSE)
[18:04:55.366]         if (TRUE) {
[18:04:55.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.366]         }
[18:04:55.366]         else {
[18:04:55.366]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.366]         }
[18:04:55.366]         base::close(...future.stdout)
[18:04:55.366]         ...future.stdout <- NULL
[18:04:55.366]     }
[18:04:55.366]     ...future.result$conditions <- ...future.conditions
[18:04:55.366]     ...future.result$finished <- base::Sys.time()
[18:04:55.366]     ...future.result
[18:04:55.366] }
[18:04:55.370] assign_globals() ...
[18:04:55.370] List of 1
[18:04:55.370]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5b9576ead818> 
[18:04:55.370]  - attr(*, "where")=List of 1
[18:04:55.370]   ..$ a:<environment: R_EmptyEnv> 
[18:04:55.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.370]  - attr(*, "resolved")= logi TRUE
[18:04:55.370]  - attr(*, "total_size")= num 10592
[18:04:55.370]  - attr(*, "already-done")= logi TRUE
[18:04:55.377] - copied ‘a’ to environment
[18:04:55.377] assign_globals() ... done
[18:04:55.378] plan(): Setting new future strategy stack:
[18:04:55.378] List of future strategies:
[18:04:55.378] 1. sequential:
[18:04:55.378]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.378]    - tweaked: FALSE
[18:04:55.378]    - call: NULL
[18:04:55.379] plan(): nbrOfWorkers() = 1
[18:04:55.381] plan(): Setting new future strategy stack:
[18:04:55.381] List of future strategies:
[18:04:55.381] 1. sequential:
[18:04:55.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.381]    - tweaked: FALSE
[18:04:55.381]    - call: plan(strategy)
[18:04:55.383] plan(): nbrOfWorkers() = 1
[18:04:55.383] SequentialFuture started (and completed)
[18:04:55.383] - Launch lazy future ... done
[18:04:55.383] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.384] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.385] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.386] 
[18:04:55.386] Searching for globals ... DONE
[18:04:55.386] - globals: [0] <none>
[18:04:55.387] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.387] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.388] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.390] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:55.390] Searching for globals ... DONE
[18:04:55.390] Resolving globals: TRUE
[18:04:55.391] Resolving any globals that are futures ...
[18:04:55.391] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:55.391] Resolving any globals that are futures ... DONE
[18:04:55.392] Resolving futures part of globals (recursively) ...
[18:04:55.392] resolve() on list ...
[18:04:55.393]  recursive: 99
[18:04:55.393]  length: 1
[18:04:55.393]  elements: ‘a’
[18:04:55.393] run() for ‘Future’ ...
[18:04:55.393] - state: ‘created’
[18:04:55.394] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.394] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.395] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.395]   - Field: ‘label’
[18:04:55.395]   - Field: ‘local’
[18:04:55.395]   - Field: ‘owner’
[18:04:55.395]   - Field: ‘envir’
[18:04:55.396]   - Field: ‘packages’
[18:04:55.396]   - Field: ‘gc’
[18:04:55.396]   - Field: ‘conditions’
[18:04:55.396]   - Field: ‘expr’
[18:04:55.396]   - Field: ‘uuid’
[18:04:55.397]   - Field: ‘seed’
[18:04:55.397]   - Field: ‘version’
[18:04:55.397]   - Field: ‘result’
[18:04:55.397]   - Field: ‘asynchronous’
[18:04:55.397]   - Field: ‘calls’
[18:04:55.398]   - Field: ‘globals’
[18:04:55.398]   - Field: ‘stdout’
[18:04:55.398]   - Field: ‘earlySignal’
[18:04:55.398]   - Field: ‘lazy’
[18:04:55.399]   - Field: ‘state’
[18:04:55.399] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.399] - Launch lazy future ...
[18:04:55.399] Packages needed by the future expression (n = 0): <none>
[18:04:55.400] Packages needed by future strategies (n = 0): <none>
[18:04:55.401] {
[18:04:55.401]     {
[18:04:55.401]         {
[18:04:55.401]             ...future.startTime <- base::Sys.time()
[18:04:55.401]             {
[18:04:55.401]                 {
[18:04:55.401]                   {
[18:04:55.401]                     base::local({
[18:04:55.401]                       has_future <- base::requireNamespace("future", 
[18:04:55.401]                         quietly = TRUE)
[18:04:55.401]                       if (has_future) {
[18:04:55.401]                         ns <- base::getNamespace("future")
[18:04:55.401]                         version <- ns[[".package"]][["version"]]
[18:04:55.401]                         if (is.null(version)) 
[18:04:55.401]                           version <- utils::packageVersion("future")
[18:04:55.401]                       }
[18:04:55.401]                       else {
[18:04:55.401]                         version <- NULL
[18:04:55.401]                       }
[18:04:55.401]                       if (!has_future || version < "1.8.0") {
[18:04:55.401]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.401]                           "", base::R.version$version.string), 
[18:04:55.401]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.401]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.401]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.401]                             "release", "version")], collapse = " "), 
[18:04:55.401]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.401]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.401]                           info)
[18:04:55.401]                         info <- base::paste(info, collapse = "; ")
[18:04:55.401]                         if (!has_future) {
[18:04:55.401]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.401]                             info)
[18:04:55.401]                         }
[18:04:55.401]                         else {
[18:04:55.401]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.401]                             info, version)
[18:04:55.401]                         }
[18:04:55.401]                         base::stop(msg)
[18:04:55.401]                       }
[18:04:55.401]                     })
[18:04:55.401]                   }
[18:04:55.401]                   ...future.strategy.old <- future::plan("list")
[18:04:55.401]                   options(future.plan = NULL)
[18:04:55.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.401]                 }
[18:04:55.401]                 ...future.workdir <- getwd()
[18:04:55.401]             }
[18:04:55.401]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.401]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.401]         }
[18:04:55.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.401]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.401]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.401]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.401]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.401]             base::names(...future.oldOptions))
[18:04:55.401]     }
[18:04:55.401]     if (FALSE) {
[18:04:55.401]     }
[18:04:55.401]     else {
[18:04:55.401]         if (TRUE) {
[18:04:55.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.401]                 open = "w")
[18:04:55.401]         }
[18:04:55.401]         else {
[18:04:55.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.401]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.401]         }
[18:04:55.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.401]             base::sink(type = "output", split = FALSE)
[18:04:55.401]             base::close(...future.stdout)
[18:04:55.401]         }, add = TRUE)
[18:04:55.401]     }
[18:04:55.401]     ...future.frame <- base::sys.nframe()
[18:04:55.401]     ...future.conditions <- base::list()
[18:04:55.401]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.401]     if (FALSE) {
[18:04:55.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.401]     }
[18:04:55.401]     ...future.result <- base::tryCatch({
[18:04:55.401]         base::withCallingHandlers({
[18:04:55.401]             ...future.value <- base::withVisible(base::local(1))
[18:04:55.401]             future::FutureResult(value = ...future.value$value, 
[18:04:55.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.401]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.401]                     ...future.globalenv.names))
[18:04:55.401]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.401]         }, condition = base::local({
[18:04:55.401]             c <- base::c
[18:04:55.401]             inherits <- base::inherits
[18:04:55.401]             invokeRestart <- base::invokeRestart
[18:04:55.401]             length <- base::length
[18:04:55.401]             list <- base::list
[18:04:55.401]             seq.int <- base::seq.int
[18:04:55.401]             signalCondition <- base::signalCondition
[18:04:55.401]             sys.calls <- base::sys.calls
[18:04:55.401]             `[[` <- base::`[[`
[18:04:55.401]             `+` <- base::`+`
[18:04:55.401]             `<<-` <- base::`<<-`
[18:04:55.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.401]                   3L)]
[18:04:55.401]             }
[18:04:55.401]             function(cond) {
[18:04:55.401]                 is_error <- inherits(cond, "error")
[18:04:55.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.401]                   NULL)
[18:04:55.401]                 if (is_error) {
[18:04:55.401]                   sessionInformation <- function() {
[18:04:55.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.401]                       search = base::search(), system = base::Sys.info())
[18:04:55.401]                   }
[18:04:55.401]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.401]                     cond$call), session = sessionInformation(), 
[18:04:55.401]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.401]                   signalCondition(cond)
[18:04:55.401]                 }
[18:04:55.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.401]                 "immediateCondition"))) {
[18:04:55.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.401]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.401]                   if (TRUE && !signal) {
[18:04:55.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.401]                     {
[18:04:55.401]                       inherits <- base::inherits
[18:04:55.401]                       invokeRestart <- base::invokeRestart
[18:04:55.401]                       is.null <- base::is.null
[18:04:55.401]                       muffled <- FALSE
[18:04:55.401]                       if (inherits(cond, "message")) {
[18:04:55.401]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.401]                         if (muffled) 
[18:04:55.401]                           invokeRestart("muffleMessage")
[18:04:55.401]                       }
[18:04:55.401]                       else if (inherits(cond, "warning")) {
[18:04:55.401]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.401]                         if (muffled) 
[18:04:55.401]                           invokeRestart("muffleWarning")
[18:04:55.401]                       }
[18:04:55.401]                       else if (inherits(cond, "condition")) {
[18:04:55.401]                         if (!is.null(pattern)) {
[18:04:55.401]                           computeRestarts <- base::computeRestarts
[18:04:55.401]                           grepl <- base::grepl
[18:04:55.401]                           restarts <- computeRestarts(cond)
[18:04:55.401]                           for (restart in restarts) {
[18:04:55.401]                             name <- restart$name
[18:04:55.401]                             if (is.null(name)) 
[18:04:55.401]                               next
[18:04:55.401]                             if (!grepl(pattern, name)) 
[18:04:55.401]                               next
[18:04:55.401]                             invokeRestart(restart)
[18:04:55.401]                             muffled <- TRUE
[18:04:55.401]                             break
[18:04:55.401]                           }
[18:04:55.401]                         }
[18:04:55.401]                       }
[18:04:55.401]                       invisible(muffled)
[18:04:55.401]                     }
[18:04:55.401]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.401]                   }
[18:04:55.401]                 }
[18:04:55.401]                 else {
[18:04:55.401]                   if (TRUE) {
[18:04:55.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.401]                     {
[18:04:55.401]                       inherits <- base::inherits
[18:04:55.401]                       invokeRestart <- base::invokeRestart
[18:04:55.401]                       is.null <- base::is.null
[18:04:55.401]                       muffled <- FALSE
[18:04:55.401]                       if (inherits(cond, "message")) {
[18:04:55.401]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.401]                         if (muffled) 
[18:04:55.401]                           invokeRestart("muffleMessage")
[18:04:55.401]                       }
[18:04:55.401]                       else if (inherits(cond, "warning")) {
[18:04:55.401]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.401]                         if (muffled) 
[18:04:55.401]                           invokeRestart("muffleWarning")
[18:04:55.401]                       }
[18:04:55.401]                       else if (inherits(cond, "condition")) {
[18:04:55.401]                         if (!is.null(pattern)) {
[18:04:55.401]                           computeRestarts <- base::computeRestarts
[18:04:55.401]                           grepl <- base::grepl
[18:04:55.401]                           restarts <- computeRestarts(cond)
[18:04:55.401]                           for (restart in restarts) {
[18:04:55.401]                             name <- restart$name
[18:04:55.401]                             if (is.null(name)) 
[18:04:55.401]                               next
[18:04:55.401]                             if (!grepl(pattern, name)) 
[18:04:55.401]                               next
[18:04:55.401]                             invokeRestart(restart)
[18:04:55.401]                             muffled <- TRUE
[18:04:55.401]                             break
[18:04:55.401]                           }
[18:04:55.401]                         }
[18:04:55.401]                       }
[18:04:55.401]                       invisible(muffled)
[18:04:55.401]                     }
[18:04:55.401]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.401]                   }
[18:04:55.401]                 }
[18:04:55.401]             }
[18:04:55.401]         }))
[18:04:55.401]     }, error = function(ex) {
[18:04:55.401]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.401]                 ...future.rng), started = ...future.startTime, 
[18:04:55.401]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.401]             version = "1.8"), class = "FutureResult")
[18:04:55.401]     }, finally = {
[18:04:55.401]         if (!identical(...future.workdir, getwd())) 
[18:04:55.401]             setwd(...future.workdir)
[18:04:55.401]         {
[18:04:55.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.401]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.401]             }
[18:04:55.401]             base::options(...future.oldOptions)
[18:04:55.401]             if (.Platform$OS.type == "windows") {
[18:04:55.401]                 old_names <- names(...future.oldEnvVars)
[18:04:55.401]                 envs <- base::Sys.getenv()
[18:04:55.401]                 names <- names(envs)
[18:04:55.401]                 common <- intersect(names, old_names)
[18:04:55.401]                 added <- setdiff(names, old_names)
[18:04:55.401]                 removed <- setdiff(old_names, names)
[18:04:55.401]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.401]                   envs[common]]
[18:04:55.401]                 NAMES <- toupper(changed)
[18:04:55.401]                 args <- list()
[18:04:55.401]                 for (kk in seq_along(NAMES)) {
[18:04:55.401]                   name <- changed[[kk]]
[18:04:55.401]                   NAME <- NAMES[[kk]]
[18:04:55.401]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.401]                     next
[18:04:55.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.401]                 }
[18:04:55.401]                 NAMES <- toupper(added)
[18:04:55.401]                 for (kk in seq_along(NAMES)) {
[18:04:55.401]                   name <- added[[kk]]
[18:04:55.401]                   NAME <- NAMES[[kk]]
[18:04:55.401]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.401]                     next
[18:04:55.401]                   args[[name]] <- ""
[18:04:55.401]                 }
[18:04:55.401]                 NAMES <- toupper(removed)
[18:04:55.401]                 for (kk in seq_along(NAMES)) {
[18:04:55.401]                   name <- removed[[kk]]
[18:04:55.401]                   NAME <- NAMES[[kk]]
[18:04:55.401]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.401]                     next
[18:04:55.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.401]                 }
[18:04:55.401]                 if (length(args) > 0) 
[18:04:55.401]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.401]             }
[18:04:55.401]             else {
[18:04:55.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.401]             }
[18:04:55.401]             {
[18:04:55.401]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.401]                   0L) {
[18:04:55.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.401]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.401]                   base::options(opts)
[18:04:55.401]                 }
[18:04:55.401]                 {
[18:04:55.401]                   {
[18:04:55.401]                     NULL
[18:04:55.401]                     RNGkind("Mersenne-Twister")
[18:04:55.401]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.401]                       inherits = FALSE)
[18:04:55.401]                   }
[18:04:55.401]                   options(future.plan = NULL)
[18:04:55.401]                   if (is.na(NA_character_)) 
[18:04:55.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.401]                     .init = FALSE)
[18:04:55.401]                 }
[18:04:55.401]             }
[18:04:55.401]         }
[18:04:55.401]     })
[18:04:55.401]     if (TRUE) {
[18:04:55.401]         base::sink(type = "output", split = FALSE)
[18:04:55.401]         if (TRUE) {
[18:04:55.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.401]         }
[18:04:55.401]         else {
[18:04:55.401]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.401]         }
[18:04:55.401]         base::close(...future.stdout)
[18:04:55.401]         ...future.stdout <- NULL
[18:04:55.401]     }
[18:04:55.401]     ...future.result$conditions <- ...future.conditions
[18:04:55.401]     ...future.result$finished <- base::Sys.time()
[18:04:55.401]     ...future.result
[18:04:55.401] }
[18:04:55.404] plan(): Setting new future strategy stack:
[18:04:55.404] List of future strategies:
[18:04:55.404] 1. sequential:
[18:04:55.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.404]    - tweaked: FALSE
[18:04:55.404]    - call: NULL
[18:04:55.405] plan(): nbrOfWorkers() = 1
[18:04:55.407] plan(): Setting new future strategy stack:
[18:04:55.408] List of future strategies:
[18:04:55.408] 1. sequential:
[18:04:55.408]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.408]    - tweaked: FALSE
[18:04:55.408]    - call: plan(strategy)
[18:04:55.409] plan(): nbrOfWorkers() = 1
[18:04:55.409] SequentialFuture started (and completed)
[18:04:55.409] - Launch lazy future ... done
[18:04:55.410] run() for ‘SequentialFuture’ ... done
[18:04:55.410] resolved() for ‘SequentialFuture’ ...
[18:04:55.410] - state: ‘finished’
[18:04:55.410] - run: TRUE
[18:04:55.410] - result: ‘FutureResult’
[18:04:55.411] resolved() for ‘SequentialFuture’ ... done
[18:04:55.411] Future #1
[18:04:55.411] resolved() for ‘SequentialFuture’ ...
[18:04:55.411] - state: ‘finished’
[18:04:55.412] - run: TRUE
[18:04:55.412] - result: ‘FutureResult’
[18:04:55.412] resolved() for ‘SequentialFuture’ ... done
[18:04:55.413] A SequentialFuture was resolved
[18:04:55.413]  length: 0 (resolved future 1)
[18:04:55.413] resolve() on list ... DONE
[18:04:55.413] - globals: [1] ‘a’
[18:04:55.414] Resolving futures part of globals (recursively) ... DONE
[18:04:55.415] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[18:04:55.416] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[18:04:55.417] - globals: [1] ‘a’
[18:04:55.417] - packages: [1] ‘future’
[18:04:55.417] getGlobalsAndPackages() ... DONE
[18:04:55.418] run() for ‘Future’ ...
[18:04:55.418] - state: ‘created’
[18:04:55.418] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.419] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.419] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.419]   - Field: ‘label’
[18:04:55.420]   - Field: ‘local’
[18:04:55.420]   - Field: ‘owner’
[18:04:55.420]   - Field: ‘envir’
[18:04:55.420]   - Field: ‘packages’
[18:04:55.420]   - Field: ‘gc’
[18:04:55.421]   - Field: ‘conditions’
[18:04:55.421]   - Field: ‘expr’
[18:04:55.421]   - Field: ‘uuid’
[18:04:55.421]   - Field: ‘seed’
[18:04:55.421]   - Field: ‘version’
[18:04:55.422]   - Field: ‘result’
[18:04:55.422]   - Field: ‘asynchronous’
[18:04:55.422]   - Field: ‘calls’
[18:04:55.422]   - Field: ‘globals’
[18:04:55.422]   - Field: ‘stdout’
[18:04:55.423]   - Field: ‘earlySignal’
[18:04:55.423]   - Field: ‘lazy’
[18:04:55.423]   - Field: ‘state’
[18:04:55.423] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.423] - Launch lazy future ...
[18:04:55.424] Packages needed by the future expression (n = 1): ‘future’
[18:04:55.424] Packages needed by future strategies (n = 0): <none>
[18:04:55.428] {
[18:04:55.428]     {
[18:04:55.428]         {
[18:04:55.428]             ...future.startTime <- base::Sys.time()
[18:04:55.428]             {
[18:04:55.428]                 {
[18:04:55.428]                   {
[18:04:55.428]                     {
[18:04:55.428]                       base::local({
[18:04:55.428]                         has_future <- base::requireNamespace("future", 
[18:04:55.428]                           quietly = TRUE)
[18:04:55.428]                         if (has_future) {
[18:04:55.428]                           ns <- base::getNamespace("future")
[18:04:55.428]                           version <- ns[[".package"]][["version"]]
[18:04:55.428]                           if (is.null(version)) 
[18:04:55.428]                             version <- utils::packageVersion("future")
[18:04:55.428]                         }
[18:04:55.428]                         else {
[18:04:55.428]                           version <- NULL
[18:04:55.428]                         }
[18:04:55.428]                         if (!has_future || version < "1.8.0") {
[18:04:55.428]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.428]                             "", base::R.version$version.string), 
[18:04:55.428]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:55.428]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.428]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.428]                               "release", "version")], collapse = " "), 
[18:04:55.428]                             hostname = base::Sys.info()[["nodename"]])
[18:04:55.428]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.428]                             info)
[18:04:55.428]                           info <- base::paste(info, collapse = "; ")
[18:04:55.428]                           if (!has_future) {
[18:04:55.428]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.428]                               info)
[18:04:55.428]                           }
[18:04:55.428]                           else {
[18:04:55.428]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.428]                               info, version)
[18:04:55.428]                           }
[18:04:55.428]                           base::stop(msg)
[18:04:55.428]                         }
[18:04:55.428]                       })
[18:04:55.428]                     }
[18:04:55.428]                     base::local({
[18:04:55.428]                       for (pkg in "future") {
[18:04:55.428]                         base::loadNamespace(pkg)
[18:04:55.428]                         base::library(pkg, character.only = TRUE)
[18:04:55.428]                       }
[18:04:55.428]                     })
[18:04:55.428]                   }
[18:04:55.428]                   ...future.strategy.old <- future::plan("list")
[18:04:55.428]                   options(future.plan = NULL)
[18:04:55.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.428]                 }
[18:04:55.428]                 ...future.workdir <- getwd()
[18:04:55.428]             }
[18:04:55.428]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.428]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.428]         }
[18:04:55.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.428]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.428]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.428]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.428]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.428]             base::names(...future.oldOptions))
[18:04:55.428]     }
[18:04:55.428]     if (FALSE) {
[18:04:55.428]     }
[18:04:55.428]     else {
[18:04:55.428]         if (TRUE) {
[18:04:55.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.428]                 open = "w")
[18:04:55.428]         }
[18:04:55.428]         else {
[18:04:55.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.428]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.428]         }
[18:04:55.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.428]             base::sink(type = "output", split = FALSE)
[18:04:55.428]             base::close(...future.stdout)
[18:04:55.428]         }, add = TRUE)
[18:04:55.428]     }
[18:04:55.428]     ...future.frame <- base::sys.nframe()
[18:04:55.428]     ...future.conditions <- base::list()
[18:04:55.428]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.428]     if (FALSE) {
[18:04:55.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.428]     }
[18:04:55.428]     ...future.result <- base::tryCatch({
[18:04:55.428]         base::withCallingHandlers({
[18:04:55.428]             ...future.value <- base::withVisible(base::local(value(a) + 
[18:04:55.428]                 1))
[18:04:55.428]             future::FutureResult(value = ...future.value$value, 
[18:04:55.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.428]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.428]                     ...future.globalenv.names))
[18:04:55.428]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.428]         }, condition = base::local({
[18:04:55.428]             c <- base::c
[18:04:55.428]             inherits <- base::inherits
[18:04:55.428]             invokeRestart <- base::invokeRestart
[18:04:55.428]             length <- base::length
[18:04:55.428]             list <- base::list
[18:04:55.428]             seq.int <- base::seq.int
[18:04:55.428]             signalCondition <- base::signalCondition
[18:04:55.428]             sys.calls <- base::sys.calls
[18:04:55.428]             `[[` <- base::`[[`
[18:04:55.428]             `+` <- base::`+`
[18:04:55.428]             `<<-` <- base::`<<-`
[18:04:55.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.428]                   3L)]
[18:04:55.428]             }
[18:04:55.428]             function(cond) {
[18:04:55.428]                 is_error <- inherits(cond, "error")
[18:04:55.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.428]                   NULL)
[18:04:55.428]                 if (is_error) {
[18:04:55.428]                   sessionInformation <- function() {
[18:04:55.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.428]                       search = base::search(), system = base::Sys.info())
[18:04:55.428]                   }
[18:04:55.428]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.428]                     cond$call), session = sessionInformation(), 
[18:04:55.428]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.428]                   signalCondition(cond)
[18:04:55.428]                 }
[18:04:55.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.428]                 "immediateCondition"))) {
[18:04:55.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.428]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.428]                   if (TRUE && !signal) {
[18:04:55.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.428]                     {
[18:04:55.428]                       inherits <- base::inherits
[18:04:55.428]                       invokeRestart <- base::invokeRestart
[18:04:55.428]                       is.null <- base::is.null
[18:04:55.428]                       muffled <- FALSE
[18:04:55.428]                       if (inherits(cond, "message")) {
[18:04:55.428]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.428]                         if (muffled) 
[18:04:55.428]                           invokeRestart("muffleMessage")
[18:04:55.428]                       }
[18:04:55.428]                       else if (inherits(cond, "warning")) {
[18:04:55.428]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.428]                         if (muffled) 
[18:04:55.428]                           invokeRestart("muffleWarning")
[18:04:55.428]                       }
[18:04:55.428]                       else if (inherits(cond, "condition")) {
[18:04:55.428]                         if (!is.null(pattern)) {
[18:04:55.428]                           computeRestarts <- base::computeRestarts
[18:04:55.428]                           grepl <- base::grepl
[18:04:55.428]                           restarts <- computeRestarts(cond)
[18:04:55.428]                           for (restart in restarts) {
[18:04:55.428]                             name <- restart$name
[18:04:55.428]                             if (is.null(name)) 
[18:04:55.428]                               next
[18:04:55.428]                             if (!grepl(pattern, name)) 
[18:04:55.428]                               next
[18:04:55.428]                             invokeRestart(restart)
[18:04:55.428]                             muffled <- TRUE
[18:04:55.428]                             break
[18:04:55.428]                           }
[18:04:55.428]                         }
[18:04:55.428]                       }
[18:04:55.428]                       invisible(muffled)
[18:04:55.428]                     }
[18:04:55.428]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.428]                   }
[18:04:55.428]                 }
[18:04:55.428]                 else {
[18:04:55.428]                   if (TRUE) {
[18:04:55.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.428]                     {
[18:04:55.428]                       inherits <- base::inherits
[18:04:55.428]                       invokeRestart <- base::invokeRestart
[18:04:55.428]                       is.null <- base::is.null
[18:04:55.428]                       muffled <- FALSE
[18:04:55.428]                       if (inherits(cond, "message")) {
[18:04:55.428]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.428]                         if (muffled) 
[18:04:55.428]                           invokeRestart("muffleMessage")
[18:04:55.428]                       }
[18:04:55.428]                       else if (inherits(cond, "warning")) {
[18:04:55.428]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.428]                         if (muffled) 
[18:04:55.428]                           invokeRestart("muffleWarning")
[18:04:55.428]                       }
[18:04:55.428]                       else if (inherits(cond, "condition")) {
[18:04:55.428]                         if (!is.null(pattern)) {
[18:04:55.428]                           computeRestarts <- base::computeRestarts
[18:04:55.428]                           grepl <- base::grepl
[18:04:55.428]                           restarts <- computeRestarts(cond)
[18:04:55.428]                           for (restart in restarts) {
[18:04:55.428]                             name <- restart$name
[18:04:55.428]                             if (is.null(name)) 
[18:04:55.428]                               next
[18:04:55.428]                             if (!grepl(pattern, name)) 
[18:04:55.428]                               next
[18:04:55.428]                             invokeRestart(restart)
[18:04:55.428]                             muffled <- TRUE
[18:04:55.428]                             break
[18:04:55.428]                           }
[18:04:55.428]                         }
[18:04:55.428]                       }
[18:04:55.428]                       invisible(muffled)
[18:04:55.428]                     }
[18:04:55.428]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.428]                   }
[18:04:55.428]                 }
[18:04:55.428]             }
[18:04:55.428]         }))
[18:04:55.428]     }, error = function(ex) {
[18:04:55.428]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.428]                 ...future.rng), started = ...future.startTime, 
[18:04:55.428]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.428]             version = "1.8"), class = "FutureResult")
[18:04:55.428]     }, finally = {
[18:04:55.428]         if (!identical(...future.workdir, getwd())) 
[18:04:55.428]             setwd(...future.workdir)
[18:04:55.428]         {
[18:04:55.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.428]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.428]             }
[18:04:55.428]             base::options(...future.oldOptions)
[18:04:55.428]             if (.Platform$OS.type == "windows") {
[18:04:55.428]                 old_names <- names(...future.oldEnvVars)
[18:04:55.428]                 envs <- base::Sys.getenv()
[18:04:55.428]                 names <- names(envs)
[18:04:55.428]                 common <- intersect(names, old_names)
[18:04:55.428]                 added <- setdiff(names, old_names)
[18:04:55.428]                 removed <- setdiff(old_names, names)
[18:04:55.428]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.428]                   envs[common]]
[18:04:55.428]                 NAMES <- toupper(changed)
[18:04:55.428]                 args <- list()
[18:04:55.428]                 for (kk in seq_along(NAMES)) {
[18:04:55.428]                   name <- changed[[kk]]
[18:04:55.428]                   NAME <- NAMES[[kk]]
[18:04:55.428]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.428]                     next
[18:04:55.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.428]                 }
[18:04:55.428]                 NAMES <- toupper(added)
[18:04:55.428]                 for (kk in seq_along(NAMES)) {
[18:04:55.428]                   name <- added[[kk]]
[18:04:55.428]                   NAME <- NAMES[[kk]]
[18:04:55.428]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.428]                     next
[18:04:55.428]                   args[[name]] <- ""
[18:04:55.428]                 }
[18:04:55.428]                 NAMES <- toupper(removed)
[18:04:55.428]                 for (kk in seq_along(NAMES)) {
[18:04:55.428]                   name <- removed[[kk]]
[18:04:55.428]                   NAME <- NAMES[[kk]]
[18:04:55.428]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.428]                     next
[18:04:55.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.428]                 }
[18:04:55.428]                 if (length(args) > 0) 
[18:04:55.428]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.428]             }
[18:04:55.428]             else {
[18:04:55.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.428]             }
[18:04:55.428]             {
[18:04:55.428]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.428]                   0L) {
[18:04:55.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.428]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.428]                   base::options(opts)
[18:04:55.428]                 }
[18:04:55.428]                 {
[18:04:55.428]                   {
[18:04:55.428]                     NULL
[18:04:55.428]                     RNGkind("Mersenne-Twister")
[18:04:55.428]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.428]                       inherits = FALSE)
[18:04:55.428]                   }
[18:04:55.428]                   options(future.plan = NULL)
[18:04:55.428]                   if (is.na(NA_character_)) 
[18:04:55.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.428]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.428]                     .init = FALSE)
[18:04:55.428]                 }
[18:04:55.428]             }
[18:04:55.428]         }
[18:04:55.428]     })
[18:04:55.428]     if (TRUE) {
[18:04:55.428]         base::sink(type = "output", split = FALSE)
[18:04:55.428]         if (TRUE) {
[18:04:55.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.428]         }
[18:04:55.428]         else {
[18:04:55.428]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.428]         }
[18:04:55.428]         base::close(...future.stdout)
[18:04:55.428]         ...future.stdout <- NULL
[18:04:55.428]     }
[18:04:55.428]     ...future.result$conditions <- ...future.conditions
[18:04:55.428]     ...future.result$finished <- base::Sys.time()
[18:04:55.428]     ...future.result
[18:04:55.428] }
[18:04:55.431] assign_globals() ...
[18:04:55.431] List of 1
[18:04:55.431]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5b9576bce9c0> 
[18:04:55.431]  - attr(*, "where")=List of 1
[18:04:55.431]   ..$ a:<environment: R_EmptyEnv> 
[18:04:55.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.431]  - attr(*, "resolved")= logi TRUE
[18:04:55.431]  - attr(*, "total_size")= num 10592
[18:04:55.431]  - attr(*, "already-done")= logi TRUE
[18:04:55.437] - copied ‘a’ to environment
[18:04:55.437] assign_globals() ... done
[18:04:55.438] plan(): Setting new future strategy stack:
[18:04:55.438] List of future strategies:
[18:04:55.438] 1. sequential:
[18:04:55.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.438]    - tweaked: FALSE
[18:04:55.438]    - call: NULL
[18:04:55.439] plan(): nbrOfWorkers() = 1
[18:04:55.441] plan(): Setting new future strategy stack:
[18:04:55.441] List of future strategies:
[18:04:55.441] 1. sequential:
[18:04:55.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.441]    - tweaked: FALSE
[18:04:55.441]    - call: plan(strategy)
[18:04:55.442] plan(): nbrOfWorkers() = 1
[18:04:55.442] SequentialFuture started (and completed)
[18:04:55.443] - Launch lazy future ... done
[18:04:55.443] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.444] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.444] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:55.446] - globals found: [2] ‘{’, ‘pkg’
[18:04:55.446] Searching for globals ... DONE
[18:04:55.447] Resolving globals: TRUE
[18:04:55.447] Resolving any globals that are futures ...
[18:04:55.447] - globals: [2] ‘{’, ‘pkg’
[18:04:55.447] Resolving any globals that are futures ... DONE
[18:04:55.448] Resolving futures part of globals (recursively) ...
[18:04:55.448] resolve() on list ...
[18:04:55.449]  recursive: 99
[18:04:55.449]  length: 1
[18:04:55.449]  elements: ‘pkg’
[18:04:55.449]  length: 0 (resolved future 1)
[18:04:55.450] resolve() on list ... DONE
[18:04:55.450] - globals: [1] ‘pkg’
[18:04:55.450] Resolving futures part of globals (recursively) ... DONE
[18:04:55.450] The total size of the 1 globals is 112 bytes (112 bytes)
[18:04:55.451] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[18:04:55.451] - globals: [1] ‘pkg’
[18:04:55.452] 
[18:04:55.452] getGlobalsAndPackages() ... DONE
[18:04:55.452] Packages needed by the future expression (n = 0): <none>
[18:04:55.453] Packages needed by future strategies (n = 0): <none>
[18:04:55.454] {
[18:04:55.454]     {
[18:04:55.454]         {
[18:04:55.454]             ...future.startTime <- base::Sys.time()
[18:04:55.454]             {
[18:04:55.454]                 {
[18:04:55.454]                   {
[18:04:55.454]                     base::local({
[18:04:55.454]                       has_future <- base::requireNamespace("future", 
[18:04:55.454]                         quietly = TRUE)
[18:04:55.454]                       if (has_future) {
[18:04:55.454]                         ns <- base::getNamespace("future")
[18:04:55.454]                         version <- ns[[".package"]][["version"]]
[18:04:55.454]                         if (is.null(version)) 
[18:04:55.454]                           version <- utils::packageVersion("future")
[18:04:55.454]                       }
[18:04:55.454]                       else {
[18:04:55.454]                         version <- NULL
[18:04:55.454]                       }
[18:04:55.454]                       if (!has_future || version < "1.8.0") {
[18:04:55.454]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.454]                           "", base::R.version$version.string), 
[18:04:55.454]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.454]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.454]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.454]                             "release", "version")], collapse = " "), 
[18:04:55.454]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.454]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.454]                           info)
[18:04:55.454]                         info <- base::paste(info, collapse = "; ")
[18:04:55.454]                         if (!has_future) {
[18:04:55.454]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.454]                             info)
[18:04:55.454]                         }
[18:04:55.454]                         else {
[18:04:55.454]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.454]                             info, version)
[18:04:55.454]                         }
[18:04:55.454]                         base::stop(msg)
[18:04:55.454]                       }
[18:04:55.454]                     })
[18:04:55.454]                   }
[18:04:55.454]                   ...future.strategy.old <- future::plan("list")
[18:04:55.454]                   options(future.plan = NULL)
[18:04:55.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.454]                 }
[18:04:55.454]                 ...future.workdir <- getwd()
[18:04:55.454]             }
[18:04:55.454]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.454]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.454]         }
[18:04:55.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.454]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:55.454]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.454]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.454]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.454]             base::names(...future.oldOptions))
[18:04:55.454]     }
[18:04:55.454]     if (FALSE) {
[18:04:55.454]     }
[18:04:55.454]     else {
[18:04:55.454]         if (TRUE) {
[18:04:55.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.454]                 open = "w")
[18:04:55.454]         }
[18:04:55.454]         else {
[18:04:55.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.454]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.454]         }
[18:04:55.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.454]             base::sink(type = "output", split = FALSE)
[18:04:55.454]             base::close(...future.stdout)
[18:04:55.454]         }, add = TRUE)
[18:04:55.454]     }
[18:04:55.454]     ...future.frame <- base::sys.nframe()
[18:04:55.454]     ...future.conditions <- base::list()
[18:04:55.454]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.454]     if (FALSE) {
[18:04:55.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.454]     }
[18:04:55.454]     ...future.result <- base::tryCatch({
[18:04:55.454]         base::withCallingHandlers({
[18:04:55.454]             ...future.value <- base::withVisible(base::local({
[18:04:55.454]                 pkg
[18:04:55.454]             }))
[18:04:55.454]             future::FutureResult(value = ...future.value$value, 
[18:04:55.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.454]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.454]                     ...future.globalenv.names))
[18:04:55.454]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.454]         }, condition = base::local({
[18:04:55.454]             c <- base::c
[18:04:55.454]             inherits <- base::inherits
[18:04:55.454]             invokeRestart <- base::invokeRestart
[18:04:55.454]             length <- base::length
[18:04:55.454]             list <- base::list
[18:04:55.454]             seq.int <- base::seq.int
[18:04:55.454]             signalCondition <- base::signalCondition
[18:04:55.454]             sys.calls <- base::sys.calls
[18:04:55.454]             `[[` <- base::`[[`
[18:04:55.454]             `+` <- base::`+`
[18:04:55.454]             `<<-` <- base::`<<-`
[18:04:55.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.454]                   3L)]
[18:04:55.454]             }
[18:04:55.454]             function(cond) {
[18:04:55.454]                 is_error <- inherits(cond, "error")
[18:04:55.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.454]                   NULL)
[18:04:55.454]                 if (is_error) {
[18:04:55.454]                   sessionInformation <- function() {
[18:04:55.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.454]                       search = base::search(), system = base::Sys.info())
[18:04:55.454]                   }
[18:04:55.454]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.454]                     cond$call), session = sessionInformation(), 
[18:04:55.454]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.454]                   signalCondition(cond)
[18:04:55.454]                 }
[18:04:55.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.454]                 "immediateCondition"))) {
[18:04:55.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.454]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.454]                   if (TRUE && !signal) {
[18:04:55.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.454]                     {
[18:04:55.454]                       inherits <- base::inherits
[18:04:55.454]                       invokeRestart <- base::invokeRestart
[18:04:55.454]                       is.null <- base::is.null
[18:04:55.454]                       muffled <- FALSE
[18:04:55.454]                       if (inherits(cond, "message")) {
[18:04:55.454]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.454]                         if (muffled) 
[18:04:55.454]                           invokeRestart("muffleMessage")
[18:04:55.454]                       }
[18:04:55.454]                       else if (inherits(cond, "warning")) {
[18:04:55.454]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.454]                         if (muffled) 
[18:04:55.454]                           invokeRestart("muffleWarning")
[18:04:55.454]                       }
[18:04:55.454]                       else if (inherits(cond, "condition")) {
[18:04:55.454]                         if (!is.null(pattern)) {
[18:04:55.454]                           computeRestarts <- base::computeRestarts
[18:04:55.454]                           grepl <- base::grepl
[18:04:55.454]                           restarts <- computeRestarts(cond)
[18:04:55.454]                           for (restart in restarts) {
[18:04:55.454]                             name <- restart$name
[18:04:55.454]                             if (is.null(name)) 
[18:04:55.454]                               next
[18:04:55.454]                             if (!grepl(pattern, name)) 
[18:04:55.454]                               next
[18:04:55.454]                             invokeRestart(restart)
[18:04:55.454]                             muffled <- TRUE
[18:04:55.454]                             break
[18:04:55.454]                           }
[18:04:55.454]                         }
[18:04:55.454]                       }
[18:04:55.454]                       invisible(muffled)
[18:04:55.454]                     }
[18:04:55.454]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.454]                   }
[18:04:55.454]                 }
[18:04:55.454]                 else {
[18:04:55.454]                   if (TRUE) {
[18:04:55.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.454]                     {
[18:04:55.454]                       inherits <- base::inherits
[18:04:55.454]                       invokeRestart <- base::invokeRestart
[18:04:55.454]                       is.null <- base::is.null
[18:04:55.454]                       muffled <- FALSE
[18:04:55.454]                       if (inherits(cond, "message")) {
[18:04:55.454]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.454]                         if (muffled) 
[18:04:55.454]                           invokeRestart("muffleMessage")
[18:04:55.454]                       }
[18:04:55.454]                       else if (inherits(cond, "warning")) {
[18:04:55.454]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.454]                         if (muffled) 
[18:04:55.454]                           invokeRestart("muffleWarning")
[18:04:55.454]                       }
[18:04:55.454]                       else if (inherits(cond, "condition")) {
[18:04:55.454]                         if (!is.null(pattern)) {
[18:04:55.454]                           computeRestarts <- base::computeRestarts
[18:04:55.454]                           grepl <- base::grepl
[18:04:55.454]                           restarts <- computeRestarts(cond)
[18:04:55.454]                           for (restart in restarts) {
[18:04:55.454]                             name <- restart$name
[18:04:55.454]                             if (is.null(name)) 
[18:04:55.454]                               next
[18:04:55.454]                             if (!grepl(pattern, name)) 
[18:04:55.454]                               next
[18:04:55.454]                             invokeRestart(restart)
[18:04:55.454]                             muffled <- TRUE
[18:04:55.454]                             break
[18:04:55.454]                           }
[18:04:55.454]                         }
[18:04:55.454]                       }
[18:04:55.454]                       invisible(muffled)
[18:04:55.454]                     }
[18:04:55.454]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.454]                   }
[18:04:55.454]                 }
[18:04:55.454]             }
[18:04:55.454]         }))
[18:04:55.454]     }, error = function(ex) {
[18:04:55.454]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.454]                 ...future.rng), started = ...future.startTime, 
[18:04:55.454]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.454]             version = "1.8"), class = "FutureResult")
[18:04:55.454]     }, finally = {
[18:04:55.454]         if (!identical(...future.workdir, getwd())) 
[18:04:55.454]             setwd(...future.workdir)
[18:04:55.454]         {
[18:04:55.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.454]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.454]             }
[18:04:55.454]             base::options(...future.oldOptions)
[18:04:55.454]             if (.Platform$OS.type == "windows") {
[18:04:55.454]                 old_names <- names(...future.oldEnvVars)
[18:04:55.454]                 envs <- base::Sys.getenv()
[18:04:55.454]                 names <- names(envs)
[18:04:55.454]                 common <- intersect(names, old_names)
[18:04:55.454]                 added <- setdiff(names, old_names)
[18:04:55.454]                 removed <- setdiff(old_names, names)
[18:04:55.454]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.454]                   envs[common]]
[18:04:55.454]                 NAMES <- toupper(changed)
[18:04:55.454]                 args <- list()
[18:04:55.454]                 for (kk in seq_along(NAMES)) {
[18:04:55.454]                   name <- changed[[kk]]
[18:04:55.454]                   NAME <- NAMES[[kk]]
[18:04:55.454]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.454]                     next
[18:04:55.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.454]                 }
[18:04:55.454]                 NAMES <- toupper(added)
[18:04:55.454]                 for (kk in seq_along(NAMES)) {
[18:04:55.454]                   name <- added[[kk]]
[18:04:55.454]                   NAME <- NAMES[[kk]]
[18:04:55.454]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.454]                     next
[18:04:55.454]                   args[[name]] <- ""
[18:04:55.454]                 }
[18:04:55.454]                 NAMES <- toupper(removed)
[18:04:55.454]                 for (kk in seq_along(NAMES)) {
[18:04:55.454]                   name <- removed[[kk]]
[18:04:55.454]                   NAME <- NAMES[[kk]]
[18:04:55.454]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.454]                     next
[18:04:55.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.454]                 }
[18:04:55.454]                 if (length(args) > 0) 
[18:04:55.454]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.454]             }
[18:04:55.454]             else {
[18:04:55.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.454]             }
[18:04:55.454]             {
[18:04:55.454]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.454]                   0L) {
[18:04:55.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.454]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.454]                   base::options(opts)
[18:04:55.454]                 }
[18:04:55.454]                 {
[18:04:55.454]                   {
[18:04:55.454]                     NULL
[18:04:55.454]                     RNGkind("Mersenne-Twister")
[18:04:55.454]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.454]                       inherits = FALSE)
[18:04:55.454]                   }
[18:04:55.454]                   options(future.plan = NULL)
[18:04:55.454]                   if (is.na(NA_character_)) 
[18:04:55.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.454]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.454]                     .init = FALSE)
[18:04:55.454]                 }
[18:04:55.454]             }
[18:04:55.454]         }
[18:04:55.454]     })
[18:04:55.454]     if (TRUE) {
[18:04:55.454]         base::sink(type = "output", split = FALSE)
[18:04:55.454]         if (TRUE) {
[18:04:55.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.454]         }
[18:04:55.454]         else {
[18:04:55.454]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.454]         }
[18:04:55.454]         base::close(...future.stdout)
[18:04:55.454]         ...future.stdout <- NULL
[18:04:55.454]     }
[18:04:55.454]     ...future.result$conditions <- ...future.conditions
[18:04:55.454]     ...future.result$finished <- base::Sys.time()
[18:04:55.454]     ...future.result
[18:04:55.454] }
[18:04:55.457] assign_globals() ...
[18:04:55.457] List of 1
[18:04:55.457]  $ pkg: chr "foo"
[18:04:55.457]  - attr(*, "where")=List of 1
[18:04:55.457]   ..$ pkg:<environment: R_EmptyEnv> 
[18:04:55.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.457]  - attr(*, "resolved")= logi TRUE
[18:04:55.457]  - attr(*, "total_size")= num 112
[18:04:55.462] - copied ‘pkg’ to environment
[18:04:55.462] assign_globals() ... done
[18:04:55.462] plan(): Setting new future strategy stack:
[18:04:55.463] List of future strategies:
[18:04:55.463] 1. sequential:
[18:04:55.463]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.463]    - tweaked: FALSE
[18:04:55.463]    - call: NULL
[18:04:55.464] plan(): nbrOfWorkers() = 1
[18:04:55.465] plan(): Setting new future strategy stack:
[18:04:55.466] List of future strategies:
[18:04:55.466] 1. sequential:
[18:04:55.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.466]    - tweaked: FALSE
[18:04:55.466]    - call: plan(strategy)
[18:04:55.467] plan(): nbrOfWorkers() = 1
[18:04:55.467] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.469] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.469] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.474] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:04:55.474] Searching for globals ... DONE
[18:04:55.475] Resolving globals: TRUE
[18:04:55.475] Resolving any globals that are futures ...
[18:04:55.475] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:04:55.475] Resolving any globals that are futures ... DONE
[18:04:55.476] Resolving futures part of globals (recursively) ...
[18:04:55.476] resolve() on list ...
[18:04:55.477]  recursive: 99
[18:04:55.477]  length: 1
[18:04:55.477]  elements: ‘a’
[18:04:55.477]  length: 0 (resolved future 1)
[18:04:55.478] resolve() on list ... DONE
[18:04:55.478] - globals: [1] ‘a’
[18:04:55.478] Resolving futures part of globals (recursively) ... DONE
[18:04:55.478] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:55.479] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:04:55.479] - globals: [1] ‘a’
[18:04:55.480] 
[18:04:55.480] getGlobalsAndPackages() ... DONE
[18:04:55.480] run() for ‘Future’ ...
[18:04:55.480] - state: ‘created’
[18:04:55.481] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.482]   - Field: ‘label’
[18:04:55.482]   - Field: ‘local’
[18:04:55.482]   - Field: ‘owner’
[18:04:55.483]   - Field: ‘envir’
[18:04:55.483]   - Field: ‘packages’
[18:04:55.483]   - Field: ‘gc’
[18:04:55.483]   - Field: ‘conditions’
[18:04:55.483]   - Field: ‘expr’
[18:04:55.484]   - Field: ‘uuid’
[18:04:55.484]   - Field: ‘seed’
[18:04:55.484]   - Field: ‘version’
[18:04:55.484]   - Field: ‘result’
[18:04:55.484]   - Field: ‘asynchronous’
[18:04:55.485]   - Field: ‘calls’
[18:04:55.485]   - Field: ‘globals’
[18:04:55.485]   - Field: ‘stdout’
[18:04:55.485]   - Field: ‘earlySignal’
[18:04:55.485]   - Field: ‘lazy’
[18:04:55.486]   - Field: ‘state’
[18:04:55.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.486] - Launch lazy future ...
[18:04:55.486] Packages needed by the future expression (n = 0): <none>
[18:04:55.487] Packages needed by future strategies (n = 0): <none>
[18:04:55.487] {
[18:04:55.487]     {
[18:04:55.487]         {
[18:04:55.487]             ...future.startTime <- base::Sys.time()
[18:04:55.487]             {
[18:04:55.487]                 {
[18:04:55.487]                   {
[18:04:55.487]                     base::local({
[18:04:55.487]                       has_future <- base::requireNamespace("future", 
[18:04:55.487]                         quietly = TRUE)
[18:04:55.487]                       if (has_future) {
[18:04:55.487]                         ns <- base::getNamespace("future")
[18:04:55.487]                         version <- ns[[".package"]][["version"]]
[18:04:55.487]                         if (is.null(version)) 
[18:04:55.487]                           version <- utils::packageVersion("future")
[18:04:55.487]                       }
[18:04:55.487]                       else {
[18:04:55.487]                         version <- NULL
[18:04:55.487]                       }
[18:04:55.487]                       if (!has_future || version < "1.8.0") {
[18:04:55.487]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.487]                           "", base::R.version$version.string), 
[18:04:55.487]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.487]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.487]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.487]                             "release", "version")], collapse = " "), 
[18:04:55.487]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.487]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.487]                           info)
[18:04:55.487]                         info <- base::paste(info, collapse = "; ")
[18:04:55.487]                         if (!has_future) {
[18:04:55.487]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.487]                             info)
[18:04:55.487]                         }
[18:04:55.487]                         else {
[18:04:55.487]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.487]                             info, version)
[18:04:55.487]                         }
[18:04:55.487]                         base::stop(msg)
[18:04:55.487]                       }
[18:04:55.487]                     })
[18:04:55.487]                   }
[18:04:55.487]                   ...future.strategy.old <- future::plan("list")
[18:04:55.487]                   options(future.plan = NULL)
[18:04:55.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.487]                 }
[18:04:55.487]                 ...future.workdir <- getwd()
[18:04:55.487]             }
[18:04:55.487]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.487]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.487]         }
[18:04:55.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.487]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.487]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.487]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.487]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.487]             base::names(...future.oldOptions))
[18:04:55.487]     }
[18:04:55.487]     if (FALSE) {
[18:04:55.487]     }
[18:04:55.487]     else {
[18:04:55.487]         if (TRUE) {
[18:04:55.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.487]                 open = "w")
[18:04:55.487]         }
[18:04:55.487]         else {
[18:04:55.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.487]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.487]         }
[18:04:55.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.487]             base::sink(type = "output", split = FALSE)
[18:04:55.487]             base::close(...future.stdout)
[18:04:55.487]         }, add = TRUE)
[18:04:55.487]     }
[18:04:55.487]     ...future.frame <- base::sys.nframe()
[18:04:55.487]     ...future.conditions <- base::list()
[18:04:55.487]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.487]     if (FALSE) {
[18:04:55.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.487]     }
[18:04:55.487]     ...future.result <- base::tryCatch({
[18:04:55.487]         base::withCallingHandlers({
[18:04:55.487]             ...future.value <- base::withVisible(base::local({
[18:04:55.487]                 b <- a
[18:04:55.487]                 a <- 2
[18:04:55.487]                 a * b
[18:04:55.487]             }))
[18:04:55.487]             future::FutureResult(value = ...future.value$value, 
[18:04:55.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.487]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.487]                     ...future.globalenv.names))
[18:04:55.487]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.487]         }, condition = base::local({
[18:04:55.487]             c <- base::c
[18:04:55.487]             inherits <- base::inherits
[18:04:55.487]             invokeRestart <- base::invokeRestart
[18:04:55.487]             length <- base::length
[18:04:55.487]             list <- base::list
[18:04:55.487]             seq.int <- base::seq.int
[18:04:55.487]             signalCondition <- base::signalCondition
[18:04:55.487]             sys.calls <- base::sys.calls
[18:04:55.487]             `[[` <- base::`[[`
[18:04:55.487]             `+` <- base::`+`
[18:04:55.487]             `<<-` <- base::`<<-`
[18:04:55.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.487]                   3L)]
[18:04:55.487]             }
[18:04:55.487]             function(cond) {
[18:04:55.487]                 is_error <- inherits(cond, "error")
[18:04:55.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.487]                   NULL)
[18:04:55.487]                 if (is_error) {
[18:04:55.487]                   sessionInformation <- function() {
[18:04:55.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.487]                       search = base::search(), system = base::Sys.info())
[18:04:55.487]                   }
[18:04:55.487]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.487]                     cond$call), session = sessionInformation(), 
[18:04:55.487]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.487]                   signalCondition(cond)
[18:04:55.487]                 }
[18:04:55.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.487]                 "immediateCondition"))) {
[18:04:55.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.487]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.487]                   if (TRUE && !signal) {
[18:04:55.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.487]                     {
[18:04:55.487]                       inherits <- base::inherits
[18:04:55.487]                       invokeRestart <- base::invokeRestart
[18:04:55.487]                       is.null <- base::is.null
[18:04:55.487]                       muffled <- FALSE
[18:04:55.487]                       if (inherits(cond, "message")) {
[18:04:55.487]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.487]                         if (muffled) 
[18:04:55.487]                           invokeRestart("muffleMessage")
[18:04:55.487]                       }
[18:04:55.487]                       else if (inherits(cond, "warning")) {
[18:04:55.487]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.487]                         if (muffled) 
[18:04:55.487]                           invokeRestart("muffleWarning")
[18:04:55.487]                       }
[18:04:55.487]                       else if (inherits(cond, "condition")) {
[18:04:55.487]                         if (!is.null(pattern)) {
[18:04:55.487]                           computeRestarts <- base::computeRestarts
[18:04:55.487]                           grepl <- base::grepl
[18:04:55.487]                           restarts <- computeRestarts(cond)
[18:04:55.487]                           for (restart in restarts) {
[18:04:55.487]                             name <- restart$name
[18:04:55.487]                             if (is.null(name)) 
[18:04:55.487]                               next
[18:04:55.487]                             if (!grepl(pattern, name)) 
[18:04:55.487]                               next
[18:04:55.487]                             invokeRestart(restart)
[18:04:55.487]                             muffled <- TRUE
[18:04:55.487]                             break
[18:04:55.487]                           }
[18:04:55.487]                         }
[18:04:55.487]                       }
[18:04:55.487]                       invisible(muffled)
[18:04:55.487]                     }
[18:04:55.487]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.487]                   }
[18:04:55.487]                 }
[18:04:55.487]                 else {
[18:04:55.487]                   if (TRUE) {
[18:04:55.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.487]                     {
[18:04:55.487]                       inherits <- base::inherits
[18:04:55.487]                       invokeRestart <- base::invokeRestart
[18:04:55.487]                       is.null <- base::is.null
[18:04:55.487]                       muffled <- FALSE
[18:04:55.487]                       if (inherits(cond, "message")) {
[18:04:55.487]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.487]                         if (muffled) 
[18:04:55.487]                           invokeRestart("muffleMessage")
[18:04:55.487]                       }
[18:04:55.487]                       else if (inherits(cond, "warning")) {
[18:04:55.487]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.487]                         if (muffled) 
[18:04:55.487]                           invokeRestart("muffleWarning")
[18:04:55.487]                       }
[18:04:55.487]                       else if (inherits(cond, "condition")) {
[18:04:55.487]                         if (!is.null(pattern)) {
[18:04:55.487]                           computeRestarts <- base::computeRestarts
[18:04:55.487]                           grepl <- base::grepl
[18:04:55.487]                           restarts <- computeRestarts(cond)
[18:04:55.487]                           for (restart in restarts) {
[18:04:55.487]                             name <- restart$name
[18:04:55.487]                             if (is.null(name)) 
[18:04:55.487]                               next
[18:04:55.487]                             if (!grepl(pattern, name)) 
[18:04:55.487]                               next
[18:04:55.487]                             invokeRestart(restart)
[18:04:55.487]                             muffled <- TRUE
[18:04:55.487]                             break
[18:04:55.487]                           }
[18:04:55.487]                         }
[18:04:55.487]                       }
[18:04:55.487]                       invisible(muffled)
[18:04:55.487]                     }
[18:04:55.487]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.487]                   }
[18:04:55.487]                 }
[18:04:55.487]             }
[18:04:55.487]         }))
[18:04:55.487]     }, error = function(ex) {
[18:04:55.487]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.487]                 ...future.rng), started = ...future.startTime, 
[18:04:55.487]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.487]             version = "1.8"), class = "FutureResult")
[18:04:55.487]     }, finally = {
[18:04:55.487]         if (!identical(...future.workdir, getwd())) 
[18:04:55.487]             setwd(...future.workdir)
[18:04:55.487]         {
[18:04:55.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.487]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.487]             }
[18:04:55.487]             base::options(...future.oldOptions)
[18:04:55.487]             if (.Platform$OS.type == "windows") {
[18:04:55.487]                 old_names <- names(...future.oldEnvVars)
[18:04:55.487]                 envs <- base::Sys.getenv()
[18:04:55.487]                 names <- names(envs)
[18:04:55.487]                 common <- intersect(names, old_names)
[18:04:55.487]                 added <- setdiff(names, old_names)
[18:04:55.487]                 removed <- setdiff(old_names, names)
[18:04:55.487]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.487]                   envs[common]]
[18:04:55.487]                 NAMES <- toupper(changed)
[18:04:55.487]                 args <- list()
[18:04:55.487]                 for (kk in seq_along(NAMES)) {
[18:04:55.487]                   name <- changed[[kk]]
[18:04:55.487]                   NAME <- NAMES[[kk]]
[18:04:55.487]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.487]                     next
[18:04:55.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.487]                 }
[18:04:55.487]                 NAMES <- toupper(added)
[18:04:55.487]                 for (kk in seq_along(NAMES)) {
[18:04:55.487]                   name <- added[[kk]]
[18:04:55.487]                   NAME <- NAMES[[kk]]
[18:04:55.487]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.487]                     next
[18:04:55.487]                   args[[name]] <- ""
[18:04:55.487]                 }
[18:04:55.487]                 NAMES <- toupper(removed)
[18:04:55.487]                 for (kk in seq_along(NAMES)) {
[18:04:55.487]                   name <- removed[[kk]]
[18:04:55.487]                   NAME <- NAMES[[kk]]
[18:04:55.487]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.487]                     next
[18:04:55.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.487]                 }
[18:04:55.487]                 if (length(args) > 0) 
[18:04:55.487]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.487]             }
[18:04:55.487]             else {
[18:04:55.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.487]             }
[18:04:55.487]             {
[18:04:55.487]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.487]                   0L) {
[18:04:55.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.487]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.487]                   base::options(opts)
[18:04:55.487]                 }
[18:04:55.487]                 {
[18:04:55.487]                   {
[18:04:55.487]                     NULL
[18:04:55.487]                     RNGkind("Mersenne-Twister")
[18:04:55.487]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.487]                       inherits = FALSE)
[18:04:55.487]                   }
[18:04:55.487]                   options(future.plan = NULL)
[18:04:55.487]                   if (is.na(NA_character_)) 
[18:04:55.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.487]                     .init = FALSE)
[18:04:55.487]                 }
[18:04:55.487]             }
[18:04:55.487]         }
[18:04:55.487]     })
[18:04:55.487]     if (TRUE) {
[18:04:55.487]         base::sink(type = "output", split = FALSE)
[18:04:55.487]         if (TRUE) {
[18:04:55.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.487]         }
[18:04:55.487]         else {
[18:04:55.487]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.487]         }
[18:04:55.487]         base::close(...future.stdout)
[18:04:55.487]         ...future.stdout <- NULL
[18:04:55.487]     }
[18:04:55.487]     ...future.result$conditions <- ...future.conditions
[18:04:55.487]     ...future.result$finished <- base::Sys.time()
[18:04:55.487]     ...future.result
[18:04:55.487] }
[18:04:55.491] assign_globals() ...
[18:04:55.491] List of 1
[18:04:55.491]  $ a: num 3
[18:04:55.491]  - attr(*, "where")=List of 1
[18:04:55.491]   ..$ a:<environment: R_EmptyEnv> 
[18:04:55.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.491]  - attr(*, "resolved")= logi TRUE
[18:04:55.491]  - attr(*, "total_size")= num 56
[18:04:55.491]  - attr(*, "already-done")= logi TRUE
[18:04:55.500] - copied ‘a’ to environment
[18:04:55.500] assign_globals() ... done
[18:04:55.500] plan(): Setting new future strategy stack:
[18:04:55.501] List of future strategies:
[18:04:55.501] 1. sequential:
[18:04:55.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.501]    - tweaked: FALSE
[18:04:55.501]    - call: NULL
[18:04:55.502] plan(): nbrOfWorkers() = 1
[18:04:55.503] plan(): Setting new future strategy stack:
[18:04:55.503] List of future strategies:
[18:04:55.503] 1. sequential:
[18:04:55.503]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.503]    - tweaked: FALSE
[18:04:55.503]    - call: plan(strategy)
[18:04:55.504] plan(): nbrOfWorkers() = 1
[18:04:55.505] SequentialFuture started (and completed)
[18:04:55.505] - Launch lazy future ... done
[18:04:55.505] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.507] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.507] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.511] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:04:55.511] Searching for globals ... DONE
[18:04:55.512] Resolving globals: TRUE
[18:04:55.512] Resolving any globals that are futures ...
[18:04:55.512] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:04:55.512] Resolving any globals that are futures ... DONE
[18:04:55.513] Resolving futures part of globals (recursively) ...
[18:04:55.514] resolve() on list ...
[18:04:55.514]  recursive: 99
[18:04:55.514]  length: 1
[18:04:55.514]  elements: ‘a’
[18:04:55.514]  length: 0 (resolved future 1)
[18:04:55.515] resolve() on list ... DONE
[18:04:55.515] - globals: [1] ‘a’
[18:04:55.515] Resolving futures part of globals (recursively) ... DONE
[18:04:55.515] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:55.516] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:04:55.516] - globals: [1] ‘a’
[18:04:55.517] 
[18:04:55.517] getGlobalsAndPackages() ... DONE
[18:04:55.518] run() for ‘Future’ ...
[18:04:55.518] - state: ‘created’
[18:04:55.518] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.519] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.519]   - Field: ‘label’
[18:04:55.519]   - Field: ‘local’
[18:04:55.520]   - Field: ‘owner’
[18:04:55.520]   - Field: ‘envir’
[18:04:55.520]   - Field: ‘packages’
[18:04:55.520]   - Field: ‘gc’
[18:04:55.520]   - Field: ‘conditions’
[18:04:55.521]   - Field: ‘expr’
[18:04:55.521]   - Field: ‘uuid’
[18:04:55.521]   - Field: ‘seed’
[18:04:55.521]   - Field: ‘version’
[18:04:55.522]   - Field: ‘result’
[18:04:55.522]   - Field: ‘asynchronous’
[18:04:55.522]   - Field: ‘calls’
[18:04:55.522]   - Field: ‘globals’
[18:04:55.522]   - Field: ‘stdout’
[18:04:55.523]   - Field: ‘earlySignal’
[18:04:55.523]   - Field: ‘lazy’
[18:04:55.523]   - Field: ‘state’
[18:04:55.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.523] - Launch lazy future ...
[18:04:55.524] Packages needed by the future expression (n = 0): <none>
[18:04:55.524] Packages needed by future strategies (n = 0): <none>
[18:04:55.525] {
[18:04:55.525]     {
[18:04:55.525]         {
[18:04:55.525]             ...future.startTime <- base::Sys.time()
[18:04:55.525]             {
[18:04:55.525]                 {
[18:04:55.525]                   {
[18:04:55.525]                     base::local({
[18:04:55.525]                       has_future <- base::requireNamespace("future", 
[18:04:55.525]                         quietly = TRUE)
[18:04:55.525]                       if (has_future) {
[18:04:55.525]                         ns <- base::getNamespace("future")
[18:04:55.525]                         version <- ns[[".package"]][["version"]]
[18:04:55.525]                         if (is.null(version)) 
[18:04:55.525]                           version <- utils::packageVersion("future")
[18:04:55.525]                       }
[18:04:55.525]                       else {
[18:04:55.525]                         version <- NULL
[18:04:55.525]                       }
[18:04:55.525]                       if (!has_future || version < "1.8.0") {
[18:04:55.525]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.525]                           "", base::R.version$version.string), 
[18:04:55.525]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.525]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.525]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.525]                             "release", "version")], collapse = " "), 
[18:04:55.525]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.525]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.525]                           info)
[18:04:55.525]                         info <- base::paste(info, collapse = "; ")
[18:04:55.525]                         if (!has_future) {
[18:04:55.525]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.525]                             info)
[18:04:55.525]                         }
[18:04:55.525]                         else {
[18:04:55.525]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.525]                             info, version)
[18:04:55.525]                         }
[18:04:55.525]                         base::stop(msg)
[18:04:55.525]                       }
[18:04:55.525]                     })
[18:04:55.525]                   }
[18:04:55.525]                   ...future.strategy.old <- future::plan("list")
[18:04:55.525]                   options(future.plan = NULL)
[18:04:55.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.525]                 }
[18:04:55.525]                 ...future.workdir <- getwd()
[18:04:55.525]             }
[18:04:55.525]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.525]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.525]         }
[18:04:55.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.525]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.525]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.525]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.525]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.525]             base::names(...future.oldOptions))
[18:04:55.525]     }
[18:04:55.525]     if (FALSE) {
[18:04:55.525]     }
[18:04:55.525]     else {
[18:04:55.525]         if (TRUE) {
[18:04:55.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.525]                 open = "w")
[18:04:55.525]         }
[18:04:55.525]         else {
[18:04:55.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.525]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.525]         }
[18:04:55.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.525]             base::sink(type = "output", split = FALSE)
[18:04:55.525]             base::close(...future.stdout)
[18:04:55.525]         }, add = TRUE)
[18:04:55.525]     }
[18:04:55.525]     ...future.frame <- base::sys.nframe()
[18:04:55.525]     ...future.conditions <- base::list()
[18:04:55.525]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.525]     if (FALSE) {
[18:04:55.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.525]     }
[18:04:55.525]     ...future.result <- base::tryCatch({
[18:04:55.525]         base::withCallingHandlers({
[18:04:55.525]             ...future.value <- base::withVisible(base::local({
[18:04:55.525]                 b <- a
[18:04:55.525]                 a <- 2
[18:04:55.525]                 a * b
[18:04:55.525]             }))
[18:04:55.525]             future::FutureResult(value = ...future.value$value, 
[18:04:55.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.525]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.525]                     ...future.globalenv.names))
[18:04:55.525]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.525]         }, condition = base::local({
[18:04:55.525]             c <- base::c
[18:04:55.525]             inherits <- base::inherits
[18:04:55.525]             invokeRestart <- base::invokeRestart
[18:04:55.525]             length <- base::length
[18:04:55.525]             list <- base::list
[18:04:55.525]             seq.int <- base::seq.int
[18:04:55.525]             signalCondition <- base::signalCondition
[18:04:55.525]             sys.calls <- base::sys.calls
[18:04:55.525]             `[[` <- base::`[[`
[18:04:55.525]             `+` <- base::`+`
[18:04:55.525]             `<<-` <- base::`<<-`
[18:04:55.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.525]                   3L)]
[18:04:55.525]             }
[18:04:55.525]             function(cond) {
[18:04:55.525]                 is_error <- inherits(cond, "error")
[18:04:55.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.525]                   NULL)
[18:04:55.525]                 if (is_error) {
[18:04:55.525]                   sessionInformation <- function() {
[18:04:55.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.525]                       search = base::search(), system = base::Sys.info())
[18:04:55.525]                   }
[18:04:55.525]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.525]                     cond$call), session = sessionInformation(), 
[18:04:55.525]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.525]                   signalCondition(cond)
[18:04:55.525]                 }
[18:04:55.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.525]                 "immediateCondition"))) {
[18:04:55.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.525]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.525]                   if (TRUE && !signal) {
[18:04:55.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.525]                     {
[18:04:55.525]                       inherits <- base::inherits
[18:04:55.525]                       invokeRestart <- base::invokeRestart
[18:04:55.525]                       is.null <- base::is.null
[18:04:55.525]                       muffled <- FALSE
[18:04:55.525]                       if (inherits(cond, "message")) {
[18:04:55.525]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.525]                         if (muffled) 
[18:04:55.525]                           invokeRestart("muffleMessage")
[18:04:55.525]                       }
[18:04:55.525]                       else if (inherits(cond, "warning")) {
[18:04:55.525]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.525]                         if (muffled) 
[18:04:55.525]                           invokeRestart("muffleWarning")
[18:04:55.525]                       }
[18:04:55.525]                       else if (inherits(cond, "condition")) {
[18:04:55.525]                         if (!is.null(pattern)) {
[18:04:55.525]                           computeRestarts <- base::computeRestarts
[18:04:55.525]                           grepl <- base::grepl
[18:04:55.525]                           restarts <- computeRestarts(cond)
[18:04:55.525]                           for (restart in restarts) {
[18:04:55.525]                             name <- restart$name
[18:04:55.525]                             if (is.null(name)) 
[18:04:55.525]                               next
[18:04:55.525]                             if (!grepl(pattern, name)) 
[18:04:55.525]                               next
[18:04:55.525]                             invokeRestart(restart)
[18:04:55.525]                             muffled <- TRUE
[18:04:55.525]                             break
[18:04:55.525]                           }
[18:04:55.525]                         }
[18:04:55.525]                       }
[18:04:55.525]                       invisible(muffled)
[18:04:55.525]                     }
[18:04:55.525]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.525]                   }
[18:04:55.525]                 }
[18:04:55.525]                 else {
[18:04:55.525]                   if (TRUE) {
[18:04:55.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.525]                     {
[18:04:55.525]                       inherits <- base::inherits
[18:04:55.525]                       invokeRestart <- base::invokeRestart
[18:04:55.525]                       is.null <- base::is.null
[18:04:55.525]                       muffled <- FALSE
[18:04:55.525]                       if (inherits(cond, "message")) {
[18:04:55.525]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.525]                         if (muffled) 
[18:04:55.525]                           invokeRestart("muffleMessage")
[18:04:55.525]                       }
[18:04:55.525]                       else if (inherits(cond, "warning")) {
[18:04:55.525]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.525]                         if (muffled) 
[18:04:55.525]                           invokeRestart("muffleWarning")
[18:04:55.525]                       }
[18:04:55.525]                       else if (inherits(cond, "condition")) {
[18:04:55.525]                         if (!is.null(pattern)) {
[18:04:55.525]                           computeRestarts <- base::computeRestarts
[18:04:55.525]                           grepl <- base::grepl
[18:04:55.525]                           restarts <- computeRestarts(cond)
[18:04:55.525]                           for (restart in restarts) {
[18:04:55.525]                             name <- restart$name
[18:04:55.525]                             if (is.null(name)) 
[18:04:55.525]                               next
[18:04:55.525]                             if (!grepl(pattern, name)) 
[18:04:55.525]                               next
[18:04:55.525]                             invokeRestart(restart)
[18:04:55.525]                             muffled <- TRUE
[18:04:55.525]                             break
[18:04:55.525]                           }
[18:04:55.525]                         }
[18:04:55.525]                       }
[18:04:55.525]                       invisible(muffled)
[18:04:55.525]                     }
[18:04:55.525]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.525]                   }
[18:04:55.525]                 }
[18:04:55.525]             }
[18:04:55.525]         }))
[18:04:55.525]     }, error = function(ex) {
[18:04:55.525]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.525]                 ...future.rng), started = ...future.startTime, 
[18:04:55.525]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.525]             version = "1.8"), class = "FutureResult")
[18:04:55.525]     }, finally = {
[18:04:55.525]         if (!identical(...future.workdir, getwd())) 
[18:04:55.525]             setwd(...future.workdir)
[18:04:55.525]         {
[18:04:55.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.525]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.525]             }
[18:04:55.525]             base::options(...future.oldOptions)
[18:04:55.525]             if (.Platform$OS.type == "windows") {
[18:04:55.525]                 old_names <- names(...future.oldEnvVars)
[18:04:55.525]                 envs <- base::Sys.getenv()
[18:04:55.525]                 names <- names(envs)
[18:04:55.525]                 common <- intersect(names, old_names)
[18:04:55.525]                 added <- setdiff(names, old_names)
[18:04:55.525]                 removed <- setdiff(old_names, names)
[18:04:55.525]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.525]                   envs[common]]
[18:04:55.525]                 NAMES <- toupper(changed)
[18:04:55.525]                 args <- list()
[18:04:55.525]                 for (kk in seq_along(NAMES)) {
[18:04:55.525]                   name <- changed[[kk]]
[18:04:55.525]                   NAME <- NAMES[[kk]]
[18:04:55.525]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.525]                     next
[18:04:55.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.525]                 }
[18:04:55.525]                 NAMES <- toupper(added)
[18:04:55.525]                 for (kk in seq_along(NAMES)) {
[18:04:55.525]                   name <- added[[kk]]
[18:04:55.525]                   NAME <- NAMES[[kk]]
[18:04:55.525]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.525]                     next
[18:04:55.525]                   args[[name]] <- ""
[18:04:55.525]                 }
[18:04:55.525]                 NAMES <- toupper(removed)
[18:04:55.525]                 for (kk in seq_along(NAMES)) {
[18:04:55.525]                   name <- removed[[kk]]
[18:04:55.525]                   NAME <- NAMES[[kk]]
[18:04:55.525]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.525]                     next
[18:04:55.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.525]                 }
[18:04:55.525]                 if (length(args) > 0) 
[18:04:55.525]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.525]             }
[18:04:55.525]             else {
[18:04:55.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.525]             }
[18:04:55.525]             {
[18:04:55.525]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.525]                   0L) {
[18:04:55.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.525]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.525]                   base::options(opts)
[18:04:55.525]                 }
[18:04:55.525]                 {
[18:04:55.525]                   {
[18:04:55.525]                     NULL
[18:04:55.525]                     RNGkind("Mersenne-Twister")
[18:04:55.525]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.525]                       inherits = FALSE)
[18:04:55.525]                   }
[18:04:55.525]                   options(future.plan = NULL)
[18:04:55.525]                   if (is.na(NA_character_)) 
[18:04:55.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.525]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.525]                     .init = FALSE)
[18:04:55.525]                 }
[18:04:55.525]             }
[18:04:55.525]         }
[18:04:55.525]     })
[18:04:55.525]     if (TRUE) {
[18:04:55.525]         base::sink(type = "output", split = FALSE)
[18:04:55.525]         if (TRUE) {
[18:04:55.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.525]         }
[18:04:55.525]         else {
[18:04:55.525]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.525]         }
[18:04:55.525]         base::close(...future.stdout)
[18:04:55.525]         ...future.stdout <- NULL
[18:04:55.525]     }
[18:04:55.525]     ...future.result$conditions <- ...future.conditions
[18:04:55.525]     ...future.result$finished <- base::Sys.time()
[18:04:55.525]     ...future.result
[18:04:55.525] }
[18:04:55.528] assign_globals() ...
[18:04:55.528] List of 1
[18:04:55.528]  $ a: num 3
[18:04:55.528]  - attr(*, "where")=List of 1
[18:04:55.528]   ..$ a:<environment: R_EmptyEnv> 
[18:04:55.528]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.528]  - attr(*, "resolved")= logi TRUE
[18:04:55.528]  - attr(*, "total_size")= num 56
[18:04:55.528]  - attr(*, "already-done")= logi TRUE
[18:04:55.534] - copied ‘a’ to environment
[18:04:55.534] assign_globals() ... done
[18:04:55.535] plan(): Setting new future strategy stack:
[18:04:55.535] List of future strategies:
[18:04:55.535] 1. sequential:
[18:04:55.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.535]    - tweaked: FALSE
[18:04:55.535]    - call: NULL
[18:04:55.536] plan(): nbrOfWorkers() = 1
[18:04:55.538] plan(): Setting new future strategy stack:
[18:04:55.538] List of future strategies:
[18:04:55.538] 1. sequential:
[18:04:55.538]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.538]    - tweaked: FALSE
[18:04:55.538]    - call: plan(strategy)
[18:04:55.539] plan(): nbrOfWorkers() = 1
[18:04:55.539] SequentialFuture started (and completed)
[18:04:55.540] - Launch lazy future ... done
[18:04:55.540] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.541] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.542] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.546] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.546] Searching for globals ... DONE
[18:04:55.546] Resolving globals: TRUE
[18:04:55.547] Resolving any globals that are futures ...
[18:04:55.547] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.547] Resolving any globals that are futures ... DONE
[18:04:55.548] Resolving futures part of globals (recursively) ...
[18:04:55.549] resolve() on list ...
[18:04:55.549]  recursive: 99
[18:04:55.549]  length: 2
[18:04:55.549]  elements: ‘a’, ‘ii’
[18:04:55.550]  length: 1 (resolved future 1)
[18:04:55.550]  length: 0 (resolved future 2)
[18:04:55.550] resolve() on list ... DONE
[18:04:55.550] - globals: [2] ‘a’, ‘ii’
[18:04:55.550] Resolving futures part of globals (recursively) ... DONE
[18:04:55.553] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:55.554] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.555] - globals: [2] ‘a’, ‘ii’
[18:04:55.555] 
[18:04:55.555] getGlobalsAndPackages() ... DONE
[18:04:55.556] run() for ‘Future’ ...
[18:04:55.556] - state: ‘created’
[18:04:55.556] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.557] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.557]   - Field: ‘label’
[18:04:55.557]   - Field: ‘local’
[18:04:55.558]   - Field: ‘owner’
[18:04:55.558]   - Field: ‘envir’
[18:04:55.558]   - Field: ‘packages’
[18:04:55.558]   - Field: ‘gc’
[18:04:55.558]   - Field: ‘conditions’
[18:04:55.559]   - Field: ‘expr’
[18:04:55.559]   - Field: ‘uuid’
[18:04:55.559]   - Field: ‘seed’
[18:04:55.559]   - Field: ‘version’
[18:04:55.560]   - Field: ‘result’
[18:04:55.560]   - Field: ‘asynchronous’
[18:04:55.560]   - Field: ‘calls’
[18:04:55.560]   - Field: ‘globals’
[18:04:55.560]   - Field: ‘stdout’
[18:04:55.561]   - Field: ‘earlySignal’
[18:04:55.561]   - Field: ‘lazy’
[18:04:55.561]   - Field: ‘state’
[18:04:55.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.561] - Launch lazy future ...
[18:04:55.562] Packages needed by the future expression (n = 0): <none>
[18:04:55.562] Packages needed by future strategies (n = 0): <none>
[18:04:55.563] {
[18:04:55.563]     {
[18:04:55.563]         {
[18:04:55.563]             ...future.startTime <- base::Sys.time()
[18:04:55.563]             {
[18:04:55.563]                 {
[18:04:55.563]                   {
[18:04:55.563]                     base::local({
[18:04:55.563]                       has_future <- base::requireNamespace("future", 
[18:04:55.563]                         quietly = TRUE)
[18:04:55.563]                       if (has_future) {
[18:04:55.563]                         ns <- base::getNamespace("future")
[18:04:55.563]                         version <- ns[[".package"]][["version"]]
[18:04:55.563]                         if (is.null(version)) 
[18:04:55.563]                           version <- utils::packageVersion("future")
[18:04:55.563]                       }
[18:04:55.563]                       else {
[18:04:55.563]                         version <- NULL
[18:04:55.563]                       }
[18:04:55.563]                       if (!has_future || version < "1.8.0") {
[18:04:55.563]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.563]                           "", base::R.version$version.string), 
[18:04:55.563]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.563]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.563]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.563]                             "release", "version")], collapse = " "), 
[18:04:55.563]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.563]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.563]                           info)
[18:04:55.563]                         info <- base::paste(info, collapse = "; ")
[18:04:55.563]                         if (!has_future) {
[18:04:55.563]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.563]                             info)
[18:04:55.563]                         }
[18:04:55.563]                         else {
[18:04:55.563]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.563]                             info, version)
[18:04:55.563]                         }
[18:04:55.563]                         base::stop(msg)
[18:04:55.563]                       }
[18:04:55.563]                     })
[18:04:55.563]                   }
[18:04:55.563]                   ...future.strategy.old <- future::plan("list")
[18:04:55.563]                   options(future.plan = NULL)
[18:04:55.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.563]                 }
[18:04:55.563]                 ...future.workdir <- getwd()
[18:04:55.563]             }
[18:04:55.563]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.563]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.563]         }
[18:04:55.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.563]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.563]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.563]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.563]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.563]             base::names(...future.oldOptions))
[18:04:55.563]     }
[18:04:55.563]     if (FALSE) {
[18:04:55.563]     }
[18:04:55.563]     else {
[18:04:55.563]         if (TRUE) {
[18:04:55.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.563]                 open = "w")
[18:04:55.563]         }
[18:04:55.563]         else {
[18:04:55.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.563]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.563]         }
[18:04:55.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.563]             base::sink(type = "output", split = FALSE)
[18:04:55.563]             base::close(...future.stdout)
[18:04:55.563]         }, add = TRUE)
[18:04:55.563]     }
[18:04:55.563]     ...future.frame <- base::sys.nframe()
[18:04:55.563]     ...future.conditions <- base::list()
[18:04:55.563]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.563]     if (FALSE) {
[18:04:55.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.563]     }
[18:04:55.563]     ...future.result <- base::tryCatch({
[18:04:55.563]         base::withCallingHandlers({
[18:04:55.563]             ...future.value <- base::withVisible(base::local({
[18:04:55.563]                 b <- a * ii
[18:04:55.563]                 a <- 0
[18:04:55.563]                 b
[18:04:55.563]             }))
[18:04:55.563]             future::FutureResult(value = ...future.value$value, 
[18:04:55.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.563]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.563]                     ...future.globalenv.names))
[18:04:55.563]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.563]         }, condition = base::local({
[18:04:55.563]             c <- base::c
[18:04:55.563]             inherits <- base::inherits
[18:04:55.563]             invokeRestart <- base::invokeRestart
[18:04:55.563]             length <- base::length
[18:04:55.563]             list <- base::list
[18:04:55.563]             seq.int <- base::seq.int
[18:04:55.563]             signalCondition <- base::signalCondition
[18:04:55.563]             sys.calls <- base::sys.calls
[18:04:55.563]             `[[` <- base::`[[`
[18:04:55.563]             `+` <- base::`+`
[18:04:55.563]             `<<-` <- base::`<<-`
[18:04:55.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.563]                   3L)]
[18:04:55.563]             }
[18:04:55.563]             function(cond) {
[18:04:55.563]                 is_error <- inherits(cond, "error")
[18:04:55.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.563]                   NULL)
[18:04:55.563]                 if (is_error) {
[18:04:55.563]                   sessionInformation <- function() {
[18:04:55.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.563]                       search = base::search(), system = base::Sys.info())
[18:04:55.563]                   }
[18:04:55.563]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.563]                     cond$call), session = sessionInformation(), 
[18:04:55.563]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.563]                   signalCondition(cond)
[18:04:55.563]                 }
[18:04:55.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.563]                 "immediateCondition"))) {
[18:04:55.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.563]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.563]                   if (TRUE && !signal) {
[18:04:55.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.563]                     {
[18:04:55.563]                       inherits <- base::inherits
[18:04:55.563]                       invokeRestart <- base::invokeRestart
[18:04:55.563]                       is.null <- base::is.null
[18:04:55.563]                       muffled <- FALSE
[18:04:55.563]                       if (inherits(cond, "message")) {
[18:04:55.563]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.563]                         if (muffled) 
[18:04:55.563]                           invokeRestart("muffleMessage")
[18:04:55.563]                       }
[18:04:55.563]                       else if (inherits(cond, "warning")) {
[18:04:55.563]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.563]                         if (muffled) 
[18:04:55.563]                           invokeRestart("muffleWarning")
[18:04:55.563]                       }
[18:04:55.563]                       else if (inherits(cond, "condition")) {
[18:04:55.563]                         if (!is.null(pattern)) {
[18:04:55.563]                           computeRestarts <- base::computeRestarts
[18:04:55.563]                           grepl <- base::grepl
[18:04:55.563]                           restarts <- computeRestarts(cond)
[18:04:55.563]                           for (restart in restarts) {
[18:04:55.563]                             name <- restart$name
[18:04:55.563]                             if (is.null(name)) 
[18:04:55.563]                               next
[18:04:55.563]                             if (!grepl(pattern, name)) 
[18:04:55.563]                               next
[18:04:55.563]                             invokeRestart(restart)
[18:04:55.563]                             muffled <- TRUE
[18:04:55.563]                             break
[18:04:55.563]                           }
[18:04:55.563]                         }
[18:04:55.563]                       }
[18:04:55.563]                       invisible(muffled)
[18:04:55.563]                     }
[18:04:55.563]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.563]                   }
[18:04:55.563]                 }
[18:04:55.563]                 else {
[18:04:55.563]                   if (TRUE) {
[18:04:55.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.563]                     {
[18:04:55.563]                       inherits <- base::inherits
[18:04:55.563]                       invokeRestart <- base::invokeRestart
[18:04:55.563]                       is.null <- base::is.null
[18:04:55.563]                       muffled <- FALSE
[18:04:55.563]                       if (inherits(cond, "message")) {
[18:04:55.563]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.563]                         if (muffled) 
[18:04:55.563]                           invokeRestart("muffleMessage")
[18:04:55.563]                       }
[18:04:55.563]                       else if (inherits(cond, "warning")) {
[18:04:55.563]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.563]                         if (muffled) 
[18:04:55.563]                           invokeRestart("muffleWarning")
[18:04:55.563]                       }
[18:04:55.563]                       else if (inherits(cond, "condition")) {
[18:04:55.563]                         if (!is.null(pattern)) {
[18:04:55.563]                           computeRestarts <- base::computeRestarts
[18:04:55.563]                           grepl <- base::grepl
[18:04:55.563]                           restarts <- computeRestarts(cond)
[18:04:55.563]                           for (restart in restarts) {
[18:04:55.563]                             name <- restart$name
[18:04:55.563]                             if (is.null(name)) 
[18:04:55.563]                               next
[18:04:55.563]                             if (!grepl(pattern, name)) 
[18:04:55.563]                               next
[18:04:55.563]                             invokeRestart(restart)
[18:04:55.563]                             muffled <- TRUE
[18:04:55.563]                             break
[18:04:55.563]                           }
[18:04:55.563]                         }
[18:04:55.563]                       }
[18:04:55.563]                       invisible(muffled)
[18:04:55.563]                     }
[18:04:55.563]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.563]                   }
[18:04:55.563]                 }
[18:04:55.563]             }
[18:04:55.563]         }))
[18:04:55.563]     }, error = function(ex) {
[18:04:55.563]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.563]                 ...future.rng), started = ...future.startTime, 
[18:04:55.563]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.563]             version = "1.8"), class = "FutureResult")
[18:04:55.563]     }, finally = {
[18:04:55.563]         if (!identical(...future.workdir, getwd())) 
[18:04:55.563]             setwd(...future.workdir)
[18:04:55.563]         {
[18:04:55.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.563]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.563]             }
[18:04:55.563]             base::options(...future.oldOptions)
[18:04:55.563]             if (.Platform$OS.type == "windows") {
[18:04:55.563]                 old_names <- names(...future.oldEnvVars)
[18:04:55.563]                 envs <- base::Sys.getenv()
[18:04:55.563]                 names <- names(envs)
[18:04:55.563]                 common <- intersect(names, old_names)
[18:04:55.563]                 added <- setdiff(names, old_names)
[18:04:55.563]                 removed <- setdiff(old_names, names)
[18:04:55.563]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.563]                   envs[common]]
[18:04:55.563]                 NAMES <- toupper(changed)
[18:04:55.563]                 args <- list()
[18:04:55.563]                 for (kk in seq_along(NAMES)) {
[18:04:55.563]                   name <- changed[[kk]]
[18:04:55.563]                   NAME <- NAMES[[kk]]
[18:04:55.563]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.563]                     next
[18:04:55.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.563]                 }
[18:04:55.563]                 NAMES <- toupper(added)
[18:04:55.563]                 for (kk in seq_along(NAMES)) {
[18:04:55.563]                   name <- added[[kk]]
[18:04:55.563]                   NAME <- NAMES[[kk]]
[18:04:55.563]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.563]                     next
[18:04:55.563]                   args[[name]] <- ""
[18:04:55.563]                 }
[18:04:55.563]                 NAMES <- toupper(removed)
[18:04:55.563]                 for (kk in seq_along(NAMES)) {
[18:04:55.563]                   name <- removed[[kk]]
[18:04:55.563]                   NAME <- NAMES[[kk]]
[18:04:55.563]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.563]                     next
[18:04:55.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.563]                 }
[18:04:55.563]                 if (length(args) > 0) 
[18:04:55.563]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.563]             }
[18:04:55.563]             else {
[18:04:55.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.563]             }
[18:04:55.563]             {
[18:04:55.563]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.563]                   0L) {
[18:04:55.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.563]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.563]                   base::options(opts)
[18:04:55.563]                 }
[18:04:55.563]                 {
[18:04:55.563]                   {
[18:04:55.563]                     NULL
[18:04:55.563]                     RNGkind("Mersenne-Twister")
[18:04:55.563]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.563]                       inherits = FALSE)
[18:04:55.563]                   }
[18:04:55.563]                   options(future.plan = NULL)
[18:04:55.563]                   if (is.na(NA_character_)) 
[18:04:55.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.563]                     .init = FALSE)
[18:04:55.563]                 }
[18:04:55.563]             }
[18:04:55.563]         }
[18:04:55.563]     })
[18:04:55.563]     if (TRUE) {
[18:04:55.563]         base::sink(type = "output", split = FALSE)
[18:04:55.563]         if (TRUE) {
[18:04:55.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.563]         }
[18:04:55.563]         else {
[18:04:55.563]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.563]         }
[18:04:55.563]         base::close(...future.stdout)
[18:04:55.563]         ...future.stdout <- NULL
[18:04:55.563]     }
[18:04:55.563]     ...future.result$conditions <- ...future.conditions
[18:04:55.563]     ...future.result$finished <- base::Sys.time()
[18:04:55.563]     ...future.result
[18:04:55.563] }
[18:04:55.566] assign_globals() ...
[18:04:55.566] List of 2
[18:04:55.566]  $ a : num 1
[18:04:55.566]  $ ii: int 1
[18:04:55.566]  - attr(*, "where")=List of 2
[18:04:55.566]   ..$ a :<environment: R_EmptyEnv> 
[18:04:55.566]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.566]  - attr(*, "resolved")= logi TRUE
[18:04:55.566]  - attr(*, "total_size")= num 112
[18:04:55.566]  - attr(*, "already-done")= logi TRUE
[18:04:55.573] - copied ‘a’ to environment
[18:04:55.573] - copied ‘ii’ to environment
[18:04:55.574] assign_globals() ... done
[18:04:55.574] plan(): Setting new future strategy stack:
[18:04:55.574] List of future strategies:
[18:04:55.574] 1. sequential:
[18:04:55.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.574]    - tweaked: FALSE
[18:04:55.574]    - call: NULL
[18:04:55.575] plan(): nbrOfWorkers() = 1
[18:04:55.577] plan(): Setting new future strategy stack:
[18:04:55.577] List of future strategies:
[18:04:55.577] 1. sequential:
[18:04:55.577]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.577]    - tweaked: FALSE
[18:04:55.577]    - call: plan(strategy)
[18:04:55.578] plan(): nbrOfWorkers() = 1
[18:04:55.579] SequentialFuture started (and completed)
[18:04:55.579] - Launch lazy future ... done
[18:04:55.579] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.580] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.581] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.585] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.585] Searching for globals ... DONE
[18:04:55.585] Resolving globals: TRUE
[18:04:55.586] Resolving any globals that are futures ...
[18:04:55.586] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.586] Resolving any globals that are futures ... DONE
[18:04:55.587] Resolving futures part of globals (recursively) ...
[18:04:55.587] resolve() on list ...
[18:04:55.588]  recursive: 99
[18:04:55.588]  length: 2
[18:04:55.588]  elements: ‘a’, ‘ii’
[18:04:55.588]  length: 1 (resolved future 1)
[18:04:55.589]  length: 0 (resolved future 2)
[18:04:55.589] resolve() on list ... DONE
[18:04:55.589] - globals: [2] ‘a’, ‘ii’
[18:04:55.589] Resolving futures part of globals (recursively) ... DONE
[18:04:55.590] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:55.590] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.591] - globals: [2] ‘a’, ‘ii’
[18:04:55.591] 
[18:04:55.591] getGlobalsAndPackages() ... DONE
[18:04:55.592] run() for ‘Future’ ...
[18:04:55.592] - state: ‘created’
[18:04:55.592] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.593] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.593] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.593]   - Field: ‘label’
[18:04:55.593]   - Field: ‘local’
[18:04:55.594]   - Field: ‘owner’
[18:04:55.594]   - Field: ‘envir’
[18:04:55.594]   - Field: ‘packages’
[18:04:55.594]   - Field: ‘gc’
[18:04:55.595]   - Field: ‘conditions’
[18:04:55.595]   - Field: ‘expr’
[18:04:55.595]   - Field: ‘uuid’
[18:04:55.595]   - Field: ‘seed’
[18:04:55.595]   - Field: ‘version’
[18:04:55.595]   - Field: ‘result’
[18:04:55.596]   - Field: ‘asynchronous’
[18:04:55.596]   - Field: ‘calls’
[18:04:55.596]   - Field: ‘globals’
[18:04:55.596]   - Field: ‘stdout’
[18:04:55.597]   - Field: ‘earlySignal’
[18:04:55.597]   - Field: ‘lazy’
[18:04:55.597]   - Field: ‘state’
[18:04:55.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.597] - Launch lazy future ...
[18:04:55.598] Packages needed by the future expression (n = 0): <none>
[18:04:55.598] Packages needed by future strategies (n = 0): <none>
[18:04:55.599] {
[18:04:55.599]     {
[18:04:55.599]         {
[18:04:55.599]             ...future.startTime <- base::Sys.time()
[18:04:55.599]             {
[18:04:55.599]                 {
[18:04:55.599]                   {
[18:04:55.599]                     base::local({
[18:04:55.599]                       has_future <- base::requireNamespace("future", 
[18:04:55.599]                         quietly = TRUE)
[18:04:55.599]                       if (has_future) {
[18:04:55.599]                         ns <- base::getNamespace("future")
[18:04:55.599]                         version <- ns[[".package"]][["version"]]
[18:04:55.599]                         if (is.null(version)) 
[18:04:55.599]                           version <- utils::packageVersion("future")
[18:04:55.599]                       }
[18:04:55.599]                       else {
[18:04:55.599]                         version <- NULL
[18:04:55.599]                       }
[18:04:55.599]                       if (!has_future || version < "1.8.0") {
[18:04:55.599]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.599]                           "", base::R.version$version.string), 
[18:04:55.599]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.599]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.599]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.599]                             "release", "version")], collapse = " "), 
[18:04:55.599]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.599]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.599]                           info)
[18:04:55.599]                         info <- base::paste(info, collapse = "; ")
[18:04:55.599]                         if (!has_future) {
[18:04:55.599]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.599]                             info)
[18:04:55.599]                         }
[18:04:55.599]                         else {
[18:04:55.599]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.599]                             info, version)
[18:04:55.599]                         }
[18:04:55.599]                         base::stop(msg)
[18:04:55.599]                       }
[18:04:55.599]                     })
[18:04:55.599]                   }
[18:04:55.599]                   ...future.strategy.old <- future::plan("list")
[18:04:55.599]                   options(future.plan = NULL)
[18:04:55.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.599]                 }
[18:04:55.599]                 ...future.workdir <- getwd()
[18:04:55.599]             }
[18:04:55.599]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.599]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.599]         }
[18:04:55.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.599]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.599]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.599]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.599]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.599]             base::names(...future.oldOptions))
[18:04:55.599]     }
[18:04:55.599]     if (FALSE) {
[18:04:55.599]     }
[18:04:55.599]     else {
[18:04:55.599]         if (TRUE) {
[18:04:55.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.599]                 open = "w")
[18:04:55.599]         }
[18:04:55.599]         else {
[18:04:55.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.599]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.599]         }
[18:04:55.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.599]             base::sink(type = "output", split = FALSE)
[18:04:55.599]             base::close(...future.stdout)
[18:04:55.599]         }, add = TRUE)
[18:04:55.599]     }
[18:04:55.599]     ...future.frame <- base::sys.nframe()
[18:04:55.599]     ...future.conditions <- base::list()
[18:04:55.599]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.599]     if (FALSE) {
[18:04:55.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.599]     }
[18:04:55.599]     ...future.result <- base::tryCatch({
[18:04:55.599]         base::withCallingHandlers({
[18:04:55.599]             ...future.value <- base::withVisible(base::local({
[18:04:55.599]                 b <- a * ii
[18:04:55.599]                 a <- 0
[18:04:55.599]                 b
[18:04:55.599]             }))
[18:04:55.599]             future::FutureResult(value = ...future.value$value, 
[18:04:55.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.599]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.599]                     ...future.globalenv.names))
[18:04:55.599]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.599]         }, condition = base::local({
[18:04:55.599]             c <- base::c
[18:04:55.599]             inherits <- base::inherits
[18:04:55.599]             invokeRestart <- base::invokeRestart
[18:04:55.599]             length <- base::length
[18:04:55.599]             list <- base::list
[18:04:55.599]             seq.int <- base::seq.int
[18:04:55.599]             signalCondition <- base::signalCondition
[18:04:55.599]             sys.calls <- base::sys.calls
[18:04:55.599]             `[[` <- base::`[[`
[18:04:55.599]             `+` <- base::`+`
[18:04:55.599]             `<<-` <- base::`<<-`
[18:04:55.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.599]                   3L)]
[18:04:55.599]             }
[18:04:55.599]             function(cond) {
[18:04:55.599]                 is_error <- inherits(cond, "error")
[18:04:55.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.599]                   NULL)
[18:04:55.599]                 if (is_error) {
[18:04:55.599]                   sessionInformation <- function() {
[18:04:55.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.599]                       search = base::search(), system = base::Sys.info())
[18:04:55.599]                   }
[18:04:55.599]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.599]                     cond$call), session = sessionInformation(), 
[18:04:55.599]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.599]                   signalCondition(cond)
[18:04:55.599]                 }
[18:04:55.599]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.599]                 "immediateCondition"))) {
[18:04:55.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.599]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.599]                   if (TRUE && !signal) {
[18:04:55.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.599]                     {
[18:04:55.599]                       inherits <- base::inherits
[18:04:55.599]                       invokeRestart <- base::invokeRestart
[18:04:55.599]                       is.null <- base::is.null
[18:04:55.599]                       muffled <- FALSE
[18:04:55.599]                       if (inherits(cond, "message")) {
[18:04:55.599]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.599]                         if (muffled) 
[18:04:55.599]                           invokeRestart("muffleMessage")
[18:04:55.599]                       }
[18:04:55.599]                       else if (inherits(cond, "warning")) {
[18:04:55.599]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.599]                         if (muffled) 
[18:04:55.599]                           invokeRestart("muffleWarning")
[18:04:55.599]                       }
[18:04:55.599]                       else if (inherits(cond, "condition")) {
[18:04:55.599]                         if (!is.null(pattern)) {
[18:04:55.599]                           computeRestarts <- base::computeRestarts
[18:04:55.599]                           grepl <- base::grepl
[18:04:55.599]                           restarts <- computeRestarts(cond)
[18:04:55.599]                           for (restart in restarts) {
[18:04:55.599]                             name <- restart$name
[18:04:55.599]                             if (is.null(name)) 
[18:04:55.599]                               next
[18:04:55.599]                             if (!grepl(pattern, name)) 
[18:04:55.599]                               next
[18:04:55.599]                             invokeRestart(restart)
[18:04:55.599]                             muffled <- TRUE
[18:04:55.599]                             break
[18:04:55.599]                           }
[18:04:55.599]                         }
[18:04:55.599]                       }
[18:04:55.599]                       invisible(muffled)
[18:04:55.599]                     }
[18:04:55.599]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.599]                   }
[18:04:55.599]                 }
[18:04:55.599]                 else {
[18:04:55.599]                   if (TRUE) {
[18:04:55.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.599]                     {
[18:04:55.599]                       inherits <- base::inherits
[18:04:55.599]                       invokeRestart <- base::invokeRestart
[18:04:55.599]                       is.null <- base::is.null
[18:04:55.599]                       muffled <- FALSE
[18:04:55.599]                       if (inherits(cond, "message")) {
[18:04:55.599]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.599]                         if (muffled) 
[18:04:55.599]                           invokeRestart("muffleMessage")
[18:04:55.599]                       }
[18:04:55.599]                       else if (inherits(cond, "warning")) {
[18:04:55.599]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.599]                         if (muffled) 
[18:04:55.599]                           invokeRestart("muffleWarning")
[18:04:55.599]                       }
[18:04:55.599]                       else if (inherits(cond, "condition")) {
[18:04:55.599]                         if (!is.null(pattern)) {
[18:04:55.599]                           computeRestarts <- base::computeRestarts
[18:04:55.599]                           grepl <- base::grepl
[18:04:55.599]                           restarts <- computeRestarts(cond)
[18:04:55.599]                           for (restart in restarts) {
[18:04:55.599]                             name <- restart$name
[18:04:55.599]                             if (is.null(name)) 
[18:04:55.599]                               next
[18:04:55.599]                             if (!grepl(pattern, name)) 
[18:04:55.599]                               next
[18:04:55.599]                             invokeRestart(restart)
[18:04:55.599]                             muffled <- TRUE
[18:04:55.599]                             break
[18:04:55.599]                           }
[18:04:55.599]                         }
[18:04:55.599]                       }
[18:04:55.599]                       invisible(muffled)
[18:04:55.599]                     }
[18:04:55.599]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.599]                   }
[18:04:55.599]                 }
[18:04:55.599]             }
[18:04:55.599]         }))
[18:04:55.599]     }, error = function(ex) {
[18:04:55.599]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.599]                 ...future.rng), started = ...future.startTime, 
[18:04:55.599]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.599]             version = "1.8"), class = "FutureResult")
[18:04:55.599]     }, finally = {
[18:04:55.599]         if (!identical(...future.workdir, getwd())) 
[18:04:55.599]             setwd(...future.workdir)
[18:04:55.599]         {
[18:04:55.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.599]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.599]             }
[18:04:55.599]             base::options(...future.oldOptions)
[18:04:55.599]             if (.Platform$OS.type == "windows") {
[18:04:55.599]                 old_names <- names(...future.oldEnvVars)
[18:04:55.599]                 envs <- base::Sys.getenv()
[18:04:55.599]                 names <- names(envs)
[18:04:55.599]                 common <- intersect(names, old_names)
[18:04:55.599]                 added <- setdiff(names, old_names)
[18:04:55.599]                 removed <- setdiff(old_names, names)
[18:04:55.599]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.599]                   envs[common]]
[18:04:55.599]                 NAMES <- toupper(changed)
[18:04:55.599]                 args <- list()
[18:04:55.599]                 for (kk in seq_along(NAMES)) {
[18:04:55.599]                   name <- changed[[kk]]
[18:04:55.599]                   NAME <- NAMES[[kk]]
[18:04:55.599]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.599]                     next
[18:04:55.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.599]                 }
[18:04:55.599]                 NAMES <- toupper(added)
[18:04:55.599]                 for (kk in seq_along(NAMES)) {
[18:04:55.599]                   name <- added[[kk]]
[18:04:55.599]                   NAME <- NAMES[[kk]]
[18:04:55.599]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.599]                     next
[18:04:55.599]                   args[[name]] <- ""
[18:04:55.599]                 }
[18:04:55.599]                 NAMES <- toupper(removed)
[18:04:55.599]                 for (kk in seq_along(NAMES)) {
[18:04:55.599]                   name <- removed[[kk]]
[18:04:55.599]                   NAME <- NAMES[[kk]]
[18:04:55.599]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.599]                     next
[18:04:55.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.599]                 }
[18:04:55.599]                 if (length(args) > 0) 
[18:04:55.599]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.599]             }
[18:04:55.599]             else {
[18:04:55.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.599]             }
[18:04:55.599]             {
[18:04:55.599]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.599]                   0L) {
[18:04:55.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.599]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.599]                   base::options(opts)
[18:04:55.599]                 }
[18:04:55.599]                 {
[18:04:55.599]                   {
[18:04:55.599]                     NULL
[18:04:55.599]                     RNGkind("Mersenne-Twister")
[18:04:55.599]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.599]                       inherits = FALSE)
[18:04:55.599]                   }
[18:04:55.599]                   options(future.plan = NULL)
[18:04:55.599]                   if (is.na(NA_character_)) 
[18:04:55.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.599]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.599]                     .init = FALSE)
[18:04:55.599]                 }
[18:04:55.599]             }
[18:04:55.599]         }
[18:04:55.599]     })
[18:04:55.599]     if (TRUE) {
[18:04:55.599]         base::sink(type = "output", split = FALSE)
[18:04:55.599]         if (TRUE) {
[18:04:55.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.599]         }
[18:04:55.599]         else {
[18:04:55.599]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.599]         }
[18:04:55.599]         base::close(...future.stdout)
[18:04:55.599]         ...future.stdout <- NULL
[18:04:55.599]     }
[18:04:55.599]     ...future.result$conditions <- ...future.conditions
[18:04:55.599]     ...future.result$finished <- base::Sys.time()
[18:04:55.599]     ...future.result
[18:04:55.599] }
[18:04:55.602] assign_globals() ...
[18:04:55.602] List of 2
[18:04:55.602]  $ a : num 1
[18:04:55.602]  $ ii: int 2
[18:04:55.602]  - attr(*, "where")=List of 2
[18:04:55.602]   ..$ a :<environment: R_EmptyEnv> 
[18:04:55.602]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.602]  - attr(*, "resolved")= logi TRUE
[18:04:55.602]  - attr(*, "total_size")= num 112
[18:04:55.602]  - attr(*, "already-done")= logi TRUE
[18:04:55.609] - copied ‘a’ to environment
[18:04:55.609] - copied ‘ii’ to environment
[18:04:55.610] assign_globals() ... done
[18:04:55.610] plan(): Setting new future strategy stack:
[18:04:55.610] List of future strategies:
[18:04:55.610] 1. sequential:
[18:04:55.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.610]    - tweaked: FALSE
[18:04:55.610]    - call: NULL
[18:04:55.614] plan(): nbrOfWorkers() = 1
[18:04:55.616] plan(): Setting new future strategy stack:
[18:04:55.616] List of future strategies:
[18:04:55.616] 1. sequential:
[18:04:55.616]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.616]    - tweaked: FALSE
[18:04:55.616]    - call: plan(strategy)
[18:04:55.617] plan(): nbrOfWorkers() = 1
[18:04:55.618] SequentialFuture started (and completed)
[18:04:55.618] - Launch lazy future ... done
[18:04:55.618] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.619] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.620] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.624] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.624] Searching for globals ... DONE
[18:04:55.624] Resolving globals: TRUE
[18:04:55.625] Resolving any globals that are futures ...
[18:04:55.625] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.625] Resolving any globals that are futures ... DONE
[18:04:55.626] Resolving futures part of globals (recursively) ...
[18:04:55.626] resolve() on list ...
[18:04:55.626]  recursive: 99
[18:04:55.627]  length: 2
[18:04:55.627]  elements: ‘a’, ‘ii’
[18:04:55.627]  length: 1 (resolved future 1)
[18:04:55.627]  length: 0 (resolved future 2)
[18:04:55.628] resolve() on list ... DONE
[18:04:55.628] - globals: [2] ‘a’, ‘ii’
[18:04:55.628] Resolving futures part of globals (recursively) ... DONE
[18:04:55.628] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:55.629] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.629] - globals: [2] ‘a’, ‘ii’
[18:04:55.630] 
[18:04:55.630] getGlobalsAndPackages() ... DONE
[18:04:55.631] run() for ‘Future’ ...
[18:04:55.631] - state: ‘created’
[18:04:55.631] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.632] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.632]   - Field: ‘label’
[18:04:55.632]   - Field: ‘local’
[18:04:55.633]   - Field: ‘owner’
[18:04:55.633]   - Field: ‘envir’
[18:04:55.633]   - Field: ‘packages’
[18:04:55.633]   - Field: ‘gc’
[18:04:55.633]   - Field: ‘conditions’
[18:04:55.634]   - Field: ‘expr’
[18:04:55.634]   - Field: ‘uuid’
[18:04:55.634]   - Field: ‘seed’
[18:04:55.634]   - Field: ‘version’
[18:04:55.634]   - Field: ‘result’
[18:04:55.635]   - Field: ‘asynchronous’
[18:04:55.635]   - Field: ‘calls’
[18:04:55.635]   - Field: ‘globals’
[18:04:55.635]   - Field: ‘stdout’
[18:04:55.635]   - Field: ‘earlySignal’
[18:04:55.636]   - Field: ‘lazy’
[18:04:55.636]   - Field: ‘state’
[18:04:55.636] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.636] - Launch lazy future ...
[18:04:55.637] Packages needed by the future expression (n = 0): <none>
[18:04:55.637] Packages needed by future strategies (n = 0): <none>
[18:04:55.638] {
[18:04:55.638]     {
[18:04:55.638]         {
[18:04:55.638]             ...future.startTime <- base::Sys.time()
[18:04:55.638]             {
[18:04:55.638]                 {
[18:04:55.638]                   {
[18:04:55.638]                     base::local({
[18:04:55.638]                       has_future <- base::requireNamespace("future", 
[18:04:55.638]                         quietly = TRUE)
[18:04:55.638]                       if (has_future) {
[18:04:55.638]                         ns <- base::getNamespace("future")
[18:04:55.638]                         version <- ns[[".package"]][["version"]]
[18:04:55.638]                         if (is.null(version)) 
[18:04:55.638]                           version <- utils::packageVersion("future")
[18:04:55.638]                       }
[18:04:55.638]                       else {
[18:04:55.638]                         version <- NULL
[18:04:55.638]                       }
[18:04:55.638]                       if (!has_future || version < "1.8.0") {
[18:04:55.638]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.638]                           "", base::R.version$version.string), 
[18:04:55.638]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.638]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.638]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.638]                             "release", "version")], collapse = " "), 
[18:04:55.638]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.638]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.638]                           info)
[18:04:55.638]                         info <- base::paste(info, collapse = "; ")
[18:04:55.638]                         if (!has_future) {
[18:04:55.638]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.638]                             info)
[18:04:55.638]                         }
[18:04:55.638]                         else {
[18:04:55.638]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.638]                             info, version)
[18:04:55.638]                         }
[18:04:55.638]                         base::stop(msg)
[18:04:55.638]                       }
[18:04:55.638]                     })
[18:04:55.638]                   }
[18:04:55.638]                   ...future.strategy.old <- future::plan("list")
[18:04:55.638]                   options(future.plan = NULL)
[18:04:55.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.638]                 }
[18:04:55.638]                 ...future.workdir <- getwd()
[18:04:55.638]             }
[18:04:55.638]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.638]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.638]         }
[18:04:55.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.638]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.638]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.638]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.638]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.638]             base::names(...future.oldOptions))
[18:04:55.638]     }
[18:04:55.638]     if (FALSE) {
[18:04:55.638]     }
[18:04:55.638]     else {
[18:04:55.638]         if (TRUE) {
[18:04:55.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.638]                 open = "w")
[18:04:55.638]         }
[18:04:55.638]         else {
[18:04:55.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.638]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.638]         }
[18:04:55.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.638]             base::sink(type = "output", split = FALSE)
[18:04:55.638]             base::close(...future.stdout)
[18:04:55.638]         }, add = TRUE)
[18:04:55.638]     }
[18:04:55.638]     ...future.frame <- base::sys.nframe()
[18:04:55.638]     ...future.conditions <- base::list()
[18:04:55.638]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.638]     if (FALSE) {
[18:04:55.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.638]     }
[18:04:55.638]     ...future.result <- base::tryCatch({
[18:04:55.638]         base::withCallingHandlers({
[18:04:55.638]             ...future.value <- base::withVisible(base::local({
[18:04:55.638]                 b <- a * ii
[18:04:55.638]                 a <- 0
[18:04:55.638]                 b
[18:04:55.638]             }))
[18:04:55.638]             future::FutureResult(value = ...future.value$value, 
[18:04:55.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.638]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.638]                     ...future.globalenv.names))
[18:04:55.638]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.638]         }, condition = base::local({
[18:04:55.638]             c <- base::c
[18:04:55.638]             inherits <- base::inherits
[18:04:55.638]             invokeRestart <- base::invokeRestart
[18:04:55.638]             length <- base::length
[18:04:55.638]             list <- base::list
[18:04:55.638]             seq.int <- base::seq.int
[18:04:55.638]             signalCondition <- base::signalCondition
[18:04:55.638]             sys.calls <- base::sys.calls
[18:04:55.638]             `[[` <- base::`[[`
[18:04:55.638]             `+` <- base::`+`
[18:04:55.638]             `<<-` <- base::`<<-`
[18:04:55.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.638]                   3L)]
[18:04:55.638]             }
[18:04:55.638]             function(cond) {
[18:04:55.638]                 is_error <- inherits(cond, "error")
[18:04:55.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.638]                   NULL)
[18:04:55.638]                 if (is_error) {
[18:04:55.638]                   sessionInformation <- function() {
[18:04:55.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.638]                       search = base::search(), system = base::Sys.info())
[18:04:55.638]                   }
[18:04:55.638]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.638]                     cond$call), session = sessionInformation(), 
[18:04:55.638]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.638]                   signalCondition(cond)
[18:04:55.638]                 }
[18:04:55.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.638]                 "immediateCondition"))) {
[18:04:55.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.638]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.638]                   if (TRUE && !signal) {
[18:04:55.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.638]                     {
[18:04:55.638]                       inherits <- base::inherits
[18:04:55.638]                       invokeRestart <- base::invokeRestart
[18:04:55.638]                       is.null <- base::is.null
[18:04:55.638]                       muffled <- FALSE
[18:04:55.638]                       if (inherits(cond, "message")) {
[18:04:55.638]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.638]                         if (muffled) 
[18:04:55.638]                           invokeRestart("muffleMessage")
[18:04:55.638]                       }
[18:04:55.638]                       else if (inherits(cond, "warning")) {
[18:04:55.638]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.638]                         if (muffled) 
[18:04:55.638]                           invokeRestart("muffleWarning")
[18:04:55.638]                       }
[18:04:55.638]                       else if (inherits(cond, "condition")) {
[18:04:55.638]                         if (!is.null(pattern)) {
[18:04:55.638]                           computeRestarts <- base::computeRestarts
[18:04:55.638]                           grepl <- base::grepl
[18:04:55.638]                           restarts <- computeRestarts(cond)
[18:04:55.638]                           for (restart in restarts) {
[18:04:55.638]                             name <- restart$name
[18:04:55.638]                             if (is.null(name)) 
[18:04:55.638]                               next
[18:04:55.638]                             if (!grepl(pattern, name)) 
[18:04:55.638]                               next
[18:04:55.638]                             invokeRestart(restart)
[18:04:55.638]                             muffled <- TRUE
[18:04:55.638]                             break
[18:04:55.638]                           }
[18:04:55.638]                         }
[18:04:55.638]                       }
[18:04:55.638]                       invisible(muffled)
[18:04:55.638]                     }
[18:04:55.638]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.638]                   }
[18:04:55.638]                 }
[18:04:55.638]                 else {
[18:04:55.638]                   if (TRUE) {
[18:04:55.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.638]                     {
[18:04:55.638]                       inherits <- base::inherits
[18:04:55.638]                       invokeRestart <- base::invokeRestart
[18:04:55.638]                       is.null <- base::is.null
[18:04:55.638]                       muffled <- FALSE
[18:04:55.638]                       if (inherits(cond, "message")) {
[18:04:55.638]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.638]                         if (muffled) 
[18:04:55.638]                           invokeRestart("muffleMessage")
[18:04:55.638]                       }
[18:04:55.638]                       else if (inherits(cond, "warning")) {
[18:04:55.638]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.638]                         if (muffled) 
[18:04:55.638]                           invokeRestart("muffleWarning")
[18:04:55.638]                       }
[18:04:55.638]                       else if (inherits(cond, "condition")) {
[18:04:55.638]                         if (!is.null(pattern)) {
[18:04:55.638]                           computeRestarts <- base::computeRestarts
[18:04:55.638]                           grepl <- base::grepl
[18:04:55.638]                           restarts <- computeRestarts(cond)
[18:04:55.638]                           for (restart in restarts) {
[18:04:55.638]                             name <- restart$name
[18:04:55.638]                             if (is.null(name)) 
[18:04:55.638]                               next
[18:04:55.638]                             if (!grepl(pattern, name)) 
[18:04:55.638]                               next
[18:04:55.638]                             invokeRestart(restart)
[18:04:55.638]                             muffled <- TRUE
[18:04:55.638]                             break
[18:04:55.638]                           }
[18:04:55.638]                         }
[18:04:55.638]                       }
[18:04:55.638]                       invisible(muffled)
[18:04:55.638]                     }
[18:04:55.638]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.638]                   }
[18:04:55.638]                 }
[18:04:55.638]             }
[18:04:55.638]         }))
[18:04:55.638]     }, error = function(ex) {
[18:04:55.638]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.638]                 ...future.rng), started = ...future.startTime, 
[18:04:55.638]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.638]             version = "1.8"), class = "FutureResult")
[18:04:55.638]     }, finally = {
[18:04:55.638]         if (!identical(...future.workdir, getwd())) 
[18:04:55.638]             setwd(...future.workdir)
[18:04:55.638]         {
[18:04:55.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.638]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.638]             }
[18:04:55.638]             base::options(...future.oldOptions)
[18:04:55.638]             if (.Platform$OS.type == "windows") {
[18:04:55.638]                 old_names <- names(...future.oldEnvVars)
[18:04:55.638]                 envs <- base::Sys.getenv()
[18:04:55.638]                 names <- names(envs)
[18:04:55.638]                 common <- intersect(names, old_names)
[18:04:55.638]                 added <- setdiff(names, old_names)
[18:04:55.638]                 removed <- setdiff(old_names, names)
[18:04:55.638]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.638]                   envs[common]]
[18:04:55.638]                 NAMES <- toupper(changed)
[18:04:55.638]                 args <- list()
[18:04:55.638]                 for (kk in seq_along(NAMES)) {
[18:04:55.638]                   name <- changed[[kk]]
[18:04:55.638]                   NAME <- NAMES[[kk]]
[18:04:55.638]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.638]                     next
[18:04:55.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.638]                 }
[18:04:55.638]                 NAMES <- toupper(added)
[18:04:55.638]                 for (kk in seq_along(NAMES)) {
[18:04:55.638]                   name <- added[[kk]]
[18:04:55.638]                   NAME <- NAMES[[kk]]
[18:04:55.638]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.638]                     next
[18:04:55.638]                   args[[name]] <- ""
[18:04:55.638]                 }
[18:04:55.638]                 NAMES <- toupper(removed)
[18:04:55.638]                 for (kk in seq_along(NAMES)) {
[18:04:55.638]                   name <- removed[[kk]]
[18:04:55.638]                   NAME <- NAMES[[kk]]
[18:04:55.638]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.638]                     next
[18:04:55.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.638]                 }
[18:04:55.638]                 if (length(args) > 0) 
[18:04:55.638]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.638]             }
[18:04:55.638]             else {
[18:04:55.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.638]             }
[18:04:55.638]             {
[18:04:55.638]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.638]                   0L) {
[18:04:55.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.638]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.638]                   base::options(opts)
[18:04:55.638]                 }
[18:04:55.638]                 {
[18:04:55.638]                   {
[18:04:55.638]                     NULL
[18:04:55.638]                     RNGkind("Mersenne-Twister")
[18:04:55.638]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.638]                       inherits = FALSE)
[18:04:55.638]                   }
[18:04:55.638]                   options(future.plan = NULL)
[18:04:55.638]                   if (is.na(NA_character_)) 
[18:04:55.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.638]                     .init = FALSE)
[18:04:55.638]                 }
[18:04:55.638]             }
[18:04:55.638]         }
[18:04:55.638]     })
[18:04:55.638]     if (TRUE) {
[18:04:55.638]         base::sink(type = "output", split = FALSE)
[18:04:55.638]         if (TRUE) {
[18:04:55.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.638]         }
[18:04:55.638]         else {
[18:04:55.638]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.638]         }
[18:04:55.638]         base::close(...future.stdout)
[18:04:55.638]         ...future.stdout <- NULL
[18:04:55.638]     }
[18:04:55.638]     ...future.result$conditions <- ...future.conditions
[18:04:55.638]     ...future.result$finished <- base::Sys.time()
[18:04:55.638]     ...future.result
[18:04:55.638] }
[18:04:55.641] assign_globals() ...
[18:04:55.641] List of 2
[18:04:55.641]  $ a : num 1
[18:04:55.641]  $ ii: int 3
[18:04:55.641]  - attr(*, "where")=List of 2
[18:04:55.641]   ..$ a :<environment: R_EmptyEnv> 
[18:04:55.641]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.641]  - attr(*, "resolved")= logi TRUE
[18:04:55.641]  - attr(*, "total_size")= num 112
[18:04:55.641]  - attr(*, "already-done")= logi TRUE
[18:04:55.648] - copied ‘a’ to environment
[18:04:55.649] - copied ‘ii’ to environment
[18:04:55.649] assign_globals() ... done
[18:04:55.649] plan(): Setting new future strategy stack:
[18:04:55.650] List of future strategies:
[18:04:55.650] 1. sequential:
[18:04:55.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.650]    - tweaked: FALSE
[18:04:55.650]    - call: NULL
[18:04:55.651] plan(): nbrOfWorkers() = 1
[18:04:55.652] plan(): Setting new future strategy stack:
[18:04:55.652] List of future strategies:
[18:04:55.652] 1. sequential:
[18:04:55.652]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.652]    - tweaked: FALSE
[18:04:55.652]    - call: plan(strategy)
[18:04:55.654] plan(): nbrOfWorkers() = 1
[18:04:55.654] SequentialFuture started (and completed)
[18:04:55.654] - Launch lazy future ... done
[18:04:55.654] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.656] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.657] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.661] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.661] Searching for globals ... DONE
[18:04:55.662] Resolving globals: TRUE
[18:04:55.662] Resolving any globals that are futures ...
[18:04:55.662] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.662] Resolving any globals that are futures ... DONE
[18:04:55.663] Resolving futures part of globals (recursively) ...
[18:04:55.664] resolve() on list ...
[18:04:55.664]  recursive: 99
[18:04:55.665]  length: 2
[18:04:55.665]  elements: ‘a’, ‘ii’
[18:04:55.665]  length: 1 (resolved future 1)
[18:04:55.665]  length: 0 (resolved future 2)
[18:04:55.665] resolve() on list ... DONE
[18:04:55.666] - globals: [2] ‘a’, ‘ii’
[18:04:55.666] Resolving futures part of globals (recursively) ... DONE
[18:04:55.666] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:55.667] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.667] - globals: [2] ‘a’, ‘ii’
[18:04:55.668] 
[18:04:55.668] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.669] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.670] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.676] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.677] Searching for globals ... DONE
[18:04:55.677] Resolving globals: TRUE
[18:04:55.677] Resolving any globals that are futures ...
[18:04:55.677] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.678] Resolving any globals that are futures ... DONE
[18:04:55.678] Resolving futures part of globals (recursively) ...
[18:04:55.679] resolve() on list ...
[18:04:55.679]  recursive: 99
[18:04:55.679]  length: 2
[18:04:55.680]  elements: ‘a’, ‘ii’
[18:04:55.680]  length: 1 (resolved future 1)
[18:04:55.680]  length: 0 (resolved future 2)
[18:04:55.680] resolve() on list ... DONE
[18:04:55.681] - globals: [2] ‘a’, ‘ii’
[18:04:55.681] Resolving futures part of globals (recursively) ... DONE
[18:04:55.681] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:55.682] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.682] - globals: [2] ‘a’, ‘ii’
[18:04:55.682] 
[18:04:55.683] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.684] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.685] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.689] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.689] Searching for globals ... DONE
[18:04:55.689] Resolving globals: TRUE
[18:04:55.689] Resolving any globals that are futures ...
[18:04:55.690] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:55.690] Resolving any globals that are futures ... DONE
[18:04:55.691] Resolving futures part of globals (recursively) ...
[18:04:55.691] resolve() on list ...
[18:04:55.691]  recursive: 99
[18:04:55.692]  length: 2
[18:04:55.692]  elements: ‘a’, ‘ii’
[18:04:55.692]  length: 1 (resolved future 1)
[18:04:55.692]  length: 0 (resolved future 2)
[18:04:55.692] resolve() on list ... DONE
[18:04:55.693] - globals: [2] ‘a’, ‘ii’
[18:04:55.693] Resolving futures part of globals (recursively) ... DONE
[18:04:55.693] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:55.694] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:55.694] - globals: [2] ‘a’, ‘ii’
[18:04:55.695] 
[18:04:55.695] getGlobalsAndPackages() ... DONE
[18:04:55.696] run() for ‘Future’ ...
[18:04:55.696] - state: ‘created’
[18:04:55.696] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.697] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.697] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.697]   - Field: ‘label’
[18:04:55.698]   - Field: ‘local’
[18:04:55.698]   - Field: ‘owner’
[18:04:55.698]   - Field: ‘envir’
[18:04:55.698]   - Field: ‘packages’
[18:04:55.698]   - Field: ‘gc’
[18:04:55.699]   - Field: ‘conditions’
[18:04:55.699]   - Field: ‘expr’
[18:04:55.699]   - Field: ‘uuid’
[18:04:55.699]   - Field: ‘seed’
[18:04:55.699]   - Field: ‘version’
[18:04:55.700]   - Field: ‘result’
[18:04:55.700]   - Field: ‘asynchronous’
[18:04:55.700]   - Field: ‘calls’
[18:04:55.700]   - Field: ‘globals’
[18:04:55.700]   - Field: ‘stdout’
[18:04:55.701]   - Field: ‘earlySignal’
[18:04:55.701]   - Field: ‘lazy’
[18:04:55.701]   - Field: ‘state’
[18:04:55.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.701] - Launch lazy future ...
[18:04:55.702] Packages needed by the future expression (n = 0): <none>
[18:04:55.702] Packages needed by future strategies (n = 0): <none>
[18:04:55.703] {
[18:04:55.703]     {
[18:04:55.703]         {
[18:04:55.703]             ...future.startTime <- base::Sys.time()
[18:04:55.703]             {
[18:04:55.703]                 {
[18:04:55.703]                   {
[18:04:55.703]                     base::local({
[18:04:55.703]                       has_future <- base::requireNamespace("future", 
[18:04:55.703]                         quietly = TRUE)
[18:04:55.703]                       if (has_future) {
[18:04:55.703]                         ns <- base::getNamespace("future")
[18:04:55.703]                         version <- ns[[".package"]][["version"]]
[18:04:55.703]                         if (is.null(version)) 
[18:04:55.703]                           version <- utils::packageVersion("future")
[18:04:55.703]                       }
[18:04:55.703]                       else {
[18:04:55.703]                         version <- NULL
[18:04:55.703]                       }
[18:04:55.703]                       if (!has_future || version < "1.8.0") {
[18:04:55.703]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.703]                           "", base::R.version$version.string), 
[18:04:55.703]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.703]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.703]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.703]                             "release", "version")], collapse = " "), 
[18:04:55.703]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.703]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.703]                           info)
[18:04:55.703]                         info <- base::paste(info, collapse = "; ")
[18:04:55.703]                         if (!has_future) {
[18:04:55.703]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.703]                             info)
[18:04:55.703]                         }
[18:04:55.703]                         else {
[18:04:55.703]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.703]                             info, version)
[18:04:55.703]                         }
[18:04:55.703]                         base::stop(msg)
[18:04:55.703]                       }
[18:04:55.703]                     })
[18:04:55.703]                   }
[18:04:55.703]                   ...future.strategy.old <- future::plan("list")
[18:04:55.703]                   options(future.plan = NULL)
[18:04:55.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.703]                 }
[18:04:55.703]                 ...future.workdir <- getwd()
[18:04:55.703]             }
[18:04:55.703]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.703]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.703]         }
[18:04:55.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.703]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.703]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.703]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.703]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.703]             base::names(...future.oldOptions))
[18:04:55.703]     }
[18:04:55.703]     if (FALSE) {
[18:04:55.703]     }
[18:04:55.703]     else {
[18:04:55.703]         if (TRUE) {
[18:04:55.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.703]                 open = "w")
[18:04:55.703]         }
[18:04:55.703]         else {
[18:04:55.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.703]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.703]         }
[18:04:55.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.703]             base::sink(type = "output", split = FALSE)
[18:04:55.703]             base::close(...future.stdout)
[18:04:55.703]         }, add = TRUE)
[18:04:55.703]     }
[18:04:55.703]     ...future.frame <- base::sys.nframe()
[18:04:55.703]     ...future.conditions <- base::list()
[18:04:55.703]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.703]     if (FALSE) {
[18:04:55.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.703]     }
[18:04:55.703]     ...future.result <- base::tryCatch({
[18:04:55.703]         base::withCallingHandlers({
[18:04:55.703]             ...future.value <- base::withVisible(base::local({
[18:04:55.703]                 b <- a * ii
[18:04:55.703]                 a <- 0
[18:04:55.703]                 b
[18:04:55.703]             }))
[18:04:55.703]             future::FutureResult(value = ...future.value$value, 
[18:04:55.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.703]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.703]                     ...future.globalenv.names))
[18:04:55.703]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.703]         }, condition = base::local({
[18:04:55.703]             c <- base::c
[18:04:55.703]             inherits <- base::inherits
[18:04:55.703]             invokeRestart <- base::invokeRestart
[18:04:55.703]             length <- base::length
[18:04:55.703]             list <- base::list
[18:04:55.703]             seq.int <- base::seq.int
[18:04:55.703]             signalCondition <- base::signalCondition
[18:04:55.703]             sys.calls <- base::sys.calls
[18:04:55.703]             `[[` <- base::`[[`
[18:04:55.703]             `+` <- base::`+`
[18:04:55.703]             `<<-` <- base::`<<-`
[18:04:55.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.703]                   3L)]
[18:04:55.703]             }
[18:04:55.703]             function(cond) {
[18:04:55.703]                 is_error <- inherits(cond, "error")
[18:04:55.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.703]                   NULL)
[18:04:55.703]                 if (is_error) {
[18:04:55.703]                   sessionInformation <- function() {
[18:04:55.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.703]                       search = base::search(), system = base::Sys.info())
[18:04:55.703]                   }
[18:04:55.703]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.703]                     cond$call), session = sessionInformation(), 
[18:04:55.703]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.703]                   signalCondition(cond)
[18:04:55.703]                 }
[18:04:55.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.703]                 "immediateCondition"))) {
[18:04:55.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.703]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.703]                   if (TRUE && !signal) {
[18:04:55.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.703]                     {
[18:04:55.703]                       inherits <- base::inherits
[18:04:55.703]                       invokeRestart <- base::invokeRestart
[18:04:55.703]                       is.null <- base::is.null
[18:04:55.703]                       muffled <- FALSE
[18:04:55.703]                       if (inherits(cond, "message")) {
[18:04:55.703]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.703]                         if (muffled) 
[18:04:55.703]                           invokeRestart("muffleMessage")
[18:04:55.703]                       }
[18:04:55.703]                       else if (inherits(cond, "warning")) {
[18:04:55.703]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.703]                         if (muffled) 
[18:04:55.703]                           invokeRestart("muffleWarning")
[18:04:55.703]                       }
[18:04:55.703]                       else if (inherits(cond, "condition")) {
[18:04:55.703]                         if (!is.null(pattern)) {
[18:04:55.703]                           computeRestarts <- base::computeRestarts
[18:04:55.703]                           grepl <- base::grepl
[18:04:55.703]                           restarts <- computeRestarts(cond)
[18:04:55.703]                           for (restart in restarts) {
[18:04:55.703]                             name <- restart$name
[18:04:55.703]                             if (is.null(name)) 
[18:04:55.703]                               next
[18:04:55.703]                             if (!grepl(pattern, name)) 
[18:04:55.703]                               next
[18:04:55.703]                             invokeRestart(restart)
[18:04:55.703]                             muffled <- TRUE
[18:04:55.703]                             break
[18:04:55.703]                           }
[18:04:55.703]                         }
[18:04:55.703]                       }
[18:04:55.703]                       invisible(muffled)
[18:04:55.703]                     }
[18:04:55.703]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.703]                   }
[18:04:55.703]                 }
[18:04:55.703]                 else {
[18:04:55.703]                   if (TRUE) {
[18:04:55.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.703]                     {
[18:04:55.703]                       inherits <- base::inherits
[18:04:55.703]                       invokeRestart <- base::invokeRestart
[18:04:55.703]                       is.null <- base::is.null
[18:04:55.703]                       muffled <- FALSE
[18:04:55.703]                       if (inherits(cond, "message")) {
[18:04:55.703]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.703]                         if (muffled) 
[18:04:55.703]                           invokeRestart("muffleMessage")
[18:04:55.703]                       }
[18:04:55.703]                       else if (inherits(cond, "warning")) {
[18:04:55.703]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.703]                         if (muffled) 
[18:04:55.703]                           invokeRestart("muffleWarning")
[18:04:55.703]                       }
[18:04:55.703]                       else if (inherits(cond, "condition")) {
[18:04:55.703]                         if (!is.null(pattern)) {
[18:04:55.703]                           computeRestarts <- base::computeRestarts
[18:04:55.703]                           grepl <- base::grepl
[18:04:55.703]                           restarts <- computeRestarts(cond)
[18:04:55.703]                           for (restart in restarts) {
[18:04:55.703]                             name <- restart$name
[18:04:55.703]                             if (is.null(name)) 
[18:04:55.703]                               next
[18:04:55.703]                             if (!grepl(pattern, name)) 
[18:04:55.703]                               next
[18:04:55.703]                             invokeRestart(restart)
[18:04:55.703]                             muffled <- TRUE
[18:04:55.703]                             break
[18:04:55.703]                           }
[18:04:55.703]                         }
[18:04:55.703]                       }
[18:04:55.703]                       invisible(muffled)
[18:04:55.703]                     }
[18:04:55.703]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.703]                   }
[18:04:55.703]                 }
[18:04:55.703]             }
[18:04:55.703]         }))
[18:04:55.703]     }, error = function(ex) {
[18:04:55.703]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.703]                 ...future.rng), started = ...future.startTime, 
[18:04:55.703]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.703]             version = "1.8"), class = "FutureResult")
[18:04:55.703]     }, finally = {
[18:04:55.703]         if (!identical(...future.workdir, getwd())) 
[18:04:55.703]             setwd(...future.workdir)
[18:04:55.703]         {
[18:04:55.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.703]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.703]             }
[18:04:55.703]             base::options(...future.oldOptions)
[18:04:55.703]             if (.Platform$OS.type == "windows") {
[18:04:55.703]                 old_names <- names(...future.oldEnvVars)
[18:04:55.703]                 envs <- base::Sys.getenv()
[18:04:55.703]                 names <- names(envs)
[18:04:55.703]                 common <- intersect(names, old_names)
[18:04:55.703]                 added <- setdiff(names, old_names)
[18:04:55.703]                 removed <- setdiff(old_names, names)
[18:04:55.703]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.703]                   envs[common]]
[18:04:55.703]                 NAMES <- toupper(changed)
[18:04:55.703]                 args <- list()
[18:04:55.703]                 for (kk in seq_along(NAMES)) {
[18:04:55.703]                   name <- changed[[kk]]
[18:04:55.703]                   NAME <- NAMES[[kk]]
[18:04:55.703]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.703]                     next
[18:04:55.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.703]                 }
[18:04:55.703]                 NAMES <- toupper(added)
[18:04:55.703]                 for (kk in seq_along(NAMES)) {
[18:04:55.703]                   name <- added[[kk]]
[18:04:55.703]                   NAME <- NAMES[[kk]]
[18:04:55.703]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.703]                     next
[18:04:55.703]                   args[[name]] <- ""
[18:04:55.703]                 }
[18:04:55.703]                 NAMES <- toupper(removed)
[18:04:55.703]                 for (kk in seq_along(NAMES)) {
[18:04:55.703]                   name <- removed[[kk]]
[18:04:55.703]                   NAME <- NAMES[[kk]]
[18:04:55.703]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.703]                     next
[18:04:55.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.703]                 }
[18:04:55.703]                 if (length(args) > 0) 
[18:04:55.703]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.703]             }
[18:04:55.703]             else {
[18:04:55.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.703]             }
[18:04:55.703]             {
[18:04:55.703]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.703]                   0L) {
[18:04:55.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.703]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.703]                   base::options(opts)
[18:04:55.703]                 }
[18:04:55.703]                 {
[18:04:55.703]                   {
[18:04:55.703]                     NULL
[18:04:55.703]                     RNGkind("Mersenne-Twister")
[18:04:55.703]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.703]                       inherits = FALSE)
[18:04:55.703]                   }
[18:04:55.703]                   options(future.plan = NULL)
[18:04:55.703]                   if (is.na(NA_character_)) 
[18:04:55.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.703]                     .init = FALSE)
[18:04:55.703]                 }
[18:04:55.703]             }
[18:04:55.703]         }
[18:04:55.703]     })
[18:04:55.703]     if (TRUE) {
[18:04:55.703]         base::sink(type = "output", split = FALSE)
[18:04:55.703]         if (TRUE) {
[18:04:55.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.703]         }
[18:04:55.703]         else {
[18:04:55.703]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.703]         }
[18:04:55.703]         base::close(...future.stdout)
[18:04:55.703]         ...future.stdout <- NULL
[18:04:55.703]     }
[18:04:55.703]     ...future.result$conditions <- ...future.conditions
[18:04:55.703]     ...future.result$finished <- base::Sys.time()
[18:04:55.703]     ...future.result
[18:04:55.703] }
[18:04:55.706] assign_globals() ...
[18:04:55.707] List of 2
[18:04:55.707]  $ a : num 1
[18:04:55.707]  $ ii: int 1
[18:04:55.707]  - attr(*, "where")=List of 2
[18:04:55.707]   ..$ a :<environment: R_EmptyEnv> 
[18:04:55.707]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.707]  - attr(*, "resolved")= logi TRUE
[18:04:55.707]  - attr(*, "total_size")= num 112
[18:04:55.707]  - attr(*, "already-done")= logi TRUE
[18:04:55.713] - copied ‘a’ to environment
[18:04:55.714] - copied ‘ii’ to environment
[18:04:55.714] assign_globals() ... done
[18:04:55.714] plan(): Setting new future strategy stack:
[18:04:55.715] List of future strategies:
[18:04:55.715] 1. sequential:
[18:04:55.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.715]    - tweaked: FALSE
[18:04:55.715]    - call: NULL
[18:04:55.716] plan(): nbrOfWorkers() = 1
[18:04:55.717] plan(): Setting new future strategy stack:
[18:04:55.718] List of future strategies:
[18:04:55.718] 1. sequential:
[18:04:55.718]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.718]    - tweaked: FALSE
[18:04:55.718]    - call: plan(strategy)
[18:04:55.719] plan(): nbrOfWorkers() = 1
[18:04:55.719] SequentialFuture started (and completed)
[18:04:55.719] - Launch lazy future ... done
[18:04:55.720] run() for ‘SequentialFuture’ ... done
[18:04:55.720] run() for ‘Future’ ...
[18:04:55.720] - state: ‘created’
[18:04:55.721] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.721] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.721] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.722]   - Field: ‘label’
[18:04:55.722]   - Field: ‘local’
[18:04:55.722]   - Field: ‘owner’
[18:04:55.722]   - Field: ‘envir’
[18:04:55.722]   - Field: ‘packages’
[18:04:55.723]   - Field: ‘gc’
[18:04:55.723]   - Field: ‘conditions’
[18:04:55.723]   - Field: ‘expr’
[18:04:55.723]   - Field: ‘uuid’
[18:04:55.724]   - Field: ‘seed’
[18:04:55.724]   - Field: ‘version’
[18:04:55.724]   - Field: ‘result’
[18:04:55.724]   - Field: ‘asynchronous’
[18:04:55.724]   - Field: ‘calls’
[18:04:55.725]   - Field: ‘globals’
[18:04:55.725]   - Field: ‘stdout’
[18:04:55.725]   - Field: ‘earlySignal’
[18:04:55.725]   - Field: ‘lazy’
[18:04:55.725]   - Field: ‘state’
[18:04:55.726] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.726] - Launch lazy future ...
[18:04:55.726] Packages needed by the future expression (n = 0): <none>
[18:04:55.726] Packages needed by future strategies (n = 0): <none>
[18:04:55.730] {
[18:04:55.730]     {
[18:04:55.730]         {
[18:04:55.730]             ...future.startTime <- base::Sys.time()
[18:04:55.730]             {
[18:04:55.730]                 {
[18:04:55.730]                   {
[18:04:55.730]                     base::local({
[18:04:55.730]                       has_future <- base::requireNamespace("future", 
[18:04:55.730]                         quietly = TRUE)
[18:04:55.730]                       if (has_future) {
[18:04:55.730]                         ns <- base::getNamespace("future")
[18:04:55.730]                         version <- ns[[".package"]][["version"]]
[18:04:55.730]                         if (is.null(version)) 
[18:04:55.730]                           version <- utils::packageVersion("future")
[18:04:55.730]                       }
[18:04:55.730]                       else {
[18:04:55.730]                         version <- NULL
[18:04:55.730]                       }
[18:04:55.730]                       if (!has_future || version < "1.8.0") {
[18:04:55.730]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.730]                           "", base::R.version$version.string), 
[18:04:55.730]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.730]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.730]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.730]                             "release", "version")], collapse = " "), 
[18:04:55.730]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.730]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.730]                           info)
[18:04:55.730]                         info <- base::paste(info, collapse = "; ")
[18:04:55.730]                         if (!has_future) {
[18:04:55.730]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.730]                             info)
[18:04:55.730]                         }
[18:04:55.730]                         else {
[18:04:55.730]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.730]                             info, version)
[18:04:55.730]                         }
[18:04:55.730]                         base::stop(msg)
[18:04:55.730]                       }
[18:04:55.730]                     })
[18:04:55.730]                   }
[18:04:55.730]                   ...future.strategy.old <- future::plan("list")
[18:04:55.730]                   options(future.plan = NULL)
[18:04:55.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.730]                 }
[18:04:55.730]                 ...future.workdir <- getwd()
[18:04:55.730]             }
[18:04:55.730]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.730]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.730]         }
[18:04:55.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.730]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.730]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.730]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.730]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.730]             base::names(...future.oldOptions))
[18:04:55.730]     }
[18:04:55.730]     if (FALSE) {
[18:04:55.730]     }
[18:04:55.730]     else {
[18:04:55.730]         if (TRUE) {
[18:04:55.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.730]                 open = "w")
[18:04:55.730]         }
[18:04:55.730]         else {
[18:04:55.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.730]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.730]         }
[18:04:55.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.730]             base::sink(type = "output", split = FALSE)
[18:04:55.730]             base::close(...future.stdout)
[18:04:55.730]         }, add = TRUE)
[18:04:55.730]     }
[18:04:55.730]     ...future.frame <- base::sys.nframe()
[18:04:55.730]     ...future.conditions <- base::list()
[18:04:55.730]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.730]     if (FALSE) {
[18:04:55.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.730]     }
[18:04:55.730]     ...future.result <- base::tryCatch({
[18:04:55.730]         base::withCallingHandlers({
[18:04:55.730]             ...future.value <- base::withVisible(base::local({
[18:04:55.730]                 b <- a * ii
[18:04:55.730]                 a <- 0
[18:04:55.730]                 b
[18:04:55.730]             }))
[18:04:55.730]             future::FutureResult(value = ...future.value$value, 
[18:04:55.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.730]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.730]                     ...future.globalenv.names))
[18:04:55.730]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.730]         }, condition = base::local({
[18:04:55.730]             c <- base::c
[18:04:55.730]             inherits <- base::inherits
[18:04:55.730]             invokeRestart <- base::invokeRestart
[18:04:55.730]             length <- base::length
[18:04:55.730]             list <- base::list
[18:04:55.730]             seq.int <- base::seq.int
[18:04:55.730]             signalCondition <- base::signalCondition
[18:04:55.730]             sys.calls <- base::sys.calls
[18:04:55.730]             `[[` <- base::`[[`
[18:04:55.730]             `+` <- base::`+`
[18:04:55.730]             `<<-` <- base::`<<-`
[18:04:55.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.730]                   3L)]
[18:04:55.730]             }
[18:04:55.730]             function(cond) {
[18:04:55.730]                 is_error <- inherits(cond, "error")
[18:04:55.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.730]                   NULL)
[18:04:55.730]                 if (is_error) {
[18:04:55.730]                   sessionInformation <- function() {
[18:04:55.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.730]                       search = base::search(), system = base::Sys.info())
[18:04:55.730]                   }
[18:04:55.730]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.730]                     cond$call), session = sessionInformation(), 
[18:04:55.730]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.730]                   signalCondition(cond)
[18:04:55.730]                 }
[18:04:55.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.730]                 "immediateCondition"))) {
[18:04:55.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.730]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.730]                   if (TRUE && !signal) {
[18:04:55.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.730]                     {
[18:04:55.730]                       inherits <- base::inherits
[18:04:55.730]                       invokeRestart <- base::invokeRestart
[18:04:55.730]                       is.null <- base::is.null
[18:04:55.730]                       muffled <- FALSE
[18:04:55.730]                       if (inherits(cond, "message")) {
[18:04:55.730]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.730]                         if (muffled) 
[18:04:55.730]                           invokeRestart("muffleMessage")
[18:04:55.730]                       }
[18:04:55.730]                       else if (inherits(cond, "warning")) {
[18:04:55.730]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.730]                         if (muffled) 
[18:04:55.730]                           invokeRestart("muffleWarning")
[18:04:55.730]                       }
[18:04:55.730]                       else if (inherits(cond, "condition")) {
[18:04:55.730]                         if (!is.null(pattern)) {
[18:04:55.730]                           computeRestarts <- base::computeRestarts
[18:04:55.730]                           grepl <- base::grepl
[18:04:55.730]                           restarts <- computeRestarts(cond)
[18:04:55.730]                           for (restart in restarts) {
[18:04:55.730]                             name <- restart$name
[18:04:55.730]                             if (is.null(name)) 
[18:04:55.730]                               next
[18:04:55.730]                             if (!grepl(pattern, name)) 
[18:04:55.730]                               next
[18:04:55.730]                             invokeRestart(restart)
[18:04:55.730]                             muffled <- TRUE
[18:04:55.730]                             break
[18:04:55.730]                           }
[18:04:55.730]                         }
[18:04:55.730]                       }
[18:04:55.730]                       invisible(muffled)
[18:04:55.730]                     }
[18:04:55.730]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.730]                   }
[18:04:55.730]                 }
[18:04:55.730]                 else {
[18:04:55.730]                   if (TRUE) {
[18:04:55.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.730]                     {
[18:04:55.730]                       inherits <- base::inherits
[18:04:55.730]                       invokeRestart <- base::invokeRestart
[18:04:55.730]                       is.null <- base::is.null
[18:04:55.730]                       muffled <- FALSE
[18:04:55.730]                       if (inherits(cond, "message")) {
[18:04:55.730]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.730]                         if (muffled) 
[18:04:55.730]                           invokeRestart("muffleMessage")
[18:04:55.730]                       }
[18:04:55.730]                       else if (inherits(cond, "warning")) {
[18:04:55.730]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.730]                         if (muffled) 
[18:04:55.730]                           invokeRestart("muffleWarning")
[18:04:55.730]                       }
[18:04:55.730]                       else if (inherits(cond, "condition")) {
[18:04:55.730]                         if (!is.null(pattern)) {
[18:04:55.730]                           computeRestarts <- base::computeRestarts
[18:04:55.730]                           grepl <- base::grepl
[18:04:55.730]                           restarts <- computeRestarts(cond)
[18:04:55.730]                           for (restart in restarts) {
[18:04:55.730]                             name <- restart$name
[18:04:55.730]                             if (is.null(name)) 
[18:04:55.730]                               next
[18:04:55.730]                             if (!grepl(pattern, name)) 
[18:04:55.730]                               next
[18:04:55.730]                             invokeRestart(restart)
[18:04:55.730]                             muffled <- TRUE
[18:04:55.730]                             break
[18:04:55.730]                           }
[18:04:55.730]                         }
[18:04:55.730]                       }
[18:04:55.730]                       invisible(muffled)
[18:04:55.730]                     }
[18:04:55.730]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.730]                   }
[18:04:55.730]                 }
[18:04:55.730]             }
[18:04:55.730]         }))
[18:04:55.730]     }, error = function(ex) {
[18:04:55.730]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.730]                 ...future.rng), started = ...future.startTime, 
[18:04:55.730]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.730]             version = "1.8"), class = "FutureResult")
[18:04:55.730]     }, finally = {
[18:04:55.730]         if (!identical(...future.workdir, getwd())) 
[18:04:55.730]             setwd(...future.workdir)
[18:04:55.730]         {
[18:04:55.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.730]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.730]             }
[18:04:55.730]             base::options(...future.oldOptions)
[18:04:55.730]             if (.Platform$OS.type == "windows") {
[18:04:55.730]                 old_names <- names(...future.oldEnvVars)
[18:04:55.730]                 envs <- base::Sys.getenv()
[18:04:55.730]                 names <- names(envs)
[18:04:55.730]                 common <- intersect(names, old_names)
[18:04:55.730]                 added <- setdiff(names, old_names)
[18:04:55.730]                 removed <- setdiff(old_names, names)
[18:04:55.730]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.730]                   envs[common]]
[18:04:55.730]                 NAMES <- toupper(changed)
[18:04:55.730]                 args <- list()
[18:04:55.730]                 for (kk in seq_along(NAMES)) {
[18:04:55.730]                   name <- changed[[kk]]
[18:04:55.730]                   NAME <- NAMES[[kk]]
[18:04:55.730]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.730]                     next
[18:04:55.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.730]                 }
[18:04:55.730]                 NAMES <- toupper(added)
[18:04:55.730]                 for (kk in seq_along(NAMES)) {
[18:04:55.730]                   name <- added[[kk]]
[18:04:55.730]                   NAME <- NAMES[[kk]]
[18:04:55.730]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.730]                     next
[18:04:55.730]                   args[[name]] <- ""
[18:04:55.730]                 }
[18:04:55.730]                 NAMES <- toupper(removed)
[18:04:55.730]                 for (kk in seq_along(NAMES)) {
[18:04:55.730]                   name <- removed[[kk]]
[18:04:55.730]                   NAME <- NAMES[[kk]]
[18:04:55.730]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.730]                     next
[18:04:55.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.730]                 }
[18:04:55.730]                 if (length(args) > 0) 
[18:04:55.730]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.730]             }
[18:04:55.730]             else {
[18:04:55.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.730]             }
[18:04:55.730]             {
[18:04:55.730]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.730]                   0L) {
[18:04:55.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.730]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.730]                   base::options(opts)
[18:04:55.730]                 }
[18:04:55.730]                 {
[18:04:55.730]                   {
[18:04:55.730]                     NULL
[18:04:55.730]                     RNGkind("Mersenne-Twister")
[18:04:55.730]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.730]                       inherits = FALSE)
[18:04:55.730]                   }
[18:04:55.730]                   options(future.plan = NULL)
[18:04:55.730]                   if (is.na(NA_character_)) 
[18:04:55.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.730]                     .init = FALSE)
[18:04:55.730]                 }
[18:04:55.730]             }
[18:04:55.730]         }
[18:04:55.730]     })
[18:04:55.730]     if (TRUE) {
[18:04:55.730]         base::sink(type = "output", split = FALSE)
[18:04:55.730]         if (TRUE) {
[18:04:55.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.730]         }
[18:04:55.730]         else {
[18:04:55.730]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.730]         }
[18:04:55.730]         base::close(...future.stdout)
[18:04:55.730]         ...future.stdout <- NULL
[18:04:55.730]     }
[18:04:55.730]     ...future.result$conditions <- ...future.conditions
[18:04:55.730]     ...future.result$finished <- base::Sys.time()
[18:04:55.730]     ...future.result
[18:04:55.730] }
[18:04:55.733] assign_globals() ...
[18:04:55.734] List of 2
[18:04:55.734]  $ a : num 1
[18:04:55.734]  $ ii: int 2
[18:04:55.734]  - attr(*, "where")=List of 2
[18:04:55.734]   ..$ a :<environment: R_EmptyEnv> 
[18:04:55.734]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.734]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.734]  - attr(*, "resolved")= logi TRUE
[18:04:55.734]  - attr(*, "total_size")= num 112
[18:04:55.734]  - attr(*, "already-done")= logi TRUE
[18:04:55.740] - copied ‘a’ to environment
[18:04:55.741] - copied ‘ii’ to environment
[18:04:55.741] assign_globals() ... done
[18:04:55.741] plan(): Setting new future strategy stack:
[18:04:55.742] List of future strategies:
[18:04:55.742] 1. sequential:
[18:04:55.742]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.742]    - tweaked: FALSE
[18:04:55.742]    - call: NULL
[18:04:55.743] plan(): nbrOfWorkers() = 1
[18:04:55.744] plan(): Setting new future strategy stack:
[18:04:55.745] List of future strategies:
[18:04:55.745] 1. sequential:
[18:04:55.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.745]    - tweaked: FALSE
[18:04:55.745]    - call: plan(strategy)
[18:04:55.746] plan(): nbrOfWorkers() = 1
[18:04:55.746] SequentialFuture started (and completed)
[18:04:55.746] - Launch lazy future ... done
[18:04:55.746] run() for ‘SequentialFuture’ ... done
[18:04:55.747] run() for ‘Future’ ...
[18:04:55.747] - state: ‘created’
[18:04:55.747] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.748] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.748] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.748]   - Field: ‘label’
[18:04:55.749]   - Field: ‘local’
[18:04:55.749]   - Field: ‘owner’
[18:04:55.749]   - Field: ‘envir’
[18:04:55.749]   - Field: ‘packages’
[18:04:55.750]   - Field: ‘gc’
[18:04:55.750]   - Field: ‘conditions’
[18:04:55.750]   - Field: ‘expr’
[18:04:55.750]   - Field: ‘uuid’
[18:04:55.750]   - Field: ‘seed’
[18:04:55.751]   - Field: ‘version’
[18:04:55.751]   - Field: ‘result’
[18:04:55.751]   - Field: ‘asynchronous’
[18:04:55.751]   - Field: ‘calls’
[18:04:55.751]   - Field: ‘globals’
[18:04:55.752]   - Field: ‘stdout’
[18:04:55.752]   - Field: ‘earlySignal’
[18:04:55.752]   - Field: ‘lazy’
[18:04:55.752]   - Field: ‘state’
[18:04:55.752] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.753] - Launch lazy future ...
[18:04:55.753] Packages needed by the future expression (n = 0): <none>
[18:04:55.753] Packages needed by future strategies (n = 0): <none>
[18:04:55.754] {
[18:04:55.754]     {
[18:04:55.754]         {
[18:04:55.754]             ...future.startTime <- base::Sys.time()
[18:04:55.754]             {
[18:04:55.754]                 {
[18:04:55.754]                   {
[18:04:55.754]                     base::local({
[18:04:55.754]                       has_future <- base::requireNamespace("future", 
[18:04:55.754]                         quietly = TRUE)
[18:04:55.754]                       if (has_future) {
[18:04:55.754]                         ns <- base::getNamespace("future")
[18:04:55.754]                         version <- ns[[".package"]][["version"]]
[18:04:55.754]                         if (is.null(version)) 
[18:04:55.754]                           version <- utils::packageVersion("future")
[18:04:55.754]                       }
[18:04:55.754]                       else {
[18:04:55.754]                         version <- NULL
[18:04:55.754]                       }
[18:04:55.754]                       if (!has_future || version < "1.8.0") {
[18:04:55.754]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.754]                           "", base::R.version$version.string), 
[18:04:55.754]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.754]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.754]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.754]                             "release", "version")], collapse = " "), 
[18:04:55.754]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.754]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.754]                           info)
[18:04:55.754]                         info <- base::paste(info, collapse = "; ")
[18:04:55.754]                         if (!has_future) {
[18:04:55.754]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.754]                             info)
[18:04:55.754]                         }
[18:04:55.754]                         else {
[18:04:55.754]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.754]                             info, version)
[18:04:55.754]                         }
[18:04:55.754]                         base::stop(msg)
[18:04:55.754]                       }
[18:04:55.754]                     })
[18:04:55.754]                   }
[18:04:55.754]                   ...future.strategy.old <- future::plan("list")
[18:04:55.754]                   options(future.plan = NULL)
[18:04:55.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.754]                 }
[18:04:55.754]                 ...future.workdir <- getwd()
[18:04:55.754]             }
[18:04:55.754]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.754]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.754]         }
[18:04:55.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.754]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.754]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.754]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.754]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.754]             base::names(...future.oldOptions))
[18:04:55.754]     }
[18:04:55.754]     if (FALSE) {
[18:04:55.754]     }
[18:04:55.754]     else {
[18:04:55.754]         if (TRUE) {
[18:04:55.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.754]                 open = "w")
[18:04:55.754]         }
[18:04:55.754]         else {
[18:04:55.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.754]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.754]         }
[18:04:55.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.754]             base::sink(type = "output", split = FALSE)
[18:04:55.754]             base::close(...future.stdout)
[18:04:55.754]         }, add = TRUE)
[18:04:55.754]     }
[18:04:55.754]     ...future.frame <- base::sys.nframe()
[18:04:55.754]     ...future.conditions <- base::list()
[18:04:55.754]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.754]     if (FALSE) {
[18:04:55.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.754]     }
[18:04:55.754]     ...future.result <- base::tryCatch({
[18:04:55.754]         base::withCallingHandlers({
[18:04:55.754]             ...future.value <- base::withVisible(base::local({
[18:04:55.754]                 b <- a * ii
[18:04:55.754]                 a <- 0
[18:04:55.754]                 b
[18:04:55.754]             }))
[18:04:55.754]             future::FutureResult(value = ...future.value$value, 
[18:04:55.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.754]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.754]                     ...future.globalenv.names))
[18:04:55.754]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.754]         }, condition = base::local({
[18:04:55.754]             c <- base::c
[18:04:55.754]             inherits <- base::inherits
[18:04:55.754]             invokeRestart <- base::invokeRestart
[18:04:55.754]             length <- base::length
[18:04:55.754]             list <- base::list
[18:04:55.754]             seq.int <- base::seq.int
[18:04:55.754]             signalCondition <- base::signalCondition
[18:04:55.754]             sys.calls <- base::sys.calls
[18:04:55.754]             `[[` <- base::`[[`
[18:04:55.754]             `+` <- base::`+`
[18:04:55.754]             `<<-` <- base::`<<-`
[18:04:55.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.754]                   3L)]
[18:04:55.754]             }
[18:04:55.754]             function(cond) {
[18:04:55.754]                 is_error <- inherits(cond, "error")
[18:04:55.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.754]                   NULL)
[18:04:55.754]                 if (is_error) {
[18:04:55.754]                   sessionInformation <- function() {
[18:04:55.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.754]                       search = base::search(), system = base::Sys.info())
[18:04:55.754]                   }
[18:04:55.754]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.754]                     cond$call), session = sessionInformation(), 
[18:04:55.754]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.754]                   signalCondition(cond)
[18:04:55.754]                 }
[18:04:55.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.754]                 "immediateCondition"))) {
[18:04:55.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.754]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.754]                   if (TRUE && !signal) {
[18:04:55.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.754]                     {
[18:04:55.754]                       inherits <- base::inherits
[18:04:55.754]                       invokeRestart <- base::invokeRestart
[18:04:55.754]                       is.null <- base::is.null
[18:04:55.754]                       muffled <- FALSE
[18:04:55.754]                       if (inherits(cond, "message")) {
[18:04:55.754]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.754]                         if (muffled) 
[18:04:55.754]                           invokeRestart("muffleMessage")
[18:04:55.754]                       }
[18:04:55.754]                       else if (inherits(cond, "warning")) {
[18:04:55.754]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.754]                         if (muffled) 
[18:04:55.754]                           invokeRestart("muffleWarning")
[18:04:55.754]                       }
[18:04:55.754]                       else if (inherits(cond, "condition")) {
[18:04:55.754]                         if (!is.null(pattern)) {
[18:04:55.754]                           computeRestarts <- base::computeRestarts
[18:04:55.754]                           grepl <- base::grepl
[18:04:55.754]                           restarts <- computeRestarts(cond)
[18:04:55.754]                           for (restart in restarts) {
[18:04:55.754]                             name <- restart$name
[18:04:55.754]                             if (is.null(name)) 
[18:04:55.754]                               next
[18:04:55.754]                             if (!grepl(pattern, name)) 
[18:04:55.754]                               next
[18:04:55.754]                             invokeRestart(restart)
[18:04:55.754]                             muffled <- TRUE
[18:04:55.754]                             break
[18:04:55.754]                           }
[18:04:55.754]                         }
[18:04:55.754]                       }
[18:04:55.754]                       invisible(muffled)
[18:04:55.754]                     }
[18:04:55.754]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.754]                   }
[18:04:55.754]                 }
[18:04:55.754]                 else {
[18:04:55.754]                   if (TRUE) {
[18:04:55.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.754]                     {
[18:04:55.754]                       inherits <- base::inherits
[18:04:55.754]                       invokeRestart <- base::invokeRestart
[18:04:55.754]                       is.null <- base::is.null
[18:04:55.754]                       muffled <- FALSE
[18:04:55.754]                       if (inherits(cond, "message")) {
[18:04:55.754]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.754]                         if (muffled) 
[18:04:55.754]                           invokeRestart("muffleMessage")
[18:04:55.754]                       }
[18:04:55.754]                       else if (inherits(cond, "warning")) {
[18:04:55.754]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.754]                         if (muffled) 
[18:04:55.754]                           invokeRestart("muffleWarning")
[18:04:55.754]                       }
[18:04:55.754]                       else if (inherits(cond, "condition")) {
[18:04:55.754]                         if (!is.null(pattern)) {
[18:04:55.754]                           computeRestarts <- base::computeRestarts
[18:04:55.754]                           grepl <- base::grepl
[18:04:55.754]                           restarts <- computeRestarts(cond)
[18:04:55.754]                           for (restart in restarts) {
[18:04:55.754]                             name <- restart$name
[18:04:55.754]                             if (is.null(name)) 
[18:04:55.754]                               next
[18:04:55.754]                             if (!grepl(pattern, name)) 
[18:04:55.754]                               next
[18:04:55.754]                             invokeRestart(restart)
[18:04:55.754]                             muffled <- TRUE
[18:04:55.754]                             break
[18:04:55.754]                           }
[18:04:55.754]                         }
[18:04:55.754]                       }
[18:04:55.754]                       invisible(muffled)
[18:04:55.754]                     }
[18:04:55.754]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.754]                   }
[18:04:55.754]                 }
[18:04:55.754]             }
[18:04:55.754]         }))
[18:04:55.754]     }, error = function(ex) {
[18:04:55.754]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.754]                 ...future.rng), started = ...future.startTime, 
[18:04:55.754]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.754]             version = "1.8"), class = "FutureResult")
[18:04:55.754]     }, finally = {
[18:04:55.754]         if (!identical(...future.workdir, getwd())) 
[18:04:55.754]             setwd(...future.workdir)
[18:04:55.754]         {
[18:04:55.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.754]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.754]             }
[18:04:55.754]             base::options(...future.oldOptions)
[18:04:55.754]             if (.Platform$OS.type == "windows") {
[18:04:55.754]                 old_names <- names(...future.oldEnvVars)
[18:04:55.754]                 envs <- base::Sys.getenv()
[18:04:55.754]                 names <- names(envs)
[18:04:55.754]                 common <- intersect(names, old_names)
[18:04:55.754]                 added <- setdiff(names, old_names)
[18:04:55.754]                 removed <- setdiff(old_names, names)
[18:04:55.754]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.754]                   envs[common]]
[18:04:55.754]                 NAMES <- toupper(changed)
[18:04:55.754]                 args <- list()
[18:04:55.754]                 for (kk in seq_along(NAMES)) {
[18:04:55.754]                   name <- changed[[kk]]
[18:04:55.754]                   NAME <- NAMES[[kk]]
[18:04:55.754]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.754]                     next
[18:04:55.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.754]                 }
[18:04:55.754]                 NAMES <- toupper(added)
[18:04:55.754]                 for (kk in seq_along(NAMES)) {
[18:04:55.754]                   name <- added[[kk]]
[18:04:55.754]                   NAME <- NAMES[[kk]]
[18:04:55.754]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.754]                     next
[18:04:55.754]                   args[[name]] <- ""
[18:04:55.754]                 }
[18:04:55.754]                 NAMES <- toupper(removed)
[18:04:55.754]                 for (kk in seq_along(NAMES)) {
[18:04:55.754]                   name <- removed[[kk]]
[18:04:55.754]                   NAME <- NAMES[[kk]]
[18:04:55.754]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.754]                     next
[18:04:55.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.754]                 }
[18:04:55.754]                 if (length(args) > 0) 
[18:04:55.754]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.754]             }
[18:04:55.754]             else {
[18:04:55.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.754]             }
[18:04:55.754]             {
[18:04:55.754]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.754]                   0L) {
[18:04:55.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.754]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.754]                   base::options(opts)
[18:04:55.754]                 }
[18:04:55.754]                 {
[18:04:55.754]                   {
[18:04:55.754]                     NULL
[18:04:55.754]                     RNGkind("Mersenne-Twister")
[18:04:55.754]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.754]                       inherits = FALSE)
[18:04:55.754]                   }
[18:04:55.754]                   options(future.plan = NULL)
[18:04:55.754]                   if (is.na(NA_character_)) 
[18:04:55.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.754]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.754]                     .init = FALSE)
[18:04:55.754]                 }
[18:04:55.754]             }
[18:04:55.754]         }
[18:04:55.754]     })
[18:04:55.754]     if (TRUE) {
[18:04:55.754]         base::sink(type = "output", split = FALSE)
[18:04:55.754]         if (TRUE) {
[18:04:55.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.754]         }
[18:04:55.754]         else {
[18:04:55.754]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.754]         }
[18:04:55.754]         base::close(...future.stdout)
[18:04:55.754]         ...future.stdout <- NULL
[18:04:55.754]     }
[18:04:55.754]     ...future.result$conditions <- ...future.conditions
[18:04:55.754]     ...future.result$finished <- base::Sys.time()
[18:04:55.754]     ...future.result
[18:04:55.754] }
[18:04:55.757] assign_globals() ...
[18:04:55.758] List of 2
[18:04:55.758]  $ a : num 1
[18:04:55.758]  $ ii: int 3
[18:04:55.758]  - attr(*, "where")=List of 2
[18:04:55.758]   ..$ a :<environment: R_EmptyEnv> 
[18:04:55.758]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:55.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.758]  - attr(*, "resolved")= logi TRUE
[18:04:55.758]  - attr(*, "total_size")= num 112
[18:04:55.758]  - attr(*, "already-done")= logi TRUE
[18:04:55.764] - copied ‘a’ to environment
[18:04:55.765] - copied ‘ii’ to environment
[18:04:55.765] assign_globals() ... done
[18:04:55.765] plan(): Setting new future strategy stack:
[18:04:55.766] List of future strategies:
[18:04:55.766] 1. sequential:
[18:04:55.766]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.766]    - tweaked: FALSE
[18:04:55.766]    - call: NULL
[18:04:55.767] plan(): nbrOfWorkers() = 1
[18:04:55.768] plan(): Setting new future strategy stack:
[18:04:55.769] List of future strategies:
[18:04:55.769] 1. sequential:
[18:04:55.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.769]    - tweaked: FALSE
[18:04:55.769]    - call: plan(strategy)
[18:04:55.770] plan(): nbrOfWorkers() = 1
[18:04:55.770] SequentialFuture started (and completed)
[18:04:55.770] - Launch lazy future ... done
[18:04:55.771] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.771] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.772] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.773] 
[18:04:55.773] Searching for globals ... DONE
[18:04:55.773] - globals: [0] <none>
[18:04:55.773] getGlobalsAndPackages() ... DONE
[18:04:55.774] run() for ‘Future’ ...
[18:04:55.774] - state: ‘created’
[18:04:55.774] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.775] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.775]   - Field: ‘label’
[18:04:55.776]   - Field: ‘local’
[18:04:55.776]   - Field: ‘owner’
[18:04:55.776]   - Field: ‘envir’
[18:04:55.776]   - Field: ‘packages’
[18:04:55.776]   - Field: ‘gc’
[18:04:55.777]   - Field: ‘conditions’
[18:04:55.777]   - Field: ‘expr’
[18:04:55.777]   - Field: ‘uuid’
[18:04:55.777]   - Field: ‘seed’
[18:04:55.777]   - Field: ‘version’
[18:04:55.778]   - Field: ‘result’
[18:04:55.778]   - Field: ‘asynchronous’
[18:04:55.778]   - Field: ‘calls’
[18:04:55.778]   - Field: ‘globals’
[18:04:55.778]   - Field: ‘stdout’
[18:04:55.779]   - Field: ‘earlySignal’
[18:04:55.779]   - Field: ‘lazy’
[18:04:55.779]   - Field: ‘state’
[18:04:55.779] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.780] - Launch lazy future ...
[18:04:55.780] Packages needed by the future expression (n = 0): <none>
[18:04:55.780] Packages needed by future strategies (n = 0): <none>
[18:04:55.781] {
[18:04:55.781]     {
[18:04:55.781]         {
[18:04:55.781]             ...future.startTime <- base::Sys.time()
[18:04:55.781]             {
[18:04:55.781]                 {
[18:04:55.781]                   {
[18:04:55.781]                     base::local({
[18:04:55.781]                       has_future <- base::requireNamespace("future", 
[18:04:55.781]                         quietly = TRUE)
[18:04:55.781]                       if (has_future) {
[18:04:55.781]                         ns <- base::getNamespace("future")
[18:04:55.781]                         version <- ns[[".package"]][["version"]]
[18:04:55.781]                         if (is.null(version)) 
[18:04:55.781]                           version <- utils::packageVersion("future")
[18:04:55.781]                       }
[18:04:55.781]                       else {
[18:04:55.781]                         version <- NULL
[18:04:55.781]                       }
[18:04:55.781]                       if (!has_future || version < "1.8.0") {
[18:04:55.781]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.781]                           "", base::R.version$version.string), 
[18:04:55.781]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.781]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.781]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.781]                             "release", "version")], collapse = " "), 
[18:04:55.781]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.781]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.781]                           info)
[18:04:55.781]                         info <- base::paste(info, collapse = "; ")
[18:04:55.781]                         if (!has_future) {
[18:04:55.781]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.781]                             info)
[18:04:55.781]                         }
[18:04:55.781]                         else {
[18:04:55.781]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.781]                             info, version)
[18:04:55.781]                         }
[18:04:55.781]                         base::stop(msg)
[18:04:55.781]                       }
[18:04:55.781]                     })
[18:04:55.781]                   }
[18:04:55.781]                   ...future.strategy.old <- future::plan("list")
[18:04:55.781]                   options(future.plan = NULL)
[18:04:55.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.781]                 }
[18:04:55.781]                 ...future.workdir <- getwd()
[18:04:55.781]             }
[18:04:55.781]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.781]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.781]         }
[18:04:55.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.781]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.781]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.781]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.781]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.781]             base::names(...future.oldOptions))
[18:04:55.781]     }
[18:04:55.781]     if (FALSE) {
[18:04:55.781]     }
[18:04:55.781]     else {
[18:04:55.781]         if (TRUE) {
[18:04:55.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.781]                 open = "w")
[18:04:55.781]         }
[18:04:55.781]         else {
[18:04:55.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.781]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.781]         }
[18:04:55.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.781]             base::sink(type = "output", split = FALSE)
[18:04:55.781]             base::close(...future.stdout)
[18:04:55.781]         }, add = TRUE)
[18:04:55.781]     }
[18:04:55.781]     ...future.frame <- base::sys.nframe()
[18:04:55.781]     ...future.conditions <- base::list()
[18:04:55.781]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.781]     if (FALSE) {
[18:04:55.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.781]     }
[18:04:55.781]     ...future.result <- base::tryCatch({
[18:04:55.781]         base::withCallingHandlers({
[18:04:55.781]             ...future.value <- base::withVisible(base::local(1))
[18:04:55.781]             future::FutureResult(value = ...future.value$value, 
[18:04:55.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.781]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.781]                     ...future.globalenv.names))
[18:04:55.781]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.781]         }, condition = base::local({
[18:04:55.781]             c <- base::c
[18:04:55.781]             inherits <- base::inherits
[18:04:55.781]             invokeRestart <- base::invokeRestart
[18:04:55.781]             length <- base::length
[18:04:55.781]             list <- base::list
[18:04:55.781]             seq.int <- base::seq.int
[18:04:55.781]             signalCondition <- base::signalCondition
[18:04:55.781]             sys.calls <- base::sys.calls
[18:04:55.781]             `[[` <- base::`[[`
[18:04:55.781]             `+` <- base::`+`
[18:04:55.781]             `<<-` <- base::`<<-`
[18:04:55.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.781]                   3L)]
[18:04:55.781]             }
[18:04:55.781]             function(cond) {
[18:04:55.781]                 is_error <- inherits(cond, "error")
[18:04:55.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.781]                   NULL)
[18:04:55.781]                 if (is_error) {
[18:04:55.781]                   sessionInformation <- function() {
[18:04:55.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.781]                       search = base::search(), system = base::Sys.info())
[18:04:55.781]                   }
[18:04:55.781]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.781]                     cond$call), session = sessionInformation(), 
[18:04:55.781]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.781]                   signalCondition(cond)
[18:04:55.781]                 }
[18:04:55.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.781]                 "immediateCondition"))) {
[18:04:55.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.781]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.781]                   if (TRUE && !signal) {
[18:04:55.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.781]                     {
[18:04:55.781]                       inherits <- base::inherits
[18:04:55.781]                       invokeRestart <- base::invokeRestart
[18:04:55.781]                       is.null <- base::is.null
[18:04:55.781]                       muffled <- FALSE
[18:04:55.781]                       if (inherits(cond, "message")) {
[18:04:55.781]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.781]                         if (muffled) 
[18:04:55.781]                           invokeRestart("muffleMessage")
[18:04:55.781]                       }
[18:04:55.781]                       else if (inherits(cond, "warning")) {
[18:04:55.781]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.781]                         if (muffled) 
[18:04:55.781]                           invokeRestart("muffleWarning")
[18:04:55.781]                       }
[18:04:55.781]                       else if (inherits(cond, "condition")) {
[18:04:55.781]                         if (!is.null(pattern)) {
[18:04:55.781]                           computeRestarts <- base::computeRestarts
[18:04:55.781]                           grepl <- base::grepl
[18:04:55.781]                           restarts <- computeRestarts(cond)
[18:04:55.781]                           for (restart in restarts) {
[18:04:55.781]                             name <- restart$name
[18:04:55.781]                             if (is.null(name)) 
[18:04:55.781]                               next
[18:04:55.781]                             if (!grepl(pattern, name)) 
[18:04:55.781]                               next
[18:04:55.781]                             invokeRestart(restart)
[18:04:55.781]                             muffled <- TRUE
[18:04:55.781]                             break
[18:04:55.781]                           }
[18:04:55.781]                         }
[18:04:55.781]                       }
[18:04:55.781]                       invisible(muffled)
[18:04:55.781]                     }
[18:04:55.781]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.781]                   }
[18:04:55.781]                 }
[18:04:55.781]                 else {
[18:04:55.781]                   if (TRUE) {
[18:04:55.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.781]                     {
[18:04:55.781]                       inherits <- base::inherits
[18:04:55.781]                       invokeRestart <- base::invokeRestart
[18:04:55.781]                       is.null <- base::is.null
[18:04:55.781]                       muffled <- FALSE
[18:04:55.781]                       if (inherits(cond, "message")) {
[18:04:55.781]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.781]                         if (muffled) 
[18:04:55.781]                           invokeRestart("muffleMessage")
[18:04:55.781]                       }
[18:04:55.781]                       else if (inherits(cond, "warning")) {
[18:04:55.781]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.781]                         if (muffled) 
[18:04:55.781]                           invokeRestart("muffleWarning")
[18:04:55.781]                       }
[18:04:55.781]                       else if (inherits(cond, "condition")) {
[18:04:55.781]                         if (!is.null(pattern)) {
[18:04:55.781]                           computeRestarts <- base::computeRestarts
[18:04:55.781]                           grepl <- base::grepl
[18:04:55.781]                           restarts <- computeRestarts(cond)
[18:04:55.781]                           for (restart in restarts) {
[18:04:55.781]                             name <- restart$name
[18:04:55.781]                             if (is.null(name)) 
[18:04:55.781]                               next
[18:04:55.781]                             if (!grepl(pattern, name)) 
[18:04:55.781]                               next
[18:04:55.781]                             invokeRestart(restart)
[18:04:55.781]                             muffled <- TRUE
[18:04:55.781]                             break
[18:04:55.781]                           }
[18:04:55.781]                         }
[18:04:55.781]                       }
[18:04:55.781]                       invisible(muffled)
[18:04:55.781]                     }
[18:04:55.781]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.781]                   }
[18:04:55.781]                 }
[18:04:55.781]             }
[18:04:55.781]         }))
[18:04:55.781]     }, error = function(ex) {
[18:04:55.781]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.781]                 ...future.rng), started = ...future.startTime, 
[18:04:55.781]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.781]             version = "1.8"), class = "FutureResult")
[18:04:55.781]     }, finally = {
[18:04:55.781]         if (!identical(...future.workdir, getwd())) 
[18:04:55.781]             setwd(...future.workdir)
[18:04:55.781]         {
[18:04:55.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.781]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.781]             }
[18:04:55.781]             base::options(...future.oldOptions)
[18:04:55.781]             if (.Platform$OS.type == "windows") {
[18:04:55.781]                 old_names <- names(...future.oldEnvVars)
[18:04:55.781]                 envs <- base::Sys.getenv()
[18:04:55.781]                 names <- names(envs)
[18:04:55.781]                 common <- intersect(names, old_names)
[18:04:55.781]                 added <- setdiff(names, old_names)
[18:04:55.781]                 removed <- setdiff(old_names, names)
[18:04:55.781]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.781]                   envs[common]]
[18:04:55.781]                 NAMES <- toupper(changed)
[18:04:55.781]                 args <- list()
[18:04:55.781]                 for (kk in seq_along(NAMES)) {
[18:04:55.781]                   name <- changed[[kk]]
[18:04:55.781]                   NAME <- NAMES[[kk]]
[18:04:55.781]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.781]                     next
[18:04:55.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.781]                 }
[18:04:55.781]                 NAMES <- toupper(added)
[18:04:55.781]                 for (kk in seq_along(NAMES)) {
[18:04:55.781]                   name <- added[[kk]]
[18:04:55.781]                   NAME <- NAMES[[kk]]
[18:04:55.781]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.781]                     next
[18:04:55.781]                   args[[name]] <- ""
[18:04:55.781]                 }
[18:04:55.781]                 NAMES <- toupper(removed)
[18:04:55.781]                 for (kk in seq_along(NAMES)) {
[18:04:55.781]                   name <- removed[[kk]]
[18:04:55.781]                   NAME <- NAMES[[kk]]
[18:04:55.781]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.781]                     next
[18:04:55.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.781]                 }
[18:04:55.781]                 if (length(args) > 0) 
[18:04:55.781]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.781]             }
[18:04:55.781]             else {
[18:04:55.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.781]             }
[18:04:55.781]             {
[18:04:55.781]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.781]                   0L) {
[18:04:55.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.781]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.781]                   base::options(opts)
[18:04:55.781]                 }
[18:04:55.781]                 {
[18:04:55.781]                   {
[18:04:55.781]                     NULL
[18:04:55.781]                     RNGkind("Mersenne-Twister")
[18:04:55.781]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.781]                       inherits = FALSE)
[18:04:55.781]                   }
[18:04:55.781]                   options(future.plan = NULL)
[18:04:55.781]                   if (is.na(NA_character_)) 
[18:04:55.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.781]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.781]                     .init = FALSE)
[18:04:55.781]                 }
[18:04:55.781]             }
[18:04:55.781]         }
[18:04:55.781]     })
[18:04:55.781]     if (TRUE) {
[18:04:55.781]         base::sink(type = "output", split = FALSE)
[18:04:55.781]         if (TRUE) {
[18:04:55.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.781]         }
[18:04:55.781]         else {
[18:04:55.781]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.781]         }
[18:04:55.781]         base::close(...future.stdout)
[18:04:55.781]         ...future.stdout <- NULL
[18:04:55.781]     }
[18:04:55.781]     ...future.result$conditions <- ...future.conditions
[18:04:55.781]     ...future.result$finished <- base::Sys.time()
[18:04:55.781]     ...future.result
[18:04:55.781] }
[18:04:55.785] plan(): Setting new future strategy stack:
[18:04:55.785] List of future strategies:
[18:04:55.785] 1. sequential:
[18:04:55.785]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.785]    - tweaked: FALSE
[18:04:55.785]    - call: NULL
[18:04:55.786] plan(): nbrOfWorkers() = 1
[18:04:55.788] plan(): Setting new future strategy stack:
[18:04:55.788] List of future strategies:
[18:04:55.788] 1. sequential:
[18:04:55.788]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.788]    - tweaked: FALSE
[18:04:55.788]    - call: plan(strategy)
[18:04:55.789] plan(): nbrOfWorkers() = 1
[18:04:55.789] SequentialFuture started (and completed)
[18:04:55.790] - Launch lazy future ... done
[18:04:55.790] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.790] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.791] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.795] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:55.796] Searching for globals ... DONE
[18:04:55.796] Resolving globals: TRUE
[18:04:55.796] Resolving any globals that are futures ...
[18:04:55.796] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:55.797] Resolving any globals that are futures ... DONE
[18:04:55.797] Resolving futures part of globals (recursively) ...
[18:04:55.798] resolve() on list ...
[18:04:55.798]  recursive: 99
[18:04:55.798]  length: 1
[18:04:55.798]  elements: ‘a’
[18:04:55.799] resolved() for ‘SequentialFuture’ ...
[18:04:55.799] - state: ‘finished’
[18:04:55.799] - run: TRUE
[18:04:55.799] - result: ‘FutureResult’
[18:04:55.800] resolved() for ‘SequentialFuture’ ... done
[18:04:55.800] Future #1
[18:04:55.800] resolved() for ‘SequentialFuture’ ...
[18:04:55.800] - state: ‘finished’
[18:04:55.801] - run: TRUE
[18:04:55.801] - result: ‘FutureResult’
[18:04:55.801] resolved() for ‘SequentialFuture’ ... done
[18:04:55.801] A SequentialFuture was resolved
[18:04:55.801]  length: 0 (resolved future 1)
[18:04:55.802] resolve() on list ... DONE
[18:04:55.802] - globals: [1] ‘a’
[18:04:55.802] Resolving futures part of globals (recursively) ... DONE
[18:04:55.806] The total size of the 1 globals is 1.55 MiB (1624736 bytes)
[18:04:55.807] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[18:04:55.807] - globals: [1] ‘a’
[18:04:55.808] - packages: [1] ‘future’
[18:04:55.808] getGlobalsAndPackages() ... DONE
[18:04:55.808] run() for ‘Future’ ...
[18:04:55.809] - state: ‘created’
[18:04:55.809] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.810] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.810]   - Field: ‘label’
[18:04:55.810]   - Field: ‘local’
[18:04:55.810]   - Field: ‘owner’
[18:04:55.811]   - Field: ‘envir’
[18:04:55.811]   - Field: ‘packages’
[18:04:55.811]   - Field: ‘gc’
[18:04:55.811]   - Field: ‘conditions’
[18:04:55.811]   - Field: ‘expr’
[18:04:55.812]   - Field: ‘uuid’
[18:04:55.812]   - Field: ‘seed’
[18:04:55.812]   - Field: ‘version’
[18:04:55.812]   - Field: ‘result’
[18:04:55.812]   - Field: ‘asynchronous’
[18:04:55.813]   - Field: ‘calls’
[18:04:55.813]   - Field: ‘globals’
[18:04:55.813]   - Field: ‘stdout’
[18:04:55.813]   - Field: ‘earlySignal’
[18:04:55.813]   - Field: ‘lazy’
[18:04:55.814]   - Field: ‘state’
[18:04:55.814] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.814] - Launch lazy future ...
[18:04:55.815] Packages needed by the future expression (n = 1): ‘future’
[18:04:55.815] Packages needed by future strategies (n = 0): <none>
[18:04:55.816] {
[18:04:55.816]     {
[18:04:55.816]         {
[18:04:55.816]             ...future.startTime <- base::Sys.time()
[18:04:55.816]             {
[18:04:55.816]                 {
[18:04:55.816]                   {
[18:04:55.816]                     {
[18:04:55.816]                       base::local({
[18:04:55.816]                         has_future <- base::requireNamespace("future", 
[18:04:55.816]                           quietly = TRUE)
[18:04:55.816]                         if (has_future) {
[18:04:55.816]                           ns <- base::getNamespace("future")
[18:04:55.816]                           version <- ns[[".package"]][["version"]]
[18:04:55.816]                           if (is.null(version)) 
[18:04:55.816]                             version <- utils::packageVersion("future")
[18:04:55.816]                         }
[18:04:55.816]                         else {
[18:04:55.816]                           version <- NULL
[18:04:55.816]                         }
[18:04:55.816]                         if (!has_future || version < "1.8.0") {
[18:04:55.816]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.816]                             "", base::R.version$version.string), 
[18:04:55.816]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:55.816]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.816]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.816]                               "release", "version")], collapse = " "), 
[18:04:55.816]                             hostname = base::Sys.info()[["nodename"]])
[18:04:55.816]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.816]                             info)
[18:04:55.816]                           info <- base::paste(info, collapse = "; ")
[18:04:55.816]                           if (!has_future) {
[18:04:55.816]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.816]                               info)
[18:04:55.816]                           }
[18:04:55.816]                           else {
[18:04:55.816]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.816]                               info, version)
[18:04:55.816]                           }
[18:04:55.816]                           base::stop(msg)
[18:04:55.816]                         }
[18:04:55.816]                       })
[18:04:55.816]                     }
[18:04:55.816]                     base::local({
[18:04:55.816]                       for (pkg in "future") {
[18:04:55.816]                         base::loadNamespace(pkg)
[18:04:55.816]                         base::library(pkg, character.only = TRUE)
[18:04:55.816]                       }
[18:04:55.816]                     })
[18:04:55.816]                   }
[18:04:55.816]                   ...future.strategy.old <- future::plan("list")
[18:04:55.816]                   options(future.plan = NULL)
[18:04:55.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.816]                 }
[18:04:55.816]                 ...future.workdir <- getwd()
[18:04:55.816]             }
[18:04:55.816]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.816]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.816]         }
[18:04:55.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.816]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.816]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.816]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.816]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.816]             base::names(...future.oldOptions))
[18:04:55.816]     }
[18:04:55.816]     if (FALSE) {
[18:04:55.816]     }
[18:04:55.816]     else {
[18:04:55.816]         if (TRUE) {
[18:04:55.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.816]                 open = "w")
[18:04:55.816]         }
[18:04:55.816]         else {
[18:04:55.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.816]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.816]         }
[18:04:55.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.816]             base::sink(type = "output", split = FALSE)
[18:04:55.816]             base::close(...future.stdout)
[18:04:55.816]         }, add = TRUE)
[18:04:55.816]     }
[18:04:55.816]     ...future.frame <- base::sys.nframe()
[18:04:55.816]     ...future.conditions <- base::list()
[18:04:55.816]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.816]     if (FALSE) {
[18:04:55.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.816]     }
[18:04:55.816]     ...future.result <- base::tryCatch({
[18:04:55.816]         base::withCallingHandlers({
[18:04:55.816]             ...future.value <- base::withVisible(base::local(value(a) + 
[18:04:55.816]                 1))
[18:04:55.816]             future::FutureResult(value = ...future.value$value, 
[18:04:55.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.816]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.816]                     ...future.globalenv.names))
[18:04:55.816]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.816]         }, condition = base::local({
[18:04:55.816]             c <- base::c
[18:04:55.816]             inherits <- base::inherits
[18:04:55.816]             invokeRestart <- base::invokeRestart
[18:04:55.816]             length <- base::length
[18:04:55.816]             list <- base::list
[18:04:55.816]             seq.int <- base::seq.int
[18:04:55.816]             signalCondition <- base::signalCondition
[18:04:55.816]             sys.calls <- base::sys.calls
[18:04:55.816]             `[[` <- base::`[[`
[18:04:55.816]             `+` <- base::`+`
[18:04:55.816]             `<<-` <- base::`<<-`
[18:04:55.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.816]                   3L)]
[18:04:55.816]             }
[18:04:55.816]             function(cond) {
[18:04:55.816]                 is_error <- inherits(cond, "error")
[18:04:55.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.816]                   NULL)
[18:04:55.816]                 if (is_error) {
[18:04:55.816]                   sessionInformation <- function() {
[18:04:55.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.816]                       search = base::search(), system = base::Sys.info())
[18:04:55.816]                   }
[18:04:55.816]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.816]                     cond$call), session = sessionInformation(), 
[18:04:55.816]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.816]                   signalCondition(cond)
[18:04:55.816]                 }
[18:04:55.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.816]                 "immediateCondition"))) {
[18:04:55.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.816]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.816]                   if (TRUE && !signal) {
[18:04:55.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.816]                     {
[18:04:55.816]                       inherits <- base::inherits
[18:04:55.816]                       invokeRestart <- base::invokeRestart
[18:04:55.816]                       is.null <- base::is.null
[18:04:55.816]                       muffled <- FALSE
[18:04:55.816]                       if (inherits(cond, "message")) {
[18:04:55.816]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.816]                         if (muffled) 
[18:04:55.816]                           invokeRestart("muffleMessage")
[18:04:55.816]                       }
[18:04:55.816]                       else if (inherits(cond, "warning")) {
[18:04:55.816]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.816]                         if (muffled) 
[18:04:55.816]                           invokeRestart("muffleWarning")
[18:04:55.816]                       }
[18:04:55.816]                       else if (inherits(cond, "condition")) {
[18:04:55.816]                         if (!is.null(pattern)) {
[18:04:55.816]                           computeRestarts <- base::computeRestarts
[18:04:55.816]                           grepl <- base::grepl
[18:04:55.816]                           restarts <- computeRestarts(cond)
[18:04:55.816]                           for (restart in restarts) {
[18:04:55.816]                             name <- restart$name
[18:04:55.816]                             if (is.null(name)) 
[18:04:55.816]                               next
[18:04:55.816]                             if (!grepl(pattern, name)) 
[18:04:55.816]                               next
[18:04:55.816]                             invokeRestart(restart)
[18:04:55.816]                             muffled <- TRUE
[18:04:55.816]                             break
[18:04:55.816]                           }
[18:04:55.816]                         }
[18:04:55.816]                       }
[18:04:55.816]                       invisible(muffled)
[18:04:55.816]                     }
[18:04:55.816]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.816]                   }
[18:04:55.816]                 }
[18:04:55.816]                 else {
[18:04:55.816]                   if (TRUE) {
[18:04:55.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.816]                     {
[18:04:55.816]                       inherits <- base::inherits
[18:04:55.816]                       invokeRestart <- base::invokeRestart
[18:04:55.816]                       is.null <- base::is.null
[18:04:55.816]                       muffled <- FALSE
[18:04:55.816]                       if (inherits(cond, "message")) {
[18:04:55.816]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.816]                         if (muffled) 
[18:04:55.816]                           invokeRestart("muffleMessage")
[18:04:55.816]                       }
[18:04:55.816]                       else if (inherits(cond, "warning")) {
[18:04:55.816]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.816]                         if (muffled) 
[18:04:55.816]                           invokeRestart("muffleWarning")
[18:04:55.816]                       }
[18:04:55.816]                       else if (inherits(cond, "condition")) {
[18:04:55.816]                         if (!is.null(pattern)) {
[18:04:55.816]                           computeRestarts <- base::computeRestarts
[18:04:55.816]                           grepl <- base::grepl
[18:04:55.816]                           restarts <- computeRestarts(cond)
[18:04:55.816]                           for (restart in restarts) {
[18:04:55.816]                             name <- restart$name
[18:04:55.816]                             if (is.null(name)) 
[18:04:55.816]                               next
[18:04:55.816]                             if (!grepl(pattern, name)) 
[18:04:55.816]                               next
[18:04:55.816]                             invokeRestart(restart)
[18:04:55.816]                             muffled <- TRUE
[18:04:55.816]                             break
[18:04:55.816]                           }
[18:04:55.816]                         }
[18:04:55.816]                       }
[18:04:55.816]                       invisible(muffled)
[18:04:55.816]                     }
[18:04:55.816]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.816]                   }
[18:04:55.816]                 }
[18:04:55.816]             }
[18:04:55.816]         }))
[18:04:55.816]     }, error = function(ex) {
[18:04:55.816]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.816]                 ...future.rng), started = ...future.startTime, 
[18:04:55.816]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.816]             version = "1.8"), class = "FutureResult")
[18:04:55.816]     }, finally = {
[18:04:55.816]         if (!identical(...future.workdir, getwd())) 
[18:04:55.816]             setwd(...future.workdir)
[18:04:55.816]         {
[18:04:55.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.816]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.816]             }
[18:04:55.816]             base::options(...future.oldOptions)
[18:04:55.816]             if (.Platform$OS.type == "windows") {
[18:04:55.816]                 old_names <- names(...future.oldEnvVars)
[18:04:55.816]                 envs <- base::Sys.getenv()
[18:04:55.816]                 names <- names(envs)
[18:04:55.816]                 common <- intersect(names, old_names)
[18:04:55.816]                 added <- setdiff(names, old_names)
[18:04:55.816]                 removed <- setdiff(old_names, names)
[18:04:55.816]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.816]                   envs[common]]
[18:04:55.816]                 NAMES <- toupper(changed)
[18:04:55.816]                 args <- list()
[18:04:55.816]                 for (kk in seq_along(NAMES)) {
[18:04:55.816]                   name <- changed[[kk]]
[18:04:55.816]                   NAME <- NAMES[[kk]]
[18:04:55.816]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.816]                     next
[18:04:55.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.816]                 }
[18:04:55.816]                 NAMES <- toupper(added)
[18:04:55.816]                 for (kk in seq_along(NAMES)) {
[18:04:55.816]                   name <- added[[kk]]
[18:04:55.816]                   NAME <- NAMES[[kk]]
[18:04:55.816]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.816]                     next
[18:04:55.816]                   args[[name]] <- ""
[18:04:55.816]                 }
[18:04:55.816]                 NAMES <- toupper(removed)
[18:04:55.816]                 for (kk in seq_along(NAMES)) {
[18:04:55.816]                   name <- removed[[kk]]
[18:04:55.816]                   NAME <- NAMES[[kk]]
[18:04:55.816]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.816]                     next
[18:04:55.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.816]                 }
[18:04:55.816]                 if (length(args) > 0) 
[18:04:55.816]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.816]             }
[18:04:55.816]             else {
[18:04:55.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.816]             }
[18:04:55.816]             {
[18:04:55.816]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.816]                   0L) {
[18:04:55.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.816]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.816]                   base::options(opts)
[18:04:55.816]                 }
[18:04:55.816]                 {
[18:04:55.816]                   {
[18:04:55.816]                     NULL
[18:04:55.816]                     RNGkind("Mersenne-Twister")
[18:04:55.816]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.816]                       inherits = FALSE)
[18:04:55.816]                   }
[18:04:55.816]                   options(future.plan = NULL)
[18:04:55.816]                   if (is.na(NA_character_)) 
[18:04:55.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.816]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.816]                     .init = FALSE)
[18:04:55.816]                 }
[18:04:55.816]             }
[18:04:55.816]         }
[18:04:55.816]     })
[18:04:55.816]     if (TRUE) {
[18:04:55.816]         base::sink(type = "output", split = FALSE)
[18:04:55.816]         if (TRUE) {
[18:04:55.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.816]         }
[18:04:55.816]         else {
[18:04:55.816]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.816]         }
[18:04:55.816]         base::close(...future.stdout)
[18:04:55.816]         ...future.stdout <- NULL
[18:04:55.816]     }
[18:04:55.816]     ...future.result$conditions <- ...future.conditions
[18:04:55.816]     ...future.result$finished <- base::Sys.time()
[18:04:55.816]     ...future.result
[18:04:55.816] }
[18:04:55.819] assign_globals() ...
[18:04:55.820] List of 1
[18:04:55.820]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5b95772733f8> 
[18:04:55.820]  - attr(*, "where")=List of 1
[18:04:55.820]   ..$ a:<environment: R_EmptyEnv> 
[18:04:55.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.820]  - attr(*, "resolved")= logi TRUE
[18:04:55.820]  - attr(*, "total_size")= num 1624736
[18:04:55.820]  - attr(*, "already-done")= logi TRUE
[18:04:55.825] - copied ‘a’ to environment
[18:04:55.825] assign_globals() ... done
[18:04:55.826] plan(): Setting new future strategy stack:
[18:04:55.826] List of future strategies:
[18:04:55.826] 1. sequential:
[18:04:55.826]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.826]    - tweaked: FALSE
[18:04:55.826]    - call: NULL
[18:04:55.827] plan(): nbrOfWorkers() = 1
[18:04:55.829] plan(): Setting new future strategy stack:
[18:04:55.829] List of future strategies:
[18:04:55.829] 1. sequential:
[18:04:55.829]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.829]    - tweaked: FALSE
[18:04:55.829]    - call: plan(strategy)
[18:04:55.830] plan(): nbrOfWorkers() = 1
[18:04:55.831] SequentialFuture started (and completed)
[18:04:55.831] - Launch lazy future ... done
[18:04:55.831] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.832] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.833] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.833] 
[18:04:55.834] Searching for globals ... DONE
[18:04:55.834] - globals: [0] <none>
[18:04:55.834] getGlobalsAndPackages() ... DONE
[18:04:55.835] run() for ‘Future’ ...
[18:04:55.835] - state: ‘created’
[18:04:55.835] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.836] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.836]   - Field: ‘label’
[18:04:55.837]   - Field: ‘local’
[18:04:55.837]   - Field: ‘owner’
[18:04:55.837]   - Field: ‘envir’
[18:04:55.837]   - Field: ‘packages’
[18:04:55.837]   - Field: ‘gc’
[18:04:55.838]   - Field: ‘conditions’
[18:04:55.838]   - Field: ‘expr’
[18:04:55.838]   - Field: ‘uuid’
[18:04:55.838]   - Field: ‘seed’
[18:04:55.838]   - Field: ‘version’
[18:04:55.839]   - Field: ‘result’
[18:04:55.839]   - Field: ‘asynchronous’
[18:04:55.839]   - Field: ‘calls’
[18:04:55.839]   - Field: ‘globals’
[18:04:55.839]   - Field: ‘stdout’
[18:04:55.839]   - Field: ‘earlySignal’
[18:04:55.840]   - Field: ‘lazy’
[18:04:55.840]   - Field: ‘state’
[18:04:55.840] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.840] - Launch lazy future ...
[18:04:55.841] Packages needed by the future expression (n = 0): <none>
[18:04:55.841] Packages needed by future strategies (n = 0): <none>
[18:04:55.842] {
[18:04:55.842]     {
[18:04:55.842]         {
[18:04:55.842]             ...future.startTime <- base::Sys.time()
[18:04:55.842]             {
[18:04:55.842]                 {
[18:04:55.842]                   {
[18:04:55.842]                     base::local({
[18:04:55.842]                       has_future <- base::requireNamespace("future", 
[18:04:55.842]                         quietly = TRUE)
[18:04:55.842]                       if (has_future) {
[18:04:55.842]                         ns <- base::getNamespace("future")
[18:04:55.842]                         version <- ns[[".package"]][["version"]]
[18:04:55.842]                         if (is.null(version)) 
[18:04:55.842]                           version <- utils::packageVersion("future")
[18:04:55.842]                       }
[18:04:55.842]                       else {
[18:04:55.842]                         version <- NULL
[18:04:55.842]                       }
[18:04:55.842]                       if (!has_future || version < "1.8.0") {
[18:04:55.842]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.842]                           "", base::R.version$version.string), 
[18:04:55.842]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.842]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.842]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.842]                             "release", "version")], collapse = " "), 
[18:04:55.842]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.842]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.842]                           info)
[18:04:55.842]                         info <- base::paste(info, collapse = "; ")
[18:04:55.842]                         if (!has_future) {
[18:04:55.842]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.842]                             info)
[18:04:55.842]                         }
[18:04:55.842]                         else {
[18:04:55.842]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.842]                             info, version)
[18:04:55.842]                         }
[18:04:55.842]                         base::stop(msg)
[18:04:55.842]                       }
[18:04:55.842]                     })
[18:04:55.842]                   }
[18:04:55.842]                   ...future.strategy.old <- future::plan("list")
[18:04:55.842]                   options(future.plan = NULL)
[18:04:55.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.842]                 }
[18:04:55.842]                 ...future.workdir <- getwd()
[18:04:55.842]             }
[18:04:55.842]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.842]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.842]         }
[18:04:55.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.842]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.842]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.842]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.842]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.842]             base::names(...future.oldOptions))
[18:04:55.842]     }
[18:04:55.842]     if (FALSE) {
[18:04:55.842]     }
[18:04:55.842]     else {
[18:04:55.842]         if (TRUE) {
[18:04:55.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.842]                 open = "w")
[18:04:55.842]         }
[18:04:55.842]         else {
[18:04:55.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.842]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.842]         }
[18:04:55.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.842]             base::sink(type = "output", split = FALSE)
[18:04:55.842]             base::close(...future.stdout)
[18:04:55.842]         }, add = TRUE)
[18:04:55.842]     }
[18:04:55.842]     ...future.frame <- base::sys.nframe()
[18:04:55.842]     ...future.conditions <- base::list()
[18:04:55.842]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.842]     if (FALSE) {
[18:04:55.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.842]     }
[18:04:55.842]     ...future.result <- base::tryCatch({
[18:04:55.842]         base::withCallingHandlers({
[18:04:55.842]             ...future.value <- base::withVisible(base::local(1))
[18:04:55.842]             future::FutureResult(value = ...future.value$value, 
[18:04:55.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.842]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.842]                     ...future.globalenv.names))
[18:04:55.842]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.842]         }, condition = base::local({
[18:04:55.842]             c <- base::c
[18:04:55.842]             inherits <- base::inherits
[18:04:55.842]             invokeRestart <- base::invokeRestart
[18:04:55.842]             length <- base::length
[18:04:55.842]             list <- base::list
[18:04:55.842]             seq.int <- base::seq.int
[18:04:55.842]             signalCondition <- base::signalCondition
[18:04:55.842]             sys.calls <- base::sys.calls
[18:04:55.842]             `[[` <- base::`[[`
[18:04:55.842]             `+` <- base::`+`
[18:04:55.842]             `<<-` <- base::`<<-`
[18:04:55.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.842]                   3L)]
[18:04:55.842]             }
[18:04:55.842]             function(cond) {
[18:04:55.842]                 is_error <- inherits(cond, "error")
[18:04:55.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.842]                   NULL)
[18:04:55.842]                 if (is_error) {
[18:04:55.842]                   sessionInformation <- function() {
[18:04:55.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.842]                       search = base::search(), system = base::Sys.info())
[18:04:55.842]                   }
[18:04:55.842]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.842]                     cond$call), session = sessionInformation(), 
[18:04:55.842]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.842]                   signalCondition(cond)
[18:04:55.842]                 }
[18:04:55.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.842]                 "immediateCondition"))) {
[18:04:55.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.842]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.842]                   if (TRUE && !signal) {
[18:04:55.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.842]                     {
[18:04:55.842]                       inherits <- base::inherits
[18:04:55.842]                       invokeRestart <- base::invokeRestart
[18:04:55.842]                       is.null <- base::is.null
[18:04:55.842]                       muffled <- FALSE
[18:04:55.842]                       if (inherits(cond, "message")) {
[18:04:55.842]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.842]                         if (muffled) 
[18:04:55.842]                           invokeRestart("muffleMessage")
[18:04:55.842]                       }
[18:04:55.842]                       else if (inherits(cond, "warning")) {
[18:04:55.842]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.842]                         if (muffled) 
[18:04:55.842]                           invokeRestart("muffleWarning")
[18:04:55.842]                       }
[18:04:55.842]                       else if (inherits(cond, "condition")) {
[18:04:55.842]                         if (!is.null(pattern)) {
[18:04:55.842]                           computeRestarts <- base::computeRestarts
[18:04:55.842]                           grepl <- base::grepl
[18:04:55.842]                           restarts <- computeRestarts(cond)
[18:04:55.842]                           for (restart in restarts) {
[18:04:55.842]                             name <- restart$name
[18:04:55.842]                             if (is.null(name)) 
[18:04:55.842]                               next
[18:04:55.842]                             if (!grepl(pattern, name)) 
[18:04:55.842]                               next
[18:04:55.842]                             invokeRestart(restart)
[18:04:55.842]                             muffled <- TRUE
[18:04:55.842]                             break
[18:04:55.842]                           }
[18:04:55.842]                         }
[18:04:55.842]                       }
[18:04:55.842]                       invisible(muffled)
[18:04:55.842]                     }
[18:04:55.842]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.842]                   }
[18:04:55.842]                 }
[18:04:55.842]                 else {
[18:04:55.842]                   if (TRUE) {
[18:04:55.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.842]                     {
[18:04:55.842]                       inherits <- base::inherits
[18:04:55.842]                       invokeRestart <- base::invokeRestart
[18:04:55.842]                       is.null <- base::is.null
[18:04:55.842]                       muffled <- FALSE
[18:04:55.842]                       if (inherits(cond, "message")) {
[18:04:55.842]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.842]                         if (muffled) 
[18:04:55.842]                           invokeRestart("muffleMessage")
[18:04:55.842]                       }
[18:04:55.842]                       else if (inherits(cond, "warning")) {
[18:04:55.842]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.842]                         if (muffled) 
[18:04:55.842]                           invokeRestart("muffleWarning")
[18:04:55.842]                       }
[18:04:55.842]                       else if (inherits(cond, "condition")) {
[18:04:55.842]                         if (!is.null(pattern)) {
[18:04:55.842]                           computeRestarts <- base::computeRestarts
[18:04:55.842]                           grepl <- base::grepl
[18:04:55.842]                           restarts <- computeRestarts(cond)
[18:04:55.842]                           for (restart in restarts) {
[18:04:55.842]                             name <- restart$name
[18:04:55.842]                             if (is.null(name)) 
[18:04:55.842]                               next
[18:04:55.842]                             if (!grepl(pattern, name)) 
[18:04:55.842]                               next
[18:04:55.842]                             invokeRestart(restart)
[18:04:55.842]                             muffled <- TRUE
[18:04:55.842]                             break
[18:04:55.842]                           }
[18:04:55.842]                         }
[18:04:55.842]                       }
[18:04:55.842]                       invisible(muffled)
[18:04:55.842]                     }
[18:04:55.842]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.842]                   }
[18:04:55.842]                 }
[18:04:55.842]             }
[18:04:55.842]         }))
[18:04:55.842]     }, error = function(ex) {
[18:04:55.842]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.842]                 ...future.rng), started = ...future.startTime, 
[18:04:55.842]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.842]             version = "1.8"), class = "FutureResult")
[18:04:55.842]     }, finally = {
[18:04:55.842]         if (!identical(...future.workdir, getwd())) 
[18:04:55.842]             setwd(...future.workdir)
[18:04:55.842]         {
[18:04:55.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.842]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.842]             }
[18:04:55.842]             base::options(...future.oldOptions)
[18:04:55.842]             if (.Platform$OS.type == "windows") {
[18:04:55.842]                 old_names <- names(...future.oldEnvVars)
[18:04:55.842]                 envs <- base::Sys.getenv()
[18:04:55.842]                 names <- names(envs)
[18:04:55.842]                 common <- intersect(names, old_names)
[18:04:55.842]                 added <- setdiff(names, old_names)
[18:04:55.842]                 removed <- setdiff(old_names, names)
[18:04:55.842]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.842]                   envs[common]]
[18:04:55.842]                 NAMES <- toupper(changed)
[18:04:55.842]                 args <- list()
[18:04:55.842]                 for (kk in seq_along(NAMES)) {
[18:04:55.842]                   name <- changed[[kk]]
[18:04:55.842]                   NAME <- NAMES[[kk]]
[18:04:55.842]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.842]                     next
[18:04:55.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.842]                 }
[18:04:55.842]                 NAMES <- toupper(added)
[18:04:55.842]                 for (kk in seq_along(NAMES)) {
[18:04:55.842]                   name <- added[[kk]]
[18:04:55.842]                   NAME <- NAMES[[kk]]
[18:04:55.842]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.842]                     next
[18:04:55.842]                   args[[name]] <- ""
[18:04:55.842]                 }
[18:04:55.842]                 NAMES <- toupper(removed)
[18:04:55.842]                 for (kk in seq_along(NAMES)) {
[18:04:55.842]                   name <- removed[[kk]]
[18:04:55.842]                   NAME <- NAMES[[kk]]
[18:04:55.842]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.842]                     next
[18:04:55.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.842]                 }
[18:04:55.842]                 if (length(args) > 0) 
[18:04:55.842]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.842]             }
[18:04:55.842]             else {
[18:04:55.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.842]             }
[18:04:55.842]             {
[18:04:55.842]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.842]                   0L) {
[18:04:55.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.842]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.842]                   base::options(opts)
[18:04:55.842]                 }
[18:04:55.842]                 {
[18:04:55.842]                   {
[18:04:55.842]                     NULL
[18:04:55.842]                     RNGkind("Mersenne-Twister")
[18:04:55.842]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.842]                       inherits = FALSE)
[18:04:55.842]                   }
[18:04:55.842]                   options(future.plan = NULL)
[18:04:55.842]                   if (is.na(NA_character_)) 
[18:04:55.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.842]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.842]                     .init = FALSE)
[18:04:55.842]                 }
[18:04:55.842]             }
[18:04:55.842]         }
[18:04:55.842]     })
[18:04:55.842]     if (TRUE) {
[18:04:55.842]         base::sink(type = "output", split = FALSE)
[18:04:55.842]         if (TRUE) {
[18:04:55.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.842]         }
[18:04:55.842]         else {
[18:04:55.842]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.842]         }
[18:04:55.842]         base::close(...future.stdout)
[18:04:55.842]         ...future.stdout <- NULL
[18:04:55.842]     }
[18:04:55.842]     ...future.result$conditions <- ...future.conditions
[18:04:55.842]     ...future.result$finished <- base::Sys.time()
[18:04:55.842]     ...future.result
[18:04:55.842] }
[18:04:55.846] plan(): Setting new future strategy stack:
[18:04:55.846] List of future strategies:
[18:04:55.846] 1. sequential:
[18:04:55.846]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.846]    - tweaked: FALSE
[18:04:55.846]    - call: NULL
[18:04:55.847] plan(): nbrOfWorkers() = 1
[18:04:55.848] plan(): Setting new future strategy stack:
[18:04:55.849] List of future strategies:
[18:04:55.849] 1. sequential:
[18:04:55.849]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.849]    - tweaked: FALSE
[18:04:55.849]    - call: plan(strategy)
[18:04:55.850] plan(): nbrOfWorkers() = 1
[18:04:55.850] SequentialFuture started (and completed)
[18:04:55.851] - Launch lazy future ... done
[18:04:55.851] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.851] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.852] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.856] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:55.857] Searching for globals ... DONE
[18:04:55.857] Resolving globals: TRUE
[18:04:55.857] Resolving any globals that are futures ...
[18:04:55.857] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:55.858] Resolving any globals that are futures ... DONE
[18:04:55.858] Resolving futures part of globals (recursively) ...
[18:04:55.859] resolve() on list ...
[18:04:55.859]  recursive: 99
[18:04:55.859]  length: 1
[18:04:55.859]  elements: ‘a’
[18:04:55.860] resolved() for ‘SequentialFuture’ ...
[18:04:55.860] - state: ‘finished’
[18:04:55.860] - run: TRUE
[18:04:55.860] - result: ‘FutureResult’
[18:04:55.861] resolved() for ‘SequentialFuture’ ... done
[18:04:55.861] Future #1
[18:04:55.861] resolved() for ‘SequentialFuture’ ...
[18:04:55.861] - state: ‘finished’
[18:04:55.862] - run: TRUE
[18:04:55.862] - result: ‘FutureResult’
[18:04:55.862] resolved() for ‘SequentialFuture’ ... done
[18:04:55.862] A SequentialFuture was resolved
[18:04:55.862]  length: 0 (resolved future 1)
[18:04:55.863] resolve() on list ... DONE
[18:04:55.863] - globals: [1] ‘a’
[18:04:55.863] Resolving futures part of globals (recursively) ... DONE
[18:04:55.867] The total size of the 1 globals is 1.55 MiB (1624736 bytes)
[18:04:55.868] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[18:04:55.868] - globals: [1] ‘a’
[18:04:55.868] - packages: [1] ‘future’
[18:04:55.869] getGlobalsAndPackages() ... DONE
[18:04:55.869] run() for ‘Future’ ...
[18:04:55.869] - state: ‘created’
[18:04:55.870] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.870] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.871] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.871]   - Field: ‘label’
[18:04:55.871]   - Field: ‘local’
[18:04:55.871]   - Field: ‘owner’
[18:04:55.871]   - Field: ‘envir’
[18:04:55.872]   - Field: ‘packages’
[18:04:55.872]   - Field: ‘gc’
[18:04:55.872]   - Field: ‘conditions’
[18:04:55.872]   - Field: ‘expr’
[18:04:55.873]   - Field: ‘uuid’
[18:04:55.873]   - Field: ‘seed’
[18:04:55.873]   - Field: ‘version’
[18:04:55.873]   - Field: ‘result’
[18:04:55.873]   - Field: ‘asynchronous’
[18:04:55.874]   - Field: ‘calls’
[18:04:55.874]   - Field: ‘globals’
[18:04:55.874]   - Field: ‘stdout’
[18:04:55.874]   - Field: ‘earlySignal’
[18:04:55.874]   - Field: ‘lazy’
[18:04:55.875]   - Field: ‘state’
[18:04:55.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.875] - Launch lazy future ...
[18:04:55.875] Packages needed by the future expression (n = 1): ‘future’
[18:04:55.876] Packages needed by future strategies (n = 0): <none>
[18:04:55.877] {
[18:04:55.877]     {
[18:04:55.877]         {
[18:04:55.877]             ...future.startTime <- base::Sys.time()
[18:04:55.877]             {
[18:04:55.877]                 {
[18:04:55.877]                   {
[18:04:55.877]                     {
[18:04:55.877]                       base::local({
[18:04:55.877]                         has_future <- base::requireNamespace("future", 
[18:04:55.877]                           quietly = TRUE)
[18:04:55.877]                         if (has_future) {
[18:04:55.877]                           ns <- base::getNamespace("future")
[18:04:55.877]                           version <- ns[[".package"]][["version"]]
[18:04:55.877]                           if (is.null(version)) 
[18:04:55.877]                             version <- utils::packageVersion("future")
[18:04:55.877]                         }
[18:04:55.877]                         else {
[18:04:55.877]                           version <- NULL
[18:04:55.877]                         }
[18:04:55.877]                         if (!has_future || version < "1.8.0") {
[18:04:55.877]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.877]                             "", base::R.version$version.string), 
[18:04:55.877]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:55.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.877]                               "release", "version")], collapse = " "), 
[18:04:55.877]                             hostname = base::Sys.info()[["nodename"]])
[18:04:55.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.877]                             info)
[18:04:55.877]                           info <- base::paste(info, collapse = "; ")
[18:04:55.877]                           if (!has_future) {
[18:04:55.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.877]                               info)
[18:04:55.877]                           }
[18:04:55.877]                           else {
[18:04:55.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.877]                               info, version)
[18:04:55.877]                           }
[18:04:55.877]                           base::stop(msg)
[18:04:55.877]                         }
[18:04:55.877]                       })
[18:04:55.877]                     }
[18:04:55.877]                     base::local({
[18:04:55.877]                       for (pkg in "future") {
[18:04:55.877]                         base::loadNamespace(pkg)
[18:04:55.877]                         base::library(pkg, character.only = TRUE)
[18:04:55.877]                       }
[18:04:55.877]                     })
[18:04:55.877]                   }
[18:04:55.877]                   ...future.strategy.old <- future::plan("list")
[18:04:55.877]                   options(future.plan = NULL)
[18:04:55.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.877]                 }
[18:04:55.877]                 ...future.workdir <- getwd()
[18:04:55.877]             }
[18:04:55.877]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.877]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.877]         }
[18:04:55.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.877]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.877]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.877]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.877]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.877]             base::names(...future.oldOptions))
[18:04:55.877]     }
[18:04:55.877]     if (FALSE) {
[18:04:55.877]     }
[18:04:55.877]     else {
[18:04:55.877]         if (TRUE) {
[18:04:55.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.877]                 open = "w")
[18:04:55.877]         }
[18:04:55.877]         else {
[18:04:55.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.877]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.877]         }
[18:04:55.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.877]             base::sink(type = "output", split = FALSE)
[18:04:55.877]             base::close(...future.stdout)
[18:04:55.877]         }, add = TRUE)
[18:04:55.877]     }
[18:04:55.877]     ...future.frame <- base::sys.nframe()
[18:04:55.877]     ...future.conditions <- base::list()
[18:04:55.877]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.877]     if (FALSE) {
[18:04:55.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.877]     }
[18:04:55.877]     ...future.result <- base::tryCatch({
[18:04:55.877]         base::withCallingHandlers({
[18:04:55.877]             ...future.value <- base::withVisible(base::local(value(a) + 
[18:04:55.877]                 1))
[18:04:55.877]             future::FutureResult(value = ...future.value$value, 
[18:04:55.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.877]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.877]                     ...future.globalenv.names))
[18:04:55.877]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.877]         }, condition = base::local({
[18:04:55.877]             c <- base::c
[18:04:55.877]             inherits <- base::inherits
[18:04:55.877]             invokeRestart <- base::invokeRestart
[18:04:55.877]             length <- base::length
[18:04:55.877]             list <- base::list
[18:04:55.877]             seq.int <- base::seq.int
[18:04:55.877]             signalCondition <- base::signalCondition
[18:04:55.877]             sys.calls <- base::sys.calls
[18:04:55.877]             `[[` <- base::`[[`
[18:04:55.877]             `+` <- base::`+`
[18:04:55.877]             `<<-` <- base::`<<-`
[18:04:55.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.877]                   3L)]
[18:04:55.877]             }
[18:04:55.877]             function(cond) {
[18:04:55.877]                 is_error <- inherits(cond, "error")
[18:04:55.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.877]                   NULL)
[18:04:55.877]                 if (is_error) {
[18:04:55.877]                   sessionInformation <- function() {
[18:04:55.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.877]                       search = base::search(), system = base::Sys.info())
[18:04:55.877]                   }
[18:04:55.877]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.877]                     cond$call), session = sessionInformation(), 
[18:04:55.877]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.877]                   signalCondition(cond)
[18:04:55.877]                 }
[18:04:55.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.877]                 "immediateCondition"))) {
[18:04:55.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.877]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.877]                   if (TRUE && !signal) {
[18:04:55.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.877]                     {
[18:04:55.877]                       inherits <- base::inherits
[18:04:55.877]                       invokeRestart <- base::invokeRestart
[18:04:55.877]                       is.null <- base::is.null
[18:04:55.877]                       muffled <- FALSE
[18:04:55.877]                       if (inherits(cond, "message")) {
[18:04:55.877]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.877]                         if (muffled) 
[18:04:55.877]                           invokeRestart("muffleMessage")
[18:04:55.877]                       }
[18:04:55.877]                       else if (inherits(cond, "warning")) {
[18:04:55.877]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.877]                         if (muffled) 
[18:04:55.877]                           invokeRestart("muffleWarning")
[18:04:55.877]                       }
[18:04:55.877]                       else if (inherits(cond, "condition")) {
[18:04:55.877]                         if (!is.null(pattern)) {
[18:04:55.877]                           computeRestarts <- base::computeRestarts
[18:04:55.877]                           grepl <- base::grepl
[18:04:55.877]                           restarts <- computeRestarts(cond)
[18:04:55.877]                           for (restart in restarts) {
[18:04:55.877]                             name <- restart$name
[18:04:55.877]                             if (is.null(name)) 
[18:04:55.877]                               next
[18:04:55.877]                             if (!grepl(pattern, name)) 
[18:04:55.877]                               next
[18:04:55.877]                             invokeRestart(restart)
[18:04:55.877]                             muffled <- TRUE
[18:04:55.877]                             break
[18:04:55.877]                           }
[18:04:55.877]                         }
[18:04:55.877]                       }
[18:04:55.877]                       invisible(muffled)
[18:04:55.877]                     }
[18:04:55.877]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.877]                   }
[18:04:55.877]                 }
[18:04:55.877]                 else {
[18:04:55.877]                   if (TRUE) {
[18:04:55.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.877]                     {
[18:04:55.877]                       inherits <- base::inherits
[18:04:55.877]                       invokeRestart <- base::invokeRestart
[18:04:55.877]                       is.null <- base::is.null
[18:04:55.877]                       muffled <- FALSE
[18:04:55.877]                       if (inherits(cond, "message")) {
[18:04:55.877]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.877]                         if (muffled) 
[18:04:55.877]                           invokeRestart("muffleMessage")
[18:04:55.877]                       }
[18:04:55.877]                       else if (inherits(cond, "warning")) {
[18:04:55.877]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.877]                         if (muffled) 
[18:04:55.877]                           invokeRestart("muffleWarning")
[18:04:55.877]                       }
[18:04:55.877]                       else if (inherits(cond, "condition")) {
[18:04:55.877]                         if (!is.null(pattern)) {
[18:04:55.877]                           computeRestarts <- base::computeRestarts
[18:04:55.877]                           grepl <- base::grepl
[18:04:55.877]                           restarts <- computeRestarts(cond)
[18:04:55.877]                           for (restart in restarts) {
[18:04:55.877]                             name <- restart$name
[18:04:55.877]                             if (is.null(name)) 
[18:04:55.877]                               next
[18:04:55.877]                             if (!grepl(pattern, name)) 
[18:04:55.877]                               next
[18:04:55.877]                             invokeRestart(restart)
[18:04:55.877]                             muffled <- TRUE
[18:04:55.877]                             break
[18:04:55.877]                           }
[18:04:55.877]                         }
[18:04:55.877]                       }
[18:04:55.877]                       invisible(muffled)
[18:04:55.877]                     }
[18:04:55.877]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.877]                   }
[18:04:55.877]                 }
[18:04:55.877]             }
[18:04:55.877]         }))
[18:04:55.877]     }, error = function(ex) {
[18:04:55.877]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.877]                 ...future.rng), started = ...future.startTime, 
[18:04:55.877]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.877]             version = "1.8"), class = "FutureResult")
[18:04:55.877]     }, finally = {
[18:04:55.877]         if (!identical(...future.workdir, getwd())) 
[18:04:55.877]             setwd(...future.workdir)
[18:04:55.877]         {
[18:04:55.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.877]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.877]             }
[18:04:55.877]             base::options(...future.oldOptions)
[18:04:55.877]             if (.Platform$OS.type == "windows") {
[18:04:55.877]                 old_names <- names(...future.oldEnvVars)
[18:04:55.877]                 envs <- base::Sys.getenv()
[18:04:55.877]                 names <- names(envs)
[18:04:55.877]                 common <- intersect(names, old_names)
[18:04:55.877]                 added <- setdiff(names, old_names)
[18:04:55.877]                 removed <- setdiff(old_names, names)
[18:04:55.877]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.877]                   envs[common]]
[18:04:55.877]                 NAMES <- toupper(changed)
[18:04:55.877]                 args <- list()
[18:04:55.877]                 for (kk in seq_along(NAMES)) {
[18:04:55.877]                   name <- changed[[kk]]
[18:04:55.877]                   NAME <- NAMES[[kk]]
[18:04:55.877]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.877]                     next
[18:04:55.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.877]                 }
[18:04:55.877]                 NAMES <- toupper(added)
[18:04:55.877]                 for (kk in seq_along(NAMES)) {
[18:04:55.877]                   name <- added[[kk]]
[18:04:55.877]                   NAME <- NAMES[[kk]]
[18:04:55.877]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.877]                     next
[18:04:55.877]                   args[[name]] <- ""
[18:04:55.877]                 }
[18:04:55.877]                 NAMES <- toupper(removed)
[18:04:55.877]                 for (kk in seq_along(NAMES)) {
[18:04:55.877]                   name <- removed[[kk]]
[18:04:55.877]                   NAME <- NAMES[[kk]]
[18:04:55.877]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.877]                     next
[18:04:55.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.877]                 }
[18:04:55.877]                 if (length(args) > 0) 
[18:04:55.877]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.877]             }
[18:04:55.877]             else {
[18:04:55.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.877]             }
[18:04:55.877]             {
[18:04:55.877]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.877]                   0L) {
[18:04:55.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.877]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.877]                   base::options(opts)
[18:04:55.877]                 }
[18:04:55.877]                 {
[18:04:55.877]                   {
[18:04:55.877]                     NULL
[18:04:55.877]                     RNGkind("Mersenne-Twister")
[18:04:55.877]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.877]                       inherits = FALSE)
[18:04:55.877]                   }
[18:04:55.877]                   options(future.plan = NULL)
[18:04:55.877]                   if (is.na(NA_character_)) 
[18:04:55.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.877]                     .init = FALSE)
[18:04:55.877]                 }
[18:04:55.877]             }
[18:04:55.877]         }
[18:04:55.877]     })
[18:04:55.877]     if (TRUE) {
[18:04:55.877]         base::sink(type = "output", split = FALSE)
[18:04:55.877]         if (TRUE) {
[18:04:55.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.877]         }
[18:04:55.877]         else {
[18:04:55.877]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.877]         }
[18:04:55.877]         base::close(...future.stdout)
[18:04:55.877]         ...future.stdout <- NULL
[18:04:55.877]     }
[18:04:55.877]     ...future.result$conditions <- ...future.conditions
[18:04:55.877]     ...future.result$finished <- base::Sys.time()
[18:04:55.877]     ...future.result
[18:04:55.877] }
[18:04:55.880] assign_globals() ...
[18:04:55.880] List of 1
[18:04:55.880]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5b9577241ee8> 
[18:04:55.880]  - attr(*, "where")=List of 1
[18:04:55.880]   ..$ a:<environment: R_EmptyEnv> 
[18:04:55.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.880]  - attr(*, "resolved")= logi TRUE
[18:04:55.880]  - attr(*, "total_size")= num 1624736
[18:04:55.880]  - attr(*, "already-done")= logi TRUE
[18:04:55.886] - copied ‘a’ to environment
[18:04:55.886] assign_globals() ... done
[18:04:55.887] plan(): Setting new future strategy stack:
[18:04:55.887] List of future strategies:
[18:04:55.887] 1. sequential:
[18:04:55.887]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.887]    - tweaked: FALSE
[18:04:55.887]    - call: NULL
[18:04:55.888] plan(): nbrOfWorkers() = 1
[18:04:55.890] plan(): Setting new future strategy stack:
[18:04:55.890] List of future strategies:
[18:04:55.890] 1. sequential:
[18:04:55.890]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.890]    - tweaked: FALSE
[18:04:55.890]    - call: plan(strategy)
[18:04:55.892] plan(): nbrOfWorkers() = 1
[18:04:55.892] SequentialFuture started (and completed)
[18:04:55.892] - Launch lazy future ... done
[18:04:55.893] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.893] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.894] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.895] 
[18:04:55.895] Searching for globals ... DONE
[18:04:55.895] - globals: [0] <none>
[18:04:55.895] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.896] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.897] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.898] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:55.899] Searching for globals ... DONE
[18:04:55.899] Resolving globals: TRUE
[18:04:55.899] Resolving any globals that are futures ...
[18:04:55.899] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:55.900] Resolving any globals that are futures ... DONE
[18:04:55.900] Resolving futures part of globals (recursively) ...
[18:04:55.901] resolve() on list ...
[18:04:55.901]  recursive: 99
[18:04:55.901]  length: 1
[18:04:55.901]  elements: ‘a’
[18:04:55.902] run() for ‘Future’ ...
[18:04:55.902] - state: ‘created’
[18:04:55.902] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.903] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.903]   - Field: ‘label’
[18:04:55.903]   - Field: ‘local’
[18:04:55.904]   - Field: ‘owner’
[18:04:55.904]   - Field: ‘envir’
[18:04:55.904]   - Field: ‘packages’
[18:04:55.904]   - Field: ‘gc’
[18:04:55.904]   - Field: ‘conditions’
[18:04:55.905]   - Field: ‘expr’
[18:04:55.905]   - Field: ‘uuid’
[18:04:55.905]   - Field: ‘seed’
[18:04:55.905]   - Field: ‘version’
[18:04:55.905]   - Field: ‘result’
[18:04:55.906]   - Field: ‘asynchronous’
[18:04:55.906]   - Field: ‘calls’
[18:04:55.906]   - Field: ‘globals’
[18:04:55.906]   - Field: ‘stdout’
[18:04:55.907]   - Field: ‘earlySignal’
[18:04:55.907]   - Field: ‘lazy’
[18:04:55.907]   - Field: ‘state’
[18:04:55.907] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.908] - Launch lazy future ...
[18:04:55.908] Packages needed by the future expression (n = 0): <none>
[18:04:55.909] Packages needed by future strategies (n = 0): <none>
[18:04:55.943] {
[18:04:55.943]     {
[18:04:55.943]         {
[18:04:55.943]             ...future.startTime <- base::Sys.time()
[18:04:55.943]             {
[18:04:55.943]                 {
[18:04:55.943]                   {
[18:04:55.943]                     base::local({
[18:04:55.943]                       has_future <- base::requireNamespace("future", 
[18:04:55.943]                         quietly = TRUE)
[18:04:55.943]                       if (has_future) {
[18:04:55.943]                         ns <- base::getNamespace("future")
[18:04:55.943]                         version <- ns[[".package"]][["version"]]
[18:04:55.943]                         if (is.null(version)) 
[18:04:55.943]                           version <- utils::packageVersion("future")
[18:04:55.943]                       }
[18:04:55.943]                       else {
[18:04:55.943]                         version <- NULL
[18:04:55.943]                       }
[18:04:55.943]                       if (!has_future || version < "1.8.0") {
[18:04:55.943]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.943]                           "", base::R.version$version.string), 
[18:04:55.943]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.943]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.943]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.943]                             "release", "version")], collapse = " "), 
[18:04:55.943]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.943]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.943]                           info)
[18:04:55.943]                         info <- base::paste(info, collapse = "; ")
[18:04:55.943]                         if (!has_future) {
[18:04:55.943]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.943]                             info)
[18:04:55.943]                         }
[18:04:55.943]                         else {
[18:04:55.943]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.943]                             info, version)
[18:04:55.943]                         }
[18:04:55.943]                         base::stop(msg)
[18:04:55.943]                       }
[18:04:55.943]                     })
[18:04:55.943]                   }
[18:04:55.943]                   ...future.strategy.old <- future::plan("list")
[18:04:55.943]                   options(future.plan = NULL)
[18:04:55.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.943]                 }
[18:04:55.943]                 ...future.workdir <- getwd()
[18:04:55.943]             }
[18:04:55.943]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.943]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.943]         }
[18:04:55.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.943]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.943]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.943]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.943]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.943]             base::names(...future.oldOptions))
[18:04:55.943]     }
[18:04:55.943]     if (FALSE) {
[18:04:55.943]     }
[18:04:55.943]     else {
[18:04:55.943]         if (TRUE) {
[18:04:55.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.943]                 open = "w")
[18:04:55.943]         }
[18:04:55.943]         else {
[18:04:55.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.943]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.943]         }
[18:04:55.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.943]             base::sink(type = "output", split = FALSE)
[18:04:55.943]             base::close(...future.stdout)
[18:04:55.943]         }, add = TRUE)
[18:04:55.943]     }
[18:04:55.943]     ...future.frame <- base::sys.nframe()
[18:04:55.943]     ...future.conditions <- base::list()
[18:04:55.943]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.943]     if (FALSE) {
[18:04:55.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.943]     }
[18:04:55.943]     ...future.result <- base::tryCatch({
[18:04:55.943]         base::withCallingHandlers({
[18:04:55.943]             ...future.value <- base::withVisible(base::local(1))
[18:04:55.943]             future::FutureResult(value = ...future.value$value, 
[18:04:55.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.943]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.943]                     ...future.globalenv.names))
[18:04:55.943]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.943]         }, condition = base::local({
[18:04:55.943]             c <- base::c
[18:04:55.943]             inherits <- base::inherits
[18:04:55.943]             invokeRestart <- base::invokeRestart
[18:04:55.943]             length <- base::length
[18:04:55.943]             list <- base::list
[18:04:55.943]             seq.int <- base::seq.int
[18:04:55.943]             signalCondition <- base::signalCondition
[18:04:55.943]             sys.calls <- base::sys.calls
[18:04:55.943]             `[[` <- base::`[[`
[18:04:55.943]             `+` <- base::`+`
[18:04:55.943]             `<<-` <- base::`<<-`
[18:04:55.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.943]                   3L)]
[18:04:55.943]             }
[18:04:55.943]             function(cond) {
[18:04:55.943]                 is_error <- inherits(cond, "error")
[18:04:55.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.943]                   NULL)
[18:04:55.943]                 if (is_error) {
[18:04:55.943]                   sessionInformation <- function() {
[18:04:55.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.943]                       search = base::search(), system = base::Sys.info())
[18:04:55.943]                   }
[18:04:55.943]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.943]                     cond$call), session = sessionInformation(), 
[18:04:55.943]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.943]                   signalCondition(cond)
[18:04:55.943]                 }
[18:04:55.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.943]                 "immediateCondition"))) {
[18:04:55.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.943]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.943]                   if (TRUE && !signal) {
[18:04:55.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.943]                     {
[18:04:55.943]                       inherits <- base::inherits
[18:04:55.943]                       invokeRestart <- base::invokeRestart
[18:04:55.943]                       is.null <- base::is.null
[18:04:55.943]                       muffled <- FALSE
[18:04:55.943]                       if (inherits(cond, "message")) {
[18:04:55.943]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.943]                         if (muffled) 
[18:04:55.943]                           invokeRestart("muffleMessage")
[18:04:55.943]                       }
[18:04:55.943]                       else if (inherits(cond, "warning")) {
[18:04:55.943]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.943]                         if (muffled) 
[18:04:55.943]                           invokeRestart("muffleWarning")
[18:04:55.943]                       }
[18:04:55.943]                       else if (inherits(cond, "condition")) {
[18:04:55.943]                         if (!is.null(pattern)) {
[18:04:55.943]                           computeRestarts <- base::computeRestarts
[18:04:55.943]                           grepl <- base::grepl
[18:04:55.943]                           restarts <- computeRestarts(cond)
[18:04:55.943]                           for (restart in restarts) {
[18:04:55.943]                             name <- restart$name
[18:04:55.943]                             if (is.null(name)) 
[18:04:55.943]                               next
[18:04:55.943]                             if (!grepl(pattern, name)) 
[18:04:55.943]                               next
[18:04:55.943]                             invokeRestart(restart)
[18:04:55.943]                             muffled <- TRUE
[18:04:55.943]                             break
[18:04:55.943]                           }
[18:04:55.943]                         }
[18:04:55.943]                       }
[18:04:55.943]                       invisible(muffled)
[18:04:55.943]                     }
[18:04:55.943]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.943]                   }
[18:04:55.943]                 }
[18:04:55.943]                 else {
[18:04:55.943]                   if (TRUE) {
[18:04:55.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.943]                     {
[18:04:55.943]                       inherits <- base::inherits
[18:04:55.943]                       invokeRestart <- base::invokeRestart
[18:04:55.943]                       is.null <- base::is.null
[18:04:55.943]                       muffled <- FALSE
[18:04:55.943]                       if (inherits(cond, "message")) {
[18:04:55.943]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.943]                         if (muffled) 
[18:04:55.943]                           invokeRestart("muffleMessage")
[18:04:55.943]                       }
[18:04:55.943]                       else if (inherits(cond, "warning")) {
[18:04:55.943]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.943]                         if (muffled) 
[18:04:55.943]                           invokeRestart("muffleWarning")
[18:04:55.943]                       }
[18:04:55.943]                       else if (inherits(cond, "condition")) {
[18:04:55.943]                         if (!is.null(pattern)) {
[18:04:55.943]                           computeRestarts <- base::computeRestarts
[18:04:55.943]                           grepl <- base::grepl
[18:04:55.943]                           restarts <- computeRestarts(cond)
[18:04:55.943]                           for (restart in restarts) {
[18:04:55.943]                             name <- restart$name
[18:04:55.943]                             if (is.null(name)) 
[18:04:55.943]                               next
[18:04:55.943]                             if (!grepl(pattern, name)) 
[18:04:55.943]                               next
[18:04:55.943]                             invokeRestart(restart)
[18:04:55.943]                             muffled <- TRUE
[18:04:55.943]                             break
[18:04:55.943]                           }
[18:04:55.943]                         }
[18:04:55.943]                       }
[18:04:55.943]                       invisible(muffled)
[18:04:55.943]                     }
[18:04:55.943]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.943]                   }
[18:04:55.943]                 }
[18:04:55.943]             }
[18:04:55.943]         }))
[18:04:55.943]     }, error = function(ex) {
[18:04:55.943]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.943]                 ...future.rng), started = ...future.startTime, 
[18:04:55.943]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.943]             version = "1.8"), class = "FutureResult")
[18:04:55.943]     }, finally = {
[18:04:55.943]         if (!identical(...future.workdir, getwd())) 
[18:04:55.943]             setwd(...future.workdir)
[18:04:55.943]         {
[18:04:55.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.943]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.943]             }
[18:04:55.943]             base::options(...future.oldOptions)
[18:04:55.943]             if (.Platform$OS.type == "windows") {
[18:04:55.943]                 old_names <- names(...future.oldEnvVars)
[18:04:55.943]                 envs <- base::Sys.getenv()
[18:04:55.943]                 names <- names(envs)
[18:04:55.943]                 common <- intersect(names, old_names)
[18:04:55.943]                 added <- setdiff(names, old_names)
[18:04:55.943]                 removed <- setdiff(old_names, names)
[18:04:55.943]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.943]                   envs[common]]
[18:04:55.943]                 NAMES <- toupper(changed)
[18:04:55.943]                 args <- list()
[18:04:55.943]                 for (kk in seq_along(NAMES)) {
[18:04:55.943]                   name <- changed[[kk]]
[18:04:55.943]                   NAME <- NAMES[[kk]]
[18:04:55.943]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.943]                     next
[18:04:55.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.943]                 }
[18:04:55.943]                 NAMES <- toupper(added)
[18:04:55.943]                 for (kk in seq_along(NAMES)) {
[18:04:55.943]                   name <- added[[kk]]
[18:04:55.943]                   NAME <- NAMES[[kk]]
[18:04:55.943]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.943]                     next
[18:04:55.943]                   args[[name]] <- ""
[18:04:55.943]                 }
[18:04:55.943]                 NAMES <- toupper(removed)
[18:04:55.943]                 for (kk in seq_along(NAMES)) {
[18:04:55.943]                   name <- removed[[kk]]
[18:04:55.943]                   NAME <- NAMES[[kk]]
[18:04:55.943]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.943]                     next
[18:04:55.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.943]                 }
[18:04:55.943]                 if (length(args) > 0) 
[18:04:55.943]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.943]             }
[18:04:55.943]             else {
[18:04:55.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.943]             }
[18:04:55.943]             {
[18:04:55.943]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.943]                   0L) {
[18:04:55.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.943]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.943]                   base::options(opts)
[18:04:55.943]                 }
[18:04:55.943]                 {
[18:04:55.943]                   {
[18:04:55.943]                     NULL
[18:04:55.943]                     RNGkind("Mersenne-Twister")
[18:04:55.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.943]                       inherits = FALSE)
[18:04:55.943]                   }
[18:04:55.943]                   options(future.plan = NULL)
[18:04:55.943]                   if (is.na(NA_character_)) 
[18:04:55.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.943]                     .init = FALSE)
[18:04:55.943]                 }
[18:04:55.943]             }
[18:04:55.943]         }
[18:04:55.943]     })
[18:04:55.943]     if (TRUE) {
[18:04:55.943]         base::sink(type = "output", split = FALSE)
[18:04:55.943]         if (TRUE) {
[18:04:55.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.943]         }
[18:04:55.943]         else {
[18:04:55.943]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.943]         }
[18:04:55.943]         base::close(...future.stdout)
[18:04:55.943]         ...future.stdout <- NULL
[18:04:55.943]     }
[18:04:55.943]     ...future.result$conditions <- ...future.conditions
[18:04:55.943]     ...future.result$finished <- base::Sys.time()
[18:04:55.943]     ...future.result
[18:04:55.943] }
[18:04:55.946] plan(): Setting new future strategy stack:
[18:04:55.946] List of future strategies:
[18:04:55.946] 1. sequential:
[18:04:55.946]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.946]    - tweaked: FALSE
[18:04:55.946]    - call: NULL
[18:04:55.947] plan(): nbrOfWorkers() = 1
[18:04:55.949] plan(): Setting new future strategy stack:
[18:04:55.949] List of future strategies:
[18:04:55.949] 1. sequential:
[18:04:55.949]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.949]    - tweaked: FALSE
[18:04:55.949]    - call: plan(strategy)
[18:04:55.950] plan(): nbrOfWorkers() = 1
[18:04:55.950] SequentialFuture started (and completed)
[18:04:55.951] - Launch lazy future ... done
[18:04:55.951] run() for ‘SequentialFuture’ ... done
[18:04:55.951] resolved() for ‘SequentialFuture’ ...
[18:04:55.951] - state: ‘finished’
[18:04:55.951] - run: TRUE
[18:04:55.952] - result: ‘FutureResult’
[18:04:55.952] resolved() for ‘SequentialFuture’ ... done
[18:04:55.952] Future #1
[18:04:55.952] resolved() for ‘SequentialFuture’ ...
[18:04:55.953] - state: ‘finished’
[18:04:55.953] - run: TRUE
[18:04:55.953] - result: ‘FutureResult’
[18:04:55.953] resolved() for ‘SequentialFuture’ ... done
[18:04:55.953] A SequentialFuture was resolved
[18:04:55.954]  length: 0 (resolved future 1)
[18:04:55.954] resolve() on list ... DONE
[18:04:55.954] - globals: [1] ‘a’
[18:04:55.954] Resolving futures part of globals (recursively) ... DONE
[18:04:55.958] The total size of the 1 globals is 1.55 MiB (1624904 bytes)
[18:04:55.959] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[18:04:55.959] - globals: [1] ‘a’
[18:04:55.959] - packages: [1] ‘future’
[18:04:55.959] getGlobalsAndPackages() ... DONE
[18:04:55.960] run() for ‘Future’ ...
[18:04:55.960] - state: ‘created’
[18:04:55.960] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.961] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.961] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.961]   - Field: ‘label’
[18:04:55.962]   - Field: ‘local’
[18:04:55.962]   - Field: ‘owner’
[18:04:55.962]   - Field: ‘envir’
[18:04:55.962]   - Field: ‘packages’
[18:04:55.962]   - Field: ‘gc’
[18:04:55.963]   - Field: ‘conditions’
[18:04:55.963]   - Field: ‘expr’
[18:04:55.963]   - Field: ‘uuid’
[18:04:55.963]   - Field: ‘seed’
[18:04:55.963]   - Field: ‘version’
[18:04:55.964]   - Field: ‘result’
[18:04:55.964]   - Field: ‘asynchronous’
[18:04:55.964]   - Field: ‘calls’
[18:04:55.964]   - Field: ‘globals’
[18:04:55.964]   - Field: ‘stdout’
[18:04:55.964]   - Field: ‘earlySignal’
[18:04:55.965]   - Field: ‘lazy’
[18:04:55.965]   - Field: ‘state’
[18:04:55.965] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.965] - Launch lazy future ...
[18:04:55.966] Packages needed by the future expression (n = 1): ‘future’
[18:04:55.966] Packages needed by future strategies (n = 0): <none>
[18:04:55.967] {
[18:04:55.967]     {
[18:04:55.967]         {
[18:04:55.967]             ...future.startTime <- base::Sys.time()
[18:04:55.967]             {
[18:04:55.967]                 {
[18:04:55.967]                   {
[18:04:55.967]                     {
[18:04:55.967]                       base::local({
[18:04:55.967]                         has_future <- base::requireNamespace("future", 
[18:04:55.967]                           quietly = TRUE)
[18:04:55.967]                         if (has_future) {
[18:04:55.967]                           ns <- base::getNamespace("future")
[18:04:55.967]                           version <- ns[[".package"]][["version"]]
[18:04:55.967]                           if (is.null(version)) 
[18:04:55.967]                             version <- utils::packageVersion("future")
[18:04:55.967]                         }
[18:04:55.967]                         else {
[18:04:55.967]                           version <- NULL
[18:04:55.967]                         }
[18:04:55.967]                         if (!has_future || version < "1.8.0") {
[18:04:55.967]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.967]                             "", base::R.version$version.string), 
[18:04:55.967]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:55.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.967]                               "release", "version")], collapse = " "), 
[18:04:55.967]                             hostname = base::Sys.info()[["nodename"]])
[18:04:55.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.967]                             info)
[18:04:55.967]                           info <- base::paste(info, collapse = "; ")
[18:04:55.967]                           if (!has_future) {
[18:04:55.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.967]                               info)
[18:04:55.967]                           }
[18:04:55.967]                           else {
[18:04:55.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.967]                               info, version)
[18:04:55.967]                           }
[18:04:55.967]                           base::stop(msg)
[18:04:55.967]                         }
[18:04:55.967]                       })
[18:04:55.967]                     }
[18:04:55.967]                     base::local({
[18:04:55.967]                       for (pkg in "future") {
[18:04:55.967]                         base::loadNamespace(pkg)
[18:04:55.967]                         base::library(pkg, character.only = TRUE)
[18:04:55.967]                       }
[18:04:55.967]                     })
[18:04:55.967]                   }
[18:04:55.967]                   ...future.strategy.old <- future::plan("list")
[18:04:55.967]                   options(future.plan = NULL)
[18:04:55.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.967]                 }
[18:04:55.967]                 ...future.workdir <- getwd()
[18:04:55.967]             }
[18:04:55.967]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.967]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.967]         }
[18:04:55.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.967]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.967]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.967]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.967]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.967]             base::names(...future.oldOptions))
[18:04:55.967]     }
[18:04:55.967]     if (FALSE) {
[18:04:55.967]     }
[18:04:55.967]     else {
[18:04:55.967]         if (TRUE) {
[18:04:55.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.967]                 open = "w")
[18:04:55.967]         }
[18:04:55.967]         else {
[18:04:55.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.967]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.967]         }
[18:04:55.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.967]             base::sink(type = "output", split = FALSE)
[18:04:55.967]             base::close(...future.stdout)
[18:04:55.967]         }, add = TRUE)
[18:04:55.967]     }
[18:04:55.967]     ...future.frame <- base::sys.nframe()
[18:04:55.967]     ...future.conditions <- base::list()
[18:04:55.967]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.967]     if (FALSE) {
[18:04:55.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.967]     }
[18:04:55.967]     ...future.result <- base::tryCatch({
[18:04:55.967]         base::withCallingHandlers({
[18:04:55.967]             ...future.value <- base::withVisible(base::local(value(a) + 
[18:04:55.967]                 1))
[18:04:55.967]             future::FutureResult(value = ...future.value$value, 
[18:04:55.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.967]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.967]                     ...future.globalenv.names))
[18:04:55.967]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.967]         }, condition = base::local({
[18:04:55.967]             c <- base::c
[18:04:55.967]             inherits <- base::inherits
[18:04:55.967]             invokeRestart <- base::invokeRestart
[18:04:55.967]             length <- base::length
[18:04:55.967]             list <- base::list
[18:04:55.967]             seq.int <- base::seq.int
[18:04:55.967]             signalCondition <- base::signalCondition
[18:04:55.967]             sys.calls <- base::sys.calls
[18:04:55.967]             `[[` <- base::`[[`
[18:04:55.967]             `+` <- base::`+`
[18:04:55.967]             `<<-` <- base::`<<-`
[18:04:55.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.967]                   3L)]
[18:04:55.967]             }
[18:04:55.967]             function(cond) {
[18:04:55.967]                 is_error <- inherits(cond, "error")
[18:04:55.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.967]                   NULL)
[18:04:55.967]                 if (is_error) {
[18:04:55.967]                   sessionInformation <- function() {
[18:04:55.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.967]                       search = base::search(), system = base::Sys.info())
[18:04:55.967]                   }
[18:04:55.967]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.967]                     cond$call), session = sessionInformation(), 
[18:04:55.967]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.967]                   signalCondition(cond)
[18:04:55.967]                 }
[18:04:55.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.967]                 "immediateCondition"))) {
[18:04:55.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.967]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.967]                   if (TRUE && !signal) {
[18:04:55.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.967]                     {
[18:04:55.967]                       inherits <- base::inherits
[18:04:55.967]                       invokeRestart <- base::invokeRestart
[18:04:55.967]                       is.null <- base::is.null
[18:04:55.967]                       muffled <- FALSE
[18:04:55.967]                       if (inherits(cond, "message")) {
[18:04:55.967]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.967]                         if (muffled) 
[18:04:55.967]                           invokeRestart("muffleMessage")
[18:04:55.967]                       }
[18:04:55.967]                       else if (inherits(cond, "warning")) {
[18:04:55.967]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.967]                         if (muffled) 
[18:04:55.967]                           invokeRestart("muffleWarning")
[18:04:55.967]                       }
[18:04:55.967]                       else if (inherits(cond, "condition")) {
[18:04:55.967]                         if (!is.null(pattern)) {
[18:04:55.967]                           computeRestarts <- base::computeRestarts
[18:04:55.967]                           grepl <- base::grepl
[18:04:55.967]                           restarts <- computeRestarts(cond)
[18:04:55.967]                           for (restart in restarts) {
[18:04:55.967]                             name <- restart$name
[18:04:55.967]                             if (is.null(name)) 
[18:04:55.967]                               next
[18:04:55.967]                             if (!grepl(pattern, name)) 
[18:04:55.967]                               next
[18:04:55.967]                             invokeRestart(restart)
[18:04:55.967]                             muffled <- TRUE
[18:04:55.967]                             break
[18:04:55.967]                           }
[18:04:55.967]                         }
[18:04:55.967]                       }
[18:04:55.967]                       invisible(muffled)
[18:04:55.967]                     }
[18:04:55.967]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.967]                   }
[18:04:55.967]                 }
[18:04:55.967]                 else {
[18:04:55.967]                   if (TRUE) {
[18:04:55.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.967]                     {
[18:04:55.967]                       inherits <- base::inherits
[18:04:55.967]                       invokeRestart <- base::invokeRestart
[18:04:55.967]                       is.null <- base::is.null
[18:04:55.967]                       muffled <- FALSE
[18:04:55.967]                       if (inherits(cond, "message")) {
[18:04:55.967]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.967]                         if (muffled) 
[18:04:55.967]                           invokeRestart("muffleMessage")
[18:04:55.967]                       }
[18:04:55.967]                       else if (inherits(cond, "warning")) {
[18:04:55.967]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.967]                         if (muffled) 
[18:04:55.967]                           invokeRestart("muffleWarning")
[18:04:55.967]                       }
[18:04:55.967]                       else if (inherits(cond, "condition")) {
[18:04:55.967]                         if (!is.null(pattern)) {
[18:04:55.967]                           computeRestarts <- base::computeRestarts
[18:04:55.967]                           grepl <- base::grepl
[18:04:55.967]                           restarts <- computeRestarts(cond)
[18:04:55.967]                           for (restart in restarts) {
[18:04:55.967]                             name <- restart$name
[18:04:55.967]                             if (is.null(name)) 
[18:04:55.967]                               next
[18:04:55.967]                             if (!grepl(pattern, name)) 
[18:04:55.967]                               next
[18:04:55.967]                             invokeRestart(restart)
[18:04:55.967]                             muffled <- TRUE
[18:04:55.967]                             break
[18:04:55.967]                           }
[18:04:55.967]                         }
[18:04:55.967]                       }
[18:04:55.967]                       invisible(muffled)
[18:04:55.967]                     }
[18:04:55.967]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.967]                   }
[18:04:55.967]                 }
[18:04:55.967]             }
[18:04:55.967]         }))
[18:04:55.967]     }, error = function(ex) {
[18:04:55.967]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.967]                 ...future.rng), started = ...future.startTime, 
[18:04:55.967]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.967]             version = "1.8"), class = "FutureResult")
[18:04:55.967]     }, finally = {
[18:04:55.967]         if (!identical(...future.workdir, getwd())) 
[18:04:55.967]             setwd(...future.workdir)
[18:04:55.967]         {
[18:04:55.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.967]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.967]             }
[18:04:55.967]             base::options(...future.oldOptions)
[18:04:55.967]             if (.Platform$OS.type == "windows") {
[18:04:55.967]                 old_names <- names(...future.oldEnvVars)
[18:04:55.967]                 envs <- base::Sys.getenv()
[18:04:55.967]                 names <- names(envs)
[18:04:55.967]                 common <- intersect(names, old_names)
[18:04:55.967]                 added <- setdiff(names, old_names)
[18:04:55.967]                 removed <- setdiff(old_names, names)
[18:04:55.967]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.967]                   envs[common]]
[18:04:55.967]                 NAMES <- toupper(changed)
[18:04:55.967]                 args <- list()
[18:04:55.967]                 for (kk in seq_along(NAMES)) {
[18:04:55.967]                   name <- changed[[kk]]
[18:04:55.967]                   NAME <- NAMES[[kk]]
[18:04:55.967]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.967]                     next
[18:04:55.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.967]                 }
[18:04:55.967]                 NAMES <- toupper(added)
[18:04:55.967]                 for (kk in seq_along(NAMES)) {
[18:04:55.967]                   name <- added[[kk]]
[18:04:55.967]                   NAME <- NAMES[[kk]]
[18:04:55.967]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.967]                     next
[18:04:55.967]                   args[[name]] <- ""
[18:04:55.967]                 }
[18:04:55.967]                 NAMES <- toupper(removed)
[18:04:55.967]                 for (kk in seq_along(NAMES)) {
[18:04:55.967]                   name <- removed[[kk]]
[18:04:55.967]                   NAME <- NAMES[[kk]]
[18:04:55.967]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.967]                     next
[18:04:55.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.967]                 }
[18:04:55.967]                 if (length(args) > 0) 
[18:04:55.967]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.967]             }
[18:04:55.967]             else {
[18:04:55.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.967]             }
[18:04:55.967]             {
[18:04:55.967]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.967]                   0L) {
[18:04:55.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.967]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.967]                   base::options(opts)
[18:04:55.967]                 }
[18:04:55.967]                 {
[18:04:55.967]                   {
[18:04:55.967]                     NULL
[18:04:55.967]                     RNGkind("Mersenne-Twister")
[18:04:55.967]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.967]                       inherits = FALSE)
[18:04:55.967]                   }
[18:04:55.967]                   options(future.plan = NULL)
[18:04:55.967]                   if (is.na(NA_character_)) 
[18:04:55.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.967]                     .init = FALSE)
[18:04:55.967]                 }
[18:04:55.967]             }
[18:04:55.967]         }
[18:04:55.967]     })
[18:04:55.967]     if (TRUE) {
[18:04:55.967]         base::sink(type = "output", split = FALSE)
[18:04:55.967]         if (TRUE) {
[18:04:55.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.967]         }
[18:04:55.967]         else {
[18:04:55.967]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.967]         }
[18:04:55.967]         base::close(...future.stdout)
[18:04:55.967]         ...future.stdout <- NULL
[18:04:55.967]     }
[18:04:55.967]     ...future.result$conditions <- ...future.conditions
[18:04:55.967]     ...future.result$finished <- base::Sys.time()
[18:04:55.967]     ...future.result
[18:04:55.967] }
[18:04:55.970] assign_globals() ...
[18:04:55.970] List of 1
[18:04:55.970]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5b95772547b8> 
[18:04:55.970]  - attr(*, "where")=List of 1
[18:04:55.970]   ..$ a:<environment: R_EmptyEnv> 
[18:04:55.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:55.970]  - attr(*, "resolved")= logi TRUE
[18:04:55.970]  - attr(*, "total_size")= num 1624904
[18:04:55.970]  - attr(*, "already-done")= logi TRUE
[18:04:55.976] - copied ‘a’ to environment
[18:04:55.976] assign_globals() ... done
[18:04:55.977] plan(): Setting new future strategy stack:
[18:04:55.977] List of future strategies:
[18:04:55.977] 1. sequential:
[18:04:55.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.977]    - tweaked: FALSE
[18:04:55.977]    - call: NULL
[18:04:55.978] plan(): nbrOfWorkers() = 1
[18:04:55.979] plan(): Setting new future strategy stack:
[18:04:55.980] List of future strategies:
[18:04:55.980] 1. sequential:
[18:04:55.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:55.980]    - tweaked: FALSE
[18:04:55.980]    - call: plan(strategy)
[18:04:55.981] plan(): nbrOfWorkers() = 1
[18:04:55.981] SequentialFuture started (and completed)
[18:04:55.981] - Launch lazy future ... done
[18:04:55.982] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.983] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.983] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.984] 
[18:04:55.984] Searching for globals ... DONE
[18:04:55.984] - globals: [0] <none>
[18:04:55.985] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:55.985] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:55.986] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:55.987] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:55.988] Searching for globals ... DONE
[18:04:55.988] Resolving globals: TRUE
[18:04:55.988] Resolving any globals that are futures ...
[18:04:55.988] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:55.989] Resolving any globals that are futures ... DONE
[18:04:55.989] Resolving futures part of globals (recursively) ...
[18:04:55.990] resolve() on list ...
[18:04:55.990]  recursive: 99
[18:04:55.990]  length: 1
[18:04:55.990]  elements: ‘a’
[18:04:55.991] run() for ‘Future’ ...
[18:04:55.991] - state: ‘created’
[18:04:55.991] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:55.992] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:55.992] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:55.992]   - Field: ‘label’
[18:04:55.993]   - Field: ‘local’
[18:04:55.993]   - Field: ‘owner’
[18:04:55.993]   - Field: ‘envir’
[18:04:55.993]   - Field: ‘packages’
[18:04:55.993]   - Field: ‘gc’
[18:04:55.994]   - Field: ‘conditions’
[18:04:55.994]   - Field: ‘expr’
[18:04:55.994]   - Field: ‘uuid’
[18:04:55.994]   - Field: ‘seed’
[18:04:55.994]   - Field: ‘version’
[18:04:55.995]   - Field: ‘result’
[18:04:55.995]   - Field: ‘asynchronous’
[18:04:55.995]   - Field: ‘calls’
[18:04:55.995]   - Field: ‘globals’
[18:04:55.995]   - Field: ‘stdout’
[18:04:55.996]   - Field: ‘earlySignal’
[18:04:55.996]   - Field: ‘lazy’
[18:04:55.996]   - Field: ‘state’
[18:04:55.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:55.996] - Launch lazy future ...
[18:04:55.997] Packages needed by the future expression (n = 0): <none>
[18:04:55.997] Packages needed by future strategies (n = 0): <none>
[18:04:55.998] {
[18:04:55.998]     {
[18:04:55.998]         {
[18:04:55.998]             ...future.startTime <- base::Sys.time()
[18:04:55.998]             {
[18:04:55.998]                 {
[18:04:55.998]                   {
[18:04:55.998]                     base::local({
[18:04:55.998]                       has_future <- base::requireNamespace("future", 
[18:04:55.998]                         quietly = TRUE)
[18:04:55.998]                       if (has_future) {
[18:04:55.998]                         ns <- base::getNamespace("future")
[18:04:55.998]                         version <- ns[[".package"]][["version"]]
[18:04:55.998]                         if (is.null(version)) 
[18:04:55.998]                           version <- utils::packageVersion("future")
[18:04:55.998]                       }
[18:04:55.998]                       else {
[18:04:55.998]                         version <- NULL
[18:04:55.998]                       }
[18:04:55.998]                       if (!has_future || version < "1.8.0") {
[18:04:55.998]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:55.998]                           "", base::R.version$version.string), 
[18:04:55.998]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:55.998]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:55.998]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:55.998]                             "release", "version")], collapse = " "), 
[18:04:55.998]                           hostname = base::Sys.info()[["nodename"]])
[18:04:55.998]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:55.998]                           info)
[18:04:55.998]                         info <- base::paste(info, collapse = "; ")
[18:04:55.998]                         if (!has_future) {
[18:04:55.998]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:55.998]                             info)
[18:04:55.998]                         }
[18:04:55.998]                         else {
[18:04:55.998]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:55.998]                             info, version)
[18:04:55.998]                         }
[18:04:55.998]                         base::stop(msg)
[18:04:55.998]                       }
[18:04:55.998]                     })
[18:04:55.998]                   }
[18:04:55.998]                   ...future.strategy.old <- future::plan("list")
[18:04:55.998]                   options(future.plan = NULL)
[18:04:55.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:55.998]                 }
[18:04:55.998]                 ...future.workdir <- getwd()
[18:04:55.998]             }
[18:04:55.998]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:55.998]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:55.998]         }
[18:04:55.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:55.998]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:55.998]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:55.998]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:55.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:55.998]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:55.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:55.998]             base::names(...future.oldOptions))
[18:04:55.998]     }
[18:04:55.998]     if (FALSE) {
[18:04:55.998]     }
[18:04:55.998]     else {
[18:04:55.998]         if (TRUE) {
[18:04:55.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:55.998]                 open = "w")
[18:04:55.998]         }
[18:04:55.998]         else {
[18:04:55.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:55.998]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:55.998]         }
[18:04:55.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:55.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:55.998]             base::sink(type = "output", split = FALSE)
[18:04:55.998]             base::close(...future.stdout)
[18:04:55.998]         }, add = TRUE)
[18:04:55.998]     }
[18:04:55.998]     ...future.frame <- base::sys.nframe()
[18:04:55.998]     ...future.conditions <- base::list()
[18:04:55.998]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:55.998]     if (FALSE) {
[18:04:55.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:55.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:55.998]     }
[18:04:55.998]     ...future.result <- base::tryCatch({
[18:04:55.998]         base::withCallingHandlers({
[18:04:55.998]             ...future.value <- base::withVisible(base::local(1))
[18:04:55.998]             future::FutureResult(value = ...future.value$value, 
[18:04:55.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.998]                   ...future.rng), globalenv = if (FALSE) 
[18:04:55.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:55.998]                     ...future.globalenv.names))
[18:04:55.998]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:55.998]         }, condition = base::local({
[18:04:55.998]             c <- base::c
[18:04:55.998]             inherits <- base::inherits
[18:04:55.998]             invokeRestart <- base::invokeRestart
[18:04:55.998]             length <- base::length
[18:04:55.998]             list <- base::list
[18:04:55.998]             seq.int <- base::seq.int
[18:04:55.998]             signalCondition <- base::signalCondition
[18:04:55.998]             sys.calls <- base::sys.calls
[18:04:55.998]             `[[` <- base::`[[`
[18:04:55.998]             `+` <- base::`+`
[18:04:55.998]             `<<-` <- base::`<<-`
[18:04:55.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:55.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:55.998]                   3L)]
[18:04:55.998]             }
[18:04:55.998]             function(cond) {
[18:04:55.998]                 is_error <- inherits(cond, "error")
[18:04:55.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:55.998]                   NULL)
[18:04:55.998]                 if (is_error) {
[18:04:55.998]                   sessionInformation <- function() {
[18:04:55.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:55.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:55.998]                       search = base::search(), system = base::Sys.info())
[18:04:55.998]                   }
[18:04:55.998]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:55.998]                     cond$call), session = sessionInformation(), 
[18:04:55.998]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:55.998]                   signalCondition(cond)
[18:04:55.998]                 }
[18:04:55.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:55.998]                 "immediateCondition"))) {
[18:04:55.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:55.998]                   ...future.conditions[[length(...future.conditions) + 
[18:04:55.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:55.998]                   if (TRUE && !signal) {
[18:04:55.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.998]                     {
[18:04:55.998]                       inherits <- base::inherits
[18:04:55.998]                       invokeRestart <- base::invokeRestart
[18:04:55.998]                       is.null <- base::is.null
[18:04:55.998]                       muffled <- FALSE
[18:04:55.998]                       if (inherits(cond, "message")) {
[18:04:55.998]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.998]                         if (muffled) 
[18:04:55.998]                           invokeRestart("muffleMessage")
[18:04:55.998]                       }
[18:04:55.998]                       else if (inherits(cond, "warning")) {
[18:04:55.998]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.998]                         if (muffled) 
[18:04:55.998]                           invokeRestart("muffleWarning")
[18:04:55.998]                       }
[18:04:55.998]                       else if (inherits(cond, "condition")) {
[18:04:55.998]                         if (!is.null(pattern)) {
[18:04:55.998]                           computeRestarts <- base::computeRestarts
[18:04:55.998]                           grepl <- base::grepl
[18:04:55.998]                           restarts <- computeRestarts(cond)
[18:04:55.998]                           for (restart in restarts) {
[18:04:55.998]                             name <- restart$name
[18:04:55.998]                             if (is.null(name)) 
[18:04:55.998]                               next
[18:04:55.998]                             if (!grepl(pattern, name)) 
[18:04:55.998]                               next
[18:04:55.998]                             invokeRestart(restart)
[18:04:55.998]                             muffled <- TRUE
[18:04:55.998]                             break
[18:04:55.998]                           }
[18:04:55.998]                         }
[18:04:55.998]                       }
[18:04:55.998]                       invisible(muffled)
[18:04:55.998]                     }
[18:04:55.998]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.998]                   }
[18:04:55.998]                 }
[18:04:55.998]                 else {
[18:04:55.998]                   if (TRUE) {
[18:04:55.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:55.998]                     {
[18:04:55.998]                       inherits <- base::inherits
[18:04:55.998]                       invokeRestart <- base::invokeRestart
[18:04:55.998]                       is.null <- base::is.null
[18:04:55.998]                       muffled <- FALSE
[18:04:55.998]                       if (inherits(cond, "message")) {
[18:04:55.998]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:55.998]                         if (muffled) 
[18:04:55.998]                           invokeRestart("muffleMessage")
[18:04:55.998]                       }
[18:04:55.998]                       else if (inherits(cond, "warning")) {
[18:04:55.998]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:55.998]                         if (muffled) 
[18:04:55.998]                           invokeRestart("muffleWarning")
[18:04:55.998]                       }
[18:04:55.998]                       else if (inherits(cond, "condition")) {
[18:04:55.998]                         if (!is.null(pattern)) {
[18:04:55.998]                           computeRestarts <- base::computeRestarts
[18:04:55.998]                           grepl <- base::grepl
[18:04:55.998]                           restarts <- computeRestarts(cond)
[18:04:55.998]                           for (restart in restarts) {
[18:04:55.998]                             name <- restart$name
[18:04:55.998]                             if (is.null(name)) 
[18:04:55.998]                               next
[18:04:55.998]                             if (!grepl(pattern, name)) 
[18:04:55.998]                               next
[18:04:55.998]                             invokeRestart(restart)
[18:04:55.998]                             muffled <- TRUE
[18:04:55.998]                             break
[18:04:55.998]                           }
[18:04:55.998]                         }
[18:04:55.998]                       }
[18:04:55.998]                       invisible(muffled)
[18:04:55.998]                     }
[18:04:55.998]                     muffleCondition(cond, pattern = "^muffle")
[18:04:55.998]                   }
[18:04:55.998]                 }
[18:04:55.998]             }
[18:04:55.998]         }))
[18:04:55.998]     }, error = function(ex) {
[18:04:55.998]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:55.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:55.998]                 ...future.rng), started = ...future.startTime, 
[18:04:55.998]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:55.998]             version = "1.8"), class = "FutureResult")
[18:04:55.998]     }, finally = {
[18:04:55.998]         if (!identical(...future.workdir, getwd())) 
[18:04:55.998]             setwd(...future.workdir)
[18:04:55.998]         {
[18:04:55.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:55.998]                 ...future.oldOptions$nwarnings <- NULL
[18:04:55.998]             }
[18:04:55.998]             base::options(...future.oldOptions)
[18:04:55.998]             if (.Platform$OS.type == "windows") {
[18:04:55.998]                 old_names <- names(...future.oldEnvVars)
[18:04:55.998]                 envs <- base::Sys.getenv()
[18:04:55.998]                 names <- names(envs)
[18:04:55.998]                 common <- intersect(names, old_names)
[18:04:55.998]                 added <- setdiff(names, old_names)
[18:04:55.998]                 removed <- setdiff(old_names, names)
[18:04:55.998]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:55.998]                   envs[common]]
[18:04:55.998]                 NAMES <- toupper(changed)
[18:04:55.998]                 args <- list()
[18:04:55.998]                 for (kk in seq_along(NAMES)) {
[18:04:55.998]                   name <- changed[[kk]]
[18:04:55.998]                   NAME <- NAMES[[kk]]
[18:04:55.998]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.998]                     next
[18:04:55.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.998]                 }
[18:04:55.998]                 NAMES <- toupper(added)
[18:04:55.998]                 for (kk in seq_along(NAMES)) {
[18:04:55.998]                   name <- added[[kk]]
[18:04:55.998]                   NAME <- NAMES[[kk]]
[18:04:55.998]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.998]                     next
[18:04:55.998]                   args[[name]] <- ""
[18:04:55.998]                 }
[18:04:55.998]                 NAMES <- toupper(removed)
[18:04:55.998]                 for (kk in seq_along(NAMES)) {
[18:04:55.998]                   name <- removed[[kk]]
[18:04:55.998]                   NAME <- NAMES[[kk]]
[18:04:55.998]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:55.998]                     next
[18:04:55.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:55.998]                 }
[18:04:55.998]                 if (length(args) > 0) 
[18:04:55.998]                   base::do.call(base::Sys.setenv, args = args)
[18:04:55.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:55.998]             }
[18:04:55.998]             else {
[18:04:55.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:55.998]             }
[18:04:55.998]             {
[18:04:55.998]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:55.998]                   0L) {
[18:04:55.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:55.998]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:55.998]                   base::options(opts)
[18:04:55.998]                 }
[18:04:55.998]                 {
[18:04:55.998]                   {
[18:04:55.998]                     NULL
[18:04:55.998]                     RNGkind("Mersenne-Twister")
[18:04:55.998]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:55.998]                       inherits = FALSE)
[18:04:55.998]                   }
[18:04:55.998]                   options(future.plan = NULL)
[18:04:55.998]                   if (is.na(NA_character_)) 
[18:04:55.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:55.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:55.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:55.998]                     .init = FALSE)
[18:04:55.998]                 }
[18:04:55.998]             }
[18:04:55.998]         }
[18:04:55.998]     })
[18:04:55.998]     if (TRUE) {
[18:04:55.998]         base::sink(type = "output", split = FALSE)
[18:04:55.998]         if (TRUE) {
[18:04:55.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:55.998]         }
[18:04:55.998]         else {
[18:04:55.998]             ...future.result["stdout"] <- base::list(NULL)
[18:04:55.998]         }
[18:04:55.998]         base::close(...future.stdout)
[18:04:55.998]         ...future.stdout <- NULL
[18:04:55.998]     }
[18:04:55.998]     ...future.result$conditions <- ...future.conditions
[18:04:55.998]     ...future.result$finished <- base::Sys.time()
[18:04:55.998]     ...future.result
[18:04:55.998] }
[18:04:56.001] plan(): Setting new future strategy stack:
[18:04:56.002] List of future strategies:
[18:04:56.002] 1. sequential:
[18:04:56.002]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.002]    - tweaked: FALSE
[18:04:56.002]    - call: NULL
[18:04:56.003] plan(): nbrOfWorkers() = 1
[18:04:56.004] plan(): Setting new future strategy stack:
[18:04:56.004] List of future strategies:
[18:04:56.004] 1. sequential:
[18:04:56.004]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.004]    - tweaked: FALSE
[18:04:56.004]    - call: plan(strategy)
[18:04:56.005] plan(): nbrOfWorkers() = 1
[18:04:56.006] SequentialFuture started (and completed)
[18:04:56.006] - Launch lazy future ... done
[18:04:56.006] run() for ‘SequentialFuture’ ... done
[18:04:56.006] resolved() for ‘SequentialFuture’ ...
[18:04:56.007] - state: ‘finished’
[18:04:56.007] - run: TRUE
[18:04:56.007] - result: ‘FutureResult’
[18:04:56.007] resolved() for ‘SequentialFuture’ ... done
[18:04:56.007] Future #1
[18:04:56.008] resolved() for ‘SequentialFuture’ ...
[18:04:56.010] - state: ‘finished’
[18:04:56.010] - run: TRUE
[18:04:56.011] - result: ‘FutureResult’
[18:04:56.011] resolved() for ‘SequentialFuture’ ... done
[18:04:56.011] A SequentialFuture was resolved
[18:04:56.011]  length: 0 (resolved future 1)
[18:04:56.012] resolve() on list ... DONE
[18:04:56.012] - globals: [1] ‘a’
[18:04:56.012] Resolving futures part of globals (recursively) ... DONE
[18:04:56.016] The total size of the 1 globals is 1.55 MiB (1624904 bytes)
[18:04:56.017] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[18:04:56.017] - globals: [1] ‘a’
[18:04:56.017] - packages: [1] ‘future’
[18:04:56.018] getGlobalsAndPackages() ... DONE
[18:04:56.018] run() for ‘Future’ ...
[18:04:56.018] - state: ‘created’
[18:04:56.019] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:56.019] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:56.019] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:56.020]   - Field: ‘label’
[18:04:56.020]   - Field: ‘local’
[18:04:56.020]   - Field: ‘owner’
[18:04:56.020]   - Field: ‘envir’
[18:04:56.020]   - Field: ‘packages’
[18:04:56.021]   - Field: ‘gc’
[18:04:56.021]   - Field: ‘conditions’
[18:04:56.021]   - Field: ‘expr’
[18:04:56.021]   - Field: ‘uuid’
[18:04:56.021]   - Field: ‘seed’
[18:04:56.022]   - Field: ‘version’
[18:04:56.022]   - Field: ‘result’
[18:04:56.022]   - Field: ‘asynchronous’
[18:04:56.022]   - Field: ‘calls’
[18:04:56.022]   - Field: ‘globals’
[18:04:56.023]   - Field: ‘stdout’
[18:04:56.023]   - Field: ‘earlySignal’
[18:04:56.023]   - Field: ‘lazy’
[18:04:56.023]   - Field: ‘state’
[18:04:56.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:56.023] - Launch lazy future ...
[18:04:56.024] Packages needed by the future expression (n = 1): ‘future’
[18:04:56.024] Packages needed by future strategies (n = 0): <none>
[18:04:56.025] {
[18:04:56.025]     {
[18:04:56.025]         {
[18:04:56.025]             ...future.startTime <- base::Sys.time()
[18:04:56.025]             {
[18:04:56.025]                 {
[18:04:56.025]                   {
[18:04:56.025]                     {
[18:04:56.025]                       base::local({
[18:04:56.025]                         has_future <- base::requireNamespace("future", 
[18:04:56.025]                           quietly = TRUE)
[18:04:56.025]                         if (has_future) {
[18:04:56.025]                           ns <- base::getNamespace("future")
[18:04:56.025]                           version <- ns[[".package"]][["version"]]
[18:04:56.025]                           if (is.null(version)) 
[18:04:56.025]                             version <- utils::packageVersion("future")
[18:04:56.025]                         }
[18:04:56.025]                         else {
[18:04:56.025]                           version <- NULL
[18:04:56.025]                         }
[18:04:56.025]                         if (!has_future || version < "1.8.0") {
[18:04:56.025]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.025]                             "", base::R.version$version.string), 
[18:04:56.025]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:56.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.025]                               "release", "version")], collapse = " "), 
[18:04:56.025]                             hostname = base::Sys.info()[["nodename"]])
[18:04:56.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.025]                             info)
[18:04:56.025]                           info <- base::paste(info, collapse = "; ")
[18:04:56.025]                           if (!has_future) {
[18:04:56.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.025]                               info)
[18:04:56.025]                           }
[18:04:56.025]                           else {
[18:04:56.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.025]                               info, version)
[18:04:56.025]                           }
[18:04:56.025]                           base::stop(msg)
[18:04:56.025]                         }
[18:04:56.025]                       })
[18:04:56.025]                     }
[18:04:56.025]                     base::local({
[18:04:56.025]                       for (pkg in "future") {
[18:04:56.025]                         base::loadNamespace(pkg)
[18:04:56.025]                         base::library(pkg, character.only = TRUE)
[18:04:56.025]                       }
[18:04:56.025]                     })
[18:04:56.025]                   }
[18:04:56.025]                   ...future.strategy.old <- future::plan("list")
[18:04:56.025]                   options(future.plan = NULL)
[18:04:56.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.025]                 }
[18:04:56.025]                 ...future.workdir <- getwd()
[18:04:56.025]             }
[18:04:56.025]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.025]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.025]         }
[18:04:56.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.025]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:56.025]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.025]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.025]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.025]             base::names(...future.oldOptions))
[18:04:56.025]     }
[18:04:56.025]     if (FALSE) {
[18:04:56.025]     }
[18:04:56.025]     else {
[18:04:56.025]         if (TRUE) {
[18:04:56.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.025]                 open = "w")
[18:04:56.025]         }
[18:04:56.025]         else {
[18:04:56.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.025]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.025]         }
[18:04:56.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.025]             base::sink(type = "output", split = FALSE)
[18:04:56.025]             base::close(...future.stdout)
[18:04:56.025]         }, add = TRUE)
[18:04:56.025]     }
[18:04:56.025]     ...future.frame <- base::sys.nframe()
[18:04:56.025]     ...future.conditions <- base::list()
[18:04:56.025]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.025]     if (FALSE) {
[18:04:56.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.025]     }
[18:04:56.025]     ...future.result <- base::tryCatch({
[18:04:56.025]         base::withCallingHandlers({
[18:04:56.025]             ...future.value <- base::withVisible(base::local(value(a) + 
[18:04:56.025]                 1))
[18:04:56.025]             future::FutureResult(value = ...future.value$value, 
[18:04:56.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.025]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.025]                     ...future.globalenv.names))
[18:04:56.025]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.025]         }, condition = base::local({
[18:04:56.025]             c <- base::c
[18:04:56.025]             inherits <- base::inherits
[18:04:56.025]             invokeRestart <- base::invokeRestart
[18:04:56.025]             length <- base::length
[18:04:56.025]             list <- base::list
[18:04:56.025]             seq.int <- base::seq.int
[18:04:56.025]             signalCondition <- base::signalCondition
[18:04:56.025]             sys.calls <- base::sys.calls
[18:04:56.025]             `[[` <- base::`[[`
[18:04:56.025]             `+` <- base::`+`
[18:04:56.025]             `<<-` <- base::`<<-`
[18:04:56.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.025]                   3L)]
[18:04:56.025]             }
[18:04:56.025]             function(cond) {
[18:04:56.025]                 is_error <- inherits(cond, "error")
[18:04:56.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.025]                   NULL)
[18:04:56.025]                 if (is_error) {
[18:04:56.025]                   sessionInformation <- function() {
[18:04:56.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.025]                       search = base::search(), system = base::Sys.info())
[18:04:56.025]                   }
[18:04:56.025]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.025]                     cond$call), session = sessionInformation(), 
[18:04:56.025]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.025]                   signalCondition(cond)
[18:04:56.025]                 }
[18:04:56.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.025]                 "immediateCondition"))) {
[18:04:56.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.025]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.025]                   if (TRUE && !signal) {
[18:04:56.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.025]                     {
[18:04:56.025]                       inherits <- base::inherits
[18:04:56.025]                       invokeRestart <- base::invokeRestart
[18:04:56.025]                       is.null <- base::is.null
[18:04:56.025]                       muffled <- FALSE
[18:04:56.025]                       if (inherits(cond, "message")) {
[18:04:56.025]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.025]                         if (muffled) 
[18:04:56.025]                           invokeRestart("muffleMessage")
[18:04:56.025]                       }
[18:04:56.025]                       else if (inherits(cond, "warning")) {
[18:04:56.025]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.025]                         if (muffled) 
[18:04:56.025]                           invokeRestart("muffleWarning")
[18:04:56.025]                       }
[18:04:56.025]                       else if (inherits(cond, "condition")) {
[18:04:56.025]                         if (!is.null(pattern)) {
[18:04:56.025]                           computeRestarts <- base::computeRestarts
[18:04:56.025]                           grepl <- base::grepl
[18:04:56.025]                           restarts <- computeRestarts(cond)
[18:04:56.025]                           for (restart in restarts) {
[18:04:56.025]                             name <- restart$name
[18:04:56.025]                             if (is.null(name)) 
[18:04:56.025]                               next
[18:04:56.025]                             if (!grepl(pattern, name)) 
[18:04:56.025]                               next
[18:04:56.025]                             invokeRestart(restart)
[18:04:56.025]                             muffled <- TRUE
[18:04:56.025]                             break
[18:04:56.025]                           }
[18:04:56.025]                         }
[18:04:56.025]                       }
[18:04:56.025]                       invisible(muffled)
[18:04:56.025]                     }
[18:04:56.025]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.025]                   }
[18:04:56.025]                 }
[18:04:56.025]                 else {
[18:04:56.025]                   if (TRUE) {
[18:04:56.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.025]                     {
[18:04:56.025]                       inherits <- base::inherits
[18:04:56.025]                       invokeRestart <- base::invokeRestart
[18:04:56.025]                       is.null <- base::is.null
[18:04:56.025]                       muffled <- FALSE
[18:04:56.025]                       if (inherits(cond, "message")) {
[18:04:56.025]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.025]                         if (muffled) 
[18:04:56.025]                           invokeRestart("muffleMessage")
[18:04:56.025]                       }
[18:04:56.025]                       else if (inherits(cond, "warning")) {
[18:04:56.025]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.025]                         if (muffled) 
[18:04:56.025]                           invokeRestart("muffleWarning")
[18:04:56.025]                       }
[18:04:56.025]                       else if (inherits(cond, "condition")) {
[18:04:56.025]                         if (!is.null(pattern)) {
[18:04:56.025]                           computeRestarts <- base::computeRestarts
[18:04:56.025]                           grepl <- base::grepl
[18:04:56.025]                           restarts <- computeRestarts(cond)
[18:04:56.025]                           for (restart in restarts) {
[18:04:56.025]                             name <- restart$name
[18:04:56.025]                             if (is.null(name)) 
[18:04:56.025]                               next
[18:04:56.025]                             if (!grepl(pattern, name)) 
[18:04:56.025]                               next
[18:04:56.025]                             invokeRestart(restart)
[18:04:56.025]                             muffled <- TRUE
[18:04:56.025]                             break
[18:04:56.025]                           }
[18:04:56.025]                         }
[18:04:56.025]                       }
[18:04:56.025]                       invisible(muffled)
[18:04:56.025]                     }
[18:04:56.025]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.025]                   }
[18:04:56.025]                 }
[18:04:56.025]             }
[18:04:56.025]         }))
[18:04:56.025]     }, error = function(ex) {
[18:04:56.025]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.025]                 ...future.rng), started = ...future.startTime, 
[18:04:56.025]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.025]             version = "1.8"), class = "FutureResult")
[18:04:56.025]     }, finally = {
[18:04:56.025]         if (!identical(...future.workdir, getwd())) 
[18:04:56.025]             setwd(...future.workdir)
[18:04:56.025]         {
[18:04:56.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.025]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.025]             }
[18:04:56.025]             base::options(...future.oldOptions)
[18:04:56.025]             if (.Platform$OS.type == "windows") {
[18:04:56.025]                 old_names <- names(...future.oldEnvVars)
[18:04:56.025]                 envs <- base::Sys.getenv()
[18:04:56.025]                 names <- names(envs)
[18:04:56.025]                 common <- intersect(names, old_names)
[18:04:56.025]                 added <- setdiff(names, old_names)
[18:04:56.025]                 removed <- setdiff(old_names, names)
[18:04:56.025]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.025]                   envs[common]]
[18:04:56.025]                 NAMES <- toupper(changed)
[18:04:56.025]                 args <- list()
[18:04:56.025]                 for (kk in seq_along(NAMES)) {
[18:04:56.025]                   name <- changed[[kk]]
[18:04:56.025]                   NAME <- NAMES[[kk]]
[18:04:56.025]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.025]                     next
[18:04:56.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.025]                 }
[18:04:56.025]                 NAMES <- toupper(added)
[18:04:56.025]                 for (kk in seq_along(NAMES)) {
[18:04:56.025]                   name <- added[[kk]]
[18:04:56.025]                   NAME <- NAMES[[kk]]
[18:04:56.025]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.025]                     next
[18:04:56.025]                   args[[name]] <- ""
[18:04:56.025]                 }
[18:04:56.025]                 NAMES <- toupper(removed)
[18:04:56.025]                 for (kk in seq_along(NAMES)) {
[18:04:56.025]                   name <- removed[[kk]]
[18:04:56.025]                   NAME <- NAMES[[kk]]
[18:04:56.025]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.025]                     next
[18:04:56.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.025]                 }
[18:04:56.025]                 if (length(args) > 0) 
[18:04:56.025]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.025]             }
[18:04:56.025]             else {
[18:04:56.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.025]             }
[18:04:56.025]             {
[18:04:56.025]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.025]                   0L) {
[18:04:56.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.025]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.025]                   base::options(opts)
[18:04:56.025]                 }
[18:04:56.025]                 {
[18:04:56.025]                   {
[18:04:56.025]                     NULL
[18:04:56.025]                     RNGkind("Mersenne-Twister")
[18:04:56.025]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:56.025]                       inherits = FALSE)
[18:04:56.025]                   }
[18:04:56.025]                   options(future.plan = NULL)
[18:04:56.025]                   if (is.na(NA_character_)) 
[18:04:56.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.025]                     .init = FALSE)
[18:04:56.025]                 }
[18:04:56.025]             }
[18:04:56.025]         }
[18:04:56.025]     })
[18:04:56.025]     if (TRUE) {
[18:04:56.025]         base::sink(type = "output", split = FALSE)
[18:04:56.025]         if (TRUE) {
[18:04:56.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.025]         }
[18:04:56.025]         else {
[18:04:56.025]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.025]         }
[18:04:56.025]         base::close(...future.stdout)
[18:04:56.025]         ...future.stdout <- NULL
[18:04:56.025]     }
[18:04:56.025]     ...future.result$conditions <- ...future.conditions
[18:04:56.025]     ...future.result$finished <- base::Sys.time()
[18:04:56.025]     ...future.result
[18:04:56.025] }
[18:04:56.028] assign_globals() ...
[18:04:56.029] List of 1
[18:04:56.029]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5b95770f02d0> 
[18:04:56.029]  - attr(*, "where")=List of 1
[18:04:56.029]   ..$ a:<environment: R_EmptyEnv> 
[18:04:56.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:56.029]  - attr(*, "resolved")= logi TRUE
[18:04:56.029]  - attr(*, "total_size")= num 1624904
[18:04:56.029]  - attr(*, "already-done")= logi TRUE
[18:04:56.033] - copied ‘a’ to environment
[18:04:56.034] assign_globals() ... done
[18:04:56.034] plan(): Setting new future strategy stack:
[18:04:56.035] List of future strategies:
[18:04:56.035] 1. sequential:
[18:04:56.035]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.035]    - tweaked: FALSE
[18:04:56.035]    - call: NULL
[18:04:56.036] plan(): nbrOfWorkers() = 1
[18:04:56.037] plan(): Setting new future strategy stack:
[18:04:56.037] List of future strategies:
[18:04:56.037] 1. sequential:
[18:04:56.037]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.037]    - tweaked: FALSE
[18:04:56.037]    - call: plan(strategy)
[18:04:56.038] plan(): nbrOfWorkers() = 1
[18:04:56.039] SequentialFuture started (and completed)
[18:04:56.039] - Launch lazy future ... done
[18:04:56.039] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.040] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.041] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:56.042] - globals found: [2] ‘{’, ‘pkg’
[18:04:56.042] Searching for globals ... DONE
[18:04:56.043] Resolving globals: TRUE
[18:04:56.043] Resolving any globals that are futures ...
[18:04:56.043] - globals: [2] ‘{’, ‘pkg’
[18:04:56.043] Resolving any globals that are futures ... DONE
[18:04:56.044] Resolving futures part of globals (recursively) ...
[18:04:56.044] resolve() on list ...
[18:04:56.044]  recursive: 99
[18:04:56.045]  length: 1
[18:04:56.045]  elements: ‘pkg’
[18:04:56.045]  length: 0 (resolved future 1)
[18:04:56.045] resolve() on list ... DONE
[18:04:56.045] - globals: [1] ‘pkg’
[18:04:56.046] Resolving futures part of globals (recursively) ... DONE
[18:04:56.046] The total size of the 1 globals is 112 bytes (112 bytes)
[18:04:56.047] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[18:04:56.047] - globals: [1] ‘pkg’
[18:04:56.047] 
[18:04:56.047] getGlobalsAndPackages() ... DONE
[18:04:56.048] Packages needed by the future expression (n = 0): <none>
[18:04:56.048] Packages needed by future strategies (n = 0): <none>
[18:04:56.049] {
[18:04:56.049]     {
[18:04:56.049]         {
[18:04:56.049]             ...future.startTime <- base::Sys.time()
[18:04:56.049]             {
[18:04:56.049]                 {
[18:04:56.049]                   {
[18:04:56.049]                     base::local({
[18:04:56.049]                       has_future <- base::requireNamespace("future", 
[18:04:56.049]                         quietly = TRUE)
[18:04:56.049]                       if (has_future) {
[18:04:56.049]                         ns <- base::getNamespace("future")
[18:04:56.049]                         version <- ns[[".package"]][["version"]]
[18:04:56.049]                         if (is.null(version)) 
[18:04:56.049]                           version <- utils::packageVersion("future")
[18:04:56.049]                       }
[18:04:56.049]                       else {
[18:04:56.049]                         version <- NULL
[18:04:56.049]                       }
[18:04:56.049]                       if (!has_future || version < "1.8.0") {
[18:04:56.049]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.049]                           "", base::R.version$version.string), 
[18:04:56.049]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:56.049]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.049]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.049]                             "release", "version")], collapse = " "), 
[18:04:56.049]                           hostname = base::Sys.info()[["nodename"]])
[18:04:56.049]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.049]                           info)
[18:04:56.049]                         info <- base::paste(info, collapse = "; ")
[18:04:56.049]                         if (!has_future) {
[18:04:56.049]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.049]                             info)
[18:04:56.049]                         }
[18:04:56.049]                         else {
[18:04:56.049]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.049]                             info, version)
[18:04:56.049]                         }
[18:04:56.049]                         base::stop(msg)
[18:04:56.049]                       }
[18:04:56.049]                     })
[18:04:56.049]                   }
[18:04:56.049]                   ...future.strategy.old <- future::plan("list")
[18:04:56.049]                   options(future.plan = NULL)
[18:04:56.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.049]                 }
[18:04:56.049]                 ...future.workdir <- getwd()
[18:04:56.049]             }
[18:04:56.049]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.049]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.049]         }
[18:04:56.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.049]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:56.049]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.049]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.049]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.049]             base::names(...future.oldOptions))
[18:04:56.049]     }
[18:04:56.049]     if (FALSE) {
[18:04:56.049]     }
[18:04:56.049]     else {
[18:04:56.049]         if (TRUE) {
[18:04:56.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.049]                 open = "w")
[18:04:56.049]         }
[18:04:56.049]         else {
[18:04:56.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.049]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.049]         }
[18:04:56.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.049]             base::sink(type = "output", split = FALSE)
[18:04:56.049]             base::close(...future.stdout)
[18:04:56.049]         }, add = TRUE)
[18:04:56.049]     }
[18:04:56.049]     ...future.frame <- base::sys.nframe()
[18:04:56.049]     ...future.conditions <- base::list()
[18:04:56.049]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.049]     if (FALSE) {
[18:04:56.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.049]     }
[18:04:56.049]     ...future.result <- base::tryCatch({
[18:04:56.049]         base::withCallingHandlers({
[18:04:56.049]             ...future.value <- base::withVisible(base::local({
[18:04:56.049]                 pkg
[18:04:56.049]             }))
[18:04:56.049]             future::FutureResult(value = ...future.value$value, 
[18:04:56.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.049]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.049]                     ...future.globalenv.names))
[18:04:56.049]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.049]         }, condition = base::local({
[18:04:56.049]             c <- base::c
[18:04:56.049]             inherits <- base::inherits
[18:04:56.049]             invokeRestart <- base::invokeRestart
[18:04:56.049]             length <- base::length
[18:04:56.049]             list <- base::list
[18:04:56.049]             seq.int <- base::seq.int
[18:04:56.049]             signalCondition <- base::signalCondition
[18:04:56.049]             sys.calls <- base::sys.calls
[18:04:56.049]             `[[` <- base::`[[`
[18:04:56.049]             `+` <- base::`+`
[18:04:56.049]             `<<-` <- base::`<<-`
[18:04:56.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.049]                   3L)]
[18:04:56.049]             }
[18:04:56.049]             function(cond) {
[18:04:56.049]                 is_error <- inherits(cond, "error")
[18:04:56.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.049]                   NULL)
[18:04:56.049]                 if (is_error) {
[18:04:56.049]                   sessionInformation <- function() {
[18:04:56.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.049]                       search = base::search(), system = base::Sys.info())
[18:04:56.049]                   }
[18:04:56.049]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.049]                     cond$call), session = sessionInformation(), 
[18:04:56.049]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.049]                   signalCondition(cond)
[18:04:56.049]                 }
[18:04:56.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.049]                 "immediateCondition"))) {
[18:04:56.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.049]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.049]                   if (TRUE && !signal) {
[18:04:56.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.049]                     {
[18:04:56.049]                       inherits <- base::inherits
[18:04:56.049]                       invokeRestart <- base::invokeRestart
[18:04:56.049]                       is.null <- base::is.null
[18:04:56.049]                       muffled <- FALSE
[18:04:56.049]                       if (inherits(cond, "message")) {
[18:04:56.049]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.049]                         if (muffled) 
[18:04:56.049]                           invokeRestart("muffleMessage")
[18:04:56.049]                       }
[18:04:56.049]                       else if (inherits(cond, "warning")) {
[18:04:56.049]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.049]                         if (muffled) 
[18:04:56.049]                           invokeRestart("muffleWarning")
[18:04:56.049]                       }
[18:04:56.049]                       else if (inherits(cond, "condition")) {
[18:04:56.049]                         if (!is.null(pattern)) {
[18:04:56.049]                           computeRestarts <- base::computeRestarts
[18:04:56.049]                           grepl <- base::grepl
[18:04:56.049]                           restarts <- computeRestarts(cond)
[18:04:56.049]                           for (restart in restarts) {
[18:04:56.049]                             name <- restart$name
[18:04:56.049]                             if (is.null(name)) 
[18:04:56.049]                               next
[18:04:56.049]                             if (!grepl(pattern, name)) 
[18:04:56.049]                               next
[18:04:56.049]                             invokeRestart(restart)
[18:04:56.049]                             muffled <- TRUE
[18:04:56.049]                             break
[18:04:56.049]                           }
[18:04:56.049]                         }
[18:04:56.049]                       }
[18:04:56.049]                       invisible(muffled)
[18:04:56.049]                     }
[18:04:56.049]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.049]                   }
[18:04:56.049]                 }
[18:04:56.049]                 else {
[18:04:56.049]                   if (TRUE) {
[18:04:56.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.049]                     {
[18:04:56.049]                       inherits <- base::inherits
[18:04:56.049]                       invokeRestart <- base::invokeRestart
[18:04:56.049]                       is.null <- base::is.null
[18:04:56.049]                       muffled <- FALSE
[18:04:56.049]                       if (inherits(cond, "message")) {
[18:04:56.049]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.049]                         if (muffled) 
[18:04:56.049]                           invokeRestart("muffleMessage")
[18:04:56.049]                       }
[18:04:56.049]                       else if (inherits(cond, "warning")) {
[18:04:56.049]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.049]                         if (muffled) 
[18:04:56.049]                           invokeRestart("muffleWarning")
[18:04:56.049]                       }
[18:04:56.049]                       else if (inherits(cond, "condition")) {
[18:04:56.049]                         if (!is.null(pattern)) {
[18:04:56.049]                           computeRestarts <- base::computeRestarts
[18:04:56.049]                           grepl <- base::grepl
[18:04:56.049]                           restarts <- computeRestarts(cond)
[18:04:56.049]                           for (restart in restarts) {
[18:04:56.049]                             name <- restart$name
[18:04:56.049]                             if (is.null(name)) 
[18:04:56.049]                               next
[18:04:56.049]                             if (!grepl(pattern, name)) 
[18:04:56.049]                               next
[18:04:56.049]                             invokeRestart(restart)
[18:04:56.049]                             muffled <- TRUE
[18:04:56.049]                             break
[18:04:56.049]                           }
[18:04:56.049]                         }
[18:04:56.049]                       }
[18:04:56.049]                       invisible(muffled)
[18:04:56.049]                     }
[18:04:56.049]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.049]                   }
[18:04:56.049]                 }
[18:04:56.049]             }
[18:04:56.049]         }))
[18:04:56.049]     }, error = function(ex) {
[18:04:56.049]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.049]                 ...future.rng), started = ...future.startTime, 
[18:04:56.049]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.049]             version = "1.8"), class = "FutureResult")
[18:04:56.049]     }, finally = {
[18:04:56.049]         if (!identical(...future.workdir, getwd())) 
[18:04:56.049]             setwd(...future.workdir)
[18:04:56.049]         {
[18:04:56.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.049]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.049]             }
[18:04:56.049]             base::options(...future.oldOptions)
[18:04:56.049]             if (.Platform$OS.type == "windows") {
[18:04:56.049]                 old_names <- names(...future.oldEnvVars)
[18:04:56.049]                 envs <- base::Sys.getenv()
[18:04:56.049]                 names <- names(envs)
[18:04:56.049]                 common <- intersect(names, old_names)
[18:04:56.049]                 added <- setdiff(names, old_names)
[18:04:56.049]                 removed <- setdiff(old_names, names)
[18:04:56.049]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.049]                   envs[common]]
[18:04:56.049]                 NAMES <- toupper(changed)
[18:04:56.049]                 args <- list()
[18:04:56.049]                 for (kk in seq_along(NAMES)) {
[18:04:56.049]                   name <- changed[[kk]]
[18:04:56.049]                   NAME <- NAMES[[kk]]
[18:04:56.049]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.049]                     next
[18:04:56.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.049]                 }
[18:04:56.049]                 NAMES <- toupper(added)
[18:04:56.049]                 for (kk in seq_along(NAMES)) {
[18:04:56.049]                   name <- added[[kk]]
[18:04:56.049]                   NAME <- NAMES[[kk]]
[18:04:56.049]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.049]                     next
[18:04:56.049]                   args[[name]] <- ""
[18:04:56.049]                 }
[18:04:56.049]                 NAMES <- toupper(removed)
[18:04:56.049]                 for (kk in seq_along(NAMES)) {
[18:04:56.049]                   name <- removed[[kk]]
[18:04:56.049]                   NAME <- NAMES[[kk]]
[18:04:56.049]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.049]                     next
[18:04:56.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.049]                 }
[18:04:56.049]                 if (length(args) > 0) 
[18:04:56.049]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.049]             }
[18:04:56.049]             else {
[18:04:56.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.049]             }
[18:04:56.049]             {
[18:04:56.049]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.049]                   0L) {
[18:04:56.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.049]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.049]                   base::options(opts)
[18:04:56.049]                 }
[18:04:56.049]                 {
[18:04:56.049]                   {
[18:04:56.049]                     NULL
[18:04:56.049]                     RNGkind("Mersenne-Twister")
[18:04:56.049]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:56.049]                       inherits = FALSE)
[18:04:56.049]                   }
[18:04:56.049]                   options(future.plan = NULL)
[18:04:56.049]                   if (is.na(NA_character_)) 
[18:04:56.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.049]                     .init = FALSE)
[18:04:56.049]                 }
[18:04:56.049]             }
[18:04:56.049]         }
[18:04:56.049]     })
[18:04:56.049]     if (TRUE) {
[18:04:56.049]         base::sink(type = "output", split = FALSE)
[18:04:56.049]         if (TRUE) {
[18:04:56.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.049]         }
[18:04:56.049]         else {
[18:04:56.049]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.049]         }
[18:04:56.049]         base::close(...future.stdout)
[18:04:56.049]         ...future.stdout <- NULL
[18:04:56.049]     }
[18:04:56.049]     ...future.result$conditions <- ...future.conditions
[18:04:56.049]     ...future.result$finished <- base::Sys.time()
[18:04:56.049]     ...future.result
[18:04:56.049] }
[18:04:56.052] assign_globals() ...
[18:04:56.052] List of 1
[18:04:56.052]  $ pkg: chr "foo"
[18:04:56.052]  - attr(*, "where")=List of 1
[18:04:56.052]   ..$ pkg:<environment: R_EmptyEnv> 
[18:04:56.052]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:56.052]  - attr(*, "resolved")= logi TRUE
[18:04:56.052]  - attr(*, "total_size")= num 112
[18:04:56.056] - copied ‘pkg’ to environment
[18:04:56.057] assign_globals() ... done
[18:04:56.057] plan(): Setting new future strategy stack:
[18:04:56.057] List of future strategies:
[18:04:56.057] 1. sequential:
[18:04:56.057]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.057]    - tweaked: FALSE
[18:04:56.057]    - call: NULL
[18:04:56.058] plan(): nbrOfWorkers() = 1
[18:04:56.060] plan(): Setting new future strategy stack:
[18:04:56.060] List of future strategies:
[18:04:56.060] 1. sequential:
[18:04:56.060]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.060]    - tweaked: FALSE
[18:04:56.060]    - call: plan(strategy)
[18:04:56.061] plan(): nbrOfWorkers() = 1
[18:04:56.061] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.062] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.062] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:56.066] - globals found: [3] ‘{’, ‘<-’, ‘+’
[18:04:56.066] Searching for globals ... DONE
[18:04:56.066] Resolving globals: TRUE
[18:04:56.067] Resolving any globals that are futures ...
[18:04:56.067] - globals: [3] ‘{’, ‘<-’, ‘+’
[18:04:56.067] Resolving any globals that are futures ... DONE
[18:04:56.068] 
[18:04:56.068] 
[18:04:56.068] getGlobalsAndPackages() ... DONE
[18:04:56.068] run() for ‘Future’ ...
[18:04:56.069] - state: ‘created’
[18:04:56.069] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:56.072] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:56.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:56.072]   - Field: ‘label’
[18:04:56.072]   - Field: ‘local’
[18:04:56.073]   - Field: ‘owner’
[18:04:56.073]   - Field: ‘envir’
[18:04:56.073]   - Field: ‘packages’
[18:04:56.073]   - Field: ‘gc’
[18:04:56.073]   - Field: ‘conditions’
[18:04:56.074]   - Field: ‘expr’
[18:04:56.074]   - Field: ‘uuid’
[18:04:56.074]   - Field: ‘seed’
[18:04:56.074]   - Field: ‘version’
[18:04:56.074]   - Field: ‘result’
[18:04:56.075]   - Field: ‘asynchronous’
[18:04:56.075]   - Field: ‘calls’
[18:04:56.075]   - Field: ‘globals’
[18:04:56.075]   - Field: ‘stdout’
[18:04:56.075]   - Field: ‘earlySignal’
[18:04:56.076]   - Field: ‘lazy’
[18:04:56.076]   - Field: ‘state’
[18:04:56.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:56.076] - Launch lazy future ...
[18:04:56.077] Packages needed by the future expression (n = 0): <none>
[18:04:56.077] Packages needed by future strategies (n = 0): <none>
[18:04:56.078] {
[18:04:56.078]     {
[18:04:56.078]         {
[18:04:56.078]             ...future.startTime <- base::Sys.time()
[18:04:56.078]             {
[18:04:56.078]                 {
[18:04:56.078]                   {
[18:04:56.078]                     base::local({
[18:04:56.078]                       has_future <- base::requireNamespace("future", 
[18:04:56.078]                         quietly = TRUE)
[18:04:56.078]                       if (has_future) {
[18:04:56.078]                         ns <- base::getNamespace("future")
[18:04:56.078]                         version <- ns[[".package"]][["version"]]
[18:04:56.078]                         if (is.null(version)) 
[18:04:56.078]                           version <- utils::packageVersion("future")
[18:04:56.078]                       }
[18:04:56.078]                       else {
[18:04:56.078]                         version <- NULL
[18:04:56.078]                       }
[18:04:56.078]                       if (!has_future || version < "1.8.0") {
[18:04:56.078]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.078]                           "", base::R.version$version.string), 
[18:04:56.078]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:56.078]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.078]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.078]                             "release", "version")], collapse = " "), 
[18:04:56.078]                           hostname = base::Sys.info()[["nodename"]])
[18:04:56.078]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.078]                           info)
[18:04:56.078]                         info <- base::paste(info, collapse = "; ")
[18:04:56.078]                         if (!has_future) {
[18:04:56.078]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.078]                             info)
[18:04:56.078]                         }
[18:04:56.078]                         else {
[18:04:56.078]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.078]                             info, version)
[18:04:56.078]                         }
[18:04:56.078]                         base::stop(msg)
[18:04:56.078]                       }
[18:04:56.078]                     })
[18:04:56.078]                   }
[18:04:56.078]                   ...future.strategy.old <- future::plan("list")
[18:04:56.078]                   options(future.plan = NULL)
[18:04:56.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.078]                 }
[18:04:56.078]                 ...future.workdir <- getwd()
[18:04:56.078]             }
[18:04:56.078]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.078]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.078]         }
[18:04:56.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.078]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:56.078]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.078]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.078]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.078]             base::names(...future.oldOptions))
[18:04:56.078]     }
[18:04:56.078]     if (FALSE) {
[18:04:56.078]     }
[18:04:56.078]     else {
[18:04:56.078]         if (TRUE) {
[18:04:56.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.078]                 open = "w")
[18:04:56.078]         }
[18:04:56.078]         else {
[18:04:56.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.078]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.078]         }
[18:04:56.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.078]             base::sink(type = "output", split = FALSE)
[18:04:56.078]             base::close(...future.stdout)
[18:04:56.078]         }, add = TRUE)
[18:04:56.078]     }
[18:04:56.078]     ...future.frame <- base::sys.nframe()
[18:04:56.078]     ...future.conditions <- base::list()
[18:04:56.078]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.078]     if (FALSE) {
[18:04:56.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.078]     }
[18:04:56.078]     ...future.result <- base::tryCatch({
[18:04:56.078]         base::withCallingHandlers({
[18:04:56.078]             ...future.value <- base::withVisible(base::local({
[18:04:56.078]                 x <- 0
[18:04:56.078]                 x <- x + 1
[18:04:56.078]                 x
[18:04:56.078]             }))
[18:04:56.078]             future::FutureResult(value = ...future.value$value, 
[18:04:56.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.078]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.078]                     ...future.globalenv.names))
[18:04:56.078]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.078]         }, condition = base::local({
[18:04:56.078]             c <- base::c
[18:04:56.078]             inherits <- base::inherits
[18:04:56.078]             invokeRestart <- base::invokeRestart
[18:04:56.078]             length <- base::length
[18:04:56.078]             list <- base::list
[18:04:56.078]             seq.int <- base::seq.int
[18:04:56.078]             signalCondition <- base::signalCondition
[18:04:56.078]             sys.calls <- base::sys.calls
[18:04:56.078]             `[[` <- base::`[[`
[18:04:56.078]             `+` <- base::`+`
[18:04:56.078]             `<<-` <- base::`<<-`
[18:04:56.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.078]                   3L)]
[18:04:56.078]             }
[18:04:56.078]             function(cond) {
[18:04:56.078]                 is_error <- inherits(cond, "error")
[18:04:56.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.078]                   NULL)
[18:04:56.078]                 if (is_error) {
[18:04:56.078]                   sessionInformation <- function() {
[18:04:56.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.078]                       search = base::search(), system = base::Sys.info())
[18:04:56.078]                   }
[18:04:56.078]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.078]                     cond$call), session = sessionInformation(), 
[18:04:56.078]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.078]                   signalCondition(cond)
[18:04:56.078]                 }
[18:04:56.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.078]                 "immediateCondition"))) {
[18:04:56.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.078]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.078]                   if (TRUE && !signal) {
[18:04:56.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.078]                     {
[18:04:56.078]                       inherits <- base::inherits
[18:04:56.078]                       invokeRestart <- base::invokeRestart
[18:04:56.078]                       is.null <- base::is.null
[18:04:56.078]                       muffled <- FALSE
[18:04:56.078]                       if (inherits(cond, "message")) {
[18:04:56.078]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.078]                         if (muffled) 
[18:04:56.078]                           invokeRestart("muffleMessage")
[18:04:56.078]                       }
[18:04:56.078]                       else if (inherits(cond, "warning")) {
[18:04:56.078]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.078]                         if (muffled) 
[18:04:56.078]                           invokeRestart("muffleWarning")
[18:04:56.078]                       }
[18:04:56.078]                       else if (inherits(cond, "condition")) {
[18:04:56.078]                         if (!is.null(pattern)) {
[18:04:56.078]                           computeRestarts <- base::computeRestarts
[18:04:56.078]                           grepl <- base::grepl
[18:04:56.078]                           restarts <- computeRestarts(cond)
[18:04:56.078]                           for (restart in restarts) {
[18:04:56.078]                             name <- restart$name
[18:04:56.078]                             if (is.null(name)) 
[18:04:56.078]                               next
[18:04:56.078]                             if (!grepl(pattern, name)) 
[18:04:56.078]                               next
[18:04:56.078]                             invokeRestart(restart)
[18:04:56.078]                             muffled <- TRUE
[18:04:56.078]                             break
[18:04:56.078]                           }
[18:04:56.078]                         }
[18:04:56.078]                       }
[18:04:56.078]                       invisible(muffled)
[18:04:56.078]                     }
[18:04:56.078]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.078]                   }
[18:04:56.078]                 }
[18:04:56.078]                 else {
[18:04:56.078]                   if (TRUE) {
[18:04:56.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.078]                     {
[18:04:56.078]                       inherits <- base::inherits
[18:04:56.078]                       invokeRestart <- base::invokeRestart
[18:04:56.078]                       is.null <- base::is.null
[18:04:56.078]                       muffled <- FALSE
[18:04:56.078]                       if (inherits(cond, "message")) {
[18:04:56.078]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.078]                         if (muffled) 
[18:04:56.078]                           invokeRestart("muffleMessage")
[18:04:56.078]                       }
[18:04:56.078]                       else if (inherits(cond, "warning")) {
[18:04:56.078]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.078]                         if (muffled) 
[18:04:56.078]                           invokeRestart("muffleWarning")
[18:04:56.078]                       }
[18:04:56.078]                       else if (inherits(cond, "condition")) {
[18:04:56.078]                         if (!is.null(pattern)) {
[18:04:56.078]                           computeRestarts <- base::computeRestarts
[18:04:56.078]                           grepl <- base::grepl
[18:04:56.078]                           restarts <- computeRestarts(cond)
[18:04:56.078]                           for (restart in restarts) {
[18:04:56.078]                             name <- restart$name
[18:04:56.078]                             if (is.null(name)) 
[18:04:56.078]                               next
[18:04:56.078]                             if (!grepl(pattern, name)) 
[18:04:56.078]                               next
[18:04:56.078]                             invokeRestart(restart)
[18:04:56.078]                             muffled <- TRUE
[18:04:56.078]                             break
[18:04:56.078]                           }
[18:04:56.078]                         }
[18:04:56.078]                       }
[18:04:56.078]                       invisible(muffled)
[18:04:56.078]                     }
[18:04:56.078]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.078]                   }
[18:04:56.078]                 }
[18:04:56.078]             }
[18:04:56.078]         }))
[18:04:56.078]     }, error = function(ex) {
[18:04:56.078]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.078]                 ...future.rng), started = ...future.startTime, 
[18:04:56.078]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.078]             version = "1.8"), class = "FutureResult")
[18:04:56.078]     }, finally = {
[18:04:56.078]         if (!identical(...future.workdir, getwd())) 
[18:04:56.078]             setwd(...future.workdir)
[18:04:56.078]         {
[18:04:56.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.078]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.078]             }
[18:04:56.078]             base::options(...future.oldOptions)
[18:04:56.078]             if (.Platform$OS.type == "windows") {
[18:04:56.078]                 old_names <- names(...future.oldEnvVars)
[18:04:56.078]                 envs <- base::Sys.getenv()
[18:04:56.078]                 names <- names(envs)
[18:04:56.078]                 common <- intersect(names, old_names)
[18:04:56.078]                 added <- setdiff(names, old_names)
[18:04:56.078]                 removed <- setdiff(old_names, names)
[18:04:56.078]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.078]                   envs[common]]
[18:04:56.078]                 NAMES <- toupper(changed)
[18:04:56.078]                 args <- list()
[18:04:56.078]                 for (kk in seq_along(NAMES)) {
[18:04:56.078]                   name <- changed[[kk]]
[18:04:56.078]                   NAME <- NAMES[[kk]]
[18:04:56.078]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.078]                     next
[18:04:56.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.078]                 }
[18:04:56.078]                 NAMES <- toupper(added)
[18:04:56.078]                 for (kk in seq_along(NAMES)) {
[18:04:56.078]                   name <- added[[kk]]
[18:04:56.078]                   NAME <- NAMES[[kk]]
[18:04:56.078]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.078]                     next
[18:04:56.078]                   args[[name]] <- ""
[18:04:56.078]                 }
[18:04:56.078]                 NAMES <- toupper(removed)
[18:04:56.078]                 for (kk in seq_along(NAMES)) {
[18:04:56.078]                   name <- removed[[kk]]
[18:04:56.078]                   NAME <- NAMES[[kk]]
[18:04:56.078]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.078]                     next
[18:04:56.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.078]                 }
[18:04:56.078]                 if (length(args) > 0) 
[18:04:56.078]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.078]             }
[18:04:56.078]             else {
[18:04:56.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.078]             }
[18:04:56.078]             {
[18:04:56.078]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.078]                   0L) {
[18:04:56.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.078]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.078]                   base::options(opts)
[18:04:56.078]                 }
[18:04:56.078]                 {
[18:04:56.078]                   {
[18:04:56.078]                     NULL
[18:04:56.078]                     RNGkind("Mersenne-Twister")
[18:04:56.078]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:56.078]                       inherits = FALSE)
[18:04:56.078]                   }
[18:04:56.078]                   options(future.plan = NULL)
[18:04:56.078]                   if (is.na(NA_character_)) 
[18:04:56.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.078]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.078]                     .init = FALSE)
[18:04:56.078]                 }
[18:04:56.078]             }
[18:04:56.078]         }
[18:04:56.078]     })
[18:04:56.078]     if (TRUE) {
[18:04:56.078]         base::sink(type = "output", split = FALSE)
[18:04:56.078]         if (TRUE) {
[18:04:56.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.078]         }
[18:04:56.078]         else {
[18:04:56.078]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.078]         }
[18:04:56.078]         base::close(...future.stdout)
[18:04:56.078]         ...future.stdout <- NULL
[18:04:56.078]     }
[18:04:56.078]     ...future.result$conditions <- ...future.conditions
[18:04:56.078]     ...future.result$finished <- base::Sys.time()
[18:04:56.078]     ...future.result
[18:04:56.078] }
[18:04:56.081] plan(): Setting new future strategy stack:
[18:04:56.081] List of future strategies:
[18:04:56.081] 1. sequential:
[18:04:56.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.081]    - tweaked: FALSE
[18:04:56.081]    - call: NULL
[18:04:56.082] plan(): nbrOfWorkers() = 1
[18:04:56.084] plan(): Setting new future strategy stack:
[18:04:56.084] List of future strategies:
[18:04:56.084] 1. sequential:
[18:04:56.084]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.084]    - tweaked: FALSE
[18:04:56.084]    - call: plan(strategy)
[18:04:56.085] plan(): nbrOfWorkers() = 1
[18:04:56.085] SequentialFuture started (and completed)
[18:04:56.085] - Launch lazy future ... done
[18:04:56.085] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.086] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.087] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:56.090] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[18:04:56.090] Searching for globals ... DONE
[18:04:56.090] Resolving globals: TRUE
[18:04:56.090] Resolving any globals that are futures ...
[18:04:56.090] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[18:04:56.091] Resolving any globals that are futures ... DONE
[18:04:56.091] Resolving futures part of globals (recursively) ...
[18:04:56.092] resolve() on list ...
[18:04:56.092]  recursive: 99
[18:04:56.092]  length: 1
[18:04:56.092]  elements: ‘x’
[18:04:56.093]  length: 0 (resolved future 1)
[18:04:56.093] resolve() on list ... DONE
[18:04:56.093] - globals: [1] ‘x’
[18:04:56.093] Resolving futures part of globals (recursively) ... DONE
[18:04:56.093] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:56.094] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[18:04:56.094] - globals: [1] ‘x’
[18:04:56.095] 
[18:04:56.095] getGlobalsAndPackages() ... DONE
[18:04:56.095] run() for ‘Future’ ...
[18:04:56.095] - state: ‘created’
[18:04:56.096] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:56.096] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:56.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:56.097]   - Field: ‘label’
[18:04:56.097]   - Field: ‘local’
[18:04:56.097]   - Field: ‘owner’
[18:04:56.097]   - Field: ‘envir’
[18:04:56.098]   - Field: ‘packages’
[18:04:56.098]   - Field: ‘gc’
[18:04:56.098]   - Field: ‘conditions’
[18:04:56.098]   - Field: ‘expr’
[18:04:56.098]   - Field: ‘uuid’
[18:04:56.098]   - Field: ‘seed’
[18:04:56.099]   - Field: ‘version’
[18:04:56.099]   - Field: ‘result’
[18:04:56.099]   - Field: ‘asynchronous’
[18:04:56.099]   - Field: ‘calls’
[18:04:56.099]   - Field: ‘globals’
[18:04:56.100]   - Field: ‘stdout’
[18:04:56.100]   - Field: ‘earlySignal’
[18:04:56.100]   - Field: ‘lazy’
[18:04:56.100]   - Field: ‘state’
[18:04:56.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:56.101] - Launch lazy future ...
[18:04:56.101] Packages needed by the future expression (n = 0): <none>
[18:04:56.101] Packages needed by future strategies (n = 0): <none>
[18:04:56.102] {
[18:04:56.102]     {
[18:04:56.102]         {
[18:04:56.102]             ...future.startTime <- base::Sys.time()
[18:04:56.102]             {
[18:04:56.102]                 {
[18:04:56.102]                   {
[18:04:56.102]                     base::local({
[18:04:56.102]                       has_future <- base::requireNamespace("future", 
[18:04:56.102]                         quietly = TRUE)
[18:04:56.102]                       if (has_future) {
[18:04:56.102]                         ns <- base::getNamespace("future")
[18:04:56.102]                         version <- ns[[".package"]][["version"]]
[18:04:56.102]                         if (is.null(version)) 
[18:04:56.102]                           version <- utils::packageVersion("future")
[18:04:56.102]                       }
[18:04:56.102]                       else {
[18:04:56.102]                         version <- NULL
[18:04:56.102]                       }
[18:04:56.102]                       if (!has_future || version < "1.8.0") {
[18:04:56.102]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.102]                           "", base::R.version$version.string), 
[18:04:56.102]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:56.102]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.102]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.102]                             "release", "version")], collapse = " "), 
[18:04:56.102]                           hostname = base::Sys.info()[["nodename"]])
[18:04:56.102]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.102]                           info)
[18:04:56.102]                         info <- base::paste(info, collapse = "; ")
[18:04:56.102]                         if (!has_future) {
[18:04:56.102]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.102]                             info)
[18:04:56.102]                         }
[18:04:56.102]                         else {
[18:04:56.102]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.102]                             info, version)
[18:04:56.102]                         }
[18:04:56.102]                         base::stop(msg)
[18:04:56.102]                       }
[18:04:56.102]                     })
[18:04:56.102]                   }
[18:04:56.102]                   ...future.strategy.old <- future::plan("list")
[18:04:56.102]                   options(future.plan = NULL)
[18:04:56.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.102]                 }
[18:04:56.102]                 ...future.workdir <- getwd()
[18:04:56.102]             }
[18:04:56.102]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.102]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.102]         }
[18:04:56.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.102]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:56.102]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.102]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.102]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.102]             base::names(...future.oldOptions))
[18:04:56.102]     }
[18:04:56.102]     if (FALSE) {
[18:04:56.102]     }
[18:04:56.102]     else {
[18:04:56.102]         if (TRUE) {
[18:04:56.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.102]                 open = "w")
[18:04:56.102]         }
[18:04:56.102]         else {
[18:04:56.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.102]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.102]         }
[18:04:56.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.102]             base::sink(type = "output", split = FALSE)
[18:04:56.102]             base::close(...future.stdout)
[18:04:56.102]         }, add = TRUE)
[18:04:56.102]     }
[18:04:56.102]     ...future.frame <- base::sys.nframe()
[18:04:56.102]     ...future.conditions <- base::list()
[18:04:56.102]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.102]     if (FALSE) {
[18:04:56.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.102]     }
[18:04:56.102]     ...future.result <- base::tryCatch({
[18:04:56.102]         base::withCallingHandlers({
[18:04:56.102]             ...future.value <- base::withVisible(base::local({
[18:04:56.102]                 x <- x + 1
[18:04:56.102]                 x
[18:04:56.102]             }))
[18:04:56.102]             future::FutureResult(value = ...future.value$value, 
[18:04:56.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.102]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.102]                     ...future.globalenv.names))
[18:04:56.102]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.102]         }, condition = base::local({
[18:04:56.102]             c <- base::c
[18:04:56.102]             inherits <- base::inherits
[18:04:56.102]             invokeRestart <- base::invokeRestart
[18:04:56.102]             length <- base::length
[18:04:56.102]             list <- base::list
[18:04:56.102]             seq.int <- base::seq.int
[18:04:56.102]             signalCondition <- base::signalCondition
[18:04:56.102]             sys.calls <- base::sys.calls
[18:04:56.102]             `[[` <- base::`[[`
[18:04:56.102]             `+` <- base::`+`
[18:04:56.102]             `<<-` <- base::`<<-`
[18:04:56.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.102]                   3L)]
[18:04:56.102]             }
[18:04:56.102]             function(cond) {
[18:04:56.102]                 is_error <- inherits(cond, "error")
[18:04:56.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.102]                   NULL)
[18:04:56.102]                 if (is_error) {
[18:04:56.102]                   sessionInformation <- function() {
[18:04:56.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.102]                       search = base::search(), system = base::Sys.info())
[18:04:56.102]                   }
[18:04:56.102]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.102]                     cond$call), session = sessionInformation(), 
[18:04:56.102]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.102]                   signalCondition(cond)
[18:04:56.102]                 }
[18:04:56.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.102]                 "immediateCondition"))) {
[18:04:56.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.102]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.102]                   if (TRUE && !signal) {
[18:04:56.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.102]                     {
[18:04:56.102]                       inherits <- base::inherits
[18:04:56.102]                       invokeRestart <- base::invokeRestart
[18:04:56.102]                       is.null <- base::is.null
[18:04:56.102]                       muffled <- FALSE
[18:04:56.102]                       if (inherits(cond, "message")) {
[18:04:56.102]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.102]                         if (muffled) 
[18:04:56.102]                           invokeRestart("muffleMessage")
[18:04:56.102]                       }
[18:04:56.102]                       else if (inherits(cond, "warning")) {
[18:04:56.102]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.102]                         if (muffled) 
[18:04:56.102]                           invokeRestart("muffleWarning")
[18:04:56.102]                       }
[18:04:56.102]                       else if (inherits(cond, "condition")) {
[18:04:56.102]                         if (!is.null(pattern)) {
[18:04:56.102]                           computeRestarts <- base::computeRestarts
[18:04:56.102]                           grepl <- base::grepl
[18:04:56.102]                           restarts <- computeRestarts(cond)
[18:04:56.102]                           for (restart in restarts) {
[18:04:56.102]                             name <- restart$name
[18:04:56.102]                             if (is.null(name)) 
[18:04:56.102]                               next
[18:04:56.102]                             if (!grepl(pattern, name)) 
[18:04:56.102]                               next
[18:04:56.102]                             invokeRestart(restart)
[18:04:56.102]                             muffled <- TRUE
[18:04:56.102]                             break
[18:04:56.102]                           }
[18:04:56.102]                         }
[18:04:56.102]                       }
[18:04:56.102]                       invisible(muffled)
[18:04:56.102]                     }
[18:04:56.102]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.102]                   }
[18:04:56.102]                 }
[18:04:56.102]                 else {
[18:04:56.102]                   if (TRUE) {
[18:04:56.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.102]                     {
[18:04:56.102]                       inherits <- base::inherits
[18:04:56.102]                       invokeRestart <- base::invokeRestart
[18:04:56.102]                       is.null <- base::is.null
[18:04:56.102]                       muffled <- FALSE
[18:04:56.102]                       if (inherits(cond, "message")) {
[18:04:56.102]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.102]                         if (muffled) 
[18:04:56.102]                           invokeRestart("muffleMessage")
[18:04:56.102]                       }
[18:04:56.102]                       else if (inherits(cond, "warning")) {
[18:04:56.102]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.102]                         if (muffled) 
[18:04:56.102]                           invokeRestart("muffleWarning")
[18:04:56.102]                       }
[18:04:56.102]                       else if (inherits(cond, "condition")) {
[18:04:56.102]                         if (!is.null(pattern)) {
[18:04:56.102]                           computeRestarts <- base::computeRestarts
[18:04:56.102]                           grepl <- base::grepl
[18:04:56.102]                           restarts <- computeRestarts(cond)
[18:04:56.102]                           for (restart in restarts) {
[18:04:56.102]                             name <- restart$name
[18:04:56.102]                             if (is.null(name)) 
[18:04:56.102]                               next
[18:04:56.102]                             if (!grepl(pattern, name)) 
[18:04:56.102]                               next
[18:04:56.102]                             invokeRestart(restart)
[18:04:56.102]                             muffled <- TRUE
[18:04:56.102]                             break
[18:04:56.102]                           }
[18:04:56.102]                         }
[18:04:56.102]                       }
[18:04:56.102]                       invisible(muffled)
[18:04:56.102]                     }
[18:04:56.102]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.102]                   }
[18:04:56.102]                 }
[18:04:56.102]             }
[18:04:56.102]         }))
[18:04:56.102]     }, error = function(ex) {
[18:04:56.102]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.102]                 ...future.rng), started = ...future.startTime, 
[18:04:56.102]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.102]             version = "1.8"), class = "FutureResult")
[18:04:56.102]     }, finally = {
[18:04:56.102]         if (!identical(...future.workdir, getwd())) 
[18:04:56.102]             setwd(...future.workdir)
[18:04:56.102]         {
[18:04:56.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.102]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.102]             }
[18:04:56.102]             base::options(...future.oldOptions)
[18:04:56.102]             if (.Platform$OS.type == "windows") {
[18:04:56.102]                 old_names <- names(...future.oldEnvVars)
[18:04:56.102]                 envs <- base::Sys.getenv()
[18:04:56.102]                 names <- names(envs)
[18:04:56.102]                 common <- intersect(names, old_names)
[18:04:56.102]                 added <- setdiff(names, old_names)
[18:04:56.102]                 removed <- setdiff(old_names, names)
[18:04:56.102]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.102]                   envs[common]]
[18:04:56.102]                 NAMES <- toupper(changed)
[18:04:56.102]                 args <- list()
[18:04:56.102]                 for (kk in seq_along(NAMES)) {
[18:04:56.102]                   name <- changed[[kk]]
[18:04:56.102]                   NAME <- NAMES[[kk]]
[18:04:56.102]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.102]                     next
[18:04:56.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.102]                 }
[18:04:56.102]                 NAMES <- toupper(added)
[18:04:56.102]                 for (kk in seq_along(NAMES)) {
[18:04:56.102]                   name <- added[[kk]]
[18:04:56.102]                   NAME <- NAMES[[kk]]
[18:04:56.102]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.102]                     next
[18:04:56.102]                   args[[name]] <- ""
[18:04:56.102]                 }
[18:04:56.102]                 NAMES <- toupper(removed)
[18:04:56.102]                 for (kk in seq_along(NAMES)) {
[18:04:56.102]                   name <- removed[[kk]]
[18:04:56.102]                   NAME <- NAMES[[kk]]
[18:04:56.102]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.102]                     next
[18:04:56.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.102]                 }
[18:04:56.102]                 if (length(args) > 0) 
[18:04:56.102]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.102]             }
[18:04:56.102]             else {
[18:04:56.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.102]             }
[18:04:56.102]             {
[18:04:56.102]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.102]                   0L) {
[18:04:56.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.102]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.102]                   base::options(opts)
[18:04:56.102]                 }
[18:04:56.102]                 {
[18:04:56.102]                   {
[18:04:56.102]                     NULL
[18:04:56.102]                     RNGkind("Mersenne-Twister")
[18:04:56.102]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:56.102]                       inherits = FALSE)
[18:04:56.102]                   }
[18:04:56.102]                   options(future.plan = NULL)
[18:04:56.102]                   if (is.na(NA_character_)) 
[18:04:56.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.102]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.102]                     .init = FALSE)
[18:04:56.102]                 }
[18:04:56.102]             }
[18:04:56.102]         }
[18:04:56.102]     })
[18:04:56.102]     if (TRUE) {
[18:04:56.102]         base::sink(type = "output", split = FALSE)
[18:04:56.102]         if (TRUE) {
[18:04:56.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.102]         }
[18:04:56.102]         else {
[18:04:56.102]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.102]         }
[18:04:56.102]         base::close(...future.stdout)
[18:04:56.102]         ...future.stdout <- NULL
[18:04:56.102]     }
[18:04:56.102]     ...future.result$conditions <- ...future.conditions
[18:04:56.102]     ...future.result$finished <- base::Sys.time()
[18:04:56.102]     ...future.result
[18:04:56.102] }
[18:04:56.105] assign_globals() ...
[18:04:56.105] List of 1
[18:04:56.105]  $ x: num 1
[18:04:56.105]  - attr(*, "where")=List of 1
[18:04:56.105]   ..$ x:<environment: R_EmptyEnv> 
[18:04:56.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:56.105]  - attr(*, "resolved")= logi TRUE
[18:04:56.105]  - attr(*, "total_size")= num 56
[18:04:56.105]  - attr(*, "already-done")= logi TRUE
[18:04:56.110] - copied ‘x’ to environment
[18:04:56.110] assign_globals() ... done
[18:04:56.111] plan(): Setting new future strategy stack:
[18:04:56.111] List of future strategies:
[18:04:56.111] 1. sequential:
[18:04:56.111]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.111]    - tweaked: FALSE
[18:04:56.111]    - call: NULL
[18:04:56.112] plan(): nbrOfWorkers() = 1
[18:04:56.113] plan(): Setting new future strategy stack:
[18:04:56.114] List of future strategies:
[18:04:56.114] 1. sequential:
[18:04:56.114]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.114]    - tweaked: FALSE
[18:04:56.114]    - call: plan(strategy)
[18:04:56.114] plan(): nbrOfWorkers() = 1
[18:04:56.115] SequentialFuture started (and completed)
[18:04:56.115] - Launch lazy future ... done
[18:04:56.115] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.116] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.116] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:56.120] - globals found: [3] ‘{’, ‘<-’, ‘x’
[18:04:56.121] Searching for globals ... DONE
[18:04:56.121] Resolving globals: TRUE
[18:04:56.121] Resolving any globals that are futures ...
[18:04:56.121] - globals: [3] ‘{’, ‘<-’, ‘x’
[18:04:56.122] Resolving any globals that are futures ... DONE
[18:04:56.122] Resolving futures part of globals (recursively) ...
[18:04:56.123] resolve() on list ...
[18:04:56.123]  recursive: 99
[18:04:56.123]  length: 1
[18:04:56.123]  elements: ‘x’
[18:04:56.123]  length: 0 (resolved future 1)
[18:04:56.124] resolve() on list ... DONE
[18:04:56.124] - globals: [1] ‘x’
[18:04:56.124] Resolving futures part of globals (recursively) ... DONE
[18:04:56.124] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[18:04:56.125] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[18:04:56.125] - globals: [1] ‘x’
[18:04:56.125] 
[18:04:56.126] getGlobalsAndPackages() ... DONE
[18:04:56.126] run() for ‘Future’ ...
[18:04:56.126] - state: ‘created’
[18:04:56.126] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:56.127] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:56.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:56.127]   - Field: ‘label’
[18:04:56.128]   - Field: ‘local’
[18:04:56.128]   - Field: ‘owner’
[18:04:56.128]   - Field: ‘envir’
[18:04:56.128]   - Field: ‘packages’
[18:04:56.128]   - Field: ‘gc’
[18:04:56.129]   - Field: ‘conditions’
[18:04:56.129]   - Field: ‘expr’
[18:04:56.129]   - Field: ‘uuid’
[18:04:56.129]   - Field: ‘seed’
[18:04:56.129]   - Field: ‘version’
[18:04:56.130]   - Field: ‘result’
[18:04:56.132]   - Field: ‘asynchronous’
[18:04:56.132]   - Field: ‘calls’
[18:04:56.133]   - Field: ‘globals’
[18:04:56.133]   - Field: ‘stdout’
[18:04:56.133]   - Field: ‘earlySignal’
[18:04:56.133]   - Field: ‘lazy’
[18:04:56.133]   - Field: ‘state’
[18:04:56.134] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:56.134] - Launch lazy future ...
[18:04:56.134] Packages needed by the future expression (n = 0): <none>
[18:04:56.134] Packages needed by future strategies (n = 0): <none>
[18:04:56.135] {
[18:04:56.135]     {
[18:04:56.135]         {
[18:04:56.135]             ...future.startTime <- base::Sys.time()
[18:04:56.135]             {
[18:04:56.135]                 {
[18:04:56.135]                   {
[18:04:56.135]                     base::local({
[18:04:56.135]                       has_future <- base::requireNamespace("future", 
[18:04:56.135]                         quietly = TRUE)
[18:04:56.135]                       if (has_future) {
[18:04:56.135]                         ns <- base::getNamespace("future")
[18:04:56.135]                         version <- ns[[".package"]][["version"]]
[18:04:56.135]                         if (is.null(version)) 
[18:04:56.135]                           version <- utils::packageVersion("future")
[18:04:56.135]                       }
[18:04:56.135]                       else {
[18:04:56.135]                         version <- NULL
[18:04:56.135]                       }
[18:04:56.135]                       if (!has_future || version < "1.8.0") {
[18:04:56.135]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.135]                           "", base::R.version$version.string), 
[18:04:56.135]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:56.135]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.135]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.135]                             "release", "version")], collapse = " "), 
[18:04:56.135]                           hostname = base::Sys.info()[["nodename"]])
[18:04:56.135]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.135]                           info)
[18:04:56.135]                         info <- base::paste(info, collapse = "; ")
[18:04:56.135]                         if (!has_future) {
[18:04:56.135]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.135]                             info)
[18:04:56.135]                         }
[18:04:56.135]                         else {
[18:04:56.135]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.135]                             info, version)
[18:04:56.135]                         }
[18:04:56.135]                         base::stop(msg)
[18:04:56.135]                       }
[18:04:56.135]                     })
[18:04:56.135]                   }
[18:04:56.135]                   ...future.strategy.old <- future::plan("list")
[18:04:56.135]                   options(future.plan = NULL)
[18:04:56.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.135]                 }
[18:04:56.135]                 ...future.workdir <- getwd()
[18:04:56.135]             }
[18:04:56.135]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.135]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.135]         }
[18:04:56.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.135]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:56.135]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.135]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.135]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.135]             base::names(...future.oldOptions))
[18:04:56.135]     }
[18:04:56.135]     if (FALSE) {
[18:04:56.135]     }
[18:04:56.135]     else {
[18:04:56.135]         if (TRUE) {
[18:04:56.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.135]                 open = "w")
[18:04:56.135]         }
[18:04:56.135]         else {
[18:04:56.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.135]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.135]         }
[18:04:56.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.135]             base::sink(type = "output", split = FALSE)
[18:04:56.135]             base::close(...future.stdout)
[18:04:56.135]         }, add = TRUE)
[18:04:56.135]     }
[18:04:56.135]     ...future.frame <- base::sys.nframe()
[18:04:56.135]     ...future.conditions <- base::list()
[18:04:56.135]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.135]     if (FALSE) {
[18:04:56.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.135]     }
[18:04:56.135]     ...future.result <- base::tryCatch({
[18:04:56.135]         base::withCallingHandlers({
[18:04:56.135]             ...future.value <- base::withVisible(base::local({
[18:04:56.135]                 x <- x()
[18:04:56.135]                 x
[18:04:56.135]             }))
[18:04:56.135]             future::FutureResult(value = ...future.value$value, 
[18:04:56.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.135]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.135]                     ...future.globalenv.names))
[18:04:56.135]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.135]         }, condition = base::local({
[18:04:56.135]             c <- base::c
[18:04:56.135]             inherits <- base::inherits
[18:04:56.135]             invokeRestart <- base::invokeRestart
[18:04:56.135]             length <- base::length
[18:04:56.135]             list <- base::list
[18:04:56.135]             seq.int <- base::seq.int
[18:04:56.135]             signalCondition <- base::signalCondition
[18:04:56.135]             sys.calls <- base::sys.calls
[18:04:56.135]             `[[` <- base::`[[`
[18:04:56.135]             `+` <- base::`+`
[18:04:56.135]             `<<-` <- base::`<<-`
[18:04:56.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.135]                   3L)]
[18:04:56.135]             }
[18:04:56.135]             function(cond) {
[18:04:56.135]                 is_error <- inherits(cond, "error")
[18:04:56.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.135]                   NULL)
[18:04:56.135]                 if (is_error) {
[18:04:56.135]                   sessionInformation <- function() {
[18:04:56.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.135]                       search = base::search(), system = base::Sys.info())
[18:04:56.135]                   }
[18:04:56.135]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.135]                     cond$call), session = sessionInformation(), 
[18:04:56.135]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.135]                   signalCondition(cond)
[18:04:56.135]                 }
[18:04:56.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.135]                 "immediateCondition"))) {
[18:04:56.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.135]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.135]                   if (TRUE && !signal) {
[18:04:56.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.135]                     {
[18:04:56.135]                       inherits <- base::inherits
[18:04:56.135]                       invokeRestart <- base::invokeRestart
[18:04:56.135]                       is.null <- base::is.null
[18:04:56.135]                       muffled <- FALSE
[18:04:56.135]                       if (inherits(cond, "message")) {
[18:04:56.135]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.135]                         if (muffled) 
[18:04:56.135]                           invokeRestart("muffleMessage")
[18:04:56.135]                       }
[18:04:56.135]                       else if (inherits(cond, "warning")) {
[18:04:56.135]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.135]                         if (muffled) 
[18:04:56.135]                           invokeRestart("muffleWarning")
[18:04:56.135]                       }
[18:04:56.135]                       else if (inherits(cond, "condition")) {
[18:04:56.135]                         if (!is.null(pattern)) {
[18:04:56.135]                           computeRestarts <- base::computeRestarts
[18:04:56.135]                           grepl <- base::grepl
[18:04:56.135]                           restarts <- computeRestarts(cond)
[18:04:56.135]                           for (restart in restarts) {
[18:04:56.135]                             name <- restart$name
[18:04:56.135]                             if (is.null(name)) 
[18:04:56.135]                               next
[18:04:56.135]                             if (!grepl(pattern, name)) 
[18:04:56.135]                               next
[18:04:56.135]                             invokeRestart(restart)
[18:04:56.135]                             muffled <- TRUE
[18:04:56.135]                             break
[18:04:56.135]                           }
[18:04:56.135]                         }
[18:04:56.135]                       }
[18:04:56.135]                       invisible(muffled)
[18:04:56.135]                     }
[18:04:56.135]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.135]                   }
[18:04:56.135]                 }
[18:04:56.135]                 else {
[18:04:56.135]                   if (TRUE) {
[18:04:56.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.135]                     {
[18:04:56.135]                       inherits <- base::inherits
[18:04:56.135]                       invokeRestart <- base::invokeRestart
[18:04:56.135]                       is.null <- base::is.null
[18:04:56.135]                       muffled <- FALSE
[18:04:56.135]                       if (inherits(cond, "message")) {
[18:04:56.135]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.135]                         if (muffled) 
[18:04:56.135]                           invokeRestart("muffleMessage")
[18:04:56.135]                       }
[18:04:56.135]                       else if (inherits(cond, "warning")) {
[18:04:56.135]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.135]                         if (muffled) 
[18:04:56.135]                           invokeRestart("muffleWarning")
[18:04:56.135]                       }
[18:04:56.135]                       else if (inherits(cond, "condition")) {
[18:04:56.135]                         if (!is.null(pattern)) {
[18:04:56.135]                           computeRestarts <- base::computeRestarts
[18:04:56.135]                           grepl <- base::grepl
[18:04:56.135]                           restarts <- computeRestarts(cond)
[18:04:56.135]                           for (restart in restarts) {
[18:04:56.135]                             name <- restart$name
[18:04:56.135]                             if (is.null(name)) 
[18:04:56.135]                               next
[18:04:56.135]                             if (!grepl(pattern, name)) 
[18:04:56.135]                               next
[18:04:56.135]                             invokeRestart(restart)
[18:04:56.135]                             muffled <- TRUE
[18:04:56.135]                             break
[18:04:56.135]                           }
[18:04:56.135]                         }
[18:04:56.135]                       }
[18:04:56.135]                       invisible(muffled)
[18:04:56.135]                     }
[18:04:56.135]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.135]                   }
[18:04:56.135]                 }
[18:04:56.135]             }
[18:04:56.135]         }))
[18:04:56.135]     }, error = function(ex) {
[18:04:56.135]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.135]                 ...future.rng), started = ...future.startTime, 
[18:04:56.135]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.135]             version = "1.8"), class = "FutureResult")
[18:04:56.135]     }, finally = {
[18:04:56.135]         if (!identical(...future.workdir, getwd())) 
[18:04:56.135]             setwd(...future.workdir)
[18:04:56.135]         {
[18:04:56.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.135]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.135]             }
[18:04:56.135]             base::options(...future.oldOptions)
[18:04:56.135]             if (.Platform$OS.type == "windows") {
[18:04:56.135]                 old_names <- names(...future.oldEnvVars)
[18:04:56.135]                 envs <- base::Sys.getenv()
[18:04:56.135]                 names <- names(envs)
[18:04:56.135]                 common <- intersect(names, old_names)
[18:04:56.135]                 added <- setdiff(names, old_names)
[18:04:56.135]                 removed <- setdiff(old_names, names)
[18:04:56.135]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.135]                   envs[common]]
[18:04:56.135]                 NAMES <- toupper(changed)
[18:04:56.135]                 args <- list()
[18:04:56.135]                 for (kk in seq_along(NAMES)) {
[18:04:56.135]                   name <- changed[[kk]]
[18:04:56.135]                   NAME <- NAMES[[kk]]
[18:04:56.135]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.135]                     next
[18:04:56.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.135]                 }
[18:04:56.135]                 NAMES <- toupper(added)
[18:04:56.135]                 for (kk in seq_along(NAMES)) {
[18:04:56.135]                   name <- added[[kk]]
[18:04:56.135]                   NAME <- NAMES[[kk]]
[18:04:56.135]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.135]                     next
[18:04:56.135]                   args[[name]] <- ""
[18:04:56.135]                 }
[18:04:56.135]                 NAMES <- toupper(removed)
[18:04:56.135]                 for (kk in seq_along(NAMES)) {
[18:04:56.135]                   name <- removed[[kk]]
[18:04:56.135]                   NAME <- NAMES[[kk]]
[18:04:56.135]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.135]                     next
[18:04:56.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.135]                 }
[18:04:56.135]                 if (length(args) > 0) 
[18:04:56.135]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.135]             }
[18:04:56.135]             else {
[18:04:56.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.135]             }
[18:04:56.135]             {
[18:04:56.135]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.135]                   0L) {
[18:04:56.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.135]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.135]                   base::options(opts)
[18:04:56.135]                 }
[18:04:56.135]                 {
[18:04:56.135]                   {
[18:04:56.135]                     NULL
[18:04:56.135]                     RNGkind("Mersenne-Twister")
[18:04:56.135]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:56.135]                       inherits = FALSE)
[18:04:56.135]                   }
[18:04:56.135]                   options(future.plan = NULL)
[18:04:56.135]                   if (is.na(NA_character_)) 
[18:04:56.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.135]                     .init = FALSE)
[18:04:56.135]                 }
[18:04:56.135]             }
[18:04:56.135]         }
[18:04:56.135]     })
[18:04:56.135]     if (TRUE) {
[18:04:56.135]         base::sink(type = "output", split = FALSE)
[18:04:56.135]         if (TRUE) {
[18:04:56.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.135]         }
[18:04:56.135]         else {
[18:04:56.135]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.135]         }
[18:04:56.135]         base::close(...future.stdout)
[18:04:56.135]         ...future.stdout <- NULL
[18:04:56.135]     }
[18:04:56.135]     ...future.result$conditions <- ...future.conditions
[18:04:56.135]     ...future.result$finished <- base::Sys.time()
[18:04:56.135]     ...future.result
[18:04:56.135] }
[18:04:56.139] assign_globals() ...
[18:04:56.139] List of 1
[18:04:56.139]  $ x:function ()  
[18:04:56.139]  - attr(*, "where")=List of 1
[18:04:56.139]   ..$ x:<environment: R_EmptyEnv> 
[18:04:56.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:56.139]  - attr(*, "resolved")= logi TRUE
[18:04:56.139]  - attr(*, "total_size")= num 1032
[18:04:56.139]  - attr(*, "already-done")= logi TRUE
[18:04:56.144] - reassign environment for ‘x’
[18:04:56.144] - copied ‘x’ to environment
[18:04:56.144] assign_globals() ... done
[18:04:56.144] plan(): Setting new future strategy stack:
[18:04:56.145] List of future strategies:
[18:04:56.145] 1. sequential:
[18:04:56.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.145]    - tweaked: FALSE
[18:04:56.145]    - call: NULL
[18:04:56.146] plan(): nbrOfWorkers() = 1
[18:04:56.147] plan(): Setting new future strategy stack:
[18:04:56.147] List of future strategies:
[18:04:56.147] 1. sequential:
[18:04:56.147]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.147]    - tweaked: FALSE
[18:04:56.147]    - call: plan(strategy)
[18:04:56.148] plan(): nbrOfWorkers() = 1
[18:04:56.148] SequentialFuture started (and completed)
[18:04:56.149] - Launch lazy future ... done
[18:04:56.149] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[18:04:56.166] plan(): Setting new future strategy stack:
[18:04:56.166] List of future strategies:
[18:04:56.166] 1. multicore:
[18:04:56.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.166]    - tweaked: FALSE
[18:04:56.166]    - call: plan(strategy)
[18:04:56.173] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.174] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.174] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.177] - globals found: [3] ‘{’, ‘<-’, ‘*’
[18:04:56.178] Searching for globals ... DONE
[18:04:56.178] Resolving globals: TRUE
[18:04:56.178] Resolving any globals that are futures ...
[18:04:56.178] - globals: [3] ‘{’, ‘<-’, ‘*’
[18:04:56.179] Resolving any globals that are futures ... DONE
[18:04:56.179] 
[18:04:56.179] 
[18:04:56.180] getGlobalsAndPackages() ... DONE
[18:04:56.180] run() for ‘Future’ ...
[18:04:56.180] - state: ‘created’
[18:04:56.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:56.188] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:56.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:56.188]   - Field: ‘label’
[18:04:56.188]   - Field: ‘local’
[18:04:56.189]   - Field: ‘owner’
[18:04:56.189]   - Field: ‘envir’
[18:04:56.189]   - Field: ‘workers’
[18:04:56.189]   - Field: ‘packages’
[18:04:56.190]   - Field: ‘gc’
[18:04:56.190]   - Field: ‘job’
[18:04:56.190]   - Field: ‘conditions’
[18:04:56.190]   - Field: ‘expr’
[18:04:56.190]   - Field: ‘uuid’
[18:04:56.191]   - Field: ‘seed’
[18:04:56.191]   - Field: ‘version’
[18:04:56.191]   - Field: ‘result’
[18:04:56.191]   - Field: ‘asynchronous’
[18:04:56.191]   - Field: ‘calls’
[18:04:56.192]   - Field: ‘globals’
[18:04:56.192]   - Field: ‘stdout’
[18:04:56.192]   - Field: ‘earlySignal’
[18:04:56.192]   - Field: ‘lazy’
[18:04:56.192]   - Field: ‘state’
[18:04:56.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:56.193] - Launch lazy future ...
[18:04:56.195] Packages needed by the future expression (n = 0): <none>
[18:04:56.195] Packages needed by future strategies (n = 0): <none>
[18:04:56.196] {
[18:04:56.196]     {
[18:04:56.196]         {
[18:04:56.196]             ...future.startTime <- base::Sys.time()
[18:04:56.196]             {
[18:04:56.196]                 {
[18:04:56.196]                   {
[18:04:56.196]                     {
[18:04:56.196]                       base::local({
[18:04:56.196]                         has_future <- base::requireNamespace("future", 
[18:04:56.196]                           quietly = TRUE)
[18:04:56.196]                         if (has_future) {
[18:04:56.196]                           ns <- base::getNamespace("future")
[18:04:56.196]                           version <- ns[[".package"]][["version"]]
[18:04:56.196]                           if (is.null(version)) 
[18:04:56.196]                             version <- utils::packageVersion("future")
[18:04:56.196]                         }
[18:04:56.196]                         else {
[18:04:56.196]                           version <- NULL
[18:04:56.196]                         }
[18:04:56.196]                         if (!has_future || version < "1.8.0") {
[18:04:56.196]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.196]                             "", base::R.version$version.string), 
[18:04:56.196]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:56.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.196]                               "release", "version")], collapse = " "), 
[18:04:56.196]                             hostname = base::Sys.info()[["nodename"]])
[18:04:56.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.196]                             info)
[18:04:56.196]                           info <- base::paste(info, collapse = "; ")
[18:04:56.196]                           if (!has_future) {
[18:04:56.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.196]                               info)
[18:04:56.196]                           }
[18:04:56.196]                           else {
[18:04:56.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.196]                               info, version)
[18:04:56.196]                           }
[18:04:56.196]                           base::stop(msg)
[18:04:56.196]                         }
[18:04:56.196]                       })
[18:04:56.196]                     }
[18:04:56.196]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:56.196]                     base::options(mc.cores = 1L)
[18:04:56.196]                   }
[18:04:56.196]                   ...future.strategy.old <- future::plan("list")
[18:04:56.196]                   options(future.plan = NULL)
[18:04:56.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.196]                 }
[18:04:56.196]                 ...future.workdir <- getwd()
[18:04:56.196]             }
[18:04:56.196]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.196]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.196]         }
[18:04:56.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.196]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:56.196]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.196]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.196]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.196]             base::names(...future.oldOptions))
[18:04:56.196]     }
[18:04:56.196]     if (FALSE) {
[18:04:56.196]     }
[18:04:56.196]     else {
[18:04:56.196]         if (TRUE) {
[18:04:56.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.196]                 open = "w")
[18:04:56.196]         }
[18:04:56.196]         else {
[18:04:56.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.196]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.196]         }
[18:04:56.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.196]             base::sink(type = "output", split = FALSE)
[18:04:56.196]             base::close(...future.stdout)
[18:04:56.196]         }, add = TRUE)
[18:04:56.196]     }
[18:04:56.196]     ...future.frame <- base::sys.nframe()
[18:04:56.196]     ...future.conditions <- base::list()
[18:04:56.196]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.196]     if (FALSE) {
[18:04:56.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.196]     }
[18:04:56.196]     ...future.result <- base::tryCatch({
[18:04:56.196]         base::withCallingHandlers({
[18:04:56.196]             ...future.value <- base::withVisible(base::local({
[18:04:56.196]                 withCallingHandlers({
[18:04:56.196]                   {
[18:04:56.196]                     b <- a
[18:04:56.196]                     a <- 2
[18:04:56.196]                     a * b
[18:04:56.196]                   }
[18:04:56.196]                 }, immediateCondition = function(cond) {
[18:04:56.196]                   save_rds <- function (object, pathname, ...) 
[18:04:56.196]                   {
[18:04:56.196]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:56.196]                     if (file_test("-f", pathname_tmp)) {
[18:04:56.196]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.196]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:56.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.196]                         fi_tmp[["mtime"]])
[18:04:56.196]                     }
[18:04:56.196]                     tryCatch({
[18:04:56.196]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:56.196]                     }, error = function(ex) {
[18:04:56.196]                       msg <- conditionMessage(ex)
[18:04:56.196]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.196]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:56.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.196]                         fi_tmp[["mtime"]], msg)
[18:04:56.196]                       ex$message <- msg
[18:04:56.196]                       stop(ex)
[18:04:56.196]                     })
[18:04:56.196]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:56.196]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:56.196]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:56.196]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.196]                       fi <- file.info(pathname)
[18:04:56.196]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:56.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.196]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:56.196]                         fi[["size"]], fi[["mtime"]])
[18:04:56.196]                       stop(msg)
[18:04:56.196]                     }
[18:04:56.196]                     invisible(pathname)
[18:04:56.196]                   }
[18:04:56.196]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:56.196]                     rootPath = tempdir()) 
[18:04:56.196]                   {
[18:04:56.196]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:56.196]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:56.196]                       tmpdir = path, fileext = ".rds")
[18:04:56.196]                     save_rds(obj, file)
[18:04:56.196]                   }
[18:04:56.196]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:56.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.196]                   {
[18:04:56.196]                     inherits <- base::inherits
[18:04:56.196]                     invokeRestart <- base::invokeRestart
[18:04:56.196]                     is.null <- base::is.null
[18:04:56.196]                     muffled <- FALSE
[18:04:56.196]                     if (inherits(cond, "message")) {
[18:04:56.196]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:56.196]                       if (muffled) 
[18:04:56.196]                         invokeRestart("muffleMessage")
[18:04:56.196]                     }
[18:04:56.196]                     else if (inherits(cond, "warning")) {
[18:04:56.196]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:56.196]                       if (muffled) 
[18:04:56.196]                         invokeRestart("muffleWarning")
[18:04:56.196]                     }
[18:04:56.196]                     else if (inherits(cond, "condition")) {
[18:04:56.196]                       if (!is.null(pattern)) {
[18:04:56.196]                         computeRestarts <- base::computeRestarts
[18:04:56.196]                         grepl <- base::grepl
[18:04:56.196]                         restarts <- computeRestarts(cond)
[18:04:56.196]                         for (restart in restarts) {
[18:04:56.196]                           name <- restart$name
[18:04:56.196]                           if (is.null(name)) 
[18:04:56.196]                             next
[18:04:56.196]                           if (!grepl(pattern, name)) 
[18:04:56.196]                             next
[18:04:56.196]                           invokeRestart(restart)
[18:04:56.196]                           muffled <- TRUE
[18:04:56.196]                           break
[18:04:56.196]                         }
[18:04:56.196]                       }
[18:04:56.196]                     }
[18:04:56.196]                     invisible(muffled)
[18:04:56.196]                   }
[18:04:56.196]                   muffleCondition(cond)
[18:04:56.196]                 })
[18:04:56.196]             }))
[18:04:56.196]             future::FutureResult(value = ...future.value$value, 
[18:04:56.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.196]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.196]                     ...future.globalenv.names))
[18:04:56.196]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.196]         }, condition = base::local({
[18:04:56.196]             c <- base::c
[18:04:56.196]             inherits <- base::inherits
[18:04:56.196]             invokeRestart <- base::invokeRestart
[18:04:56.196]             length <- base::length
[18:04:56.196]             list <- base::list
[18:04:56.196]             seq.int <- base::seq.int
[18:04:56.196]             signalCondition <- base::signalCondition
[18:04:56.196]             sys.calls <- base::sys.calls
[18:04:56.196]             `[[` <- base::`[[`
[18:04:56.196]             `+` <- base::`+`
[18:04:56.196]             `<<-` <- base::`<<-`
[18:04:56.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.196]                   3L)]
[18:04:56.196]             }
[18:04:56.196]             function(cond) {
[18:04:56.196]                 is_error <- inherits(cond, "error")
[18:04:56.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.196]                   NULL)
[18:04:56.196]                 if (is_error) {
[18:04:56.196]                   sessionInformation <- function() {
[18:04:56.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.196]                       search = base::search(), system = base::Sys.info())
[18:04:56.196]                   }
[18:04:56.196]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.196]                     cond$call), session = sessionInformation(), 
[18:04:56.196]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.196]                   signalCondition(cond)
[18:04:56.196]                 }
[18:04:56.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.196]                 "immediateCondition"))) {
[18:04:56.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.196]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.196]                   if (TRUE && !signal) {
[18:04:56.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.196]                     {
[18:04:56.196]                       inherits <- base::inherits
[18:04:56.196]                       invokeRestart <- base::invokeRestart
[18:04:56.196]                       is.null <- base::is.null
[18:04:56.196]                       muffled <- FALSE
[18:04:56.196]                       if (inherits(cond, "message")) {
[18:04:56.196]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.196]                         if (muffled) 
[18:04:56.196]                           invokeRestart("muffleMessage")
[18:04:56.196]                       }
[18:04:56.196]                       else if (inherits(cond, "warning")) {
[18:04:56.196]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.196]                         if (muffled) 
[18:04:56.196]                           invokeRestart("muffleWarning")
[18:04:56.196]                       }
[18:04:56.196]                       else if (inherits(cond, "condition")) {
[18:04:56.196]                         if (!is.null(pattern)) {
[18:04:56.196]                           computeRestarts <- base::computeRestarts
[18:04:56.196]                           grepl <- base::grepl
[18:04:56.196]                           restarts <- computeRestarts(cond)
[18:04:56.196]                           for (restart in restarts) {
[18:04:56.196]                             name <- restart$name
[18:04:56.196]                             if (is.null(name)) 
[18:04:56.196]                               next
[18:04:56.196]                             if (!grepl(pattern, name)) 
[18:04:56.196]                               next
[18:04:56.196]                             invokeRestart(restart)
[18:04:56.196]                             muffled <- TRUE
[18:04:56.196]                             break
[18:04:56.196]                           }
[18:04:56.196]                         }
[18:04:56.196]                       }
[18:04:56.196]                       invisible(muffled)
[18:04:56.196]                     }
[18:04:56.196]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.196]                   }
[18:04:56.196]                 }
[18:04:56.196]                 else {
[18:04:56.196]                   if (TRUE) {
[18:04:56.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.196]                     {
[18:04:56.196]                       inherits <- base::inherits
[18:04:56.196]                       invokeRestart <- base::invokeRestart
[18:04:56.196]                       is.null <- base::is.null
[18:04:56.196]                       muffled <- FALSE
[18:04:56.196]                       if (inherits(cond, "message")) {
[18:04:56.196]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.196]                         if (muffled) 
[18:04:56.196]                           invokeRestart("muffleMessage")
[18:04:56.196]                       }
[18:04:56.196]                       else if (inherits(cond, "warning")) {
[18:04:56.196]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.196]                         if (muffled) 
[18:04:56.196]                           invokeRestart("muffleWarning")
[18:04:56.196]                       }
[18:04:56.196]                       else if (inherits(cond, "condition")) {
[18:04:56.196]                         if (!is.null(pattern)) {
[18:04:56.196]                           computeRestarts <- base::computeRestarts
[18:04:56.196]                           grepl <- base::grepl
[18:04:56.196]                           restarts <- computeRestarts(cond)
[18:04:56.196]                           for (restart in restarts) {
[18:04:56.196]                             name <- restart$name
[18:04:56.196]                             if (is.null(name)) 
[18:04:56.196]                               next
[18:04:56.196]                             if (!grepl(pattern, name)) 
[18:04:56.196]                               next
[18:04:56.196]                             invokeRestart(restart)
[18:04:56.196]                             muffled <- TRUE
[18:04:56.196]                             break
[18:04:56.196]                           }
[18:04:56.196]                         }
[18:04:56.196]                       }
[18:04:56.196]                       invisible(muffled)
[18:04:56.196]                     }
[18:04:56.196]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.196]                   }
[18:04:56.196]                 }
[18:04:56.196]             }
[18:04:56.196]         }))
[18:04:56.196]     }, error = function(ex) {
[18:04:56.196]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.196]                 ...future.rng), started = ...future.startTime, 
[18:04:56.196]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.196]             version = "1.8"), class = "FutureResult")
[18:04:56.196]     }, finally = {
[18:04:56.196]         if (!identical(...future.workdir, getwd())) 
[18:04:56.196]             setwd(...future.workdir)
[18:04:56.196]         {
[18:04:56.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.196]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.196]             }
[18:04:56.196]             base::options(...future.oldOptions)
[18:04:56.196]             if (.Platform$OS.type == "windows") {
[18:04:56.196]                 old_names <- names(...future.oldEnvVars)
[18:04:56.196]                 envs <- base::Sys.getenv()
[18:04:56.196]                 names <- names(envs)
[18:04:56.196]                 common <- intersect(names, old_names)
[18:04:56.196]                 added <- setdiff(names, old_names)
[18:04:56.196]                 removed <- setdiff(old_names, names)
[18:04:56.196]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.196]                   envs[common]]
[18:04:56.196]                 NAMES <- toupper(changed)
[18:04:56.196]                 args <- list()
[18:04:56.196]                 for (kk in seq_along(NAMES)) {
[18:04:56.196]                   name <- changed[[kk]]
[18:04:56.196]                   NAME <- NAMES[[kk]]
[18:04:56.196]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.196]                     next
[18:04:56.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.196]                 }
[18:04:56.196]                 NAMES <- toupper(added)
[18:04:56.196]                 for (kk in seq_along(NAMES)) {
[18:04:56.196]                   name <- added[[kk]]
[18:04:56.196]                   NAME <- NAMES[[kk]]
[18:04:56.196]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.196]                     next
[18:04:56.196]                   args[[name]] <- ""
[18:04:56.196]                 }
[18:04:56.196]                 NAMES <- toupper(removed)
[18:04:56.196]                 for (kk in seq_along(NAMES)) {
[18:04:56.196]                   name <- removed[[kk]]
[18:04:56.196]                   NAME <- NAMES[[kk]]
[18:04:56.196]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.196]                     next
[18:04:56.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.196]                 }
[18:04:56.196]                 if (length(args) > 0) 
[18:04:56.196]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.196]             }
[18:04:56.196]             else {
[18:04:56.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.196]             }
[18:04:56.196]             {
[18:04:56.196]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.196]                   0L) {
[18:04:56.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.196]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.196]                   base::options(opts)
[18:04:56.196]                 }
[18:04:56.196]                 {
[18:04:56.196]                   {
[18:04:56.196]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:56.196]                     NULL
[18:04:56.196]                   }
[18:04:56.196]                   options(future.plan = NULL)
[18:04:56.196]                   if (is.na(NA_character_)) 
[18:04:56.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.196]                     .init = FALSE)
[18:04:56.196]                 }
[18:04:56.196]             }
[18:04:56.196]         }
[18:04:56.196]     })
[18:04:56.196]     if (TRUE) {
[18:04:56.196]         base::sink(type = "output", split = FALSE)
[18:04:56.196]         if (TRUE) {
[18:04:56.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.196]         }
[18:04:56.196]         else {
[18:04:56.196]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.196]         }
[18:04:56.196]         base::close(...future.stdout)
[18:04:56.196]         ...future.stdout <- NULL
[18:04:56.196]     }
[18:04:56.196]     ...future.result$conditions <- ...future.conditions
[18:04:56.196]     ...future.result$finished <- base::Sys.time()
[18:04:56.196]     ...future.result
[18:04:56.196] }
[18:04:56.200] requestCore(): workers = 2
[18:04:56.205] MulticoreFuture started
[18:04:56.206] - Launch lazy future ... done
[18:04:56.206] run() for ‘MulticoreFuture’ ... done
[18:04:56.210] plan(): Setting new future strategy stack:
[18:04:56.216] result() for MulticoreFuture ...
[18:04:56.210] List of future strategies:
[18:04:56.210] 1. sequential:
[18:04:56.210]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.210]    - tweaked: FALSE
[18:04:56.210]    - call: NULL
[18:04:56.226] plan(): nbrOfWorkers() = 1
[18:04:56.230] plan(): Setting new future strategy stack:
[18:04:56.231] List of future strategies:
[18:04:56.231] 1. multicore:
[18:04:56.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.231]    - tweaked: FALSE
[18:04:56.231]    - call: plan(strategy)
[18:04:56.243] plan(): nbrOfWorkers() = 2
[18:04:56.256] result() for MulticoreFuture ...
[18:04:56.257] result() for MulticoreFuture ... done
[18:04:56.257] result() for MulticoreFuture ... done
[18:04:56.257] result() for MulticoreFuture ...
[18:04:56.257] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.259] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.259] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.263] - globals found: [3] ‘{’, ‘<-’, ‘*’
[18:04:56.263] Searching for globals ... DONE
[18:04:56.263] Resolving globals: TRUE
[18:04:56.264] Resolving any globals that are futures ...
[18:04:56.264] - globals: [3] ‘{’, ‘<-’, ‘*’
[18:04:56.264] Resolving any globals that are futures ... DONE
[18:04:56.265] 
[18:04:56.265] 
[18:04:56.266] getGlobalsAndPackages() ... DONE
[18:04:56.266] run() for ‘Future’ ...
[18:04:56.267] - state: ‘created’
[18:04:56.267] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:56.274] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:56.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:56.274]   - Field: ‘label’
[18:04:56.275]   - Field: ‘local’
[18:04:56.275]   - Field: ‘owner’
[18:04:56.275]   - Field: ‘envir’
[18:04:56.275]   - Field: ‘workers’
[18:04:56.276]   - Field: ‘packages’
[18:04:56.276]   - Field: ‘gc’
[18:04:56.276]   - Field: ‘job’
[18:04:56.276]   - Field: ‘conditions’
[18:04:56.277]   - Field: ‘expr’
[18:04:56.277]   - Field: ‘uuid’
[18:04:56.277]   - Field: ‘seed’
[18:04:56.277]   - Field: ‘version’
[18:04:56.277]   - Field: ‘result’
[18:04:56.278]   - Field: ‘asynchronous’
[18:04:56.278]   - Field: ‘calls’
[18:04:56.278]   - Field: ‘globals’
[18:04:56.278]   - Field: ‘stdout’
[18:04:56.279]   - Field: ‘earlySignal’
[18:04:56.279]   - Field: ‘lazy’
[18:04:56.279]   - Field: ‘state’
[18:04:56.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:56.280] - Launch lazy future ...
[18:04:56.280] Packages needed by the future expression (n = 0): <none>
[18:04:56.280] Packages needed by future strategies (n = 0): <none>
[18:04:56.281] {
[18:04:56.281]     {
[18:04:56.281]         {
[18:04:56.281]             ...future.startTime <- base::Sys.time()
[18:04:56.281]             {
[18:04:56.281]                 {
[18:04:56.281]                   {
[18:04:56.281]                     {
[18:04:56.281]                       base::local({
[18:04:56.281]                         has_future <- base::requireNamespace("future", 
[18:04:56.281]                           quietly = TRUE)
[18:04:56.281]                         if (has_future) {
[18:04:56.281]                           ns <- base::getNamespace("future")
[18:04:56.281]                           version <- ns[[".package"]][["version"]]
[18:04:56.281]                           if (is.null(version)) 
[18:04:56.281]                             version <- utils::packageVersion("future")
[18:04:56.281]                         }
[18:04:56.281]                         else {
[18:04:56.281]                           version <- NULL
[18:04:56.281]                         }
[18:04:56.281]                         if (!has_future || version < "1.8.0") {
[18:04:56.281]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.281]                             "", base::R.version$version.string), 
[18:04:56.281]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:56.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.281]                               "release", "version")], collapse = " "), 
[18:04:56.281]                             hostname = base::Sys.info()[["nodename"]])
[18:04:56.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.281]                             info)
[18:04:56.281]                           info <- base::paste(info, collapse = "; ")
[18:04:56.281]                           if (!has_future) {
[18:04:56.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.281]                               info)
[18:04:56.281]                           }
[18:04:56.281]                           else {
[18:04:56.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.281]                               info, version)
[18:04:56.281]                           }
[18:04:56.281]                           base::stop(msg)
[18:04:56.281]                         }
[18:04:56.281]                       })
[18:04:56.281]                     }
[18:04:56.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:56.281]                     base::options(mc.cores = 1L)
[18:04:56.281]                   }
[18:04:56.281]                   ...future.strategy.old <- future::plan("list")
[18:04:56.281]                   options(future.plan = NULL)
[18:04:56.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.281]                 }
[18:04:56.281]                 ...future.workdir <- getwd()
[18:04:56.281]             }
[18:04:56.281]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.281]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.281]         }
[18:04:56.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.281]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:56.281]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.281]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.281]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.281]             base::names(...future.oldOptions))
[18:04:56.281]     }
[18:04:56.281]     if (FALSE) {
[18:04:56.281]     }
[18:04:56.281]     else {
[18:04:56.281]         if (TRUE) {
[18:04:56.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.281]                 open = "w")
[18:04:56.281]         }
[18:04:56.281]         else {
[18:04:56.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.281]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.281]         }
[18:04:56.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.281]             base::sink(type = "output", split = FALSE)
[18:04:56.281]             base::close(...future.stdout)
[18:04:56.281]         }, add = TRUE)
[18:04:56.281]     }
[18:04:56.281]     ...future.frame <- base::sys.nframe()
[18:04:56.281]     ...future.conditions <- base::list()
[18:04:56.281]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.281]     if (FALSE) {
[18:04:56.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.281]     }
[18:04:56.281]     ...future.result <- base::tryCatch({
[18:04:56.281]         base::withCallingHandlers({
[18:04:56.281]             ...future.value <- base::withVisible(base::local({
[18:04:56.281]                 withCallingHandlers({
[18:04:56.281]                   {
[18:04:56.281]                     b <- a
[18:04:56.281]                     a <- 2
[18:04:56.281]                     a * b
[18:04:56.281]                   }
[18:04:56.281]                 }, immediateCondition = function(cond) {
[18:04:56.281]                   save_rds <- function (object, pathname, ...) 
[18:04:56.281]                   {
[18:04:56.281]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:56.281]                     if (file_test("-f", pathname_tmp)) {
[18:04:56.281]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.281]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:56.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.281]                         fi_tmp[["mtime"]])
[18:04:56.281]                     }
[18:04:56.281]                     tryCatch({
[18:04:56.281]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:56.281]                     }, error = function(ex) {
[18:04:56.281]                       msg <- conditionMessage(ex)
[18:04:56.281]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.281]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:56.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.281]                         fi_tmp[["mtime"]], msg)
[18:04:56.281]                       ex$message <- msg
[18:04:56.281]                       stop(ex)
[18:04:56.281]                     })
[18:04:56.281]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:56.281]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:56.281]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:56.281]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.281]                       fi <- file.info(pathname)
[18:04:56.281]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:56.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.281]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:56.281]                         fi[["size"]], fi[["mtime"]])
[18:04:56.281]                       stop(msg)
[18:04:56.281]                     }
[18:04:56.281]                     invisible(pathname)
[18:04:56.281]                   }
[18:04:56.281]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:56.281]                     rootPath = tempdir()) 
[18:04:56.281]                   {
[18:04:56.281]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:56.281]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:56.281]                       tmpdir = path, fileext = ".rds")
[18:04:56.281]                     save_rds(obj, file)
[18:04:56.281]                   }
[18:04:56.281]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:56.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.281]                   {
[18:04:56.281]                     inherits <- base::inherits
[18:04:56.281]                     invokeRestart <- base::invokeRestart
[18:04:56.281]                     is.null <- base::is.null
[18:04:56.281]                     muffled <- FALSE
[18:04:56.281]                     if (inherits(cond, "message")) {
[18:04:56.281]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:56.281]                       if (muffled) 
[18:04:56.281]                         invokeRestart("muffleMessage")
[18:04:56.281]                     }
[18:04:56.281]                     else if (inherits(cond, "warning")) {
[18:04:56.281]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:56.281]                       if (muffled) 
[18:04:56.281]                         invokeRestart("muffleWarning")
[18:04:56.281]                     }
[18:04:56.281]                     else if (inherits(cond, "condition")) {
[18:04:56.281]                       if (!is.null(pattern)) {
[18:04:56.281]                         computeRestarts <- base::computeRestarts
[18:04:56.281]                         grepl <- base::grepl
[18:04:56.281]                         restarts <- computeRestarts(cond)
[18:04:56.281]                         for (restart in restarts) {
[18:04:56.281]                           name <- restart$name
[18:04:56.281]                           if (is.null(name)) 
[18:04:56.281]                             next
[18:04:56.281]                           if (!grepl(pattern, name)) 
[18:04:56.281]                             next
[18:04:56.281]                           invokeRestart(restart)
[18:04:56.281]                           muffled <- TRUE
[18:04:56.281]                           break
[18:04:56.281]                         }
[18:04:56.281]                       }
[18:04:56.281]                     }
[18:04:56.281]                     invisible(muffled)
[18:04:56.281]                   }
[18:04:56.281]                   muffleCondition(cond)
[18:04:56.281]                 })
[18:04:56.281]             }))
[18:04:56.281]             future::FutureResult(value = ...future.value$value, 
[18:04:56.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.281]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.281]                     ...future.globalenv.names))
[18:04:56.281]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.281]         }, condition = base::local({
[18:04:56.281]             c <- base::c
[18:04:56.281]             inherits <- base::inherits
[18:04:56.281]             invokeRestart <- base::invokeRestart
[18:04:56.281]             length <- base::length
[18:04:56.281]             list <- base::list
[18:04:56.281]             seq.int <- base::seq.int
[18:04:56.281]             signalCondition <- base::signalCondition
[18:04:56.281]             sys.calls <- base::sys.calls
[18:04:56.281]             `[[` <- base::`[[`
[18:04:56.281]             `+` <- base::`+`
[18:04:56.281]             `<<-` <- base::`<<-`
[18:04:56.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.281]                   3L)]
[18:04:56.281]             }
[18:04:56.281]             function(cond) {
[18:04:56.281]                 is_error <- inherits(cond, "error")
[18:04:56.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.281]                   NULL)
[18:04:56.281]                 if (is_error) {
[18:04:56.281]                   sessionInformation <- function() {
[18:04:56.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.281]                       search = base::search(), system = base::Sys.info())
[18:04:56.281]                   }
[18:04:56.281]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.281]                     cond$call), session = sessionInformation(), 
[18:04:56.281]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.281]                   signalCondition(cond)
[18:04:56.281]                 }
[18:04:56.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.281]                 "immediateCondition"))) {
[18:04:56.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.281]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.281]                   if (TRUE && !signal) {
[18:04:56.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.281]                     {
[18:04:56.281]                       inherits <- base::inherits
[18:04:56.281]                       invokeRestart <- base::invokeRestart
[18:04:56.281]                       is.null <- base::is.null
[18:04:56.281]                       muffled <- FALSE
[18:04:56.281]                       if (inherits(cond, "message")) {
[18:04:56.281]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.281]                         if (muffled) 
[18:04:56.281]                           invokeRestart("muffleMessage")
[18:04:56.281]                       }
[18:04:56.281]                       else if (inherits(cond, "warning")) {
[18:04:56.281]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.281]                         if (muffled) 
[18:04:56.281]                           invokeRestart("muffleWarning")
[18:04:56.281]                       }
[18:04:56.281]                       else if (inherits(cond, "condition")) {
[18:04:56.281]                         if (!is.null(pattern)) {
[18:04:56.281]                           computeRestarts <- base::computeRestarts
[18:04:56.281]                           grepl <- base::grepl
[18:04:56.281]                           restarts <- computeRestarts(cond)
[18:04:56.281]                           for (restart in restarts) {
[18:04:56.281]                             name <- restart$name
[18:04:56.281]                             if (is.null(name)) 
[18:04:56.281]                               next
[18:04:56.281]                             if (!grepl(pattern, name)) 
[18:04:56.281]                               next
[18:04:56.281]                             invokeRestart(restart)
[18:04:56.281]                             muffled <- TRUE
[18:04:56.281]                             break
[18:04:56.281]                           }
[18:04:56.281]                         }
[18:04:56.281]                       }
[18:04:56.281]                       invisible(muffled)
[18:04:56.281]                     }
[18:04:56.281]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.281]                   }
[18:04:56.281]                 }
[18:04:56.281]                 else {
[18:04:56.281]                   if (TRUE) {
[18:04:56.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.281]                     {
[18:04:56.281]                       inherits <- base::inherits
[18:04:56.281]                       invokeRestart <- base::invokeRestart
[18:04:56.281]                       is.null <- base::is.null
[18:04:56.281]                       muffled <- FALSE
[18:04:56.281]                       if (inherits(cond, "message")) {
[18:04:56.281]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.281]                         if (muffled) 
[18:04:56.281]                           invokeRestart("muffleMessage")
[18:04:56.281]                       }
[18:04:56.281]                       else if (inherits(cond, "warning")) {
[18:04:56.281]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.281]                         if (muffled) 
[18:04:56.281]                           invokeRestart("muffleWarning")
[18:04:56.281]                       }
[18:04:56.281]                       else if (inherits(cond, "condition")) {
[18:04:56.281]                         if (!is.null(pattern)) {
[18:04:56.281]                           computeRestarts <- base::computeRestarts
[18:04:56.281]                           grepl <- base::grepl
[18:04:56.281]                           restarts <- computeRestarts(cond)
[18:04:56.281]                           for (restart in restarts) {
[18:04:56.281]                             name <- restart$name
[18:04:56.281]                             if (is.null(name)) 
[18:04:56.281]                               next
[18:04:56.281]                             if (!grepl(pattern, name)) 
[18:04:56.281]                               next
[18:04:56.281]                             invokeRestart(restart)
[18:04:56.281]                             muffled <- TRUE
[18:04:56.281]                             break
[18:04:56.281]                           }
[18:04:56.281]                         }
[18:04:56.281]                       }
[18:04:56.281]                       invisible(muffled)
[18:04:56.281]                     }
[18:04:56.281]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.281]                   }
[18:04:56.281]                 }
[18:04:56.281]             }
[18:04:56.281]         }))
[18:04:56.281]     }, error = function(ex) {
[18:04:56.281]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.281]                 ...future.rng), started = ...future.startTime, 
[18:04:56.281]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.281]             version = "1.8"), class = "FutureResult")
[18:04:56.281]     }, finally = {
[18:04:56.281]         if (!identical(...future.workdir, getwd())) 
[18:04:56.281]             setwd(...future.workdir)
[18:04:56.281]         {
[18:04:56.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.281]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.281]             }
[18:04:56.281]             base::options(...future.oldOptions)
[18:04:56.281]             if (.Platform$OS.type == "windows") {
[18:04:56.281]                 old_names <- names(...future.oldEnvVars)
[18:04:56.281]                 envs <- base::Sys.getenv()
[18:04:56.281]                 names <- names(envs)
[18:04:56.281]                 common <- intersect(names, old_names)
[18:04:56.281]                 added <- setdiff(names, old_names)
[18:04:56.281]                 removed <- setdiff(old_names, names)
[18:04:56.281]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.281]                   envs[common]]
[18:04:56.281]                 NAMES <- toupper(changed)
[18:04:56.281]                 args <- list()
[18:04:56.281]                 for (kk in seq_along(NAMES)) {
[18:04:56.281]                   name <- changed[[kk]]
[18:04:56.281]                   NAME <- NAMES[[kk]]
[18:04:56.281]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.281]                     next
[18:04:56.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.281]                 }
[18:04:56.281]                 NAMES <- toupper(added)
[18:04:56.281]                 for (kk in seq_along(NAMES)) {
[18:04:56.281]                   name <- added[[kk]]
[18:04:56.281]                   NAME <- NAMES[[kk]]
[18:04:56.281]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.281]                     next
[18:04:56.281]                   args[[name]] <- ""
[18:04:56.281]                 }
[18:04:56.281]                 NAMES <- toupper(removed)
[18:04:56.281]                 for (kk in seq_along(NAMES)) {
[18:04:56.281]                   name <- removed[[kk]]
[18:04:56.281]                   NAME <- NAMES[[kk]]
[18:04:56.281]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.281]                     next
[18:04:56.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.281]                 }
[18:04:56.281]                 if (length(args) > 0) 
[18:04:56.281]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.281]             }
[18:04:56.281]             else {
[18:04:56.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.281]             }
[18:04:56.281]             {
[18:04:56.281]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.281]                   0L) {
[18:04:56.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.281]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.281]                   base::options(opts)
[18:04:56.281]                 }
[18:04:56.281]                 {
[18:04:56.281]                   {
[18:04:56.281]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:56.281]                     NULL
[18:04:56.281]                   }
[18:04:56.281]                   options(future.plan = NULL)
[18:04:56.281]                   if (is.na(NA_character_)) 
[18:04:56.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.281]                     .init = FALSE)
[18:04:56.281]                 }
[18:04:56.281]             }
[18:04:56.281]         }
[18:04:56.281]     })
[18:04:56.281]     if (TRUE) {
[18:04:56.281]         base::sink(type = "output", split = FALSE)
[18:04:56.281]         if (TRUE) {
[18:04:56.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.281]         }
[18:04:56.281]         else {
[18:04:56.281]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.281]         }
[18:04:56.281]         base::close(...future.stdout)
[18:04:56.281]         ...future.stdout <- NULL
[18:04:56.281]     }
[18:04:56.281]     ...future.result$conditions <- ...future.conditions
[18:04:56.281]     ...future.result$finished <- base::Sys.time()
[18:04:56.281]     ...future.result
[18:04:56.281] }
[18:04:56.286] requestCore(): workers = 2
[18:04:56.289] MulticoreFuture started
[18:04:56.290] - Launch lazy future ... done
[18:04:56.291] run() for ‘MulticoreFuture’ ... done
[18:04:56.291] result() for MulticoreFuture ...
[18:04:56.291] plan(): Setting new future strategy stack:
[18:04:56.292] List of future strategies:
[18:04:56.292] 1. sequential:
[18:04:56.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.292]    - tweaked: FALSE
[18:04:56.292]    - call: NULL
[18:04:56.294] plan(): nbrOfWorkers() = 1
[18:04:56.298] plan(): Setting new future strategy stack:
[18:04:56.298] List of future strategies:
[18:04:56.298] 1. multicore:
[18:04:56.298]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.298]    - tweaked: FALSE
[18:04:56.298]    - call: plan(strategy)
[18:04:56.307] plan(): nbrOfWorkers() = 2
[18:04:56.318] result() for MulticoreFuture ...
[18:04:56.318] result() for MulticoreFuture ... done
[18:04:56.319] signalConditions() ...
[18:04:56.319]  - include = ‘immediateCondition’
[18:04:56.319]  - exclude = 
[18:04:56.320]  - resignal = FALSE
[18:04:56.320]  - Number of conditions: 1
[18:04:56.320] signalConditions() ... done
[18:04:56.320] result() for MulticoreFuture ... done
[18:04:56.321] result() for MulticoreFuture ...
[18:04:56.321] result() for MulticoreFuture ... done
[18:04:56.321] signalConditions() ...
[18:04:56.321]  - include = ‘immediateCondition’
[18:04:56.322]  - exclude = 
[18:04:56.322]  - resignal = FALSE
[18:04:56.322]  - Number of conditions: 1
[18:04:56.322] signalConditions() ... done
[18:04:56.323] Future state: ‘finished’
[18:04:56.323] result() for MulticoreFuture ...
[18:04:56.323] result() for MulticoreFuture ... done
[18:04:56.323] signalConditions() ...
[18:04:56.324]  - include = ‘condition’
[18:04:56.324]  - exclude = ‘immediateCondition’
[18:04:56.324]  - resignal = TRUE
[18:04:56.324]  - Number of conditions: 1
[18:04:56.324]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:56.325] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.8.0-48-generic" "#48-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 14:04:52 UTC 2024" "99adafdbb12a" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-21 18:04:56"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.383] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.384] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.387] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.387] Searching for globals ... DONE
[18:04:56.387] Resolving globals: TRUE
[18:04:56.387] Resolving any globals that are futures ...
[18:04:56.388] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.388] Resolving any globals that are futures ... DONE
[18:04:56.389] Resolving futures part of globals (recursively) ...
[18:04:56.389] resolve() on list ...
[18:04:56.389]  recursive: 99
[18:04:56.390]  length: 1
[18:04:56.390]  elements: ‘ii’
[18:04:56.390]  length: 0 (resolved future 1)
[18:04:56.390] resolve() on list ... DONE
[18:04:56.390] - globals: [1] ‘ii’
[18:04:56.391] Resolving futures part of globals (recursively) ... DONE
[18:04:56.391] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:56.392] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:56.392] - globals: [1] ‘ii’
[18:04:56.392] 
[18:04:56.392] getGlobalsAndPackages() ... DONE
[18:04:56.393] run() for ‘Future’ ...
[18:04:56.393] - state: ‘created’
[18:04:56.393] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:56.400] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:56.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:56.400]   - Field: ‘label’
[18:04:56.401]   - Field: ‘local’
[18:04:56.401]   - Field: ‘owner’
[18:04:56.401]   - Field: ‘envir’
[18:04:56.403]   - Field: ‘workers’
[18:04:56.404]   - Field: ‘packages’
[18:04:56.404]   - Field: ‘gc’
[18:04:56.404]   - Field: ‘job’
[18:04:56.404]   - Field: ‘conditions’
[18:04:56.405]   - Field: ‘expr’
[18:04:56.405]   - Field: ‘uuid’
[18:04:56.405]   - Field: ‘seed’
[18:04:56.405]   - Field: ‘version’
[18:04:56.405]   - Field: ‘result’
[18:04:56.406]   - Field: ‘asynchronous’
[18:04:56.406]   - Field: ‘calls’
[18:04:56.406]   - Field: ‘globals’
[18:04:56.406]   - Field: ‘stdout’
[18:04:56.406]   - Field: ‘earlySignal’
[18:04:56.407]   - Field: ‘lazy’
[18:04:56.407]   - Field: ‘state’
[18:04:56.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:56.407] - Launch lazy future ...
[18:04:56.408] Packages needed by the future expression (n = 0): <none>
[18:04:56.409] Packages needed by future strategies (n = 0): <none>
[18:04:56.409] {
[18:04:56.409]     {
[18:04:56.409]         {
[18:04:56.409]             ...future.startTime <- base::Sys.time()
[18:04:56.409]             {
[18:04:56.409]                 {
[18:04:56.409]                   {
[18:04:56.409]                     {
[18:04:56.409]                       base::local({
[18:04:56.409]                         has_future <- base::requireNamespace("future", 
[18:04:56.409]                           quietly = TRUE)
[18:04:56.409]                         if (has_future) {
[18:04:56.409]                           ns <- base::getNamespace("future")
[18:04:56.409]                           version <- ns[[".package"]][["version"]]
[18:04:56.409]                           if (is.null(version)) 
[18:04:56.409]                             version <- utils::packageVersion("future")
[18:04:56.409]                         }
[18:04:56.409]                         else {
[18:04:56.409]                           version <- NULL
[18:04:56.409]                         }
[18:04:56.409]                         if (!has_future || version < "1.8.0") {
[18:04:56.409]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.409]                             "", base::R.version$version.string), 
[18:04:56.409]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:56.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.409]                               "release", "version")], collapse = " "), 
[18:04:56.409]                             hostname = base::Sys.info()[["nodename"]])
[18:04:56.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.409]                             info)
[18:04:56.409]                           info <- base::paste(info, collapse = "; ")
[18:04:56.409]                           if (!has_future) {
[18:04:56.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.409]                               info)
[18:04:56.409]                           }
[18:04:56.409]                           else {
[18:04:56.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.409]                               info, version)
[18:04:56.409]                           }
[18:04:56.409]                           base::stop(msg)
[18:04:56.409]                         }
[18:04:56.409]                       })
[18:04:56.409]                     }
[18:04:56.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:56.409]                     base::options(mc.cores = 1L)
[18:04:56.409]                   }
[18:04:56.409]                   ...future.strategy.old <- future::plan("list")
[18:04:56.409]                   options(future.plan = NULL)
[18:04:56.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.409]                 }
[18:04:56.409]                 ...future.workdir <- getwd()
[18:04:56.409]             }
[18:04:56.409]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.409]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.409]         }
[18:04:56.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.409]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:56.409]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.409]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.409]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.409]             base::names(...future.oldOptions))
[18:04:56.409]     }
[18:04:56.409]     if (FALSE) {
[18:04:56.409]     }
[18:04:56.409]     else {
[18:04:56.409]         if (TRUE) {
[18:04:56.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.409]                 open = "w")
[18:04:56.409]         }
[18:04:56.409]         else {
[18:04:56.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.409]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.409]         }
[18:04:56.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.409]             base::sink(type = "output", split = FALSE)
[18:04:56.409]             base::close(...future.stdout)
[18:04:56.409]         }, add = TRUE)
[18:04:56.409]     }
[18:04:56.409]     ...future.frame <- base::sys.nframe()
[18:04:56.409]     ...future.conditions <- base::list()
[18:04:56.409]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.409]     if (FALSE) {
[18:04:56.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.409]     }
[18:04:56.409]     ...future.result <- base::tryCatch({
[18:04:56.409]         base::withCallingHandlers({
[18:04:56.409]             ...future.value <- base::withVisible(base::local({
[18:04:56.409]                 withCallingHandlers({
[18:04:56.409]                   {
[18:04:56.409]                     b <- a * ii
[18:04:56.409]                     a <- 0
[18:04:56.409]                     b
[18:04:56.409]                   }
[18:04:56.409]                 }, immediateCondition = function(cond) {
[18:04:56.409]                   save_rds <- function (object, pathname, ...) 
[18:04:56.409]                   {
[18:04:56.409]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:56.409]                     if (file_test("-f", pathname_tmp)) {
[18:04:56.409]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.409]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:56.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.409]                         fi_tmp[["mtime"]])
[18:04:56.409]                     }
[18:04:56.409]                     tryCatch({
[18:04:56.409]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:56.409]                     }, error = function(ex) {
[18:04:56.409]                       msg <- conditionMessage(ex)
[18:04:56.409]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.409]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:56.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.409]                         fi_tmp[["mtime"]], msg)
[18:04:56.409]                       ex$message <- msg
[18:04:56.409]                       stop(ex)
[18:04:56.409]                     })
[18:04:56.409]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:56.409]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:56.409]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:56.409]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.409]                       fi <- file.info(pathname)
[18:04:56.409]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:56.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.409]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:56.409]                         fi[["size"]], fi[["mtime"]])
[18:04:56.409]                       stop(msg)
[18:04:56.409]                     }
[18:04:56.409]                     invisible(pathname)
[18:04:56.409]                   }
[18:04:56.409]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:56.409]                     rootPath = tempdir()) 
[18:04:56.409]                   {
[18:04:56.409]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:56.409]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:56.409]                       tmpdir = path, fileext = ".rds")
[18:04:56.409]                     save_rds(obj, file)
[18:04:56.409]                   }
[18:04:56.409]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:56.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.409]                   {
[18:04:56.409]                     inherits <- base::inherits
[18:04:56.409]                     invokeRestart <- base::invokeRestart
[18:04:56.409]                     is.null <- base::is.null
[18:04:56.409]                     muffled <- FALSE
[18:04:56.409]                     if (inherits(cond, "message")) {
[18:04:56.409]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:56.409]                       if (muffled) 
[18:04:56.409]                         invokeRestart("muffleMessage")
[18:04:56.409]                     }
[18:04:56.409]                     else if (inherits(cond, "warning")) {
[18:04:56.409]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:56.409]                       if (muffled) 
[18:04:56.409]                         invokeRestart("muffleWarning")
[18:04:56.409]                     }
[18:04:56.409]                     else if (inherits(cond, "condition")) {
[18:04:56.409]                       if (!is.null(pattern)) {
[18:04:56.409]                         computeRestarts <- base::computeRestarts
[18:04:56.409]                         grepl <- base::grepl
[18:04:56.409]                         restarts <- computeRestarts(cond)
[18:04:56.409]                         for (restart in restarts) {
[18:04:56.409]                           name <- restart$name
[18:04:56.409]                           if (is.null(name)) 
[18:04:56.409]                             next
[18:04:56.409]                           if (!grepl(pattern, name)) 
[18:04:56.409]                             next
[18:04:56.409]                           invokeRestart(restart)
[18:04:56.409]                           muffled <- TRUE
[18:04:56.409]                           break
[18:04:56.409]                         }
[18:04:56.409]                       }
[18:04:56.409]                     }
[18:04:56.409]                     invisible(muffled)
[18:04:56.409]                   }
[18:04:56.409]                   muffleCondition(cond)
[18:04:56.409]                 })
[18:04:56.409]             }))
[18:04:56.409]             future::FutureResult(value = ...future.value$value, 
[18:04:56.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.409]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.409]                     ...future.globalenv.names))
[18:04:56.409]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.409]         }, condition = base::local({
[18:04:56.409]             c <- base::c
[18:04:56.409]             inherits <- base::inherits
[18:04:56.409]             invokeRestart <- base::invokeRestart
[18:04:56.409]             length <- base::length
[18:04:56.409]             list <- base::list
[18:04:56.409]             seq.int <- base::seq.int
[18:04:56.409]             signalCondition <- base::signalCondition
[18:04:56.409]             sys.calls <- base::sys.calls
[18:04:56.409]             `[[` <- base::`[[`
[18:04:56.409]             `+` <- base::`+`
[18:04:56.409]             `<<-` <- base::`<<-`
[18:04:56.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.409]                   3L)]
[18:04:56.409]             }
[18:04:56.409]             function(cond) {
[18:04:56.409]                 is_error <- inherits(cond, "error")
[18:04:56.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.409]                   NULL)
[18:04:56.409]                 if (is_error) {
[18:04:56.409]                   sessionInformation <- function() {
[18:04:56.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.409]                       search = base::search(), system = base::Sys.info())
[18:04:56.409]                   }
[18:04:56.409]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.409]                     cond$call), session = sessionInformation(), 
[18:04:56.409]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.409]                   signalCondition(cond)
[18:04:56.409]                 }
[18:04:56.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.409]                 "immediateCondition"))) {
[18:04:56.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.409]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.409]                   if (TRUE && !signal) {
[18:04:56.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.409]                     {
[18:04:56.409]                       inherits <- base::inherits
[18:04:56.409]                       invokeRestart <- base::invokeRestart
[18:04:56.409]                       is.null <- base::is.null
[18:04:56.409]                       muffled <- FALSE
[18:04:56.409]                       if (inherits(cond, "message")) {
[18:04:56.409]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.409]                         if (muffled) 
[18:04:56.409]                           invokeRestart("muffleMessage")
[18:04:56.409]                       }
[18:04:56.409]                       else if (inherits(cond, "warning")) {
[18:04:56.409]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.409]                         if (muffled) 
[18:04:56.409]                           invokeRestart("muffleWarning")
[18:04:56.409]                       }
[18:04:56.409]                       else if (inherits(cond, "condition")) {
[18:04:56.409]                         if (!is.null(pattern)) {
[18:04:56.409]                           computeRestarts <- base::computeRestarts
[18:04:56.409]                           grepl <- base::grepl
[18:04:56.409]                           restarts <- computeRestarts(cond)
[18:04:56.409]                           for (restart in restarts) {
[18:04:56.409]                             name <- restart$name
[18:04:56.409]                             if (is.null(name)) 
[18:04:56.409]                               next
[18:04:56.409]                             if (!grepl(pattern, name)) 
[18:04:56.409]                               next
[18:04:56.409]                             invokeRestart(restart)
[18:04:56.409]                             muffled <- TRUE
[18:04:56.409]                             break
[18:04:56.409]                           }
[18:04:56.409]                         }
[18:04:56.409]                       }
[18:04:56.409]                       invisible(muffled)
[18:04:56.409]                     }
[18:04:56.409]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.409]                   }
[18:04:56.409]                 }
[18:04:56.409]                 else {
[18:04:56.409]                   if (TRUE) {
[18:04:56.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.409]                     {
[18:04:56.409]                       inherits <- base::inherits
[18:04:56.409]                       invokeRestart <- base::invokeRestart
[18:04:56.409]                       is.null <- base::is.null
[18:04:56.409]                       muffled <- FALSE
[18:04:56.409]                       if (inherits(cond, "message")) {
[18:04:56.409]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.409]                         if (muffled) 
[18:04:56.409]                           invokeRestart("muffleMessage")
[18:04:56.409]                       }
[18:04:56.409]                       else if (inherits(cond, "warning")) {
[18:04:56.409]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.409]                         if (muffled) 
[18:04:56.409]                           invokeRestart("muffleWarning")
[18:04:56.409]                       }
[18:04:56.409]                       else if (inherits(cond, "condition")) {
[18:04:56.409]                         if (!is.null(pattern)) {
[18:04:56.409]                           computeRestarts <- base::computeRestarts
[18:04:56.409]                           grepl <- base::grepl
[18:04:56.409]                           restarts <- computeRestarts(cond)
[18:04:56.409]                           for (restart in restarts) {
[18:04:56.409]                             name <- restart$name
[18:04:56.409]                             if (is.null(name)) 
[18:04:56.409]                               next
[18:04:56.409]                             if (!grepl(pattern, name)) 
[18:04:56.409]                               next
[18:04:56.409]                             invokeRestart(restart)
[18:04:56.409]                             muffled <- TRUE
[18:04:56.409]                             break
[18:04:56.409]                           }
[18:04:56.409]                         }
[18:04:56.409]                       }
[18:04:56.409]                       invisible(muffled)
[18:04:56.409]                     }
[18:04:56.409]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.409]                   }
[18:04:56.409]                 }
[18:04:56.409]             }
[18:04:56.409]         }))
[18:04:56.409]     }, error = function(ex) {
[18:04:56.409]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.409]                 ...future.rng), started = ...future.startTime, 
[18:04:56.409]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.409]             version = "1.8"), class = "FutureResult")
[18:04:56.409]     }, finally = {
[18:04:56.409]         if (!identical(...future.workdir, getwd())) 
[18:04:56.409]             setwd(...future.workdir)
[18:04:56.409]         {
[18:04:56.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.409]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.409]             }
[18:04:56.409]             base::options(...future.oldOptions)
[18:04:56.409]             if (.Platform$OS.type == "windows") {
[18:04:56.409]                 old_names <- names(...future.oldEnvVars)
[18:04:56.409]                 envs <- base::Sys.getenv()
[18:04:56.409]                 names <- names(envs)
[18:04:56.409]                 common <- intersect(names, old_names)
[18:04:56.409]                 added <- setdiff(names, old_names)
[18:04:56.409]                 removed <- setdiff(old_names, names)
[18:04:56.409]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.409]                   envs[common]]
[18:04:56.409]                 NAMES <- toupper(changed)
[18:04:56.409]                 args <- list()
[18:04:56.409]                 for (kk in seq_along(NAMES)) {
[18:04:56.409]                   name <- changed[[kk]]
[18:04:56.409]                   NAME <- NAMES[[kk]]
[18:04:56.409]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.409]                     next
[18:04:56.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.409]                 }
[18:04:56.409]                 NAMES <- toupper(added)
[18:04:56.409]                 for (kk in seq_along(NAMES)) {
[18:04:56.409]                   name <- added[[kk]]
[18:04:56.409]                   NAME <- NAMES[[kk]]
[18:04:56.409]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.409]                     next
[18:04:56.409]                   args[[name]] <- ""
[18:04:56.409]                 }
[18:04:56.409]                 NAMES <- toupper(removed)
[18:04:56.409]                 for (kk in seq_along(NAMES)) {
[18:04:56.409]                   name <- removed[[kk]]
[18:04:56.409]                   NAME <- NAMES[[kk]]
[18:04:56.409]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.409]                     next
[18:04:56.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.409]                 }
[18:04:56.409]                 if (length(args) > 0) 
[18:04:56.409]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.409]             }
[18:04:56.409]             else {
[18:04:56.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.409]             }
[18:04:56.409]             {
[18:04:56.409]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.409]                   0L) {
[18:04:56.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.409]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.409]                   base::options(opts)
[18:04:56.409]                 }
[18:04:56.409]                 {
[18:04:56.409]                   {
[18:04:56.409]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:56.409]                     NULL
[18:04:56.409]                   }
[18:04:56.409]                   options(future.plan = NULL)
[18:04:56.409]                   if (is.na(NA_character_)) 
[18:04:56.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.409]                     .init = FALSE)
[18:04:56.409]                 }
[18:04:56.409]             }
[18:04:56.409]         }
[18:04:56.409]     })
[18:04:56.409]     if (TRUE) {
[18:04:56.409]         base::sink(type = "output", split = FALSE)
[18:04:56.409]         if (TRUE) {
[18:04:56.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.409]         }
[18:04:56.409]         else {
[18:04:56.409]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.409]         }
[18:04:56.409]         base::close(...future.stdout)
[18:04:56.409]         ...future.stdout <- NULL
[18:04:56.409]     }
[18:04:56.409]     ...future.result$conditions <- ...future.conditions
[18:04:56.409]     ...future.result$finished <- base::Sys.time()
[18:04:56.409]     ...future.result
[18:04:56.409] }
[18:04:56.414] assign_globals() ...
[18:04:56.414] List of 1
[18:04:56.414]  $ ii: int 1
[18:04:56.414]  - attr(*, "where")=List of 1
[18:04:56.414]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:56.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:56.414]  - attr(*, "resolved")= logi TRUE
[18:04:56.414]  - attr(*, "total_size")= num 56
[18:04:56.414]  - attr(*, "already-done")= logi TRUE
[18:04:56.419] - copied ‘ii’ to environment
[18:04:56.419] assign_globals() ... done
[18:04:56.419] requestCore(): workers = 2
[18:04:56.423] MulticoreFuture started
[18:04:56.424] - Launch lazy future ... done
[18:04:56.424] run() for ‘MulticoreFuture’ ... done
[18:04:56.425] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.427] getGlobalsAndPackages() ...
[18:04:56.426] List of future strategies:
[18:04:56.426] 1. sequential:
[18:04:56.426]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.426]    - tweaked: FALSE
[18:04:56.426]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.428] Searching for globals...
[18:04:56.428] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.432] plan(): Setting new future strategy stack:
[18:04:56.432] List of future strategies:
[18:04:56.432] 1. multicore:
[18:04:56.432]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.432]    - tweaked: FALSE
[18:04:56.432]    - call: plan(strategy)
[18:04:56.434] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.434] Searching for globals ... DONE
[18:04:56.435] Resolving globals: TRUE
[18:04:56.435] Resolving any globals that are futures ...
[18:04:56.436] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.436] Resolving any globals that are futures ... DONE
[18:04:56.437] Resolving futures part of globals (recursively) ...
[18:04:56.439] resolve() on list ...
[18:04:56.439]  recursive: 99
[18:04:56.440]  length: 1
[18:04:56.440]  elements: ‘ii’
[18:04:56.440]  length: 0 (resolved future 1)
[18:04:56.441] resolve() on list ... DONE
[18:04:56.441] - globals: [1] ‘ii’
[18:04:56.441] plan(): nbrOfWorkers() = 2
[18:04:56.441] Resolving futures part of globals (recursively) ... DONE
[18:04:56.442] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:56.443] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:56.444] - globals: [1] ‘ii’
[18:04:56.444] 
[18:04:56.444] getGlobalsAndPackages() ... DONE
[18:04:56.445] run() for ‘Future’ ...
[18:04:56.445] - state: ‘created’
[18:04:56.446] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:56.454] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:56.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:56.454]   - Field: ‘label’
[18:04:56.455]   - Field: ‘local’
[18:04:56.455]   - Field: ‘owner’
[18:04:56.456]   - Field: ‘envir’
[18:04:56.456]   - Field: ‘workers’
[18:04:56.456]   - Field: ‘packages’
[18:04:56.456]   - Field: ‘gc’
[18:04:56.457]   - Field: ‘job’
[18:04:56.457]   - Field: ‘conditions’
[18:04:56.457]   - Field: ‘expr’
[18:04:56.458]   - Field: ‘uuid’
[18:04:56.458]   - Field: ‘seed’
[18:04:56.458]   - Field: ‘version’
[18:04:56.459]   - Field: ‘result’
[18:04:56.459]   - Field: ‘asynchronous’
[18:04:56.459]   - Field: ‘calls’
[18:04:56.459]   - Field: ‘globals’
[18:04:56.460]   - Field: ‘stdout’
[18:04:56.460]   - Field: ‘earlySignal’
[18:04:56.460]   - Field: ‘lazy’
[18:04:56.461]   - Field: ‘state’
[18:04:56.461] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:56.461] - Launch lazy future ...
[18:04:56.462] Packages needed by the future expression (n = 0): <none>
[18:04:56.463] Packages needed by future strategies (n = 0): <none>
[18:04:56.464] {
[18:04:56.464]     {
[18:04:56.464]         {
[18:04:56.464]             ...future.startTime <- base::Sys.time()
[18:04:56.464]             {
[18:04:56.464]                 {
[18:04:56.464]                   {
[18:04:56.464]                     {
[18:04:56.464]                       base::local({
[18:04:56.464]                         has_future <- base::requireNamespace("future", 
[18:04:56.464]                           quietly = TRUE)
[18:04:56.464]                         if (has_future) {
[18:04:56.464]                           ns <- base::getNamespace("future")
[18:04:56.464]                           version <- ns[[".package"]][["version"]]
[18:04:56.464]                           if (is.null(version)) 
[18:04:56.464]                             version <- utils::packageVersion("future")
[18:04:56.464]                         }
[18:04:56.464]                         else {
[18:04:56.464]                           version <- NULL
[18:04:56.464]                         }
[18:04:56.464]                         if (!has_future || version < "1.8.0") {
[18:04:56.464]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.464]                             "", base::R.version$version.string), 
[18:04:56.464]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:56.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.464]                               "release", "version")], collapse = " "), 
[18:04:56.464]                             hostname = base::Sys.info()[["nodename"]])
[18:04:56.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.464]                             info)
[18:04:56.464]                           info <- base::paste(info, collapse = "; ")
[18:04:56.464]                           if (!has_future) {
[18:04:56.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.464]                               info)
[18:04:56.464]                           }
[18:04:56.464]                           else {
[18:04:56.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.464]                               info, version)
[18:04:56.464]                           }
[18:04:56.464]                           base::stop(msg)
[18:04:56.464]                         }
[18:04:56.464]                       })
[18:04:56.464]                     }
[18:04:56.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:56.464]                     base::options(mc.cores = 1L)
[18:04:56.464]                   }
[18:04:56.464]                   ...future.strategy.old <- future::plan("list")
[18:04:56.464]                   options(future.plan = NULL)
[18:04:56.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.464]                 }
[18:04:56.464]                 ...future.workdir <- getwd()
[18:04:56.464]             }
[18:04:56.464]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.464]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.464]         }
[18:04:56.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.464]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:56.464]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.464]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.464]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.464]             base::names(...future.oldOptions))
[18:04:56.464]     }
[18:04:56.464]     if (FALSE) {
[18:04:56.464]     }
[18:04:56.464]     else {
[18:04:56.464]         if (TRUE) {
[18:04:56.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.464]                 open = "w")
[18:04:56.464]         }
[18:04:56.464]         else {
[18:04:56.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.464]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.464]         }
[18:04:56.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.464]             base::sink(type = "output", split = FALSE)
[18:04:56.464]             base::close(...future.stdout)
[18:04:56.464]         }, add = TRUE)
[18:04:56.464]     }
[18:04:56.464]     ...future.frame <- base::sys.nframe()
[18:04:56.464]     ...future.conditions <- base::list()
[18:04:56.464]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.464]     if (FALSE) {
[18:04:56.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.464]     }
[18:04:56.464]     ...future.result <- base::tryCatch({
[18:04:56.464]         base::withCallingHandlers({
[18:04:56.464]             ...future.value <- base::withVisible(base::local({
[18:04:56.464]                 withCallingHandlers({
[18:04:56.464]                   {
[18:04:56.464]                     b <- a * ii
[18:04:56.464]                     a <- 0
[18:04:56.464]                     b
[18:04:56.464]                   }
[18:04:56.464]                 }, immediateCondition = function(cond) {
[18:04:56.464]                   save_rds <- function (object, pathname, ...) 
[18:04:56.464]                   {
[18:04:56.464]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:56.464]                     if (file_test("-f", pathname_tmp)) {
[18:04:56.464]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.464]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:56.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.464]                         fi_tmp[["mtime"]])
[18:04:56.464]                     }
[18:04:56.464]                     tryCatch({
[18:04:56.464]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:56.464]                     }, error = function(ex) {
[18:04:56.464]                       msg <- conditionMessage(ex)
[18:04:56.464]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.464]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:56.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.464]                         fi_tmp[["mtime"]], msg)
[18:04:56.464]                       ex$message <- msg
[18:04:56.464]                       stop(ex)
[18:04:56.464]                     })
[18:04:56.464]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:56.464]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:56.464]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:56.464]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.464]                       fi <- file.info(pathname)
[18:04:56.464]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:56.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.464]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:56.464]                         fi[["size"]], fi[["mtime"]])
[18:04:56.464]                       stop(msg)
[18:04:56.464]                     }
[18:04:56.464]                     invisible(pathname)
[18:04:56.464]                   }
[18:04:56.464]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:56.464]                     rootPath = tempdir()) 
[18:04:56.464]                   {
[18:04:56.464]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:56.464]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:56.464]                       tmpdir = path, fileext = ".rds")
[18:04:56.464]                     save_rds(obj, file)
[18:04:56.464]                   }
[18:04:56.464]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:56.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.464]                   {
[18:04:56.464]                     inherits <- base::inherits
[18:04:56.464]                     invokeRestart <- base::invokeRestart
[18:04:56.464]                     is.null <- base::is.null
[18:04:56.464]                     muffled <- FALSE
[18:04:56.464]                     if (inherits(cond, "message")) {
[18:04:56.464]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:56.464]                       if (muffled) 
[18:04:56.464]                         invokeRestart("muffleMessage")
[18:04:56.464]                     }
[18:04:56.464]                     else if (inherits(cond, "warning")) {
[18:04:56.464]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:56.464]                       if (muffled) 
[18:04:56.464]                         invokeRestart("muffleWarning")
[18:04:56.464]                     }
[18:04:56.464]                     else if (inherits(cond, "condition")) {
[18:04:56.464]                       if (!is.null(pattern)) {
[18:04:56.464]                         computeRestarts <- base::computeRestarts
[18:04:56.464]                         grepl <- base::grepl
[18:04:56.464]                         restarts <- computeRestarts(cond)
[18:04:56.464]                         for (restart in restarts) {
[18:04:56.464]                           name <- restart$name
[18:04:56.464]                           if (is.null(name)) 
[18:04:56.464]                             next
[18:04:56.464]                           if (!grepl(pattern, name)) 
[18:04:56.464]                             next
[18:04:56.464]                           invokeRestart(restart)
[18:04:56.464]                           muffled <- TRUE
[18:04:56.464]                           break
[18:04:56.464]                         }
[18:04:56.464]                       }
[18:04:56.464]                     }
[18:04:56.464]                     invisible(muffled)
[18:04:56.464]                   }
[18:04:56.464]                   muffleCondition(cond)
[18:04:56.464]                 })
[18:04:56.464]             }))
[18:04:56.464]             future::FutureResult(value = ...future.value$value, 
[18:04:56.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.464]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.464]                     ...future.globalenv.names))
[18:04:56.464]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.464]         }, condition = base::local({
[18:04:56.464]             c <- base::c
[18:04:56.464]             inherits <- base::inherits
[18:04:56.464]             invokeRestart <- base::invokeRestart
[18:04:56.464]             length <- base::length
[18:04:56.464]             list <- base::list
[18:04:56.464]             seq.int <- base::seq.int
[18:04:56.464]             signalCondition <- base::signalCondition
[18:04:56.464]             sys.calls <- base::sys.calls
[18:04:56.464]             `[[` <- base::`[[`
[18:04:56.464]             `+` <- base::`+`
[18:04:56.464]             `<<-` <- base::`<<-`
[18:04:56.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.464]                   3L)]
[18:04:56.464]             }
[18:04:56.464]             function(cond) {
[18:04:56.464]                 is_error <- inherits(cond, "error")
[18:04:56.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.464]                   NULL)
[18:04:56.464]                 if (is_error) {
[18:04:56.464]                   sessionInformation <- function() {
[18:04:56.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.464]                       search = base::search(), system = base::Sys.info())
[18:04:56.464]                   }
[18:04:56.464]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.464]                     cond$call), session = sessionInformation(), 
[18:04:56.464]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.464]                   signalCondition(cond)
[18:04:56.464]                 }
[18:04:56.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.464]                 "immediateCondition"))) {
[18:04:56.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.464]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.464]                   if (TRUE && !signal) {
[18:04:56.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.464]                     {
[18:04:56.464]                       inherits <- base::inherits
[18:04:56.464]                       invokeRestart <- base::invokeRestart
[18:04:56.464]                       is.null <- base::is.null
[18:04:56.464]                       muffled <- FALSE
[18:04:56.464]                       if (inherits(cond, "message")) {
[18:04:56.464]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.464]                         if (muffled) 
[18:04:56.464]                           invokeRestart("muffleMessage")
[18:04:56.464]                       }
[18:04:56.464]                       else if (inherits(cond, "warning")) {
[18:04:56.464]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.464]                         if (muffled) 
[18:04:56.464]                           invokeRestart("muffleWarning")
[18:04:56.464]                       }
[18:04:56.464]                       else if (inherits(cond, "condition")) {
[18:04:56.464]                         if (!is.null(pattern)) {
[18:04:56.464]                           computeRestarts <- base::computeRestarts
[18:04:56.464]                           grepl <- base::grepl
[18:04:56.464]                           restarts <- computeRestarts(cond)
[18:04:56.464]                           for (restart in restarts) {
[18:04:56.464]                             name <- restart$name
[18:04:56.464]                             if (is.null(name)) 
[18:04:56.464]                               next
[18:04:56.464]                             if (!grepl(pattern, name)) 
[18:04:56.464]                               next
[18:04:56.464]                             invokeRestart(restart)
[18:04:56.464]                             muffled <- TRUE
[18:04:56.464]                             break
[18:04:56.464]                           }
[18:04:56.464]                         }
[18:04:56.464]                       }
[18:04:56.464]                       invisible(muffled)
[18:04:56.464]                     }
[18:04:56.464]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.464]                   }
[18:04:56.464]                 }
[18:04:56.464]                 else {
[18:04:56.464]                   if (TRUE) {
[18:04:56.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.464]                     {
[18:04:56.464]                       inherits <- base::inherits
[18:04:56.464]                       invokeRestart <- base::invokeRestart
[18:04:56.464]                       is.null <- base::is.null
[18:04:56.464]                       muffled <- FALSE
[18:04:56.464]                       if (inherits(cond, "message")) {
[18:04:56.464]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.464]                         if (muffled) 
[18:04:56.464]                           invokeRestart("muffleMessage")
[18:04:56.464]                       }
[18:04:56.464]                       else if (inherits(cond, "warning")) {
[18:04:56.464]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.464]                         if (muffled) 
[18:04:56.464]                           invokeRestart("muffleWarning")
[18:04:56.464]                       }
[18:04:56.464]                       else if (inherits(cond, "condition")) {
[18:04:56.464]                         if (!is.null(pattern)) {
[18:04:56.464]                           computeRestarts <- base::computeRestarts
[18:04:56.464]                           grepl <- base::grepl
[18:04:56.464]                           restarts <- computeRestarts(cond)
[18:04:56.464]                           for (restart in restarts) {
[18:04:56.464]                             name <- restart$name
[18:04:56.464]                             if (is.null(name)) 
[18:04:56.464]                               next
[18:04:56.464]                             if (!grepl(pattern, name)) 
[18:04:56.464]                               next
[18:04:56.464]                             invokeRestart(restart)
[18:04:56.464]                             muffled <- TRUE
[18:04:56.464]                             break
[18:04:56.464]                           }
[18:04:56.464]                         }
[18:04:56.464]                       }
[18:04:56.464]                       invisible(muffled)
[18:04:56.464]                     }
[18:04:56.464]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.464]                   }
[18:04:56.464]                 }
[18:04:56.464]             }
[18:04:56.464]         }))
[18:04:56.464]     }, error = function(ex) {
[18:04:56.464]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.464]                 ...future.rng), started = ...future.startTime, 
[18:04:56.464]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.464]             version = "1.8"), class = "FutureResult")
[18:04:56.464]     }, finally = {
[18:04:56.464]         if (!identical(...future.workdir, getwd())) 
[18:04:56.464]             setwd(...future.workdir)
[18:04:56.464]         {
[18:04:56.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.464]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.464]             }
[18:04:56.464]             base::options(...future.oldOptions)
[18:04:56.464]             if (.Platform$OS.type == "windows") {
[18:04:56.464]                 old_names <- names(...future.oldEnvVars)
[18:04:56.464]                 envs <- base::Sys.getenv()
[18:04:56.464]                 names <- names(envs)
[18:04:56.464]                 common <- intersect(names, old_names)
[18:04:56.464]                 added <- setdiff(names, old_names)
[18:04:56.464]                 removed <- setdiff(old_names, names)
[18:04:56.464]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.464]                   envs[common]]
[18:04:56.464]                 NAMES <- toupper(changed)
[18:04:56.464]                 args <- list()
[18:04:56.464]                 for (kk in seq_along(NAMES)) {
[18:04:56.464]                   name <- changed[[kk]]
[18:04:56.464]                   NAME <- NAMES[[kk]]
[18:04:56.464]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.464]                     next
[18:04:56.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.464]                 }
[18:04:56.464]                 NAMES <- toupper(added)
[18:04:56.464]                 for (kk in seq_along(NAMES)) {
[18:04:56.464]                   name <- added[[kk]]
[18:04:56.464]                   NAME <- NAMES[[kk]]
[18:04:56.464]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.464]                     next
[18:04:56.464]                   args[[name]] <- ""
[18:04:56.464]                 }
[18:04:56.464]                 NAMES <- toupper(removed)
[18:04:56.464]                 for (kk in seq_along(NAMES)) {
[18:04:56.464]                   name <- removed[[kk]]
[18:04:56.464]                   NAME <- NAMES[[kk]]
[18:04:56.464]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.464]                     next
[18:04:56.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.464]                 }
[18:04:56.464]                 if (length(args) > 0) 
[18:04:56.464]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.464]             }
[18:04:56.464]             else {
[18:04:56.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.464]             }
[18:04:56.464]             {
[18:04:56.464]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.464]                   0L) {
[18:04:56.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.464]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.464]                   base::options(opts)
[18:04:56.464]                 }
[18:04:56.464]                 {
[18:04:56.464]                   {
[18:04:56.464]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:56.464]                     NULL
[18:04:56.464]                   }
[18:04:56.464]                   options(future.plan = NULL)
[18:04:56.464]                   if (is.na(NA_character_)) 
[18:04:56.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.464]                     .init = FALSE)
[18:04:56.464]                 }
[18:04:56.464]             }
[18:04:56.464]         }
[18:04:56.464]     })
[18:04:56.464]     if (TRUE) {
[18:04:56.464]         base::sink(type = "output", split = FALSE)
[18:04:56.464]         if (TRUE) {
[18:04:56.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.464]         }
[18:04:56.464]         else {
[18:04:56.464]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.464]         }
[18:04:56.464]         base::close(...future.stdout)
[18:04:56.464]         ...future.stdout <- NULL
[18:04:56.464]     }
[18:04:56.464]     ...future.result$conditions <- ...future.conditions
[18:04:56.464]     ...future.result$finished <- base::Sys.time()
[18:04:56.464]     ...future.result
[18:04:56.464] }
[18:04:56.470] assign_globals() ...
[18:04:56.470] List of 1
[18:04:56.470]  $ ii: int 2
[18:04:56.470]  - attr(*, "where")=List of 1
[18:04:56.470]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:56.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:56.470]  - attr(*, "resolved")= logi TRUE
[18:04:56.470]  - attr(*, "total_size")= num 56
[18:04:56.470]  - attr(*, "already-done")= logi TRUE
[18:04:56.479] - copied ‘ii’ to environment
[18:04:56.479] assign_globals() ... done
[18:04:56.479] requestCore(): workers = 2
[18:04:56.483] MulticoreFuture started
[18:04:56.484] - Launch lazy future ... done
[18:04:56.484] run() for ‘MulticoreFuture’ ... done
[18:04:56.485] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.487] getGlobalsAndPackages() ...
[18:04:56.486] List of future strategies:
[18:04:56.486] 1. sequential:
[18:04:56.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.486]    - tweaked: FALSE
[18:04:56.486]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.488] Searching for globals...
[18:04:56.488] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.492] plan(): Setting new future strategy stack:
[18:04:56.492] List of future strategies:
[18:04:56.492] 1. multicore:
[18:04:56.492]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.492]    - tweaked: FALSE
[18:04:56.492]    - call: plan(strategy)
[18:04:56.494] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.494] Searching for globals ... DONE
[18:04:56.495] Resolving globals: TRUE
[18:04:56.495] Resolving any globals that are futures ...
[18:04:56.495] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.503] Resolving any globals that are futures ... DONE
[18:04:56.506] Resolving futures part of globals (recursively) ...
[18:04:56.508] resolve() on list ...
[18:04:56.509]  recursive: 99
[18:04:56.510]  length: 1
[18:04:56.510]  elements: ‘ii’
[18:04:56.511] plan(): nbrOfWorkers() = 2
[18:04:56.511]  length: 0 (resolved future 1)
[18:04:56.512] resolve() on list ... DONE
[18:04:56.512] - globals: [1] ‘ii’
[18:04:56.513] Resolving futures part of globals (recursively) ... DONE
[18:04:56.514] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:56.516] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:56.516] - globals: [1] ‘ii’
[18:04:56.517] 
[18:04:56.517] getGlobalsAndPackages() ... DONE
[18:04:56.518] run() for ‘Future’ ...
[18:04:56.518] - state: ‘created’
[18:04:56.519] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:56.527] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:56.528] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:56.528]   - Field: ‘label’
[18:04:56.528]   - Field: ‘local’
[18:04:56.529]   - Field: ‘owner’
[18:04:56.529]   - Field: ‘envir’
[18:04:56.530]   - Field: ‘workers’
[18:04:56.530]   - Field: ‘packages’
[18:04:56.530]   - Field: ‘gc’
[18:04:56.531]   - Field: ‘job’
[18:04:56.531]   - Field: ‘conditions’
[18:04:56.531]   - Field: ‘expr’
[18:04:56.532]   - Field: ‘uuid’
[18:04:56.532]   - Field: ‘seed’
[18:04:56.532]   - Field: ‘version’
[18:04:56.533]   - Field: ‘result’
[18:04:56.533]   - Field: ‘asynchronous’
[18:04:56.533]   - Field: ‘calls’
[18:04:56.533]   - Field: ‘globals’
[18:04:56.534]   - Field: ‘stdout’
[18:04:56.534]   - Field: ‘earlySignal’
[18:04:56.534]   - Field: ‘lazy’
[18:04:56.535]   - Field: ‘state’
[18:04:56.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:56.535] - Launch lazy future ...
[18:04:56.536] Packages needed by the future expression (n = 0): <none>
[18:04:56.536] Packages needed by future strategies (n = 0): <none>
[18:04:56.538] {
[18:04:56.538]     {
[18:04:56.538]         {
[18:04:56.538]             ...future.startTime <- base::Sys.time()
[18:04:56.538]             {
[18:04:56.538]                 {
[18:04:56.538]                   {
[18:04:56.538]                     {
[18:04:56.538]                       base::local({
[18:04:56.538]                         has_future <- base::requireNamespace("future", 
[18:04:56.538]                           quietly = TRUE)
[18:04:56.538]                         if (has_future) {
[18:04:56.538]                           ns <- base::getNamespace("future")
[18:04:56.538]                           version <- ns[[".package"]][["version"]]
[18:04:56.538]                           if (is.null(version)) 
[18:04:56.538]                             version <- utils::packageVersion("future")
[18:04:56.538]                         }
[18:04:56.538]                         else {
[18:04:56.538]                           version <- NULL
[18:04:56.538]                         }
[18:04:56.538]                         if (!has_future || version < "1.8.0") {
[18:04:56.538]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.538]                             "", base::R.version$version.string), 
[18:04:56.538]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:56.538]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.538]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.538]                               "release", "version")], collapse = " "), 
[18:04:56.538]                             hostname = base::Sys.info()[["nodename"]])
[18:04:56.538]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.538]                             info)
[18:04:56.538]                           info <- base::paste(info, collapse = "; ")
[18:04:56.538]                           if (!has_future) {
[18:04:56.538]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.538]                               info)
[18:04:56.538]                           }
[18:04:56.538]                           else {
[18:04:56.538]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.538]                               info, version)
[18:04:56.538]                           }
[18:04:56.538]                           base::stop(msg)
[18:04:56.538]                         }
[18:04:56.538]                       })
[18:04:56.538]                     }
[18:04:56.538]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:56.538]                     base::options(mc.cores = 1L)
[18:04:56.538]                   }
[18:04:56.538]                   ...future.strategy.old <- future::plan("list")
[18:04:56.538]                   options(future.plan = NULL)
[18:04:56.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.538]                 }
[18:04:56.538]                 ...future.workdir <- getwd()
[18:04:56.538]             }
[18:04:56.538]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.538]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.538]         }
[18:04:56.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.538]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:56.538]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.538]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.538]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.538]             base::names(...future.oldOptions))
[18:04:56.538]     }
[18:04:56.538]     if (FALSE) {
[18:04:56.538]     }
[18:04:56.538]     else {
[18:04:56.538]         if (TRUE) {
[18:04:56.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.538]                 open = "w")
[18:04:56.538]         }
[18:04:56.538]         else {
[18:04:56.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.538]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.538]         }
[18:04:56.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.538]             base::sink(type = "output", split = FALSE)
[18:04:56.538]             base::close(...future.stdout)
[18:04:56.538]         }, add = TRUE)
[18:04:56.538]     }
[18:04:56.538]     ...future.frame <- base::sys.nframe()
[18:04:56.538]     ...future.conditions <- base::list()
[18:04:56.538]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.538]     if (FALSE) {
[18:04:56.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.538]     }
[18:04:56.538]     ...future.result <- base::tryCatch({
[18:04:56.538]         base::withCallingHandlers({
[18:04:56.538]             ...future.value <- base::withVisible(base::local({
[18:04:56.538]                 withCallingHandlers({
[18:04:56.538]                   {
[18:04:56.538]                     b <- a * ii
[18:04:56.538]                     a <- 0
[18:04:56.538]                     b
[18:04:56.538]                   }
[18:04:56.538]                 }, immediateCondition = function(cond) {
[18:04:56.538]                   save_rds <- function (object, pathname, ...) 
[18:04:56.538]                   {
[18:04:56.538]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:56.538]                     if (file_test("-f", pathname_tmp)) {
[18:04:56.538]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.538]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:56.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.538]                         fi_tmp[["mtime"]])
[18:04:56.538]                     }
[18:04:56.538]                     tryCatch({
[18:04:56.538]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:56.538]                     }, error = function(ex) {
[18:04:56.538]                       msg <- conditionMessage(ex)
[18:04:56.538]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.538]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:56.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.538]                         fi_tmp[["mtime"]], msg)
[18:04:56.538]                       ex$message <- msg
[18:04:56.538]                       stop(ex)
[18:04:56.538]                     })
[18:04:56.538]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:56.538]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:56.538]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:56.538]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.538]                       fi <- file.info(pathname)
[18:04:56.538]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:56.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.538]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:56.538]                         fi[["size"]], fi[["mtime"]])
[18:04:56.538]                       stop(msg)
[18:04:56.538]                     }
[18:04:56.538]                     invisible(pathname)
[18:04:56.538]                   }
[18:04:56.538]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:56.538]                     rootPath = tempdir()) 
[18:04:56.538]                   {
[18:04:56.538]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:56.538]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:56.538]                       tmpdir = path, fileext = ".rds")
[18:04:56.538]                     save_rds(obj, file)
[18:04:56.538]                   }
[18:04:56.538]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:56.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.538]                   {
[18:04:56.538]                     inherits <- base::inherits
[18:04:56.538]                     invokeRestart <- base::invokeRestart
[18:04:56.538]                     is.null <- base::is.null
[18:04:56.538]                     muffled <- FALSE
[18:04:56.538]                     if (inherits(cond, "message")) {
[18:04:56.538]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:56.538]                       if (muffled) 
[18:04:56.538]                         invokeRestart("muffleMessage")
[18:04:56.538]                     }
[18:04:56.538]                     else if (inherits(cond, "warning")) {
[18:04:56.538]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:56.538]                       if (muffled) 
[18:04:56.538]                         invokeRestart("muffleWarning")
[18:04:56.538]                     }
[18:04:56.538]                     else if (inherits(cond, "condition")) {
[18:04:56.538]                       if (!is.null(pattern)) {
[18:04:56.538]                         computeRestarts <- base::computeRestarts
[18:04:56.538]                         grepl <- base::grepl
[18:04:56.538]                         restarts <- computeRestarts(cond)
[18:04:56.538]                         for (restart in restarts) {
[18:04:56.538]                           name <- restart$name
[18:04:56.538]                           if (is.null(name)) 
[18:04:56.538]                             next
[18:04:56.538]                           if (!grepl(pattern, name)) 
[18:04:56.538]                             next
[18:04:56.538]                           invokeRestart(restart)
[18:04:56.538]                           muffled <- TRUE
[18:04:56.538]                           break
[18:04:56.538]                         }
[18:04:56.538]                       }
[18:04:56.538]                     }
[18:04:56.538]                     invisible(muffled)
[18:04:56.538]                   }
[18:04:56.538]                   muffleCondition(cond)
[18:04:56.538]                 })
[18:04:56.538]             }))
[18:04:56.538]             future::FutureResult(value = ...future.value$value, 
[18:04:56.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.538]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.538]                     ...future.globalenv.names))
[18:04:56.538]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.538]         }, condition = base::local({
[18:04:56.538]             c <- base::c
[18:04:56.538]             inherits <- base::inherits
[18:04:56.538]             invokeRestart <- base::invokeRestart
[18:04:56.538]             length <- base::length
[18:04:56.538]             list <- base::list
[18:04:56.538]             seq.int <- base::seq.int
[18:04:56.538]             signalCondition <- base::signalCondition
[18:04:56.538]             sys.calls <- base::sys.calls
[18:04:56.538]             `[[` <- base::`[[`
[18:04:56.538]             `+` <- base::`+`
[18:04:56.538]             `<<-` <- base::`<<-`
[18:04:56.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.538]                   3L)]
[18:04:56.538]             }
[18:04:56.538]             function(cond) {
[18:04:56.538]                 is_error <- inherits(cond, "error")
[18:04:56.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.538]                   NULL)
[18:04:56.538]                 if (is_error) {
[18:04:56.538]                   sessionInformation <- function() {
[18:04:56.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.538]                       search = base::search(), system = base::Sys.info())
[18:04:56.538]                   }
[18:04:56.538]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.538]                     cond$call), session = sessionInformation(), 
[18:04:56.538]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.538]                   signalCondition(cond)
[18:04:56.538]                 }
[18:04:56.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.538]                 "immediateCondition"))) {
[18:04:56.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.538]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.538]                   if (TRUE && !signal) {
[18:04:56.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.538]                     {
[18:04:56.538]                       inherits <- base::inherits
[18:04:56.538]                       invokeRestart <- base::invokeRestart
[18:04:56.538]                       is.null <- base::is.null
[18:04:56.538]                       muffled <- FALSE
[18:04:56.538]                       if (inherits(cond, "message")) {
[18:04:56.538]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.538]                         if (muffled) 
[18:04:56.538]                           invokeRestart("muffleMessage")
[18:04:56.538]                       }
[18:04:56.538]                       else if (inherits(cond, "warning")) {
[18:04:56.538]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.538]                         if (muffled) 
[18:04:56.538]                           invokeRestart("muffleWarning")
[18:04:56.538]                       }
[18:04:56.538]                       else if (inherits(cond, "condition")) {
[18:04:56.538]                         if (!is.null(pattern)) {
[18:04:56.538]                           computeRestarts <- base::computeRestarts
[18:04:56.538]                           grepl <- base::grepl
[18:04:56.538]                           restarts <- computeRestarts(cond)
[18:04:56.538]                           for (restart in restarts) {
[18:04:56.538]                             name <- restart$name
[18:04:56.538]                             if (is.null(name)) 
[18:04:56.538]                               next
[18:04:56.538]                             if (!grepl(pattern, name)) 
[18:04:56.538]                               next
[18:04:56.538]                             invokeRestart(restart)
[18:04:56.538]                             muffled <- TRUE
[18:04:56.538]                             break
[18:04:56.538]                           }
[18:04:56.538]                         }
[18:04:56.538]                       }
[18:04:56.538]                       invisible(muffled)
[18:04:56.538]                     }
[18:04:56.538]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.538]                   }
[18:04:56.538]                 }
[18:04:56.538]                 else {
[18:04:56.538]                   if (TRUE) {
[18:04:56.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.538]                     {
[18:04:56.538]                       inherits <- base::inherits
[18:04:56.538]                       invokeRestart <- base::invokeRestart
[18:04:56.538]                       is.null <- base::is.null
[18:04:56.538]                       muffled <- FALSE
[18:04:56.538]                       if (inherits(cond, "message")) {
[18:04:56.538]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.538]                         if (muffled) 
[18:04:56.538]                           invokeRestart("muffleMessage")
[18:04:56.538]                       }
[18:04:56.538]                       else if (inherits(cond, "warning")) {
[18:04:56.538]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.538]                         if (muffled) 
[18:04:56.538]                           invokeRestart("muffleWarning")
[18:04:56.538]                       }
[18:04:56.538]                       else if (inherits(cond, "condition")) {
[18:04:56.538]                         if (!is.null(pattern)) {
[18:04:56.538]                           computeRestarts <- base::computeRestarts
[18:04:56.538]                           grepl <- base::grepl
[18:04:56.538]                           restarts <- computeRestarts(cond)
[18:04:56.538]                           for (restart in restarts) {
[18:04:56.538]                             name <- restart$name
[18:04:56.538]                             if (is.null(name)) 
[18:04:56.538]                               next
[18:04:56.538]                             if (!grepl(pattern, name)) 
[18:04:56.538]                               next
[18:04:56.538]                             invokeRestart(restart)
[18:04:56.538]                             muffled <- TRUE
[18:04:56.538]                             break
[18:04:56.538]                           }
[18:04:56.538]                         }
[18:04:56.538]                       }
[18:04:56.538]                       invisible(muffled)
[18:04:56.538]                     }
[18:04:56.538]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.538]                   }
[18:04:56.538]                 }
[18:04:56.538]             }
[18:04:56.538]         }))
[18:04:56.538]     }, error = function(ex) {
[18:04:56.538]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.538]                 ...future.rng), started = ...future.startTime, 
[18:04:56.538]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.538]             version = "1.8"), class = "FutureResult")
[18:04:56.538]     }, finally = {
[18:04:56.538]         if (!identical(...future.workdir, getwd())) 
[18:04:56.538]             setwd(...future.workdir)
[18:04:56.538]         {
[18:04:56.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.538]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.538]             }
[18:04:56.538]             base::options(...future.oldOptions)
[18:04:56.538]             if (.Platform$OS.type == "windows") {
[18:04:56.538]                 old_names <- names(...future.oldEnvVars)
[18:04:56.538]                 envs <- base::Sys.getenv()
[18:04:56.538]                 names <- names(envs)
[18:04:56.538]                 common <- intersect(names, old_names)
[18:04:56.538]                 added <- setdiff(names, old_names)
[18:04:56.538]                 removed <- setdiff(old_names, names)
[18:04:56.538]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.538]                   envs[common]]
[18:04:56.538]                 NAMES <- toupper(changed)
[18:04:56.538]                 args <- list()
[18:04:56.538]                 for (kk in seq_along(NAMES)) {
[18:04:56.538]                   name <- changed[[kk]]
[18:04:56.538]                   NAME <- NAMES[[kk]]
[18:04:56.538]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.538]                     next
[18:04:56.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.538]                 }
[18:04:56.538]                 NAMES <- toupper(added)
[18:04:56.538]                 for (kk in seq_along(NAMES)) {
[18:04:56.538]                   name <- added[[kk]]
[18:04:56.538]                   NAME <- NAMES[[kk]]
[18:04:56.538]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.538]                     next
[18:04:56.538]                   args[[name]] <- ""
[18:04:56.538]                 }
[18:04:56.538]                 NAMES <- toupper(removed)
[18:04:56.538]                 for (kk in seq_along(NAMES)) {
[18:04:56.538]                   name <- removed[[kk]]
[18:04:56.538]                   NAME <- NAMES[[kk]]
[18:04:56.538]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.538]                     next
[18:04:56.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.538]                 }
[18:04:56.538]                 if (length(args) > 0) 
[18:04:56.538]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.538]             }
[18:04:56.538]             else {
[18:04:56.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.538]             }
[18:04:56.538]             {
[18:04:56.538]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.538]                   0L) {
[18:04:56.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.538]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.538]                   base::options(opts)
[18:04:56.538]                 }
[18:04:56.538]                 {
[18:04:56.538]                   {
[18:04:56.538]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:56.538]                     NULL
[18:04:56.538]                   }
[18:04:56.538]                   options(future.plan = NULL)
[18:04:56.538]                   if (is.na(NA_character_)) 
[18:04:56.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.538]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.538]                     .init = FALSE)
[18:04:56.538]                 }
[18:04:56.538]             }
[18:04:56.538]         }
[18:04:56.538]     })
[18:04:56.538]     if (TRUE) {
[18:04:56.538]         base::sink(type = "output", split = FALSE)
[18:04:56.538]         if (TRUE) {
[18:04:56.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.538]         }
[18:04:56.538]         else {
[18:04:56.538]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.538]         }
[18:04:56.538]         base::close(...future.stdout)
[18:04:56.538]         ...future.stdout <- NULL
[18:04:56.538]     }
[18:04:56.538]     ...future.result$conditions <- ...future.conditions
[18:04:56.538]     ...future.result$finished <- base::Sys.time()
[18:04:56.538]     ...future.result
[18:04:56.538] }
[18:04:56.543] assign_globals() ...
[18:04:56.543] List of 1
[18:04:56.543]  $ ii: int 3
[18:04:56.543]  - attr(*, "where")=List of 1
[18:04:56.543]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:56.543]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:56.543]  - attr(*, "resolved")= logi TRUE
[18:04:56.543]  - attr(*, "total_size")= num 56
[18:04:56.543]  - attr(*, "already-done")= logi TRUE
[18:04:56.552] - copied ‘ii’ to environment
[18:04:56.552] assign_globals() ... done
[18:04:56.552] requestCore(): workers = 2
[18:04:56.553] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:56.565] result() for MulticoreFuture ...
[18:04:56.567] result() for MulticoreFuture ...
[18:04:56.567] result() for MulticoreFuture ... done
[18:04:56.568] result() for MulticoreFuture ... done
[18:04:56.568] result() for MulticoreFuture ...
[18:04:56.568] result() for MulticoreFuture ... done
[18:04:56.573] MulticoreFuture started
[18:04:56.576] - Launch lazy future ... done
[18:04:56.577] run() for ‘MulticoreFuture’ ... done
[18:04:56.579] plan(): Setting new future strategy stack:
[18:04:56.580] result() for MulticoreFuture ...
[18:04:56.580] result() for MulticoreFuture ... done
[18:04:56.581] result() for MulticoreFuture ...
[18:04:56.581] result() for MulticoreFuture ... done
[18:04:56.579] List of future strategies:
[18:04:56.579] 1. sequential:
[18:04:56.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.579]    - tweaked: FALSE
[18:04:56.579]    - call: NULL
[18:04:56.584] result() for MulticoreFuture ...
[18:04:56.586] plan(): nbrOfWorkers() = 1
[18:04:56.589] result() for MulticoreFuture ...
[18:04:56.589] result() for MulticoreFuture ... done
[18:04:56.592] result() for MulticoreFuture ... done
[18:04:56.592] result() for MulticoreFuture ...
[18:04:56.593] result() for MulticoreFuture ... done
[18:04:56.594] plan(): Setting new future strategy stack:
[18:04:56.594] List of future strategies:
[18:04:56.594] 1. multicore:
[18:04:56.594]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.594]    - tweaked: FALSE
[18:04:56.594]    - call: plan(strategy)
[18:04:56.593] result() for MulticoreFuture ...
[18:04:56.605] plan(): nbrOfWorkers() = 2
[18:04:56.606] result() for MulticoreFuture ...
[18:04:56.607] result() for MulticoreFuture ... done
[18:04:56.607] result() for MulticoreFuture ... done
[18:04:56.607] result() for MulticoreFuture ...
[18:04:56.607] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.612] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.613] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.617] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.617] Searching for globals ... DONE
[18:04:56.618] Resolving globals: TRUE
[18:04:56.618] Resolving any globals that are futures ...
[18:04:56.618] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.618] Resolving any globals that are futures ... DONE
[18:04:56.619] Resolving futures part of globals (recursively) ...
[18:04:56.620] resolve() on list ...
[18:04:56.621]  recursive: 99
[18:04:56.621]  length: 1
[18:04:56.621]  elements: ‘ii’
[18:04:56.621]  length: 0 (resolved future 1)
[18:04:56.622] resolve() on list ... DONE
[18:04:56.622] - globals: [1] ‘ii’
[18:04:56.622] Resolving futures part of globals (recursively) ... DONE
[18:04:56.623] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:56.623] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:56.624] - globals: [1] ‘ii’
[18:04:56.624] 
[18:04:56.624] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.626] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.626] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.630] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.630] Searching for globals ... DONE
[18:04:56.631] Resolving globals: TRUE
[18:04:56.631] Resolving any globals that are futures ...
[18:04:56.631] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.635] Resolving any globals that are futures ... DONE
[18:04:56.636] Resolving futures part of globals (recursively) ...
[18:04:56.637] resolve() on list ...
[18:04:56.637]  recursive: 99
[18:04:56.637]  length: 1
[18:04:56.638]  elements: ‘ii’
[18:04:56.638]  length: 0 (resolved future 1)
[18:04:56.639] resolve() on list ... DONE
[18:04:56.639] - globals: [1] ‘ii’
[18:04:56.639] Resolving futures part of globals (recursively) ... DONE
[18:04:56.640] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:56.641] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:56.641] - globals: [1] ‘ii’
[18:04:56.641] 
[18:04:56.641] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.643] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.643] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.647] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.647] Searching for globals ... DONE
[18:04:56.648] Resolving globals: TRUE
[18:04:56.648] Resolving any globals that are futures ...
[18:04:56.648] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:04:56.648] Resolving any globals that are futures ... DONE
[18:04:56.649] Resolving futures part of globals (recursively) ...
[18:04:56.650] resolve() on list ...
[18:04:56.650]  recursive: 99
[18:04:56.650]  length: 1
[18:04:56.650]  elements: ‘ii’
[18:04:56.651]  length: 0 (resolved future 1)
[18:04:56.651] resolve() on list ... DONE
[18:04:56.651] - globals: [1] ‘ii’
[18:04:56.651] Resolving futures part of globals (recursively) ... DONE
[18:04:56.652] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:56.653] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:04:56.653] - globals: [1] ‘ii’
[18:04:56.653] 
[18:04:56.653] getGlobalsAndPackages() ... DONE
[18:04:56.654] run() for ‘Future’ ...
[18:04:56.654] - state: ‘created’
[18:04:56.655] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:56.662] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:56.662] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:56.662]   - Field: ‘label’
[18:04:56.663]   - Field: ‘local’
[18:04:56.663]   - Field: ‘owner’
[18:04:56.663]   - Field: ‘envir’
[18:04:56.664]   - Field: ‘workers’
[18:04:56.664]   - Field: ‘packages’
[18:04:56.664]   - Field: ‘gc’
[18:04:56.664]   - Field: ‘job’
[18:04:56.665]   - Field: ‘conditions’
[18:04:56.665]   - Field: ‘expr’
[18:04:56.665]   - Field: ‘uuid’
[18:04:56.665]   - Field: ‘seed’
[18:04:56.665]   - Field: ‘version’
[18:04:56.666]   - Field: ‘result’
[18:04:56.666]   - Field: ‘asynchronous’
[18:04:56.666]   - Field: ‘calls’
[18:04:56.666]   - Field: ‘globals’
[18:04:56.667]   - Field: ‘stdout’
[18:04:56.667]   - Field: ‘earlySignal’
[18:04:56.667]   - Field: ‘lazy’
[18:04:56.667]   - Field: ‘state’
[18:04:56.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:56.668] - Launch lazy future ...
[18:04:56.668] Packages needed by the future expression (n = 0): <none>
[18:04:56.669] Packages needed by future strategies (n = 0): <none>
[18:04:56.670] {
[18:04:56.670]     {
[18:04:56.670]         {
[18:04:56.670]             ...future.startTime <- base::Sys.time()
[18:04:56.670]             {
[18:04:56.670]                 {
[18:04:56.670]                   {
[18:04:56.670]                     {
[18:04:56.670]                       base::local({
[18:04:56.670]                         has_future <- base::requireNamespace("future", 
[18:04:56.670]                           quietly = TRUE)
[18:04:56.670]                         if (has_future) {
[18:04:56.670]                           ns <- base::getNamespace("future")
[18:04:56.670]                           version <- ns[[".package"]][["version"]]
[18:04:56.670]                           if (is.null(version)) 
[18:04:56.670]                             version <- utils::packageVersion("future")
[18:04:56.670]                         }
[18:04:56.670]                         else {
[18:04:56.670]                           version <- NULL
[18:04:56.670]                         }
[18:04:56.670]                         if (!has_future || version < "1.8.0") {
[18:04:56.670]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.670]                             "", base::R.version$version.string), 
[18:04:56.670]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:56.670]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.670]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.670]                               "release", "version")], collapse = " "), 
[18:04:56.670]                             hostname = base::Sys.info()[["nodename"]])
[18:04:56.670]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.670]                             info)
[18:04:56.670]                           info <- base::paste(info, collapse = "; ")
[18:04:56.670]                           if (!has_future) {
[18:04:56.670]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.670]                               info)
[18:04:56.670]                           }
[18:04:56.670]                           else {
[18:04:56.670]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.670]                               info, version)
[18:04:56.670]                           }
[18:04:56.670]                           base::stop(msg)
[18:04:56.670]                         }
[18:04:56.670]                       })
[18:04:56.670]                     }
[18:04:56.670]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:56.670]                     base::options(mc.cores = 1L)
[18:04:56.670]                   }
[18:04:56.670]                   ...future.strategy.old <- future::plan("list")
[18:04:56.670]                   options(future.plan = NULL)
[18:04:56.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.670]                 }
[18:04:56.670]                 ...future.workdir <- getwd()
[18:04:56.670]             }
[18:04:56.670]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.670]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.670]         }
[18:04:56.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.670]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:56.670]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.670]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.670]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.670]             base::names(...future.oldOptions))
[18:04:56.670]     }
[18:04:56.670]     if (FALSE) {
[18:04:56.670]     }
[18:04:56.670]     else {
[18:04:56.670]         if (TRUE) {
[18:04:56.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.670]                 open = "w")
[18:04:56.670]         }
[18:04:56.670]         else {
[18:04:56.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.670]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.670]         }
[18:04:56.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.670]             base::sink(type = "output", split = FALSE)
[18:04:56.670]             base::close(...future.stdout)
[18:04:56.670]         }, add = TRUE)
[18:04:56.670]     }
[18:04:56.670]     ...future.frame <- base::sys.nframe()
[18:04:56.670]     ...future.conditions <- base::list()
[18:04:56.670]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.670]     if (FALSE) {
[18:04:56.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.670]     }
[18:04:56.670]     ...future.result <- base::tryCatch({
[18:04:56.670]         base::withCallingHandlers({
[18:04:56.670]             ...future.value <- base::withVisible(base::local({
[18:04:56.670]                 withCallingHandlers({
[18:04:56.670]                   {
[18:04:56.670]                     b <- a * ii
[18:04:56.670]                     a <- 0
[18:04:56.670]                     b
[18:04:56.670]                   }
[18:04:56.670]                 }, immediateCondition = function(cond) {
[18:04:56.670]                   save_rds <- function (object, pathname, ...) 
[18:04:56.670]                   {
[18:04:56.670]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:56.670]                     if (file_test("-f", pathname_tmp)) {
[18:04:56.670]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.670]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:56.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.670]                         fi_tmp[["mtime"]])
[18:04:56.670]                     }
[18:04:56.670]                     tryCatch({
[18:04:56.670]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:56.670]                     }, error = function(ex) {
[18:04:56.670]                       msg <- conditionMessage(ex)
[18:04:56.670]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.670]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:56.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.670]                         fi_tmp[["mtime"]], msg)
[18:04:56.670]                       ex$message <- msg
[18:04:56.670]                       stop(ex)
[18:04:56.670]                     })
[18:04:56.670]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:56.670]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:56.670]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:56.670]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.670]                       fi <- file.info(pathname)
[18:04:56.670]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:56.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.670]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:56.670]                         fi[["size"]], fi[["mtime"]])
[18:04:56.670]                       stop(msg)
[18:04:56.670]                     }
[18:04:56.670]                     invisible(pathname)
[18:04:56.670]                   }
[18:04:56.670]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:56.670]                     rootPath = tempdir()) 
[18:04:56.670]                   {
[18:04:56.670]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:56.670]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:56.670]                       tmpdir = path, fileext = ".rds")
[18:04:56.670]                     save_rds(obj, file)
[18:04:56.670]                   }
[18:04:56.670]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:56.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.670]                   {
[18:04:56.670]                     inherits <- base::inherits
[18:04:56.670]                     invokeRestart <- base::invokeRestart
[18:04:56.670]                     is.null <- base::is.null
[18:04:56.670]                     muffled <- FALSE
[18:04:56.670]                     if (inherits(cond, "message")) {
[18:04:56.670]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:56.670]                       if (muffled) 
[18:04:56.670]                         invokeRestart("muffleMessage")
[18:04:56.670]                     }
[18:04:56.670]                     else if (inherits(cond, "warning")) {
[18:04:56.670]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:56.670]                       if (muffled) 
[18:04:56.670]                         invokeRestart("muffleWarning")
[18:04:56.670]                     }
[18:04:56.670]                     else if (inherits(cond, "condition")) {
[18:04:56.670]                       if (!is.null(pattern)) {
[18:04:56.670]                         computeRestarts <- base::computeRestarts
[18:04:56.670]                         grepl <- base::grepl
[18:04:56.670]                         restarts <- computeRestarts(cond)
[18:04:56.670]                         for (restart in restarts) {
[18:04:56.670]                           name <- restart$name
[18:04:56.670]                           if (is.null(name)) 
[18:04:56.670]                             next
[18:04:56.670]                           if (!grepl(pattern, name)) 
[18:04:56.670]                             next
[18:04:56.670]                           invokeRestart(restart)
[18:04:56.670]                           muffled <- TRUE
[18:04:56.670]                           break
[18:04:56.670]                         }
[18:04:56.670]                       }
[18:04:56.670]                     }
[18:04:56.670]                     invisible(muffled)
[18:04:56.670]                   }
[18:04:56.670]                   muffleCondition(cond)
[18:04:56.670]                 })
[18:04:56.670]             }))
[18:04:56.670]             future::FutureResult(value = ...future.value$value, 
[18:04:56.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.670]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.670]                     ...future.globalenv.names))
[18:04:56.670]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.670]         }, condition = base::local({
[18:04:56.670]             c <- base::c
[18:04:56.670]             inherits <- base::inherits
[18:04:56.670]             invokeRestart <- base::invokeRestart
[18:04:56.670]             length <- base::length
[18:04:56.670]             list <- base::list
[18:04:56.670]             seq.int <- base::seq.int
[18:04:56.670]             signalCondition <- base::signalCondition
[18:04:56.670]             sys.calls <- base::sys.calls
[18:04:56.670]             `[[` <- base::`[[`
[18:04:56.670]             `+` <- base::`+`
[18:04:56.670]             `<<-` <- base::`<<-`
[18:04:56.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.670]                   3L)]
[18:04:56.670]             }
[18:04:56.670]             function(cond) {
[18:04:56.670]                 is_error <- inherits(cond, "error")
[18:04:56.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.670]                   NULL)
[18:04:56.670]                 if (is_error) {
[18:04:56.670]                   sessionInformation <- function() {
[18:04:56.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.670]                       search = base::search(), system = base::Sys.info())
[18:04:56.670]                   }
[18:04:56.670]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.670]                     cond$call), session = sessionInformation(), 
[18:04:56.670]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.670]                   signalCondition(cond)
[18:04:56.670]                 }
[18:04:56.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.670]                 "immediateCondition"))) {
[18:04:56.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.670]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.670]                   if (TRUE && !signal) {
[18:04:56.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.670]                     {
[18:04:56.670]                       inherits <- base::inherits
[18:04:56.670]                       invokeRestart <- base::invokeRestart
[18:04:56.670]                       is.null <- base::is.null
[18:04:56.670]                       muffled <- FALSE
[18:04:56.670]                       if (inherits(cond, "message")) {
[18:04:56.670]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.670]                         if (muffled) 
[18:04:56.670]                           invokeRestart("muffleMessage")
[18:04:56.670]                       }
[18:04:56.670]                       else if (inherits(cond, "warning")) {
[18:04:56.670]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.670]                         if (muffled) 
[18:04:56.670]                           invokeRestart("muffleWarning")
[18:04:56.670]                       }
[18:04:56.670]                       else if (inherits(cond, "condition")) {
[18:04:56.670]                         if (!is.null(pattern)) {
[18:04:56.670]                           computeRestarts <- base::computeRestarts
[18:04:56.670]                           grepl <- base::grepl
[18:04:56.670]                           restarts <- computeRestarts(cond)
[18:04:56.670]                           for (restart in restarts) {
[18:04:56.670]                             name <- restart$name
[18:04:56.670]                             if (is.null(name)) 
[18:04:56.670]                               next
[18:04:56.670]                             if (!grepl(pattern, name)) 
[18:04:56.670]                               next
[18:04:56.670]                             invokeRestart(restart)
[18:04:56.670]                             muffled <- TRUE
[18:04:56.670]                             break
[18:04:56.670]                           }
[18:04:56.670]                         }
[18:04:56.670]                       }
[18:04:56.670]                       invisible(muffled)
[18:04:56.670]                     }
[18:04:56.670]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.670]                   }
[18:04:56.670]                 }
[18:04:56.670]                 else {
[18:04:56.670]                   if (TRUE) {
[18:04:56.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.670]                     {
[18:04:56.670]                       inherits <- base::inherits
[18:04:56.670]                       invokeRestart <- base::invokeRestart
[18:04:56.670]                       is.null <- base::is.null
[18:04:56.670]                       muffled <- FALSE
[18:04:56.670]                       if (inherits(cond, "message")) {
[18:04:56.670]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.670]                         if (muffled) 
[18:04:56.670]                           invokeRestart("muffleMessage")
[18:04:56.670]                       }
[18:04:56.670]                       else if (inherits(cond, "warning")) {
[18:04:56.670]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.670]                         if (muffled) 
[18:04:56.670]                           invokeRestart("muffleWarning")
[18:04:56.670]                       }
[18:04:56.670]                       else if (inherits(cond, "condition")) {
[18:04:56.670]                         if (!is.null(pattern)) {
[18:04:56.670]                           computeRestarts <- base::computeRestarts
[18:04:56.670]                           grepl <- base::grepl
[18:04:56.670]                           restarts <- computeRestarts(cond)
[18:04:56.670]                           for (restart in restarts) {
[18:04:56.670]                             name <- restart$name
[18:04:56.670]                             if (is.null(name)) 
[18:04:56.670]                               next
[18:04:56.670]                             if (!grepl(pattern, name)) 
[18:04:56.670]                               next
[18:04:56.670]                             invokeRestart(restart)
[18:04:56.670]                             muffled <- TRUE
[18:04:56.670]                             break
[18:04:56.670]                           }
[18:04:56.670]                         }
[18:04:56.670]                       }
[18:04:56.670]                       invisible(muffled)
[18:04:56.670]                     }
[18:04:56.670]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.670]                   }
[18:04:56.670]                 }
[18:04:56.670]             }
[18:04:56.670]         }))
[18:04:56.670]     }, error = function(ex) {
[18:04:56.670]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.670]                 ...future.rng), started = ...future.startTime, 
[18:04:56.670]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.670]             version = "1.8"), class = "FutureResult")
[18:04:56.670]     }, finally = {
[18:04:56.670]         if (!identical(...future.workdir, getwd())) 
[18:04:56.670]             setwd(...future.workdir)
[18:04:56.670]         {
[18:04:56.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.670]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.670]             }
[18:04:56.670]             base::options(...future.oldOptions)
[18:04:56.670]             if (.Platform$OS.type == "windows") {
[18:04:56.670]                 old_names <- names(...future.oldEnvVars)
[18:04:56.670]                 envs <- base::Sys.getenv()
[18:04:56.670]                 names <- names(envs)
[18:04:56.670]                 common <- intersect(names, old_names)
[18:04:56.670]                 added <- setdiff(names, old_names)
[18:04:56.670]                 removed <- setdiff(old_names, names)
[18:04:56.670]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.670]                   envs[common]]
[18:04:56.670]                 NAMES <- toupper(changed)
[18:04:56.670]                 args <- list()
[18:04:56.670]                 for (kk in seq_along(NAMES)) {
[18:04:56.670]                   name <- changed[[kk]]
[18:04:56.670]                   NAME <- NAMES[[kk]]
[18:04:56.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.670]                     next
[18:04:56.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.670]                 }
[18:04:56.670]                 NAMES <- toupper(added)
[18:04:56.670]                 for (kk in seq_along(NAMES)) {
[18:04:56.670]                   name <- added[[kk]]
[18:04:56.670]                   NAME <- NAMES[[kk]]
[18:04:56.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.670]                     next
[18:04:56.670]                   args[[name]] <- ""
[18:04:56.670]                 }
[18:04:56.670]                 NAMES <- toupper(removed)
[18:04:56.670]                 for (kk in seq_along(NAMES)) {
[18:04:56.670]                   name <- removed[[kk]]
[18:04:56.670]                   NAME <- NAMES[[kk]]
[18:04:56.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.670]                     next
[18:04:56.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.670]                 }
[18:04:56.670]                 if (length(args) > 0) 
[18:04:56.670]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.670]             }
[18:04:56.670]             else {
[18:04:56.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.670]             }
[18:04:56.670]             {
[18:04:56.670]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.670]                   0L) {
[18:04:56.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.670]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.670]                   base::options(opts)
[18:04:56.670]                 }
[18:04:56.670]                 {
[18:04:56.670]                   {
[18:04:56.670]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:56.670]                     NULL
[18:04:56.670]                   }
[18:04:56.670]                   options(future.plan = NULL)
[18:04:56.670]                   if (is.na(NA_character_)) 
[18:04:56.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.670]                     .init = FALSE)
[18:04:56.670]                 }
[18:04:56.670]             }
[18:04:56.670]         }
[18:04:56.670]     })
[18:04:56.670]     if (TRUE) {
[18:04:56.670]         base::sink(type = "output", split = FALSE)
[18:04:56.670]         if (TRUE) {
[18:04:56.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.670]         }
[18:04:56.670]         else {
[18:04:56.670]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.670]         }
[18:04:56.670]         base::close(...future.stdout)
[18:04:56.670]         ...future.stdout <- NULL
[18:04:56.670]     }
[18:04:56.670]     ...future.result$conditions <- ...future.conditions
[18:04:56.670]     ...future.result$finished <- base::Sys.time()
[18:04:56.670]     ...future.result
[18:04:56.670] }
[18:04:56.674] assign_globals() ...
[18:04:56.675] List of 1
[18:04:56.675]  $ ii: int 1
[18:04:56.675]  - attr(*, "where")=List of 1
[18:04:56.675]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:56.675]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:56.675]  - attr(*, "resolved")= logi TRUE
[18:04:56.675]  - attr(*, "total_size")= num 56
[18:04:56.675]  - attr(*, "already-done")= logi TRUE
[18:04:56.680] - copied ‘ii’ to environment
[18:04:56.681] assign_globals() ... done
[18:04:56.681] requestCore(): workers = 2
[18:04:56.685] MulticoreFuture started
[18:04:56.687] - Launch lazy future ... done
[18:04:56.688] run() for ‘MulticoreFuture’ ... done
[18:04:56.690] plan(): Setting new future strategy stack:
[18:04:56.689] result() for MulticoreFuture ...
[18:04:56.690] List of future strategies:
[18:04:56.690] 1. sequential:
[18:04:56.690]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.690]    - tweaked: FALSE
[18:04:56.690]    - call: NULL
[18:04:56.694] plan(): nbrOfWorkers() = 1
[18:04:56.698] plan(): Setting new future strategy stack:
[18:04:56.699] List of future strategies:
[18:04:56.699] 1. multicore:
[18:04:56.699]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.699]    - tweaked: FALSE
[18:04:56.699]    - call: plan(strategy)
[18:04:56.709] plan(): nbrOfWorkers() = 2
[18:04:56.722] result() for MulticoreFuture ...
[18:04:56.722] result() for MulticoreFuture ... done
[18:04:56.722] signalConditions() ...
[18:04:56.722]  - include = ‘immediateCondition’
[18:04:56.723]  - exclude = 
[18:04:56.723]  - resignal = FALSE
[18:04:56.723]  - Number of conditions: 1
[18:04:56.723] signalConditions() ... done
[18:04:56.724] result() for MulticoreFuture ... done
[18:04:56.724] result() for MulticoreFuture ...
[18:04:56.724] result() for MulticoreFuture ... done
[18:04:56.724] signalConditions() ...
[18:04:56.725]  - include = ‘immediateCondition’
[18:04:56.725]  - exclude = 
[18:04:56.725]  - resignal = FALSE
[18:04:56.725]  - Number of conditions: 1
[18:04:56.725] signalConditions() ... done
[18:04:56.726] Future state: ‘finished’
[18:04:56.726] result() for MulticoreFuture ...
[18:04:56.726] result() for MulticoreFuture ... done
[18:04:56.727] signalConditions() ...
[18:04:56.727]  - include = ‘condition’
[18:04:56.727]  - exclude = ‘immediateCondition’
[18:04:56.727]  - resignal = TRUE
[18:04:56.727]  - Number of conditions: 1
[18:04:56.728]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:04:56.728] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.8.0-48-generic" "#48-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 14:04:52 UTC 2024" "99adafdbb12a" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-21 18:04:56"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.794] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.794] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.795] 
[18:04:56.795] Searching for globals ... DONE
[18:04:56.796] - globals: [0] <none>
[18:04:56.796] getGlobalsAndPackages() ... DONE
[18:04:56.796] run() for ‘Future’ ...
[18:04:56.797] - state: ‘created’
[18:04:56.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:56.803] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:56.804] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:56.804]   - Field: ‘label’
[18:04:56.804]   - Field: ‘local’
[18:04:56.804]   - Field: ‘owner’
[18:04:56.805]   - Field: ‘envir’
[18:04:56.805]   - Field: ‘workers’
[18:04:56.805]   - Field: ‘packages’
[18:04:56.805]   - Field: ‘gc’
[18:04:56.805]   - Field: ‘job’
[18:04:56.806]   - Field: ‘conditions’
[18:04:56.806]   - Field: ‘expr’
[18:04:56.806]   - Field: ‘uuid’
[18:04:56.806]   - Field: ‘seed’
[18:04:56.806]   - Field: ‘version’
[18:04:56.807]   - Field: ‘result’
[18:04:56.807]   - Field: ‘asynchronous’
[18:04:56.807]   - Field: ‘calls’
[18:04:56.807]   - Field: ‘globals’
[18:04:56.807]   - Field: ‘stdout’
[18:04:56.808]   - Field: ‘earlySignal’
[18:04:56.808]   - Field: ‘lazy’
[18:04:56.808]   - Field: ‘state’
[18:04:56.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:56.808] - Launch lazy future ...
[18:04:56.809] Packages needed by the future expression (n = 0): <none>
[18:04:56.809] Packages needed by future strategies (n = 0): <none>
[18:04:56.810] {
[18:04:56.810]     {
[18:04:56.810]         {
[18:04:56.810]             ...future.startTime <- base::Sys.time()
[18:04:56.810]             {
[18:04:56.810]                 {
[18:04:56.810]                   {
[18:04:56.810]                     {
[18:04:56.810]                       base::local({
[18:04:56.810]                         has_future <- base::requireNamespace("future", 
[18:04:56.810]                           quietly = TRUE)
[18:04:56.810]                         if (has_future) {
[18:04:56.810]                           ns <- base::getNamespace("future")
[18:04:56.810]                           version <- ns[[".package"]][["version"]]
[18:04:56.810]                           if (is.null(version)) 
[18:04:56.810]                             version <- utils::packageVersion("future")
[18:04:56.810]                         }
[18:04:56.810]                         else {
[18:04:56.810]                           version <- NULL
[18:04:56.810]                         }
[18:04:56.810]                         if (!has_future || version < "1.8.0") {
[18:04:56.810]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.810]                             "", base::R.version$version.string), 
[18:04:56.810]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:56.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.810]                               "release", "version")], collapse = " "), 
[18:04:56.810]                             hostname = base::Sys.info()[["nodename"]])
[18:04:56.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.810]                             info)
[18:04:56.810]                           info <- base::paste(info, collapse = "; ")
[18:04:56.810]                           if (!has_future) {
[18:04:56.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.810]                               info)
[18:04:56.810]                           }
[18:04:56.810]                           else {
[18:04:56.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.810]                               info, version)
[18:04:56.810]                           }
[18:04:56.810]                           base::stop(msg)
[18:04:56.810]                         }
[18:04:56.810]                       })
[18:04:56.810]                     }
[18:04:56.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:56.810]                     base::options(mc.cores = 1L)
[18:04:56.810]                   }
[18:04:56.810]                   ...future.strategy.old <- future::plan("list")
[18:04:56.810]                   options(future.plan = NULL)
[18:04:56.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.810]                 }
[18:04:56.810]                 ...future.workdir <- getwd()
[18:04:56.810]             }
[18:04:56.810]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.810]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.810]         }
[18:04:56.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.810]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:56.810]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.810]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.810]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.810]             base::names(...future.oldOptions))
[18:04:56.810]     }
[18:04:56.810]     if (FALSE) {
[18:04:56.810]     }
[18:04:56.810]     else {
[18:04:56.810]         if (TRUE) {
[18:04:56.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.810]                 open = "w")
[18:04:56.810]         }
[18:04:56.810]         else {
[18:04:56.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.810]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.810]         }
[18:04:56.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.810]             base::sink(type = "output", split = FALSE)
[18:04:56.810]             base::close(...future.stdout)
[18:04:56.810]         }, add = TRUE)
[18:04:56.810]     }
[18:04:56.810]     ...future.frame <- base::sys.nframe()
[18:04:56.810]     ...future.conditions <- base::list()
[18:04:56.810]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.810]     if (FALSE) {
[18:04:56.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.810]     }
[18:04:56.810]     ...future.result <- base::tryCatch({
[18:04:56.810]         base::withCallingHandlers({
[18:04:56.810]             ...future.value <- base::withVisible(base::local({
[18:04:56.810]                 withCallingHandlers({
[18:04:56.810]                   1
[18:04:56.810]                 }, immediateCondition = function(cond) {
[18:04:56.810]                   save_rds <- function (object, pathname, ...) 
[18:04:56.810]                   {
[18:04:56.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:56.810]                     if (file_test("-f", pathname_tmp)) {
[18:04:56.810]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:56.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.810]                         fi_tmp[["mtime"]])
[18:04:56.810]                     }
[18:04:56.810]                     tryCatch({
[18:04:56.810]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:56.810]                     }, error = function(ex) {
[18:04:56.810]                       msg <- conditionMessage(ex)
[18:04:56.810]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:56.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.810]                         fi_tmp[["mtime"]], msg)
[18:04:56.810]                       ex$message <- msg
[18:04:56.810]                       stop(ex)
[18:04:56.810]                     })
[18:04:56.810]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:56.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:56.810]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:56.810]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.810]                       fi <- file.info(pathname)
[18:04:56.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:56.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:56.810]                         fi[["size"]], fi[["mtime"]])
[18:04:56.810]                       stop(msg)
[18:04:56.810]                     }
[18:04:56.810]                     invisible(pathname)
[18:04:56.810]                   }
[18:04:56.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:56.810]                     rootPath = tempdir()) 
[18:04:56.810]                   {
[18:04:56.810]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:56.810]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:56.810]                       tmpdir = path, fileext = ".rds")
[18:04:56.810]                     save_rds(obj, file)
[18:04:56.810]                   }
[18:04:56.810]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:56.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.810]                   {
[18:04:56.810]                     inherits <- base::inherits
[18:04:56.810]                     invokeRestart <- base::invokeRestart
[18:04:56.810]                     is.null <- base::is.null
[18:04:56.810]                     muffled <- FALSE
[18:04:56.810]                     if (inherits(cond, "message")) {
[18:04:56.810]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:56.810]                       if (muffled) 
[18:04:56.810]                         invokeRestart("muffleMessage")
[18:04:56.810]                     }
[18:04:56.810]                     else if (inherits(cond, "warning")) {
[18:04:56.810]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:56.810]                       if (muffled) 
[18:04:56.810]                         invokeRestart("muffleWarning")
[18:04:56.810]                     }
[18:04:56.810]                     else if (inherits(cond, "condition")) {
[18:04:56.810]                       if (!is.null(pattern)) {
[18:04:56.810]                         computeRestarts <- base::computeRestarts
[18:04:56.810]                         grepl <- base::grepl
[18:04:56.810]                         restarts <- computeRestarts(cond)
[18:04:56.810]                         for (restart in restarts) {
[18:04:56.810]                           name <- restart$name
[18:04:56.810]                           if (is.null(name)) 
[18:04:56.810]                             next
[18:04:56.810]                           if (!grepl(pattern, name)) 
[18:04:56.810]                             next
[18:04:56.810]                           invokeRestart(restart)
[18:04:56.810]                           muffled <- TRUE
[18:04:56.810]                           break
[18:04:56.810]                         }
[18:04:56.810]                       }
[18:04:56.810]                     }
[18:04:56.810]                     invisible(muffled)
[18:04:56.810]                   }
[18:04:56.810]                   muffleCondition(cond)
[18:04:56.810]                 })
[18:04:56.810]             }))
[18:04:56.810]             future::FutureResult(value = ...future.value$value, 
[18:04:56.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.810]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.810]                     ...future.globalenv.names))
[18:04:56.810]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.810]         }, condition = base::local({
[18:04:56.810]             c <- base::c
[18:04:56.810]             inherits <- base::inherits
[18:04:56.810]             invokeRestart <- base::invokeRestart
[18:04:56.810]             length <- base::length
[18:04:56.810]             list <- base::list
[18:04:56.810]             seq.int <- base::seq.int
[18:04:56.810]             signalCondition <- base::signalCondition
[18:04:56.810]             sys.calls <- base::sys.calls
[18:04:56.810]             `[[` <- base::`[[`
[18:04:56.810]             `+` <- base::`+`
[18:04:56.810]             `<<-` <- base::`<<-`
[18:04:56.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.810]                   3L)]
[18:04:56.810]             }
[18:04:56.810]             function(cond) {
[18:04:56.810]                 is_error <- inherits(cond, "error")
[18:04:56.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.810]                   NULL)
[18:04:56.810]                 if (is_error) {
[18:04:56.810]                   sessionInformation <- function() {
[18:04:56.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.810]                       search = base::search(), system = base::Sys.info())
[18:04:56.810]                   }
[18:04:56.810]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.810]                     cond$call), session = sessionInformation(), 
[18:04:56.810]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.810]                   signalCondition(cond)
[18:04:56.810]                 }
[18:04:56.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.810]                 "immediateCondition"))) {
[18:04:56.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.810]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.810]                   if (TRUE && !signal) {
[18:04:56.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.810]                     {
[18:04:56.810]                       inherits <- base::inherits
[18:04:56.810]                       invokeRestart <- base::invokeRestart
[18:04:56.810]                       is.null <- base::is.null
[18:04:56.810]                       muffled <- FALSE
[18:04:56.810]                       if (inherits(cond, "message")) {
[18:04:56.810]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.810]                         if (muffled) 
[18:04:56.810]                           invokeRestart("muffleMessage")
[18:04:56.810]                       }
[18:04:56.810]                       else if (inherits(cond, "warning")) {
[18:04:56.810]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.810]                         if (muffled) 
[18:04:56.810]                           invokeRestart("muffleWarning")
[18:04:56.810]                       }
[18:04:56.810]                       else if (inherits(cond, "condition")) {
[18:04:56.810]                         if (!is.null(pattern)) {
[18:04:56.810]                           computeRestarts <- base::computeRestarts
[18:04:56.810]                           grepl <- base::grepl
[18:04:56.810]                           restarts <- computeRestarts(cond)
[18:04:56.810]                           for (restart in restarts) {
[18:04:56.810]                             name <- restart$name
[18:04:56.810]                             if (is.null(name)) 
[18:04:56.810]                               next
[18:04:56.810]                             if (!grepl(pattern, name)) 
[18:04:56.810]                               next
[18:04:56.810]                             invokeRestart(restart)
[18:04:56.810]                             muffled <- TRUE
[18:04:56.810]                             break
[18:04:56.810]                           }
[18:04:56.810]                         }
[18:04:56.810]                       }
[18:04:56.810]                       invisible(muffled)
[18:04:56.810]                     }
[18:04:56.810]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.810]                   }
[18:04:56.810]                 }
[18:04:56.810]                 else {
[18:04:56.810]                   if (TRUE) {
[18:04:56.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.810]                     {
[18:04:56.810]                       inherits <- base::inherits
[18:04:56.810]                       invokeRestart <- base::invokeRestart
[18:04:56.810]                       is.null <- base::is.null
[18:04:56.810]                       muffled <- FALSE
[18:04:56.810]                       if (inherits(cond, "message")) {
[18:04:56.810]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.810]                         if (muffled) 
[18:04:56.810]                           invokeRestart("muffleMessage")
[18:04:56.810]                       }
[18:04:56.810]                       else if (inherits(cond, "warning")) {
[18:04:56.810]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.810]                         if (muffled) 
[18:04:56.810]                           invokeRestart("muffleWarning")
[18:04:56.810]                       }
[18:04:56.810]                       else if (inherits(cond, "condition")) {
[18:04:56.810]                         if (!is.null(pattern)) {
[18:04:56.810]                           computeRestarts <- base::computeRestarts
[18:04:56.810]                           grepl <- base::grepl
[18:04:56.810]                           restarts <- computeRestarts(cond)
[18:04:56.810]                           for (restart in restarts) {
[18:04:56.810]                             name <- restart$name
[18:04:56.810]                             if (is.null(name)) 
[18:04:56.810]                               next
[18:04:56.810]                             if (!grepl(pattern, name)) 
[18:04:56.810]                               next
[18:04:56.810]                             invokeRestart(restart)
[18:04:56.810]                             muffled <- TRUE
[18:04:56.810]                             break
[18:04:56.810]                           }
[18:04:56.810]                         }
[18:04:56.810]                       }
[18:04:56.810]                       invisible(muffled)
[18:04:56.810]                     }
[18:04:56.810]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.810]                   }
[18:04:56.810]                 }
[18:04:56.810]             }
[18:04:56.810]         }))
[18:04:56.810]     }, error = function(ex) {
[18:04:56.810]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.810]                 ...future.rng), started = ...future.startTime, 
[18:04:56.810]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.810]             version = "1.8"), class = "FutureResult")
[18:04:56.810]     }, finally = {
[18:04:56.810]         if (!identical(...future.workdir, getwd())) 
[18:04:56.810]             setwd(...future.workdir)
[18:04:56.810]         {
[18:04:56.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.810]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.810]             }
[18:04:56.810]             base::options(...future.oldOptions)
[18:04:56.810]             if (.Platform$OS.type == "windows") {
[18:04:56.810]                 old_names <- names(...future.oldEnvVars)
[18:04:56.810]                 envs <- base::Sys.getenv()
[18:04:56.810]                 names <- names(envs)
[18:04:56.810]                 common <- intersect(names, old_names)
[18:04:56.810]                 added <- setdiff(names, old_names)
[18:04:56.810]                 removed <- setdiff(old_names, names)
[18:04:56.810]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.810]                   envs[common]]
[18:04:56.810]                 NAMES <- toupper(changed)
[18:04:56.810]                 args <- list()
[18:04:56.810]                 for (kk in seq_along(NAMES)) {
[18:04:56.810]                   name <- changed[[kk]]
[18:04:56.810]                   NAME <- NAMES[[kk]]
[18:04:56.810]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.810]                     next
[18:04:56.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.810]                 }
[18:04:56.810]                 NAMES <- toupper(added)
[18:04:56.810]                 for (kk in seq_along(NAMES)) {
[18:04:56.810]                   name <- added[[kk]]
[18:04:56.810]                   NAME <- NAMES[[kk]]
[18:04:56.810]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.810]                     next
[18:04:56.810]                   args[[name]] <- ""
[18:04:56.810]                 }
[18:04:56.810]                 NAMES <- toupper(removed)
[18:04:56.810]                 for (kk in seq_along(NAMES)) {
[18:04:56.810]                   name <- removed[[kk]]
[18:04:56.810]                   NAME <- NAMES[[kk]]
[18:04:56.810]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.810]                     next
[18:04:56.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.810]                 }
[18:04:56.810]                 if (length(args) > 0) 
[18:04:56.810]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.810]             }
[18:04:56.810]             else {
[18:04:56.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.810]             }
[18:04:56.810]             {
[18:04:56.810]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.810]                   0L) {
[18:04:56.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.810]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.810]                   base::options(opts)
[18:04:56.810]                 }
[18:04:56.810]                 {
[18:04:56.810]                   {
[18:04:56.810]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:56.810]                     NULL
[18:04:56.810]                   }
[18:04:56.810]                   options(future.plan = NULL)
[18:04:56.810]                   if (is.na(NA_character_)) 
[18:04:56.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.810]                     .init = FALSE)
[18:04:56.810]                 }
[18:04:56.810]             }
[18:04:56.810]         }
[18:04:56.810]     })
[18:04:56.810]     if (TRUE) {
[18:04:56.810]         base::sink(type = "output", split = FALSE)
[18:04:56.810]         if (TRUE) {
[18:04:56.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.810]         }
[18:04:56.810]         else {
[18:04:56.810]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.810]         }
[18:04:56.810]         base::close(...future.stdout)
[18:04:56.810]         ...future.stdout <- NULL
[18:04:56.810]     }
[18:04:56.810]     ...future.result$conditions <- ...future.conditions
[18:04:56.810]     ...future.result$finished <- base::Sys.time()
[18:04:56.810]     ...future.result
[18:04:56.810] }
[18:04:56.814] requestCore(): workers = 2
[18:04:56.818] MulticoreFuture started
[18:04:56.819] - Launch lazy future ... done
[18:04:56.819] run() for ‘MulticoreFuture’ ... done
[18:04:56.820] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.820] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.821] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.820] List of future strategies:
[18:04:56.820] 1. sequential:
[18:04:56.820]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.820]    - tweaked: FALSE
[18:04:56.820]    - call: NULL
[18:04:56.823] plan(): nbrOfWorkers() = 1
[18:04:56.825] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:56.826] Searching for globals ... DONE
[18:04:56.826] Resolving globals: TRUE
[18:04:56.827] Resolving any globals that are futures ...
[18:04:56.827] plan(): Setting new future strategy stack:
[18:04:56.827] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:56.827] Resolving any globals that are futures ... DONE
[18:04:56.827] List of future strategies:
[18:04:56.827] 1. multicore:
[18:04:56.827]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.827]    - tweaked: FALSE
[18:04:56.827]    - call: plan(strategy)
[18:04:56.829] Resolving futures part of globals (recursively) ...
[18:04:56.830] resolve() on list ...
[18:04:56.830]  recursive: 99
[18:04:56.830]  length: 1
[18:04:56.831]  elements: ‘a’
[18:04:56.835] plan(): nbrOfWorkers() = 2
[18:04:56.837] Future #1
[18:04:56.837] result() for MulticoreFuture ...
[18:04:56.839] result() for MulticoreFuture ...
[18:04:56.839] result() for MulticoreFuture ... done
[18:04:56.840] result() for MulticoreFuture ... done
[18:04:56.840] result() for MulticoreFuture ...
[18:04:56.840] result() for MulticoreFuture ... done
[18:04:56.841] A MulticoreFuture was resolved
[18:04:56.841]  length: 0 (resolved future 1)
[18:04:56.842] resolve() on list ... DONE
[18:04:56.842] - globals: [1] ‘a’
[18:04:56.842] Resolving futures part of globals (recursively) ... DONE
[18:04:56.844] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[18:04:56.845] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[18:04:56.846] - globals: [1] ‘a’
[18:04:56.846] - packages: [1] ‘future’
[18:04:56.846] getGlobalsAndPackages() ... DONE
[18:04:56.847] run() for ‘Future’ ...
[18:04:56.847] - state: ‘created’
[18:04:56.848] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:56.855] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:56.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:56.856]   - Field: ‘label’
[18:04:56.856]   - Field: ‘local’
[18:04:56.856]   - Field: ‘owner’
[18:04:56.856]   - Field: ‘envir’
[18:04:56.857]   - Field: ‘workers’
[18:04:56.857]   - Field: ‘packages’
[18:04:56.857]   - Field: ‘gc’
[18:04:56.857]   - Field: ‘job’
[18:04:56.858]   - Field: ‘conditions’
[18:04:56.858]   - Field: ‘expr’
[18:04:56.858]   - Field: ‘uuid’
[18:04:56.858]   - Field: ‘seed’
[18:04:56.859]   - Field: ‘version’
[18:04:56.859]   - Field: ‘result’
[18:04:56.862]   - Field: ‘asynchronous’
[18:04:56.862]   - Field: ‘calls’
[18:04:56.863]   - Field: ‘globals’
[18:04:56.863]   - Field: ‘stdout’
[18:04:56.863]   - Field: ‘earlySignal’
[18:04:56.864]   - Field: ‘lazy’
[18:04:56.864]   - Field: ‘state’
[18:04:56.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:56.865] - Launch lazy future ...
[18:04:56.866] Packages needed by the future expression (n = 1): ‘future’
[18:04:56.866] Packages needed by future strategies (n = 0): <none>
[18:04:56.867] {
[18:04:56.867]     {
[18:04:56.867]         {
[18:04:56.867]             ...future.startTime <- base::Sys.time()
[18:04:56.867]             {
[18:04:56.867]                 {
[18:04:56.867]                   {
[18:04:56.867]                     {
[18:04:56.867]                       {
[18:04:56.867]                         base::local({
[18:04:56.867]                           has_future <- base::requireNamespace("future", 
[18:04:56.867]                             quietly = TRUE)
[18:04:56.867]                           if (has_future) {
[18:04:56.867]                             ns <- base::getNamespace("future")
[18:04:56.867]                             version <- ns[[".package"]][["version"]]
[18:04:56.867]                             if (is.null(version)) 
[18:04:56.867]                               version <- utils::packageVersion("future")
[18:04:56.867]                           }
[18:04:56.867]                           else {
[18:04:56.867]                             version <- NULL
[18:04:56.867]                           }
[18:04:56.867]                           if (!has_future || version < "1.8.0") {
[18:04:56.867]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.867]                               "", base::R.version$version.string), 
[18:04:56.867]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:56.867]                                 base::R.version$platform, 8 * 
[18:04:56.867]                                   base::.Machine$sizeof.pointer), 
[18:04:56.867]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.867]                                 "release", "version")], collapse = " "), 
[18:04:56.867]                               hostname = base::Sys.info()[["nodename"]])
[18:04:56.867]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.867]                               info)
[18:04:56.867]                             info <- base::paste(info, collapse = "; ")
[18:04:56.867]                             if (!has_future) {
[18:04:56.867]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.867]                                 info)
[18:04:56.867]                             }
[18:04:56.867]                             else {
[18:04:56.867]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.867]                                 info, version)
[18:04:56.867]                             }
[18:04:56.867]                             base::stop(msg)
[18:04:56.867]                           }
[18:04:56.867]                         })
[18:04:56.867]                       }
[18:04:56.867]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:56.867]                       base::options(mc.cores = 1L)
[18:04:56.867]                     }
[18:04:56.867]                     base::local({
[18:04:56.867]                       for (pkg in "future") {
[18:04:56.867]                         base::loadNamespace(pkg)
[18:04:56.867]                         base::library(pkg, character.only = TRUE)
[18:04:56.867]                       }
[18:04:56.867]                     })
[18:04:56.867]                   }
[18:04:56.867]                   ...future.strategy.old <- future::plan("list")
[18:04:56.867]                   options(future.plan = NULL)
[18:04:56.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.867]                 }
[18:04:56.867]                 ...future.workdir <- getwd()
[18:04:56.867]             }
[18:04:56.867]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.867]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.867]         }
[18:04:56.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.867]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:56.867]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.867]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.867]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.867]             base::names(...future.oldOptions))
[18:04:56.867]     }
[18:04:56.867]     if (FALSE) {
[18:04:56.867]     }
[18:04:56.867]     else {
[18:04:56.867]         if (TRUE) {
[18:04:56.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.867]                 open = "w")
[18:04:56.867]         }
[18:04:56.867]         else {
[18:04:56.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.867]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.867]         }
[18:04:56.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.867]             base::sink(type = "output", split = FALSE)
[18:04:56.867]             base::close(...future.stdout)
[18:04:56.867]         }, add = TRUE)
[18:04:56.867]     }
[18:04:56.867]     ...future.frame <- base::sys.nframe()
[18:04:56.867]     ...future.conditions <- base::list()
[18:04:56.867]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.867]     if (FALSE) {
[18:04:56.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.867]     }
[18:04:56.867]     ...future.result <- base::tryCatch({
[18:04:56.867]         base::withCallingHandlers({
[18:04:56.867]             ...future.value <- base::withVisible(base::local({
[18:04:56.867]                 withCallingHandlers({
[18:04:56.867]                   value(a) + 1
[18:04:56.867]                 }, immediateCondition = function(cond) {
[18:04:56.867]                   save_rds <- function (object, pathname, ...) 
[18:04:56.867]                   {
[18:04:56.867]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:56.867]                     if (file_test("-f", pathname_tmp)) {
[18:04:56.867]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.867]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:56.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.867]                         fi_tmp[["mtime"]])
[18:04:56.867]                     }
[18:04:56.867]                     tryCatch({
[18:04:56.867]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:56.867]                     }, error = function(ex) {
[18:04:56.867]                       msg <- conditionMessage(ex)
[18:04:56.867]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.867]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:56.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.867]                         fi_tmp[["mtime"]], msg)
[18:04:56.867]                       ex$message <- msg
[18:04:56.867]                       stop(ex)
[18:04:56.867]                     })
[18:04:56.867]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:56.867]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:56.867]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:56.867]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.867]                       fi <- file.info(pathname)
[18:04:56.867]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:56.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.867]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:56.867]                         fi[["size"]], fi[["mtime"]])
[18:04:56.867]                       stop(msg)
[18:04:56.867]                     }
[18:04:56.867]                     invisible(pathname)
[18:04:56.867]                   }
[18:04:56.867]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:56.867]                     rootPath = tempdir()) 
[18:04:56.867]                   {
[18:04:56.867]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:56.867]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:56.867]                       tmpdir = path, fileext = ".rds")
[18:04:56.867]                     save_rds(obj, file)
[18:04:56.867]                   }
[18:04:56.867]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:56.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.867]                   {
[18:04:56.867]                     inherits <- base::inherits
[18:04:56.867]                     invokeRestart <- base::invokeRestart
[18:04:56.867]                     is.null <- base::is.null
[18:04:56.867]                     muffled <- FALSE
[18:04:56.867]                     if (inherits(cond, "message")) {
[18:04:56.867]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:56.867]                       if (muffled) 
[18:04:56.867]                         invokeRestart("muffleMessage")
[18:04:56.867]                     }
[18:04:56.867]                     else if (inherits(cond, "warning")) {
[18:04:56.867]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:56.867]                       if (muffled) 
[18:04:56.867]                         invokeRestart("muffleWarning")
[18:04:56.867]                     }
[18:04:56.867]                     else if (inherits(cond, "condition")) {
[18:04:56.867]                       if (!is.null(pattern)) {
[18:04:56.867]                         computeRestarts <- base::computeRestarts
[18:04:56.867]                         grepl <- base::grepl
[18:04:56.867]                         restarts <- computeRestarts(cond)
[18:04:56.867]                         for (restart in restarts) {
[18:04:56.867]                           name <- restart$name
[18:04:56.867]                           if (is.null(name)) 
[18:04:56.867]                             next
[18:04:56.867]                           if (!grepl(pattern, name)) 
[18:04:56.867]                             next
[18:04:56.867]                           invokeRestart(restart)
[18:04:56.867]                           muffled <- TRUE
[18:04:56.867]                           break
[18:04:56.867]                         }
[18:04:56.867]                       }
[18:04:56.867]                     }
[18:04:56.867]                     invisible(muffled)
[18:04:56.867]                   }
[18:04:56.867]                   muffleCondition(cond)
[18:04:56.867]                 })
[18:04:56.867]             }))
[18:04:56.867]             future::FutureResult(value = ...future.value$value, 
[18:04:56.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.867]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.867]                     ...future.globalenv.names))
[18:04:56.867]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.867]         }, condition = base::local({
[18:04:56.867]             c <- base::c
[18:04:56.867]             inherits <- base::inherits
[18:04:56.867]             invokeRestart <- base::invokeRestart
[18:04:56.867]             length <- base::length
[18:04:56.867]             list <- base::list
[18:04:56.867]             seq.int <- base::seq.int
[18:04:56.867]             signalCondition <- base::signalCondition
[18:04:56.867]             sys.calls <- base::sys.calls
[18:04:56.867]             `[[` <- base::`[[`
[18:04:56.867]             `+` <- base::`+`
[18:04:56.867]             `<<-` <- base::`<<-`
[18:04:56.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.867]                   3L)]
[18:04:56.867]             }
[18:04:56.867]             function(cond) {
[18:04:56.867]                 is_error <- inherits(cond, "error")
[18:04:56.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.867]                   NULL)
[18:04:56.867]                 if (is_error) {
[18:04:56.867]                   sessionInformation <- function() {
[18:04:56.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.867]                       search = base::search(), system = base::Sys.info())
[18:04:56.867]                   }
[18:04:56.867]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.867]                     cond$call), session = sessionInformation(), 
[18:04:56.867]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.867]                   signalCondition(cond)
[18:04:56.867]                 }
[18:04:56.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.867]                 "immediateCondition"))) {
[18:04:56.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.867]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.867]                   if (TRUE && !signal) {
[18:04:56.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.867]                     {
[18:04:56.867]                       inherits <- base::inherits
[18:04:56.867]                       invokeRestart <- base::invokeRestart
[18:04:56.867]                       is.null <- base::is.null
[18:04:56.867]                       muffled <- FALSE
[18:04:56.867]                       if (inherits(cond, "message")) {
[18:04:56.867]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.867]                         if (muffled) 
[18:04:56.867]                           invokeRestart("muffleMessage")
[18:04:56.867]                       }
[18:04:56.867]                       else if (inherits(cond, "warning")) {
[18:04:56.867]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.867]                         if (muffled) 
[18:04:56.867]                           invokeRestart("muffleWarning")
[18:04:56.867]                       }
[18:04:56.867]                       else if (inherits(cond, "condition")) {
[18:04:56.867]                         if (!is.null(pattern)) {
[18:04:56.867]                           computeRestarts <- base::computeRestarts
[18:04:56.867]                           grepl <- base::grepl
[18:04:56.867]                           restarts <- computeRestarts(cond)
[18:04:56.867]                           for (restart in restarts) {
[18:04:56.867]                             name <- restart$name
[18:04:56.867]                             if (is.null(name)) 
[18:04:56.867]                               next
[18:04:56.867]                             if (!grepl(pattern, name)) 
[18:04:56.867]                               next
[18:04:56.867]                             invokeRestart(restart)
[18:04:56.867]                             muffled <- TRUE
[18:04:56.867]                             break
[18:04:56.867]                           }
[18:04:56.867]                         }
[18:04:56.867]                       }
[18:04:56.867]                       invisible(muffled)
[18:04:56.867]                     }
[18:04:56.867]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.867]                   }
[18:04:56.867]                 }
[18:04:56.867]                 else {
[18:04:56.867]                   if (TRUE) {
[18:04:56.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.867]                     {
[18:04:56.867]                       inherits <- base::inherits
[18:04:56.867]                       invokeRestart <- base::invokeRestart
[18:04:56.867]                       is.null <- base::is.null
[18:04:56.867]                       muffled <- FALSE
[18:04:56.867]                       if (inherits(cond, "message")) {
[18:04:56.867]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.867]                         if (muffled) 
[18:04:56.867]                           invokeRestart("muffleMessage")
[18:04:56.867]                       }
[18:04:56.867]                       else if (inherits(cond, "warning")) {
[18:04:56.867]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.867]                         if (muffled) 
[18:04:56.867]                           invokeRestart("muffleWarning")
[18:04:56.867]                       }
[18:04:56.867]                       else if (inherits(cond, "condition")) {
[18:04:56.867]                         if (!is.null(pattern)) {
[18:04:56.867]                           computeRestarts <- base::computeRestarts
[18:04:56.867]                           grepl <- base::grepl
[18:04:56.867]                           restarts <- computeRestarts(cond)
[18:04:56.867]                           for (restart in restarts) {
[18:04:56.867]                             name <- restart$name
[18:04:56.867]                             if (is.null(name)) 
[18:04:56.867]                               next
[18:04:56.867]                             if (!grepl(pattern, name)) 
[18:04:56.867]                               next
[18:04:56.867]                             invokeRestart(restart)
[18:04:56.867]                             muffled <- TRUE
[18:04:56.867]                             break
[18:04:56.867]                           }
[18:04:56.867]                         }
[18:04:56.867]                       }
[18:04:56.867]                       invisible(muffled)
[18:04:56.867]                     }
[18:04:56.867]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.867]                   }
[18:04:56.867]                 }
[18:04:56.867]             }
[18:04:56.867]         }))
[18:04:56.867]     }, error = function(ex) {
[18:04:56.867]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.867]                 ...future.rng), started = ...future.startTime, 
[18:04:56.867]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.867]             version = "1.8"), class = "FutureResult")
[18:04:56.867]     }, finally = {
[18:04:56.867]         if (!identical(...future.workdir, getwd())) 
[18:04:56.867]             setwd(...future.workdir)
[18:04:56.867]         {
[18:04:56.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.867]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.867]             }
[18:04:56.867]             base::options(...future.oldOptions)
[18:04:56.867]             if (.Platform$OS.type == "windows") {
[18:04:56.867]                 old_names <- names(...future.oldEnvVars)
[18:04:56.867]                 envs <- base::Sys.getenv()
[18:04:56.867]                 names <- names(envs)
[18:04:56.867]                 common <- intersect(names, old_names)
[18:04:56.867]                 added <- setdiff(names, old_names)
[18:04:56.867]                 removed <- setdiff(old_names, names)
[18:04:56.867]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.867]                   envs[common]]
[18:04:56.867]                 NAMES <- toupper(changed)
[18:04:56.867]                 args <- list()
[18:04:56.867]                 for (kk in seq_along(NAMES)) {
[18:04:56.867]                   name <- changed[[kk]]
[18:04:56.867]                   NAME <- NAMES[[kk]]
[18:04:56.867]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.867]                     next
[18:04:56.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.867]                 }
[18:04:56.867]                 NAMES <- toupper(added)
[18:04:56.867]                 for (kk in seq_along(NAMES)) {
[18:04:56.867]                   name <- added[[kk]]
[18:04:56.867]                   NAME <- NAMES[[kk]]
[18:04:56.867]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.867]                     next
[18:04:56.867]                   args[[name]] <- ""
[18:04:56.867]                 }
[18:04:56.867]                 NAMES <- toupper(removed)
[18:04:56.867]                 for (kk in seq_along(NAMES)) {
[18:04:56.867]                   name <- removed[[kk]]
[18:04:56.867]                   NAME <- NAMES[[kk]]
[18:04:56.867]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.867]                     next
[18:04:56.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.867]                 }
[18:04:56.867]                 if (length(args) > 0) 
[18:04:56.867]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.867]             }
[18:04:56.867]             else {
[18:04:56.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.867]             }
[18:04:56.867]             {
[18:04:56.867]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.867]                   0L) {
[18:04:56.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.867]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.867]                   base::options(opts)
[18:04:56.867]                 }
[18:04:56.867]                 {
[18:04:56.867]                   {
[18:04:56.867]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:56.867]                     NULL
[18:04:56.867]                   }
[18:04:56.867]                   options(future.plan = NULL)
[18:04:56.867]                   if (is.na(NA_character_)) 
[18:04:56.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.867]                     .init = FALSE)
[18:04:56.867]                 }
[18:04:56.867]             }
[18:04:56.867]         }
[18:04:56.867]     })
[18:04:56.867]     if (TRUE) {
[18:04:56.867]         base::sink(type = "output", split = FALSE)
[18:04:56.867]         if (TRUE) {
[18:04:56.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.867]         }
[18:04:56.867]         else {
[18:04:56.867]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.867]         }
[18:04:56.867]         base::close(...future.stdout)
[18:04:56.867]         ...future.stdout <- NULL
[18:04:56.867]     }
[18:04:56.867]     ...future.result$conditions <- ...future.conditions
[18:04:56.867]     ...future.result$finished <- base::Sys.time()
[18:04:56.867]     ...future.result
[18:04:56.867] }
[18:04:56.872] assign_globals() ...
[18:04:56.872] List of 1
[18:04:56.872]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5b95752ced80> 
[18:04:56.872]  - attr(*, "where")=List of 1
[18:04:56.872]   ..$ a:<environment: R_EmptyEnv> 
[18:04:56.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:56.872]  - attr(*, "resolved")= logi TRUE
[18:04:56.872]  - attr(*, "total_size")= num 10816
[18:04:56.872]  - attr(*, "already-done")= logi TRUE
[18:04:56.878] - copied ‘a’ to environment
[18:04:56.878] assign_globals() ... done
[18:04:56.878] requestCore(): workers = 2
[18:04:56.882] MulticoreFuture started
[18:04:56.883] - Launch lazy future ... done
[18:04:56.883] run() for ‘MulticoreFuture’ ... done
[18:04:56.884] result() for MulticoreFuture ...
[18:04:56.885] plan(): Setting new future strategy stack:
[18:04:56.885] List of future strategies:
[18:04:56.885] 1. sequential:
[18:04:56.885]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.885]    - tweaked: FALSE
[18:04:56.885]    - call: NULL
[18:04:56.888] plan(): nbrOfWorkers() = 1
[18:04:56.896] plan(): Setting new future strategy stack:
[18:04:56.897] List of future strategies:
[18:04:56.897] 1. multicore:
[18:04:56.897]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.897]    - tweaked: FALSE
[18:04:56.897]    - call: plan(strategy)
[18:04:56.907] plan(): nbrOfWorkers() = 2
[18:04:56.908] result() for MulticoreFuture ...
[18:04:56.909] result() for MulticoreFuture ... done
[18:04:56.909] signalConditions() ...
[18:04:56.909]  - include = ‘immediateCondition’
[18:04:56.910]  - exclude = 
[18:04:56.910]  - resignal = FALSE
[18:04:56.911]  - Number of conditions: 4
[18:04:56.911] signalConditions() ... done
[18:04:56.911] result() for MulticoreFuture ... done
[18:04:56.911] result() for MulticoreFuture ...
[18:04:56.912] result() for MulticoreFuture ... done
[18:04:56.912] signalConditions() ...
[18:04:56.912]  - include = ‘immediateCondition’
[18:04:56.912]  - exclude = 
[18:04:56.913]  - resignal = FALSE
[18:04:56.913]  - Number of conditions: 4
[18:04:56.913] signalConditions() ... done
[18:04:56.913] Future state: ‘finished’
[18:04:56.914] result() for MulticoreFuture ...
[18:04:56.914] result() for MulticoreFuture ... done
[18:04:56.914] signalConditions() ...
[18:04:56.914]  - include = ‘condition’
[18:04:56.915]  - exclude = ‘immediateCondition’
[18:04:56.915]  - resignal = TRUE
[18:04:56.915]  - Number of conditions: 4
[18:04:56.915]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:56.891] result() for MulticoreFuture ...
[18:04:56.916]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:56.892] result() for MulticoreFuture ... done
[18:04:56.916]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:56.893] result() for MulticoreFuture ...
[18:04:56.916]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:56.893] result() for MulticoreFuture ... done
[18:04:56.917] signalConditions() ... done
value(b) = 2
[18:04:56.917] result() for MulticoreFuture ...
[18:04:56.917] result() for MulticoreFuture ... done
[18:04:56.918] result() for MulticoreFuture ...
[18:04:56.918] result() for MulticoreFuture ... done
[18:04:56.918] signalConditions() ...
[18:04:56.918]  - include = ‘immediateCondition’
[18:04:56.919]  - exclude = 
[18:04:56.919]  - resignal = FALSE
[18:04:56.919]  - Number of conditions: 4
[18:04:56.919] signalConditions() ... done
[18:04:56.920] Future state: ‘finished’
[18:04:56.920] result() for MulticoreFuture ...
[18:04:56.920] result() for MulticoreFuture ... done
[18:04:56.920] signalConditions() ...
[18:04:56.921]  - include = ‘condition’
[18:04:56.921]  - exclude = ‘immediateCondition’
[18:04:56.921]  - resignal = TRUE
[18:04:56.921]  - Number of conditions: 4
[18:04:56.921]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:56.891] result() for MulticoreFuture ...
[18:04:56.922]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:56.892] result() for MulticoreFuture ... done
[18:04:56.922]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:56.893] result() for MulticoreFuture ...
[18:04:56.922]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:56.893] result() for MulticoreFuture ... done
[18:04:56.923] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.923] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.924] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.925] 
[18:04:56.926] Searching for globals ... DONE
[18:04:56.926] - globals: [0] <none>
[18:04:56.926] getGlobalsAndPackages() ... DONE
[18:04:56.927] run() for ‘Future’ ...
[18:04:56.927] - state: ‘created’
[18:04:56.927] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:56.935] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:56.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:56.935]   - Field: ‘label’
[18:04:56.936]   - Field: ‘local’
[18:04:56.936]   - Field: ‘owner’
[18:04:56.936]   - Field: ‘envir’
[18:04:56.936]   - Field: ‘workers’
[18:04:56.937]   - Field: ‘packages’
[18:04:56.937]   - Field: ‘gc’
[18:04:56.937]   - Field: ‘job’
[18:04:56.937]   - Field: ‘conditions’
[18:04:56.938]   - Field: ‘expr’
[18:04:56.938]   - Field: ‘uuid’
[18:04:56.938]   - Field: ‘seed’
[18:04:56.938]   - Field: ‘version’
[18:04:56.939]   - Field: ‘result’
[18:04:56.939]   - Field: ‘asynchronous’
[18:04:56.939]   - Field: ‘calls’
[18:04:56.939]   - Field: ‘globals’
[18:04:56.939]   - Field: ‘stdout’
[18:04:56.940]   - Field: ‘earlySignal’
[18:04:56.940]   - Field: ‘lazy’
[18:04:56.940]   - Field: ‘state’
[18:04:56.940] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:56.941] - Launch lazy future ...
[18:04:56.941] Packages needed by the future expression (n = 0): <none>
[18:04:56.942] Packages needed by future strategies (n = 0): <none>
[18:04:56.943] {
[18:04:56.943]     {
[18:04:56.943]         {
[18:04:56.943]             ...future.startTime <- base::Sys.time()
[18:04:56.943]             {
[18:04:56.943]                 {
[18:04:56.943]                   {
[18:04:56.943]                     {
[18:04:56.943]                       base::local({
[18:04:56.943]                         has_future <- base::requireNamespace("future", 
[18:04:56.943]                           quietly = TRUE)
[18:04:56.943]                         if (has_future) {
[18:04:56.943]                           ns <- base::getNamespace("future")
[18:04:56.943]                           version <- ns[[".package"]][["version"]]
[18:04:56.943]                           if (is.null(version)) 
[18:04:56.943]                             version <- utils::packageVersion("future")
[18:04:56.943]                         }
[18:04:56.943]                         else {
[18:04:56.943]                           version <- NULL
[18:04:56.943]                         }
[18:04:56.943]                         if (!has_future || version < "1.8.0") {
[18:04:56.943]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:56.943]                             "", base::R.version$version.string), 
[18:04:56.943]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:56.943]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:56.943]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:56.943]                               "release", "version")], collapse = " "), 
[18:04:56.943]                             hostname = base::Sys.info()[["nodename"]])
[18:04:56.943]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:56.943]                             info)
[18:04:56.943]                           info <- base::paste(info, collapse = "; ")
[18:04:56.943]                           if (!has_future) {
[18:04:56.943]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:56.943]                               info)
[18:04:56.943]                           }
[18:04:56.943]                           else {
[18:04:56.943]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:56.943]                               info, version)
[18:04:56.943]                           }
[18:04:56.943]                           base::stop(msg)
[18:04:56.943]                         }
[18:04:56.943]                       })
[18:04:56.943]                     }
[18:04:56.943]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:56.943]                     base::options(mc.cores = 1L)
[18:04:56.943]                   }
[18:04:56.943]                   ...future.strategy.old <- future::plan("list")
[18:04:56.943]                   options(future.plan = NULL)
[18:04:56.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:56.943]                 }
[18:04:56.943]                 ...future.workdir <- getwd()
[18:04:56.943]             }
[18:04:56.943]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:56.943]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:56.943]         }
[18:04:56.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:56.943]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:56.943]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:56.943]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:56.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:56.943]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:56.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:56.943]             base::names(...future.oldOptions))
[18:04:56.943]     }
[18:04:56.943]     if (FALSE) {
[18:04:56.943]     }
[18:04:56.943]     else {
[18:04:56.943]         if (TRUE) {
[18:04:56.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:56.943]                 open = "w")
[18:04:56.943]         }
[18:04:56.943]         else {
[18:04:56.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:56.943]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:56.943]         }
[18:04:56.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:56.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:56.943]             base::sink(type = "output", split = FALSE)
[18:04:56.943]             base::close(...future.stdout)
[18:04:56.943]         }, add = TRUE)
[18:04:56.943]     }
[18:04:56.943]     ...future.frame <- base::sys.nframe()
[18:04:56.943]     ...future.conditions <- base::list()
[18:04:56.943]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:56.943]     if (FALSE) {
[18:04:56.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:56.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:56.943]     }
[18:04:56.943]     ...future.result <- base::tryCatch({
[18:04:56.943]         base::withCallingHandlers({
[18:04:56.943]             ...future.value <- base::withVisible(base::local({
[18:04:56.943]                 withCallingHandlers({
[18:04:56.943]                   1
[18:04:56.943]                 }, immediateCondition = function(cond) {
[18:04:56.943]                   save_rds <- function (object, pathname, ...) 
[18:04:56.943]                   {
[18:04:56.943]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:56.943]                     if (file_test("-f", pathname_tmp)) {
[18:04:56.943]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.943]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:56.943]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.943]                         fi_tmp[["mtime"]])
[18:04:56.943]                     }
[18:04:56.943]                     tryCatch({
[18:04:56.943]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:56.943]                     }, error = function(ex) {
[18:04:56.943]                       msg <- conditionMessage(ex)
[18:04:56.943]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.943]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:56.943]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.943]                         fi_tmp[["mtime"]], msg)
[18:04:56.943]                       ex$message <- msg
[18:04:56.943]                       stop(ex)
[18:04:56.943]                     })
[18:04:56.943]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:56.943]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:56.943]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:56.943]                       fi_tmp <- file.info(pathname_tmp)
[18:04:56.943]                       fi <- file.info(pathname)
[18:04:56.943]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:56.943]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:56.943]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:56.943]                         fi[["size"]], fi[["mtime"]])
[18:04:56.943]                       stop(msg)
[18:04:56.943]                     }
[18:04:56.943]                     invisible(pathname)
[18:04:56.943]                   }
[18:04:56.943]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:56.943]                     rootPath = tempdir()) 
[18:04:56.943]                   {
[18:04:56.943]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:56.943]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:56.943]                       tmpdir = path, fileext = ".rds")
[18:04:56.943]                     save_rds(obj, file)
[18:04:56.943]                   }
[18:04:56.943]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:56.943]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.943]                   {
[18:04:56.943]                     inherits <- base::inherits
[18:04:56.943]                     invokeRestart <- base::invokeRestart
[18:04:56.943]                     is.null <- base::is.null
[18:04:56.943]                     muffled <- FALSE
[18:04:56.943]                     if (inherits(cond, "message")) {
[18:04:56.943]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:56.943]                       if (muffled) 
[18:04:56.943]                         invokeRestart("muffleMessage")
[18:04:56.943]                     }
[18:04:56.943]                     else if (inherits(cond, "warning")) {
[18:04:56.943]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:56.943]                       if (muffled) 
[18:04:56.943]                         invokeRestart("muffleWarning")
[18:04:56.943]                     }
[18:04:56.943]                     else if (inherits(cond, "condition")) {
[18:04:56.943]                       if (!is.null(pattern)) {
[18:04:56.943]                         computeRestarts <- base::computeRestarts
[18:04:56.943]                         grepl <- base::grepl
[18:04:56.943]                         restarts <- computeRestarts(cond)
[18:04:56.943]                         for (restart in restarts) {
[18:04:56.943]                           name <- restart$name
[18:04:56.943]                           if (is.null(name)) 
[18:04:56.943]                             next
[18:04:56.943]                           if (!grepl(pattern, name)) 
[18:04:56.943]                             next
[18:04:56.943]                           invokeRestart(restart)
[18:04:56.943]                           muffled <- TRUE
[18:04:56.943]                           break
[18:04:56.943]                         }
[18:04:56.943]                       }
[18:04:56.943]                     }
[18:04:56.943]                     invisible(muffled)
[18:04:56.943]                   }
[18:04:56.943]                   muffleCondition(cond)
[18:04:56.943]                 })
[18:04:56.943]             }))
[18:04:56.943]             future::FutureResult(value = ...future.value$value, 
[18:04:56.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.943]                   ...future.rng), globalenv = if (FALSE) 
[18:04:56.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:56.943]                     ...future.globalenv.names))
[18:04:56.943]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:56.943]         }, condition = base::local({
[18:04:56.943]             c <- base::c
[18:04:56.943]             inherits <- base::inherits
[18:04:56.943]             invokeRestart <- base::invokeRestart
[18:04:56.943]             length <- base::length
[18:04:56.943]             list <- base::list
[18:04:56.943]             seq.int <- base::seq.int
[18:04:56.943]             signalCondition <- base::signalCondition
[18:04:56.943]             sys.calls <- base::sys.calls
[18:04:56.943]             `[[` <- base::`[[`
[18:04:56.943]             `+` <- base::`+`
[18:04:56.943]             `<<-` <- base::`<<-`
[18:04:56.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:56.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:56.943]                   3L)]
[18:04:56.943]             }
[18:04:56.943]             function(cond) {
[18:04:56.943]                 is_error <- inherits(cond, "error")
[18:04:56.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:56.943]                   NULL)
[18:04:56.943]                 if (is_error) {
[18:04:56.943]                   sessionInformation <- function() {
[18:04:56.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:56.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:56.943]                       search = base::search(), system = base::Sys.info())
[18:04:56.943]                   }
[18:04:56.943]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:56.943]                     cond$call), session = sessionInformation(), 
[18:04:56.943]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:56.943]                   signalCondition(cond)
[18:04:56.943]                 }
[18:04:56.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:56.943]                 "immediateCondition"))) {
[18:04:56.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:56.943]                   ...future.conditions[[length(...future.conditions) + 
[18:04:56.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:56.943]                   if (TRUE && !signal) {
[18:04:56.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.943]                     {
[18:04:56.943]                       inherits <- base::inherits
[18:04:56.943]                       invokeRestart <- base::invokeRestart
[18:04:56.943]                       is.null <- base::is.null
[18:04:56.943]                       muffled <- FALSE
[18:04:56.943]                       if (inherits(cond, "message")) {
[18:04:56.943]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.943]                         if (muffled) 
[18:04:56.943]                           invokeRestart("muffleMessage")
[18:04:56.943]                       }
[18:04:56.943]                       else if (inherits(cond, "warning")) {
[18:04:56.943]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.943]                         if (muffled) 
[18:04:56.943]                           invokeRestart("muffleWarning")
[18:04:56.943]                       }
[18:04:56.943]                       else if (inherits(cond, "condition")) {
[18:04:56.943]                         if (!is.null(pattern)) {
[18:04:56.943]                           computeRestarts <- base::computeRestarts
[18:04:56.943]                           grepl <- base::grepl
[18:04:56.943]                           restarts <- computeRestarts(cond)
[18:04:56.943]                           for (restart in restarts) {
[18:04:56.943]                             name <- restart$name
[18:04:56.943]                             if (is.null(name)) 
[18:04:56.943]                               next
[18:04:56.943]                             if (!grepl(pattern, name)) 
[18:04:56.943]                               next
[18:04:56.943]                             invokeRestart(restart)
[18:04:56.943]                             muffled <- TRUE
[18:04:56.943]                             break
[18:04:56.943]                           }
[18:04:56.943]                         }
[18:04:56.943]                       }
[18:04:56.943]                       invisible(muffled)
[18:04:56.943]                     }
[18:04:56.943]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.943]                   }
[18:04:56.943]                 }
[18:04:56.943]                 else {
[18:04:56.943]                   if (TRUE) {
[18:04:56.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:56.943]                     {
[18:04:56.943]                       inherits <- base::inherits
[18:04:56.943]                       invokeRestart <- base::invokeRestart
[18:04:56.943]                       is.null <- base::is.null
[18:04:56.943]                       muffled <- FALSE
[18:04:56.943]                       if (inherits(cond, "message")) {
[18:04:56.943]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:56.943]                         if (muffled) 
[18:04:56.943]                           invokeRestart("muffleMessage")
[18:04:56.943]                       }
[18:04:56.943]                       else if (inherits(cond, "warning")) {
[18:04:56.943]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:56.943]                         if (muffled) 
[18:04:56.943]                           invokeRestart("muffleWarning")
[18:04:56.943]                       }
[18:04:56.943]                       else if (inherits(cond, "condition")) {
[18:04:56.943]                         if (!is.null(pattern)) {
[18:04:56.943]                           computeRestarts <- base::computeRestarts
[18:04:56.943]                           grepl <- base::grepl
[18:04:56.943]                           restarts <- computeRestarts(cond)
[18:04:56.943]                           for (restart in restarts) {
[18:04:56.943]                             name <- restart$name
[18:04:56.943]                             if (is.null(name)) 
[18:04:56.943]                               next
[18:04:56.943]                             if (!grepl(pattern, name)) 
[18:04:56.943]                               next
[18:04:56.943]                             invokeRestart(restart)
[18:04:56.943]                             muffled <- TRUE
[18:04:56.943]                             break
[18:04:56.943]                           }
[18:04:56.943]                         }
[18:04:56.943]                       }
[18:04:56.943]                       invisible(muffled)
[18:04:56.943]                     }
[18:04:56.943]                     muffleCondition(cond, pattern = "^muffle")
[18:04:56.943]                   }
[18:04:56.943]                 }
[18:04:56.943]             }
[18:04:56.943]         }))
[18:04:56.943]     }, error = function(ex) {
[18:04:56.943]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:56.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:56.943]                 ...future.rng), started = ...future.startTime, 
[18:04:56.943]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:56.943]             version = "1.8"), class = "FutureResult")
[18:04:56.943]     }, finally = {
[18:04:56.943]         if (!identical(...future.workdir, getwd())) 
[18:04:56.943]             setwd(...future.workdir)
[18:04:56.943]         {
[18:04:56.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:56.943]                 ...future.oldOptions$nwarnings <- NULL
[18:04:56.943]             }
[18:04:56.943]             base::options(...future.oldOptions)
[18:04:56.943]             if (.Platform$OS.type == "windows") {
[18:04:56.943]                 old_names <- names(...future.oldEnvVars)
[18:04:56.943]                 envs <- base::Sys.getenv()
[18:04:56.943]                 names <- names(envs)
[18:04:56.943]                 common <- intersect(names, old_names)
[18:04:56.943]                 added <- setdiff(names, old_names)
[18:04:56.943]                 removed <- setdiff(old_names, names)
[18:04:56.943]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:56.943]                   envs[common]]
[18:04:56.943]                 NAMES <- toupper(changed)
[18:04:56.943]                 args <- list()
[18:04:56.943]                 for (kk in seq_along(NAMES)) {
[18:04:56.943]                   name <- changed[[kk]]
[18:04:56.943]                   NAME <- NAMES[[kk]]
[18:04:56.943]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.943]                     next
[18:04:56.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.943]                 }
[18:04:56.943]                 NAMES <- toupper(added)
[18:04:56.943]                 for (kk in seq_along(NAMES)) {
[18:04:56.943]                   name <- added[[kk]]
[18:04:56.943]                   NAME <- NAMES[[kk]]
[18:04:56.943]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.943]                     next
[18:04:56.943]                   args[[name]] <- ""
[18:04:56.943]                 }
[18:04:56.943]                 NAMES <- toupper(removed)
[18:04:56.943]                 for (kk in seq_along(NAMES)) {
[18:04:56.943]                   name <- removed[[kk]]
[18:04:56.943]                   NAME <- NAMES[[kk]]
[18:04:56.943]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:56.943]                     next
[18:04:56.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:56.943]                 }
[18:04:56.943]                 if (length(args) > 0) 
[18:04:56.943]                   base::do.call(base::Sys.setenv, args = args)
[18:04:56.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:56.943]             }
[18:04:56.943]             else {
[18:04:56.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:56.943]             }
[18:04:56.943]             {
[18:04:56.943]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:56.943]                   0L) {
[18:04:56.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:56.943]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:56.943]                   base::options(opts)
[18:04:56.943]                 }
[18:04:56.943]                 {
[18:04:56.943]                   {
[18:04:56.943]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:56.943]                     NULL
[18:04:56.943]                   }
[18:04:56.943]                   options(future.plan = NULL)
[18:04:56.943]                   if (is.na(NA_character_)) 
[18:04:56.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:56.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:56.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:56.943]                     .init = FALSE)
[18:04:56.943]                 }
[18:04:56.943]             }
[18:04:56.943]         }
[18:04:56.943]     })
[18:04:56.943]     if (TRUE) {
[18:04:56.943]         base::sink(type = "output", split = FALSE)
[18:04:56.943]         if (TRUE) {
[18:04:56.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:56.943]         }
[18:04:56.943]         else {
[18:04:56.943]             ...future.result["stdout"] <- base::list(NULL)
[18:04:56.943]         }
[18:04:56.943]         base::close(...future.stdout)
[18:04:56.943]         ...future.stdout <- NULL
[18:04:56.943]     }
[18:04:56.943]     ...future.result$conditions <- ...future.conditions
[18:04:56.943]     ...future.result$finished <- base::Sys.time()
[18:04:56.943]     ...future.result
[18:04:56.943] }
[18:04:56.947] requestCore(): workers = 2
[18:04:56.951] MulticoreFuture started
[18:04:56.952] - Launch lazy future ... done
[18:04:56.952] run() for ‘MulticoreFuture’ ... done
[18:04:56.953] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:56.953] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:56.954] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:56.953] List of future strategies:
[18:04:56.953] 1. sequential:
[18:04:56.953]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:56.953]    - tweaked: FALSE
[18:04:56.953]    - call: NULL
[18:04:56.955] plan(): nbrOfWorkers() = 1
[18:04:56.959] plan(): Setting new future strategy stack:
[18:04:56.965] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:56.960] List of future strategies:
[18:04:56.960] 1. multicore:
[18:04:56.960]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:56.960]    - tweaked: FALSE
[18:04:56.960]    - call: plan(strategy)
[18:04:56.966] Searching for globals ... DONE
[18:04:56.967] Resolving globals: TRUE
[18:04:56.968] Resolving any globals that are futures ...
[18:04:56.969] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:56.969] Resolving any globals that are futures ... DONE
[18:04:56.971] Resolving futures part of globals (recursively) ...
[18:04:56.975] plan(): nbrOfWorkers() = 2
[18:04:56.973] resolve() on list ...
[18:04:56.976]  recursive: 99
[18:04:56.977]  length: 1
[18:04:56.977]  elements: ‘a’
[18:04:56.980] Future #1
[18:04:56.981] result() for MulticoreFuture ...
[18:04:56.983] result() for MulticoreFuture ...
[18:04:56.983] result() for MulticoreFuture ... done
[18:04:56.984] result() for MulticoreFuture ... done
[18:04:56.984] result() for MulticoreFuture ...
[18:04:56.984] result() for MulticoreFuture ... done
[18:04:56.985] A MulticoreFuture was resolved
[18:04:56.985]  length: 0 (resolved future 1)
[18:04:56.986] resolve() on list ... DONE
[18:04:56.986] - globals: [1] ‘a’
[18:04:56.986] Resolving futures part of globals (recursively) ... DONE
[18:04:56.989] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[18:04:56.990] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[18:04:56.991] - globals: [1] ‘a’
[18:04:56.991] - packages: [1] ‘future’
[18:04:56.991] getGlobalsAndPackages() ... DONE
[18:04:56.992] run() for ‘Future’ ...
[18:04:56.992] - state: ‘created’
[18:04:56.993] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.000] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.000]   - Field: ‘label’
[18:04:57.001]   - Field: ‘local’
[18:04:57.001]   - Field: ‘owner’
[18:04:57.001]   - Field: ‘envir’
[18:04:57.001]   - Field: ‘workers’
[18:04:57.002]   - Field: ‘packages’
[18:04:57.002]   - Field: ‘gc’
[18:04:57.002]   - Field: ‘job’
[18:04:57.002]   - Field: ‘conditions’
[18:04:57.002]   - Field: ‘expr’
[18:04:57.003]   - Field: ‘uuid’
[18:04:57.003]   - Field: ‘seed’
[18:04:57.003]   - Field: ‘version’
[18:04:57.003]   - Field: ‘result’
[18:04:57.004]   - Field: ‘asynchronous’
[18:04:57.004]   - Field: ‘calls’
[18:04:57.004]   - Field: ‘globals’
[18:04:57.004]   - Field: ‘stdout’
[18:04:57.005]   - Field: ‘earlySignal’
[18:04:57.005]   - Field: ‘lazy’
[18:04:57.005]   - Field: ‘state’
[18:04:57.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.006] - Launch lazy future ...
[18:04:57.006] Packages needed by the future expression (n = 1): ‘future’
[18:04:57.007] Packages needed by future strategies (n = 0): <none>
[18:04:57.008] {
[18:04:57.008]     {
[18:04:57.008]         {
[18:04:57.008]             ...future.startTime <- base::Sys.time()
[18:04:57.008]             {
[18:04:57.008]                 {
[18:04:57.008]                   {
[18:04:57.008]                     {
[18:04:57.008]                       {
[18:04:57.008]                         base::local({
[18:04:57.008]                           has_future <- base::requireNamespace("future", 
[18:04:57.008]                             quietly = TRUE)
[18:04:57.008]                           if (has_future) {
[18:04:57.008]                             ns <- base::getNamespace("future")
[18:04:57.008]                             version <- ns[[".package"]][["version"]]
[18:04:57.008]                             if (is.null(version)) 
[18:04:57.008]                               version <- utils::packageVersion("future")
[18:04:57.008]                           }
[18:04:57.008]                           else {
[18:04:57.008]                             version <- NULL
[18:04:57.008]                           }
[18:04:57.008]                           if (!has_future || version < "1.8.0") {
[18:04:57.008]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.008]                               "", base::R.version$version.string), 
[18:04:57.008]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:57.008]                                 base::R.version$platform, 8 * 
[18:04:57.008]                                   base::.Machine$sizeof.pointer), 
[18:04:57.008]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.008]                                 "release", "version")], collapse = " "), 
[18:04:57.008]                               hostname = base::Sys.info()[["nodename"]])
[18:04:57.008]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.008]                               info)
[18:04:57.008]                             info <- base::paste(info, collapse = "; ")
[18:04:57.008]                             if (!has_future) {
[18:04:57.008]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.008]                                 info)
[18:04:57.008]                             }
[18:04:57.008]                             else {
[18:04:57.008]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.008]                                 info, version)
[18:04:57.008]                             }
[18:04:57.008]                             base::stop(msg)
[18:04:57.008]                           }
[18:04:57.008]                         })
[18:04:57.008]                       }
[18:04:57.008]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.008]                       base::options(mc.cores = 1L)
[18:04:57.008]                     }
[18:04:57.008]                     base::local({
[18:04:57.008]                       for (pkg in "future") {
[18:04:57.008]                         base::loadNamespace(pkg)
[18:04:57.008]                         base::library(pkg, character.only = TRUE)
[18:04:57.008]                       }
[18:04:57.008]                     })
[18:04:57.008]                   }
[18:04:57.008]                   ...future.strategy.old <- future::plan("list")
[18:04:57.008]                   options(future.plan = NULL)
[18:04:57.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.008]                 }
[18:04:57.008]                 ...future.workdir <- getwd()
[18:04:57.008]             }
[18:04:57.008]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.008]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.008]         }
[18:04:57.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.008]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:57.008]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.008]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.008]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.008]             base::names(...future.oldOptions))
[18:04:57.008]     }
[18:04:57.008]     if (FALSE) {
[18:04:57.008]     }
[18:04:57.008]     else {
[18:04:57.008]         if (TRUE) {
[18:04:57.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.008]                 open = "w")
[18:04:57.008]         }
[18:04:57.008]         else {
[18:04:57.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.008]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.008]         }
[18:04:57.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.008]             base::sink(type = "output", split = FALSE)
[18:04:57.008]             base::close(...future.stdout)
[18:04:57.008]         }, add = TRUE)
[18:04:57.008]     }
[18:04:57.008]     ...future.frame <- base::sys.nframe()
[18:04:57.008]     ...future.conditions <- base::list()
[18:04:57.008]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.008]     if (FALSE) {
[18:04:57.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.008]     }
[18:04:57.008]     ...future.result <- base::tryCatch({
[18:04:57.008]         base::withCallingHandlers({
[18:04:57.008]             ...future.value <- base::withVisible(base::local({
[18:04:57.008]                 withCallingHandlers({
[18:04:57.008]                   value(a) + 1
[18:04:57.008]                 }, immediateCondition = function(cond) {
[18:04:57.008]                   save_rds <- function (object, pathname, ...) 
[18:04:57.008]                   {
[18:04:57.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.008]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.008]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.008]                         fi_tmp[["mtime"]])
[18:04:57.008]                     }
[18:04:57.008]                     tryCatch({
[18:04:57.008]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.008]                     }, error = function(ex) {
[18:04:57.008]                       msg <- conditionMessage(ex)
[18:04:57.008]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.008]                         fi_tmp[["mtime"]], msg)
[18:04:57.008]                       ex$message <- msg
[18:04:57.008]                       stop(ex)
[18:04:57.008]                     })
[18:04:57.008]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.008]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.008]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.008]                       fi <- file.info(pathname)
[18:04:57.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.008]                         fi[["size"]], fi[["mtime"]])
[18:04:57.008]                       stop(msg)
[18:04:57.008]                     }
[18:04:57.008]                     invisible(pathname)
[18:04:57.008]                   }
[18:04:57.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.008]                     rootPath = tempdir()) 
[18:04:57.008]                   {
[18:04:57.008]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.008]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.008]                       tmpdir = path, fileext = ".rds")
[18:04:57.008]                     save_rds(obj, file)
[18:04:57.008]                   }
[18:04:57.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.008]                   {
[18:04:57.008]                     inherits <- base::inherits
[18:04:57.008]                     invokeRestart <- base::invokeRestart
[18:04:57.008]                     is.null <- base::is.null
[18:04:57.008]                     muffled <- FALSE
[18:04:57.008]                     if (inherits(cond, "message")) {
[18:04:57.008]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.008]                       if (muffled) 
[18:04:57.008]                         invokeRestart("muffleMessage")
[18:04:57.008]                     }
[18:04:57.008]                     else if (inherits(cond, "warning")) {
[18:04:57.008]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.008]                       if (muffled) 
[18:04:57.008]                         invokeRestart("muffleWarning")
[18:04:57.008]                     }
[18:04:57.008]                     else if (inherits(cond, "condition")) {
[18:04:57.008]                       if (!is.null(pattern)) {
[18:04:57.008]                         computeRestarts <- base::computeRestarts
[18:04:57.008]                         grepl <- base::grepl
[18:04:57.008]                         restarts <- computeRestarts(cond)
[18:04:57.008]                         for (restart in restarts) {
[18:04:57.008]                           name <- restart$name
[18:04:57.008]                           if (is.null(name)) 
[18:04:57.008]                             next
[18:04:57.008]                           if (!grepl(pattern, name)) 
[18:04:57.008]                             next
[18:04:57.008]                           invokeRestart(restart)
[18:04:57.008]                           muffled <- TRUE
[18:04:57.008]                           break
[18:04:57.008]                         }
[18:04:57.008]                       }
[18:04:57.008]                     }
[18:04:57.008]                     invisible(muffled)
[18:04:57.008]                   }
[18:04:57.008]                   muffleCondition(cond)
[18:04:57.008]                 })
[18:04:57.008]             }))
[18:04:57.008]             future::FutureResult(value = ...future.value$value, 
[18:04:57.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.008]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.008]                     ...future.globalenv.names))
[18:04:57.008]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.008]         }, condition = base::local({
[18:04:57.008]             c <- base::c
[18:04:57.008]             inherits <- base::inherits
[18:04:57.008]             invokeRestart <- base::invokeRestart
[18:04:57.008]             length <- base::length
[18:04:57.008]             list <- base::list
[18:04:57.008]             seq.int <- base::seq.int
[18:04:57.008]             signalCondition <- base::signalCondition
[18:04:57.008]             sys.calls <- base::sys.calls
[18:04:57.008]             `[[` <- base::`[[`
[18:04:57.008]             `+` <- base::`+`
[18:04:57.008]             `<<-` <- base::`<<-`
[18:04:57.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.008]                   3L)]
[18:04:57.008]             }
[18:04:57.008]             function(cond) {
[18:04:57.008]                 is_error <- inherits(cond, "error")
[18:04:57.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.008]                   NULL)
[18:04:57.008]                 if (is_error) {
[18:04:57.008]                   sessionInformation <- function() {
[18:04:57.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.008]                       search = base::search(), system = base::Sys.info())
[18:04:57.008]                   }
[18:04:57.008]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.008]                     cond$call), session = sessionInformation(), 
[18:04:57.008]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.008]                   signalCondition(cond)
[18:04:57.008]                 }
[18:04:57.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.008]                 "immediateCondition"))) {
[18:04:57.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.008]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.008]                   if (TRUE && !signal) {
[18:04:57.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.008]                     {
[18:04:57.008]                       inherits <- base::inherits
[18:04:57.008]                       invokeRestart <- base::invokeRestart
[18:04:57.008]                       is.null <- base::is.null
[18:04:57.008]                       muffled <- FALSE
[18:04:57.008]                       if (inherits(cond, "message")) {
[18:04:57.008]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.008]                         if (muffled) 
[18:04:57.008]                           invokeRestart("muffleMessage")
[18:04:57.008]                       }
[18:04:57.008]                       else if (inherits(cond, "warning")) {
[18:04:57.008]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.008]                         if (muffled) 
[18:04:57.008]                           invokeRestart("muffleWarning")
[18:04:57.008]                       }
[18:04:57.008]                       else if (inherits(cond, "condition")) {
[18:04:57.008]                         if (!is.null(pattern)) {
[18:04:57.008]                           computeRestarts <- base::computeRestarts
[18:04:57.008]                           grepl <- base::grepl
[18:04:57.008]                           restarts <- computeRestarts(cond)
[18:04:57.008]                           for (restart in restarts) {
[18:04:57.008]                             name <- restart$name
[18:04:57.008]                             if (is.null(name)) 
[18:04:57.008]                               next
[18:04:57.008]                             if (!grepl(pattern, name)) 
[18:04:57.008]                               next
[18:04:57.008]                             invokeRestart(restart)
[18:04:57.008]                             muffled <- TRUE
[18:04:57.008]                             break
[18:04:57.008]                           }
[18:04:57.008]                         }
[18:04:57.008]                       }
[18:04:57.008]                       invisible(muffled)
[18:04:57.008]                     }
[18:04:57.008]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.008]                   }
[18:04:57.008]                 }
[18:04:57.008]                 else {
[18:04:57.008]                   if (TRUE) {
[18:04:57.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.008]                     {
[18:04:57.008]                       inherits <- base::inherits
[18:04:57.008]                       invokeRestart <- base::invokeRestart
[18:04:57.008]                       is.null <- base::is.null
[18:04:57.008]                       muffled <- FALSE
[18:04:57.008]                       if (inherits(cond, "message")) {
[18:04:57.008]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.008]                         if (muffled) 
[18:04:57.008]                           invokeRestart("muffleMessage")
[18:04:57.008]                       }
[18:04:57.008]                       else if (inherits(cond, "warning")) {
[18:04:57.008]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.008]                         if (muffled) 
[18:04:57.008]                           invokeRestart("muffleWarning")
[18:04:57.008]                       }
[18:04:57.008]                       else if (inherits(cond, "condition")) {
[18:04:57.008]                         if (!is.null(pattern)) {
[18:04:57.008]                           computeRestarts <- base::computeRestarts
[18:04:57.008]                           grepl <- base::grepl
[18:04:57.008]                           restarts <- computeRestarts(cond)
[18:04:57.008]                           for (restart in restarts) {
[18:04:57.008]                             name <- restart$name
[18:04:57.008]                             if (is.null(name)) 
[18:04:57.008]                               next
[18:04:57.008]                             if (!grepl(pattern, name)) 
[18:04:57.008]                               next
[18:04:57.008]                             invokeRestart(restart)
[18:04:57.008]                             muffled <- TRUE
[18:04:57.008]                             break
[18:04:57.008]                           }
[18:04:57.008]                         }
[18:04:57.008]                       }
[18:04:57.008]                       invisible(muffled)
[18:04:57.008]                     }
[18:04:57.008]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.008]                   }
[18:04:57.008]                 }
[18:04:57.008]             }
[18:04:57.008]         }))
[18:04:57.008]     }, error = function(ex) {
[18:04:57.008]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.008]                 ...future.rng), started = ...future.startTime, 
[18:04:57.008]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.008]             version = "1.8"), class = "FutureResult")
[18:04:57.008]     }, finally = {
[18:04:57.008]         if (!identical(...future.workdir, getwd())) 
[18:04:57.008]             setwd(...future.workdir)
[18:04:57.008]         {
[18:04:57.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.008]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.008]             }
[18:04:57.008]             base::options(...future.oldOptions)
[18:04:57.008]             if (.Platform$OS.type == "windows") {
[18:04:57.008]                 old_names <- names(...future.oldEnvVars)
[18:04:57.008]                 envs <- base::Sys.getenv()
[18:04:57.008]                 names <- names(envs)
[18:04:57.008]                 common <- intersect(names, old_names)
[18:04:57.008]                 added <- setdiff(names, old_names)
[18:04:57.008]                 removed <- setdiff(old_names, names)
[18:04:57.008]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.008]                   envs[common]]
[18:04:57.008]                 NAMES <- toupper(changed)
[18:04:57.008]                 args <- list()
[18:04:57.008]                 for (kk in seq_along(NAMES)) {
[18:04:57.008]                   name <- changed[[kk]]
[18:04:57.008]                   NAME <- NAMES[[kk]]
[18:04:57.008]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.008]                     next
[18:04:57.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.008]                 }
[18:04:57.008]                 NAMES <- toupper(added)
[18:04:57.008]                 for (kk in seq_along(NAMES)) {
[18:04:57.008]                   name <- added[[kk]]
[18:04:57.008]                   NAME <- NAMES[[kk]]
[18:04:57.008]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.008]                     next
[18:04:57.008]                   args[[name]] <- ""
[18:04:57.008]                 }
[18:04:57.008]                 NAMES <- toupper(removed)
[18:04:57.008]                 for (kk in seq_along(NAMES)) {
[18:04:57.008]                   name <- removed[[kk]]
[18:04:57.008]                   NAME <- NAMES[[kk]]
[18:04:57.008]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.008]                     next
[18:04:57.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.008]                 }
[18:04:57.008]                 if (length(args) > 0) 
[18:04:57.008]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.008]             }
[18:04:57.008]             else {
[18:04:57.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.008]             }
[18:04:57.008]             {
[18:04:57.008]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.008]                   0L) {
[18:04:57.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.008]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.008]                   base::options(opts)
[18:04:57.008]                 }
[18:04:57.008]                 {
[18:04:57.008]                   {
[18:04:57.008]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.008]                     NULL
[18:04:57.008]                   }
[18:04:57.008]                   options(future.plan = NULL)
[18:04:57.008]                   if (is.na(NA_character_)) 
[18:04:57.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.008]                     .init = FALSE)
[18:04:57.008]                 }
[18:04:57.008]             }
[18:04:57.008]         }
[18:04:57.008]     })
[18:04:57.008]     if (TRUE) {
[18:04:57.008]         base::sink(type = "output", split = FALSE)
[18:04:57.008]         if (TRUE) {
[18:04:57.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.008]         }
[18:04:57.008]         else {
[18:04:57.008]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.008]         }
[18:04:57.008]         base::close(...future.stdout)
[18:04:57.008]         ...future.stdout <- NULL
[18:04:57.008]     }
[18:04:57.008]     ...future.result$conditions <- ...future.conditions
[18:04:57.008]     ...future.result$finished <- base::Sys.time()
[18:04:57.008]     ...future.result
[18:04:57.008] }
[18:04:57.013] assign_globals() ...
[18:04:57.013] List of 1
[18:04:57.013]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5b9576e3bfc0> 
[18:04:57.013]  - attr(*, "where")=List of 1
[18:04:57.013]   ..$ a:<environment: R_EmptyEnv> 
[18:04:57.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.013]  - attr(*, "resolved")= logi TRUE
[18:04:57.013]  - attr(*, "total_size")= num 10816
[18:04:57.013]  - attr(*, "already-done")= logi TRUE
[18:04:57.019] - copied ‘a’ to environment
[18:04:57.019] assign_globals() ... done
[18:04:57.020] requestCore(): workers = 2
[18:04:57.023] MulticoreFuture started
[18:04:57.024] - Launch lazy future ... done
[18:04:57.025] run() for ‘MulticoreFuture’ ... done
[18:04:57.026] result() for MulticoreFuture ...
[18:04:57.028] plan(): Setting new future strategy stack:
[18:04:57.029] List of future strategies:
[18:04:57.029] 1. sequential:
[18:04:57.029]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.029]    - tweaked: FALSE
[18:04:57.029]    - call: NULL
[18:04:57.031] plan(): nbrOfWorkers() = 1
[18:04:57.038] plan(): Setting new future strategy stack:
[18:04:57.039] List of future strategies:
[18:04:57.039] 1. multicore:
[18:04:57.039]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.039]    - tweaked: FALSE
[18:04:57.039]    - call: plan(strategy)
[18:04:57.049] plan(): nbrOfWorkers() = 2
[18:04:57.050] result() for MulticoreFuture ...
[18:04:57.051] result() for MulticoreFuture ... done
[18:04:57.051] signalConditions() ...
[18:04:57.051]  - include = ‘immediateCondition’
[18:04:57.051]  - exclude = 
[18:04:57.052]  - resignal = FALSE
[18:04:57.052]  - Number of conditions: 4
[18:04:57.052] signalConditions() ... done
[18:04:57.053] result() for MulticoreFuture ... done
[18:04:57.053] result() for MulticoreFuture ...
[18:04:57.053] result() for MulticoreFuture ... done
[18:04:57.053] signalConditions() ...
[18:04:57.054]  - include = ‘immediateCondition’
[18:04:57.054]  - exclude = 
[18:04:57.054]  - resignal = FALSE
[18:04:57.054]  - Number of conditions: 4
[18:04:57.055] signalConditions() ... done
[18:04:57.055] Future state: ‘finished’
[18:04:57.055] result() for MulticoreFuture ...
[18:04:57.055] result() for MulticoreFuture ... done
[18:04:57.056] signalConditions() ...
[18:04:57.056]  - include = ‘condition’
[18:04:57.056]  - exclude = ‘immediateCondition’
[18:04:57.056]  - resignal = TRUE
[18:04:57.057]  - Number of conditions: 4
[18:04:57.057]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.034] result() for MulticoreFuture ...
[18:04:57.057]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.035] result() for MulticoreFuture ... done
[18:04:57.058]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.035] result() for MulticoreFuture ...
[18:04:57.058]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.036] result() for MulticoreFuture ... done
[18:04:57.058] signalConditions() ... done
value(b) = 2
[18:04:57.059] result() for MulticoreFuture ...
[18:04:57.059] result() for MulticoreFuture ... done
[18:04:57.059] result() for MulticoreFuture ...
[18:04:57.059] result() for MulticoreFuture ... done
[18:04:57.060] signalConditions() ...
[18:04:57.060]  - include = ‘immediateCondition’
[18:04:57.060]  - exclude = 
[18:04:57.060]  - resignal = FALSE
[18:04:57.060]  - Number of conditions: 4
[18:04:57.061] signalConditions() ... done
[18:04:57.061] Future state: ‘finished’
[18:04:57.061] result() for MulticoreFuture ...
[18:04:57.062] result() for MulticoreFuture ... done
[18:04:57.062] signalConditions() ...
[18:04:57.062]  - include = ‘condition’
[18:04:57.062]  - exclude = ‘immediateCondition’
[18:04:57.062]  - resignal = TRUE
[18:04:57.063]  - Number of conditions: 4
[18:04:57.063]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.034] result() for MulticoreFuture ...
[18:04:57.063]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.035] result() for MulticoreFuture ... done
[18:04:57.064]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.035] result() for MulticoreFuture ...
[18:04:57.064]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.036] result() for MulticoreFuture ... done
[18:04:57.064] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.068] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.069] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:57.071] 
[18:04:57.071] Searching for globals ... DONE
[18:04:57.072] - globals: [0] <none>
[18:04:57.072] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.073] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.074] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:57.076] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:57.076] Searching for globals ... DONE
[18:04:57.077] Resolving globals: TRUE
[18:04:57.077] Resolving any globals that are futures ...
[18:04:57.077] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:57.077] Resolving any globals that are futures ... DONE
[18:04:57.078] Resolving futures part of globals (recursively) ...
[18:04:57.079] resolve() on list ...
[18:04:57.079]  recursive: 99
[18:04:57.079]  length: 1
[18:04:57.079]  elements: ‘a’
[18:04:57.080] run() for ‘Future’ ...
[18:04:57.080] - state: ‘created’
[18:04:57.080] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.088] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.088]   - Field: ‘label’
[18:04:57.089]   - Field: ‘local’
[18:04:57.089]   - Field: ‘owner’
[18:04:57.089]   - Field: ‘envir’
[18:04:57.089]   - Field: ‘workers’
[18:04:57.090]   - Field: ‘packages’
[18:04:57.090]   - Field: ‘gc’
[18:04:57.090]   - Field: ‘job’
[18:04:57.090]   - Field: ‘conditions’
[18:04:57.091]   - Field: ‘expr’
[18:04:57.091]   - Field: ‘uuid’
[18:04:57.091]   - Field: ‘seed’
[18:04:57.091]   - Field: ‘version’
[18:04:57.091]   - Field: ‘result’
[18:04:57.092]   - Field: ‘asynchronous’
[18:04:57.092]   - Field: ‘calls’
[18:04:57.092]   - Field: ‘globals’
[18:04:57.092]   - Field: ‘stdout’
[18:04:57.093]   - Field: ‘earlySignal’
[18:04:57.093]   - Field: ‘lazy’
[18:04:57.093]   - Field: ‘state’
[18:04:57.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.094] - Launch lazy future ...
[18:04:57.094] Packages needed by the future expression (n = 0): <none>
[18:04:57.095] Packages needed by future strategies (n = 0): <none>
[18:04:57.096] {
[18:04:57.096]     {
[18:04:57.096]         {
[18:04:57.096]             ...future.startTime <- base::Sys.time()
[18:04:57.096]             {
[18:04:57.096]                 {
[18:04:57.096]                   {
[18:04:57.096]                     {
[18:04:57.096]                       base::local({
[18:04:57.096]                         has_future <- base::requireNamespace("future", 
[18:04:57.096]                           quietly = TRUE)
[18:04:57.096]                         if (has_future) {
[18:04:57.096]                           ns <- base::getNamespace("future")
[18:04:57.096]                           version <- ns[[".package"]][["version"]]
[18:04:57.096]                           if (is.null(version)) 
[18:04:57.096]                             version <- utils::packageVersion("future")
[18:04:57.096]                         }
[18:04:57.096]                         else {
[18:04:57.096]                           version <- NULL
[18:04:57.096]                         }
[18:04:57.096]                         if (!has_future || version < "1.8.0") {
[18:04:57.096]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.096]                             "", base::R.version$version.string), 
[18:04:57.096]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:57.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:57.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.096]                               "release", "version")], collapse = " "), 
[18:04:57.096]                             hostname = base::Sys.info()[["nodename"]])
[18:04:57.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.096]                             info)
[18:04:57.096]                           info <- base::paste(info, collapse = "; ")
[18:04:57.096]                           if (!has_future) {
[18:04:57.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.096]                               info)
[18:04:57.096]                           }
[18:04:57.096]                           else {
[18:04:57.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.096]                               info, version)
[18:04:57.096]                           }
[18:04:57.096]                           base::stop(msg)
[18:04:57.096]                         }
[18:04:57.096]                       })
[18:04:57.096]                     }
[18:04:57.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.096]                     base::options(mc.cores = 1L)
[18:04:57.096]                   }
[18:04:57.096]                   ...future.strategy.old <- future::plan("list")
[18:04:57.096]                   options(future.plan = NULL)
[18:04:57.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.096]                 }
[18:04:57.096]                 ...future.workdir <- getwd()
[18:04:57.096]             }
[18:04:57.096]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.096]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.096]         }
[18:04:57.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.096]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:57.096]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.096]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.096]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.096]             base::names(...future.oldOptions))
[18:04:57.096]     }
[18:04:57.096]     if (FALSE) {
[18:04:57.096]     }
[18:04:57.096]     else {
[18:04:57.096]         if (TRUE) {
[18:04:57.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.096]                 open = "w")
[18:04:57.096]         }
[18:04:57.096]         else {
[18:04:57.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.096]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.096]         }
[18:04:57.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.096]             base::sink(type = "output", split = FALSE)
[18:04:57.096]             base::close(...future.stdout)
[18:04:57.096]         }, add = TRUE)
[18:04:57.096]     }
[18:04:57.096]     ...future.frame <- base::sys.nframe()
[18:04:57.096]     ...future.conditions <- base::list()
[18:04:57.096]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.096]     if (FALSE) {
[18:04:57.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.096]     }
[18:04:57.096]     ...future.result <- base::tryCatch({
[18:04:57.096]         base::withCallingHandlers({
[18:04:57.096]             ...future.value <- base::withVisible(base::local({
[18:04:57.096]                 withCallingHandlers({
[18:04:57.096]                   1
[18:04:57.096]                 }, immediateCondition = function(cond) {
[18:04:57.096]                   save_rds <- function (object, pathname, ...) 
[18:04:57.096]                   {
[18:04:57.096]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.096]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.096]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.096]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.096]                         fi_tmp[["mtime"]])
[18:04:57.096]                     }
[18:04:57.096]                     tryCatch({
[18:04:57.096]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.096]                     }, error = function(ex) {
[18:04:57.096]                       msg <- conditionMessage(ex)
[18:04:57.096]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.096]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.096]                         fi_tmp[["mtime"]], msg)
[18:04:57.096]                       ex$message <- msg
[18:04:57.096]                       stop(ex)
[18:04:57.096]                     })
[18:04:57.096]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.096]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.096]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.096]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.096]                       fi <- file.info(pathname)
[18:04:57.096]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.096]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.096]                         fi[["size"]], fi[["mtime"]])
[18:04:57.096]                       stop(msg)
[18:04:57.096]                     }
[18:04:57.096]                     invisible(pathname)
[18:04:57.096]                   }
[18:04:57.096]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.096]                     rootPath = tempdir()) 
[18:04:57.096]                   {
[18:04:57.096]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.096]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.096]                       tmpdir = path, fileext = ".rds")
[18:04:57.096]                     save_rds(obj, file)
[18:04:57.096]                   }
[18:04:57.096]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.096]                   {
[18:04:57.096]                     inherits <- base::inherits
[18:04:57.096]                     invokeRestart <- base::invokeRestart
[18:04:57.096]                     is.null <- base::is.null
[18:04:57.096]                     muffled <- FALSE
[18:04:57.096]                     if (inherits(cond, "message")) {
[18:04:57.096]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.096]                       if (muffled) 
[18:04:57.096]                         invokeRestart("muffleMessage")
[18:04:57.096]                     }
[18:04:57.096]                     else if (inherits(cond, "warning")) {
[18:04:57.096]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.096]                       if (muffled) 
[18:04:57.096]                         invokeRestart("muffleWarning")
[18:04:57.096]                     }
[18:04:57.096]                     else if (inherits(cond, "condition")) {
[18:04:57.096]                       if (!is.null(pattern)) {
[18:04:57.096]                         computeRestarts <- base::computeRestarts
[18:04:57.096]                         grepl <- base::grepl
[18:04:57.096]                         restarts <- computeRestarts(cond)
[18:04:57.096]                         for (restart in restarts) {
[18:04:57.096]                           name <- restart$name
[18:04:57.096]                           if (is.null(name)) 
[18:04:57.096]                             next
[18:04:57.096]                           if (!grepl(pattern, name)) 
[18:04:57.096]                             next
[18:04:57.096]                           invokeRestart(restart)
[18:04:57.096]                           muffled <- TRUE
[18:04:57.096]                           break
[18:04:57.096]                         }
[18:04:57.096]                       }
[18:04:57.096]                     }
[18:04:57.096]                     invisible(muffled)
[18:04:57.096]                   }
[18:04:57.096]                   muffleCondition(cond)
[18:04:57.096]                 })
[18:04:57.096]             }))
[18:04:57.096]             future::FutureResult(value = ...future.value$value, 
[18:04:57.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.096]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.096]                     ...future.globalenv.names))
[18:04:57.096]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.096]         }, condition = base::local({
[18:04:57.096]             c <- base::c
[18:04:57.096]             inherits <- base::inherits
[18:04:57.096]             invokeRestart <- base::invokeRestart
[18:04:57.096]             length <- base::length
[18:04:57.096]             list <- base::list
[18:04:57.096]             seq.int <- base::seq.int
[18:04:57.096]             signalCondition <- base::signalCondition
[18:04:57.096]             sys.calls <- base::sys.calls
[18:04:57.096]             `[[` <- base::`[[`
[18:04:57.096]             `+` <- base::`+`
[18:04:57.096]             `<<-` <- base::`<<-`
[18:04:57.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.096]                   3L)]
[18:04:57.096]             }
[18:04:57.096]             function(cond) {
[18:04:57.096]                 is_error <- inherits(cond, "error")
[18:04:57.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.096]                   NULL)
[18:04:57.096]                 if (is_error) {
[18:04:57.096]                   sessionInformation <- function() {
[18:04:57.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.096]                       search = base::search(), system = base::Sys.info())
[18:04:57.096]                   }
[18:04:57.096]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.096]                     cond$call), session = sessionInformation(), 
[18:04:57.096]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.096]                   signalCondition(cond)
[18:04:57.096]                 }
[18:04:57.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.096]                 "immediateCondition"))) {
[18:04:57.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.096]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.096]                   if (TRUE && !signal) {
[18:04:57.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.096]                     {
[18:04:57.096]                       inherits <- base::inherits
[18:04:57.096]                       invokeRestart <- base::invokeRestart
[18:04:57.096]                       is.null <- base::is.null
[18:04:57.096]                       muffled <- FALSE
[18:04:57.096]                       if (inherits(cond, "message")) {
[18:04:57.096]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.096]                         if (muffled) 
[18:04:57.096]                           invokeRestart("muffleMessage")
[18:04:57.096]                       }
[18:04:57.096]                       else if (inherits(cond, "warning")) {
[18:04:57.096]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.096]                         if (muffled) 
[18:04:57.096]                           invokeRestart("muffleWarning")
[18:04:57.096]                       }
[18:04:57.096]                       else if (inherits(cond, "condition")) {
[18:04:57.096]                         if (!is.null(pattern)) {
[18:04:57.096]                           computeRestarts <- base::computeRestarts
[18:04:57.096]                           grepl <- base::grepl
[18:04:57.096]                           restarts <- computeRestarts(cond)
[18:04:57.096]                           for (restart in restarts) {
[18:04:57.096]                             name <- restart$name
[18:04:57.096]                             if (is.null(name)) 
[18:04:57.096]                               next
[18:04:57.096]                             if (!grepl(pattern, name)) 
[18:04:57.096]                               next
[18:04:57.096]                             invokeRestart(restart)
[18:04:57.096]                             muffled <- TRUE
[18:04:57.096]                             break
[18:04:57.096]                           }
[18:04:57.096]                         }
[18:04:57.096]                       }
[18:04:57.096]                       invisible(muffled)
[18:04:57.096]                     }
[18:04:57.096]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.096]                   }
[18:04:57.096]                 }
[18:04:57.096]                 else {
[18:04:57.096]                   if (TRUE) {
[18:04:57.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.096]                     {
[18:04:57.096]                       inherits <- base::inherits
[18:04:57.096]                       invokeRestart <- base::invokeRestart
[18:04:57.096]                       is.null <- base::is.null
[18:04:57.096]                       muffled <- FALSE
[18:04:57.096]                       if (inherits(cond, "message")) {
[18:04:57.096]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.096]                         if (muffled) 
[18:04:57.096]                           invokeRestart("muffleMessage")
[18:04:57.096]                       }
[18:04:57.096]                       else if (inherits(cond, "warning")) {
[18:04:57.096]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.096]                         if (muffled) 
[18:04:57.096]                           invokeRestart("muffleWarning")
[18:04:57.096]                       }
[18:04:57.096]                       else if (inherits(cond, "condition")) {
[18:04:57.096]                         if (!is.null(pattern)) {
[18:04:57.096]                           computeRestarts <- base::computeRestarts
[18:04:57.096]                           grepl <- base::grepl
[18:04:57.096]                           restarts <- computeRestarts(cond)
[18:04:57.096]                           for (restart in restarts) {
[18:04:57.096]                             name <- restart$name
[18:04:57.096]                             if (is.null(name)) 
[18:04:57.096]                               next
[18:04:57.096]                             if (!grepl(pattern, name)) 
[18:04:57.096]                               next
[18:04:57.096]                             invokeRestart(restart)
[18:04:57.096]                             muffled <- TRUE
[18:04:57.096]                             break
[18:04:57.096]                           }
[18:04:57.096]                         }
[18:04:57.096]                       }
[18:04:57.096]                       invisible(muffled)
[18:04:57.096]                     }
[18:04:57.096]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.096]                   }
[18:04:57.096]                 }
[18:04:57.096]             }
[18:04:57.096]         }))
[18:04:57.096]     }, error = function(ex) {
[18:04:57.096]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.096]                 ...future.rng), started = ...future.startTime, 
[18:04:57.096]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.096]             version = "1.8"), class = "FutureResult")
[18:04:57.096]     }, finally = {
[18:04:57.096]         if (!identical(...future.workdir, getwd())) 
[18:04:57.096]             setwd(...future.workdir)
[18:04:57.096]         {
[18:04:57.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.096]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.096]             }
[18:04:57.096]             base::options(...future.oldOptions)
[18:04:57.096]             if (.Platform$OS.type == "windows") {
[18:04:57.096]                 old_names <- names(...future.oldEnvVars)
[18:04:57.096]                 envs <- base::Sys.getenv()
[18:04:57.096]                 names <- names(envs)
[18:04:57.096]                 common <- intersect(names, old_names)
[18:04:57.096]                 added <- setdiff(names, old_names)
[18:04:57.096]                 removed <- setdiff(old_names, names)
[18:04:57.096]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.096]                   envs[common]]
[18:04:57.096]                 NAMES <- toupper(changed)
[18:04:57.096]                 args <- list()
[18:04:57.096]                 for (kk in seq_along(NAMES)) {
[18:04:57.096]                   name <- changed[[kk]]
[18:04:57.096]                   NAME <- NAMES[[kk]]
[18:04:57.096]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.096]                     next
[18:04:57.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.096]                 }
[18:04:57.096]                 NAMES <- toupper(added)
[18:04:57.096]                 for (kk in seq_along(NAMES)) {
[18:04:57.096]                   name <- added[[kk]]
[18:04:57.096]                   NAME <- NAMES[[kk]]
[18:04:57.096]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.096]                     next
[18:04:57.096]                   args[[name]] <- ""
[18:04:57.096]                 }
[18:04:57.096]                 NAMES <- toupper(removed)
[18:04:57.096]                 for (kk in seq_along(NAMES)) {
[18:04:57.096]                   name <- removed[[kk]]
[18:04:57.096]                   NAME <- NAMES[[kk]]
[18:04:57.096]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.096]                     next
[18:04:57.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.096]                 }
[18:04:57.096]                 if (length(args) > 0) 
[18:04:57.096]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.096]             }
[18:04:57.096]             else {
[18:04:57.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.096]             }
[18:04:57.096]             {
[18:04:57.096]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.096]                   0L) {
[18:04:57.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.096]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.096]                   base::options(opts)
[18:04:57.096]                 }
[18:04:57.096]                 {
[18:04:57.096]                   {
[18:04:57.096]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.096]                     NULL
[18:04:57.096]                   }
[18:04:57.096]                   options(future.plan = NULL)
[18:04:57.096]                   if (is.na(NA_character_)) 
[18:04:57.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.096]                     .init = FALSE)
[18:04:57.096]                 }
[18:04:57.096]             }
[18:04:57.096]         }
[18:04:57.096]     })
[18:04:57.096]     if (TRUE) {
[18:04:57.096]         base::sink(type = "output", split = FALSE)
[18:04:57.096]         if (TRUE) {
[18:04:57.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.096]         }
[18:04:57.096]         else {
[18:04:57.096]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.096]         }
[18:04:57.096]         base::close(...future.stdout)
[18:04:57.096]         ...future.stdout <- NULL
[18:04:57.096]     }
[18:04:57.096]     ...future.result$conditions <- ...future.conditions
[18:04:57.096]     ...future.result$finished <- base::Sys.time()
[18:04:57.096]     ...future.result
[18:04:57.096] }
[18:04:57.100] requestCore(): workers = 2
[18:04:57.104] MulticoreFuture started
[18:04:57.105] - Launch lazy future ... done
[18:04:57.106] run() for ‘MulticoreFuture’ ... done
[18:04:57.107] plan(): Setting new future strategy stack:
[18:04:57.108] List of future strategies:
[18:04:57.108] 1. sequential:
[18:04:57.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.108]    - tweaked: FALSE
[18:04:57.108]    - call: NULL
[18:04:57.110] plan(): nbrOfWorkers() = 1
[18:04:57.115] plan(): Setting new future strategy stack:
[18:04:57.115] List of future strategies:
[18:04:57.115] 1. multicore:
[18:04:57.115]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.115]    - tweaked: FALSE
[18:04:57.115]    - call: plan(strategy)
[18:04:57.125] plan(): nbrOfWorkers() = 2
[18:04:57.129] Future #1
[18:04:57.129] result() for MulticoreFuture ...
[18:04:57.131] result() for MulticoreFuture ...
[18:04:57.131] result() for MulticoreFuture ... done
[18:04:57.132] result() for MulticoreFuture ... done
[18:04:57.134] result() for MulticoreFuture ...
[18:04:57.134] result() for MulticoreFuture ... done
[18:04:57.135] A MulticoreFuture was resolved
[18:04:57.135]  length: 0 (resolved future 1)
[18:04:57.135] resolve() on list ... DONE
[18:04:57.136] - globals: [1] ‘a’
[18:04:57.136] Resolving futures part of globals (recursively) ... DONE
[18:04:57.138] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[18:04:57.139] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[18:04:57.140] - globals: [1] ‘a’
[18:04:57.140] - packages: [1] ‘future’
[18:04:57.141] getGlobalsAndPackages() ... DONE
[18:04:57.141] run() for ‘Future’ ...
[18:04:57.141] - state: ‘created’
[18:04:57.142] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.149] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.150] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.150]   - Field: ‘label’
[18:04:57.150]   - Field: ‘local’
[18:04:57.150]   - Field: ‘owner’
[18:04:57.151]   - Field: ‘envir’
[18:04:57.151]   - Field: ‘workers’
[18:04:57.151]   - Field: ‘packages’
[18:04:57.151]   - Field: ‘gc’
[18:04:57.152]   - Field: ‘job’
[18:04:57.152]   - Field: ‘conditions’
[18:04:57.152]   - Field: ‘expr’
[18:04:57.152]   - Field: ‘uuid’
[18:04:57.153]   - Field: ‘seed’
[18:04:57.153]   - Field: ‘version’
[18:04:57.153]   - Field: ‘result’
[18:04:57.153]   - Field: ‘asynchronous’
[18:04:57.154]   - Field: ‘calls’
[18:04:57.154]   - Field: ‘globals’
[18:04:57.154]   - Field: ‘stdout’
[18:04:57.154]   - Field: ‘earlySignal’
[18:04:57.155]   - Field: ‘lazy’
[18:04:57.155]   - Field: ‘state’
[18:04:57.155] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.155] - Launch lazy future ...
[18:04:57.156] Packages needed by the future expression (n = 1): ‘future’
[18:04:57.156] Packages needed by future strategies (n = 0): <none>
[18:04:57.157] {
[18:04:57.157]     {
[18:04:57.157]         {
[18:04:57.157]             ...future.startTime <- base::Sys.time()
[18:04:57.157]             {
[18:04:57.157]                 {
[18:04:57.157]                   {
[18:04:57.157]                     {
[18:04:57.157]                       {
[18:04:57.157]                         base::local({
[18:04:57.157]                           has_future <- base::requireNamespace("future", 
[18:04:57.157]                             quietly = TRUE)
[18:04:57.157]                           if (has_future) {
[18:04:57.157]                             ns <- base::getNamespace("future")
[18:04:57.157]                             version <- ns[[".package"]][["version"]]
[18:04:57.157]                             if (is.null(version)) 
[18:04:57.157]                               version <- utils::packageVersion("future")
[18:04:57.157]                           }
[18:04:57.157]                           else {
[18:04:57.157]                             version <- NULL
[18:04:57.157]                           }
[18:04:57.157]                           if (!has_future || version < "1.8.0") {
[18:04:57.157]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.157]                               "", base::R.version$version.string), 
[18:04:57.157]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:57.157]                                 base::R.version$platform, 8 * 
[18:04:57.157]                                   base::.Machine$sizeof.pointer), 
[18:04:57.157]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.157]                                 "release", "version")], collapse = " "), 
[18:04:57.157]                               hostname = base::Sys.info()[["nodename"]])
[18:04:57.157]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.157]                               info)
[18:04:57.157]                             info <- base::paste(info, collapse = "; ")
[18:04:57.157]                             if (!has_future) {
[18:04:57.157]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.157]                                 info)
[18:04:57.157]                             }
[18:04:57.157]                             else {
[18:04:57.157]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.157]                                 info, version)
[18:04:57.157]                             }
[18:04:57.157]                             base::stop(msg)
[18:04:57.157]                           }
[18:04:57.157]                         })
[18:04:57.157]                       }
[18:04:57.157]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.157]                       base::options(mc.cores = 1L)
[18:04:57.157]                     }
[18:04:57.157]                     base::local({
[18:04:57.157]                       for (pkg in "future") {
[18:04:57.157]                         base::loadNamespace(pkg)
[18:04:57.157]                         base::library(pkg, character.only = TRUE)
[18:04:57.157]                       }
[18:04:57.157]                     })
[18:04:57.157]                   }
[18:04:57.157]                   ...future.strategy.old <- future::plan("list")
[18:04:57.157]                   options(future.plan = NULL)
[18:04:57.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.157]                 }
[18:04:57.157]                 ...future.workdir <- getwd()
[18:04:57.157]             }
[18:04:57.157]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.157]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.157]         }
[18:04:57.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.157]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:57.157]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.157]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.157]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.157]             base::names(...future.oldOptions))
[18:04:57.157]     }
[18:04:57.157]     if (FALSE) {
[18:04:57.157]     }
[18:04:57.157]     else {
[18:04:57.157]         if (TRUE) {
[18:04:57.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.157]                 open = "w")
[18:04:57.157]         }
[18:04:57.157]         else {
[18:04:57.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.157]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.157]         }
[18:04:57.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.157]             base::sink(type = "output", split = FALSE)
[18:04:57.157]             base::close(...future.stdout)
[18:04:57.157]         }, add = TRUE)
[18:04:57.157]     }
[18:04:57.157]     ...future.frame <- base::sys.nframe()
[18:04:57.157]     ...future.conditions <- base::list()
[18:04:57.157]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.157]     if (FALSE) {
[18:04:57.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.157]     }
[18:04:57.157]     ...future.result <- base::tryCatch({
[18:04:57.157]         base::withCallingHandlers({
[18:04:57.157]             ...future.value <- base::withVisible(base::local({
[18:04:57.157]                 withCallingHandlers({
[18:04:57.157]                   value(a) + 1
[18:04:57.157]                 }, immediateCondition = function(cond) {
[18:04:57.157]                   save_rds <- function (object, pathname, ...) 
[18:04:57.157]                   {
[18:04:57.157]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.157]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.157]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.157]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.157]                         fi_tmp[["mtime"]])
[18:04:57.157]                     }
[18:04:57.157]                     tryCatch({
[18:04:57.157]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.157]                     }, error = function(ex) {
[18:04:57.157]                       msg <- conditionMessage(ex)
[18:04:57.157]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.157]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.157]                         fi_tmp[["mtime"]], msg)
[18:04:57.157]                       ex$message <- msg
[18:04:57.157]                       stop(ex)
[18:04:57.157]                     })
[18:04:57.157]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.157]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.157]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.157]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.157]                       fi <- file.info(pathname)
[18:04:57.157]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.157]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.157]                         fi[["size"]], fi[["mtime"]])
[18:04:57.157]                       stop(msg)
[18:04:57.157]                     }
[18:04:57.157]                     invisible(pathname)
[18:04:57.157]                   }
[18:04:57.157]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.157]                     rootPath = tempdir()) 
[18:04:57.157]                   {
[18:04:57.157]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.157]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.157]                       tmpdir = path, fileext = ".rds")
[18:04:57.157]                     save_rds(obj, file)
[18:04:57.157]                   }
[18:04:57.157]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.157]                   {
[18:04:57.157]                     inherits <- base::inherits
[18:04:57.157]                     invokeRestart <- base::invokeRestart
[18:04:57.157]                     is.null <- base::is.null
[18:04:57.157]                     muffled <- FALSE
[18:04:57.157]                     if (inherits(cond, "message")) {
[18:04:57.157]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.157]                       if (muffled) 
[18:04:57.157]                         invokeRestart("muffleMessage")
[18:04:57.157]                     }
[18:04:57.157]                     else if (inherits(cond, "warning")) {
[18:04:57.157]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.157]                       if (muffled) 
[18:04:57.157]                         invokeRestart("muffleWarning")
[18:04:57.157]                     }
[18:04:57.157]                     else if (inherits(cond, "condition")) {
[18:04:57.157]                       if (!is.null(pattern)) {
[18:04:57.157]                         computeRestarts <- base::computeRestarts
[18:04:57.157]                         grepl <- base::grepl
[18:04:57.157]                         restarts <- computeRestarts(cond)
[18:04:57.157]                         for (restart in restarts) {
[18:04:57.157]                           name <- restart$name
[18:04:57.157]                           if (is.null(name)) 
[18:04:57.157]                             next
[18:04:57.157]                           if (!grepl(pattern, name)) 
[18:04:57.157]                             next
[18:04:57.157]                           invokeRestart(restart)
[18:04:57.157]                           muffled <- TRUE
[18:04:57.157]                           break
[18:04:57.157]                         }
[18:04:57.157]                       }
[18:04:57.157]                     }
[18:04:57.157]                     invisible(muffled)
[18:04:57.157]                   }
[18:04:57.157]                   muffleCondition(cond)
[18:04:57.157]                 })
[18:04:57.157]             }))
[18:04:57.157]             future::FutureResult(value = ...future.value$value, 
[18:04:57.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.157]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.157]                     ...future.globalenv.names))
[18:04:57.157]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.157]         }, condition = base::local({
[18:04:57.157]             c <- base::c
[18:04:57.157]             inherits <- base::inherits
[18:04:57.157]             invokeRestart <- base::invokeRestart
[18:04:57.157]             length <- base::length
[18:04:57.157]             list <- base::list
[18:04:57.157]             seq.int <- base::seq.int
[18:04:57.157]             signalCondition <- base::signalCondition
[18:04:57.157]             sys.calls <- base::sys.calls
[18:04:57.157]             `[[` <- base::`[[`
[18:04:57.157]             `+` <- base::`+`
[18:04:57.157]             `<<-` <- base::`<<-`
[18:04:57.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.157]                   3L)]
[18:04:57.157]             }
[18:04:57.157]             function(cond) {
[18:04:57.157]                 is_error <- inherits(cond, "error")
[18:04:57.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.157]                   NULL)
[18:04:57.157]                 if (is_error) {
[18:04:57.157]                   sessionInformation <- function() {
[18:04:57.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.157]                       search = base::search(), system = base::Sys.info())
[18:04:57.157]                   }
[18:04:57.157]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.157]                     cond$call), session = sessionInformation(), 
[18:04:57.157]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.157]                   signalCondition(cond)
[18:04:57.157]                 }
[18:04:57.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.157]                 "immediateCondition"))) {
[18:04:57.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.157]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.157]                   if (TRUE && !signal) {
[18:04:57.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.157]                     {
[18:04:57.157]                       inherits <- base::inherits
[18:04:57.157]                       invokeRestart <- base::invokeRestart
[18:04:57.157]                       is.null <- base::is.null
[18:04:57.157]                       muffled <- FALSE
[18:04:57.157]                       if (inherits(cond, "message")) {
[18:04:57.157]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.157]                         if (muffled) 
[18:04:57.157]                           invokeRestart("muffleMessage")
[18:04:57.157]                       }
[18:04:57.157]                       else if (inherits(cond, "warning")) {
[18:04:57.157]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.157]                         if (muffled) 
[18:04:57.157]                           invokeRestart("muffleWarning")
[18:04:57.157]                       }
[18:04:57.157]                       else if (inherits(cond, "condition")) {
[18:04:57.157]                         if (!is.null(pattern)) {
[18:04:57.157]                           computeRestarts <- base::computeRestarts
[18:04:57.157]                           grepl <- base::grepl
[18:04:57.157]                           restarts <- computeRestarts(cond)
[18:04:57.157]                           for (restart in restarts) {
[18:04:57.157]                             name <- restart$name
[18:04:57.157]                             if (is.null(name)) 
[18:04:57.157]                               next
[18:04:57.157]                             if (!grepl(pattern, name)) 
[18:04:57.157]                               next
[18:04:57.157]                             invokeRestart(restart)
[18:04:57.157]                             muffled <- TRUE
[18:04:57.157]                             break
[18:04:57.157]                           }
[18:04:57.157]                         }
[18:04:57.157]                       }
[18:04:57.157]                       invisible(muffled)
[18:04:57.157]                     }
[18:04:57.157]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.157]                   }
[18:04:57.157]                 }
[18:04:57.157]                 else {
[18:04:57.157]                   if (TRUE) {
[18:04:57.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.157]                     {
[18:04:57.157]                       inherits <- base::inherits
[18:04:57.157]                       invokeRestart <- base::invokeRestart
[18:04:57.157]                       is.null <- base::is.null
[18:04:57.157]                       muffled <- FALSE
[18:04:57.157]                       if (inherits(cond, "message")) {
[18:04:57.157]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.157]                         if (muffled) 
[18:04:57.157]                           invokeRestart("muffleMessage")
[18:04:57.157]                       }
[18:04:57.157]                       else if (inherits(cond, "warning")) {
[18:04:57.157]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.157]                         if (muffled) 
[18:04:57.157]                           invokeRestart("muffleWarning")
[18:04:57.157]                       }
[18:04:57.157]                       else if (inherits(cond, "condition")) {
[18:04:57.157]                         if (!is.null(pattern)) {
[18:04:57.157]                           computeRestarts <- base::computeRestarts
[18:04:57.157]                           grepl <- base::grepl
[18:04:57.157]                           restarts <- computeRestarts(cond)
[18:04:57.157]                           for (restart in restarts) {
[18:04:57.157]                             name <- restart$name
[18:04:57.157]                             if (is.null(name)) 
[18:04:57.157]                               next
[18:04:57.157]                             if (!grepl(pattern, name)) 
[18:04:57.157]                               next
[18:04:57.157]                             invokeRestart(restart)
[18:04:57.157]                             muffled <- TRUE
[18:04:57.157]                             break
[18:04:57.157]                           }
[18:04:57.157]                         }
[18:04:57.157]                       }
[18:04:57.157]                       invisible(muffled)
[18:04:57.157]                     }
[18:04:57.157]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.157]                   }
[18:04:57.157]                 }
[18:04:57.157]             }
[18:04:57.157]         }))
[18:04:57.157]     }, error = function(ex) {
[18:04:57.157]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.157]                 ...future.rng), started = ...future.startTime, 
[18:04:57.157]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.157]             version = "1.8"), class = "FutureResult")
[18:04:57.157]     }, finally = {
[18:04:57.157]         if (!identical(...future.workdir, getwd())) 
[18:04:57.157]             setwd(...future.workdir)
[18:04:57.157]         {
[18:04:57.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.157]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.157]             }
[18:04:57.157]             base::options(...future.oldOptions)
[18:04:57.157]             if (.Platform$OS.type == "windows") {
[18:04:57.157]                 old_names <- names(...future.oldEnvVars)
[18:04:57.157]                 envs <- base::Sys.getenv()
[18:04:57.157]                 names <- names(envs)
[18:04:57.157]                 common <- intersect(names, old_names)
[18:04:57.157]                 added <- setdiff(names, old_names)
[18:04:57.157]                 removed <- setdiff(old_names, names)
[18:04:57.157]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.157]                   envs[common]]
[18:04:57.157]                 NAMES <- toupper(changed)
[18:04:57.157]                 args <- list()
[18:04:57.157]                 for (kk in seq_along(NAMES)) {
[18:04:57.157]                   name <- changed[[kk]]
[18:04:57.157]                   NAME <- NAMES[[kk]]
[18:04:57.157]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.157]                     next
[18:04:57.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.157]                 }
[18:04:57.157]                 NAMES <- toupper(added)
[18:04:57.157]                 for (kk in seq_along(NAMES)) {
[18:04:57.157]                   name <- added[[kk]]
[18:04:57.157]                   NAME <- NAMES[[kk]]
[18:04:57.157]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.157]                     next
[18:04:57.157]                   args[[name]] <- ""
[18:04:57.157]                 }
[18:04:57.157]                 NAMES <- toupper(removed)
[18:04:57.157]                 for (kk in seq_along(NAMES)) {
[18:04:57.157]                   name <- removed[[kk]]
[18:04:57.157]                   NAME <- NAMES[[kk]]
[18:04:57.157]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.157]                     next
[18:04:57.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.157]                 }
[18:04:57.157]                 if (length(args) > 0) 
[18:04:57.157]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.157]             }
[18:04:57.157]             else {
[18:04:57.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.157]             }
[18:04:57.157]             {
[18:04:57.157]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.157]                   0L) {
[18:04:57.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.157]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.157]                   base::options(opts)
[18:04:57.157]                 }
[18:04:57.157]                 {
[18:04:57.157]                   {
[18:04:57.157]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.157]                     NULL
[18:04:57.157]                   }
[18:04:57.157]                   options(future.plan = NULL)
[18:04:57.157]                   if (is.na(NA_character_)) 
[18:04:57.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.157]                     .init = FALSE)
[18:04:57.157]                 }
[18:04:57.157]             }
[18:04:57.157]         }
[18:04:57.157]     })
[18:04:57.157]     if (TRUE) {
[18:04:57.157]         base::sink(type = "output", split = FALSE)
[18:04:57.157]         if (TRUE) {
[18:04:57.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.157]         }
[18:04:57.157]         else {
[18:04:57.157]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.157]         }
[18:04:57.157]         base::close(...future.stdout)
[18:04:57.157]         ...future.stdout <- NULL
[18:04:57.157]     }
[18:04:57.157]     ...future.result$conditions <- ...future.conditions
[18:04:57.157]     ...future.result$finished <- base::Sys.time()
[18:04:57.157]     ...future.result
[18:04:57.157] }
[18:04:57.162] assign_globals() ...
[18:04:57.163] List of 1
[18:04:57.163]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5b9577432028> 
[18:04:57.163]  - attr(*, "where")=List of 1
[18:04:57.163]   ..$ a:<environment: R_EmptyEnv> 
[18:04:57.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.163]  - attr(*, "resolved")= logi TRUE
[18:04:57.163]  - attr(*, "total_size")= num 10984
[18:04:57.163]  - attr(*, "already-done")= logi TRUE
[18:04:57.173] - copied ‘a’ to environment
[18:04:57.173] assign_globals() ... done
[18:04:57.173] requestCore(): workers = 2
[18:04:57.177] MulticoreFuture started
[18:04:57.178] - Launch lazy future ... done
[18:04:57.178] run() for ‘MulticoreFuture’ ... done
[18:04:57.180] result() for MulticoreFuture ...
[18:04:57.180] plan(): Setting new future strategy stack:
[18:04:57.180] List of future strategies:
[18:04:57.180] 1. sequential:
[18:04:57.180]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.180]    - tweaked: FALSE
[18:04:57.180]    - call: NULL
[18:04:57.183] plan(): nbrOfWorkers() = 1
[18:04:57.192] plan(): Setting new future strategy stack:
[18:04:57.193] List of future strategies:
[18:04:57.193] 1. multicore:
[18:04:57.193]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.193]    - tweaked: FALSE
[18:04:57.193]    - call: plan(strategy)
[18:04:57.202] plan(): nbrOfWorkers() = 2
[18:04:57.204] result() for MulticoreFuture ...
[18:04:57.205] result() for MulticoreFuture ... done
[18:04:57.205] signalConditions() ...
[18:04:57.205]  - include = ‘immediateCondition’
[18:04:57.206]  - exclude = 
[18:04:57.206]  - resignal = FALSE
[18:04:57.206]  - Number of conditions: 4
[18:04:57.207] signalConditions() ... done
[18:04:57.207] result() for MulticoreFuture ... done
[18:04:57.207] result() for MulticoreFuture ...
[18:04:57.207] result() for MulticoreFuture ... done
[18:04:57.208] signalConditions() ...
[18:04:57.208]  - include = ‘immediateCondition’
[18:04:57.208]  - exclude = 
[18:04:57.208]  - resignal = FALSE
[18:04:57.209]  - Number of conditions: 4
[18:04:57.209] signalConditions() ... done
[18:04:57.209] Future state: ‘finished’
[18:04:57.210] result() for MulticoreFuture ...
[18:04:57.210] result() for MulticoreFuture ... done
[18:04:57.210] signalConditions() ...
[18:04:57.210]  - include = ‘condition’
[18:04:57.211]  - exclude = ‘immediateCondition’
[18:04:57.211]  - resignal = TRUE
[18:04:57.211]  - Number of conditions: 4
[18:04:57.211]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.187] result() for MulticoreFuture ...
[18:04:57.212]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.188] result() for MulticoreFuture ... done
[18:04:57.212]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.189] result() for MulticoreFuture ...
[18:04:57.212]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.189] result() for MulticoreFuture ... done
[18:04:57.213] signalConditions() ... done
value(b) = 2
[18:04:57.213] result() for MulticoreFuture ...
[18:04:57.213] result() for MulticoreFuture ... done
[18:04:57.214] result() for MulticoreFuture ...
[18:04:57.214] result() for MulticoreFuture ... done
[18:04:57.214] signalConditions() ...
[18:04:57.214]  - include = ‘immediateCondition’
[18:04:57.215]  - exclude = 
[18:04:57.215]  - resignal = FALSE
[18:04:57.215]  - Number of conditions: 4
[18:04:57.215] signalConditions() ... done
[18:04:57.216] Future state: ‘finished’
[18:04:57.216] result() for MulticoreFuture ...
[18:04:57.216] result() for MulticoreFuture ... done
[18:04:57.216] signalConditions() ...
[18:04:57.217]  - include = ‘condition’
[18:04:57.217]  - exclude = ‘immediateCondition’
[18:04:57.217]  - resignal = TRUE
[18:04:57.217]  - Number of conditions: 4
[18:04:57.218]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.187] result() for MulticoreFuture ...
[18:04:57.218]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.188] result() for MulticoreFuture ... done
[18:04:57.218]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.189] result() for MulticoreFuture ...
[18:04:57.219]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.189] result() for MulticoreFuture ... done
[18:04:57.219] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.219] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.220] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:57.221] 
[18:04:57.222] Searching for globals ... DONE
[18:04:57.222] - globals: [0] <none>
[18:04:57.222] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.223] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.223] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:57.226] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:57.226] Searching for globals ... DONE
[18:04:57.226] Resolving globals: TRUE
[18:04:57.226] Resolving any globals that are futures ...
[18:04:57.227] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:57.227] Resolving any globals that are futures ... DONE
[18:04:57.228] Resolving futures part of globals (recursively) ...
[18:04:57.228] resolve() on list ...
[18:04:57.228]  recursive: 99
[18:04:57.229]  length: 1
[18:04:57.229]  elements: ‘a’
[18:04:57.229] run() for ‘Future’ ...
[18:04:57.230] - state: ‘created’
[18:04:57.230] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.237] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.238]   - Field: ‘label’
[18:04:57.238]   - Field: ‘local’
[18:04:57.238]   - Field: ‘owner’
[18:04:57.238]   - Field: ‘envir’
[18:04:57.239]   - Field: ‘workers’
[18:04:57.239]   - Field: ‘packages’
[18:04:57.239]   - Field: ‘gc’
[18:04:57.239]   - Field: ‘job’
[18:04:57.240]   - Field: ‘conditions’
[18:04:57.240]   - Field: ‘expr’
[18:04:57.240]   - Field: ‘uuid’
[18:04:57.240]   - Field: ‘seed’
[18:04:57.241]   - Field: ‘version’
[18:04:57.241]   - Field: ‘result’
[18:04:57.241]   - Field: ‘asynchronous’
[18:04:57.241]   - Field: ‘calls’
[18:04:57.241]   - Field: ‘globals’
[18:04:57.242]   - Field: ‘stdout’
[18:04:57.242]   - Field: ‘earlySignal’
[18:04:57.242]   - Field: ‘lazy’
[18:04:57.242]   - Field: ‘state’
[18:04:57.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.243] - Launch lazy future ...
[18:04:57.243] Packages needed by the future expression (n = 0): <none>
[18:04:57.244] Packages needed by future strategies (n = 0): <none>
[18:04:57.245] {
[18:04:57.245]     {
[18:04:57.245]         {
[18:04:57.245]             ...future.startTime <- base::Sys.time()
[18:04:57.245]             {
[18:04:57.245]                 {
[18:04:57.245]                   {
[18:04:57.245]                     {
[18:04:57.245]                       base::local({
[18:04:57.245]                         has_future <- base::requireNamespace("future", 
[18:04:57.245]                           quietly = TRUE)
[18:04:57.245]                         if (has_future) {
[18:04:57.245]                           ns <- base::getNamespace("future")
[18:04:57.245]                           version <- ns[[".package"]][["version"]]
[18:04:57.245]                           if (is.null(version)) 
[18:04:57.245]                             version <- utils::packageVersion("future")
[18:04:57.245]                         }
[18:04:57.245]                         else {
[18:04:57.245]                           version <- NULL
[18:04:57.245]                         }
[18:04:57.245]                         if (!has_future || version < "1.8.0") {
[18:04:57.245]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.245]                             "", base::R.version$version.string), 
[18:04:57.245]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:57.245]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:57.245]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.245]                               "release", "version")], collapse = " "), 
[18:04:57.245]                             hostname = base::Sys.info()[["nodename"]])
[18:04:57.245]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.245]                             info)
[18:04:57.245]                           info <- base::paste(info, collapse = "; ")
[18:04:57.245]                           if (!has_future) {
[18:04:57.245]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.245]                               info)
[18:04:57.245]                           }
[18:04:57.245]                           else {
[18:04:57.245]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.245]                               info, version)
[18:04:57.245]                           }
[18:04:57.245]                           base::stop(msg)
[18:04:57.245]                         }
[18:04:57.245]                       })
[18:04:57.245]                     }
[18:04:57.245]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.245]                     base::options(mc.cores = 1L)
[18:04:57.245]                   }
[18:04:57.245]                   ...future.strategy.old <- future::plan("list")
[18:04:57.245]                   options(future.plan = NULL)
[18:04:57.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.245]                 }
[18:04:57.245]                 ...future.workdir <- getwd()
[18:04:57.245]             }
[18:04:57.245]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.245]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.245]         }
[18:04:57.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.245]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:57.245]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.245]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.245]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.245]             base::names(...future.oldOptions))
[18:04:57.245]     }
[18:04:57.245]     if (FALSE) {
[18:04:57.245]     }
[18:04:57.245]     else {
[18:04:57.245]         if (TRUE) {
[18:04:57.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.245]                 open = "w")
[18:04:57.245]         }
[18:04:57.245]         else {
[18:04:57.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.245]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.245]         }
[18:04:57.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.245]             base::sink(type = "output", split = FALSE)
[18:04:57.245]             base::close(...future.stdout)
[18:04:57.245]         }, add = TRUE)
[18:04:57.245]     }
[18:04:57.245]     ...future.frame <- base::sys.nframe()
[18:04:57.245]     ...future.conditions <- base::list()
[18:04:57.245]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.245]     if (FALSE) {
[18:04:57.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.245]     }
[18:04:57.245]     ...future.result <- base::tryCatch({
[18:04:57.245]         base::withCallingHandlers({
[18:04:57.245]             ...future.value <- base::withVisible(base::local({
[18:04:57.245]                 withCallingHandlers({
[18:04:57.245]                   1
[18:04:57.245]                 }, immediateCondition = function(cond) {
[18:04:57.245]                   save_rds <- function (object, pathname, ...) 
[18:04:57.245]                   {
[18:04:57.245]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.245]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.245]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.245]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.245]                         fi_tmp[["mtime"]])
[18:04:57.245]                     }
[18:04:57.245]                     tryCatch({
[18:04:57.245]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.245]                     }, error = function(ex) {
[18:04:57.245]                       msg <- conditionMessage(ex)
[18:04:57.245]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.245]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.245]                         fi_tmp[["mtime"]], msg)
[18:04:57.245]                       ex$message <- msg
[18:04:57.245]                       stop(ex)
[18:04:57.245]                     })
[18:04:57.245]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.245]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.245]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.245]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.245]                       fi <- file.info(pathname)
[18:04:57.245]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.245]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.245]                         fi[["size"]], fi[["mtime"]])
[18:04:57.245]                       stop(msg)
[18:04:57.245]                     }
[18:04:57.245]                     invisible(pathname)
[18:04:57.245]                   }
[18:04:57.245]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.245]                     rootPath = tempdir()) 
[18:04:57.245]                   {
[18:04:57.245]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.245]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.245]                       tmpdir = path, fileext = ".rds")
[18:04:57.245]                     save_rds(obj, file)
[18:04:57.245]                   }
[18:04:57.245]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.245]                   {
[18:04:57.245]                     inherits <- base::inherits
[18:04:57.245]                     invokeRestart <- base::invokeRestart
[18:04:57.245]                     is.null <- base::is.null
[18:04:57.245]                     muffled <- FALSE
[18:04:57.245]                     if (inherits(cond, "message")) {
[18:04:57.245]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.245]                       if (muffled) 
[18:04:57.245]                         invokeRestart("muffleMessage")
[18:04:57.245]                     }
[18:04:57.245]                     else if (inherits(cond, "warning")) {
[18:04:57.245]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.245]                       if (muffled) 
[18:04:57.245]                         invokeRestart("muffleWarning")
[18:04:57.245]                     }
[18:04:57.245]                     else if (inherits(cond, "condition")) {
[18:04:57.245]                       if (!is.null(pattern)) {
[18:04:57.245]                         computeRestarts <- base::computeRestarts
[18:04:57.245]                         grepl <- base::grepl
[18:04:57.245]                         restarts <- computeRestarts(cond)
[18:04:57.245]                         for (restart in restarts) {
[18:04:57.245]                           name <- restart$name
[18:04:57.245]                           if (is.null(name)) 
[18:04:57.245]                             next
[18:04:57.245]                           if (!grepl(pattern, name)) 
[18:04:57.245]                             next
[18:04:57.245]                           invokeRestart(restart)
[18:04:57.245]                           muffled <- TRUE
[18:04:57.245]                           break
[18:04:57.245]                         }
[18:04:57.245]                       }
[18:04:57.245]                     }
[18:04:57.245]                     invisible(muffled)
[18:04:57.245]                   }
[18:04:57.245]                   muffleCondition(cond)
[18:04:57.245]                 })
[18:04:57.245]             }))
[18:04:57.245]             future::FutureResult(value = ...future.value$value, 
[18:04:57.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.245]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.245]                     ...future.globalenv.names))
[18:04:57.245]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.245]         }, condition = base::local({
[18:04:57.245]             c <- base::c
[18:04:57.245]             inherits <- base::inherits
[18:04:57.245]             invokeRestart <- base::invokeRestart
[18:04:57.245]             length <- base::length
[18:04:57.245]             list <- base::list
[18:04:57.245]             seq.int <- base::seq.int
[18:04:57.245]             signalCondition <- base::signalCondition
[18:04:57.245]             sys.calls <- base::sys.calls
[18:04:57.245]             `[[` <- base::`[[`
[18:04:57.245]             `+` <- base::`+`
[18:04:57.245]             `<<-` <- base::`<<-`
[18:04:57.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.245]                   3L)]
[18:04:57.245]             }
[18:04:57.245]             function(cond) {
[18:04:57.245]                 is_error <- inherits(cond, "error")
[18:04:57.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.245]                   NULL)
[18:04:57.245]                 if (is_error) {
[18:04:57.245]                   sessionInformation <- function() {
[18:04:57.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.245]                       search = base::search(), system = base::Sys.info())
[18:04:57.245]                   }
[18:04:57.245]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.245]                     cond$call), session = sessionInformation(), 
[18:04:57.245]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.245]                   signalCondition(cond)
[18:04:57.245]                 }
[18:04:57.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.245]                 "immediateCondition"))) {
[18:04:57.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.245]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.245]                   if (TRUE && !signal) {
[18:04:57.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.245]                     {
[18:04:57.245]                       inherits <- base::inherits
[18:04:57.245]                       invokeRestart <- base::invokeRestart
[18:04:57.245]                       is.null <- base::is.null
[18:04:57.245]                       muffled <- FALSE
[18:04:57.245]                       if (inherits(cond, "message")) {
[18:04:57.245]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.245]                         if (muffled) 
[18:04:57.245]                           invokeRestart("muffleMessage")
[18:04:57.245]                       }
[18:04:57.245]                       else if (inherits(cond, "warning")) {
[18:04:57.245]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.245]                         if (muffled) 
[18:04:57.245]                           invokeRestart("muffleWarning")
[18:04:57.245]                       }
[18:04:57.245]                       else if (inherits(cond, "condition")) {
[18:04:57.245]                         if (!is.null(pattern)) {
[18:04:57.245]                           computeRestarts <- base::computeRestarts
[18:04:57.245]                           grepl <- base::grepl
[18:04:57.245]                           restarts <- computeRestarts(cond)
[18:04:57.245]                           for (restart in restarts) {
[18:04:57.245]                             name <- restart$name
[18:04:57.245]                             if (is.null(name)) 
[18:04:57.245]                               next
[18:04:57.245]                             if (!grepl(pattern, name)) 
[18:04:57.245]                               next
[18:04:57.245]                             invokeRestart(restart)
[18:04:57.245]                             muffled <- TRUE
[18:04:57.245]                             break
[18:04:57.245]                           }
[18:04:57.245]                         }
[18:04:57.245]                       }
[18:04:57.245]                       invisible(muffled)
[18:04:57.245]                     }
[18:04:57.245]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.245]                   }
[18:04:57.245]                 }
[18:04:57.245]                 else {
[18:04:57.245]                   if (TRUE) {
[18:04:57.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.245]                     {
[18:04:57.245]                       inherits <- base::inherits
[18:04:57.245]                       invokeRestart <- base::invokeRestart
[18:04:57.245]                       is.null <- base::is.null
[18:04:57.245]                       muffled <- FALSE
[18:04:57.245]                       if (inherits(cond, "message")) {
[18:04:57.245]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.245]                         if (muffled) 
[18:04:57.245]                           invokeRestart("muffleMessage")
[18:04:57.245]                       }
[18:04:57.245]                       else if (inherits(cond, "warning")) {
[18:04:57.245]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.245]                         if (muffled) 
[18:04:57.245]                           invokeRestart("muffleWarning")
[18:04:57.245]                       }
[18:04:57.245]                       else if (inherits(cond, "condition")) {
[18:04:57.245]                         if (!is.null(pattern)) {
[18:04:57.245]                           computeRestarts <- base::computeRestarts
[18:04:57.245]                           grepl <- base::grepl
[18:04:57.245]                           restarts <- computeRestarts(cond)
[18:04:57.245]                           for (restart in restarts) {
[18:04:57.245]                             name <- restart$name
[18:04:57.245]                             if (is.null(name)) 
[18:04:57.245]                               next
[18:04:57.245]                             if (!grepl(pattern, name)) 
[18:04:57.245]                               next
[18:04:57.245]                             invokeRestart(restart)
[18:04:57.245]                             muffled <- TRUE
[18:04:57.245]                             break
[18:04:57.245]                           }
[18:04:57.245]                         }
[18:04:57.245]                       }
[18:04:57.245]                       invisible(muffled)
[18:04:57.245]                     }
[18:04:57.245]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.245]                   }
[18:04:57.245]                 }
[18:04:57.245]             }
[18:04:57.245]         }))
[18:04:57.245]     }, error = function(ex) {
[18:04:57.245]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.245]                 ...future.rng), started = ...future.startTime, 
[18:04:57.245]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.245]             version = "1.8"), class = "FutureResult")
[18:04:57.245]     }, finally = {
[18:04:57.245]         if (!identical(...future.workdir, getwd())) 
[18:04:57.245]             setwd(...future.workdir)
[18:04:57.245]         {
[18:04:57.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.245]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.245]             }
[18:04:57.245]             base::options(...future.oldOptions)
[18:04:57.245]             if (.Platform$OS.type == "windows") {
[18:04:57.245]                 old_names <- names(...future.oldEnvVars)
[18:04:57.245]                 envs <- base::Sys.getenv()
[18:04:57.245]                 names <- names(envs)
[18:04:57.245]                 common <- intersect(names, old_names)
[18:04:57.245]                 added <- setdiff(names, old_names)
[18:04:57.245]                 removed <- setdiff(old_names, names)
[18:04:57.245]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.245]                   envs[common]]
[18:04:57.245]                 NAMES <- toupper(changed)
[18:04:57.245]                 args <- list()
[18:04:57.245]                 for (kk in seq_along(NAMES)) {
[18:04:57.245]                   name <- changed[[kk]]
[18:04:57.245]                   NAME <- NAMES[[kk]]
[18:04:57.245]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.245]                     next
[18:04:57.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.245]                 }
[18:04:57.245]                 NAMES <- toupper(added)
[18:04:57.245]                 for (kk in seq_along(NAMES)) {
[18:04:57.245]                   name <- added[[kk]]
[18:04:57.245]                   NAME <- NAMES[[kk]]
[18:04:57.245]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.245]                     next
[18:04:57.245]                   args[[name]] <- ""
[18:04:57.245]                 }
[18:04:57.245]                 NAMES <- toupper(removed)
[18:04:57.245]                 for (kk in seq_along(NAMES)) {
[18:04:57.245]                   name <- removed[[kk]]
[18:04:57.245]                   NAME <- NAMES[[kk]]
[18:04:57.245]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.245]                     next
[18:04:57.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.245]                 }
[18:04:57.245]                 if (length(args) > 0) 
[18:04:57.245]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.245]             }
[18:04:57.245]             else {
[18:04:57.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.245]             }
[18:04:57.245]             {
[18:04:57.245]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.245]                   0L) {
[18:04:57.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.245]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.245]                   base::options(opts)
[18:04:57.245]                 }
[18:04:57.245]                 {
[18:04:57.245]                   {
[18:04:57.245]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.245]                     NULL
[18:04:57.245]                   }
[18:04:57.245]                   options(future.plan = NULL)
[18:04:57.245]                   if (is.na(NA_character_)) 
[18:04:57.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.245]                     .init = FALSE)
[18:04:57.245]                 }
[18:04:57.245]             }
[18:04:57.245]         }
[18:04:57.245]     })
[18:04:57.245]     if (TRUE) {
[18:04:57.245]         base::sink(type = "output", split = FALSE)
[18:04:57.245]         if (TRUE) {
[18:04:57.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.245]         }
[18:04:57.245]         else {
[18:04:57.245]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.245]         }
[18:04:57.245]         base::close(...future.stdout)
[18:04:57.245]         ...future.stdout <- NULL
[18:04:57.245]     }
[18:04:57.245]     ...future.result$conditions <- ...future.conditions
[18:04:57.245]     ...future.result$finished <- base::Sys.time()
[18:04:57.245]     ...future.result
[18:04:57.245] }
[18:04:57.250] requestCore(): workers = 2
[18:04:57.254] MulticoreFuture started
[18:04:57.254] - Launch lazy future ... done
[18:04:57.255] run() for ‘MulticoreFuture’ ... done
[18:04:57.255] plan(): Setting new future strategy stack:
[18:04:57.256] List of future strategies:
[18:04:57.256] 1. sequential:
[18:04:57.256]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.256]    - tweaked: FALSE
[18:04:57.256]    - call: NULL
[18:04:57.259] plan(): nbrOfWorkers() = 1
[18:04:57.264] plan(): Setting new future strategy stack:
[18:04:57.272] List of future strategies:
[18:04:57.272] 1. multicore:
[18:04:57.272]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.272]    - tweaked: FALSE
[18:04:57.272]    - call: plan(strategy)
[18:04:57.287] plan(): nbrOfWorkers() = 2
[18:04:57.297] Future #1
[18:04:57.298] result() for MulticoreFuture ...
[18:04:57.300] result() for MulticoreFuture ...
[18:04:57.300] result() for MulticoreFuture ... done
[18:04:57.300] result() for MulticoreFuture ... done
[18:04:57.301] result() for MulticoreFuture ...
[18:04:57.305] result() for MulticoreFuture ... done
[18:04:57.306] A MulticoreFuture was resolved
[18:04:57.307]  length: 0 (resolved future 1)
[18:04:57.308] resolve() on list ... DONE
[18:04:57.308] - globals: [1] ‘a’
[18:04:57.309] Resolving futures part of globals (recursively) ... DONE
[18:04:57.312] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[18:04:57.314] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[18:04:57.314] - globals: [1] ‘a’
[18:04:57.314] - packages: [1] ‘future’
[18:04:57.315] getGlobalsAndPackages() ... DONE
[18:04:57.315] run() for ‘Future’ ...
[18:04:57.316] - state: ‘created’
[18:04:57.316] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.324] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.324]   - Field: ‘label’
[18:04:57.325]   - Field: ‘local’
[18:04:57.325]   - Field: ‘owner’
[18:04:57.325]   - Field: ‘envir’
[18:04:57.325]   - Field: ‘workers’
[18:04:57.326]   - Field: ‘packages’
[18:04:57.326]   - Field: ‘gc’
[18:04:57.326]   - Field: ‘job’
[18:04:57.326]   - Field: ‘conditions’
[18:04:57.327]   - Field: ‘expr’
[18:04:57.327]   - Field: ‘uuid’
[18:04:57.327]   - Field: ‘seed’
[18:04:57.327]   - Field: ‘version’
[18:04:57.328]   - Field: ‘result’
[18:04:57.328]   - Field: ‘asynchronous’
[18:04:57.328]   - Field: ‘calls’
[18:04:57.328]   - Field: ‘globals’
[18:04:57.329]   - Field: ‘stdout’
[18:04:57.329]   - Field: ‘earlySignal’
[18:04:57.329]   - Field: ‘lazy’
[18:04:57.329]   - Field: ‘state’
[18:04:57.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.330] - Launch lazy future ...
[18:04:57.331] Packages needed by the future expression (n = 1): ‘future’
[18:04:57.331] Packages needed by future strategies (n = 0): <none>
[18:04:57.332] {
[18:04:57.332]     {
[18:04:57.332]         {
[18:04:57.332]             ...future.startTime <- base::Sys.time()
[18:04:57.332]             {
[18:04:57.332]                 {
[18:04:57.332]                   {
[18:04:57.332]                     {
[18:04:57.332]                       {
[18:04:57.332]                         base::local({
[18:04:57.332]                           has_future <- base::requireNamespace("future", 
[18:04:57.332]                             quietly = TRUE)
[18:04:57.332]                           if (has_future) {
[18:04:57.332]                             ns <- base::getNamespace("future")
[18:04:57.332]                             version <- ns[[".package"]][["version"]]
[18:04:57.332]                             if (is.null(version)) 
[18:04:57.332]                               version <- utils::packageVersion("future")
[18:04:57.332]                           }
[18:04:57.332]                           else {
[18:04:57.332]                             version <- NULL
[18:04:57.332]                           }
[18:04:57.332]                           if (!has_future || version < "1.8.0") {
[18:04:57.332]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.332]                               "", base::R.version$version.string), 
[18:04:57.332]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:57.332]                                 base::R.version$platform, 8 * 
[18:04:57.332]                                   base::.Machine$sizeof.pointer), 
[18:04:57.332]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.332]                                 "release", "version")], collapse = " "), 
[18:04:57.332]                               hostname = base::Sys.info()[["nodename"]])
[18:04:57.332]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.332]                               info)
[18:04:57.332]                             info <- base::paste(info, collapse = "; ")
[18:04:57.332]                             if (!has_future) {
[18:04:57.332]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.332]                                 info)
[18:04:57.332]                             }
[18:04:57.332]                             else {
[18:04:57.332]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.332]                                 info, version)
[18:04:57.332]                             }
[18:04:57.332]                             base::stop(msg)
[18:04:57.332]                           }
[18:04:57.332]                         })
[18:04:57.332]                       }
[18:04:57.332]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.332]                       base::options(mc.cores = 1L)
[18:04:57.332]                     }
[18:04:57.332]                     base::local({
[18:04:57.332]                       for (pkg in "future") {
[18:04:57.332]                         base::loadNamespace(pkg)
[18:04:57.332]                         base::library(pkg, character.only = TRUE)
[18:04:57.332]                       }
[18:04:57.332]                     })
[18:04:57.332]                   }
[18:04:57.332]                   ...future.strategy.old <- future::plan("list")
[18:04:57.332]                   options(future.plan = NULL)
[18:04:57.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.332]                 }
[18:04:57.332]                 ...future.workdir <- getwd()
[18:04:57.332]             }
[18:04:57.332]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.332]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.332]         }
[18:04:57.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.332]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:57.332]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.332]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.332]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.332]             base::names(...future.oldOptions))
[18:04:57.332]     }
[18:04:57.332]     if (FALSE) {
[18:04:57.332]     }
[18:04:57.332]     else {
[18:04:57.332]         if (TRUE) {
[18:04:57.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.332]                 open = "w")
[18:04:57.332]         }
[18:04:57.332]         else {
[18:04:57.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.332]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.332]         }
[18:04:57.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.332]             base::sink(type = "output", split = FALSE)
[18:04:57.332]             base::close(...future.stdout)
[18:04:57.332]         }, add = TRUE)
[18:04:57.332]     }
[18:04:57.332]     ...future.frame <- base::sys.nframe()
[18:04:57.332]     ...future.conditions <- base::list()
[18:04:57.332]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.332]     if (FALSE) {
[18:04:57.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.332]     }
[18:04:57.332]     ...future.result <- base::tryCatch({
[18:04:57.332]         base::withCallingHandlers({
[18:04:57.332]             ...future.value <- base::withVisible(base::local({
[18:04:57.332]                 withCallingHandlers({
[18:04:57.332]                   value(a) + 1
[18:04:57.332]                 }, immediateCondition = function(cond) {
[18:04:57.332]                   save_rds <- function (object, pathname, ...) 
[18:04:57.332]                   {
[18:04:57.332]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.332]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.332]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.332]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.332]                         fi_tmp[["mtime"]])
[18:04:57.332]                     }
[18:04:57.332]                     tryCatch({
[18:04:57.332]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.332]                     }, error = function(ex) {
[18:04:57.332]                       msg <- conditionMessage(ex)
[18:04:57.332]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.332]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.332]                         fi_tmp[["mtime"]], msg)
[18:04:57.332]                       ex$message <- msg
[18:04:57.332]                       stop(ex)
[18:04:57.332]                     })
[18:04:57.332]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.332]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.332]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.332]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.332]                       fi <- file.info(pathname)
[18:04:57.332]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.332]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.332]                         fi[["size"]], fi[["mtime"]])
[18:04:57.332]                       stop(msg)
[18:04:57.332]                     }
[18:04:57.332]                     invisible(pathname)
[18:04:57.332]                   }
[18:04:57.332]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.332]                     rootPath = tempdir()) 
[18:04:57.332]                   {
[18:04:57.332]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.332]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.332]                       tmpdir = path, fileext = ".rds")
[18:04:57.332]                     save_rds(obj, file)
[18:04:57.332]                   }
[18:04:57.332]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.332]                   {
[18:04:57.332]                     inherits <- base::inherits
[18:04:57.332]                     invokeRestart <- base::invokeRestart
[18:04:57.332]                     is.null <- base::is.null
[18:04:57.332]                     muffled <- FALSE
[18:04:57.332]                     if (inherits(cond, "message")) {
[18:04:57.332]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.332]                       if (muffled) 
[18:04:57.332]                         invokeRestart("muffleMessage")
[18:04:57.332]                     }
[18:04:57.332]                     else if (inherits(cond, "warning")) {
[18:04:57.332]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.332]                       if (muffled) 
[18:04:57.332]                         invokeRestart("muffleWarning")
[18:04:57.332]                     }
[18:04:57.332]                     else if (inherits(cond, "condition")) {
[18:04:57.332]                       if (!is.null(pattern)) {
[18:04:57.332]                         computeRestarts <- base::computeRestarts
[18:04:57.332]                         grepl <- base::grepl
[18:04:57.332]                         restarts <- computeRestarts(cond)
[18:04:57.332]                         for (restart in restarts) {
[18:04:57.332]                           name <- restart$name
[18:04:57.332]                           if (is.null(name)) 
[18:04:57.332]                             next
[18:04:57.332]                           if (!grepl(pattern, name)) 
[18:04:57.332]                             next
[18:04:57.332]                           invokeRestart(restart)
[18:04:57.332]                           muffled <- TRUE
[18:04:57.332]                           break
[18:04:57.332]                         }
[18:04:57.332]                       }
[18:04:57.332]                     }
[18:04:57.332]                     invisible(muffled)
[18:04:57.332]                   }
[18:04:57.332]                   muffleCondition(cond)
[18:04:57.332]                 })
[18:04:57.332]             }))
[18:04:57.332]             future::FutureResult(value = ...future.value$value, 
[18:04:57.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.332]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.332]                     ...future.globalenv.names))
[18:04:57.332]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.332]         }, condition = base::local({
[18:04:57.332]             c <- base::c
[18:04:57.332]             inherits <- base::inherits
[18:04:57.332]             invokeRestart <- base::invokeRestart
[18:04:57.332]             length <- base::length
[18:04:57.332]             list <- base::list
[18:04:57.332]             seq.int <- base::seq.int
[18:04:57.332]             signalCondition <- base::signalCondition
[18:04:57.332]             sys.calls <- base::sys.calls
[18:04:57.332]             `[[` <- base::`[[`
[18:04:57.332]             `+` <- base::`+`
[18:04:57.332]             `<<-` <- base::`<<-`
[18:04:57.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.332]                   3L)]
[18:04:57.332]             }
[18:04:57.332]             function(cond) {
[18:04:57.332]                 is_error <- inherits(cond, "error")
[18:04:57.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.332]                   NULL)
[18:04:57.332]                 if (is_error) {
[18:04:57.332]                   sessionInformation <- function() {
[18:04:57.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.332]                       search = base::search(), system = base::Sys.info())
[18:04:57.332]                   }
[18:04:57.332]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.332]                     cond$call), session = sessionInformation(), 
[18:04:57.332]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.332]                   signalCondition(cond)
[18:04:57.332]                 }
[18:04:57.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.332]                 "immediateCondition"))) {
[18:04:57.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.332]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.332]                   if (TRUE && !signal) {
[18:04:57.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.332]                     {
[18:04:57.332]                       inherits <- base::inherits
[18:04:57.332]                       invokeRestart <- base::invokeRestart
[18:04:57.332]                       is.null <- base::is.null
[18:04:57.332]                       muffled <- FALSE
[18:04:57.332]                       if (inherits(cond, "message")) {
[18:04:57.332]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.332]                         if (muffled) 
[18:04:57.332]                           invokeRestart("muffleMessage")
[18:04:57.332]                       }
[18:04:57.332]                       else if (inherits(cond, "warning")) {
[18:04:57.332]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.332]                         if (muffled) 
[18:04:57.332]                           invokeRestart("muffleWarning")
[18:04:57.332]                       }
[18:04:57.332]                       else if (inherits(cond, "condition")) {
[18:04:57.332]                         if (!is.null(pattern)) {
[18:04:57.332]                           computeRestarts <- base::computeRestarts
[18:04:57.332]                           grepl <- base::grepl
[18:04:57.332]                           restarts <- computeRestarts(cond)
[18:04:57.332]                           for (restart in restarts) {
[18:04:57.332]                             name <- restart$name
[18:04:57.332]                             if (is.null(name)) 
[18:04:57.332]                               next
[18:04:57.332]                             if (!grepl(pattern, name)) 
[18:04:57.332]                               next
[18:04:57.332]                             invokeRestart(restart)
[18:04:57.332]                             muffled <- TRUE
[18:04:57.332]                             break
[18:04:57.332]                           }
[18:04:57.332]                         }
[18:04:57.332]                       }
[18:04:57.332]                       invisible(muffled)
[18:04:57.332]                     }
[18:04:57.332]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.332]                   }
[18:04:57.332]                 }
[18:04:57.332]                 else {
[18:04:57.332]                   if (TRUE) {
[18:04:57.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.332]                     {
[18:04:57.332]                       inherits <- base::inherits
[18:04:57.332]                       invokeRestart <- base::invokeRestart
[18:04:57.332]                       is.null <- base::is.null
[18:04:57.332]                       muffled <- FALSE
[18:04:57.332]                       if (inherits(cond, "message")) {
[18:04:57.332]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.332]                         if (muffled) 
[18:04:57.332]                           invokeRestart("muffleMessage")
[18:04:57.332]                       }
[18:04:57.332]                       else if (inherits(cond, "warning")) {
[18:04:57.332]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.332]                         if (muffled) 
[18:04:57.332]                           invokeRestart("muffleWarning")
[18:04:57.332]                       }
[18:04:57.332]                       else if (inherits(cond, "condition")) {
[18:04:57.332]                         if (!is.null(pattern)) {
[18:04:57.332]                           computeRestarts <- base::computeRestarts
[18:04:57.332]                           grepl <- base::grepl
[18:04:57.332]                           restarts <- computeRestarts(cond)
[18:04:57.332]                           for (restart in restarts) {
[18:04:57.332]                             name <- restart$name
[18:04:57.332]                             if (is.null(name)) 
[18:04:57.332]                               next
[18:04:57.332]                             if (!grepl(pattern, name)) 
[18:04:57.332]                               next
[18:04:57.332]                             invokeRestart(restart)
[18:04:57.332]                             muffled <- TRUE
[18:04:57.332]                             break
[18:04:57.332]                           }
[18:04:57.332]                         }
[18:04:57.332]                       }
[18:04:57.332]                       invisible(muffled)
[18:04:57.332]                     }
[18:04:57.332]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.332]                   }
[18:04:57.332]                 }
[18:04:57.332]             }
[18:04:57.332]         }))
[18:04:57.332]     }, error = function(ex) {
[18:04:57.332]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.332]                 ...future.rng), started = ...future.startTime, 
[18:04:57.332]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.332]             version = "1.8"), class = "FutureResult")
[18:04:57.332]     }, finally = {
[18:04:57.332]         if (!identical(...future.workdir, getwd())) 
[18:04:57.332]             setwd(...future.workdir)
[18:04:57.332]         {
[18:04:57.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.332]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.332]             }
[18:04:57.332]             base::options(...future.oldOptions)
[18:04:57.332]             if (.Platform$OS.type == "windows") {
[18:04:57.332]                 old_names <- names(...future.oldEnvVars)
[18:04:57.332]                 envs <- base::Sys.getenv()
[18:04:57.332]                 names <- names(envs)
[18:04:57.332]                 common <- intersect(names, old_names)
[18:04:57.332]                 added <- setdiff(names, old_names)
[18:04:57.332]                 removed <- setdiff(old_names, names)
[18:04:57.332]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.332]                   envs[common]]
[18:04:57.332]                 NAMES <- toupper(changed)
[18:04:57.332]                 args <- list()
[18:04:57.332]                 for (kk in seq_along(NAMES)) {
[18:04:57.332]                   name <- changed[[kk]]
[18:04:57.332]                   NAME <- NAMES[[kk]]
[18:04:57.332]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.332]                     next
[18:04:57.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.332]                 }
[18:04:57.332]                 NAMES <- toupper(added)
[18:04:57.332]                 for (kk in seq_along(NAMES)) {
[18:04:57.332]                   name <- added[[kk]]
[18:04:57.332]                   NAME <- NAMES[[kk]]
[18:04:57.332]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.332]                     next
[18:04:57.332]                   args[[name]] <- ""
[18:04:57.332]                 }
[18:04:57.332]                 NAMES <- toupper(removed)
[18:04:57.332]                 for (kk in seq_along(NAMES)) {
[18:04:57.332]                   name <- removed[[kk]]
[18:04:57.332]                   NAME <- NAMES[[kk]]
[18:04:57.332]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.332]                     next
[18:04:57.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.332]                 }
[18:04:57.332]                 if (length(args) > 0) 
[18:04:57.332]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.332]             }
[18:04:57.332]             else {
[18:04:57.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.332]             }
[18:04:57.332]             {
[18:04:57.332]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.332]                   0L) {
[18:04:57.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.332]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.332]                   base::options(opts)
[18:04:57.332]                 }
[18:04:57.332]                 {
[18:04:57.332]                   {
[18:04:57.332]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.332]                     NULL
[18:04:57.332]                   }
[18:04:57.332]                   options(future.plan = NULL)
[18:04:57.332]                   if (is.na(NA_character_)) 
[18:04:57.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.332]                     .init = FALSE)
[18:04:57.332]                 }
[18:04:57.332]             }
[18:04:57.332]         }
[18:04:57.332]     })
[18:04:57.332]     if (TRUE) {
[18:04:57.332]         base::sink(type = "output", split = FALSE)
[18:04:57.332]         if (TRUE) {
[18:04:57.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.332]         }
[18:04:57.332]         else {
[18:04:57.332]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.332]         }
[18:04:57.332]         base::close(...future.stdout)
[18:04:57.332]         ...future.stdout <- NULL
[18:04:57.332]     }
[18:04:57.332]     ...future.result$conditions <- ...future.conditions
[18:04:57.332]     ...future.result$finished <- base::Sys.time()
[18:04:57.332]     ...future.result
[18:04:57.332] }
[18:04:57.337] assign_globals() ...
[18:04:57.337] List of 1
[18:04:57.337]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5b9576a73738> 
[18:04:57.337]  - attr(*, "where")=List of 1
[18:04:57.337]   ..$ a:<environment: R_EmptyEnv> 
[18:04:57.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.337]  - attr(*, "resolved")= logi TRUE
[18:04:57.337]  - attr(*, "total_size")= num 10984
[18:04:57.337]  - attr(*, "already-done")= logi TRUE
[18:04:57.351] - copied ‘a’ to environment
[18:04:57.351] assign_globals() ... done
[18:04:57.351] requestCore(): workers = 2
[18:04:57.361] MulticoreFuture started
[18:04:57.363] - Launch lazy future ... done
[18:04:57.364] run() for ‘MulticoreFuture’ ... done
[18:04:57.364] result() for MulticoreFuture ...
[18:04:57.369] plan(): Setting new future strategy stack:
[18:04:57.369] List of future strategies:
[18:04:57.369] 1. sequential:
[18:04:57.369]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.369]    - tweaked: FALSE
[18:04:57.369]    - call: NULL
[18:04:57.372] plan(): nbrOfWorkers() = 1
[18:04:57.379] plan(): Setting new future strategy stack:
[18:04:57.380] List of future strategies:
[18:04:57.380] 1. multicore:
[18:04:57.380]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.380]    - tweaked: FALSE
[18:04:57.380]    - call: plan(strategy)
[18:04:57.392] plan(): nbrOfWorkers() = 2
[18:04:57.394] result() for MulticoreFuture ...
[18:04:57.396] result() for MulticoreFuture ... done
[18:04:57.398] signalConditions() ...
[18:04:57.398]  - include = ‘immediateCondition’
[18:04:57.399]  - exclude = 
[18:04:57.400]  - resignal = FALSE
[18:04:57.400]  - Number of conditions: 4
[18:04:57.401] signalConditions() ... done
[18:04:57.401] result() for MulticoreFuture ... done
[18:04:57.401] result() for MulticoreFuture ...
[18:04:57.402] result() for MulticoreFuture ... done
[18:04:57.402] signalConditions() ...
[18:04:57.402]  - include = ‘immediateCondition’
[18:04:57.402]  - exclude = 
[18:04:57.403]  - resignal = FALSE
[18:04:57.403]  - Number of conditions: 4
[18:04:57.403] signalConditions() ... done
[18:04:57.403] Future state: ‘finished’
[18:04:57.404] result() for MulticoreFuture ...
[18:04:57.404] result() for MulticoreFuture ... done
[18:04:57.404] signalConditions() ...
[18:04:57.404]  - include = ‘condition’
[18:04:57.405]  - exclude = ‘immediateCondition’
[18:04:57.405]  - resignal = TRUE
[18:04:57.405]  - Number of conditions: 4
[18:04:57.405]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.374] result() for MulticoreFuture ...
[18:04:57.406]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.375] result() for MulticoreFuture ... done
[18:04:57.406]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.376] result() for MulticoreFuture ...
[18:04:57.407]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.376] result() for MulticoreFuture ... done
[18:04:57.407] signalConditions() ... done
value(b) = 2
[18:04:57.408] result() for MulticoreFuture ...
[18:04:57.408] result() for MulticoreFuture ... done
[18:04:57.408] result() for MulticoreFuture ...
[18:04:57.408] result() for MulticoreFuture ... done
[18:04:57.409] signalConditions() ...
[18:04:57.409]  - include = ‘immediateCondition’
[18:04:57.409]  - exclude = 
[18:04:57.409]  - resignal = FALSE
[18:04:57.410]  - Number of conditions: 4
[18:04:57.410] signalConditions() ... done
[18:04:57.410] Future state: ‘finished’
[18:04:57.410] result() for MulticoreFuture ...
[18:04:57.411] result() for MulticoreFuture ... done
[18:04:57.411] signalConditions() ...
[18:04:57.411]  - include = ‘condition’
[18:04:57.411]  - exclude = ‘immediateCondition’
[18:04:57.412]  - resignal = TRUE
[18:04:57.412]  - Number of conditions: 4
[18:04:57.412]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.374] result() for MulticoreFuture ...
[18:04:57.412]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.375] result() for MulticoreFuture ... done
[18:04:57.413]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.376] result() for MulticoreFuture ...
[18:04:57.413]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:57.376] result() for MulticoreFuture ... done
[18:04:57.414] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.414] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.415] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:04:57.417] - globals found: [2] ‘{’, ‘pkg’
[18:04:57.418] Searching for globals ... DONE
[18:04:57.418] Resolving globals: TRUE
[18:04:57.418] Resolving any globals that are futures ...
[18:04:57.419] - globals: [2] ‘{’, ‘pkg’
[18:04:57.419] Resolving any globals that are futures ... DONE
[18:04:57.423] Resolving futures part of globals (recursively) ...
[18:04:57.424] resolve() on list ...
[18:04:57.425]  recursive: 99
[18:04:57.425]  length: 1
[18:04:57.425]  elements: ‘pkg’
[18:04:57.426]  length: 0 (resolved future 1)
[18:04:57.426] resolve() on list ... DONE
[18:04:57.426] - globals: [1] ‘pkg’
[18:04:57.427] Resolving futures part of globals (recursively) ... DONE
[18:04:57.427] The total size of the 1 globals is 112 bytes (112 bytes)
[18:04:57.428] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[18:04:57.429] - globals: [1] ‘pkg’
[18:04:57.429] 
[18:04:57.429] getGlobalsAndPackages() ... DONE
[18:04:57.430] Packages needed by the future expression (n = 0): <none>
[18:04:57.430] Packages needed by future strategies (n = 0): <none>
[18:04:57.432] {
[18:04:57.432]     {
[18:04:57.432]         {
[18:04:57.432]             ...future.startTime <- base::Sys.time()
[18:04:57.432]             {
[18:04:57.432]                 {
[18:04:57.432]                   {
[18:04:57.432]                     base::local({
[18:04:57.432]                       has_future <- base::requireNamespace("future", 
[18:04:57.432]                         quietly = TRUE)
[18:04:57.432]                       if (has_future) {
[18:04:57.432]                         ns <- base::getNamespace("future")
[18:04:57.432]                         version <- ns[[".package"]][["version"]]
[18:04:57.432]                         if (is.null(version)) 
[18:04:57.432]                           version <- utils::packageVersion("future")
[18:04:57.432]                       }
[18:04:57.432]                       else {
[18:04:57.432]                         version <- NULL
[18:04:57.432]                       }
[18:04:57.432]                       if (!has_future || version < "1.8.0") {
[18:04:57.432]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.432]                           "", base::R.version$version.string), 
[18:04:57.432]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:57.432]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:57.432]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.432]                             "release", "version")], collapse = " "), 
[18:04:57.432]                           hostname = base::Sys.info()[["nodename"]])
[18:04:57.432]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.432]                           info)
[18:04:57.432]                         info <- base::paste(info, collapse = "; ")
[18:04:57.432]                         if (!has_future) {
[18:04:57.432]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.432]                             info)
[18:04:57.432]                         }
[18:04:57.432]                         else {
[18:04:57.432]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.432]                             info, version)
[18:04:57.432]                         }
[18:04:57.432]                         base::stop(msg)
[18:04:57.432]                       }
[18:04:57.432]                     })
[18:04:57.432]                   }
[18:04:57.432]                   ...future.strategy.old <- future::plan("list")
[18:04:57.432]                   options(future.plan = NULL)
[18:04:57.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.432]                 }
[18:04:57.432]                 ...future.workdir <- getwd()
[18:04:57.432]             }
[18:04:57.432]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.432]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.432]         }
[18:04:57.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.432]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:04:57.432]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.432]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.432]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.432]             base::names(...future.oldOptions))
[18:04:57.432]     }
[18:04:57.432]     if (FALSE) {
[18:04:57.432]     }
[18:04:57.432]     else {
[18:04:57.432]         if (TRUE) {
[18:04:57.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.432]                 open = "w")
[18:04:57.432]         }
[18:04:57.432]         else {
[18:04:57.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.432]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.432]         }
[18:04:57.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.432]             base::sink(type = "output", split = FALSE)
[18:04:57.432]             base::close(...future.stdout)
[18:04:57.432]         }, add = TRUE)
[18:04:57.432]     }
[18:04:57.432]     ...future.frame <- base::sys.nframe()
[18:04:57.432]     ...future.conditions <- base::list()
[18:04:57.432]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.432]     if (FALSE) {
[18:04:57.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.432]     }
[18:04:57.432]     ...future.result <- base::tryCatch({
[18:04:57.432]         base::withCallingHandlers({
[18:04:57.432]             ...future.value <- base::withVisible(base::local({
[18:04:57.432]                 pkg
[18:04:57.432]             }))
[18:04:57.432]             future::FutureResult(value = ...future.value$value, 
[18:04:57.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.432]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.432]                     ...future.globalenv.names))
[18:04:57.432]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.432]         }, condition = base::local({
[18:04:57.432]             c <- base::c
[18:04:57.432]             inherits <- base::inherits
[18:04:57.432]             invokeRestart <- base::invokeRestart
[18:04:57.432]             length <- base::length
[18:04:57.432]             list <- base::list
[18:04:57.432]             seq.int <- base::seq.int
[18:04:57.432]             signalCondition <- base::signalCondition
[18:04:57.432]             sys.calls <- base::sys.calls
[18:04:57.432]             `[[` <- base::`[[`
[18:04:57.432]             `+` <- base::`+`
[18:04:57.432]             `<<-` <- base::`<<-`
[18:04:57.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.432]                   3L)]
[18:04:57.432]             }
[18:04:57.432]             function(cond) {
[18:04:57.432]                 is_error <- inherits(cond, "error")
[18:04:57.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.432]                   NULL)
[18:04:57.432]                 if (is_error) {
[18:04:57.432]                   sessionInformation <- function() {
[18:04:57.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.432]                       search = base::search(), system = base::Sys.info())
[18:04:57.432]                   }
[18:04:57.432]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.432]                     cond$call), session = sessionInformation(), 
[18:04:57.432]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.432]                   signalCondition(cond)
[18:04:57.432]                 }
[18:04:57.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.432]                 "immediateCondition"))) {
[18:04:57.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.432]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.432]                   if (TRUE && !signal) {
[18:04:57.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.432]                     {
[18:04:57.432]                       inherits <- base::inherits
[18:04:57.432]                       invokeRestart <- base::invokeRestart
[18:04:57.432]                       is.null <- base::is.null
[18:04:57.432]                       muffled <- FALSE
[18:04:57.432]                       if (inherits(cond, "message")) {
[18:04:57.432]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.432]                         if (muffled) 
[18:04:57.432]                           invokeRestart("muffleMessage")
[18:04:57.432]                       }
[18:04:57.432]                       else if (inherits(cond, "warning")) {
[18:04:57.432]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.432]                         if (muffled) 
[18:04:57.432]                           invokeRestart("muffleWarning")
[18:04:57.432]                       }
[18:04:57.432]                       else if (inherits(cond, "condition")) {
[18:04:57.432]                         if (!is.null(pattern)) {
[18:04:57.432]                           computeRestarts <- base::computeRestarts
[18:04:57.432]                           grepl <- base::grepl
[18:04:57.432]                           restarts <- computeRestarts(cond)
[18:04:57.432]                           for (restart in restarts) {
[18:04:57.432]                             name <- restart$name
[18:04:57.432]                             if (is.null(name)) 
[18:04:57.432]                               next
[18:04:57.432]                             if (!grepl(pattern, name)) 
[18:04:57.432]                               next
[18:04:57.432]                             invokeRestart(restart)
[18:04:57.432]                             muffled <- TRUE
[18:04:57.432]                             break
[18:04:57.432]                           }
[18:04:57.432]                         }
[18:04:57.432]                       }
[18:04:57.432]                       invisible(muffled)
[18:04:57.432]                     }
[18:04:57.432]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.432]                   }
[18:04:57.432]                 }
[18:04:57.432]                 else {
[18:04:57.432]                   if (TRUE) {
[18:04:57.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.432]                     {
[18:04:57.432]                       inherits <- base::inherits
[18:04:57.432]                       invokeRestart <- base::invokeRestart
[18:04:57.432]                       is.null <- base::is.null
[18:04:57.432]                       muffled <- FALSE
[18:04:57.432]                       if (inherits(cond, "message")) {
[18:04:57.432]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.432]                         if (muffled) 
[18:04:57.432]                           invokeRestart("muffleMessage")
[18:04:57.432]                       }
[18:04:57.432]                       else if (inherits(cond, "warning")) {
[18:04:57.432]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.432]                         if (muffled) 
[18:04:57.432]                           invokeRestart("muffleWarning")
[18:04:57.432]                       }
[18:04:57.432]                       else if (inherits(cond, "condition")) {
[18:04:57.432]                         if (!is.null(pattern)) {
[18:04:57.432]                           computeRestarts <- base::computeRestarts
[18:04:57.432]                           grepl <- base::grepl
[18:04:57.432]                           restarts <- computeRestarts(cond)
[18:04:57.432]                           for (restart in restarts) {
[18:04:57.432]                             name <- restart$name
[18:04:57.432]                             if (is.null(name)) 
[18:04:57.432]                               next
[18:04:57.432]                             if (!grepl(pattern, name)) 
[18:04:57.432]                               next
[18:04:57.432]                             invokeRestart(restart)
[18:04:57.432]                             muffled <- TRUE
[18:04:57.432]                             break
[18:04:57.432]                           }
[18:04:57.432]                         }
[18:04:57.432]                       }
[18:04:57.432]                       invisible(muffled)
[18:04:57.432]                     }
[18:04:57.432]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.432]                   }
[18:04:57.432]                 }
[18:04:57.432]             }
[18:04:57.432]         }))
[18:04:57.432]     }, error = function(ex) {
[18:04:57.432]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.432]                 ...future.rng), started = ...future.startTime, 
[18:04:57.432]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.432]             version = "1.8"), class = "FutureResult")
[18:04:57.432]     }, finally = {
[18:04:57.432]         if (!identical(...future.workdir, getwd())) 
[18:04:57.432]             setwd(...future.workdir)
[18:04:57.432]         {
[18:04:57.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.432]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.432]             }
[18:04:57.432]             base::options(...future.oldOptions)
[18:04:57.432]             if (.Platform$OS.type == "windows") {
[18:04:57.432]                 old_names <- names(...future.oldEnvVars)
[18:04:57.432]                 envs <- base::Sys.getenv()
[18:04:57.432]                 names <- names(envs)
[18:04:57.432]                 common <- intersect(names, old_names)
[18:04:57.432]                 added <- setdiff(names, old_names)
[18:04:57.432]                 removed <- setdiff(old_names, names)
[18:04:57.432]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.432]                   envs[common]]
[18:04:57.432]                 NAMES <- toupper(changed)
[18:04:57.432]                 args <- list()
[18:04:57.432]                 for (kk in seq_along(NAMES)) {
[18:04:57.432]                   name <- changed[[kk]]
[18:04:57.432]                   NAME <- NAMES[[kk]]
[18:04:57.432]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.432]                     next
[18:04:57.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.432]                 }
[18:04:57.432]                 NAMES <- toupper(added)
[18:04:57.432]                 for (kk in seq_along(NAMES)) {
[18:04:57.432]                   name <- added[[kk]]
[18:04:57.432]                   NAME <- NAMES[[kk]]
[18:04:57.432]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.432]                     next
[18:04:57.432]                   args[[name]] <- ""
[18:04:57.432]                 }
[18:04:57.432]                 NAMES <- toupper(removed)
[18:04:57.432]                 for (kk in seq_along(NAMES)) {
[18:04:57.432]                   name <- removed[[kk]]
[18:04:57.432]                   NAME <- NAMES[[kk]]
[18:04:57.432]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.432]                     next
[18:04:57.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.432]                 }
[18:04:57.432]                 if (length(args) > 0) 
[18:04:57.432]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.432]             }
[18:04:57.432]             else {
[18:04:57.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.432]             }
[18:04:57.432]             {
[18:04:57.432]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.432]                   0L) {
[18:04:57.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.432]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.432]                   base::options(opts)
[18:04:57.432]                 }
[18:04:57.432]                 {
[18:04:57.432]                   {
[18:04:57.432]                     NULL
[18:04:57.432]                     RNGkind("Mersenne-Twister")
[18:04:57.432]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:57.432]                       inherits = FALSE)
[18:04:57.432]                   }
[18:04:57.432]                   options(future.plan = NULL)
[18:04:57.432]                   if (is.na(NA_character_)) 
[18:04:57.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.432]                     .init = FALSE)
[18:04:57.432]                 }
[18:04:57.432]             }
[18:04:57.432]         }
[18:04:57.432]     })
[18:04:57.432]     if (TRUE) {
[18:04:57.432]         base::sink(type = "output", split = FALSE)
[18:04:57.432]         if (TRUE) {
[18:04:57.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.432]         }
[18:04:57.432]         else {
[18:04:57.432]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.432]         }
[18:04:57.432]         base::close(...future.stdout)
[18:04:57.432]         ...future.stdout <- NULL
[18:04:57.432]     }
[18:04:57.432]     ...future.result$conditions <- ...future.conditions
[18:04:57.432]     ...future.result$finished <- base::Sys.time()
[18:04:57.432]     ...future.result
[18:04:57.432] }
[18:04:57.436] assign_globals() ...
[18:04:57.436] List of 1
[18:04:57.436]  $ pkg: chr "foo"
[18:04:57.436]  - attr(*, "where")=List of 1
[18:04:57.436]   ..$ pkg:<environment: R_EmptyEnv> 
[18:04:57.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.436]  - attr(*, "resolved")= logi TRUE
[18:04:57.436]  - attr(*, "total_size")= num 112
[18:04:57.442] - copied ‘pkg’ to environment
[18:04:57.442] assign_globals() ... done
[18:04:57.443] plan(): Setting new future strategy stack:
[18:04:57.443] List of future strategies:
[18:04:57.443] 1. sequential:
[18:04:57.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.443]    - tweaked: FALSE
[18:04:57.443]    - call: NULL
[18:04:57.444] plan(): nbrOfWorkers() = 1
[18:04:57.446] plan(): Setting new future strategy stack:
[18:04:57.446] List of future strategies:
[18:04:57.446] 1. multicore:
[18:04:57.446]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.446]    - tweaked: FALSE
[18:04:57.446]    - call: plan(strategy)
[18:04:57.453] plan(): nbrOfWorkers() = 2
[18:04:57.453] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.456] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.456] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:57.461] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:04:57.461] Searching for globals ... DONE
[18:04:57.462] Resolving globals: TRUE
[18:04:57.462] Resolving any globals that are futures ...
[18:04:57.462] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:04:57.462] Resolving any globals that are futures ... DONE
[18:04:57.463] Resolving futures part of globals (recursively) ...
[18:04:57.464] resolve() on list ...
[18:04:57.464]  recursive: 99
[18:04:57.464]  length: 1
[18:04:57.464]  elements: ‘a’
[18:04:57.464]  length: 0 (resolved future 1)
[18:04:57.465] resolve() on list ... DONE
[18:04:57.465] - globals: [1] ‘a’
[18:04:57.465] Resolving futures part of globals (recursively) ... DONE
[18:04:57.465] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:57.466] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:04:57.467] - globals: [1] ‘a’
[18:04:57.467] 
[18:04:57.467] getGlobalsAndPackages() ... DONE
[18:04:57.469] run() for ‘Future’ ...
[18:04:57.469] - state: ‘created’
[18:04:57.469] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.476] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.476]   - Field: ‘label’
[18:04:57.476]   - Field: ‘local’
[18:04:57.477]   - Field: ‘owner’
[18:04:57.477]   - Field: ‘envir’
[18:04:57.477]   - Field: ‘workers’
[18:04:57.477]   - Field: ‘packages’
[18:04:57.478]   - Field: ‘gc’
[18:04:57.478]   - Field: ‘job’
[18:04:57.478]   - Field: ‘conditions’
[18:04:57.478]   - Field: ‘expr’
[18:04:57.478]   - Field: ‘uuid’
[18:04:57.479]   - Field: ‘seed’
[18:04:57.479]   - Field: ‘version’
[18:04:57.479]   - Field: ‘result’
[18:04:57.479]   - Field: ‘asynchronous’
[18:04:57.479]   - Field: ‘calls’
[18:04:57.480]   - Field: ‘globals’
[18:04:57.480]   - Field: ‘stdout’
[18:04:57.480]   - Field: ‘earlySignal’
[18:04:57.480]   - Field: ‘lazy’
[18:04:57.481]   - Field: ‘state’
[18:04:57.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.481] - Launch lazy future ...
[18:04:57.482] Packages needed by the future expression (n = 0): <none>
[18:04:57.482] Packages needed by future strategies (n = 0): <none>
[18:04:57.483] {
[18:04:57.483]     {
[18:04:57.483]         {
[18:04:57.483]             ...future.startTime <- base::Sys.time()
[18:04:57.483]             {
[18:04:57.483]                 {
[18:04:57.483]                   {
[18:04:57.483]                     {
[18:04:57.483]                       base::local({
[18:04:57.483]                         has_future <- base::requireNamespace("future", 
[18:04:57.483]                           quietly = TRUE)
[18:04:57.483]                         if (has_future) {
[18:04:57.483]                           ns <- base::getNamespace("future")
[18:04:57.483]                           version <- ns[[".package"]][["version"]]
[18:04:57.483]                           if (is.null(version)) 
[18:04:57.483]                             version <- utils::packageVersion("future")
[18:04:57.483]                         }
[18:04:57.483]                         else {
[18:04:57.483]                           version <- NULL
[18:04:57.483]                         }
[18:04:57.483]                         if (!has_future || version < "1.8.0") {
[18:04:57.483]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.483]                             "", base::R.version$version.string), 
[18:04:57.483]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:57.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:57.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.483]                               "release", "version")], collapse = " "), 
[18:04:57.483]                             hostname = base::Sys.info()[["nodename"]])
[18:04:57.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.483]                             info)
[18:04:57.483]                           info <- base::paste(info, collapse = "; ")
[18:04:57.483]                           if (!has_future) {
[18:04:57.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.483]                               info)
[18:04:57.483]                           }
[18:04:57.483]                           else {
[18:04:57.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.483]                               info, version)
[18:04:57.483]                           }
[18:04:57.483]                           base::stop(msg)
[18:04:57.483]                         }
[18:04:57.483]                       })
[18:04:57.483]                     }
[18:04:57.483]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.483]                     base::options(mc.cores = 1L)
[18:04:57.483]                   }
[18:04:57.483]                   ...future.strategy.old <- future::plan("list")
[18:04:57.483]                   options(future.plan = NULL)
[18:04:57.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.483]                 }
[18:04:57.483]                 ...future.workdir <- getwd()
[18:04:57.483]             }
[18:04:57.483]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.483]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.483]         }
[18:04:57.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.483]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:57.483]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.483]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.483]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.483]             base::names(...future.oldOptions))
[18:04:57.483]     }
[18:04:57.483]     if (FALSE) {
[18:04:57.483]     }
[18:04:57.483]     else {
[18:04:57.483]         if (TRUE) {
[18:04:57.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.483]                 open = "w")
[18:04:57.483]         }
[18:04:57.483]         else {
[18:04:57.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.483]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.483]         }
[18:04:57.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.483]             base::sink(type = "output", split = FALSE)
[18:04:57.483]             base::close(...future.stdout)
[18:04:57.483]         }, add = TRUE)
[18:04:57.483]     }
[18:04:57.483]     ...future.frame <- base::sys.nframe()
[18:04:57.483]     ...future.conditions <- base::list()
[18:04:57.483]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.483]     if (FALSE) {
[18:04:57.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.483]     }
[18:04:57.483]     ...future.result <- base::tryCatch({
[18:04:57.483]         base::withCallingHandlers({
[18:04:57.483]             ...future.value <- base::withVisible(base::local({
[18:04:57.483]                 withCallingHandlers({
[18:04:57.483]                   {
[18:04:57.483]                     b <- a
[18:04:57.483]                     a <- 2
[18:04:57.483]                     a * b
[18:04:57.483]                   }
[18:04:57.483]                 }, immediateCondition = function(cond) {
[18:04:57.483]                   save_rds <- function (object, pathname, ...) 
[18:04:57.483]                   {
[18:04:57.483]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.483]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.483]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.483]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.483]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.483]                         fi_tmp[["mtime"]])
[18:04:57.483]                     }
[18:04:57.483]                     tryCatch({
[18:04:57.483]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.483]                     }, error = function(ex) {
[18:04:57.483]                       msg <- conditionMessage(ex)
[18:04:57.483]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.483]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.483]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.483]                         fi_tmp[["mtime"]], msg)
[18:04:57.483]                       ex$message <- msg
[18:04:57.483]                       stop(ex)
[18:04:57.483]                     })
[18:04:57.483]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.483]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.483]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.483]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.483]                       fi <- file.info(pathname)
[18:04:57.483]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.483]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.483]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.483]                         fi[["size"]], fi[["mtime"]])
[18:04:57.483]                       stop(msg)
[18:04:57.483]                     }
[18:04:57.483]                     invisible(pathname)
[18:04:57.483]                   }
[18:04:57.483]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.483]                     rootPath = tempdir()) 
[18:04:57.483]                   {
[18:04:57.483]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.483]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.483]                       tmpdir = path, fileext = ".rds")
[18:04:57.483]                     save_rds(obj, file)
[18:04:57.483]                   }
[18:04:57.483]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.483]                   {
[18:04:57.483]                     inherits <- base::inherits
[18:04:57.483]                     invokeRestart <- base::invokeRestart
[18:04:57.483]                     is.null <- base::is.null
[18:04:57.483]                     muffled <- FALSE
[18:04:57.483]                     if (inherits(cond, "message")) {
[18:04:57.483]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.483]                       if (muffled) 
[18:04:57.483]                         invokeRestart("muffleMessage")
[18:04:57.483]                     }
[18:04:57.483]                     else if (inherits(cond, "warning")) {
[18:04:57.483]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.483]                       if (muffled) 
[18:04:57.483]                         invokeRestart("muffleWarning")
[18:04:57.483]                     }
[18:04:57.483]                     else if (inherits(cond, "condition")) {
[18:04:57.483]                       if (!is.null(pattern)) {
[18:04:57.483]                         computeRestarts <- base::computeRestarts
[18:04:57.483]                         grepl <- base::grepl
[18:04:57.483]                         restarts <- computeRestarts(cond)
[18:04:57.483]                         for (restart in restarts) {
[18:04:57.483]                           name <- restart$name
[18:04:57.483]                           if (is.null(name)) 
[18:04:57.483]                             next
[18:04:57.483]                           if (!grepl(pattern, name)) 
[18:04:57.483]                             next
[18:04:57.483]                           invokeRestart(restart)
[18:04:57.483]                           muffled <- TRUE
[18:04:57.483]                           break
[18:04:57.483]                         }
[18:04:57.483]                       }
[18:04:57.483]                     }
[18:04:57.483]                     invisible(muffled)
[18:04:57.483]                   }
[18:04:57.483]                   muffleCondition(cond)
[18:04:57.483]                 })
[18:04:57.483]             }))
[18:04:57.483]             future::FutureResult(value = ...future.value$value, 
[18:04:57.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.483]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.483]                     ...future.globalenv.names))
[18:04:57.483]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.483]         }, condition = base::local({
[18:04:57.483]             c <- base::c
[18:04:57.483]             inherits <- base::inherits
[18:04:57.483]             invokeRestart <- base::invokeRestart
[18:04:57.483]             length <- base::length
[18:04:57.483]             list <- base::list
[18:04:57.483]             seq.int <- base::seq.int
[18:04:57.483]             signalCondition <- base::signalCondition
[18:04:57.483]             sys.calls <- base::sys.calls
[18:04:57.483]             `[[` <- base::`[[`
[18:04:57.483]             `+` <- base::`+`
[18:04:57.483]             `<<-` <- base::`<<-`
[18:04:57.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.483]                   3L)]
[18:04:57.483]             }
[18:04:57.483]             function(cond) {
[18:04:57.483]                 is_error <- inherits(cond, "error")
[18:04:57.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.483]                   NULL)
[18:04:57.483]                 if (is_error) {
[18:04:57.483]                   sessionInformation <- function() {
[18:04:57.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.483]                       search = base::search(), system = base::Sys.info())
[18:04:57.483]                   }
[18:04:57.483]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.483]                     cond$call), session = sessionInformation(), 
[18:04:57.483]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.483]                   signalCondition(cond)
[18:04:57.483]                 }
[18:04:57.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.483]                 "immediateCondition"))) {
[18:04:57.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.483]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.483]                   if (TRUE && !signal) {
[18:04:57.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.483]                     {
[18:04:57.483]                       inherits <- base::inherits
[18:04:57.483]                       invokeRestart <- base::invokeRestart
[18:04:57.483]                       is.null <- base::is.null
[18:04:57.483]                       muffled <- FALSE
[18:04:57.483]                       if (inherits(cond, "message")) {
[18:04:57.483]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.483]                         if (muffled) 
[18:04:57.483]                           invokeRestart("muffleMessage")
[18:04:57.483]                       }
[18:04:57.483]                       else if (inherits(cond, "warning")) {
[18:04:57.483]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.483]                         if (muffled) 
[18:04:57.483]                           invokeRestart("muffleWarning")
[18:04:57.483]                       }
[18:04:57.483]                       else if (inherits(cond, "condition")) {
[18:04:57.483]                         if (!is.null(pattern)) {
[18:04:57.483]                           computeRestarts <- base::computeRestarts
[18:04:57.483]                           grepl <- base::grepl
[18:04:57.483]                           restarts <- computeRestarts(cond)
[18:04:57.483]                           for (restart in restarts) {
[18:04:57.483]                             name <- restart$name
[18:04:57.483]                             if (is.null(name)) 
[18:04:57.483]                               next
[18:04:57.483]                             if (!grepl(pattern, name)) 
[18:04:57.483]                               next
[18:04:57.483]                             invokeRestart(restart)
[18:04:57.483]                             muffled <- TRUE
[18:04:57.483]                             break
[18:04:57.483]                           }
[18:04:57.483]                         }
[18:04:57.483]                       }
[18:04:57.483]                       invisible(muffled)
[18:04:57.483]                     }
[18:04:57.483]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.483]                   }
[18:04:57.483]                 }
[18:04:57.483]                 else {
[18:04:57.483]                   if (TRUE) {
[18:04:57.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.483]                     {
[18:04:57.483]                       inherits <- base::inherits
[18:04:57.483]                       invokeRestart <- base::invokeRestart
[18:04:57.483]                       is.null <- base::is.null
[18:04:57.483]                       muffled <- FALSE
[18:04:57.483]                       if (inherits(cond, "message")) {
[18:04:57.483]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.483]                         if (muffled) 
[18:04:57.483]                           invokeRestart("muffleMessage")
[18:04:57.483]                       }
[18:04:57.483]                       else if (inherits(cond, "warning")) {
[18:04:57.483]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.483]                         if (muffled) 
[18:04:57.483]                           invokeRestart("muffleWarning")
[18:04:57.483]                       }
[18:04:57.483]                       else if (inherits(cond, "condition")) {
[18:04:57.483]                         if (!is.null(pattern)) {
[18:04:57.483]                           computeRestarts <- base::computeRestarts
[18:04:57.483]                           grepl <- base::grepl
[18:04:57.483]                           restarts <- computeRestarts(cond)
[18:04:57.483]                           for (restart in restarts) {
[18:04:57.483]                             name <- restart$name
[18:04:57.483]                             if (is.null(name)) 
[18:04:57.483]                               next
[18:04:57.483]                             if (!grepl(pattern, name)) 
[18:04:57.483]                               next
[18:04:57.483]                             invokeRestart(restart)
[18:04:57.483]                             muffled <- TRUE
[18:04:57.483]                             break
[18:04:57.483]                           }
[18:04:57.483]                         }
[18:04:57.483]                       }
[18:04:57.483]                       invisible(muffled)
[18:04:57.483]                     }
[18:04:57.483]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.483]                   }
[18:04:57.483]                 }
[18:04:57.483]             }
[18:04:57.483]         }))
[18:04:57.483]     }, error = function(ex) {
[18:04:57.483]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.483]                 ...future.rng), started = ...future.startTime, 
[18:04:57.483]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.483]             version = "1.8"), class = "FutureResult")
[18:04:57.483]     }, finally = {
[18:04:57.483]         if (!identical(...future.workdir, getwd())) 
[18:04:57.483]             setwd(...future.workdir)
[18:04:57.483]         {
[18:04:57.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.483]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.483]             }
[18:04:57.483]             base::options(...future.oldOptions)
[18:04:57.483]             if (.Platform$OS.type == "windows") {
[18:04:57.483]                 old_names <- names(...future.oldEnvVars)
[18:04:57.483]                 envs <- base::Sys.getenv()
[18:04:57.483]                 names <- names(envs)
[18:04:57.483]                 common <- intersect(names, old_names)
[18:04:57.483]                 added <- setdiff(names, old_names)
[18:04:57.483]                 removed <- setdiff(old_names, names)
[18:04:57.483]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.483]                   envs[common]]
[18:04:57.483]                 NAMES <- toupper(changed)
[18:04:57.483]                 args <- list()
[18:04:57.483]                 for (kk in seq_along(NAMES)) {
[18:04:57.483]                   name <- changed[[kk]]
[18:04:57.483]                   NAME <- NAMES[[kk]]
[18:04:57.483]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.483]                     next
[18:04:57.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.483]                 }
[18:04:57.483]                 NAMES <- toupper(added)
[18:04:57.483]                 for (kk in seq_along(NAMES)) {
[18:04:57.483]                   name <- added[[kk]]
[18:04:57.483]                   NAME <- NAMES[[kk]]
[18:04:57.483]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.483]                     next
[18:04:57.483]                   args[[name]] <- ""
[18:04:57.483]                 }
[18:04:57.483]                 NAMES <- toupper(removed)
[18:04:57.483]                 for (kk in seq_along(NAMES)) {
[18:04:57.483]                   name <- removed[[kk]]
[18:04:57.483]                   NAME <- NAMES[[kk]]
[18:04:57.483]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.483]                     next
[18:04:57.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.483]                 }
[18:04:57.483]                 if (length(args) > 0) 
[18:04:57.483]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.483]             }
[18:04:57.483]             else {
[18:04:57.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.483]             }
[18:04:57.483]             {
[18:04:57.483]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.483]                   0L) {
[18:04:57.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.483]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.483]                   base::options(opts)
[18:04:57.483]                 }
[18:04:57.483]                 {
[18:04:57.483]                   {
[18:04:57.483]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.483]                     NULL
[18:04:57.483]                   }
[18:04:57.483]                   options(future.plan = NULL)
[18:04:57.483]                   if (is.na(NA_character_)) 
[18:04:57.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.483]                     .init = FALSE)
[18:04:57.483]                 }
[18:04:57.483]             }
[18:04:57.483]         }
[18:04:57.483]     })
[18:04:57.483]     if (TRUE) {
[18:04:57.483]         base::sink(type = "output", split = FALSE)
[18:04:57.483]         if (TRUE) {
[18:04:57.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.483]         }
[18:04:57.483]         else {
[18:04:57.483]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.483]         }
[18:04:57.483]         base::close(...future.stdout)
[18:04:57.483]         ...future.stdout <- NULL
[18:04:57.483]     }
[18:04:57.483]     ...future.result$conditions <- ...future.conditions
[18:04:57.483]     ...future.result$finished <- base::Sys.time()
[18:04:57.483]     ...future.result
[18:04:57.483] }
[18:04:57.490] assign_globals() ...
[18:04:57.490] List of 1
[18:04:57.490]  $ a: num 3
[18:04:57.490]  - attr(*, "where")=List of 1
[18:04:57.490]   ..$ a:<environment: R_EmptyEnv> 
[18:04:57.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.490]  - attr(*, "resolved")= logi TRUE
[18:04:57.490]  - attr(*, "total_size")= num 56
[18:04:57.490]  - attr(*, "already-done")= logi TRUE
[18:04:57.496] - copied ‘a’ to environment
[18:04:57.496] assign_globals() ... done
[18:04:57.497] requestCore(): workers = 2
[18:04:57.503] MulticoreFuture started
[18:04:57.504] - Launch lazy future ... done
[18:04:57.506] plan(): Setting new future strategy stack:
[18:04:57.504] run() for ‘MulticoreFuture’ ... done
[18:04:57.508] result() for MulticoreFuture ...
[18:04:57.507] List of future strategies:
[18:04:57.507] 1. sequential:
[18:04:57.507]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.507]    - tweaked: FALSE
[18:04:57.507]    - call: NULL
[18:04:57.512] plan(): nbrOfWorkers() = 1
[18:04:57.517] plan(): Setting new future strategy stack:
[18:04:57.517] List of future strategies:
[18:04:57.517] 1. multicore:
[18:04:57.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.517]    - tweaked: FALSE
[18:04:57.517]    - call: plan(strategy)
[18:04:57.527] plan(): nbrOfWorkers() = 2
[18:04:57.529] result() for MulticoreFuture ...
[18:04:57.530] result() for MulticoreFuture ... done
[18:04:57.530] result() for MulticoreFuture ... done
[18:04:57.530] result() for MulticoreFuture ...
[18:04:57.534] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.536] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.536] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:57.542] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:04:57.542] Searching for globals ... DONE
[18:04:57.542] Resolving globals: TRUE
[18:04:57.543] Resolving any globals that are futures ...
[18:04:57.543] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:04:57.543] Resolving any globals that are futures ... DONE
[18:04:57.544] Resolving futures part of globals (recursively) ...
[18:04:57.545] resolve() on list ...
[18:04:57.545]  recursive: 99
[18:04:57.545]  length: 1
[18:04:57.546]  elements: ‘a’
[18:04:57.546]  length: 0 (resolved future 1)
[18:04:57.546] resolve() on list ... DONE
[18:04:57.546] - globals: [1] ‘a’
[18:04:57.547] Resolving futures part of globals (recursively) ... DONE
[18:04:57.547] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:57.548] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:04:57.549] - globals: [1] ‘a’
[18:04:57.549] 
[18:04:57.549] getGlobalsAndPackages() ... DONE
[18:04:57.550] run() for ‘Future’ ...
[18:04:57.550] - state: ‘created’
[18:04:57.551] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.558] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.559]   - Field: ‘label’
[18:04:57.559]   - Field: ‘local’
[18:04:57.559]   - Field: ‘owner’
[18:04:57.560]   - Field: ‘envir’
[18:04:57.560]   - Field: ‘workers’
[18:04:57.560]   - Field: ‘packages’
[18:04:57.560]   - Field: ‘gc’
[18:04:57.561]   - Field: ‘job’
[18:04:57.561]   - Field: ‘conditions’
[18:04:57.561]   - Field: ‘expr’
[18:04:57.561]   - Field: ‘uuid’
[18:04:57.562]   - Field: ‘seed’
[18:04:57.562]   - Field: ‘version’
[18:04:57.562]   - Field: ‘result’
[18:04:57.562]   - Field: ‘asynchronous’
[18:04:57.563]   - Field: ‘calls’
[18:04:57.563]   - Field: ‘globals’
[18:04:57.563]   - Field: ‘stdout’
[18:04:57.563]   - Field: ‘earlySignal’
[18:04:57.564]   - Field: ‘lazy’
[18:04:57.564]   - Field: ‘state’
[18:04:57.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.564] - Launch lazy future ...
[18:04:57.565] Packages needed by the future expression (n = 0): <none>
[18:04:57.565] Packages needed by future strategies (n = 0): <none>
[18:04:57.566] {
[18:04:57.566]     {
[18:04:57.566]         {
[18:04:57.566]             ...future.startTime <- base::Sys.time()
[18:04:57.566]             {
[18:04:57.566]                 {
[18:04:57.566]                   {
[18:04:57.566]                     {
[18:04:57.566]                       base::local({
[18:04:57.566]                         has_future <- base::requireNamespace("future", 
[18:04:57.566]                           quietly = TRUE)
[18:04:57.566]                         if (has_future) {
[18:04:57.566]                           ns <- base::getNamespace("future")
[18:04:57.566]                           version <- ns[[".package"]][["version"]]
[18:04:57.566]                           if (is.null(version)) 
[18:04:57.566]                             version <- utils::packageVersion("future")
[18:04:57.566]                         }
[18:04:57.566]                         else {
[18:04:57.566]                           version <- NULL
[18:04:57.566]                         }
[18:04:57.566]                         if (!has_future || version < "1.8.0") {
[18:04:57.566]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.566]                             "", base::R.version$version.string), 
[18:04:57.566]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:57.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:57.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.566]                               "release", "version")], collapse = " "), 
[18:04:57.566]                             hostname = base::Sys.info()[["nodename"]])
[18:04:57.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.566]                             info)
[18:04:57.566]                           info <- base::paste(info, collapse = "; ")
[18:04:57.566]                           if (!has_future) {
[18:04:57.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.566]                               info)
[18:04:57.566]                           }
[18:04:57.566]                           else {
[18:04:57.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.566]                               info, version)
[18:04:57.566]                           }
[18:04:57.566]                           base::stop(msg)
[18:04:57.566]                         }
[18:04:57.566]                       })
[18:04:57.566]                     }
[18:04:57.566]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.566]                     base::options(mc.cores = 1L)
[18:04:57.566]                   }
[18:04:57.566]                   ...future.strategy.old <- future::plan("list")
[18:04:57.566]                   options(future.plan = NULL)
[18:04:57.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.566]                 }
[18:04:57.566]                 ...future.workdir <- getwd()
[18:04:57.566]             }
[18:04:57.566]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.566]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.566]         }
[18:04:57.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.566]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:57.566]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.566]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.566]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.566]             base::names(...future.oldOptions))
[18:04:57.566]     }
[18:04:57.566]     if (FALSE) {
[18:04:57.566]     }
[18:04:57.566]     else {
[18:04:57.566]         if (TRUE) {
[18:04:57.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.566]                 open = "w")
[18:04:57.566]         }
[18:04:57.566]         else {
[18:04:57.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.566]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.566]         }
[18:04:57.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.566]             base::sink(type = "output", split = FALSE)
[18:04:57.566]             base::close(...future.stdout)
[18:04:57.566]         }, add = TRUE)
[18:04:57.566]     }
[18:04:57.566]     ...future.frame <- base::sys.nframe()
[18:04:57.566]     ...future.conditions <- base::list()
[18:04:57.566]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.566]     if (FALSE) {
[18:04:57.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.566]     }
[18:04:57.566]     ...future.result <- base::tryCatch({
[18:04:57.566]         base::withCallingHandlers({
[18:04:57.566]             ...future.value <- base::withVisible(base::local({
[18:04:57.566]                 withCallingHandlers({
[18:04:57.566]                   {
[18:04:57.566]                     b <- a
[18:04:57.566]                     a <- 2
[18:04:57.566]                     a * b
[18:04:57.566]                   }
[18:04:57.566]                 }, immediateCondition = function(cond) {
[18:04:57.566]                   save_rds <- function (object, pathname, ...) 
[18:04:57.566]                   {
[18:04:57.566]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.566]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.566]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.566]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.566]                         fi_tmp[["mtime"]])
[18:04:57.566]                     }
[18:04:57.566]                     tryCatch({
[18:04:57.566]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.566]                     }, error = function(ex) {
[18:04:57.566]                       msg <- conditionMessage(ex)
[18:04:57.566]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.566]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.566]                         fi_tmp[["mtime"]], msg)
[18:04:57.566]                       ex$message <- msg
[18:04:57.566]                       stop(ex)
[18:04:57.566]                     })
[18:04:57.566]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.566]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.566]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.566]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.566]                       fi <- file.info(pathname)
[18:04:57.566]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.566]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.566]                         fi[["size"]], fi[["mtime"]])
[18:04:57.566]                       stop(msg)
[18:04:57.566]                     }
[18:04:57.566]                     invisible(pathname)
[18:04:57.566]                   }
[18:04:57.566]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.566]                     rootPath = tempdir()) 
[18:04:57.566]                   {
[18:04:57.566]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.566]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.566]                       tmpdir = path, fileext = ".rds")
[18:04:57.566]                     save_rds(obj, file)
[18:04:57.566]                   }
[18:04:57.566]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.566]                   {
[18:04:57.566]                     inherits <- base::inherits
[18:04:57.566]                     invokeRestart <- base::invokeRestart
[18:04:57.566]                     is.null <- base::is.null
[18:04:57.566]                     muffled <- FALSE
[18:04:57.566]                     if (inherits(cond, "message")) {
[18:04:57.566]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.566]                       if (muffled) 
[18:04:57.566]                         invokeRestart("muffleMessage")
[18:04:57.566]                     }
[18:04:57.566]                     else if (inherits(cond, "warning")) {
[18:04:57.566]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.566]                       if (muffled) 
[18:04:57.566]                         invokeRestart("muffleWarning")
[18:04:57.566]                     }
[18:04:57.566]                     else if (inherits(cond, "condition")) {
[18:04:57.566]                       if (!is.null(pattern)) {
[18:04:57.566]                         computeRestarts <- base::computeRestarts
[18:04:57.566]                         grepl <- base::grepl
[18:04:57.566]                         restarts <- computeRestarts(cond)
[18:04:57.566]                         for (restart in restarts) {
[18:04:57.566]                           name <- restart$name
[18:04:57.566]                           if (is.null(name)) 
[18:04:57.566]                             next
[18:04:57.566]                           if (!grepl(pattern, name)) 
[18:04:57.566]                             next
[18:04:57.566]                           invokeRestart(restart)
[18:04:57.566]                           muffled <- TRUE
[18:04:57.566]                           break
[18:04:57.566]                         }
[18:04:57.566]                       }
[18:04:57.566]                     }
[18:04:57.566]                     invisible(muffled)
[18:04:57.566]                   }
[18:04:57.566]                   muffleCondition(cond)
[18:04:57.566]                 })
[18:04:57.566]             }))
[18:04:57.566]             future::FutureResult(value = ...future.value$value, 
[18:04:57.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.566]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.566]                     ...future.globalenv.names))
[18:04:57.566]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.566]         }, condition = base::local({
[18:04:57.566]             c <- base::c
[18:04:57.566]             inherits <- base::inherits
[18:04:57.566]             invokeRestart <- base::invokeRestart
[18:04:57.566]             length <- base::length
[18:04:57.566]             list <- base::list
[18:04:57.566]             seq.int <- base::seq.int
[18:04:57.566]             signalCondition <- base::signalCondition
[18:04:57.566]             sys.calls <- base::sys.calls
[18:04:57.566]             `[[` <- base::`[[`
[18:04:57.566]             `+` <- base::`+`
[18:04:57.566]             `<<-` <- base::`<<-`
[18:04:57.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.566]                   3L)]
[18:04:57.566]             }
[18:04:57.566]             function(cond) {
[18:04:57.566]                 is_error <- inherits(cond, "error")
[18:04:57.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.566]                   NULL)
[18:04:57.566]                 if (is_error) {
[18:04:57.566]                   sessionInformation <- function() {
[18:04:57.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.566]                       search = base::search(), system = base::Sys.info())
[18:04:57.566]                   }
[18:04:57.566]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.566]                     cond$call), session = sessionInformation(), 
[18:04:57.566]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.566]                   signalCondition(cond)
[18:04:57.566]                 }
[18:04:57.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.566]                 "immediateCondition"))) {
[18:04:57.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.566]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.566]                   if (TRUE && !signal) {
[18:04:57.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.566]                     {
[18:04:57.566]                       inherits <- base::inherits
[18:04:57.566]                       invokeRestart <- base::invokeRestart
[18:04:57.566]                       is.null <- base::is.null
[18:04:57.566]                       muffled <- FALSE
[18:04:57.566]                       if (inherits(cond, "message")) {
[18:04:57.566]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.566]                         if (muffled) 
[18:04:57.566]                           invokeRestart("muffleMessage")
[18:04:57.566]                       }
[18:04:57.566]                       else if (inherits(cond, "warning")) {
[18:04:57.566]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.566]                         if (muffled) 
[18:04:57.566]                           invokeRestart("muffleWarning")
[18:04:57.566]                       }
[18:04:57.566]                       else if (inherits(cond, "condition")) {
[18:04:57.566]                         if (!is.null(pattern)) {
[18:04:57.566]                           computeRestarts <- base::computeRestarts
[18:04:57.566]                           grepl <- base::grepl
[18:04:57.566]                           restarts <- computeRestarts(cond)
[18:04:57.566]                           for (restart in restarts) {
[18:04:57.566]                             name <- restart$name
[18:04:57.566]                             if (is.null(name)) 
[18:04:57.566]                               next
[18:04:57.566]                             if (!grepl(pattern, name)) 
[18:04:57.566]                               next
[18:04:57.566]                             invokeRestart(restart)
[18:04:57.566]                             muffled <- TRUE
[18:04:57.566]                             break
[18:04:57.566]                           }
[18:04:57.566]                         }
[18:04:57.566]                       }
[18:04:57.566]                       invisible(muffled)
[18:04:57.566]                     }
[18:04:57.566]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.566]                   }
[18:04:57.566]                 }
[18:04:57.566]                 else {
[18:04:57.566]                   if (TRUE) {
[18:04:57.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.566]                     {
[18:04:57.566]                       inherits <- base::inherits
[18:04:57.566]                       invokeRestart <- base::invokeRestart
[18:04:57.566]                       is.null <- base::is.null
[18:04:57.566]                       muffled <- FALSE
[18:04:57.566]                       if (inherits(cond, "message")) {
[18:04:57.566]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.566]                         if (muffled) 
[18:04:57.566]                           invokeRestart("muffleMessage")
[18:04:57.566]                       }
[18:04:57.566]                       else if (inherits(cond, "warning")) {
[18:04:57.566]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.566]                         if (muffled) 
[18:04:57.566]                           invokeRestart("muffleWarning")
[18:04:57.566]                       }
[18:04:57.566]                       else if (inherits(cond, "condition")) {
[18:04:57.566]                         if (!is.null(pattern)) {
[18:04:57.566]                           computeRestarts <- base::computeRestarts
[18:04:57.566]                           grepl <- base::grepl
[18:04:57.566]                           restarts <- computeRestarts(cond)
[18:04:57.566]                           for (restart in restarts) {
[18:04:57.566]                             name <- restart$name
[18:04:57.566]                             if (is.null(name)) 
[18:04:57.566]                               next
[18:04:57.566]                             if (!grepl(pattern, name)) 
[18:04:57.566]                               next
[18:04:57.566]                             invokeRestart(restart)
[18:04:57.566]                             muffled <- TRUE
[18:04:57.566]                             break
[18:04:57.566]                           }
[18:04:57.566]                         }
[18:04:57.566]                       }
[18:04:57.566]                       invisible(muffled)
[18:04:57.566]                     }
[18:04:57.566]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.566]                   }
[18:04:57.566]                 }
[18:04:57.566]             }
[18:04:57.566]         }))
[18:04:57.566]     }, error = function(ex) {
[18:04:57.566]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.566]                 ...future.rng), started = ...future.startTime, 
[18:04:57.566]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.566]             version = "1.8"), class = "FutureResult")
[18:04:57.566]     }, finally = {
[18:04:57.566]         if (!identical(...future.workdir, getwd())) 
[18:04:57.566]             setwd(...future.workdir)
[18:04:57.566]         {
[18:04:57.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.566]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.566]             }
[18:04:57.566]             base::options(...future.oldOptions)
[18:04:57.566]             if (.Platform$OS.type == "windows") {
[18:04:57.566]                 old_names <- names(...future.oldEnvVars)
[18:04:57.566]                 envs <- base::Sys.getenv()
[18:04:57.566]                 names <- names(envs)
[18:04:57.566]                 common <- intersect(names, old_names)
[18:04:57.566]                 added <- setdiff(names, old_names)
[18:04:57.566]                 removed <- setdiff(old_names, names)
[18:04:57.566]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.566]                   envs[common]]
[18:04:57.566]                 NAMES <- toupper(changed)
[18:04:57.566]                 args <- list()
[18:04:57.566]                 for (kk in seq_along(NAMES)) {
[18:04:57.566]                   name <- changed[[kk]]
[18:04:57.566]                   NAME <- NAMES[[kk]]
[18:04:57.566]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.566]                     next
[18:04:57.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.566]                 }
[18:04:57.566]                 NAMES <- toupper(added)
[18:04:57.566]                 for (kk in seq_along(NAMES)) {
[18:04:57.566]                   name <- added[[kk]]
[18:04:57.566]                   NAME <- NAMES[[kk]]
[18:04:57.566]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.566]                     next
[18:04:57.566]                   args[[name]] <- ""
[18:04:57.566]                 }
[18:04:57.566]                 NAMES <- toupper(removed)
[18:04:57.566]                 for (kk in seq_along(NAMES)) {
[18:04:57.566]                   name <- removed[[kk]]
[18:04:57.566]                   NAME <- NAMES[[kk]]
[18:04:57.566]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.566]                     next
[18:04:57.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.566]                 }
[18:04:57.566]                 if (length(args) > 0) 
[18:04:57.566]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.566]             }
[18:04:57.566]             else {
[18:04:57.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.566]             }
[18:04:57.566]             {
[18:04:57.566]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.566]                   0L) {
[18:04:57.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.566]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.566]                   base::options(opts)
[18:04:57.566]                 }
[18:04:57.566]                 {
[18:04:57.566]                   {
[18:04:57.566]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.566]                     NULL
[18:04:57.566]                   }
[18:04:57.566]                   options(future.plan = NULL)
[18:04:57.566]                   if (is.na(NA_character_)) 
[18:04:57.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.566]                     .init = FALSE)
[18:04:57.566]                 }
[18:04:57.566]             }
[18:04:57.566]         }
[18:04:57.566]     })
[18:04:57.566]     if (TRUE) {
[18:04:57.566]         base::sink(type = "output", split = FALSE)
[18:04:57.566]         if (TRUE) {
[18:04:57.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.566]         }
[18:04:57.566]         else {
[18:04:57.566]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.566]         }
[18:04:57.566]         base::close(...future.stdout)
[18:04:57.566]         ...future.stdout <- NULL
[18:04:57.566]     }
[18:04:57.566]     ...future.result$conditions <- ...future.conditions
[18:04:57.566]     ...future.result$finished <- base::Sys.time()
[18:04:57.566]     ...future.result
[18:04:57.566] }
[18:04:57.573] assign_globals() ...
[18:04:57.573] List of 1
[18:04:57.573]  $ a: num 3
[18:04:57.573]  - attr(*, "where")=List of 1
[18:04:57.573]   ..$ a:<environment: R_EmptyEnv> 
[18:04:57.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.573]  - attr(*, "resolved")= logi TRUE
[18:04:57.573]  - attr(*, "total_size")= num 56
[18:04:57.573]  - attr(*, "already-done")= logi TRUE
[18:04:57.580] - copied ‘a’ to environment
[18:04:57.581] assign_globals() ... done
[18:04:57.581] requestCore(): workers = 2
[18:04:57.585] MulticoreFuture started
[18:04:57.586] - Launch lazy future ... done
[18:04:57.588] run() for ‘MulticoreFuture’ ... done
[18:04:57.590] plan(): Setting new future strategy stack:
[18:04:57.589] result() for MulticoreFuture ...
[18:04:57.591] List of future strategies:
[18:04:57.591] 1. sequential:
[18:04:57.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.591]    - tweaked: FALSE
[18:04:57.591]    - call: NULL
[18:04:57.607] plan(): nbrOfWorkers() = 1
[18:04:57.614] plan(): Setting new future strategy stack:
[18:04:57.615] List of future strategies:
[18:04:57.615] 1. multicore:
[18:04:57.615]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.615]    - tweaked: FALSE
[18:04:57.615]    - call: plan(strategy)
[18:04:57.626] plan(): nbrOfWorkers() = 2
[18:04:57.630] result() for MulticoreFuture ...
[18:04:57.630] result() for MulticoreFuture ... done
[18:04:57.631] result() for MulticoreFuture ... done
[18:04:57.633] result() for MulticoreFuture ...
[18:04:57.633] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.636] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.637] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:57.643] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.643] Searching for globals ... DONE
[18:04:57.643] Resolving globals: TRUE
[18:04:57.644] Resolving any globals that are futures ...
[18:04:57.644] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.644] Resolving any globals that are futures ... DONE
[18:04:57.646] Resolving futures part of globals (recursively) ...
[18:04:57.646] resolve() on list ...
[18:04:57.646]  recursive: 99
[18:04:57.647]  length: 2
[18:04:57.647]  elements: ‘a’, ‘ii’
[18:04:57.647]  length: 1 (resolved future 1)
[18:04:57.648]  length: 0 (resolved future 2)
[18:04:57.648] resolve() on list ... DONE
[18:04:57.648] - globals: [2] ‘a’, ‘ii’
[18:04:57.648] Resolving futures part of globals (recursively) ... DONE
[18:04:57.649] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:57.650] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:57.650] - globals: [2] ‘a’, ‘ii’
[18:04:57.650] 
[18:04:57.651] getGlobalsAndPackages() ... DONE
[18:04:57.651] run() for ‘Future’ ...
[18:04:57.652] - state: ‘created’
[18:04:57.652] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.659] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.659] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.660]   - Field: ‘label’
[18:04:57.660]   - Field: ‘local’
[18:04:57.660]   - Field: ‘owner’
[18:04:57.660]   - Field: ‘envir’
[18:04:57.661]   - Field: ‘workers’
[18:04:57.661]   - Field: ‘packages’
[18:04:57.661]   - Field: ‘gc’
[18:04:57.661]   - Field: ‘job’
[18:04:57.662]   - Field: ‘conditions’
[18:04:57.662]   - Field: ‘expr’
[18:04:57.662]   - Field: ‘uuid’
[18:04:57.662]   - Field: ‘seed’
[18:04:57.663]   - Field: ‘version’
[18:04:57.663]   - Field: ‘result’
[18:04:57.663]   - Field: ‘asynchronous’
[18:04:57.663]   - Field: ‘calls’
[18:04:57.664]   - Field: ‘globals’
[18:04:57.664]   - Field: ‘stdout’
[18:04:57.664]   - Field: ‘earlySignal’
[18:04:57.664]   - Field: ‘lazy’
[18:04:57.664]   - Field: ‘state’
[18:04:57.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.665] - Launch lazy future ...
[18:04:57.666] Packages needed by the future expression (n = 0): <none>
[18:04:57.666] Packages needed by future strategies (n = 0): <none>
[18:04:57.667] {
[18:04:57.667]     {
[18:04:57.667]         {
[18:04:57.667]             ...future.startTime <- base::Sys.time()
[18:04:57.667]             {
[18:04:57.667]                 {
[18:04:57.667]                   {
[18:04:57.667]                     {
[18:04:57.667]                       base::local({
[18:04:57.667]                         has_future <- base::requireNamespace("future", 
[18:04:57.667]                           quietly = TRUE)
[18:04:57.667]                         if (has_future) {
[18:04:57.667]                           ns <- base::getNamespace("future")
[18:04:57.667]                           version <- ns[[".package"]][["version"]]
[18:04:57.667]                           if (is.null(version)) 
[18:04:57.667]                             version <- utils::packageVersion("future")
[18:04:57.667]                         }
[18:04:57.667]                         else {
[18:04:57.667]                           version <- NULL
[18:04:57.667]                         }
[18:04:57.667]                         if (!has_future || version < "1.8.0") {
[18:04:57.667]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.667]                             "", base::R.version$version.string), 
[18:04:57.667]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:57.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:57.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.667]                               "release", "version")], collapse = " "), 
[18:04:57.667]                             hostname = base::Sys.info()[["nodename"]])
[18:04:57.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.667]                             info)
[18:04:57.667]                           info <- base::paste(info, collapse = "; ")
[18:04:57.667]                           if (!has_future) {
[18:04:57.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.667]                               info)
[18:04:57.667]                           }
[18:04:57.667]                           else {
[18:04:57.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.667]                               info, version)
[18:04:57.667]                           }
[18:04:57.667]                           base::stop(msg)
[18:04:57.667]                         }
[18:04:57.667]                       })
[18:04:57.667]                     }
[18:04:57.667]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.667]                     base::options(mc.cores = 1L)
[18:04:57.667]                   }
[18:04:57.667]                   ...future.strategy.old <- future::plan("list")
[18:04:57.667]                   options(future.plan = NULL)
[18:04:57.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.667]                 }
[18:04:57.667]                 ...future.workdir <- getwd()
[18:04:57.667]             }
[18:04:57.667]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.667]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.667]         }
[18:04:57.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.667]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:57.667]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.667]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.667]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.667]             base::names(...future.oldOptions))
[18:04:57.667]     }
[18:04:57.667]     if (FALSE) {
[18:04:57.667]     }
[18:04:57.667]     else {
[18:04:57.667]         if (TRUE) {
[18:04:57.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.667]                 open = "w")
[18:04:57.667]         }
[18:04:57.667]         else {
[18:04:57.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.667]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.667]         }
[18:04:57.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.667]             base::sink(type = "output", split = FALSE)
[18:04:57.667]             base::close(...future.stdout)
[18:04:57.667]         }, add = TRUE)
[18:04:57.667]     }
[18:04:57.667]     ...future.frame <- base::sys.nframe()
[18:04:57.667]     ...future.conditions <- base::list()
[18:04:57.667]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.667]     if (FALSE) {
[18:04:57.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.667]     }
[18:04:57.667]     ...future.result <- base::tryCatch({
[18:04:57.667]         base::withCallingHandlers({
[18:04:57.667]             ...future.value <- base::withVisible(base::local({
[18:04:57.667]                 withCallingHandlers({
[18:04:57.667]                   {
[18:04:57.667]                     b <- a * ii
[18:04:57.667]                     a <- 0
[18:04:57.667]                     b
[18:04:57.667]                   }
[18:04:57.667]                 }, immediateCondition = function(cond) {
[18:04:57.667]                   save_rds <- function (object, pathname, ...) 
[18:04:57.667]                   {
[18:04:57.667]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.667]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.667]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.667]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.667]                         fi_tmp[["mtime"]])
[18:04:57.667]                     }
[18:04:57.667]                     tryCatch({
[18:04:57.667]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.667]                     }, error = function(ex) {
[18:04:57.667]                       msg <- conditionMessage(ex)
[18:04:57.667]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.667]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.667]                         fi_tmp[["mtime"]], msg)
[18:04:57.667]                       ex$message <- msg
[18:04:57.667]                       stop(ex)
[18:04:57.667]                     })
[18:04:57.667]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.667]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.667]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.667]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.667]                       fi <- file.info(pathname)
[18:04:57.667]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.667]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.667]                         fi[["size"]], fi[["mtime"]])
[18:04:57.667]                       stop(msg)
[18:04:57.667]                     }
[18:04:57.667]                     invisible(pathname)
[18:04:57.667]                   }
[18:04:57.667]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.667]                     rootPath = tempdir()) 
[18:04:57.667]                   {
[18:04:57.667]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.667]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.667]                       tmpdir = path, fileext = ".rds")
[18:04:57.667]                     save_rds(obj, file)
[18:04:57.667]                   }
[18:04:57.667]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.667]                   {
[18:04:57.667]                     inherits <- base::inherits
[18:04:57.667]                     invokeRestart <- base::invokeRestart
[18:04:57.667]                     is.null <- base::is.null
[18:04:57.667]                     muffled <- FALSE
[18:04:57.667]                     if (inherits(cond, "message")) {
[18:04:57.667]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.667]                       if (muffled) 
[18:04:57.667]                         invokeRestart("muffleMessage")
[18:04:57.667]                     }
[18:04:57.667]                     else if (inherits(cond, "warning")) {
[18:04:57.667]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.667]                       if (muffled) 
[18:04:57.667]                         invokeRestart("muffleWarning")
[18:04:57.667]                     }
[18:04:57.667]                     else if (inherits(cond, "condition")) {
[18:04:57.667]                       if (!is.null(pattern)) {
[18:04:57.667]                         computeRestarts <- base::computeRestarts
[18:04:57.667]                         grepl <- base::grepl
[18:04:57.667]                         restarts <- computeRestarts(cond)
[18:04:57.667]                         for (restart in restarts) {
[18:04:57.667]                           name <- restart$name
[18:04:57.667]                           if (is.null(name)) 
[18:04:57.667]                             next
[18:04:57.667]                           if (!grepl(pattern, name)) 
[18:04:57.667]                             next
[18:04:57.667]                           invokeRestart(restart)
[18:04:57.667]                           muffled <- TRUE
[18:04:57.667]                           break
[18:04:57.667]                         }
[18:04:57.667]                       }
[18:04:57.667]                     }
[18:04:57.667]                     invisible(muffled)
[18:04:57.667]                   }
[18:04:57.667]                   muffleCondition(cond)
[18:04:57.667]                 })
[18:04:57.667]             }))
[18:04:57.667]             future::FutureResult(value = ...future.value$value, 
[18:04:57.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.667]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.667]                     ...future.globalenv.names))
[18:04:57.667]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.667]         }, condition = base::local({
[18:04:57.667]             c <- base::c
[18:04:57.667]             inherits <- base::inherits
[18:04:57.667]             invokeRestart <- base::invokeRestart
[18:04:57.667]             length <- base::length
[18:04:57.667]             list <- base::list
[18:04:57.667]             seq.int <- base::seq.int
[18:04:57.667]             signalCondition <- base::signalCondition
[18:04:57.667]             sys.calls <- base::sys.calls
[18:04:57.667]             `[[` <- base::`[[`
[18:04:57.667]             `+` <- base::`+`
[18:04:57.667]             `<<-` <- base::`<<-`
[18:04:57.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.667]                   3L)]
[18:04:57.667]             }
[18:04:57.667]             function(cond) {
[18:04:57.667]                 is_error <- inherits(cond, "error")
[18:04:57.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.667]                   NULL)
[18:04:57.667]                 if (is_error) {
[18:04:57.667]                   sessionInformation <- function() {
[18:04:57.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.667]                       search = base::search(), system = base::Sys.info())
[18:04:57.667]                   }
[18:04:57.667]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.667]                     cond$call), session = sessionInformation(), 
[18:04:57.667]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.667]                   signalCondition(cond)
[18:04:57.667]                 }
[18:04:57.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.667]                 "immediateCondition"))) {
[18:04:57.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.667]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.667]                   if (TRUE && !signal) {
[18:04:57.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.667]                     {
[18:04:57.667]                       inherits <- base::inherits
[18:04:57.667]                       invokeRestart <- base::invokeRestart
[18:04:57.667]                       is.null <- base::is.null
[18:04:57.667]                       muffled <- FALSE
[18:04:57.667]                       if (inherits(cond, "message")) {
[18:04:57.667]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.667]                         if (muffled) 
[18:04:57.667]                           invokeRestart("muffleMessage")
[18:04:57.667]                       }
[18:04:57.667]                       else if (inherits(cond, "warning")) {
[18:04:57.667]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.667]                         if (muffled) 
[18:04:57.667]                           invokeRestart("muffleWarning")
[18:04:57.667]                       }
[18:04:57.667]                       else if (inherits(cond, "condition")) {
[18:04:57.667]                         if (!is.null(pattern)) {
[18:04:57.667]                           computeRestarts <- base::computeRestarts
[18:04:57.667]                           grepl <- base::grepl
[18:04:57.667]                           restarts <- computeRestarts(cond)
[18:04:57.667]                           for (restart in restarts) {
[18:04:57.667]                             name <- restart$name
[18:04:57.667]                             if (is.null(name)) 
[18:04:57.667]                               next
[18:04:57.667]                             if (!grepl(pattern, name)) 
[18:04:57.667]                               next
[18:04:57.667]                             invokeRestart(restart)
[18:04:57.667]                             muffled <- TRUE
[18:04:57.667]                             break
[18:04:57.667]                           }
[18:04:57.667]                         }
[18:04:57.667]                       }
[18:04:57.667]                       invisible(muffled)
[18:04:57.667]                     }
[18:04:57.667]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.667]                   }
[18:04:57.667]                 }
[18:04:57.667]                 else {
[18:04:57.667]                   if (TRUE) {
[18:04:57.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.667]                     {
[18:04:57.667]                       inherits <- base::inherits
[18:04:57.667]                       invokeRestart <- base::invokeRestart
[18:04:57.667]                       is.null <- base::is.null
[18:04:57.667]                       muffled <- FALSE
[18:04:57.667]                       if (inherits(cond, "message")) {
[18:04:57.667]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.667]                         if (muffled) 
[18:04:57.667]                           invokeRestart("muffleMessage")
[18:04:57.667]                       }
[18:04:57.667]                       else if (inherits(cond, "warning")) {
[18:04:57.667]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.667]                         if (muffled) 
[18:04:57.667]                           invokeRestart("muffleWarning")
[18:04:57.667]                       }
[18:04:57.667]                       else if (inherits(cond, "condition")) {
[18:04:57.667]                         if (!is.null(pattern)) {
[18:04:57.667]                           computeRestarts <- base::computeRestarts
[18:04:57.667]                           grepl <- base::grepl
[18:04:57.667]                           restarts <- computeRestarts(cond)
[18:04:57.667]                           for (restart in restarts) {
[18:04:57.667]                             name <- restart$name
[18:04:57.667]                             if (is.null(name)) 
[18:04:57.667]                               next
[18:04:57.667]                             if (!grepl(pattern, name)) 
[18:04:57.667]                               next
[18:04:57.667]                             invokeRestart(restart)
[18:04:57.667]                             muffled <- TRUE
[18:04:57.667]                             break
[18:04:57.667]                           }
[18:04:57.667]                         }
[18:04:57.667]                       }
[18:04:57.667]                       invisible(muffled)
[18:04:57.667]                     }
[18:04:57.667]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.667]                   }
[18:04:57.667]                 }
[18:04:57.667]             }
[18:04:57.667]         }))
[18:04:57.667]     }, error = function(ex) {
[18:04:57.667]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.667]                 ...future.rng), started = ...future.startTime, 
[18:04:57.667]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.667]             version = "1.8"), class = "FutureResult")
[18:04:57.667]     }, finally = {
[18:04:57.667]         if (!identical(...future.workdir, getwd())) 
[18:04:57.667]             setwd(...future.workdir)
[18:04:57.667]         {
[18:04:57.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.667]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.667]             }
[18:04:57.667]             base::options(...future.oldOptions)
[18:04:57.667]             if (.Platform$OS.type == "windows") {
[18:04:57.667]                 old_names <- names(...future.oldEnvVars)
[18:04:57.667]                 envs <- base::Sys.getenv()
[18:04:57.667]                 names <- names(envs)
[18:04:57.667]                 common <- intersect(names, old_names)
[18:04:57.667]                 added <- setdiff(names, old_names)
[18:04:57.667]                 removed <- setdiff(old_names, names)
[18:04:57.667]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.667]                   envs[common]]
[18:04:57.667]                 NAMES <- toupper(changed)
[18:04:57.667]                 args <- list()
[18:04:57.667]                 for (kk in seq_along(NAMES)) {
[18:04:57.667]                   name <- changed[[kk]]
[18:04:57.667]                   NAME <- NAMES[[kk]]
[18:04:57.667]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.667]                     next
[18:04:57.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.667]                 }
[18:04:57.667]                 NAMES <- toupper(added)
[18:04:57.667]                 for (kk in seq_along(NAMES)) {
[18:04:57.667]                   name <- added[[kk]]
[18:04:57.667]                   NAME <- NAMES[[kk]]
[18:04:57.667]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.667]                     next
[18:04:57.667]                   args[[name]] <- ""
[18:04:57.667]                 }
[18:04:57.667]                 NAMES <- toupper(removed)
[18:04:57.667]                 for (kk in seq_along(NAMES)) {
[18:04:57.667]                   name <- removed[[kk]]
[18:04:57.667]                   NAME <- NAMES[[kk]]
[18:04:57.667]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.667]                     next
[18:04:57.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.667]                 }
[18:04:57.667]                 if (length(args) > 0) 
[18:04:57.667]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.667]             }
[18:04:57.667]             else {
[18:04:57.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.667]             }
[18:04:57.667]             {
[18:04:57.667]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.667]                   0L) {
[18:04:57.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.667]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.667]                   base::options(opts)
[18:04:57.667]                 }
[18:04:57.667]                 {
[18:04:57.667]                   {
[18:04:57.667]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.667]                     NULL
[18:04:57.667]                   }
[18:04:57.667]                   options(future.plan = NULL)
[18:04:57.667]                   if (is.na(NA_character_)) 
[18:04:57.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.667]                     .init = FALSE)
[18:04:57.667]                 }
[18:04:57.667]             }
[18:04:57.667]         }
[18:04:57.667]     })
[18:04:57.667]     if (TRUE) {
[18:04:57.667]         base::sink(type = "output", split = FALSE)
[18:04:57.667]         if (TRUE) {
[18:04:57.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.667]         }
[18:04:57.667]         else {
[18:04:57.667]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.667]         }
[18:04:57.667]         base::close(...future.stdout)
[18:04:57.667]         ...future.stdout <- NULL
[18:04:57.667]     }
[18:04:57.667]     ...future.result$conditions <- ...future.conditions
[18:04:57.667]     ...future.result$finished <- base::Sys.time()
[18:04:57.667]     ...future.result
[18:04:57.667] }
[18:04:57.672] assign_globals() ...
[18:04:57.672] List of 2
[18:04:57.672]  $ a : num 1
[18:04:57.672]  $ ii: int 1
[18:04:57.672]  - attr(*, "where")=List of 2
[18:04:57.672]   ..$ a :<environment: R_EmptyEnv> 
[18:04:57.672]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:57.672]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.672]  - attr(*, "resolved")= logi TRUE
[18:04:57.672]  - attr(*, "total_size")= num 112
[18:04:57.672]  - attr(*, "already-done")= logi TRUE
[18:04:57.680] - copied ‘a’ to environment
[18:04:57.680] - copied ‘ii’ to environment
[18:04:57.680] assign_globals() ... done
[18:04:57.681] requestCore(): workers = 2
[18:04:57.684] MulticoreFuture started
[18:04:57.685] - Launch lazy future ... done
[18:04:57.688] plan(): Setting new future strategy stack:
[18:04:57.686] run() for ‘MulticoreFuture’ ... done
[18:04:57.689] List of future strategies:
[18:04:57.689] 1. sequential:
[18:04:57.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.689]    - tweaked: FALSE
[18:04:57.689]    - call: NULL
[18:04:57.693] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.694] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.695] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:57.702] plan(): Setting new future strategy stack:
[18:04:57.704] List of future strategies:
[18:04:57.704] 1. multicore:
[18:04:57.704]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.704]    - tweaked: FALSE
[18:04:57.704]    - call: plan(strategy)
[18:04:57.718] plan(): nbrOfWorkers() = 2
[18:04:57.721] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.722] Searching for globals ... DONE
[18:04:57.723] Resolving globals: TRUE
[18:04:57.724] Resolving any globals that are futures ...
[18:04:57.725] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.725] Resolving any globals that are futures ... DONE
[18:04:57.727] Resolving futures part of globals (recursively) ...
[18:04:57.729] resolve() on list ...
[18:04:57.729]  recursive: 99
[18:04:57.730]  length: 2
[18:04:57.730]  elements: ‘a’, ‘ii’
[18:04:57.731]  length: 1 (resolved future 1)
[18:04:57.731]  length: 0 (resolved future 2)
[18:04:57.731] resolve() on list ... DONE
[18:04:57.732] - globals: [2] ‘a’, ‘ii’
[18:04:57.733] Resolving futures part of globals (recursively) ... DONE
[18:04:57.734] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:57.735] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:57.736] - globals: [2] ‘a’, ‘ii’
[18:04:57.736] 
[18:04:57.736] getGlobalsAndPackages() ... DONE
[18:04:57.737] run() for ‘Future’ ...
[18:04:57.738] - state: ‘created’
[18:04:57.738] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.747] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.747] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.748]   - Field: ‘label’
[18:04:57.748]   - Field: ‘local’
[18:04:57.748]   - Field: ‘owner’
[18:04:57.749]   - Field: ‘envir’
[18:04:57.749]   - Field: ‘workers’
[18:04:57.749]   - Field: ‘packages’
[18:04:57.750]   - Field: ‘gc’
[18:04:57.750]   - Field: ‘job’
[18:04:57.750]   - Field: ‘conditions’
[18:04:57.751]   - Field: ‘expr’
[18:04:57.751]   - Field: ‘uuid’
[18:04:57.751]   - Field: ‘seed’
[18:04:57.751]   - Field: ‘version’
[18:04:57.752]   - Field: ‘result’
[18:04:57.752]   - Field: ‘asynchronous’
[18:04:57.752]   - Field: ‘calls’
[18:04:57.753]   - Field: ‘globals’
[18:04:57.753]   - Field: ‘stdout’
[18:04:57.753]   - Field: ‘earlySignal’
[18:04:57.754]   - Field: ‘lazy’
[18:04:57.754]   - Field: ‘state’
[18:04:57.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.754] - Launch lazy future ...
[18:04:57.755] Packages needed by the future expression (n = 0): <none>
[18:04:57.756] Packages needed by future strategies (n = 0): <none>
[18:04:57.757] {
[18:04:57.757]     {
[18:04:57.757]         {
[18:04:57.757]             ...future.startTime <- base::Sys.time()
[18:04:57.757]             {
[18:04:57.757]                 {
[18:04:57.757]                   {
[18:04:57.757]                     {
[18:04:57.757]                       base::local({
[18:04:57.757]                         has_future <- base::requireNamespace("future", 
[18:04:57.757]                           quietly = TRUE)
[18:04:57.757]                         if (has_future) {
[18:04:57.757]                           ns <- base::getNamespace("future")
[18:04:57.757]                           version <- ns[[".package"]][["version"]]
[18:04:57.757]                           if (is.null(version)) 
[18:04:57.757]                             version <- utils::packageVersion("future")
[18:04:57.757]                         }
[18:04:57.757]                         else {
[18:04:57.757]                           version <- NULL
[18:04:57.757]                         }
[18:04:57.757]                         if (!has_future || version < "1.8.0") {
[18:04:57.757]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.757]                             "", base::R.version$version.string), 
[18:04:57.757]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:57.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:57.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.757]                               "release", "version")], collapse = " "), 
[18:04:57.757]                             hostname = base::Sys.info()[["nodename"]])
[18:04:57.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.757]                             info)
[18:04:57.757]                           info <- base::paste(info, collapse = "; ")
[18:04:57.757]                           if (!has_future) {
[18:04:57.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.757]                               info)
[18:04:57.757]                           }
[18:04:57.757]                           else {
[18:04:57.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.757]                               info, version)
[18:04:57.757]                           }
[18:04:57.757]                           base::stop(msg)
[18:04:57.757]                         }
[18:04:57.757]                       })
[18:04:57.757]                     }
[18:04:57.757]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.757]                     base::options(mc.cores = 1L)
[18:04:57.757]                   }
[18:04:57.757]                   ...future.strategy.old <- future::plan("list")
[18:04:57.757]                   options(future.plan = NULL)
[18:04:57.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.757]                 }
[18:04:57.757]                 ...future.workdir <- getwd()
[18:04:57.757]             }
[18:04:57.757]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.757]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.757]         }
[18:04:57.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.757]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:57.757]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.757]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.757]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.757]             base::names(...future.oldOptions))
[18:04:57.757]     }
[18:04:57.757]     if (FALSE) {
[18:04:57.757]     }
[18:04:57.757]     else {
[18:04:57.757]         if (TRUE) {
[18:04:57.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.757]                 open = "w")
[18:04:57.757]         }
[18:04:57.757]         else {
[18:04:57.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.757]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.757]         }
[18:04:57.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.757]             base::sink(type = "output", split = FALSE)
[18:04:57.757]             base::close(...future.stdout)
[18:04:57.757]         }, add = TRUE)
[18:04:57.757]     }
[18:04:57.757]     ...future.frame <- base::sys.nframe()
[18:04:57.757]     ...future.conditions <- base::list()
[18:04:57.757]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.757]     if (FALSE) {
[18:04:57.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.757]     }
[18:04:57.757]     ...future.result <- base::tryCatch({
[18:04:57.757]         base::withCallingHandlers({
[18:04:57.757]             ...future.value <- base::withVisible(base::local({
[18:04:57.757]                 withCallingHandlers({
[18:04:57.757]                   {
[18:04:57.757]                     b <- a * ii
[18:04:57.757]                     a <- 0
[18:04:57.757]                     b
[18:04:57.757]                   }
[18:04:57.757]                 }, immediateCondition = function(cond) {
[18:04:57.757]                   save_rds <- function (object, pathname, ...) 
[18:04:57.757]                   {
[18:04:57.757]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.757]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.757]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.757]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.757]                         fi_tmp[["mtime"]])
[18:04:57.757]                     }
[18:04:57.757]                     tryCatch({
[18:04:57.757]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.757]                     }, error = function(ex) {
[18:04:57.757]                       msg <- conditionMessage(ex)
[18:04:57.757]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.757]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.757]                         fi_tmp[["mtime"]], msg)
[18:04:57.757]                       ex$message <- msg
[18:04:57.757]                       stop(ex)
[18:04:57.757]                     })
[18:04:57.757]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.757]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.757]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.757]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.757]                       fi <- file.info(pathname)
[18:04:57.757]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.757]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.757]                         fi[["size"]], fi[["mtime"]])
[18:04:57.757]                       stop(msg)
[18:04:57.757]                     }
[18:04:57.757]                     invisible(pathname)
[18:04:57.757]                   }
[18:04:57.757]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.757]                     rootPath = tempdir()) 
[18:04:57.757]                   {
[18:04:57.757]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.757]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.757]                       tmpdir = path, fileext = ".rds")
[18:04:57.757]                     save_rds(obj, file)
[18:04:57.757]                   }
[18:04:57.757]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.757]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.757]                   {
[18:04:57.757]                     inherits <- base::inherits
[18:04:57.757]                     invokeRestart <- base::invokeRestart
[18:04:57.757]                     is.null <- base::is.null
[18:04:57.757]                     muffled <- FALSE
[18:04:57.757]                     if (inherits(cond, "message")) {
[18:04:57.757]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.757]                       if (muffled) 
[18:04:57.757]                         invokeRestart("muffleMessage")
[18:04:57.757]                     }
[18:04:57.757]                     else if (inherits(cond, "warning")) {
[18:04:57.757]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.757]                       if (muffled) 
[18:04:57.757]                         invokeRestart("muffleWarning")
[18:04:57.757]                     }
[18:04:57.757]                     else if (inherits(cond, "condition")) {
[18:04:57.757]                       if (!is.null(pattern)) {
[18:04:57.757]                         computeRestarts <- base::computeRestarts
[18:04:57.757]                         grepl <- base::grepl
[18:04:57.757]                         restarts <- computeRestarts(cond)
[18:04:57.757]                         for (restart in restarts) {
[18:04:57.757]                           name <- restart$name
[18:04:57.757]                           if (is.null(name)) 
[18:04:57.757]                             next
[18:04:57.757]                           if (!grepl(pattern, name)) 
[18:04:57.757]                             next
[18:04:57.757]                           invokeRestart(restart)
[18:04:57.757]                           muffled <- TRUE
[18:04:57.757]                           break
[18:04:57.757]                         }
[18:04:57.757]                       }
[18:04:57.757]                     }
[18:04:57.757]                     invisible(muffled)
[18:04:57.757]                   }
[18:04:57.757]                   muffleCondition(cond)
[18:04:57.757]                 })
[18:04:57.757]             }))
[18:04:57.757]             future::FutureResult(value = ...future.value$value, 
[18:04:57.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.757]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.757]                     ...future.globalenv.names))
[18:04:57.757]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.757]         }, condition = base::local({
[18:04:57.757]             c <- base::c
[18:04:57.757]             inherits <- base::inherits
[18:04:57.757]             invokeRestart <- base::invokeRestart
[18:04:57.757]             length <- base::length
[18:04:57.757]             list <- base::list
[18:04:57.757]             seq.int <- base::seq.int
[18:04:57.757]             signalCondition <- base::signalCondition
[18:04:57.757]             sys.calls <- base::sys.calls
[18:04:57.757]             `[[` <- base::`[[`
[18:04:57.757]             `+` <- base::`+`
[18:04:57.757]             `<<-` <- base::`<<-`
[18:04:57.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.757]                   3L)]
[18:04:57.757]             }
[18:04:57.757]             function(cond) {
[18:04:57.757]                 is_error <- inherits(cond, "error")
[18:04:57.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.757]                   NULL)
[18:04:57.757]                 if (is_error) {
[18:04:57.757]                   sessionInformation <- function() {
[18:04:57.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.757]                       search = base::search(), system = base::Sys.info())
[18:04:57.757]                   }
[18:04:57.757]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.757]                     cond$call), session = sessionInformation(), 
[18:04:57.757]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.757]                   signalCondition(cond)
[18:04:57.757]                 }
[18:04:57.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.757]                 "immediateCondition"))) {
[18:04:57.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.757]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.757]                   if (TRUE && !signal) {
[18:04:57.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.757]                     {
[18:04:57.757]                       inherits <- base::inherits
[18:04:57.757]                       invokeRestart <- base::invokeRestart
[18:04:57.757]                       is.null <- base::is.null
[18:04:57.757]                       muffled <- FALSE
[18:04:57.757]                       if (inherits(cond, "message")) {
[18:04:57.757]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.757]                         if (muffled) 
[18:04:57.757]                           invokeRestart("muffleMessage")
[18:04:57.757]                       }
[18:04:57.757]                       else if (inherits(cond, "warning")) {
[18:04:57.757]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.757]                         if (muffled) 
[18:04:57.757]                           invokeRestart("muffleWarning")
[18:04:57.757]                       }
[18:04:57.757]                       else if (inherits(cond, "condition")) {
[18:04:57.757]                         if (!is.null(pattern)) {
[18:04:57.757]                           computeRestarts <- base::computeRestarts
[18:04:57.757]                           grepl <- base::grepl
[18:04:57.757]                           restarts <- computeRestarts(cond)
[18:04:57.757]                           for (restart in restarts) {
[18:04:57.757]                             name <- restart$name
[18:04:57.757]                             if (is.null(name)) 
[18:04:57.757]                               next
[18:04:57.757]                             if (!grepl(pattern, name)) 
[18:04:57.757]                               next
[18:04:57.757]                             invokeRestart(restart)
[18:04:57.757]                             muffled <- TRUE
[18:04:57.757]                             break
[18:04:57.757]                           }
[18:04:57.757]                         }
[18:04:57.757]                       }
[18:04:57.757]                       invisible(muffled)
[18:04:57.757]                     }
[18:04:57.757]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.757]                   }
[18:04:57.757]                 }
[18:04:57.757]                 else {
[18:04:57.757]                   if (TRUE) {
[18:04:57.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.757]                     {
[18:04:57.757]                       inherits <- base::inherits
[18:04:57.757]                       invokeRestart <- base::invokeRestart
[18:04:57.757]                       is.null <- base::is.null
[18:04:57.757]                       muffled <- FALSE
[18:04:57.757]                       if (inherits(cond, "message")) {
[18:04:57.757]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.757]                         if (muffled) 
[18:04:57.757]                           invokeRestart("muffleMessage")
[18:04:57.757]                       }
[18:04:57.757]                       else if (inherits(cond, "warning")) {
[18:04:57.757]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.757]                         if (muffled) 
[18:04:57.757]                           invokeRestart("muffleWarning")
[18:04:57.757]                       }
[18:04:57.757]                       else if (inherits(cond, "condition")) {
[18:04:57.757]                         if (!is.null(pattern)) {
[18:04:57.757]                           computeRestarts <- base::computeRestarts
[18:04:57.757]                           grepl <- base::grepl
[18:04:57.757]                           restarts <- computeRestarts(cond)
[18:04:57.757]                           for (restart in restarts) {
[18:04:57.757]                             name <- restart$name
[18:04:57.757]                             if (is.null(name)) 
[18:04:57.757]                               next
[18:04:57.757]                             if (!grepl(pattern, name)) 
[18:04:57.757]                               next
[18:04:57.757]                             invokeRestart(restart)
[18:04:57.757]                             muffled <- TRUE
[18:04:57.757]                             break
[18:04:57.757]                           }
[18:04:57.757]                         }
[18:04:57.757]                       }
[18:04:57.757]                       invisible(muffled)
[18:04:57.757]                     }
[18:04:57.757]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.757]                   }
[18:04:57.757]                 }
[18:04:57.757]             }
[18:04:57.757]         }))
[18:04:57.757]     }, error = function(ex) {
[18:04:57.757]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.757]                 ...future.rng), started = ...future.startTime, 
[18:04:57.757]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.757]             version = "1.8"), class = "FutureResult")
[18:04:57.757]     }, finally = {
[18:04:57.757]         if (!identical(...future.workdir, getwd())) 
[18:04:57.757]             setwd(...future.workdir)
[18:04:57.757]         {
[18:04:57.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.757]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.757]             }
[18:04:57.757]             base::options(...future.oldOptions)
[18:04:57.757]             if (.Platform$OS.type == "windows") {
[18:04:57.757]                 old_names <- names(...future.oldEnvVars)
[18:04:57.757]                 envs <- base::Sys.getenv()
[18:04:57.757]                 names <- names(envs)
[18:04:57.757]                 common <- intersect(names, old_names)
[18:04:57.757]                 added <- setdiff(names, old_names)
[18:04:57.757]                 removed <- setdiff(old_names, names)
[18:04:57.757]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.757]                   envs[common]]
[18:04:57.757]                 NAMES <- toupper(changed)
[18:04:57.757]                 args <- list()
[18:04:57.757]                 for (kk in seq_along(NAMES)) {
[18:04:57.757]                   name <- changed[[kk]]
[18:04:57.757]                   NAME <- NAMES[[kk]]
[18:04:57.757]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.757]                     next
[18:04:57.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.757]                 }
[18:04:57.757]                 NAMES <- toupper(added)
[18:04:57.757]                 for (kk in seq_along(NAMES)) {
[18:04:57.757]                   name <- added[[kk]]
[18:04:57.757]                   NAME <- NAMES[[kk]]
[18:04:57.757]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.757]                     next
[18:04:57.757]                   args[[name]] <- ""
[18:04:57.757]                 }
[18:04:57.757]                 NAMES <- toupper(removed)
[18:04:57.757]                 for (kk in seq_along(NAMES)) {
[18:04:57.757]                   name <- removed[[kk]]
[18:04:57.757]                   NAME <- NAMES[[kk]]
[18:04:57.757]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.757]                     next
[18:04:57.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.757]                 }
[18:04:57.757]                 if (length(args) > 0) 
[18:04:57.757]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.757]             }
[18:04:57.757]             else {
[18:04:57.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.757]             }
[18:04:57.757]             {
[18:04:57.757]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.757]                   0L) {
[18:04:57.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.757]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.757]                   base::options(opts)
[18:04:57.757]                 }
[18:04:57.757]                 {
[18:04:57.757]                   {
[18:04:57.757]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.757]                     NULL
[18:04:57.757]                   }
[18:04:57.757]                   options(future.plan = NULL)
[18:04:57.757]                   if (is.na(NA_character_)) 
[18:04:57.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.757]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.757]                     .init = FALSE)
[18:04:57.757]                 }
[18:04:57.757]             }
[18:04:57.757]         }
[18:04:57.757]     })
[18:04:57.757]     if (TRUE) {
[18:04:57.757]         base::sink(type = "output", split = FALSE)
[18:04:57.757]         if (TRUE) {
[18:04:57.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.757]         }
[18:04:57.757]         else {
[18:04:57.757]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.757]         }
[18:04:57.757]         base::close(...future.stdout)
[18:04:57.757]         ...future.stdout <- NULL
[18:04:57.757]     }
[18:04:57.757]     ...future.result$conditions <- ...future.conditions
[18:04:57.757]     ...future.result$finished <- base::Sys.time()
[18:04:57.757]     ...future.result
[18:04:57.757] }
[18:04:57.762] assign_globals() ...
[18:04:57.762] List of 2
[18:04:57.762]  $ a : num 1
[18:04:57.762]  $ ii: int 2
[18:04:57.762]  - attr(*, "where")=List of 2
[18:04:57.762]   ..$ a :<environment: R_EmptyEnv> 
[18:04:57.762]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:57.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.762]  - attr(*, "resolved")= logi TRUE
[18:04:57.762]  - attr(*, "total_size")= num 112
[18:04:57.762]  - attr(*, "already-done")= logi TRUE
[18:04:57.772] - copied ‘a’ to environment
[18:04:57.772] - copied ‘ii’ to environment
[18:04:57.772] assign_globals() ... done
[18:04:57.773] requestCore(): workers = 2
[18:04:57.776] MulticoreFuture started
[18:04:57.777] - Launch lazy future ... done
[18:04:57.778] run() for ‘MulticoreFuture’ ... done
[18:04:57.778] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.780] getGlobalsAndPackages() ...
[18:04:57.779] List of future strategies:
[18:04:57.779] 1. sequential:
[18:04:57.779]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.779]    - tweaked: FALSE
[18:04:57.779]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.781] Searching for globals...
[18:04:57.781] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:57.785] plan(): Setting new future strategy stack:
[18:04:57.785] List of future strategies:
[18:04:57.785] 1. multicore:
[18:04:57.785]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.785]    - tweaked: FALSE
[18:04:57.785]    - call: plan(strategy)
[18:04:57.789] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.789] Searching for globals ... DONE
[18:04:57.790] Resolving globals: TRUE
[18:04:57.790] Resolving any globals that are futures ...
[18:04:57.790] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.791] Resolving any globals that are futures ... DONE
[18:04:57.792] Resolving futures part of globals (recursively) ...
[18:04:57.793] resolve() on list ...
[18:04:57.794]  recursive: 99
[18:04:57.794]  length: 2
[18:04:57.794] plan(): nbrOfWorkers() = 2
[18:04:57.794]  elements: ‘a’, ‘ii’
[18:04:57.795]  length: 1 (resolved future 1)
[18:04:57.795]  length: 0 (resolved future 2)
[18:04:57.795] resolve() on list ... DONE
[18:04:57.796] - globals: [2] ‘a’, ‘ii’
[18:04:57.796] Resolving futures part of globals (recursively) ... DONE
[18:04:57.797] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:57.798] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:57.798] - globals: [2] ‘a’, ‘ii’
[18:04:57.799] 
[18:04:57.799] getGlobalsAndPackages() ... DONE
[18:04:57.805] run() for ‘Future’ ...
[18:04:57.806] - state: ‘created’
[18:04:57.807] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.818] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.818] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.818]   - Field: ‘label’
[18:04:57.819]   - Field: ‘local’
[18:04:57.819]   - Field: ‘owner’
[18:04:57.819]   - Field: ‘envir’
[18:04:57.820]   - Field: ‘workers’
[18:04:57.820]   - Field: ‘packages’
[18:04:57.821]   - Field: ‘gc’
[18:04:57.821]   - Field: ‘job’
[18:04:57.821]   - Field: ‘conditions’
[18:04:57.822]   - Field: ‘expr’
[18:04:57.822]   - Field: ‘uuid’
[18:04:57.822]   - Field: ‘seed’
[18:04:57.823]   - Field: ‘version’
[18:04:57.823]   - Field: ‘result’
[18:04:57.823]   - Field: ‘asynchronous’
[18:04:57.824]   - Field: ‘calls’
[18:04:57.824]   - Field: ‘globals’
[18:04:57.824]   - Field: ‘stdout’
[18:04:57.825]   - Field: ‘earlySignal’
[18:04:57.825]   - Field: ‘lazy’
[18:04:57.825]   - Field: ‘state’
[18:04:57.826] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.826] - Launch lazy future ...
[18:04:57.827] Packages needed by the future expression (n = 0): <none>
[18:04:57.827] Packages needed by future strategies (n = 0): <none>
[18:04:57.829] {
[18:04:57.829]     {
[18:04:57.829]         {
[18:04:57.829]             ...future.startTime <- base::Sys.time()
[18:04:57.829]             {
[18:04:57.829]                 {
[18:04:57.829]                   {
[18:04:57.829]                     {
[18:04:57.829]                       base::local({
[18:04:57.829]                         has_future <- base::requireNamespace("future", 
[18:04:57.829]                           quietly = TRUE)
[18:04:57.829]                         if (has_future) {
[18:04:57.829]                           ns <- base::getNamespace("future")
[18:04:57.829]                           version <- ns[[".package"]][["version"]]
[18:04:57.829]                           if (is.null(version)) 
[18:04:57.829]                             version <- utils::packageVersion("future")
[18:04:57.829]                         }
[18:04:57.829]                         else {
[18:04:57.829]                           version <- NULL
[18:04:57.829]                         }
[18:04:57.829]                         if (!has_future || version < "1.8.0") {
[18:04:57.829]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.829]                             "", base::R.version$version.string), 
[18:04:57.829]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:57.829]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:57.829]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.829]                               "release", "version")], collapse = " "), 
[18:04:57.829]                             hostname = base::Sys.info()[["nodename"]])
[18:04:57.829]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.829]                             info)
[18:04:57.829]                           info <- base::paste(info, collapse = "; ")
[18:04:57.829]                           if (!has_future) {
[18:04:57.829]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.829]                               info)
[18:04:57.829]                           }
[18:04:57.829]                           else {
[18:04:57.829]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.829]                               info, version)
[18:04:57.829]                           }
[18:04:57.829]                           base::stop(msg)
[18:04:57.829]                         }
[18:04:57.829]                       })
[18:04:57.829]                     }
[18:04:57.829]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.829]                     base::options(mc.cores = 1L)
[18:04:57.829]                   }
[18:04:57.829]                   ...future.strategy.old <- future::plan("list")
[18:04:57.829]                   options(future.plan = NULL)
[18:04:57.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.829]                 }
[18:04:57.829]                 ...future.workdir <- getwd()
[18:04:57.829]             }
[18:04:57.829]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.829]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.829]         }
[18:04:57.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.829]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:57.829]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.829]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.829]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.829]             base::names(...future.oldOptions))
[18:04:57.829]     }
[18:04:57.829]     if (FALSE) {
[18:04:57.829]     }
[18:04:57.829]     else {
[18:04:57.829]         if (TRUE) {
[18:04:57.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.829]                 open = "w")
[18:04:57.829]         }
[18:04:57.829]         else {
[18:04:57.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.829]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.829]         }
[18:04:57.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.829]             base::sink(type = "output", split = FALSE)
[18:04:57.829]             base::close(...future.stdout)
[18:04:57.829]         }, add = TRUE)
[18:04:57.829]     }
[18:04:57.829]     ...future.frame <- base::sys.nframe()
[18:04:57.829]     ...future.conditions <- base::list()
[18:04:57.829]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.829]     if (FALSE) {
[18:04:57.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.829]     }
[18:04:57.829]     ...future.result <- base::tryCatch({
[18:04:57.829]         base::withCallingHandlers({
[18:04:57.829]             ...future.value <- base::withVisible(base::local({
[18:04:57.829]                 withCallingHandlers({
[18:04:57.829]                   {
[18:04:57.829]                     b <- a * ii
[18:04:57.829]                     a <- 0
[18:04:57.829]                     b
[18:04:57.829]                   }
[18:04:57.829]                 }, immediateCondition = function(cond) {
[18:04:57.829]                   save_rds <- function (object, pathname, ...) 
[18:04:57.829]                   {
[18:04:57.829]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.829]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.829]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.829]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.829]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.829]                         fi_tmp[["mtime"]])
[18:04:57.829]                     }
[18:04:57.829]                     tryCatch({
[18:04:57.829]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.829]                     }, error = function(ex) {
[18:04:57.829]                       msg <- conditionMessage(ex)
[18:04:57.829]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.829]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.829]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.829]                         fi_tmp[["mtime"]], msg)
[18:04:57.829]                       ex$message <- msg
[18:04:57.829]                       stop(ex)
[18:04:57.829]                     })
[18:04:57.829]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.829]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.829]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.829]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.829]                       fi <- file.info(pathname)
[18:04:57.829]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.829]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.829]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.829]                         fi[["size"]], fi[["mtime"]])
[18:04:57.829]                       stop(msg)
[18:04:57.829]                     }
[18:04:57.829]                     invisible(pathname)
[18:04:57.829]                   }
[18:04:57.829]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.829]                     rootPath = tempdir()) 
[18:04:57.829]                   {
[18:04:57.829]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.829]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.829]                       tmpdir = path, fileext = ".rds")
[18:04:57.829]                     save_rds(obj, file)
[18:04:57.829]                   }
[18:04:57.829]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.829]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.829]                   {
[18:04:57.829]                     inherits <- base::inherits
[18:04:57.829]                     invokeRestart <- base::invokeRestart
[18:04:57.829]                     is.null <- base::is.null
[18:04:57.829]                     muffled <- FALSE
[18:04:57.829]                     if (inherits(cond, "message")) {
[18:04:57.829]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.829]                       if (muffled) 
[18:04:57.829]                         invokeRestart("muffleMessage")
[18:04:57.829]                     }
[18:04:57.829]                     else if (inherits(cond, "warning")) {
[18:04:57.829]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.829]                       if (muffled) 
[18:04:57.829]                         invokeRestart("muffleWarning")
[18:04:57.829]                     }
[18:04:57.829]                     else if (inherits(cond, "condition")) {
[18:04:57.829]                       if (!is.null(pattern)) {
[18:04:57.829]                         computeRestarts <- base::computeRestarts
[18:04:57.829]                         grepl <- base::grepl
[18:04:57.829]                         restarts <- computeRestarts(cond)
[18:04:57.829]                         for (restart in restarts) {
[18:04:57.829]                           name <- restart$name
[18:04:57.829]                           if (is.null(name)) 
[18:04:57.829]                             next
[18:04:57.829]                           if (!grepl(pattern, name)) 
[18:04:57.829]                             next
[18:04:57.829]                           invokeRestart(restart)
[18:04:57.829]                           muffled <- TRUE
[18:04:57.829]                           break
[18:04:57.829]                         }
[18:04:57.829]                       }
[18:04:57.829]                     }
[18:04:57.829]                     invisible(muffled)
[18:04:57.829]                   }
[18:04:57.829]                   muffleCondition(cond)
[18:04:57.829]                 })
[18:04:57.829]             }))
[18:04:57.829]             future::FutureResult(value = ...future.value$value, 
[18:04:57.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.829]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.829]                     ...future.globalenv.names))
[18:04:57.829]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.829]         }, condition = base::local({
[18:04:57.829]             c <- base::c
[18:04:57.829]             inherits <- base::inherits
[18:04:57.829]             invokeRestart <- base::invokeRestart
[18:04:57.829]             length <- base::length
[18:04:57.829]             list <- base::list
[18:04:57.829]             seq.int <- base::seq.int
[18:04:57.829]             signalCondition <- base::signalCondition
[18:04:57.829]             sys.calls <- base::sys.calls
[18:04:57.829]             `[[` <- base::`[[`
[18:04:57.829]             `+` <- base::`+`
[18:04:57.829]             `<<-` <- base::`<<-`
[18:04:57.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.829]                   3L)]
[18:04:57.829]             }
[18:04:57.829]             function(cond) {
[18:04:57.829]                 is_error <- inherits(cond, "error")
[18:04:57.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.829]                   NULL)
[18:04:57.829]                 if (is_error) {
[18:04:57.829]                   sessionInformation <- function() {
[18:04:57.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.829]                       search = base::search(), system = base::Sys.info())
[18:04:57.829]                   }
[18:04:57.829]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.829]                     cond$call), session = sessionInformation(), 
[18:04:57.829]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.829]                   signalCondition(cond)
[18:04:57.829]                 }
[18:04:57.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.829]                 "immediateCondition"))) {
[18:04:57.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.829]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.829]                   if (TRUE && !signal) {
[18:04:57.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.829]                     {
[18:04:57.829]                       inherits <- base::inherits
[18:04:57.829]                       invokeRestart <- base::invokeRestart
[18:04:57.829]                       is.null <- base::is.null
[18:04:57.829]                       muffled <- FALSE
[18:04:57.829]                       if (inherits(cond, "message")) {
[18:04:57.829]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.829]                         if (muffled) 
[18:04:57.829]                           invokeRestart("muffleMessage")
[18:04:57.829]                       }
[18:04:57.829]                       else if (inherits(cond, "warning")) {
[18:04:57.829]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.829]                         if (muffled) 
[18:04:57.829]                           invokeRestart("muffleWarning")
[18:04:57.829]                       }
[18:04:57.829]                       else if (inherits(cond, "condition")) {
[18:04:57.829]                         if (!is.null(pattern)) {
[18:04:57.829]                           computeRestarts <- base::computeRestarts
[18:04:57.829]                           grepl <- base::grepl
[18:04:57.829]                           restarts <- computeRestarts(cond)
[18:04:57.829]                           for (restart in restarts) {
[18:04:57.829]                             name <- restart$name
[18:04:57.829]                             if (is.null(name)) 
[18:04:57.829]                               next
[18:04:57.829]                             if (!grepl(pattern, name)) 
[18:04:57.829]                               next
[18:04:57.829]                             invokeRestart(restart)
[18:04:57.829]                             muffled <- TRUE
[18:04:57.829]                             break
[18:04:57.829]                           }
[18:04:57.829]                         }
[18:04:57.829]                       }
[18:04:57.829]                       invisible(muffled)
[18:04:57.829]                     }
[18:04:57.829]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.829]                   }
[18:04:57.829]                 }
[18:04:57.829]                 else {
[18:04:57.829]                   if (TRUE) {
[18:04:57.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.829]                     {
[18:04:57.829]                       inherits <- base::inherits
[18:04:57.829]                       invokeRestart <- base::invokeRestart
[18:04:57.829]                       is.null <- base::is.null
[18:04:57.829]                       muffled <- FALSE
[18:04:57.829]                       if (inherits(cond, "message")) {
[18:04:57.829]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.829]                         if (muffled) 
[18:04:57.829]                           invokeRestart("muffleMessage")
[18:04:57.829]                       }
[18:04:57.829]                       else if (inherits(cond, "warning")) {
[18:04:57.829]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.829]                         if (muffled) 
[18:04:57.829]                           invokeRestart("muffleWarning")
[18:04:57.829]                       }
[18:04:57.829]                       else if (inherits(cond, "condition")) {
[18:04:57.829]                         if (!is.null(pattern)) {
[18:04:57.829]                           computeRestarts <- base::computeRestarts
[18:04:57.829]                           grepl <- base::grepl
[18:04:57.829]                           restarts <- computeRestarts(cond)
[18:04:57.829]                           for (restart in restarts) {
[18:04:57.829]                             name <- restart$name
[18:04:57.829]                             if (is.null(name)) 
[18:04:57.829]                               next
[18:04:57.829]                             if (!grepl(pattern, name)) 
[18:04:57.829]                               next
[18:04:57.829]                             invokeRestart(restart)
[18:04:57.829]                             muffled <- TRUE
[18:04:57.829]                             break
[18:04:57.829]                           }
[18:04:57.829]                         }
[18:04:57.829]                       }
[18:04:57.829]                       invisible(muffled)
[18:04:57.829]                     }
[18:04:57.829]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.829]                   }
[18:04:57.829]                 }
[18:04:57.829]             }
[18:04:57.829]         }))
[18:04:57.829]     }, error = function(ex) {
[18:04:57.829]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.829]                 ...future.rng), started = ...future.startTime, 
[18:04:57.829]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.829]             version = "1.8"), class = "FutureResult")
[18:04:57.829]     }, finally = {
[18:04:57.829]         if (!identical(...future.workdir, getwd())) 
[18:04:57.829]             setwd(...future.workdir)
[18:04:57.829]         {
[18:04:57.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.829]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.829]             }
[18:04:57.829]             base::options(...future.oldOptions)
[18:04:57.829]             if (.Platform$OS.type == "windows") {
[18:04:57.829]                 old_names <- names(...future.oldEnvVars)
[18:04:57.829]                 envs <- base::Sys.getenv()
[18:04:57.829]                 names <- names(envs)
[18:04:57.829]                 common <- intersect(names, old_names)
[18:04:57.829]                 added <- setdiff(names, old_names)
[18:04:57.829]                 removed <- setdiff(old_names, names)
[18:04:57.829]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.829]                   envs[common]]
[18:04:57.829]                 NAMES <- toupper(changed)
[18:04:57.829]                 args <- list()
[18:04:57.829]                 for (kk in seq_along(NAMES)) {
[18:04:57.829]                   name <- changed[[kk]]
[18:04:57.829]                   NAME <- NAMES[[kk]]
[18:04:57.829]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.829]                     next
[18:04:57.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.829]                 }
[18:04:57.829]                 NAMES <- toupper(added)
[18:04:57.829]                 for (kk in seq_along(NAMES)) {
[18:04:57.829]                   name <- added[[kk]]
[18:04:57.829]                   NAME <- NAMES[[kk]]
[18:04:57.829]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.829]                     next
[18:04:57.829]                   args[[name]] <- ""
[18:04:57.829]                 }
[18:04:57.829]                 NAMES <- toupper(removed)
[18:04:57.829]                 for (kk in seq_along(NAMES)) {
[18:04:57.829]                   name <- removed[[kk]]
[18:04:57.829]                   NAME <- NAMES[[kk]]
[18:04:57.829]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.829]                     next
[18:04:57.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.829]                 }
[18:04:57.829]                 if (length(args) > 0) 
[18:04:57.829]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.829]             }
[18:04:57.829]             else {
[18:04:57.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.829]             }
[18:04:57.829]             {
[18:04:57.829]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.829]                   0L) {
[18:04:57.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.829]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.829]                   base::options(opts)
[18:04:57.829]                 }
[18:04:57.829]                 {
[18:04:57.829]                   {
[18:04:57.829]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.829]                     NULL
[18:04:57.829]                   }
[18:04:57.829]                   options(future.plan = NULL)
[18:04:57.829]                   if (is.na(NA_character_)) 
[18:04:57.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.829]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.829]                     .init = FALSE)
[18:04:57.829]                 }
[18:04:57.829]             }
[18:04:57.829]         }
[18:04:57.829]     })
[18:04:57.829]     if (TRUE) {
[18:04:57.829]         base::sink(type = "output", split = FALSE)
[18:04:57.829]         if (TRUE) {
[18:04:57.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.829]         }
[18:04:57.829]         else {
[18:04:57.829]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.829]         }
[18:04:57.829]         base::close(...future.stdout)
[18:04:57.829]         ...future.stdout <- NULL
[18:04:57.829]     }
[18:04:57.829]     ...future.result$conditions <- ...future.conditions
[18:04:57.829]     ...future.result$finished <- base::Sys.time()
[18:04:57.829]     ...future.result
[18:04:57.829] }
[18:04:57.834] assign_globals() ...
[18:04:57.834] List of 2
[18:04:57.834]  $ a : num 1
[18:04:57.834]  $ ii: int 3
[18:04:57.834]  - attr(*, "where")=List of 2
[18:04:57.834]   ..$ a :<environment: R_EmptyEnv> 
[18:04:57.834]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:57.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.834]  - attr(*, "resolved")= logi TRUE
[18:04:57.834]  - attr(*, "total_size")= num 112
[18:04:57.834]  - attr(*, "already-done")= logi TRUE
[18:04:57.843] - copied ‘a’ to environment
[18:04:57.843] - copied ‘ii’ to environment
[18:04:57.843] assign_globals() ... done
[18:04:57.844] requestCore(): workers = 2
[18:04:57.844] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:57.886] result() for MulticoreFuture ...
[18:04:57.888] result() for MulticoreFuture ...
[18:04:57.888] result() for MulticoreFuture ... done
[18:04:57.888] result() for MulticoreFuture ... done
[18:04:57.888] result() for MulticoreFuture ...
[18:04:57.889] result() for MulticoreFuture ... done
[18:04:57.893] MulticoreFuture started
[18:04:57.894] - Launch lazy future ... done
[18:04:57.894] run() for ‘MulticoreFuture’ ... done
[18:04:57.895] plan(): Setting new future strategy stack:
[18:04:57.896] result() for MulticoreFuture ...
[18:04:57.896] result() for MulticoreFuture ... done
[18:04:57.897] result() for MulticoreFuture ...
[18:04:57.895] List of future strategies:
[18:04:57.895] 1. sequential:
[18:04:57.895]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:57.895]    - tweaked: FALSE
[18:04:57.895]    - call: NULL
[18:04:57.897] result() for MulticoreFuture ... done
[18:04:57.897] plan(): nbrOfWorkers() = 1
[18:04:57.898] result() for MulticoreFuture ...
[18:04:57.900] result() for MulticoreFuture ...
[18:04:57.901] result() for MulticoreFuture ... done
[18:04:57.901] result() for MulticoreFuture ... done
[18:04:57.902] result() for MulticoreFuture ...
[18:04:57.903] result() for MulticoreFuture ... done
[18:04:57.904] plan(): Setting new future strategy stack:
[18:04:57.904] result() for MulticoreFuture ...
[18:04:57.904] List of future strategies:
[18:04:57.904] 1. multicore:
[18:04:57.904]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:57.904]    - tweaked: FALSE
[18:04:57.904]    - call: plan(strategy)
[18:04:57.916] plan(): nbrOfWorkers() = 2
[18:04:57.917] result() for MulticoreFuture ...
[18:04:57.918] result() for MulticoreFuture ... done
[18:04:57.918] result() for MulticoreFuture ... done
[18:04:57.919] result() for MulticoreFuture ...
[18:04:57.920] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.922] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.922] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:57.928] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.928] Searching for globals ... DONE
[18:04:57.928] Resolving globals: TRUE
[18:04:57.929] Resolving any globals that are futures ...
[18:04:57.929] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.929] Resolving any globals that are futures ... DONE
[18:04:57.930] Resolving futures part of globals (recursively) ...
[18:04:57.931] resolve() on list ...
[18:04:57.931]  recursive: 99
[18:04:57.931]  length: 2
[18:04:57.931]  elements: ‘a’, ‘ii’
[18:04:57.932]  length: 1 (resolved future 1)
[18:04:57.932]  length: 0 (resolved future 2)
[18:04:57.932] resolve() on list ... DONE
[18:04:57.932] - globals: [2] ‘a’, ‘ii’
[18:04:57.933] Resolving futures part of globals (recursively) ... DONE
[18:04:57.933] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:57.934] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:57.934] - globals: [2] ‘a’, ‘ii’
[18:04:57.935] 
[18:04:57.935] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.936] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.937] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:57.941] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.941] Searching for globals ... DONE
[18:04:57.942] Resolving globals: TRUE
[18:04:57.942] Resolving any globals that are futures ...
[18:04:57.942] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.942] Resolving any globals that are futures ... DONE
[18:04:57.943] Resolving futures part of globals (recursively) ...
[18:04:57.944] resolve() on list ...
[18:04:57.944]  recursive: 99
[18:04:57.944]  length: 2
[18:04:57.944]  elements: ‘a’, ‘ii’
[18:04:57.945]  length: 1 (resolved future 1)
[18:04:57.945]  length: 0 (resolved future 2)
[18:04:57.945] resolve() on list ... DONE
[18:04:57.945] - globals: [2] ‘a’, ‘ii’
[18:04:57.946] Resolving futures part of globals (recursively) ... DONE
[18:04:57.946] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:57.947] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:57.947] - globals: [2] ‘a’, ‘ii’
[18:04:57.947] 
[18:04:57.948] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:57.949] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:57.949] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:57.954] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.954] Searching for globals ... DONE
[18:04:57.954] Resolving globals: TRUE
[18:04:57.954] Resolving any globals that are futures ...
[18:04:57.955] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:04:57.955] Resolving any globals that are futures ... DONE
[18:04:57.956] Resolving futures part of globals (recursively) ...
[18:04:57.956] resolve() on list ...
[18:04:57.956]  recursive: 99
[18:04:57.957]  length: 2
[18:04:57.957]  elements: ‘a’, ‘ii’
[18:04:57.957]  length: 1 (resolved future 1)
[18:04:57.957]  length: 0 (resolved future 2)
[18:04:57.958] resolve() on list ... DONE
[18:04:57.958] - globals: [2] ‘a’, ‘ii’
[18:04:57.958] Resolving futures part of globals (recursively) ... DONE
[18:04:57.958] The total size of the 2 globals is 112 bytes (112 bytes)
[18:04:57.959] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:04:57.959] - globals: [2] ‘a’, ‘ii’
[18:04:57.960] 
[18:04:57.960] getGlobalsAndPackages() ... DONE
[18:04:57.961] run() for ‘Future’ ...
[18:04:57.961] - state: ‘created’
[18:04:57.961] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:57.972] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:57.972] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:57.972]   - Field: ‘label’
[18:04:57.973]   - Field: ‘local’
[18:04:57.973]   - Field: ‘owner’
[18:04:57.973]   - Field: ‘envir’
[18:04:57.973]   - Field: ‘workers’
[18:04:57.974]   - Field: ‘packages’
[18:04:57.974]   - Field: ‘gc’
[18:04:57.974]   - Field: ‘job’
[18:04:57.974]   - Field: ‘conditions’
[18:04:57.974]   - Field: ‘expr’
[18:04:57.975]   - Field: ‘uuid’
[18:04:57.975]   - Field: ‘seed’
[18:04:57.975]   - Field: ‘version’
[18:04:57.975]   - Field: ‘result’
[18:04:57.976]   - Field: ‘asynchronous’
[18:04:57.976]   - Field: ‘calls’
[18:04:57.976]   - Field: ‘globals’
[18:04:57.976]   - Field: ‘stdout’
[18:04:57.976]   - Field: ‘earlySignal’
[18:04:57.977]   - Field: ‘lazy’
[18:04:57.977]   - Field: ‘state’
[18:04:57.977] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:57.977] - Launch lazy future ...
[18:04:57.978] Packages needed by the future expression (n = 0): <none>
[18:04:57.978] Packages needed by future strategies (n = 0): <none>
[18:04:57.979] {
[18:04:57.979]     {
[18:04:57.979]         {
[18:04:57.979]             ...future.startTime <- base::Sys.time()
[18:04:57.979]             {
[18:04:57.979]                 {
[18:04:57.979]                   {
[18:04:57.979]                     {
[18:04:57.979]                       base::local({
[18:04:57.979]                         has_future <- base::requireNamespace("future", 
[18:04:57.979]                           quietly = TRUE)
[18:04:57.979]                         if (has_future) {
[18:04:57.979]                           ns <- base::getNamespace("future")
[18:04:57.979]                           version <- ns[[".package"]][["version"]]
[18:04:57.979]                           if (is.null(version)) 
[18:04:57.979]                             version <- utils::packageVersion("future")
[18:04:57.979]                         }
[18:04:57.979]                         else {
[18:04:57.979]                           version <- NULL
[18:04:57.979]                         }
[18:04:57.979]                         if (!has_future || version < "1.8.0") {
[18:04:57.979]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:57.979]                             "", base::R.version$version.string), 
[18:04:57.979]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:57.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:57.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:57.979]                               "release", "version")], collapse = " "), 
[18:04:57.979]                             hostname = base::Sys.info()[["nodename"]])
[18:04:57.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:57.979]                             info)
[18:04:57.979]                           info <- base::paste(info, collapse = "; ")
[18:04:57.979]                           if (!has_future) {
[18:04:57.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:57.979]                               info)
[18:04:57.979]                           }
[18:04:57.979]                           else {
[18:04:57.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:57.979]                               info, version)
[18:04:57.979]                           }
[18:04:57.979]                           base::stop(msg)
[18:04:57.979]                         }
[18:04:57.979]                       })
[18:04:57.979]                     }
[18:04:57.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:57.979]                     base::options(mc.cores = 1L)
[18:04:57.979]                   }
[18:04:57.979]                   ...future.strategy.old <- future::plan("list")
[18:04:57.979]                   options(future.plan = NULL)
[18:04:57.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:57.979]                 }
[18:04:57.979]                 ...future.workdir <- getwd()
[18:04:57.979]             }
[18:04:57.979]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:57.979]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:57.979]         }
[18:04:57.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:57.979]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:57.979]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:57.979]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:57.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:57.979]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:57.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:57.979]             base::names(...future.oldOptions))
[18:04:57.979]     }
[18:04:57.979]     if (FALSE) {
[18:04:57.979]     }
[18:04:57.979]     else {
[18:04:57.979]         if (TRUE) {
[18:04:57.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:57.979]                 open = "w")
[18:04:57.979]         }
[18:04:57.979]         else {
[18:04:57.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:57.979]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:57.979]         }
[18:04:57.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:57.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:57.979]             base::sink(type = "output", split = FALSE)
[18:04:57.979]             base::close(...future.stdout)
[18:04:57.979]         }, add = TRUE)
[18:04:57.979]     }
[18:04:57.979]     ...future.frame <- base::sys.nframe()
[18:04:57.979]     ...future.conditions <- base::list()
[18:04:57.979]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:57.979]     if (FALSE) {
[18:04:57.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:57.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:57.979]     }
[18:04:57.979]     ...future.result <- base::tryCatch({
[18:04:57.979]         base::withCallingHandlers({
[18:04:57.979]             ...future.value <- base::withVisible(base::local({
[18:04:57.979]                 withCallingHandlers({
[18:04:57.979]                   {
[18:04:57.979]                     b <- a * ii
[18:04:57.979]                     a <- 0
[18:04:57.979]                     b
[18:04:57.979]                   }
[18:04:57.979]                 }, immediateCondition = function(cond) {
[18:04:57.979]                   save_rds <- function (object, pathname, ...) 
[18:04:57.979]                   {
[18:04:57.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:57.979]                     if (file_test("-f", pathname_tmp)) {
[18:04:57.979]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:57.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.979]                         fi_tmp[["mtime"]])
[18:04:57.979]                     }
[18:04:57.979]                     tryCatch({
[18:04:57.979]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:57.979]                     }, error = function(ex) {
[18:04:57.979]                       msg <- conditionMessage(ex)
[18:04:57.979]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:57.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.979]                         fi_tmp[["mtime"]], msg)
[18:04:57.979]                       ex$message <- msg
[18:04:57.979]                       stop(ex)
[18:04:57.979]                     })
[18:04:57.979]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:57.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:57.979]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:57.979]                       fi_tmp <- file.info(pathname_tmp)
[18:04:57.979]                       fi <- file.info(pathname)
[18:04:57.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:57.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:57.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:57.979]                         fi[["size"]], fi[["mtime"]])
[18:04:57.979]                       stop(msg)
[18:04:57.979]                     }
[18:04:57.979]                     invisible(pathname)
[18:04:57.979]                   }
[18:04:57.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:57.979]                     rootPath = tempdir()) 
[18:04:57.979]                   {
[18:04:57.979]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:57.979]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:57.979]                       tmpdir = path, fileext = ".rds")
[18:04:57.979]                     save_rds(obj, file)
[18:04:57.979]                   }
[18:04:57.979]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:57.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.979]                   {
[18:04:57.979]                     inherits <- base::inherits
[18:04:57.979]                     invokeRestart <- base::invokeRestart
[18:04:57.979]                     is.null <- base::is.null
[18:04:57.979]                     muffled <- FALSE
[18:04:57.979]                     if (inherits(cond, "message")) {
[18:04:57.979]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:57.979]                       if (muffled) 
[18:04:57.979]                         invokeRestart("muffleMessage")
[18:04:57.979]                     }
[18:04:57.979]                     else if (inherits(cond, "warning")) {
[18:04:57.979]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:57.979]                       if (muffled) 
[18:04:57.979]                         invokeRestart("muffleWarning")
[18:04:57.979]                     }
[18:04:57.979]                     else if (inherits(cond, "condition")) {
[18:04:57.979]                       if (!is.null(pattern)) {
[18:04:57.979]                         computeRestarts <- base::computeRestarts
[18:04:57.979]                         grepl <- base::grepl
[18:04:57.979]                         restarts <- computeRestarts(cond)
[18:04:57.979]                         for (restart in restarts) {
[18:04:57.979]                           name <- restart$name
[18:04:57.979]                           if (is.null(name)) 
[18:04:57.979]                             next
[18:04:57.979]                           if (!grepl(pattern, name)) 
[18:04:57.979]                             next
[18:04:57.979]                           invokeRestart(restart)
[18:04:57.979]                           muffled <- TRUE
[18:04:57.979]                           break
[18:04:57.979]                         }
[18:04:57.979]                       }
[18:04:57.979]                     }
[18:04:57.979]                     invisible(muffled)
[18:04:57.979]                   }
[18:04:57.979]                   muffleCondition(cond)
[18:04:57.979]                 })
[18:04:57.979]             }))
[18:04:57.979]             future::FutureResult(value = ...future.value$value, 
[18:04:57.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.979]                   ...future.rng), globalenv = if (FALSE) 
[18:04:57.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:57.979]                     ...future.globalenv.names))
[18:04:57.979]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:57.979]         }, condition = base::local({
[18:04:57.979]             c <- base::c
[18:04:57.979]             inherits <- base::inherits
[18:04:57.979]             invokeRestart <- base::invokeRestart
[18:04:57.979]             length <- base::length
[18:04:57.979]             list <- base::list
[18:04:57.979]             seq.int <- base::seq.int
[18:04:57.979]             signalCondition <- base::signalCondition
[18:04:57.979]             sys.calls <- base::sys.calls
[18:04:57.979]             `[[` <- base::`[[`
[18:04:57.979]             `+` <- base::`+`
[18:04:57.979]             `<<-` <- base::`<<-`
[18:04:57.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:57.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:57.979]                   3L)]
[18:04:57.979]             }
[18:04:57.979]             function(cond) {
[18:04:57.979]                 is_error <- inherits(cond, "error")
[18:04:57.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:57.979]                   NULL)
[18:04:57.979]                 if (is_error) {
[18:04:57.979]                   sessionInformation <- function() {
[18:04:57.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:57.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:57.979]                       search = base::search(), system = base::Sys.info())
[18:04:57.979]                   }
[18:04:57.979]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:57.979]                     cond$call), session = sessionInformation(), 
[18:04:57.979]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:57.979]                   signalCondition(cond)
[18:04:57.979]                 }
[18:04:57.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:57.979]                 "immediateCondition"))) {
[18:04:57.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:57.979]                   ...future.conditions[[length(...future.conditions) + 
[18:04:57.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:57.979]                   if (TRUE && !signal) {
[18:04:57.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.979]                     {
[18:04:57.979]                       inherits <- base::inherits
[18:04:57.979]                       invokeRestart <- base::invokeRestart
[18:04:57.979]                       is.null <- base::is.null
[18:04:57.979]                       muffled <- FALSE
[18:04:57.979]                       if (inherits(cond, "message")) {
[18:04:57.979]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.979]                         if (muffled) 
[18:04:57.979]                           invokeRestart("muffleMessage")
[18:04:57.979]                       }
[18:04:57.979]                       else if (inherits(cond, "warning")) {
[18:04:57.979]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.979]                         if (muffled) 
[18:04:57.979]                           invokeRestart("muffleWarning")
[18:04:57.979]                       }
[18:04:57.979]                       else if (inherits(cond, "condition")) {
[18:04:57.979]                         if (!is.null(pattern)) {
[18:04:57.979]                           computeRestarts <- base::computeRestarts
[18:04:57.979]                           grepl <- base::grepl
[18:04:57.979]                           restarts <- computeRestarts(cond)
[18:04:57.979]                           for (restart in restarts) {
[18:04:57.979]                             name <- restart$name
[18:04:57.979]                             if (is.null(name)) 
[18:04:57.979]                               next
[18:04:57.979]                             if (!grepl(pattern, name)) 
[18:04:57.979]                               next
[18:04:57.979]                             invokeRestart(restart)
[18:04:57.979]                             muffled <- TRUE
[18:04:57.979]                             break
[18:04:57.979]                           }
[18:04:57.979]                         }
[18:04:57.979]                       }
[18:04:57.979]                       invisible(muffled)
[18:04:57.979]                     }
[18:04:57.979]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.979]                   }
[18:04:57.979]                 }
[18:04:57.979]                 else {
[18:04:57.979]                   if (TRUE) {
[18:04:57.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:57.979]                     {
[18:04:57.979]                       inherits <- base::inherits
[18:04:57.979]                       invokeRestart <- base::invokeRestart
[18:04:57.979]                       is.null <- base::is.null
[18:04:57.979]                       muffled <- FALSE
[18:04:57.979]                       if (inherits(cond, "message")) {
[18:04:57.979]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:57.979]                         if (muffled) 
[18:04:57.979]                           invokeRestart("muffleMessage")
[18:04:57.979]                       }
[18:04:57.979]                       else if (inherits(cond, "warning")) {
[18:04:57.979]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:57.979]                         if (muffled) 
[18:04:57.979]                           invokeRestart("muffleWarning")
[18:04:57.979]                       }
[18:04:57.979]                       else if (inherits(cond, "condition")) {
[18:04:57.979]                         if (!is.null(pattern)) {
[18:04:57.979]                           computeRestarts <- base::computeRestarts
[18:04:57.979]                           grepl <- base::grepl
[18:04:57.979]                           restarts <- computeRestarts(cond)
[18:04:57.979]                           for (restart in restarts) {
[18:04:57.979]                             name <- restart$name
[18:04:57.979]                             if (is.null(name)) 
[18:04:57.979]                               next
[18:04:57.979]                             if (!grepl(pattern, name)) 
[18:04:57.979]                               next
[18:04:57.979]                             invokeRestart(restart)
[18:04:57.979]                             muffled <- TRUE
[18:04:57.979]                             break
[18:04:57.979]                           }
[18:04:57.979]                         }
[18:04:57.979]                       }
[18:04:57.979]                       invisible(muffled)
[18:04:57.979]                     }
[18:04:57.979]                     muffleCondition(cond, pattern = "^muffle")
[18:04:57.979]                   }
[18:04:57.979]                 }
[18:04:57.979]             }
[18:04:57.979]         }))
[18:04:57.979]     }, error = function(ex) {
[18:04:57.979]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:57.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:57.979]                 ...future.rng), started = ...future.startTime, 
[18:04:57.979]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:57.979]             version = "1.8"), class = "FutureResult")
[18:04:57.979]     }, finally = {
[18:04:57.979]         if (!identical(...future.workdir, getwd())) 
[18:04:57.979]             setwd(...future.workdir)
[18:04:57.979]         {
[18:04:57.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:57.979]                 ...future.oldOptions$nwarnings <- NULL
[18:04:57.979]             }
[18:04:57.979]             base::options(...future.oldOptions)
[18:04:57.979]             if (.Platform$OS.type == "windows") {
[18:04:57.979]                 old_names <- names(...future.oldEnvVars)
[18:04:57.979]                 envs <- base::Sys.getenv()
[18:04:57.979]                 names <- names(envs)
[18:04:57.979]                 common <- intersect(names, old_names)
[18:04:57.979]                 added <- setdiff(names, old_names)
[18:04:57.979]                 removed <- setdiff(old_names, names)
[18:04:57.979]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:57.979]                   envs[common]]
[18:04:57.979]                 NAMES <- toupper(changed)
[18:04:57.979]                 args <- list()
[18:04:57.979]                 for (kk in seq_along(NAMES)) {
[18:04:57.979]                   name <- changed[[kk]]
[18:04:57.979]                   NAME <- NAMES[[kk]]
[18:04:57.979]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.979]                     next
[18:04:57.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.979]                 }
[18:04:57.979]                 NAMES <- toupper(added)
[18:04:57.979]                 for (kk in seq_along(NAMES)) {
[18:04:57.979]                   name <- added[[kk]]
[18:04:57.979]                   NAME <- NAMES[[kk]]
[18:04:57.979]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.979]                     next
[18:04:57.979]                   args[[name]] <- ""
[18:04:57.979]                 }
[18:04:57.979]                 NAMES <- toupper(removed)
[18:04:57.979]                 for (kk in seq_along(NAMES)) {
[18:04:57.979]                   name <- removed[[kk]]
[18:04:57.979]                   NAME <- NAMES[[kk]]
[18:04:57.979]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:57.979]                     next
[18:04:57.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:57.979]                 }
[18:04:57.979]                 if (length(args) > 0) 
[18:04:57.979]                   base::do.call(base::Sys.setenv, args = args)
[18:04:57.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:57.979]             }
[18:04:57.979]             else {
[18:04:57.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:57.979]             }
[18:04:57.979]             {
[18:04:57.979]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:57.979]                   0L) {
[18:04:57.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:57.979]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:57.979]                   base::options(opts)
[18:04:57.979]                 }
[18:04:57.979]                 {
[18:04:57.979]                   {
[18:04:57.979]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:57.979]                     NULL
[18:04:57.979]                   }
[18:04:57.979]                   options(future.plan = NULL)
[18:04:57.979]                   if (is.na(NA_character_)) 
[18:04:57.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:57.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:57.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:57.979]                     .init = FALSE)
[18:04:57.979]                 }
[18:04:57.979]             }
[18:04:57.979]         }
[18:04:57.979]     })
[18:04:57.979]     if (TRUE) {
[18:04:57.979]         base::sink(type = "output", split = FALSE)
[18:04:57.979]         if (TRUE) {
[18:04:57.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:57.979]         }
[18:04:57.979]         else {
[18:04:57.979]             ...future.result["stdout"] <- base::list(NULL)
[18:04:57.979]         }
[18:04:57.979]         base::close(...future.stdout)
[18:04:57.979]         ...future.stdout <- NULL
[18:04:57.979]     }
[18:04:57.979]     ...future.result$conditions <- ...future.conditions
[18:04:57.979]     ...future.result$finished <- base::Sys.time()
[18:04:57.979]     ...future.result
[18:04:57.979] }
[18:04:57.984] assign_globals() ...
[18:04:57.984] List of 2
[18:04:57.984]  $ a : num 1
[18:04:57.984]  $ ii: int 1
[18:04:57.984]  - attr(*, "where")=List of 2
[18:04:57.984]   ..$ a :<environment: R_EmptyEnv> 
[18:04:57.984]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:57.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:57.984]  - attr(*, "resolved")= logi TRUE
[18:04:57.984]  - attr(*, "total_size")= num 112
[18:04:57.984]  - attr(*, "already-done")= logi TRUE
[18:04:57.992] - copied ‘a’ to environment
[18:04:57.992] - copied ‘ii’ to environment
[18:04:57.992] assign_globals() ... done
[18:04:57.993] requestCore(): workers = 2
[18:04:57.996] MulticoreFuture started
[18:04:57.997] - Launch lazy future ... done
[18:04:57.998] run() for ‘MulticoreFuture’ ... done
[18:04:57.999] result() for MulticoreFuture ...
[18:04:58.001] plan(): Setting new future strategy stack:
[18:04:58.002] List of future strategies:
[18:04:58.002] 1. sequential:
[18:04:58.002]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.002]    - tweaked: FALSE
[18:04:58.002]    - call: NULL
[18:04:58.005] plan(): nbrOfWorkers() = 1
[18:04:58.010] plan(): Setting new future strategy stack:
[18:04:58.011] List of future strategies:
[18:04:58.011] 1. multicore:
[18:04:58.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.011]    - tweaked: FALSE
[18:04:58.011]    - call: plan(strategy)
[18:04:58.021] plan(): nbrOfWorkers() = 2
[18:04:58.023] result() for MulticoreFuture ...
[18:04:58.023] result() for MulticoreFuture ... done
[18:04:58.024] result() for MulticoreFuture ... done
[18:04:58.026] result() for MulticoreFuture ...
[18:04:58.027] result() for MulticoreFuture ... done
[18:04:58.027] run() for ‘Future’ ...
[18:04:58.029] - state: ‘created’
[18:04:58.029] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.037] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.038] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.038]   - Field: ‘label’
[18:04:58.038]   - Field: ‘local’
[18:04:58.039]   - Field: ‘owner’
[18:04:58.039]   - Field: ‘envir’
[18:04:58.039]   - Field: ‘workers’
[18:04:58.040]   - Field: ‘packages’
[18:04:58.040]   - Field: ‘gc’
[18:04:58.040]   - Field: ‘job’
[18:04:58.040]   - Field: ‘conditions’
[18:04:58.041]   - Field: ‘expr’
[18:04:58.041]   - Field: ‘uuid’
[18:04:58.041]   - Field: ‘seed’
[18:04:58.041]   - Field: ‘version’
[18:04:58.042]   - Field: ‘result’
[18:04:58.042]   - Field: ‘asynchronous’
[18:04:58.042]   - Field: ‘calls’
[18:04:58.042]   - Field: ‘globals’
[18:04:58.043]   - Field: ‘stdout’
[18:04:58.043]   - Field: ‘earlySignal’
[18:04:58.043]   - Field: ‘lazy’
[18:04:58.043]   - Field: ‘state’
[18:04:58.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.044] - Launch lazy future ...
[18:04:58.045] Packages needed by the future expression (n = 0): <none>
[18:04:58.045] Packages needed by future strategies (n = 0): <none>
[18:04:58.046] {
[18:04:58.046]     {
[18:04:58.046]         {
[18:04:58.046]             ...future.startTime <- base::Sys.time()
[18:04:58.046]             {
[18:04:58.046]                 {
[18:04:58.046]                   {
[18:04:58.046]                     {
[18:04:58.046]                       base::local({
[18:04:58.046]                         has_future <- base::requireNamespace("future", 
[18:04:58.046]                           quietly = TRUE)
[18:04:58.046]                         if (has_future) {
[18:04:58.046]                           ns <- base::getNamespace("future")
[18:04:58.046]                           version <- ns[[".package"]][["version"]]
[18:04:58.046]                           if (is.null(version)) 
[18:04:58.046]                             version <- utils::packageVersion("future")
[18:04:58.046]                         }
[18:04:58.046]                         else {
[18:04:58.046]                           version <- NULL
[18:04:58.046]                         }
[18:04:58.046]                         if (!has_future || version < "1.8.0") {
[18:04:58.046]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.046]                             "", base::R.version$version.string), 
[18:04:58.046]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:58.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:58.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.046]                               "release", "version")], collapse = " "), 
[18:04:58.046]                             hostname = base::Sys.info()[["nodename"]])
[18:04:58.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.046]                             info)
[18:04:58.046]                           info <- base::paste(info, collapse = "; ")
[18:04:58.046]                           if (!has_future) {
[18:04:58.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.046]                               info)
[18:04:58.046]                           }
[18:04:58.046]                           else {
[18:04:58.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.046]                               info, version)
[18:04:58.046]                           }
[18:04:58.046]                           base::stop(msg)
[18:04:58.046]                         }
[18:04:58.046]                       })
[18:04:58.046]                     }
[18:04:58.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.046]                     base::options(mc.cores = 1L)
[18:04:58.046]                   }
[18:04:58.046]                   ...future.strategy.old <- future::plan("list")
[18:04:58.046]                   options(future.plan = NULL)
[18:04:58.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.046]                 }
[18:04:58.046]                 ...future.workdir <- getwd()
[18:04:58.046]             }
[18:04:58.046]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.046]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.046]         }
[18:04:58.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.046]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.046]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.046]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.046]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.046]             base::names(...future.oldOptions))
[18:04:58.046]     }
[18:04:58.046]     if (FALSE) {
[18:04:58.046]     }
[18:04:58.046]     else {
[18:04:58.046]         if (TRUE) {
[18:04:58.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.046]                 open = "w")
[18:04:58.046]         }
[18:04:58.046]         else {
[18:04:58.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.046]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.046]         }
[18:04:58.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.046]             base::sink(type = "output", split = FALSE)
[18:04:58.046]             base::close(...future.stdout)
[18:04:58.046]         }, add = TRUE)
[18:04:58.046]     }
[18:04:58.046]     ...future.frame <- base::sys.nframe()
[18:04:58.046]     ...future.conditions <- base::list()
[18:04:58.046]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.046]     if (FALSE) {
[18:04:58.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.046]     }
[18:04:58.046]     ...future.result <- base::tryCatch({
[18:04:58.046]         base::withCallingHandlers({
[18:04:58.046]             ...future.value <- base::withVisible(base::local({
[18:04:58.046]                 withCallingHandlers({
[18:04:58.046]                   {
[18:04:58.046]                     b <- a * ii
[18:04:58.046]                     a <- 0
[18:04:58.046]                     b
[18:04:58.046]                   }
[18:04:58.046]                 }, immediateCondition = function(cond) {
[18:04:58.046]                   save_rds <- function (object, pathname, ...) 
[18:04:58.046]                   {
[18:04:58.046]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.046]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.046]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.046]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.046]                         fi_tmp[["mtime"]])
[18:04:58.046]                     }
[18:04:58.046]                     tryCatch({
[18:04:58.046]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.046]                     }, error = function(ex) {
[18:04:58.046]                       msg <- conditionMessage(ex)
[18:04:58.046]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.046]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.046]                         fi_tmp[["mtime"]], msg)
[18:04:58.046]                       ex$message <- msg
[18:04:58.046]                       stop(ex)
[18:04:58.046]                     })
[18:04:58.046]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.046]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.046]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.046]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.046]                       fi <- file.info(pathname)
[18:04:58.046]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.046]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.046]                         fi[["size"]], fi[["mtime"]])
[18:04:58.046]                       stop(msg)
[18:04:58.046]                     }
[18:04:58.046]                     invisible(pathname)
[18:04:58.046]                   }
[18:04:58.046]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.046]                     rootPath = tempdir()) 
[18:04:58.046]                   {
[18:04:58.046]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.046]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.046]                       tmpdir = path, fileext = ".rds")
[18:04:58.046]                     save_rds(obj, file)
[18:04:58.046]                   }
[18:04:58.046]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.046]                   {
[18:04:58.046]                     inherits <- base::inherits
[18:04:58.046]                     invokeRestart <- base::invokeRestart
[18:04:58.046]                     is.null <- base::is.null
[18:04:58.046]                     muffled <- FALSE
[18:04:58.046]                     if (inherits(cond, "message")) {
[18:04:58.046]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.046]                       if (muffled) 
[18:04:58.046]                         invokeRestart("muffleMessage")
[18:04:58.046]                     }
[18:04:58.046]                     else if (inherits(cond, "warning")) {
[18:04:58.046]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.046]                       if (muffled) 
[18:04:58.046]                         invokeRestart("muffleWarning")
[18:04:58.046]                     }
[18:04:58.046]                     else if (inherits(cond, "condition")) {
[18:04:58.046]                       if (!is.null(pattern)) {
[18:04:58.046]                         computeRestarts <- base::computeRestarts
[18:04:58.046]                         grepl <- base::grepl
[18:04:58.046]                         restarts <- computeRestarts(cond)
[18:04:58.046]                         for (restart in restarts) {
[18:04:58.046]                           name <- restart$name
[18:04:58.046]                           if (is.null(name)) 
[18:04:58.046]                             next
[18:04:58.046]                           if (!grepl(pattern, name)) 
[18:04:58.046]                             next
[18:04:58.046]                           invokeRestart(restart)
[18:04:58.046]                           muffled <- TRUE
[18:04:58.046]                           break
[18:04:58.046]                         }
[18:04:58.046]                       }
[18:04:58.046]                     }
[18:04:58.046]                     invisible(muffled)
[18:04:58.046]                   }
[18:04:58.046]                   muffleCondition(cond)
[18:04:58.046]                 })
[18:04:58.046]             }))
[18:04:58.046]             future::FutureResult(value = ...future.value$value, 
[18:04:58.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.046]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.046]                     ...future.globalenv.names))
[18:04:58.046]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.046]         }, condition = base::local({
[18:04:58.046]             c <- base::c
[18:04:58.046]             inherits <- base::inherits
[18:04:58.046]             invokeRestart <- base::invokeRestart
[18:04:58.046]             length <- base::length
[18:04:58.046]             list <- base::list
[18:04:58.046]             seq.int <- base::seq.int
[18:04:58.046]             signalCondition <- base::signalCondition
[18:04:58.046]             sys.calls <- base::sys.calls
[18:04:58.046]             `[[` <- base::`[[`
[18:04:58.046]             `+` <- base::`+`
[18:04:58.046]             `<<-` <- base::`<<-`
[18:04:58.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.046]                   3L)]
[18:04:58.046]             }
[18:04:58.046]             function(cond) {
[18:04:58.046]                 is_error <- inherits(cond, "error")
[18:04:58.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.046]                   NULL)
[18:04:58.046]                 if (is_error) {
[18:04:58.046]                   sessionInformation <- function() {
[18:04:58.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.046]                       search = base::search(), system = base::Sys.info())
[18:04:58.046]                   }
[18:04:58.046]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.046]                     cond$call), session = sessionInformation(), 
[18:04:58.046]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.046]                   signalCondition(cond)
[18:04:58.046]                 }
[18:04:58.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.046]                 "immediateCondition"))) {
[18:04:58.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.046]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.046]                   if (TRUE && !signal) {
[18:04:58.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.046]                     {
[18:04:58.046]                       inherits <- base::inherits
[18:04:58.046]                       invokeRestart <- base::invokeRestart
[18:04:58.046]                       is.null <- base::is.null
[18:04:58.046]                       muffled <- FALSE
[18:04:58.046]                       if (inherits(cond, "message")) {
[18:04:58.046]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.046]                         if (muffled) 
[18:04:58.046]                           invokeRestart("muffleMessage")
[18:04:58.046]                       }
[18:04:58.046]                       else if (inherits(cond, "warning")) {
[18:04:58.046]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.046]                         if (muffled) 
[18:04:58.046]                           invokeRestart("muffleWarning")
[18:04:58.046]                       }
[18:04:58.046]                       else if (inherits(cond, "condition")) {
[18:04:58.046]                         if (!is.null(pattern)) {
[18:04:58.046]                           computeRestarts <- base::computeRestarts
[18:04:58.046]                           grepl <- base::grepl
[18:04:58.046]                           restarts <- computeRestarts(cond)
[18:04:58.046]                           for (restart in restarts) {
[18:04:58.046]                             name <- restart$name
[18:04:58.046]                             if (is.null(name)) 
[18:04:58.046]                               next
[18:04:58.046]                             if (!grepl(pattern, name)) 
[18:04:58.046]                               next
[18:04:58.046]                             invokeRestart(restart)
[18:04:58.046]                             muffled <- TRUE
[18:04:58.046]                             break
[18:04:58.046]                           }
[18:04:58.046]                         }
[18:04:58.046]                       }
[18:04:58.046]                       invisible(muffled)
[18:04:58.046]                     }
[18:04:58.046]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.046]                   }
[18:04:58.046]                 }
[18:04:58.046]                 else {
[18:04:58.046]                   if (TRUE) {
[18:04:58.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.046]                     {
[18:04:58.046]                       inherits <- base::inherits
[18:04:58.046]                       invokeRestart <- base::invokeRestart
[18:04:58.046]                       is.null <- base::is.null
[18:04:58.046]                       muffled <- FALSE
[18:04:58.046]                       if (inherits(cond, "message")) {
[18:04:58.046]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.046]                         if (muffled) 
[18:04:58.046]                           invokeRestart("muffleMessage")
[18:04:58.046]                       }
[18:04:58.046]                       else if (inherits(cond, "warning")) {
[18:04:58.046]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.046]                         if (muffled) 
[18:04:58.046]                           invokeRestart("muffleWarning")
[18:04:58.046]                       }
[18:04:58.046]                       else if (inherits(cond, "condition")) {
[18:04:58.046]                         if (!is.null(pattern)) {
[18:04:58.046]                           computeRestarts <- base::computeRestarts
[18:04:58.046]                           grepl <- base::grepl
[18:04:58.046]                           restarts <- computeRestarts(cond)
[18:04:58.046]                           for (restart in restarts) {
[18:04:58.046]                             name <- restart$name
[18:04:58.046]                             if (is.null(name)) 
[18:04:58.046]                               next
[18:04:58.046]                             if (!grepl(pattern, name)) 
[18:04:58.046]                               next
[18:04:58.046]                             invokeRestart(restart)
[18:04:58.046]                             muffled <- TRUE
[18:04:58.046]                             break
[18:04:58.046]                           }
[18:04:58.046]                         }
[18:04:58.046]                       }
[18:04:58.046]                       invisible(muffled)
[18:04:58.046]                     }
[18:04:58.046]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.046]                   }
[18:04:58.046]                 }
[18:04:58.046]             }
[18:04:58.046]         }))
[18:04:58.046]     }, error = function(ex) {
[18:04:58.046]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.046]                 ...future.rng), started = ...future.startTime, 
[18:04:58.046]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.046]             version = "1.8"), class = "FutureResult")
[18:04:58.046]     }, finally = {
[18:04:58.046]         if (!identical(...future.workdir, getwd())) 
[18:04:58.046]             setwd(...future.workdir)
[18:04:58.046]         {
[18:04:58.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.046]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.046]             }
[18:04:58.046]             base::options(...future.oldOptions)
[18:04:58.046]             if (.Platform$OS.type == "windows") {
[18:04:58.046]                 old_names <- names(...future.oldEnvVars)
[18:04:58.046]                 envs <- base::Sys.getenv()
[18:04:58.046]                 names <- names(envs)
[18:04:58.046]                 common <- intersect(names, old_names)
[18:04:58.046]                 added <- setdiff(names, old_names)
[18:04:58.046]                 removed <- setdiff(old_names, names)
[18:04:58.046]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.046]                   envs[common]]
[18:04:58.046]                 NAMES <- toupper(changed)
[18:04:58.046]                 args <- list()
[18:04:58.046]                 for (kk in seq_along(NAMES)) {
[18:04:58.046]                   name <- changed[[kk]]
[18:04:58.046]                   NAME <- NAMES[[kk]]
[18:04:58.046]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.046]                     next
[18:04:58.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.046]                 }
[18:04:58.046]                 NAMES <- toupper(added)
[18:04:58.046]                 for (kk in seq_along(NAMES)) {
[18:04:58.046]                   name <- added[[kk]]
[18:04:58.046]                   NAME <- NAMES[[kk]]
[18:04:58.046]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.046]                     next
[18:04:58.046]                   args[[name]] <- ""
[18:04:58.046]                 }
[18:04:58.046]                 NAMES <- toupper(removed)
[18:04:58.046]                 for (kk in seq_along(NAMES)) {
[18:04:58.046]                   name <- removed[[kk]]
[18:04:58.046]                   NAME <- NAMES[[kk]]
[18:04:58.046]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.046]                     next
[18:04:58.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.046]                 }
[18:04:58.046]                 if (length(args) > 0) 
[18:04:58.046]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.046]             }
[18:04:58.046]             else {
[18:04:58.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.046]             }
[18:04:58.046]             {
[18:04:58.046]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.046]                   0L) {
[18:04:58.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.046]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.046]                   base::options(opts)
[18:04:58.046]                 }
[18:04:58.046]                 {
[18:04:58.046]                   {
[18:04:58.046]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.046]                     NULL
[18:04:58.046]                   }
[18:04:58.046]                   options(future.plan = NULL)
[18:04:58.046]                   if (is.na(NA_character_)) 
[18:04:58.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.046]                     .init = FALSE)
[18:04:58.046]                 }
[18:04:58.046]             }
[18:04:58.046]         }
[18:04:58.046]     })
[18:04:58.046]     if (TRUE) {
[18:04:58.046]         base::sink(type = "output", split = FALSE)
[18:04:58.046]         if (TRUE) {
[18:04:58.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.046]         }
[18:04:58.046]         else {
[18:04:58.046]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.046]         }
[18:04:58.046]         base::close(...future.stdout)
[18:04:58.046]         ...future.stdout <- NULL
[18:04:58.046]     }
[18:04:58.046]     ...future.result$conditions <- ...future.conditions
[18:04:58.046]     ...future.result$finished <- base::Sys.time()
[18:04:58.046]     ...future.result
[18:04:58.046] }
[18:04:58.052] assign_globals() ...
[18:04:58.052] List of 2
[18:04:58.052]  $ a : num 1
[18:04:58.052]  $ ii: int 2
[18:04:58.052]  - attr(*, "where")=List of 2
[18:04:58.052]   ..$ a :<environment: R_EmptyEnv> 
[18:04:58.052]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:58.052]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:58.052]  - attr(*, "resolved")= logi TRUE
[18:04:58.052]  - attr(*, "total_size")= num 112
[18:04:58.052]  - attr(*, "already-done")= logi TRUE
[18:04:58.060] - copied ‘a’ to environment
[18:04:58.060] - copied ‘ii’ to environment
[18:04:58.061] assign_globals() ... done
[18:04:58.061] requestCore(): workers = 2
[18:04:58.065] MulticoreFuture started
[18:04:58.066] - Launch lazy future ... done
[18:04:58.068] run() for ‘MulticoreFuture’ ... done
[18:04:58.069] result() for MulticoreFuture ...
[18:04:58.071] plan(): Setting new future strategy stack:
[18:04:58.071] List of future strategies:
[18:04:58.071] 1. sequential:
[18:04:58.071]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.071]    - tweaked: FALSE
[18:04:58.071]    - call: NULL
[18:04:58.074] plan(): nbrOfWorkers() = 1
[18:04:58.079] plan(): Setting new future strategy stack:
[18:04:58.079] List of future strategies:
[18:04:58.079] 1. multicore:
[18:04:58.079]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.079]    - tweaked: FALSE
[18:04:58.079]    - call: plan(strategy)
[18:04:58.090] plan(): nbrOfWorkers() = 2
[18:04:58.094] result() for MulticoreFuture ...
[18:04:58.094] result() for MulticoreFuture ... done
[18:04:58.094] result() for MulticoreFuture ... done
[18:04:58.095] result() for MulticoreFuture ...
[18:04:58.096] result() for MulticoreFuture ... done
[18:04:58.096] run() for ‘Future’ ...
[18:04:58.097] - state: ‘created’
[18:04:58.097] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.105] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.106] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.106]   - Field: ‘label’
[18:04:58.106]   - Field: ‘local’
[18:04:58.107]   - Field: ‘owner’
[18:04:58.107]   - Field: ‘envir’
[18:04:58.107]   - Field: ‘workers’
[18:04:58.108]   - Field: ‘packages’
[18:04:58.108]   - Field: ‘gc’
[18:04:58.108]   - Field: ‘job’
[18:04:58.108]   - Field: ‘conditions’
[18:04:58.109]   - Field: ‘expr’
[18:04:58.109]   - Field: ‘uuid’
[18:04:58.109]   - Field: ‘seed’
[18:04:58.109]   - Field: ‘version’
[18:04:58.110]   - Field: ‘result’
[18:04:58.110]   - Field: ‘asynchronous’
[18:04:58.110]   - Field: ‘calls’
[18:04:58.110]   - Field: ‘globals’
[18:04:58.111]   - Field: ‘stdout’
[18:04:58.111]   - Field: ‘earlySignal’
[18:04:58.111]   - Field: ‘lazy’
[18:04:58.112]   - Field: ‘state’
[18:04:58.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.112] - Launch lazy future ...
[18:04:58.113] Packages needed by the future expression (n = 0): <none>
[18:04:58.113] Packages needed by future strategies (n = 0): <none>
[18:04:58.114] {
[18:04:58.114]     {
[18:04:58.114]         {
[18:04:58.114]             ...future.startTime <- base::Sys.time()
[18:04:58.114]             {
[18:04:58.114]                 {
[18:04:58.114]                   {
[18:04:58.114]                     {
[18:04:58.114]                       base::local({
[18:04:58.114]                         has_future <- base::requireNamespace("future", 
[18:04:58.114]                           quietly = TRUE)
[18:04:58.114]                         if (has_future) {
[18:04:58.114]                           ns <- base::getNamespace("future")
[18:04:58.114]                           version <- ns[[".package"]][["version"]]
[18:04:58.114]                           if (is.null(version)) 
[18:04:58.114]                             version <- utils::packageVersion("future")
[18:04:58.114]                         }
[18:04:58.114]                         else {
[18:04:58.114]                           version <- NULL
[18:04:58.114]                         }
[18:04:58.114]                         if (!has_future || version < "1.8.0") {
[18:04:58.114]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.114]                             "", base::R.version$version.string), 
[18:04:58.114]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:58.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:58.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.114]                               "release", "version")], collapse = " "), 
[18:04:58.114]                             hostname = base::Sys.info()[["nodename"]])
[18:04:58.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.114]                             info)
[18:04:58.114]                           info <- base::paste(info, collapse = "; ")
[18:04:58.114]                           if (!has_future) {
[18:04:58.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.114]                               info)
[18:04:58.114]                           }
[18:04:58.114]                           else {
[18:04:58.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.114]                               info, version)
[18:04:58.114]                           }
[18:04:58.114]                           base::stop(msg)
[18:04:58.114]                         }
[18:04:58.114]                       })
[18:04:58.114]                     }
[18:04:58.114]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.114]                     base::options(mc.cores = 1L)
[18:04:58.114]                   }
[18:04:58.114]                   ...future.strategy.old <- future::plan("list")
[18:04:58.114]                   options(future.plan = NULL)
[18:04:58.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.114]                 }
[18:04:58.114]                 ...future.workdir <- getwd()
[18:04:58.114]             }
[18:04:58.114]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.114]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.114]         }
[18:04:58.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.114]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.114]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.114]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.114]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.114]             base::names(...future.oldOptions))
[18:04:58.114]     }
[18:04:58.114]     if (FALSE) {
[18:04:58.114]     }
[18:04:58.114]     else {
[18:04:58.114]         if (TRUE) {
[18:04:58.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.114]                 open = "w")
[18:04:58.114]         }
[18:04:58.114]         else {
[18:04:58.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.114]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.114]         }
[18:04:58.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.114]             base::sink(type = "output", split = FALSE)
[18:04:58.114]             base::close(...future.stdout)
[18:04:58.114]         }, add = TRUE)
[18:04:58.114]     }
[18:04:58.114]     ...future.frame <- base::sys.nframe()
[18:04:58.114]     ...future.conditions <- base::list()
[18:04:58.114]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.114]     if (FALSE) {
[18:04:58.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.114]     }
[18:04:58.114]     ...future.result <- base::tryCatch({
[18:04:58.114]         base::withCallingHandlers({
[18:04:58.114]             ...future.value <- base::withVisible(base::local({
[18:04:58.114]                 withCallingHandlers({
[18:04:58.114]                   {
[18:04:58.114]                     b <- a * ii
[18:04:58.114]                     a <- 0
[18:04:58.114]                     b
[18:04:58.114]                   }
[18:04:58.114]                 }, immediateCondition = function(cond) {
[18:04:58.114]                   save_rds <- function (object, pathname, ...) 
[18:04:58.114]                   {
[18:04:58.114]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.114]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.114]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.114]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.114]                         fi_tmp[["mtime"]])
[18:04:58.114]                     }
[18:04:58.114]                     tryCatch({
[18:04:58.114]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.114]                     }, error = function(ex) {
[18:04:58.114]                       msg <- conditionMessage(ex)
[18:04:58.114]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.114]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.114]                         fi_tmp[["mtime"]], msg)
[18:04:58.114]                       ex$message <- msg
[18:04:58.114]                       stop(ex)
[18:04:58.114]                     })
[18:04:58.114]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.114]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.114]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.114]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.114]                       fi <- file.info(pathname)
[18:04:58.114]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.114]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.114]                         fi[["size"]], fi[["mtime"]])
[18:04:58.114]                       stop(msg)
[18:04:58.114]                     }
[18:04:58.114]                     invisible(pathname)
[18:04:58.114]                   }
[18:04:58.114]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.114]                     rootPath = tempdir()) 
[18:04:58.114]                   {
[18:04:58.114]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.114]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.114]                       tmpdir = path, fileext = ".rds")
[18:04:58.114]                     save_rds(obj, file)
[18:04:58.114]                   }
[18:04:58.114]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.114]                   {
[18:04:58.114]                     inherits <- base::inherits
[18:04:58.114]                     invokeRestart <- base::invokeRestart
[18:04:58.114]                     is.null <- base::is.null
[18:04:58.114]                     muffled <- FALSE
[18:04:58.114]                     if (inherits(cond, "message")) {
[18:04:58.114]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.114]                       if (muffled) 
[18:04:58.114]                         invokeRestart("muffleMessage")
[18:04:58.114]                     }
[18:04:58.114]                     else if (inherits(cond, "warning")) {
[18:04:58.114]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.114]                       if (muffled) 
[18:04:58.114]                         invokeRestart("muffleWarning")
[18:04:58.114]                     }
[18:04:58.114]                     else if (inherits(cond, "condition")) {
[18:04:58.114]                       if (!is.null(pattern)) {
[18:04:58.114]                         computeRestarts <- base::computeRestarts
[18:04:58.114]                         grepl <- base::grepl
[18:04:58.114]                         restarts <- computeRestarts(cond)
[18:04:58.114]                         for (restart in restarts) {
[18:04:58.114]                           name <- restart$name
[18:04:58.114]                           if (is.null(name)) 
[18:04:58.114]                             next
[18:04:58.114]                           if (!grepl(pattern, name)) 
[18:04:58.114]                             next
[18:04:58.114]                           invokeRestart(restart)
[18:04:58.114]                           muffled <- TRUE
[18:04:58.114]                           break
[18:04:58.114]                         }
[18:04:58.114]                       }
[18:04:58.114]                     }
[18:04:58.114]                     invisible(muffled)
[18:04:58.114]                   }
[18:04:58.114]                   muffleCondition(cond)
[18:04:58.114]                 })
[18:04:58.114]             }))
[18:04:58.114]             future::FutureResult(value = ...future.value$value, 
[18:04:58.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.114]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.114]                     ...future.globalenv.names))
[18:04:58.114]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.114]         }, condition = base::local({
[18:04:58.114]             c <- base::c
[18:04:58.114]             inherits <- base::inherits
[18:04:58.114]             invokeRestart <- base::invokeRestart
[18:04:58.114]             length <- base::length
[18:04:58.114]             list <- base::list
[18:04:58.114]             seq.int <- base::seq.int
[18:04:58.114]             signalCondition <- base::signalCondition
[18:04:58.114]             sys.calls <- base::sys.calls
[18:04:58.114]             `[[` <- base::`[[`
[18:04:58.114]             `+` <- base::`+`
[18:04:58.114]             `<<-` <- base::`<<-`
[18:04:58.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.114]                   3L)]
[18:04:58.114]             }
[18:04:58.114]             function(cond) {
[18:04:58.114]                 is_error <- inherits(cond, "error")
[18:04:58.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.114]                   NULL)
[18:04:58.114]                 if (is_error) {
[18:04:58.114]                   sessionInformation <- function() {
[18:04:58.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.114]                       search = base::search(), system = base::Sys.info())
[18:04:58.114]                   }
[18:04:58.114]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.114]                     cond$call), session = sessionInformation(), 
[18:04:58.114]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.114]                   signalCondition(cond)
[18:04:58.114]                 }
[18:04:58.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.114]                 "immediateCondition"))) {
[18:04:58.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.114]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.114]                   if (TRUE && !signal) {
[18:04:58.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.114]                     {
[18:04:58.114]                       inherits <- base::inherits
[18:04:58.114]                       invokeRestart <- base::invokeRestart
[18:04:58.114]                       is.null <- base::is.null
[18:04:58.114]                       muffled <- FALSE
[18:04:58.114]                       if (inherits(cond, "message")) {
[18:04:58.114]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.114]                         if (muffled) 
[18:04:58.114]                           invokeRestart("muffleMessage")
[18:04:58.114]                       }
[18:04:58.114]                       else if (inherits(cond, "warning")) {
[18:04:58.114]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.114]                         if (muffled) 
[18:04:58.114]                           invokeRestart("muffleWarning")
[18:04:58.114]                       }
[18:04:58.114]                       else if (inherits(cond, "condition")) {
[18:04:58.114]                         if (!is.null(pattern)) {
[18:04:58.114]                           computeRestarts <- base::computeRestarts
[18:04:58.114]                           grepl <- base::grepl
[18:04:58.114]                           restarts <- computeRestarts(cond)
[18:04:58.114]                           for (restart in restarts) {
[18:04:58.114]                             name <- restart$name
[18:04:58.114]                             if (is.null(name)) 
[18:04:58.114]                               next
[18:04:58.114]                             if (!grepl(pattern, name)) 
[18:04:58.114]                               next
[18:04:58.114]                             invokeRestart(restart)
[18:04:58.114]                             muffled <- TRUE
[18:04:58.114]                             break
[18:04:58.114]                           }
[18:04:58.114]                         }
[18:04:58.114]                       }
[18:04:58.114]                       invisible(muffled)
[18:04:58.114]                     }
[18:04:58.114]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.114]                   }
[18:04:58.114]                 }
[18:04:58.114]                 else {
[18:04:58.114]                   if (TRUE) {
[18:04:58.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.114]                     {
[18:04:58.114]                       inherits <- base::inherits
[18:04:58.114]                       invokeRestart <- base::invokeRestart
[18:04:58.114]                       is.null <- base::is.null
[18:04:58.114]                       muffled <- FALSE
[18:04:58.114]                       if (inherits(cond, "message")) {
[18:04:58.114]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.114]                         if (muffled) 
[18:04:58.114]                           invokeRestart("muffleMessage")
[18:04:58.114]                       }
[18:04:58.114]                       else if (inherits(cond, "warning")) {
[18:04:58.114]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.114]                         if (muffled) 
[18:04:58.114]                           invokeRestart("muffleWarning")
[18:04:58.114]                       }
[18:04:58.114]                       else if (inherits(cond, "condition")) {
[18:04:58.114]                         if (!is.null(pattern)) {
[18:04:58.114]                           computeRestarts <- base::computeRestarts
[18:04:58.114]                           grepl <- base::grepl
[18:04:58.114]                           restarts <- computeRestarts(cond)
[18:04:58.114]                           for (restart in restarts) {
[18:04:58.114]                             name <- restart$name
[18:04:58.114]                             if (is.null(name)) 
[18:04:58.114]                               next
[18:04:58.114]                             if (!grepl(pattern, name)) 
[18:04:58.114]                               next
[18:04:58.114]                             invokeRestart(restart)
[18:04:58.114]                             muffled <- TRUE
[18:04:58.114]                             break
[18:04:58.114]                           }
[18:04:58.114]                         }
[18:04:58.114]                       }
[18:04:58.114]                       invisible(muffled)
[18:04:58.114]                     }
[18:04:58.114]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.114]                   }
[18:04:58.114]                 }
[18:04:58.114]             }
[18:04:58.114]         }))
[18:04:58.114]     }, error = function(ex) {
[18:04:58.114]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.114]                 ...future.rng), started = ...future.startTime, 
[18:04:58.114]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.114]             version = "1.8"), class = "FutureResult")
[18:04:58.114]     }, finally = {
[18:04:58.114]         if (!identical(...future.workdir, getwd())) 
[18:04:58.114]             setwd(...future.workdir)
[18:04:58.114]         {
[18:04:58.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.114]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.114]             }
[18:04:58.114]             base::options(...future.oldOptions)
[18:04:58.114]             if (.Platform$OS.type == "windows") {
[18:04:58.114]                 old_names <- names(...future.oldEnvVars)
[18:04:58.114]                 envs <- base::Sys.getenv()
[18:04:58.114]                 names <- names(envs)
[18:04:58.114]                 common <- intersect(names, old_names)
[18:04:58.114]                 added <- setdiff(names, old_names)
[18:04:58.114]                 removed <- setdiff(old_names, names)
[18:04:58.114]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.114]                   envs[common]]
[18:04:58.114]                 NAMES <- toupper(changed)
[18:04:58.114]                 args <- list()
[18:04:58.114]                 for (kk in seq_along(NAMES)) {
[18:04:58.114]                   name <- changed[[kk]]
[18:04:58.114]                   NAME <- NAMES[[kk]]
[18:04:58.114]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.114]                     next
[18:04:58.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.114]                 }
[18:04:58.114]                 NAMES <- toupper(added)
[18:04:58.114]                 for (kk in seq_along(NAMES)) {
[18:04:58.114]                   name <- added[[kk]]
[18:04:58.114]                   NAME <- NAMES[[kk]]
[18:04:58.114]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.114]                     next
[18:04:58.114]                   args[[name]] <- ""
[18:04:58.114]                 }
[18:04:58.114]                 NAMES <- toupper(removed)
[18:04:58.114]                 for (kk in seq_along(NAMES)) {
[18:04:58.114]                   name <- removed[[kk]]
[18:04:58.114]                   NAME <- NAMES[[kk]]
[18:04:58.114]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.114]                     next
[18:04:58.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.114]                 }
[18:04:58.114]                 if (length(args) > 0) 
[18:04:58.114]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.114]             }
[18:04:58.114]             else {
[18:04:58.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.114]             }
[18:04:58.114]             {
[18:04:58.114]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.114]                   0L) {
[18:04:58.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.114]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.114]                   base::options(opts)
[18:04:58.114]                 }
[18:04:58.114]                 {
[18:04:58.114]                   {
[18:04:58.114]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.114]                     NULL
[18:04:58.114]                   }
[18:04:58.114]                   options(future.plan = NULL)
[18:04:58.114]                   if (is.na(NA_character_)) 
[18:04:58.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.114]                     .init = FALSE)
[18:04:58.114]                 }
[18:04:58.114]             }
[18:04:58.114]         }
[18:04:58.114]     })
[18:04:58.114]     if (TRUE) {
[18:04:58.114]         base::sink(type = "output", split = FALSE)
[18:04:58.114]         if (TRUE) {
[18:04:58.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.114]         }
[18:04:58.114]         else {
[18:04:58.114]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.114]         }
[18:04:58.114]         base::close(...future.stdout)
[18:04:58.114]         ...future.stdout <- NULL
[18:04:58.114]     }
[18:04:58.114]     ...future.result$conditions <- ...future.conditions
[18:04:58.114]     ...future.result$finished <- base::Sys.time()
[18:04:58.114]     ...future.result
[18:04:58.114] }
[18:04:58.123] assign_globals() ...
[18:04:58.124] List of 2
[18:04:58.124]  $ a : num 1
[18:04:58.124]  $ ii: int 3
[18:04:58.124]  - attr(*, "where")=List of 2
[18:04:58.124]   ..$ a :<environment: R_EmptyEnv> 
[18:04:58.124]   ..$ ii:<environment: R_EmptyEnv> 
[18:04:58.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:58.124]  - attr(*, "resolved")= logi TRUE
[18:04:58.124]  - attr(*, "total_size")= num 112
[18:04:58.124]  - attr(*, "already-done")= logi TRUE
[18:04:58.132] - copied ‘a’ to environment
[18:04:58.133] - copied ‘ii’ to environment
[18:04:58.133] assign_globals() ... done
[18:04:58.133] requestCore(): workers = 2
[18:04:58.137] MulticoreFuture started
[18:04:58.140] - Launch lazy future ... done
[18:04:58.143] plan(): Setting new future strategy stack:
[18:04:58.141] run() for ‘MulticoreFuture’ ... done
[18:04:58.144] result() for MulticoreFuture ...
[18:04:58.146] List of future strategies:
[18:04:58.146] 1. sequential:
[18:04:58.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.146]    - tweaked: FALSE
[18:04:58.146]    - call: NULL
[18:04:58.150] plan(): nbrOfWorkers() = 1
[18:04:58.156] plan(): Setting new future strategy stack:
[18:04:58.157] List of future strategies:
[18:04:58.157] 1. multicore:
[18:04:58.157]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.157]    - tweaked: FALSE
[18:04:58.157]    - call: plan(strategy)
[18:04:58.170] plan(): nbrOfWorkers() = 2
[18:04:58.173] result() for MulticoreFuture ...
[18:04:58.173] result() for MulticoreFuture ... done
[18:04:58.174] result() for MulticoreFuture ... done
[18:04:58.174] result() for MulticoreFuture ...
[18:04:58.174] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.176] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.176] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.178] 
[18:04:58.178] Searching for globals ... DONE
[18:04:58.179] - globals: [0] <none>
[18:04:58.179] getGlobalsAndPackages() ... DONE
[18:04:58.180] run() for ‘Future’ ...
[18:04:58.180] - state: ‘created’
[18:04:58.180] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.188] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.188]   - Field: ‘label’
[18:04:58.189]   - Field: ‘local’
[18:04:58.189]   - Field: ‘owner’
[18:04:58.189]   - Field: ‘envir’
[18:04:58.190]   - Field: ‘workers’
[18:04:58.190]   - Field: ‘packages’
[18:04:58.190]   - Field: ‘gc’
[18:04:58.190]   - Field: ‘job’
[18:04:58.191]   - Field: ‘conditions’
[18:04:58.191]   - Field: ‘expr’
[18:04:58.191]   - Field: ‘uuid’
[18:04:58.191]   - Field: ‘seed’
[18:04:58.192]   - Field: ‘version’
[18:04:58.192]   - Field: ‘result’
[18:04:58.192]   - Field: ‘asynchronous’
[18:04:58.192]   - Field: ‘calls’
[18:04:58.193]   - Field: ‘globals’
[18:04:58.193]   - Field: ‘stdout’
[18:04:58.193]   - Field: ‘earlySignal’
[18:04:58.193]   - Field: ‘lazy’
[18:04:58.194]   - Field: ‘state’
[18:04:58.194] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.194] - Launch lazy future ...
[18:04:58.195] Packages needed by the future expression (n = 0): <none>
[18:04:58.195] Packages needed by future strategies (n = 0): <none>
[18:04:58.196] {
[18:04:58.196]     {
[18:04:58.196]         {
[18:04:58.196]             ...future.startTime <- base::Sys.time()
[18:04:58.196]             {
[18:04:58.196]                 {
[18:04:58.196]                   {
[18:04:58.196]                     {
[18:04:58.196]                       base::local({
[18:04:58.196]                         has_future <- base::requireNamespace("future", 
[18:04:58.196]                           quietly = TRUE)
[18:04:58.196]                         if (has_future) {
[18:04:58.196]                           ns <- base::getNamespace("future")
[18:04:58.196]                           version <- ns[[".package"]][["version"]]
[18:04:58.196]                           if (is.null(version)) 
[18:04:58.196]                             version <- utils::packageVersion("future")
[18:04:58.196]                         }
[18:04:58.196]                         else {
[18:04:58.196]                           version <- NULL
[18:04:58.196]                         }
[18:04:58.196]                         if (!has_future || version < "1.8.0") {
[18:04:58.196]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.196]                             "", base::R.version$version.string), 
[18:04:58.196]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:58.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:58.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.196]                               "release", "version")], collapse = " "), 
[18:04:58.196]                             hostname = base::Sys.info()[["nodename"]])
[18:04:58.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.196]                             info)
[18:04:58.196]                           info <- base::paste(info, collapse = "; ")
[18:04:58.196]                           if (!has_future) {
[18:04:58.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.196]                               info)
[18:04:58.196]                           }
[18:04:58.196]                           else {
[18:04:58.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.196]                               info, version)
[18:04:58.196]                           }
[18:04:58.196]                           base::stop(msg)
[18:04:58.196]                         }
[18:04:58.196]                       })
[18:04:58.196]                     }
[18:04:58.196]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.196]                     base::options(mc.cores = 1L)
[18:04:58.196]                   }
[18:04:58.196]                   ...future.strategy.old <- future::plan("list")
[18:04:58.196]                   options(future.plan = NULL)
[18:04:58.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.196]                 }
[18:04:58.196]                 ...future.workdir <- getwd()
[18:04:58.196]             }
[18:04:58.196]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.196]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.196]         }
[18:04:58.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.196]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.196]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.196]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.196]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.196]             base::names(...future.oldOptions))
[18:04:58.196]     }
[18:04:58.196]     if (FALSE) {
[18:04:58.196]     }
[18:04:58.196]     else {
[18:04:58.196]         if (TRUE) {
[18:04:58.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.196]                 open = "w")
[18:04:58.196]         }
[18:04:58.196]         else {
[18:04:58.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.196]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.196]         }
[18:04:58.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.196]             base::sink(type = "output", split = FALSE)
[18:04:58.196]             base::close(...future.stdout)
[18:04:58.196]         }, add = TRUE)
[18:04:58.196]     }
[18:04:58.196]     ...future.frame <- base::sys.nframe()
[18:04:58.196]     ...future.conditions <- base::list()
[18:04:58.196]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.196]     if (FALSE) {
[18:04:58.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.196]     }
[18:04:58.196]     ...future.result <- base::tryCatch({
[18:04:58.196]         base::withCallingHandlers({
[18:04:58.196]             ...future.value <- base::withVisible(base::local({
[18:04:58.196]                 withCallingHandlers({
[18:04:58.196]                   1
[18:04:58.196]                 }, immediateCondition = function(cond) {
[18:04:58.196]                   save_rds <- function (object, pathname, ...) 
[18:04:58.196]                   {
[18:04:58.196]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.196]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.196]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.196]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.196]                         fi_tmp[["mtime"]])
[18:04:58.196]                     }
[18:04:58.196]                     tryCatch({
[18:04:58.196]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.196]                     }, error = function(ex) {
[18:04:58.196]                       msg <- conditionMessage(ex)
[18:04:58.196]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.196]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.196]                         fi_tmp[["mtime"]], msg)
[18:04:58.196]                       ex$message <- msg
[18:04:58.196]                       stop(ex)
[18:04:58.196]                     })
[18:04:58.196]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.196]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.196]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.196]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.196]                       fi <- file.info(pathname)
[18:04:58.196]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.196]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.196]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.196]                         fi[["size"]], fi[["mtime"]])
[18:04:58.196]                       stop(msg)
[18:04:58.196]                     }
[18:04:58.196]                     invisible(pathname)
[18:04:58.196]                   }
[18:04:58.196]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.196]                     rootPath = tempdir()) 
[18:04:58.196]                   {
[18:04:58.196]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.196]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.196]                       tmpdir = path, fileext = ".rds")
[18:04:58.196]                     save_rds(obj, file)
[18:04:58.196]                   }
[18:04:58.196]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.196]                   {
[18:04:58.196]                     inherits <- base::inherits
[18:04:58.196]                     invokeRestart <- base::invokeRestart
[18:04:58.196]                     is.null <- base::is.null
[18:04:58.196]                     muffled <- FALSE
[18:04:58.196]                     if (inherits(cond, "message")) {
[18:04:58.196]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.196]                       if (muffled) 
[18:04:58.196]                         invokeRestart("muffleMessage")
[18:04:58.196]                     }
[18:04:58.196]                     else if (inherits(cond, "warning")) {
[18:04:58.196]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.196]                       if (muffled) 
[18:04:58.196]                         invokeRestart("muffleWarning")
[18:04:58.196]                     }
[18:04:58.196]                     else if (inherits(cond, "condition")) {
[18:04:58.196]                       if (!is.null(pattern)) {
[18:04:58.196]                         computeRestarts <- base::computeRestarts
[18:04:58.196]                         grepl <- base::grepl
[18:04:58.196]                         restarts <- computeRestarts(cond)
[18:04:58.196]                         for (restart in restarts) {
[18:04:58.196]                           name <- restart$name
[18:04:58.196]                           if (is.null(name)) 
[18:04:58.196]                             next
[18:04:58.196]                           if (!grepl(pattern, name)) 
[18:04:58.196]                             next
[18:04:58.196]                           invokeRestart(restart)
[18:04:58.196]                           muffled <- TRUE
[18:04:58.196]                           break
[18:04:58.196]                         }
[18:04:58.196]                       }
[18:04:58.196]                     }
[18:04:58.196]                     invisible(muffled)
[18:04:58.196]                   }
[18:04:58.196]                   muffleCondition(cond)
[18:04:58.196]                 })
[18:04:58.196]             }))
[18:04:58.196]             future::FutureResult(value = ...future.value$value, 
[18:04:58.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.196]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.196]                     ...future.globalenv.names))
[18:04:58.196]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.196]         }, condition = base::local({
[18:04:58.196]             c <- base::c
[18:04:58.196]             inherits <- base::inherits
[18:04:58.196]             invokeRestart <- base::invokeRestart
[18:04:58.196]             length <- base::length
[18:04:58.196]             list <- base::list
[18:04:58.196]             seq.int <- base::seq.int
[18:04:58.196]             signalCondition <- base::signalCondition
[18:04:58.196]             sys.calls <- base::sys.calls
[18:04:58.196]             `[[` <- base::`[[`
[18:04:58.196]             `+` <- base::`+`
[18:04:58.196]             `<<-` <- base::`<<-`
[18:04:58.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.196]                   3L)]
[18:04:58.196]             }
[18:04:58.196]             function(cond) {
[18:04:58.196]                 is_error <- inherits(cond, "error")
[18:04:58.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.196]                   NULL)
[18:04:58.196]                 if (is_error) {
[18:04:58.196]                   sessionInformation <- function() {
[18:04:58.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.196]                       search = base::search(), system = base::Sys.info())
[18:04:58.196]                   }
[18:04:58.196]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.196]                     cond$call), session = sessionInformation(), 
[18:04:58.196]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.196]                   signalCondition(cond)
[18:04:58.196]                 }
[18:04:58.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.196]                 "immediateCondition"))) {
[18:04:58.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.196]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.196]                   if (TRUE && !signal) {
[18:04:58.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.196]                     {
[18:04:58.196]                       inherits <- base::inherits
[18:04:58.196]                       invokeRestart <- base::invokeRestart
[18:04:58.196]                       is.null <- base::is.null
[18:04:58.196]                       muffled <- FALSE
[18:04:58.196]                       if (inherits(cond, "message")) {
[18:04:58.196]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.196]                         if (muffled) 
[18:04:58.196]                           invokeRestart("muffleMessage")
[18:04:58.196]                       }
[18:04:58.196]                       else if (inherits(cond, "warning")) {
[18:04:58.196]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.196]                         if (muffled) 
[18:04:58.196]                           invokeRestart("muffleWarning")
[18:04:58.196]                       }
[18:04:58.196]                       else if (inherits(cond, "condition")) {
[18:04:58.196]                         if (!is.null(pattern)) {
[18:04:58.196]                           computeRestarts <- base::computeRestarts
[18:04:58.196]                           grepl <- base::grepl
[18:04:58.196]                           restarts <- computeRestarts(cond)
[18:04:58.196]                           for (restart in restarts) {
[18:04:58.196]                             name <- restart$name
[18:04:58.196]                             if (is.null(name)) 
[18:04:58.196]                               next
[18:04:58.196]                             if (!grepl(pattern, name)) 
[18:04:58.196]                               next
[18:04:58.196]                             invokeRestart(restart)
[18:04:58.196]                             muffled <- TRUE
[18:04:58.196]                             break
[18:04:58.196]                           }
[18:04:58.196]                         }
[18:04:58.196]                       }
[18:04:58.196]                       invisible(muffled)
[18:04:58.196]                     }
[18:04:58.196]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.196]                   }
[18:04:58.196]                 }
[18:04:58.196]                 else {
[18:04:58.196]                   if (TRUE) {
[18:04:58.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.196]                     {
[18:04:58.196]                       inherits <- base::inherits
[18:04:58.196]                       invokeRestart <- base::invokeRestart
[18:04:58.196]                       is.null <- base::is.null
[18:04:58.196]                       muffled <- FALSE
[18:04:58.196]                       if (inherits(cond, "message")) {
[18:04:58.196]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.196]                         if (muffled) 
[18:04:58.196]                           invokeRestart("muffleMessage")
[18:04:58.196]                       }
[18:04:58.196]                       else if (inherits(cond, "warning")) {
[18:04:58.196]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.196]                         if (muffled) 
[18:04:58.196]                           invokeRestart("muffleWarning")
[18:04:58.196]                       }
[18:04:58.196]                       else if (inherits(cond, "condition")) {
[18:04:58.196]                         if (!is.null(pattern)) {
[18:04:58.196]                           computeRestarts <- base::computeRestarts
[18:04:58.196]                           grepl <- base::grepl
[18:04:58.196]                           restarts <- computeRestarts(cond)
[18:04:58.196]                           for (restart in restarts) {
[18:04:58.196]                             name <- restart$name
[18:04:58.196]                             if (is.null(name)) 
[18:04:58.196]                               next
[18:04:58.196]                             if (!grepl(pattern, name)) 
[18:04:58.196]                               next
[18:04:58.196]                             invokeRestart(restart)
[18:04:58.196]                             muffled <- TRUE
[18:04:58.196]                             break
[18:04:58.196]                           }
[18:04:58.196]                         }
[18:04:58.196]                       }
[18:04:58.196]                       invisible(muffled)
[18:04:58.196]                     }
[18:04:58.196]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.196]                   }
[18:04:58.196]                 }
[18:04:58.196]             }
[18:04:58.196]         }))
[18:04:58.196]     }, error = function(ex) {
[18:04:58.196]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.196]                 ...future.rng), started = ...future.startTime, 
[18:04:58.196]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.196]             version = "1.8"), class = "FutureResult")
[18:04:58.196]     }, finally = {
[18:04:58.196]         if (!identical(...future.workdir, getwd())) 
[18:04:58.196]             setwd(...future.workdir)
[18:04:58.196]         {
[18:04:58.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.196]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.196]             }
[18:04:58.196]             base::options(...future.oldOptions)
[18:04:58.196]             if (.Platform$OS.type == "windows") {
[18:04:58.196]                 old_names <- names(...future.oldEnvVars)
[18:04:58.196]                 envs <- base::Sys.getenv()
[18:04:58.196]                 names <- names(envs)
[18:04:58.196]                 common <- intersect(names, old_names)
[18:04:58.196]                 added <- setdiff(names, old_names)
[18:04:58.196]                 removed <- setdiff(old_names, names)
[18:04:58.196]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.196]                   envs[common]]
[18:04:58.196]                 NAMES <- toupper(changed)
[18:04:58.196]                 args <- list()
[18:04:58.196]                 for (kk in seq_along(NAMES)) {
[18:04:58.196]                   name <- changed[[kk]]
[18:04:58.196]                   NAME <- NAMES[[kk]]
[18:04:58.196]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.196]                     next
[18:04:58.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.196]                 }
[18:04:58.196]                 NAMES <- toupper(added)
[18:04:58.196]                 for (kk in seq_along(NAMES)) {
[18:04:58.196]                   name <- added[[kk]]
[18:04:58.196]                   NAME <- NAMES[[kk]]
[18:04:58.196]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.196]                     next
[18:04:58.196]                   args[[name]] <- ""
[18:04:58.196]                 }
[18:04:58.196]                 NAMES <- toupper(removed)
[18:04:58.196]                 for (kk in seq_along(NAMES)) {
[18:04:58.196]                   name <- removed[[kk]]
[18:04:58.196]                   NAME <- NAMES[[kk]]
[18:04:58.196]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.196]                     next
[18:04:58.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.196]                 }
[18:04:58.196]                 if (length(args) > 0) 
[18:04:58.196]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.196]             }
[18:04:58.196]             else {
[18:04:58.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.196]             }
[18:04:58.196]             {
[18:04:58.196]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.196]                   0L) {
[18:04:58.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.196]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.196]                   base::options(opts)
[18:04:58.196]                 }
[18:04:58.196]                 {
[18:04:58.196]                   {
[18:04:58.196]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.196]                     NULL
[18:04:58.196]                   }
[18:04:58.196]                   options(future.plan = NULL)
[18:04:58.196]                   if (is.na(NA_character_)) 
[18:04:58.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.196]                     .init = FALSE)
[18:04:58.196]                 }
[18:04:58.196]             }
[18:04:58.196]         }
[18:04:58.196]     })
[18:04:58.196]     if (TRUE) {
[18:04:58.196]         base::sink(type = "output", split = FALSE)
[18:04:58.196]         if (TRUE) {
[18:04:58.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.196]         }
[18:04:58.196]         else {
[18:04:58.196]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.196]         }
[18:04:58.196]         base::close(...future.stdout)
[18:04:58.196]         ...future.stdout <- NULL
[18:04:58.196]     }
[18:04:58.196]     ...future.result$conditions <- ...future.conditions
[18:04:58.196]     ...future.result$finished <- base::Sys.time()
[18:04:58.196]     ...future.result
[18:04:58.196] }
[18:04:58.202] requestCore(): workers = 2
[18:04:58.205] MulticoreFuture started
[18:04:58.206] - Launch lazy future ... done
[18:04:58.207] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.208] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.209] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.210] plan(): Setting new future strategy stack:
[18:04:58.212] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:58.213] Searching for globals ... DONE
[18:04:58.213] Resolving globals: TRUE
[18:04:58.214] Resolving any globals that are futures ...
[18:04:58.214] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:58.214] Resolving any globals that are futures ... DONE
[18:04:58.210] List of future strategies:
[18:04:58.210] 1. sequential:
[18:04:58.210]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.210]    - tweaked: FALSE
[18:04:58.210]    - call: NULL
[18:04:58.215] plan(): nbrOfWorkers() = 1
[18:04:58.216] Resolving futures part of globals (recursively) ...
[18:04:58.217] resolve() on list ...
[18:04:58.218]  recursive: 99
[18:04:58.218]  length: 1
[18:04:58.219]  elements: ‘a’
[18:04:58.224] plan(): Setting new future strategy stack:
[18:04:58.224] List of future strategies:
[18:04:58.224] 1. multicore:
[18:04:58.224]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.224]    - tweaked: FALSE
[18:04:58.224]    - call: plan(strategy)
[18:04:58.232] plan(): nbrOfWorkers() = 2
[18:04:58.241] Future #1
[18:04:58.241] result() for MulticoreFuture ...
[18:04:58.243] result() for MulticoreFuture ...
[18:04:58.244] result() for MulticoreFuture ... done
[18:04:58.244] result() for MulticoreFuture ... done
[18:04:58.244] result() for MulticoreFuture ...
[18:04:58.245] result() for MulticoreFuture ... done
[18:04:58.245] A MulticoreFuture was resolved
[18:04:58.245]  length: 0 (resolved future 1)
[18:04:58.246] resolve() on list ... DONE
[18:04:58.246] - globals: [1] ‘a’
[18:04:58.246] Resolving futures part of globals (recursively) ... DONE
[18:04:58.251] The total size of the 1 globals is 1.57 MiB (1649944 bytes)
[18:04:58.252] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[18:04:58.253] - globals: [1] ‘a’
[18:04:58.253] - packages: [1] ‘future’
[18:04:58.253] getGlobalsAndPackages() ... DONE
[18:04:58.254] run() for ‘Future’ ...
[18:04:58.254] - state: ‘created’
[18:04:58.255] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.262] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.262] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.262]   - Field: ‘label’
[18:04:58.263]   - Field: ‘local’
[18:04:58.263]   - Field: ‘owner’
[18:04:58.263]   - Field: ‘envir’
[18:04:58.263]   - Field: ‘workers’
[18:04:58.264]   - Field: ‘packages’
[18:04:58.264]   - Field: ‘gc’
[18:04:58.264]   - Field: ‘job’
[18:04:58.264]   - Field: ‘conditions’
[18:04:58.265]   - Field: ‘expr’
[18:04:58.265]   - Field: ‘uuid’
[18:04:58.265]   - Field: ‘seed’
[18:04:58.265]   - Field: ‘version’
[18:04:58.266]   - Field: ‘result’
[18:04:58.266]   - Field: ‘asynchronous’
[18:04:58.266]   - Field: ‘calls’
[18:04:58.266]   - Field: ‘globals’
[18:04:58.267]   - Field: ‘stdout’
[18:04:58.267]   - Field: ‘earlySignal’
[18:04:58.267]   - Field: ‘lazy’
[18:04:58.267]   - Field: ‘state’
[18:04:58.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.268] - Launch lazy future ...
[18:04:58.268] Packages needed by the future expression (n = 1): ‘future’
[18:04:58.272] Packages needed by future strategies (n = 0): <none>
[18:04:58.274] {
[18:04:58.274]     {
[18:04:58.274]         {
[18:04:58.274]             ...future.startTime <- base::Sys.time()
[18:04:58.274]             {
[18:04:58.274]                 {
[18:04:58.274]                   {
[18:04:58.274]                     {
[18:04:58.274]                       {
[18:04:58.274]                         base::local({
[18:04:58.274]                           has_future <- base::requireNamespace("future", 
[18:04:58.274]                             quietly = TRUE)
[18:04:58.274]                           if (has_future) {
[18:04:58.274]                             ns <- base::getNamespace("future")
[18:04:58.274]                             version <- ns[[".package"]][["version"]]
[18:04:58.274]                             if (is.null(version)) 
[18:04:58.274]                               version <- utils::packageVersion("future")
[18:04:58.274]                           }
[18:04:58.274]                           else {
[18:04:58.274]                             version <- NULL
[18:04:58.274]                           }
[18:04:58.274]                           if (!has_future || version < "1.8.0") {
[18:04:58.274]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.274]                               "", base::R.version$version.string), 
[18:04:58.274]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:58.274]                                 base::R.version$platform, 8 * 
[18:04:58.274]                                   base::.Machine$sizeof.pointer), 
[18:04:58.274]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.274]                                 "release", "version")], collapse = " "), 
[18:04:58.274]                               hostname = base::Sys.info()[["nodename"]])
[18:04:58.274]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.274]                               info)
[18:04:58.274]                             info <- base::paste(info, collapse = "; ")
[18:04:58.274]                             if (!has_future) {
[18:04:58.274]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.274]                                 info)
[18:04:58.274]                             }
[18:04:58.274]                             else {
[18:04:58.274]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.274]                                 info, version)
[18:04:58.274]                             }
[18:04:58.274]                             base::stop(msg)
[18:04:58.274]                           }
[18:04:58.274]                         })
[18:04:58.274]                       }
[18:04:58.274]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.274]                       base::options(mc.cores = 1L)
[18:04:58.274]                     }
[18:04:58.274]                     base::local({
[18:04:58.274]                       for (pkg in "future") {
[18:04:58.274]                         base::loadNamespace(pkg)
[18:04:58.274]                         base::library(pkg, character.only = TRUE)
[18:04:58.274]                       }
[18:04:58.274]                     })
[18:04:58.274]                   }
[18:04:58.274]                   ...future.strategy.old <- future::plan("list")
[18:04:58.274]                   options(future.plan = NULL)
[18:04:58.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.274]                 }
[18:04:58.274]                 ...future.workdir <- getwd()
[18:04:58.274]             }
[18:04:58.274]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.274]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.274]         }
[18:04:58.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.274]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.274]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.274]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.274]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.274]             base::names(...future.oldOptions))
[18:04:58.274]     }
[18:04:58.274]     if (FALSE) {
[18:04:58.274]     }
[18:04:58.274]     else {
[18:04:58.274]         if (TRUE) {
[18:04:58.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.274]                 open = "w")
[18:04:58.274]         }
[18:04:58.274]         else {
[18:04:58.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.274]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.274]         }
[18:04:58.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.274]             base::sink(type = "output", split = FALSE)
[18:04:58.274]             base::close(...future.stdout)
[18:04:58.274]         }, add = TRUE)
[18:04:58.274]     }
[18:04:58.274]     ...future.frame <- base::sys.nframe()
[18:04:58.274]     ...future.conditions <- base::list()
[18:04:58.274]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.274]     if (FALSE) {
[18:04:58.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.274]     }
[18:04:58.274]     ...future.result <- base::tryCatch({
[18:04:58.274]         base::withCallingHandlers({
[18:04:58.274]             ...future.value <- base::withVisible(base::local({
[18:04:58.274]                 withCallingHandlers({
[18:04:58.274]                   value(a) + 1
[18:04:58.274]                 }, immediateCondition = function(cond) {
[18:04:58.274]                   save_rds <- function (object, pathname, ...) 
[18:04:58.274]                   {
[18:04:58.274]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.274]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.274]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.274]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.274]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.274]                         fi_tmp[["mtime"]])
[18:04:58.274]                     }
[18:04:58.274]                     tryCatch({
[18:04:58.274]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.274]                     }, error = function(ex) {
[18:04:58.274]                       msg <- conditionMessage(ex)
[18:04:58.274]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.274]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.274]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.274]                         fi_tmp[["mtime"]], msg)
[18:04:58.274]                       ex$message <- msg
[18:04:58.274]                       stop(ex)
[18:04:58.274]                     })
[18:04:58.274]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.274]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.274]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.274]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.274]                       fi <- file.info(pathname)
[18:04:58.274]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.274]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.274]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.274]                         fi[["size"]], fi[["mtime"]])
[18:04:58.274]                       stop(msg)
[18:04:58.274]                     }
[18:04:58.274]                     invisible(pathname)
[18:04:58.274]                   }
[18:04:58.274]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.274]                     rootPath = tempdir()) 
[18:04:58.274]                   {
[18:04:58.274]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.274]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.274]                       tmpdir = path, fileext = ".rds")
[18:04:58.274]                     save_rds(obj, file)
[18:04:58.274]                   }
[18:04:58.274]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.274]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.274]                   {
[18:04:58.274]                     inherits <- base::inherits
[18:04:58.274]                     invokeRestart <- base::invokeRestart
[18:04:58.274]                     is.null <- base::is.null
[18:04:58.274]                     muffled <- FALSE
[18:04:58.274]                     if (inherits(cond, "message")) {
[18:04:58.274]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.274]                       if (muffled) 
[18:04:58.274]                         invokeRestart("muffleMessage")
[18:04:58.274]                     }
[18:04:58.274]                     else if (inherits(cond, "warning")) {
[18:04:58.274]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.274]                       if (muffled) 
[18:04:58.274]                         invokeRestart("muffleWarning")
[18:04:58.274]                     }
[18:04:58.274]                     else if (inherits(cond, "condition")) {
[18:04:58.274]                       if (!is.null(pattern)) {
[18:04:58.274]                         computeRestarts <- base::computeRestarts
[18:04:58.274]                         grepl <- base::grepl
[18:04:58.274]                         restarts <- computeRestarts(cond)
[18:04:58.274]                         for (restart in restarts) {
[18:04:58.274]                           name <- restart$name
[18:04:58.274]                           if (is.null(name)) 
[18:04:58.274]                             next
[18:04:58.274]                           if (!grepl(pattern, name)) 
[18:04:58.274]                             next
[18:04:58.274]                           invokeRestart(restart)
[18:04:58.274]                           muffled <- TRUE
[18:04:58.274]                           break
[18:04:58.274]                         }
[18:04:58.274]                       }
[18:04:58.274]                     }
[18:04:58.274]                     invisible(muffled)
[18:04:58.274]                   }
[18:04:58.274]                   muffleCondition(cond)
[18:04:58.274]                 })
[18:04:58.274]             }))
[18:04:58.274]             future::FutureResult(value = ...future.value$value, 
[18:04:58.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.274]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.274]                     ...future.globalenv.names))
[18:04:58.274]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.274]         }, condition = base::local({
[18:04:58.274]             c <- base::c
[18:04:58.274]             inherits <- base::inherits
[18:04:58.274]             invokeRestart <- base::invokeRestart
[18:04:58.274]             length <- base::length
[18:04:58.274]             list <- base::list
[18:04:58.274]             seq.int <- base::seq.int
[18:04:58.274]             signalCondition <- base::signalCondition
[18:04:58.274]             sys.calls <- base::sys.calls
[18:04:58.274]             `[[` <- base::`[[`
[18:04:58.274]             `+` <- base::`+`
[18:04:58.274]             `<<-` <- base::`<<-`
[18:04:58.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.274]                   3L)]
[18:04:58.274]             }
[18:04:58.274]             function(cond) {
[18:04:58.274]                 is_error <- inherits(cond, "error")
[18:04:58.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.274]                   NULL)
[18:04:58.274]                 if (is_error) {
[18:04:58.274]                   sessionInformation <- function() {
[18:04:58.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.274]                       search = base::search(), system = base::Sys.info())
[18:04:58.274]                   }
[18:04:58.274]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.274]                     cond$call), session = sessionInformation(), 
[18:04:58.274]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.274]                   signalCondition(cond)
[18:04:58.274]                 }
[18:04:58.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.274]                 "immediateCondition"))) {
[18:04:58.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.274]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.274]                   if (TRUE && !signal) {
[18:04:58.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.274]                     {
[18:04:58.274]                       inherits <- base::inherits
[18:04:58.274]                       invokeRestart <- base::invokeRestart
[18:04:58.274]                       is.null <- base::is.null
[18:04:58.274]                       muffled <- FALSE
[18:04:58.274]                       if (inherits(cond, "message")) {
[18:04:58.274]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.274]                         if (muffled) 
[18:04:58.274]                           invokeRestart("muffleMessage")
[18:04:58.274]                       }
[18:04:58.274]                       else if (inherits(cond, "warning")) {
[18:04:58.274]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.274]                         if (muffled) 
[18:04:58.274]                           invokeRestart("muffleWarning")
[18:04:58.274]                       }
[18:04:58.274]                       else if (inherits(cond, "condition")) {
[18:04:58.274]                         if (!is.null(pattern)) {
[18:04:58.274]                           computeRestarts <- base::computeRestarts
[18:04:58.274]                           grepl <- base::grepl
[18:04:58.274]                           restarts <- computeRestarts(cond)
[18:04:58.274]                           for (restart in restarts) {
[18:04:58.274]                             name <- restart$name
[18:04:58.274]                             if (is.null(name)) 
[18:04:58.274]                               next
[18:04:58.274]                             if (!grepl(pattern, name)) 
[18:04:58.274]                               next
[18:04:58.274]                             invokeRestart(restart)
[18:04:58.274]                             muffled <- TRUE
[18:04:58.274]                             break
[18:04:58.274]                           }
[18:04:58.274]                         }
[18:04:58.274]                       }
[18:04:58.274]                       invisible(muffled)
[18:04:58.274]                     }
[18:04:58.274]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.274]                   }
[18:04:58.274]                 }
[18:04:58.274]                 else {
[18:04:58.274]                   if (TRUE) {
[18:04:58.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.274]                     {
[18:04:58.274]                       inherits <- base::inherits
[18:04:58.274]                       invokeRestart <- base::invokeRestart
[18:04:58.274]                       is.null <- base::is.null
[18:04:58.274]                       muffled <- FALSE
[18:04:58.274]                       if (inherits(cond, "message")) {
[18:04:58.274]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.274]                         if (muffled) 
[18:04:58.274]                           invokeRestart("muffleMessage")
[18:04:58.274]                       }
[18:04:58.274]                       else if (inherits(cond, "warning")) {
[18:04:58.274]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.274]                         if (muffled) 
[18:04:58.274]                           invokeRestart("muffleWarning")
[18:04:58.274]                       }
[18:04:58.274]                       else if (inherits(cond, "condition")) {
[18:04:58.274]                         if (!is.null(pattern)) {
[18:04:58.274]                           computeRestarts <- base::computeRestarts
[18:04:58.274]                           grepl <- base::grepl
[18:04:58.274]                           restarts <- computeRestarts(cond)
[18:04:58.274]                           for (restart in restarts) {
[18:04:58.274]                             name <- restart$name
[18:04:58.274]                             if (is.null(name)) 
[18:04:58.274]                               next
[18:04:58.274]                             if (!grepl(pattern, name)) 
[18:04:58.274]                               next
[18:04:58.274]                             invokeRestart(restart)
[18:04:58.274]                             muffled <- TRUE
[18:04:58.274]                             break
[18:04:58.274]                           }
[18:04:58.274]                         }
[18:04:58.274]                       }
[18:04:58.274]                       invisible(muffled)
[18:04:58.274]                     }
[18:04:58.274]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.274]                   }
[18:04:58.274]                 }
[18:04:58.274]             }
[18:04:58.274]         }))
[18:04:58.274]     }, error = function(ex) {
[18:04:58.274]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.274]                 ...future.rng), started = ...future.startTime, 
[18:04:58.274]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.274]             version = "1.8"), class = "FutureResult")
[18:04:58.274]     }, finally = {
[18:04:58.274]         if (!identical(...future.workdir, getwd())) 
[18:04:58.274]             setwd(...future.workdir)
[18:04:58.274]         {
[18:04:58.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.274]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.274]             }
[18:04:58.274]             base::options(...future.oldOptions)
[18:04:58.274]             if (.Platform$OS.type == "windows") {
[18:04:58.274]                 old_names <- names(...future.oldEnvVars)
[18:04:58.274]                 envs <- base::Sys.getenv()
[18:04:58.274]                 names <- names(envs)
[18:04:58.274]                 common <- intersect(names, old_names)
[18:04:58.274]                 added <- setdiff(names, old_names)
[18:04:58.274]                 removed <- setdiff(old_names, names)
[18:04:58.274]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.274]                   envs[common]]
[18:04:58.274]                 NAMES <- toupper(changed)
[18:04:58.274]                 args <- list()
[18:04:58.274]                 for (kk in seq_along(NAMES)) {
[18:04:58.274]                   name <- changed[[kk]]
[18:04:58.274]                   NAME <- NAMES[[kk]]
[18:04:58.274]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.274]                     next
[18:04:58.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.274]                 }
[18:04:58.274]                 NAMES <- toupper(added)
[18:04:58.274]                 for (kk in seq_along(NAMES)) {
[18:04:58.274]                   name <- added[[kk]]
[18:04:58.274]                   NAME <- NAMES[[kk]]
[18:04:58.274]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.274]                     next
[18:04:58.274]                   args[[name]] <- ""
[18:04:58.274]                 }
[18:04:58.274]                 NAMES <- toupper(removed)
[18:04:58.274]                 for (kk in seq_along(NAMES)) {
[18:04:58.274]                   name <- removed[[kk]]
[18:04:58.274]                   NAME <- NAMES[[kk]]
[18:04:58.274]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.274]                     next
[18:04:58.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.274]                 }
[18:04:58.274]                 if (length(args) > 0) 
[18:04:58.274]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.274]             }
[18:04:58.274]             else {
[18:04:58.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.274]             }
[18:04:58.274]             {
[18:04:58.274]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.274]                   0L) {
[18:04:58.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.274]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.274]                   base::options(opts)
[18:04:58.274]                 }
[18:04:58.274]                 {
[18:04:58.274]                   {
[18:04:58.274]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.274]                     NULL
[18:04:58.274]                   }
[18:04:58.274]                   options(future.plan = NULL)
[18:04:58.274]                   if (is.na(NA_character_)) 
[18:04:58.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.274]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.274]                     .init = FALSE)
[18:04:58.274]                 }
[18:04:58.274]             }
[18:04:58.274]         }
[18:04:58.274]     })
[18:04:58.274]     if (TRUE) {
[18:04:58.274]         base::sink(type = "output", split = FALSE)
[18:04:58.274]         if (TRUE) {
[18:04:58.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.274]         }
[18:04:58.274]         else {
[18:04:58.274]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.274]         }
[18:04:58.274]         base::close(...future.stdout)
[18:04:58.274]         ...future.stdout <- NULL
[18:04:58.274]     }
[18:04:58.274]     ...future.result$conditions <- ...future.conditions
[18:04:58.274]     ...future.result$finished <- base::Sys.time()
[18:04:58.274]     ...future.result
[18:04:58.274] }
[18:04:58.278] assign_globals() ...
[18:04:58.278] List of 1
[18:04:58.278]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5b9576541b70> 
[18:04:58.278]  - attr(*, "where")=List of 1
[18:04:58.278]   ..$ a:<environment: R_EmptyEnv> 
[18:04:58.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:58.278]  - attr(*, "resolved")= logi TRUE
[18:04:58.278]  - attr(*, "total_size")= num 1649944
[18:04:58.278]  - attr(*, "already-done")= logi TRUE
[18:04:58.284] - copied ‘a’ to environment
[18:04:58.284] assign_globals() ... done
[18:04:58.285] requestCore(): workers = 2
[18:04:58.288] MulticoreFuture started
[18:04:58.290] - Launch lazy future ... done
[18:04:58.291] run() for ‘MulticoreFuture’ ... done
[18:04:58.292] result() for MulticoreFuture ...
[18:04:58.292] plan(): Setting new future strategy stack:
[18:04:58.292] List of future strategies:
[18:04:58.292] 1. sequential:
[18:04:58.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.292]    - tweaked: FALSE
[18:04:58.292]    - call: NULL
[18:04:58.296] plan(): nbrOfWorkers() = 1
[18:04:58.307] plan(): Setting new future strategy stack:
[18:04:58.307] List of future strategies:
[18:04:58.307] 1. multicore:
[18:04:58.307]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.307]    - tweaked: FALSE
[18:04:58.307]    - call: plan(strategy)
[18:04:58.317] plan(): nbrOfWorkers() = 2
[18:04:58.319] result() for MulticoreFuture ...
[18:04:58.320] result() for MulticoreFuture ... done
[18:04:58.320] signalConditions() ...
[18:04:58.321]  - include = ‘immediateCondition’
[18:04:58.321]  - exclude = 
[18:04:58.321]  - resignal = FALSE
[18:04:58.322]  - Number of conditions: 4
[18:04:58.322] signalConditions() ... done
[18:04:58.322] result() for MulticoreFuture ... done
[18:04:58.323] result() for MulticoreFuture ...
[18:04:58.323] result() for MulticoreFuture ... done
[18:04:58.324] signalConditions() ...
[18:04:58.324]  - include = ‘immediateCondition’
[18:04:58.324]  - exclude = 
[18:04:58.325]  - resignal = FALSE
[18:04:58.325]  - Number of conditions: 4
[18:04:58.325] signalConditions() ... done
[18:04:58.325] Future state: ‘finished’
[18:04:58.326] result() for MulticoreFuture ...
[18:04:58.326] result() for MulticoreFuture ... done
[18:04:58.326] signalConditions() ...
[18:04:58.326]  - include = ‘condition’
[18:04:58.327]  - exclude = ‘immediateCondition’
[18:04:58.327]  - resignal = TRUE
[18:04:58.327]  - Number of conditions: 4
[18:04:58.327]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.300] result() for MulticoreFuture ...
[18:04:58.328]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.301] result() for MulticoreFuture ... done
[18:04:58.328]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.302] result() for MulticoreFuture ...
[18:04:58.329]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.303] result() for MulticoreFuture ... done
[18:04:58.329] signalConditions() ... done
value(b) = 2
[18:04:58.329] result() for MulticoreFuture ...
[18:04:58.330] result() for MulticoreFuture ... done
[18:04:58.330] result() for MulticoreFuture ...
[18:04:58.330] result() for MulticoreFuture ... done
[18:04:58.330] signalConditions() ...
[18:04:58.331]  - include = ‘immediateCondition’
[18:04:58.331]  - exclude = 
[18:04:58.331]  - resignal = FALSE
[18:04:58.331]  - Number of conditions: 4
[18:04:58.331] signalConditions() ... done
[18:04:58.332] Future state: ‘finished’
[18:04:58.332] result() for MulticoreFuture ...
[18:04:58.332] result() for MulticoreFuture ... done
[18:04:58.332] signalConditions() ...
[18:04:58.333]  - include = ‘condition’
[18:04:58.333]  - exclude = ‘immediateCondition’
[18:04:58.333]  - resignal = TRUE
[18:04:58.333]  - Number of conditions: 4
[18:04:58.334]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.300] result() for MulticoreFuture ...
[18:04:58.334]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.301] result() for MulticoreFuture ... done
[18:04:58.334]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.302] result() for MulticoreFuture ...
[18:04:58.335]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.303] result() for MulticoreFuture ... done
[18:04:58.335] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.335] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.336] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.337] 
[18:04:58.337] Searching for globals ... DONE
[18:04:58.337] - globals: [0] <none>
[18:04:58.338] getGlobalsAndPackages() ... DONE
[18:04:58.338] run() for ‘Future’ ...
[18:04:58.338] - state: ‘created’
[18:04:58.339] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.346] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.347]   - Field: ‘label’
[18:04:58.347]   - Field: ‘local’
[18:04:58.347]   - Field: ‘owner’
[18:04:58.348]   - Field: ‘envir’
[18:04:58.348]   - Field: ‘workers’
[18:04:58.348]   - Field: ‘packages’
[18:04:58.348]   - Field: ‘gc’
[18:04:58.349]   - Field: ‘job’
[18:04:58.349]   - Field: ‘conditions’
[18:04:58.349]   - Field: ‘expr’
[18:04:58.349]   - Field: ‘uuid’
[18:04:58.350]   - Field: ‘seed’
[18:04:58.350]   - Field: ‘version’
[18:04:58.350]   - Field: ‘result’
[18:04:58.350]   - Field: ‘asynchronous’
[18:04:58.350]   - Field: ‘calls’
[18:04:58.351]   - Field: ‘globals’
[18:04:58.351]   - Field: ‘stdout’
[18:04:58.351]   - Field: ‘earlySignal’
[18:04:58.351]   - Field: ‘lazy’
[18:04:58.352]   - Field: ‘state’
[18:04:58.352] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.352] - Launch lazy future ...
[18:04:58.353] Packages needed by the future expression (n = 0): <none>
[18:04:58.353] Packages needed by future strategies (n = 0): <none>
[18:04:58.354] {
[18:04:58.354]     {
[18:04:58.354]         {
[18:04:58.354]             ...future.startTime <- base::Sys.time()
[18:04:58.354]             {
[18:04:58.354]                 {
[18:04:58.354]                   {
[18:04:58.354]                     {
[18:04:58.354]                       base::local({
[18:04:58.354]                         has_future <- base::requireNamespace("future", 
[18:04:58.354]                           quietly = TRUE)
[18:04:58.354]                         if (has_future) {
[18:04:58.354]                           ns <- base::getNamespace("future")
[18:04:58.354]                           version <- ns[[".package"]][["version"]]
[18:04:58.354]                           if (is.null(version)) 
[18:04:58.354]                             version <- utils::packageVersion("future")
[18:04:58.354]                         }
[18:04:58.354]                         else {
[18:04:58.354]                           version <- NULL
[18:04:58.354]                         }
[18:04:58.354]                         if (!has_future || version < "1.8.0") {
[18:04:58.354]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.354]                             "", base::R.version$version.string), 
[18:04:58.354]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:58.354]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:58.354]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.354]                               "release", "version")], collapse = " "), 
[18:04:58.354]                             hostname = base::Sys.info()[["nodename"]])
[18:04:58.354]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.354]                             info)
[18:04:58.354]                           info <- base::paste(info, collapse = "; ")
[18:04:58.354]                           if (!has_future) {
[18:04:58.354]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.354]                               info)
[18:04:58.354]                           }
[18:04:58.354]                           else {
[18:04:58.354]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.354]                               info, version)
[18:04:58.354]                           }
[18:04:58.354]                           base::stop(msg)
[18:04:58.354]                         }
[18:04:58.354]                       })
[18:04:58.354]                     }
[18:04:58.354]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.354]                     base::options(mc.cores = 1L)
[18:04:58.354]                   }
[18:04:58.354]                   ...future.strategy.old <- future::plan("list")
[18:04:58.354]                   options(future.plan = NULL)
[18:04:58.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.354]                 }
[18:04:58.354]                 ...future.workdir <- getwd()
[18:04:58.354]             }
[18:04:58.354]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.354]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.354]         }
[18:04:58.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.354]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.354]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.354]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.354]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.354]             base::names(...future.oldOptions))
[18:04:58.354]     }
[18:04:58.354]     if (FALSE) {
[18:04:58.354]     }
[18:04:58.354]     else {
[18:04:58.354]         if (TRUE) {
[18:04:58.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.354]                 open = "w")
[18:04:58.354]         }
[18:04:58.354]         else {
[18:04:58.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.354]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.354]         }
[18:04:58.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.354]             base::sink(type = "output", split = FALSE)
[18:04:58.354]             base::close(...future.stdout)
[18:04:58.354]         }, add = TRUE)
[18:04:58.354]     }
[18:04:58.354]     ...future.frame <- base::sys.nframe()
[18:04:58.354]     ...future.conditions <- base::list()
[18:04:58.354]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.354]     if (FALSE) {
[18:04:58.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.354]     }
[18:04:58.354]     ...future.result <- base::tryCatch({
[18:04:58.354]         base::withCallingHandlers({
[18:04:58.354]             ...future.value <- base::withVisible(base::local({
[18:04:58.354]                 withCallingHandlers({
[18:04:58.354]                   1
[18:04:58.354]                 }, immediateCondition = function(cond) {
[18:04:58.354]                   save_rds <- function (object, pathname, ...) 
[18:04:58.354]                   {
[18:04:58.354]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.354]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.354]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.354]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.354]                         fi_tmp[["mtime"]])
[18:04:58.354]                     }
[18:04:58.354]                     tryCatch({
[18:04:58.354]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.354]                     }, error = function(ex) {
[18:04:58.354]                       msg <- conditionMessage(ex)
[18:04:58.354]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.354]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.354]                         fi_tmp[["mtime"]], msg)
[18:04:58.354]                       ex$message <- msg
[18:04:58.354]                       stop(ex)
[18:04:58.354]                     })
[18:04:58.354]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.354]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.354]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.354]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.354]                       fi <- file.info(pathname)
[18:04:58.354]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.354]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.354]                         fi[["size"]], fi[["mtime"]])
[18:04:58.354]                       stop(msg)
[18:04:58.354]                     }
[18:04:58.354]                     invisible(pathname)
[18:04:58.354]                   }
[18:04:58.354]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.354]                     rootPath = tempdir()) 
[18:04:58.354]                   {
[18:04:58.354]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.354]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.354]                       tmpdir = path, fileext = ".rds")
[18:04:58.354]                     save_rds(obj, file)
[18:04:58.354]                   }
[18:04:58.354]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.354]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.354]                   {
[18:04:58.354]                     inherits <- base::inherits
[18:04:58.354]                     invokeRestart <- base::invokeRestart
[18:04:58.354]                     is.null <- base::is.null
[18:04:58.354]                     muffled <- FALSE
[18:04:58.354]                     if (inherits(cond, "message")) {
[18:04:58.354]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.354]                       if (muffled) 
[18:04:58.354]                         invokeRestart("muffleMessage")
[18:04:58.354]                     }
[18:04:58.354]                     else if (inherits(cond, "warning")) {
[18:04:58.354]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.354]                       if (muffled) 
[18:04:58.354]                         invokeRestart("muffleWarning")
[18:04:58.354]                     }
[18:04:58.354]                     else if (inherits(cond, "condition")) {
[18:04:58.354]                       if (!is.null(pattern)) {
[18:04:58.354]                         computeRestarts <- base::computeRestarts
[18:04:58.354]                         grepl <- base::grepl
[18:04:58.354]                         restarts <- computeRestarts(cond)
[18:04:58.354]                         for (restart in restarts) {
[18:04:58.354]                           name <- restart$name
[18:04:58.354]                           if (is.null(name)) 
[18:04:58.354]                             next
[18:04:58.354]                           if (!grepl(pattern, name)) 
[18:04:58.354]                             next
[18:04:58.354]                           invokeRestart(restart)
[18:04:58.354]                           muffled <- TRUE
[18:04:58.354]                           break
[18:04:58.354]                         }
[18:04:58.354]                       }
[18:04:58.354]                     }
[18:04:58.354]                     invisible(muffled)
[18:04:58.354]                   }
[18:04:58.354]                   muffleCondition(cond)
[18:04:58.354]                 })
[18:04:58.354]             }))
[18:04:58.354]             future::FutureResult(value = ...future.value$value, 
[18:04:58.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.354]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.354]                     ...future.globalenv.names))
[18:04:58.354]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.354]         }, condition = base::local({
[18:04:58.354]             c <- base::c
[18:04:58.354]             inherits <- base::inherits
[18:04:58.354]             invokeRestart <- base::invokeRestart
[18:04:58.354]             length <- base::length
[18:04:58.354]             list <- base::list
[18:04:58.354]             seq.int <- base::seq.int
[18:04:58.354]             signalCondition <- base::signalCondition
[18:04:58.354]             sys.calls <- base::sys.calls
[18:04:58.354]             `[[` <- base::`[[`
[18:04:58.354]             `+` <- base::`+`
[18:04:58.354]             `<<-` <- base::`<<-`
[18:04:58.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.354]                   3L)]
[18:04:58.354]             }
[18:04:58.354]             function(cond) {
[18:04:58.354]                 is_error <- inherits(cond, "error")
[18:04:58.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.354]                   NULL)
[18:04:58.354]                 if (is_error) {
[18:04:58.354]                   sessionInformation <- function() {
[18:04:58.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.354]                       search = base::search(), system = base::Sys.info())
[18:04:58.354]                   }
[18:04:58.354]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.354]                     cond$call), session = sessionInformation(), 
[18:04:58.354]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.354]                   signalCondition(cond)
[18:04:58.354]                 }
[18:04:58.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.354]                 "immediateCondition"))) {
[18:04:58.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.354]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.354]                   if (TRUE && !signal) {
[18:04:58.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.354]                     {
[18:04:58.354]                       inherits <- base::inherits
[18:04:58.354]                       invokeRestart <- base::invokeRestart
[18:04:58.354]                       is.null <- base::is.null
[18:04:58.354]                       muffled <- FALSE
[18:04:58.354]                       if (inherits(cond, "message")) {
[18:04:58.354]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.354]                         if (muffled) 
[18:04:58.354]                           invokeRestart("muffleMessage")
[18:04:58.354]                       }
[18:04:58.354]                       else if (inherits(cond, "warning")) {
[18:04:58.354]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.354]                         if (muffled) 
[18:04:58.354]                           invokeRestart("muffleWarning")
[18:04:58.354]                       }
[18:04:58.354]                       else if (inherits(cond, "condition")) {
[18:04:58.354]                         if (!is.null(pattern)) {
[18:04:58.354]                           computeRestarts <- base::computeRestarts
[18:04:58.354]                           grepl <- base::grepl
[18:04:58.354]                           restarts <- computeRestarts(cond)
[18:04:58.354]                           for (restart in restarts) {
[18:04:58.354]                             name <- restart$name
[18:04:58.354]                             if (is.null(name)) 
[18:04:58.354]                               next
[18:04:58.354]                             if (!grepl(pattern, name)) 
[18:04:58.354]                               next
[18:04:58.354]                             invokeRestart(restart)
[18:04:58.354]                             muffled <- TRUE
[18:04:58.354]                             break
[18:04:58.354]                           }
[18:04:58.354]                         }
[18:04:58.354]                       }
[18:04:58.354]                       invisible(muffled)
[18:04:58.354]                     }
[18:04:58.354]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.354]                   }
[18:04:58.354]                 }
[18:04:58.354]                 else {
[18:04:58.354]                   if (TRUE) {
[18:04:58.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.354]                     {
[18:04:58.354]                       inherits <- base::inherits
[18:04:58.354]                       invokeRestart <- base::invokeRestart
[18:04:58.354]                       is.null <- base::is.null
[18:04:58.354]                       muffled <- FALSE
[18:04:58.354]                       if (inherits(cond, "message")) {
[18:04:58.354]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.354]                         if (muffled) 
[18:04:58.354]                           invokeRestart("muffleMessage")
[18:04:58.354]                       }
[18:04:58.354]                       else if (inherits(cond, "warning")) {
[18:04:58.354]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.354]                         if (muffled) 
[18:04:58.354]                           invokeRestart("muffleWarning")
[18:04:58.354]                       }
[18:04:58.354]                       else if (inherits(cond, "condition")) {
[18:04:58.354]                         if (!is.null(pattern)) {
[18:04:58.354]                           computeRestarts <- base::computeRestarts
[18:04:58.354]                           grepl <- base::grepl
[18:04:58.354]                           restarts <- computeRestarts(cond)
[18:04:58.354]                           for (restart in restarts) {
[18:04:58.354]                             name <- restart$name
[18:04:58.354]                             if (is.null(name)) 
[18:04:58.354]                               next
[18:04:58.354]                             if (!grepl(pattern, name)) 
[18:04:58.354]                               next
[18:04:58.354]                             invokeRestart(restart)
[18:04:58.354]                             muffled <- TRUE
[18:04:58.354]                             break
[18:04:58.354]                           }
[18:04:58.354]                         }
[18:04:58.354]                       }
[18:04:58.354]                       invisible(muffled)
[18:04:58.354]                     }
[18:04:58.354]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.354]                   }
[18:04:58.354]                 }
[18:04:58.354]             }
[18:04:58.354]         }))
[18:04:58.354]     }, error = function(ex) {
[18:04:58.354]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.354]                 ...future.rng), started = ...future.startTime, 
[18:04:58.354]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.354]             version = "1.8"), class = "FutureResult")
[18:04:58.354]     }, finally = {
[18:04:58.354]         if (!identical(...future.workdir, getwd())) 
[18:04:58.354]             setwd(...future.workdir)
[18:04:58.354]         {
[18:04:58.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.354]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.354]             }
[18:04:58.354]             base::options(...future.oldOptions)
[18:04:58.354]             if (.Platform$OS.type == "windows") {
[18:04:58.354]                 old_names <- names(...future.oldEnvVars)
[18:04:58.354]                 envs <- base::Sys.getenv()
[18:04:58.354]                 names <- names(envs)
[18:04:58.354]                 common <- intersect(names, old_names)
[18:04:58.354]                 added <- setdiff(names, old_names)
[18:04:58.354]                 removed <- setdiff(old_names, names)
[18:04:58.354]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.354]                   envs[common]]
[18:04:58.354]                 NAMES <- toupper(changed)
[18:04:58.354]                 args <- list()
[18:04:58.354]                 for (kk in seq_along(NAMES)) {
[18:04:58.354]                   name <- changed[[kk]]
[18:04:58.354]                   NAME <- NAMES[[kk]]
[18:04:58.354]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.354]                     next
[18:04:58.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.354]                 }
[18:04:58.354]                 NAMES <- toupper(added)
[18:04:58.354]                 for (kk in seq_along(NAMES)) {
[18:04:58.354]                   name <- added[[kk]]
[18:04:58.354]                   NAME <- NAMES[[kk]]
[18:04:58.354]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.354]                     next
[18:04:58.354]                   args[[name]] <- ""
[18:04:58.354]                 }
[18:04:58.354]                 NAMES <- toupper(removed)
[18:04:58.354]                 for (kk in seq_along(NAMES)) {
[18:04:58.354]                   name <- removed[[kk]]
[18:04:58.354]                   NAME <- NAMES[[kk]]
[18:04:58.354]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.354]                     next
[18:04:58.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.354]                 }
[18:04:58.354]                 if (length(args) > 0) 
[18:04:58.354]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.354]             }
[18:04:58.354]             else {
[18:04:58.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.354]             }
[18:04:58.354]             {
[18:04:58.354]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.354]                   0L) {
[18:04:58.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.354]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.354]                   base::options(opts)
[18:04:58.354]                 }
[18:04:58.354]                 {
[18:04:58.354]                   {
[18:04:58.354]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.354]                     NULL
[18:04:58.354]                   }
[18:04:58.354]                   options(future.plan = NULL)
[18:04:58.354]                   if (is.na(NA_character_)) 
[18:04:58.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.354]                     .init = FALSE)
[18:04:58.354]                 }
[18:04:58.354]             }
[18:04:58.354]         }
[18:04:58.354]     })
[18:04:58.354]     if (TRUE) {
[18:04:58.354]         base::sink(type = "output", split = FALSE)
[18:04:58.354]         if (TRUE) {
[18:04:58.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.354]         }
[18:04:58.354]         else {
[18:04:58.354]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.354]         }
[18:04:58.354]         base::close(...future.stdout)
[18:04:58.354]         ...future.stdout <- NULL
[18:04:58.354]     }
[18:04:58.354]     ...future.result$conditions <- ...future.conditions
[18:04:58.354]     ...future.result$finished <- base::Sys.time()
[18:04:58.354]     ...future.result
[18:04:58.354] }
[18:04:58.359] requestCore(): workers = 2
[18:04:58.362] MulticoreFuture started
[18:04:58.363] - Launch lazy future ... done
[18:04:58.363] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.364] plan(): Setting new future strategy stack:
[18:04:58.365] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.365] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.365] List of future strategies:
[18:04:58.365] 1. sequential:
[18:04:58.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.365]    - tweaked: FALSE
[18:04:58.365]    - call: NULL
[18:04:58.369] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:58.369] plan(): nbrOfWorkers() = 1
[18:04:58.369] Searching for globals ... DONE
[18:04:58.370] Resolving globals: TRUE
[18:04:58.370] Resolving any globals that are futures ...
[18:04:58.371] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:58.371] Resolving any globals that are futures ... DONE
[18:04:58.373] Resolving futures part of globals (recursively) ...
[18:04:58.376] resolve() on list ...
[18:04:58.376]  recursive: 99
[18:04:58.376]  length: 1
[18:04:58.377]  elements: ‘a’
[18:04:58.379] plan(): Setting new future strategy stack:
[18:04:58.379] List of future strategies:
[18:04:58.379] 1. multicore:
[18:04:58.379]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.379]    - tweaked: FALSE
[18:04:58.379]    - call: plan(strategy)
[18:04:58.388] plan(): nbrOfWorkers() = 2
[18:04:58.399] Future #1
[18:04:58.399] result() for MulticoreFuture ...
[18:04:58.401] result() for MulticoreFuture ...
[18:04:58.402] result() for MulticoreFuture ... done
[18:04:58.402] result() for MulticoreFuture ... done
[18:04:58.402] result() for MulticoreFuture ...
[18:04:58.403] result() for MulticoreFuture ... done
[18:04:58.403] A MulticoreFuture was resolved
[18:04:58.404]  length: 0 (resolved future 1)
[18:04:58.404] resolve() on list ... DONE
[18:04:58.404] - globals: [1] ‘a’
[18:04:58.404] Resolving futures part of globals (recursively) ... DONE
[18:04:58.414] The total size of the 1 globals is 1.57 MiB (1649944 bytes)
[18:04:58.415] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[18:04:58.415] - globals: [1] ‘a’
[18:04:58.416] - packages: [1] ‘future’
[18:04:58.416] getGlobalsAndPackages() ... DONE
[18:04:58.417] run() for ‘Future’ ...
[18:04:58.417] - state: ‘created’
[18:04:58.417] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.425] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.426]   - Field: ‘label’
[18:04:58.426]   - Field: ‘local’
[18:04:58.426]   - Field: ‘owner’
[18:04:58.426]   - Field: ‘envir’
[18:04:58.427]   - Field: ‘workers’
[18:04:58.427]   - Field: ‘packages’
[18:04:58.427]   - Field: ‘gc’
[18:04:58.427]   - Field: ‘job’
[18:04:58.428]   - Field: ‘conditions’
[18:04:58.428]   - Field: ‘expr’
[18:04:58.428]   - Field: ‘uuid’
[18:04:58.428]   - Field: ‘seed’
[18:04:58.429]   - Field: ‘version’
[18:04:58.429]   - Field: ‘result’
[18:04:58.429]   - Field: ‘asynchronous’
[18:04:58.430]   - Field: ‘calls’
[18:04:58.430]   - Field: ‘globals’
[18:04:58.430]   - Field: ‘stdout’
[18:04:58.431]   - Field: ‘earlySignal’
[18:04:58.431]   - Field: ‘lazy’
[18:04:58.431]   - Field: ‘state’
[18:04:58.431] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.432] - Launch lazy future ...
[18:04:58.432] Packages needed by the future expression (n = 1): ‘future’
[18:04:58.433] Packages needed by future strategies (n = 0): <none>
[18:04:58.434] {
[18:04:58.434]     {
[18:04:58.434]         {
[18:04:58.434]             ...future.startTime <- base::Sys.time()
[18:04:58.434]             {
[18:04:58.434]                 {
[18:04:58.434]                   {
[18:04:58.434]                     {
[18:04:58.434]                       {
[18:04:58.434]                         base::local({
[18:04:58.434]                           has_future <- base::requireNamespace("future", 
[18:04:58.434]                             quietly = TRUE)
[18:04:58.434]                           if (has_future) {
[18:04:58.434]                             ns <- base::getNamespace("future")
[18:04:58.434]                             version <- ns[[".package"]][["version"]]
[18:04:58.434]                             if (is.null(version)) 
[18:04:58.434]                               version <- utils::packageVersion("future")
[18:04:58.434]                           }
[18:04:58.434]                           else {
[18:04:58.434]                             version <- NULL
[18:04:58.434]                           }
[18:04:58.434]                           if (!has_future || version < "1.8.0") {
[18:04:58.434]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.434]                               "", base::R.version$version.string), 
[18:04:58.434]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:58.434]                                 base::R.version$platform, 8 * 
[18:04:58.434]                                   base::.Machine$sizeof.pointer), 
[18:04:58.434]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.434]                                 "release", "version")], collapse = " "), 
[18:04:58.434]                               hostname = base::Sys.info()[["nodename"]])
[18:04:58.434]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.434]                               info)
[18:04:58.434]                             info <- base::paste(info, collapse = "; ")
[18:04:58.434]                             if (!has_future) {
[18:04:58.434]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.434]                                 info)
[18:04:58.434]                             }
[18:04:58.434]                             else {
[18:04:58.434]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.434]                                 info, version)
[18:04:58.434]                             }
[18:04:58.434]                             base::stop(msg)
[18:04:58.434]                           }
[18:04:58.434]                         })
[18:04:58.434]                       }
[18:04:58.434]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.434]                       base::options(mc.cores = 1L)
[18:04:58.434]                     }
[18:04:58.434]                     base::local({
[18:04:58.434]                       for (pkg in "future") {
[18:04:58.434]                         base::loadNamespace(pkg)
[18:04:58.434]                         base::library(pkg, character.only = TRUE)
[18:04:58.434]                       }
[18:04:58.434]                     })
[18:04:58.434]                   }
[18:04:58.434]                   ...future.strategy.old <- future::plan("list")
[18:04:58.434]                   options(future.plan = NULL)
[18:04:58.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.434]                 }
[18:04:58.434]                 ...future.workdir <- getwd()
[18:04:58.434]             }
[18:04:58.434]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.434]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.434]         }
[18:04:58.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.434]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.434]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.434]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.434]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.434]             base::names(...future.oldOptions))
[18:04:58.434]     }
[18:04:58.434]     if (FALSE) {
[18:04:58.434]     }
[18:04:58.434]     else {
[18:04:58.434]         if (TRUE) {
[18:04:58.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.434]                 open = "w")
[18:04:58.434]         }
[18:04:58.434]         else {
[18:04:58.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.434]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.434]         }
[18:04:58.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.434]             base::sink(type = "output", split = FALSE)
[18:04:58.434]             base::close(...future.stdout)
[18:04:58.434]         }, add = TRUE)
[18:04:58.434]     }
[18:04:58.434]     ...future.frame <- base::sys.nframe()
[18:04:58.434]     ...future.conditions <- base::list()
[18:04:58.434]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.434]     if (FALSE) {
[18:04:58.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.434]     }
[18:04:58.434]     ...future.result <- base::tryCatch({
[18:04:58.434]         base::withCallingHandlers({
[18:04:58.434]             ...future.value <- base::withVisible(base::local({
[18:04:58.434]                 withCallingHandlers({
[18:04:58.434]                   value(a) + 1
[18:04:58.434]                 }, immediateCondition = function(cond) {
[18:04:58.434]                   save_rds <- function (object, pathname, ...) 
[18:04:58.434]                   {
[18:04:58.434]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.434]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.434]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.434]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.434]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.434]                         fi_tmp[["mtime"]])
[18:04:58.434]                     }
[18:04:58.434]                     tryCatch({
[18:04:58.434]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.434]                     }, error = function(ex) {
[18:04:58.434]                       msg <- conditionMessage(ex)
[18:04:58.434]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.434]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.434]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.434]                         fi_tmp[["mtime"]], msg)
[18:04:58.434]                       ex$message <- msg
[18:04:58.434]                       stop(ex)
[18:04:58.434]                     })
[18:04:58.434]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.434]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.434]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.434]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.434]                       fi <- file.info(pathname)
[18:04:58.434]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.434]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.434]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.434]                         fi[["size"]], fi[["mtime"]])
[18:04:58.434]                       stop(msg)
[18:04:58.434]                     }
[18:04:58.434]                     invisible(pathname)
[18:04:58.434]                   }
[18:04:58.434]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.434]                     rootPath = tempdir()) 
[18:04:58.434]                   {
[18:04:58.434]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.434]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.434]                       tmpdir = path, fileext = ".rds")
[18:04:58.434]                     save_rds(obj, file)
[18:04:58.434]                   }
[18:04:58.434]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.434]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.434]                   {
[18:04:58.434]                     inherits <- base::inherits
[18:04:58.434]                     invokeRestart <- base::invokeRestart
[18:04:58.434]                     is.null <- base::is.null
[18:04:58.434]                     muffled <- FALSE
[18:04:58.434]                     if (inherits(cond, "message")) {
[18:04:58.434]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.434]                       if (muffled) 
[18:04:58.434]                         invokeRestart("muffleMessage")
[18:04:58.434]                     }
[18:04:58.434]                     else if (inherits(cond, "warning")) {
[18:04:58.434]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.434]                       if (muffled) 
[18:04:58.434]                         invokeRestart("muffleWarning")
[18:04:58.434]                     }
[18:04:58.434]                     else if (inherits(cond, "condition")) {
[18:04:58.434]                       if (!is.null(pattern)) {
[18:04:58.434]                         computeRestarts <- base::computeRestarts
[18:04:58.434]                         grepl <- base::grepl
[18:04:58.434]                         restarts <- computeRestarts(cond)
[18:04:58.434]                         for (restart in restarts) {
[18:04:58.434]                           name <- restart$name
[18:04:58.434]                           if (is.null(name)) 
[18:04:58.434]                             next
[18:04:58.434]                           if (!grepl(pattern, name)) 
[18:04:58.434]                             next
[18:04:58.434]                           invokeRestart(restart)
[18:04:58.434]                           muffled <- TRUE
[18:04:58.434]                           break
[18:04:58.434]                         }
[18:04:58.434]                       }
[18:04:58.434]                     }
[18:04:58.434]                     invisible(muffled)
[18:04:58.434]                   }
[18:04:58.434]                   muffleCondition(cond)
[18:04:58.434]                 })
[18:04:58.434]             }))
[18:04:58.434]             future::FutureResult(value = ...future.value$value, 
[18:04:58.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.434]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.434]                     ...future.globalenv.names))
[18:04:58.434]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.434]         }, condition = base::local({
[18:04:58.434]             c <- base::c
[18:04:58.434]             inherits <- base::inherits
[18:04:58.434]             invokeRestart <- base::invokeRestart
[18:04:58.434]             length <- base::length
[18:04:58.434]             list <- base::list
[18:04:58.434]             seq.int <- base::seq.int
[18:04:58.434]             signalCondition <- base::signalCondition
[18:04:58.434]             sys.calls <- base::sys.calls
[18:04:58.434]             `[[` <- base::`[[`
[18:04:58.434]             `+` <- base::`+`
[18:04:58.434]             `<<-` <- base::`<<-`
[18:04:58.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.434]                   3L)]
[18:04:58.434]             }
[18:04:58.434]             function(cond) {
[18:04:58.434]                 is_error <- inherits(cond, "error")
[18:04:58.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.434]                   NULL)
[18:04:58.434]                 if (is_error) {
[18:04:58.434]                   sessionInformation <- function() {
[18:04:58.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.434]                       search = base::search(), system = base::Sys.info())
[18:04:58.434]                   }
[18:04:58.434]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.434]                     cond$call), session = sessionInformation(), 
[18:04:58.434]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.434]                   signalCondition(cond)
[18:04:58.434]                 }
[18:04:58.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.434]                 "immediateCondition"))) {
[18:04:58.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.434]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.434]                   if (TRUE && !signal) {
[18:04:58.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.434]                     {
[18:04:58.434]                       inherits <- base::inherits
[18:04:58.434]                       invokeRestart <- base::invokeRestart
[18:04:58.434]                       is.null <- base::is.null
[18:04:58.434]                       muffled <- FALSE
[18:04:58.434]                       if (inherits(cond, "message")) {
[18:04:58.434]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.434]                         if (muffled) 
[18:04:58.434]                           invokeRestart("muffleMessage")
[18:04:58.434]                       }
[18:04:58.434]                       else if (inherits(cond, "warning")) {
[18:04:58.434]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.434]                         if (muffled) 
[18:04:58.434]                           invokeRestart("muffleWarning")
[18:04:58.434]                       }
[18:04:58.434]                       else if (inherits(cond, "condition")) {
[18:04:58.434]                         if (!is.null(pattern)) {
[18:04:58.434]                           computeRestarts <- base::computeRestarts
[18:04:58.434]                           grepl <- base::grepl
[18:04:58.434]                           restarts <- computeRestarts(cond)
[18:04:58.434]                           for (restart in restarts) {
[18:04:58.434]                             name <- restart$name
[18:04:58.434]                             if (is.null(name)) 
[18:04:58.434]                               next
[18:04:58.434]                             if (!grepl(pattern, name)) 
[18:04:58.434]                               next
[18:04:58.434]                             invokeRestart(restart)
[18:04:58.434]                             muffled <- TRUE
[18:04:58.434]                             break
[18:04:58.434]                           }
[18:04:58.434]                         }
[18:04:58.434]                       }
[18:04:58.434]                       invisible(muffled)
[18:04:58.434]                     }
[18:04:58.434]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.434]                   }
[18:04:58.434]                 }
[18:04:58.434]                 else {
[18:04:58.434]                   if (TRUE) {
[18:04:58.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.434]                     {
[18:04:58.434]                       inherits <- base::inherits
[18:04:58.434]                       invokeRestart <- base::invokeRestart
[18:04:58.434]                       is.null <- base::is.null
[18:04:58.434]                       muffled <- FALSE
[18:04:58.434]                       if (inherits(cond, "message")) {
[18:04:58.434]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.434]                         if (muffled) 
[18:04:58.434]                           invokeRestart("muffleMessage")
[18:04:58.434]                       }
[18:04:58.434]                       else if (inherits(cond, "warning")) {
[18:04:58.434]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.434]                         if (muffled) 
[18:04:58.434]                           invokeRestart("muffleWarning")
[18:04:58.434]                       }
[18:04:58.434]                       else if (inherits(cond, "condition")) {
[18:04:58.434]                         if (!is.null(pattern)) {
[18:04:58.434]                           computeRestarts <- base::computeRestarts
[18:04:58.434]                           grepl <- base::grepl
[18:04:58.434]                           restarts <- computeRestarts(cond)
[18:04:58.434]                           for (restart in restarts) {
[18:04:58.434]                             name <- restart$name
[18:04:58.434]                             if (is.null(name)) 
[18:04:58.434]                               next
[18:04:58.434]                             if (!grepl(pattern, name)) 
[18:04:58.434]                               next
[18:04:58.434]                             invokeRestart(restart)
[18:04:58.434]                             muffled <- TRUE
[18:04:58.434]                             break
[18:04:58.434]                           }
[18:04:58.434]                         }
[18:04:58.434]                       }
[18:04:58.434]                       invisible(muffled)
[18:04:58.434]                     }
[18:04:58.434]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.434]                   }
[18:04:58.434]                 }
[18:04:58.434]             }
[18:04:58.434]         }))
[18:04:58.434]     }, error = function(ex) {
[18:04:58.434]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.434]                 ...future.rng), started = ...future.startTime, 
[18:04:58.434]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.434]             version = "1.8"), class = "FutureResult")
[18:04:58.434]     }, finally = {
[18:04:58.434]         if (!identical(...future.workdir, getwd())) 
[18:04:58.434]             setwd(...future.workdir)
[18:04:58.434]         {
[18:04:58.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.434]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.434]             }
[18:04:58.434]             base::options(...future.oldOptions)
[18:04:58.434]             if (.Platform$OS.type == "windows") {
[18:04:58.434]                 old_names <- names(...future.oldEnvVars)
[18:04:58.434]                 envs <- base::Sys.getenv()
[18:04:58.434]                 names <- names(envs)
[18:04:58.434]                 common <- intersect(names, old_names)
[18:04:58.434]                 added <- setdiff(names, old_names)
[18:04:58.434]                 removed <- setdiff(old_names, names)
[18:04:58.434]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.434]                   envs[common]]
[18:04:58.434]                 NAMES <- toupper(changed)
[18:04:58.434]                 args <- list()
[18:04:58.434]                 for (kk in seq_along(NAMES)) {
[18:04:58.434]                   name <- changed[[kk]]
[18:04:58.434]                   NAME <- NAMES[[kk]]
[18:04:58.434]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.434]                     next
[18:04:58.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.434]                 }
[18:04:58.434]                 NAMES <- toupper(added)
[18:04:58.434]                 for (kk in seq_along(NAMES)) {
[18:04:58.434]                   name <- added[[kk]]
[18:04:58.434]                   NAME <- NAMES[[kk]]
[18:04:58.434]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.434]                     next
[18:04:58.434]                   args[[name]] <- ""
[18:04:58.434]                 }
[18:04:58.434]                 NAMES <- toupper(removed)
[18:04:58.434]                 for (kk in seq_along(NAMES)) {
[18:04:58.434]                   name <- removed[[kk]]
[18:04:58.434]                   NAME <- NAMES[[kk]]
[18:04:58.434]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.434]                     next
[18:04:58.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.434]                 }
[18:04:58.434]                 if (length(args) > 0) 
[18:04:58.434]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.434]             }
[18:04:58.434]             else {
[18:04:58.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.434]             }
[18:04:58.434]             {
[18:04:58.434]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.434]                   0L) {
[18:04:58.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.434]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.434]                   base::options(opts)
[18:04:58.434]                 }
[18:04:58.434]                 {
[18:04:58.434]                   {
[18:04:58.434]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.434]                     NULL
[18:04:58.434]                   }
[18:04:58.434]                   options(future.plan = NULL)
[18:04:58.434]                   if (is.na(NA_character_)) 
[18:04:58.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.434]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.434]                     .init = FALSE)
[18:04:58.434]                 }
[18:04:58.434]             }
[18:04:58.434]         }
[18:04:58.434]     })
[18:04:58.434]     if (TRUE) {
[18:04:58.434]         base::sink(type = "output", split = FALSE)
[18:04:58.434]         if (TRUE) {
[18:04:58.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.434]         }
[18:04:58.434]         else {
[18:04:58.434]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.434]         }
[18:04:58.434]         base::close(...future.stdout)
[18:04:58.434]         ...future.stdout <- NULL
[18:04:58.434]     }
[18:04:58.434]     ...future.result$conditions <- ...future.conditions
[18:04:58.434]     ...future.result$finished <- base::Sys.time()
[18:04:58.434]     ...future.result
[18:04:58.434] }
[18:04:58.439] assign_globals() ...
[18:04:58.439] List of 1
[18:04:58.439]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5b95757a2fb0> 
[18:04:58.439]  - attr(*, "where")=List of 1
[18:04:58.439]   ..$ a:<environment: R_EmptyEnv> 
[18:04:58.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:58.439]  - attr(*, "resolved")= logi TRUE
[18:04:58.439]  - attr(*, "total_size")= num 1649944
[18:04:58.439]  - attr(*, "already-done")= logi TRUE
[18:04:58.446] - copied ‘a’ to environment
[18:04:58.446] assign_globals() ... done
[18:04:58.447] requestCore(): workers = 2
[18:04:58.450] MulticoreFuture started
[18:04:58.451] - Launch lazy future ... done
[18:04:58.452] run() for ‘MulticoreFuture’ ... done
[18:04:58.452] result() for MulticoreFuture ...
[18:04:58.455] plan(): Setting new future strategy stack:
[18:04:58.456] List of future strategies:
[18:04:58.456] 1. sequential:
[18:04:58.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.456]    - tweaked: FALSE
[18:04:58.456]    - call: NULL
[18:04:58.459] plan(): nbrOfWorkers() = 1
[18:04:58.466] plan(): Setting new future strategy stack:
[18:04:58.467] List of future strategies:
[18:04:58.467] 1. multicore:
[18:04:58.467]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.467]    - tweaked: FALSE
[18:04:58.467]    - call: plan(strategy)
[18:04:58.477] plan(): nbrOfWorkers() = 2
[18:04:58.481] result() for MulticoreFuture ...
[18:04:58.481] result() for MulticoreFuture ... done
[18:04:58.482] signalConditions() ...
[18:04:58.482]  - include = ‘immediateCondition’
[18:04:58.482]  - exclude = 
[18:04:58.483]  - resignal = FALSE
[18:04:58.483]  - Number of conditions: 4
[18:04:58.483] signalConditions() ... done
[18:04:58.483] result() for MulticoreFuture ... done
[18:04:58.485] result() for MulticoreFuture ...
[18:04:58.485] result() for MulticoreFuture ... done
[18:04:58.485] signalConditions() ...
[18:04:58.486]  - include = ‘immediateCondition’
[18:04:58.486]  - exclude = 
[18:04:58.486]  - resignal = FALSE
[18:04:58.486]  - Number of conditions: 4
[18:04:58.487] signalConditions() ... done
[18:04:58.487] Future state: ‘finished’
[18:04:58.487] result() for MulticoreFuture ...
[18:04:58.488] result() for MulticoreFuture ... done
[18:04:58.488] signalConditions() ...
[18:04:58.488]  - include = ‘condition’
[18:04:58.488]  - exclude = ‘immediateCondition’
[18:04:58.489]  - resignal = TRUE
[18:04:58.489]  - Number of conditions: 4
[18:04:58.489]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.461] result() for MulticoreFuture ...
[18:04:58.490]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.462] result() for MulticoreFuture ... done
[18:04:58.490]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.463] result() for MulticoreFuture ...
[18:04:58.490]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.464] result() for MulticoreFuture ... done
[18:04:58.491] signalConditions() ... done
value(b) = 2
[18:04:58.491] result() for MulticoreFuture ...
[18:04:58.492] result() for MulticoreFuture ... done
[18:04:58.492] result() for MulticoreFuture ...
[18:04:58.492] result() for MulticoreFuture ... done
[18:04:58.492] signalConditions() ...
[18:04:58.493]  - include = ‘immediateCondition’
[18:04:58.493]  - exclude = 
[18:04:58.493]  - resignal = FALSE
[18:04:58.493]  - Number of conditions: 4
[18:04:58.494] signalConditions() ... done
[18:04:58.494] Future state: ‘finished’
[18:04:58.494] result() for MulticoreFuture ...
[18:04:58.494] result() for MulticoreFuture ... done
[18:04:58.495] signalConditions() ...
[18:04:58.495]  - include = ‘condition’
[18:04:58.495]  - exclude = ‘immediateCondition’
[18:04:58.495]  - resignal = TRUE
[18:04:58.496]  - Number of conditions: 4
[18:04:58.496]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.461] result() for MulticoreFuture ...
[18:04:58.496]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.462] result() for MulticoreFuture ... done
[18:04:58.497]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.463] result() for MulticoreFuture ...
[18:04:58.497]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.464] result() for MulticoreFuture ... done
[18:04:58.497] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.498] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.499] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.500] 
[18:04:58.500] Searching for globals ... DONE
[18:04:58.500] - globals: [0] <none>
[18:04:58.501] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.502] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.502] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.504] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:58.505] Searching for globals ... DONE
[18:04:58.505] Resolving globals: TRUE
[18:04:58.505] Resolving any globals that are futures ...
[18:04:58.505] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:58.506] Resolving any globals that are futures ... DONE
[18:04:58.507] Resolving futures part of globals (recursively) ...
[18:04:58.507] resolve() on list ...
[18:04:58.508]  recursive: 99
[18:04:58.508]  length: 1
[18:04:58.508]  elements: ‘a’
[18:04:58.509] run() for ‘Future’ ...
[18:04:58.509] - state: ‘created’
[18:04:58.509] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.517] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.517]   - Field: ‘label’
[18:04:58.518]   - Field: ‘local’
[18:04:58.518]   - Field: ‘owner’
[18:04:58.518]   - Field: ‘envir’
[18:04:58.519]   - Field: ‘workers’
[18:04:58.519]   - Field: ‘packages’
[18:04:58.519]   - Field: ‘gc’
[18:04:58.519]   - Field: ‘job’
[18:04:58.520]   - Field: ‘conditions’
[18:04:58.520]   - Field: ‘expr’
[18:04:58.520]   - Field: ‘uuid’
[18:04:58.520]   - Field: ‘seed’
[18:04:58.521]   - Field: ‘version’
[18:04:58.521]   - Field: ‘result’
[18:04:58.521]   - Field: ‘asynchronous’
[18:04:58.521]   - Field: ‘calls’
[18:04:58.522]   - Field: ‘globals’
[18:04:58.522]   - Field: ‘stdout’
[18:04:58.522]   - Field: ‘earlySignal’
[18:04:58.522]   - Field: ‘lazy’
[18:04:58.523]   - Field: ‘state’
[18:04:58.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.527] - Launch lazy future ...
[18:04:58.528] Packages needed by the future expression (n = 0): <none>
[18:04:58.529] Packages needed by future strategies (n = 0): <none>
[18:04:58.530] {
[18:04:58.530]     {
[18:04:58.530]         {
[18:04:58.530]             ...future.startTime <- base::Sys.time()
[18:04:58.530]             {
[18:04:58.530]                 {
[18:04:58.530]                   {
[18:04:58.530]                     {
[18:04:58.530]                       base::local({
[18:04:58.530]                         has_future <- base::requireNamespace("future", 
[18:04:58.530]                           quietly = TRUE)
[18:04:58.530]                         if (has_future) {
[18:04:58.530]                           ns <- base::getNamespace("future")
[18:04:58.530]                           version <- ns[[".package"]][["version"]]
[18:04:58.530]                           if (is.null(version)) 
[18:04:58.530]                             version <- utils::packageVersion("future")
[18:04:58.530]                         }
[18:04:58.530]                         else {
[18:04:58.530]                           version <- NULL
[18:04:58.530]                         }
[18:04:58.530]                         if (!has_future || version < "1.8.0") {
[18:04:58.530]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.530]                             "", base::R.version$version.string), 
[18:04:58.530]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:58.530]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:58.530]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.530]                               "release", "version")], collapse = " "), 
[18:04:58.530]                             hostname = base::Sys.info()[["nodename"]])
[18:04:58.530]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.530]                             info)
[18:04:58.530]                           info <- base::paste(info, collapse = "; ")
[18:04:58.530]                           if (!has_future) {
[18:04:58.530]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.530]                               info)
[18:04:58.530]                           }
[18:04:58.530]                           else {
[18:04:58.530]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.530]                               info, version)
[18:04:58.530]                           }
[18:04:58.530]                           base::stop(msg)
[18:04:58.530]                         }
[18:04:58.530]                       })
[18:04:58.530]                     }
[18:04:58.530]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.530]                     base::options(mc.cores = 1L)
[18:04:58.530]                   }
[18:04:58.530]                   ...future.strategy.old <- future::plan("list")
[18:04:58.530]                   options(future.plan = NULL)
[18:04:58.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.530]                 }
[18:04:58.530]                 ...future.workdir <- getwd()
[18:04:58.530]             }
[18:04:58.530]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.530]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.530]         }
[18:04:58.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.530]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.530]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.530]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.530]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.530]             base::names(...future.oldOptions))
[18:04:58.530]     }
[18:04:58.530]     if (FALSE) {
[18:04:58.530]     }
[18:04:58.530]     else {
[18:04:58.530]         if (TRUE) {
[18:04:58.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.530]                 open = "w")
[18:04:58.530]         }
[18:04:58.530]         else {
[18:04:58.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.530]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.530]         }
[18:04:58.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.530]             base::sink(type = "output", split = FALSE)
[18:04:58.530]             base::close(...future.stdout)
[18:04:58.530]         }, add = TRUE)
[18:04:58.530]     }
[18:04:58.530]     ...future.frame <- base::sys.nframe()
[18:04:58.530]     ...future.conditions <- base::list()
[18:04:58.530]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.530]     if (FALSE) {
[18:04:58.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.530]     }
[18:04:58.530]     ...future.result <- base::tryCatch({
[18:04:58.530]         base::withCallingHandlers({
[18:04:58.530]             ...future.value <- base::withVisible(base::local({
[18:04:58.530]                 withCallingHandlers({
[18:04:58.530]                   1
[18:04:58.530]                 }, immediateCondition = function(cond) {
[18:04:58.530]                   save_rds <- function (object, pathname, ...) 
[18:04:58.530]                   {
[18:04:58.530]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.530]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.530]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.530]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.530]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.530]                         fi_tmp[["mtime"]])
[18:04:58.530]                     }
[18:04:58.530]                     tryCatch({
[18:04:58.530]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.530]                     }, error = function(ex) {
[18:04:58.530]                       msg <- conditionMessage(ex)
[18:04:58.530]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.530]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.530]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.530]                         fi_tmp[["mtime"]], msg)
[18:04:58.530]                       ex$message <- msg
[18:04:58.530]                       stop(ex)
[18:04:58.530]                     })
[18:04:58.530]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.530]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.530]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.530]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.530]                       fi <- file.info(pathname)
[18:04:58.530]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.530]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.530]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.530]                         fi[["size"]], fi[["mtime"]])
[18:04:58.530]                       stop(msg)
[18:04:58.530]                     }
[18:04:58.530]                     invisible(pathname)
[18:04:58.530]                   }
[18:04:58.530]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.530]                     rootPath = tempdir()) 
[18:04:58.530]                   {
[18:04:58.530]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.530]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.530]                       tmpdir = path, fileext = ".rds")
[18:04:58.530]                     save_rds(obj, file)
[18:04:58.530]                   }
[18:04:58.530]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.530]                   {
[18:04:58.530]                     inherits <- base::inherits
[18:04:58.530]                     invokeRestart <- base::invokeRestart
[18:04:58.530]                     is.null <- base::is.null
[18:04:58.530]                     muffled <- FALSE
[18:04:58.530]                     if (inherits(cond, "message")) {
[18:04:58.530]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.530]                       if (muffled) 
[18:04:58.530]                         invokeRestart("muffleMessage")
[18:04:58.530]                     }
[18:04:58.530]                     else if (inherits(cond, "warning")) {
[18:04:58.530]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.530]                       if (muffled) 
[18:04:58.530]                         invokeRestart("muffleWarning")
[18:04:58.530]                     }
[18:04:58.530]                     else if (inherits(cond, "condition")) {
[18:04:58.530]                       if (!is.null(pattern)) {
[18:04:58.530]                         computeRestarts <- base::computeRestarts
[18:04:58.530]                         grepl <- base::grepl
[18:04:58.530]                         restarts <- computeRestarts(cond)
[18:04:58.530]                         for (restart in restarts) {
[18:04:58.530]                           name <- restart$name
[18:04:58.530]                           if (is.null(name)) 
[18:04:58.530]                             next
[18:04:58.530]                           if (!grepl(pattern, name)) 
[18:04:58.530]                             next
[18:04:58.530]                           invokeRestart(restart)
[18:04:58.530]                           muffled <- TRUE
[18:04:58.530]                           break
[18:04:58.530]                         }
[18:04:58.530]                       }
[18:04:58.530]                     }
[18:04:58.530]                     invisible(muffled)
[18:04:58.530]                   }
[18:04:58.530]                   muffleCondition(cond)
[18:04:58.530]                 })
[18:04:58.530]             }))
[18:04:58.530]             future::FutureResult(value = ...future.value$value, 
[18:04:58.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.530]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.530]                     ...future.globalenv.names))
[18:04:58.530]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.530]         }, condition = base::local({
[18:04:58.530]             c <- base::c
[18:04:58.530]             inherits <- base::inherits
[18:04:58.530]             invokeRestart <- base::invokeRestart
[18:04:58.530]             length <- base::length
[18:04:58.530]             list <- base::list
[18:04:58.530]             seq.int <- base::seq.int
[18:04:58.530]             signalCondition <- base::signalCondition
[18:04:58.530]             sys.calls <- base::sys.calls
[18:04:58.530]             `[[` <- base::`[[`
[18:04:58.530]             `+` <- base::`+`
[18:04:58.530]             `<<-` <- base::`<<-`
[18:04:58.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.530]                   3L)]
[18:04:58.530]             }
[18:04:58.530]             function(cond) {
[18:04:58.530]                 is_error <- inherits(cond, "error")
[18:04:58.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.530]                   NULL)
[18:04:58.530]                 if (is_error) {
[18:04:58.530]                   sessionInformation <- function() {
[18:04:58.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.530]                       search = base::search(), system = base::Sys.info())
[18:04:58.530]                   }
[18:04:58.530]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.530]                     cond$call), session = sessionInformation(), 
[18:04:58.530]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.530]                   signalCondition(cond)
[18:04:58.530]                 }
[18:04:58.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.530]                 "immediateCondition"))) {
[18:04:58.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.530]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.530]                   if (TRUE && !signal) {
[18:04:58.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.530]                     {
[18:04:58.530]                       inherits <- base::inherits
[18:04:58.530]                       invokeRestart <- base::invokeRestart
[18:04:58.530]                       is.null <- base::is.null
[18:04:58.530]                       muffled <- FALSE
[18:04:58.530]                       if (inherits(cond, "message")) {
[18:04:58.530]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.530]                         if (muffled) 
[18:04:58.530]                           invokeRestart("muffleMessage")
[18:04:58.530]                       }
[18:04:58.530]                       else if (inherits(cond, "warning")) {
[18:04:58.530]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.530]                         if (muffled) 
[18:04:58.530]                           invokeRestart("muffleWarning")
[18:04:58.530]                       }
[18:04:58.530]                       else if (inherits(cond, "condition")) {
[18:04:58.530]                         if (!is.null(pattern)) {
[18:04:58.530]                           computeRestarts <- base::computeRestarts
[18:04:58.530]                           grepl <- base::grepl
[18:04:58.530]                           restarts <- computeRestarts(cond)
[18:04:58.530]                           for (restart in restarts) {
[18:04:58.530]                             name <- restart$name
[18:04:58.530]                             if (is.null(name)) 
[18:04:58.530]                               next
[18:04:58.530]                             if (!grepl(pattern, name)) 
[18:04:58.530]                               next
[18:04:58.530]                             invokeRestart(restart)
[18:04:58.530]                             muffled <- TRUE
[18:04:58.530]                             break
[18:04:58.530]                           }
[18:04:58.530]                         }
[18:04:58.530]                       }
[18:04:58.530]                       invisible(muffled)
[18:04:58.530]                     }
[18:04:58.530]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.530]                   }
[18:04:58.530]                 }
[18:04:58.530]                 else {
[18:04:58.530]                   if (TRUE) {
[18:04:58.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.530]                     {
[18:04:58.530]                       inherits <- base::inherits
[18:04:58.530]                       invokeRestart <- base::invokeRestart
[18:04:58.530]                       is.null <- base::is.null
[18:04:58.530]                       muffled <- FALSE
[18:04:58.530]                       if (inherits(cond, "message")) {
[18:04:58.530]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.530]                         if (muffled) 
[18:04:58.530]                           invokeRestart("muffleMessage")
[18:04:58.530]                       }
[18:04:58.530]                       else if (inherits(cond, "warning")) {
[18:04:58.530]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.530]                         if (muffled) 
[18:04:58.530]                           invokeRestart("muffleWarning")
[18:04:58.530]                       }
[18:04:58.530]                       else if (inherits(cond, "condition")) {
[18:04:58.530]                         if (!is.null(pattern)) {
[18:04:58.530]                           computeRestarts <- base::computeRestarts
[18:04:58.530]                           grepl <- base::grepl
[18:04:58.530]                           restarts <- computeRestarts(cond)
[18:04:58.530]                           for (restart in restarts) {
[18:04:58.530]                             name <- restart$name
[18:04:58.530]                             if (is.null(name)) 
[18:04:58.530]                               next
[18:04:58.530]                             if (!grepl(pattern, name)) 
[18:04:58.530]                               next
[18:04:58.530]                             invokeRestart(restart)
[18:04:58.530]                             muffled <- TRUE
[18:04:58.530]                             break
[18:04:58.530]                           }
[18:04:58.530]                         }
[18:04:58.530]                       }
[18:04:58.530]                       invisible(muffled)
[18:04:58.530]                     }
[18:04:58.530]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.530]                   }
[18:04:58.530]                 }
[18:04:58.530]             }
[18:04:58.530]         }))
[18:04:58.530]     }, error = function(ex) {
[18:04:58.530]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.530]                 ...future.rng), started = ...future.startTime, 
[18:04:58.530]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.530]             version = "1.8"), class = "FutureResult")
[18:04:58.530]     }, finally = {
[18:04:58.530]         if (!identical(...future.workdir, getwd())) 
[18:04:58.530]             setwd(...future.workdir)
[18:04:58.530]         {
[18:04:58.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.530]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.530]             }
[18:04:58.530]             base::options(...future.oldOptions)
[18:04:58.530]             if (.Platform$OS.type == "windows") {
[18:04:58.530]                 old_names <- names(...future.oldEnvVars)
[18:04:58.530]                 envs <- base::Sys.getenv()
[18:04:58.530]                 names <- names(envs)
[18:04:58.530]                 common <- intersect(names, old_names)
[18:04:58.530]                 added <- setdiff(names, old_names)
[18:04:58.530]                 removed <- setdiff(old_names, names)
[18:04:58.530]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.530]                   envs[common]]
[18:04:58.530]                 NAMES <- toupper(changed)
[18:04:58.530]                 args <- list()
[18:04:58.530]                 for (kk in seq_along(NAMES)) {
[18:04:58.530]                   name <- changed[[kk]]
[18:04:58.530]                   NAME <- NAMES[[kk]]
[18:04:58.530]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.530]                     next
[18:04:58.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.530]                 }
[18:04:58.530]                 NAMES <- toupper(added)
[18:04:58.530]                 for (kk in seq_along(NAMES)) {
[18:04:58.530]                   name <- added[[kk]]
[18:04:58.530]                   NAME <- NAMES[[kk]]
[18:04:58.530]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.530]                     next
[18:04:58.530]                   args[[name]] <- ""
[18:04:58.530]                 }
[18:04:58.530]                 NAMES <- toupper(removed)
[18:04:58.530]                 for (kk in seq_along(NAMES)) {
[18:04:58.530]                   name <- removed[[kk]]
[18:04:58.530]                   NAME <- NAMES[[kk]]
[18:04:58.530]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.530]                     next
[18:04:58.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.530]                 }
[18:04:58.530]                 if (length(args) > 0) 
[18:04:58.530]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.530]             }
[18:04:58.530]             else {
[18:04:58.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.530]             }
[18:04:58.530]             {
[18:04:58.530]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.530]                   0L) {
[18:04:58.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.530]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.530]                   base::options(opts)
[18:04:58.530]                 }
[18:04:58.530]                 {
[18:04:58.530]                   {
[18:04:58.530]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.530]                     NULL
[18:04:58.530]                   }
[18:04:58.530]                   options(future.plan = NULL)
[18:04:58.530]                   if (is.na(NA_character_)) 
[18:04:58.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.530]                     .init = FALSE)
[18:04:58.530]                 }
[18:04:58.530]             }
[18:04:58.530]         }
[18:04:58.530]     })
[18:04:58.530]     if (TRUE) {
[18:04:58.530]         base::sink(type = "output", split = FALSE)
[18:04:58.530]         if (TRUE) {
[18:04:58.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.530]         }
[18:04:58.530]         else {
[18:04:58.530]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.530]         }
[18:04:58.530]         base::close(...future.stdout)
[18:04:58.530]         ...future.stdout <- NULL
[18:04:58.530]     }
[18:04:58.530]     ...future.result$conditions <- ...future.conditions
[18:04:58.530]     ...future.result$finished <- base::Sys.time()
[18:04:58.530]     ...future.result
[18:04:58.530] }
[18:04:58.535] requestCore(): workers = 2
[18:04:58.538] MulticoreFuture started
[18:04:58.542] plan(): Setting new future strategy stack:
[18:04:58.539] - Launch lazy future ... done
[18:04:58.544] run() for ‘MulticoreFuture’ ... done
[18:04:58.543] List of future strategies:
[18:04:58.543] 1. sequential:
[18:04:58.543]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.543]    - tweaked: FALSE
[18:04:58.543]    - call: NULL
[18:04:58.547] plan(): nbrOfWorkers() = 1
[18:04:58.553] plan(): Setting new future strategy stack:
[18:04:58.554] List of future strategies:
[18:04:58.554] 1. multicore:
[18:04:58.554]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.554]    - tweaked: FALSE
[18:04:58.554]    - call: plan(strategy)
[18:04:58.569] plan(): nbrOfWorkers() = 2
[18:04:58.573] Future #1
[18:04:58.573] result() for MulticoreFuture ...
[18:04:58.580] result() for MulticoreFuture ...
[18:04:58.583] result() for MulticoreFuture ... done
[18:04:58.583] result() for MulticoreFuture ... done
[18:04:58.584] result() for MulticoreFuture ...
[18:04:58.584] result() for MulticoreFuture ... done
[18:04:58.584] A MulticoreFuture was resolved
[18:04:58.585]  length: 0 (resolved future 1)
[18:04:58.585] resolve() on list ... DONE
[18:04:58.585] - globals: [1] ‘a’
[18:04:58.586] Resolving futures part of globals (recursively) ... DONE
[18:04:58.593] The total size of the 1 globals is 1.57 MiB (1650112 bytes)
[18:04:58.594] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[18:04:58.595] - globals: [1] ‘a’
[18:04:58.595] - packages: [1] ‘future’
[18:04:58.596] getGlobalsAndPackages() ... DONE
[18:04:58.596] run() for ‘Future’ ...
[18:04:58.597] - state: ‘created’
[18:04:58.597] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.604] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.605]   - Field: ‘label’
[18:04:58.606]   - Field: ‘local’
[18:04:58.606]   - Field: ‘owner’
[18:04:58.606]   - Field: ‘envir’
[18:04:58.606]   - Field: ‘workers’
[18:04:58.607]   - Field: ‘packages’
[18:04:58.607]   - Field: ‘gc’
[18:04:58.607]   - Field: ‘job’
[18:04:58.607]   - Field: ‘conditions’
[18:04:58.608]   - Field: ‘expr’
[18:04:58.608]   - Field: ‘uuid’
[18:04:58.608]   - Field: ‘seed’
[18:04:58.608]   - Field: ‘version’
[18:04:58.609]   - Field: ‘result’
[18:04:58.609]   - Field: ‘asynchronous’
[18:04:58.609]   - Field: ‘calls’
[18:04:58.609]   - Field: ‘globals’
[18:04:58.610]   - Field: ‘stdout’
[18:04:58.610]   - Field: ‘earlySignal’
[18:04:58.610]   - Field: ‘lazy’
[18:04:58.610]   - Field: ‘state’
[18:04:58.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.611] - Launch lazy future ...
[18:04:58.611] Packages needed by the future expression (n = 1): ‘future’
[18:04:58.612] Packages needed by future strategies (n = 0): <none>
[18:04:58.613] {
[18:04:58.613]     {
[18:04:58.613]         {
[18:04:58.613]             ...future.startTime <- base::Sys.time()
[18:04:58.613]             {
[18:04:58.613]                 {
[18:04:58.613]                   {
[18:04:58.613]                     {
[18:04:58.613]                       {
[18:04:58.613]                         base::local({
[18:04:58.613]                           has_future <- base::requireNamespace("future", 
[18:04:58.613]                             quietly = TRUE)
[18:04:58.613]                           if (has_future) {
[18:04:58.613]                             ns <- base::getNamespace("future")
[18:04:58.613]                             version <- ns[[".package"]][["version"]]
[18:04:58.613]                             if (is.null(version)) 
[18:04:58.613]                               version <- utils::packageVersion("future")
[18:04:58.613]                           }
[18:04:58.613]                           else {
[18:04:58.613]                             version <- NULL
[18:04:58.613]                           }
[18:04:58.613]                           if (!has_future || version < "1.8.0") {
[18:04:58.613]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.613]                               "", base::R.version$version.string), 
[18:04:58.613]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:58.613]                                 base::R.version$platform, 8 * 
[18:04:58.613]                                   base::.Machine$sizeof.pointer), 
[18:04:58.613]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.613]                                 "release", "version")], collapse = " "), 
[18:04:58.613]                               hostname = base::Sys.info()[["nodename"]])
[18:04:58.613]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.613]                               info)
[18:04:58.613]                             info <- base::paste(info, collapse = "; ")
[18:04:58.613]                             if (!has_future) {
[18:04:58.613]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.613]                                 info)
[18:04:58.613]                             }
[18:04:58.613]                             else {
[18:04:58.613]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.613]                                 info, version)
[18:04:58.613]                             }
[18:04:58.613]                             base::stop(msg)
[18:04:58.613]                           }
[18:04:58.613]                         })
[18:04:58.613]                       }
[18:04:58.613]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.613]                       base::options(mc.cores = 1L)
[18:04:58.613]                     }
[18:04:58.613]                     base::local({
[18:04:58.613]                       for (pkg in "future") {
[18:04:58.613]                         base::loadNamespace(pkg)
[18:04:58.613]                         base::library(pkg, character.only = TRUE)
[18:04:58.613]                       }
[18:04:58.613]                     })
[18:04:58.613]                   }
[18:04:58.613]                   ...future.strategy.old <- future::plan("list")
[18:04:58.613]                   options(future.plan = NULL)
[18:04:58.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.613]                 }
[18:04:58.613]                 ...future.workdir <- getwd()
[18:04:58.613]             }
[18:04:58.613]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.613]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.613]         }
[18:04:58.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.613]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.613]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.613]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.613]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.613]             base::names(...future.oldOptions))
[18:04:58.613]     }
[18:04:58.613]     if (FALSE) {
[18:04:58.613]     }
[18:04:58.613]     else {
[18:04:58.613]         if (TRUE) {
[18:04:58.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.613]                 open = "w")
[18:04:58.613]         }
[18:04:58.613]         else {
[18:04:58.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.613]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.613]         }
[18:04:58.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.613]             base::sink(type = "output", split = FALSE)
[18:04:58.613]             base::close(...future.stdout)
[18:04:58.613]         }, add = TRUE)
[18:04:58.613]     }
[18:04:58.613]     ...future.frame <- base::sys.nframe()
[18:04:58.613]     ...future.conditions <- base::list()
[18:04:58.613]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.613]     if (FALSE) {
[18:04:58.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.613]     }
[18:04:58.613]     ...future.result <- base::tryCatch({
[18:04:58.613]         base::withCallingHandlers({
[18:04:58.613]             ...future.value <- base::withVisible(base::local({
[18:04:58.613]                 withCallingHandlers({
[18:04:58.613]                   value(a) + 1
[18:04:58.613]                 }, immediateCondition = function(cond) {
[18:04:58.613]                   save_rds <- function (object, pathname, ...) 
[18:04:58.613]                   {
[18:04:58.613]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.613]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.613]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.613]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.613]                         fi_tmp[["mtime"]])
[18:04:58.613]                     }
[18:04:58.613]                     tryCatch({
[18:04:58.613]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.613]                     }, error = function(ex) {
[18:04:58.613]                       msg <- conditionMessage(ex)
[18:04:58.613]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.613]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.613]                         fi_tmp[["mtime"]], msg)
[18:04:58.613]                       ex$message <- msg
[18:04:58.613]                       stop(ex)
[18:04:58.613]                     })
[18:04:58.613]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.613]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.613]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.613]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.613]                       fi <- file.info(pathname)
[18:04:58.613]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.613]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.613]                         fi[["size"]], fi[["mtime"]])
[18:04:58.613]                       stop(msg)
[18:04:58.613]                     }
[18:04:58.613]                     invisible(pathname)
[18:04:58.613]                   }
[18:04:58.613]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.613]                     rootPath = tempdir()) 
[18:04:58.613]                   {
[18:04:58.613]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.613]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.613]                       tmpdir = path, fileext = ".rds")
[18:04:58.613]                     save_rds(obj, file)
[18:04:58.613]                   }
[18:04:58.613]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.613]                   {
[18:04:58.613]                     inherits <- base::inherits
[18:04:58.613]                     invokeRestart <- base::invokeRestart
[18:04:58.613]                     is.null <- base::is.null
[18:04:58.613]                     muffled <- FALSE
[18:04:58.613]                     if (inherits(cond, "message")) {
[18:04:58.613]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.613]                       if (muffled) 
[18:04:58.613]                         invokeRestart("muffleMessage")
[18:04:58.613]                     }
[18:04:58.613]                     else if (inherits(cond, "warning")) {
[18:04:58.613]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.613]                       if (muffled) 
[18:04:58.613]                         invokeRestart("muffleWarning")
[18:04:58.613]                     }
[18:04:58.613]                     else if (inherits(cond, "condition")) {
[18:04:58.613]                       if (!is.null(pattern)) {
[18:04:58.613]                         computeRestarts <- base::computeRestarts
[18:04:58.613]                         grepl <- base::grepl
[18:04:58.613]                         restarts <- computeRestarts(cond)
[18:04:58.613]                         for (restart in restarts) {
[18:04:58.613]                           name <- restart$name
[18:04:58.613]                           if (is.null(name)) 
[18:04:58.613]                             next
[18:04:58.613]                           if (!grepl(pattern, name)) 
[18:04:58.613]                             next
[18:04:58.613]                           invokeRestart(restart)
[18:04:58.613]                           muffled <- TRUE
[18:04:58.613]                           break
[18:04:58.613]                         }
[18:04:58.613]                       }
[18:04:58.613]                     }
[18:04:58.613]                     invisible(muffled)
[18:04:58.613]                   }
[18:04:58.613]                   muffleCondition(cond)
[18:04:58.613]                 })
[18:04:58.613]             }))
[18:04:58.613]             future::FutureResult(value = ...future.value$value, 
[18:04:58.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.613]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.613]                     ...future.globalenv.names))
[18:04:58.613]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.613]         }, condition = base::local({
[18:04:58.613]             c <- base::c
[18:04:58.613]             inherits <- base::inherits
[18:04:58.613]             invokeRestart <- base::invokeRestart
[18:04:58.613]             length <- base::length
[18:04:58.613]             list <- base::list
[18:04:58.613]             seq.int <- base::seq.int
[18:04:58.613]             signalCondition <- base::signalCondition
[18:04:58.613]             sys.calls <- base::sys.calls
[18:04:58.613]             `[[` <- base::`[[`
[18:04:58.613]             `+` <- base::`+`
[18:04:58.613]             `<<-` <- base::`<<-`
[18:04:58.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.613]                   3L)]
[18:04:58.613]             }
[18:04:58.613]             function(cond) {
[18:04:58.613]                 is_error <- inherits(cond, "error")
[18:04:58.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.613]                   NULL)
[18:04:58.613]                 if (is_error) {
[18:04:58.613]                   sessionInformation <- function() {
[18:04:58.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.613]                       search = base::search(), system = base::Sys.info())
[18:04:58.613]                   }
[18:04:58.613]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.613]                     cond$call), session = sessionInformation(), 
[18:04:58.613]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.613]                   signalCondition(cond)
[18:04:58.613]                 }
[18:04:58.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.613]                 "immediateCondition"))) {
[18:04:58.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.613]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.613]                   if (TRUE && !signal) {
[18:04:58.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.613]                     {
[18:04:58.613]                       inherits <- base::inherits
[18:04:58.613]                       invokeRestart <- base::invokeRestart
[18:04:58.613]                       is.null <- base::is.null
[18:04:58.613]                       muffled <- FALSE
[18:04:58.613]                       if (inherits(cond, "message")) {
[18:04:58.613]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.613]                         if (muffled) 
[18:04:58.613]                           invokeRestart("muffleMessage")
[18:04:58.613]                       }
[18:04:58.613]                       else if (inherits(cond, "warning")) {
[18:04:58.613]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.613]                         if (muffled) 
[18:04:58.613]                           invokeRestart("muffleWarning")
[18:04:58.613]                       }
[18:04:58.613]                       else if (inherits(cond, "condition")) {
[18:04:58.613]                         if (!is.null(pattern)) {
[18:04:58.613]                           computeRestarts <- base::computeRestarts
[18:04:58.613]                           grepl <- base::grepl
[18:04:58.613]                           restarts <- computeRestarts(cond)
[18:04:58.613]                           for (restart in restarts) {
[18:04:58.613]                             name <- restart$name
[18:04:58.613]                             if (is.null(name)) 
[18:04:58.613]                               next
[18:04:58.613]                             if (!grepl(pattern, name)) 
[18:04:58.613]                               next
[18:04:58.613]                             invokeRestart(restart)
[18:04:58.613]                             muffled <- TRUE
[18:04:58.613]                             break
[18:04:58.613]                           }
[18:04:58.613]                         }
[18:04:58.613]                       }
[18:04:58.613]                       invisible(muffled)
[18:04:58.613]                     }
[18:04:58.613]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.613]                   }
[18:04:58.613]                 }
[18:04:58.613]                 else {
[18:04:58.613]                   if (TRUE) {
[18:04:58.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.613]                     {
[18:04:58.613]                       inherits <- base::inherits
[18:04:58.613]                       invokeRestart <- base::invokeRestart
[18:04:58.613]                       is.null <- base::is.null
[18:04:58.613]                       muffled <- FALSE
[18:04:58.613]                       if (inherits(cond, "message")) {
[18:04:58.613]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.613]                         if (muffled) 
[18:04:58.613]                           invokeRestart("muffleMessage")
[18:04:58.613]                       }
[18:04:58.613]                       else if (inherits(cond, "warning")) {
[18:04:58.613]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.613]                         if (muffled) 
[18:04:58.613]                           invokeRestart("muffleWarning")
[18:04:58.613]                       }
[18:04:58.613]                       else if (inherits(cond, "condition")) {
[18:04:58.613]                         if (!is.null(pattern)) {
[18:04:58.613]                           computeRestarts <- base::computeRestarts
[18:04:58.613]                           grepl <- base::grepl
[18:04:58.613]                           restarts <- computeRestarts(cond)
[18:04:58.613]                           for (restart in restarts) {
[18:04:58.613]                             name <- restart$name
[18:04:58.613]                             if (is.null(name)) 
[18:04:58.613]                               next
[18:04:58.613]                             if (!grepl(pattern, name)) 
[18:04:58.613]                               next
[18:04:58.613]                             invokeRestart(restart)
[18:04:58.613]                             muffled <- TRUE
[18:04:58.613]                             break
[18:04:58.613]                           }
[18:04:58.613]                         }
[18:04:58.613]                       }
[18:04:58.613]                       invisible(muffled)
[18:04:58.613]                     }
[18:04:58.613]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.613]                   }
[18:04:58.613]                 }
[18:04:58.613]             }
[18:04:58.613]         }))
[18:04:58.613]     }, error = function(ex) {
[18:04:58.613]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.613]                 ...future.rng), started = ...future.startTime, 
[18:04:58.613]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.613]             version = "1.8"), class = "FutureResult")
[18:04:58.613]     }, finally = {
[18:04:58.613]         if (!identical(...future.workdir, getwd())) 
[18:04:58.613]             setwd(...future.workdir)
[18:04:58.613]         {
[18:04:58.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.613]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.613]             }
[18:04:58.613]             base::options(...future.oldOptions)
[18:04:58.613]             if (.Platform$OS.type == "windows") {
[18:04:58.613]                 old_names <- names(...future.oldEnvVars)
[18:04:58.613]                 envs <- base::Sys.getenv()
[18:04:58.613]                 names <- names(envs)
[18:04:58.613]                 common <- intersect(names, old_names)
[18:04:58.613]                 added <- setdiff(names, old_names)
[18:04:58.613]                 removed <- setdiff(old_names, names)
[18:04:58.613]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.613]                   envs[common]]
[18:04:58.613]                 NAMES <- toupper(changed)
[18:04:58.613]                 args <- list()
[18:04:58.613]                 for (kk in seq_along(NAMES)) {
[18:04:58.613]                   name <- changed[[kk]]
[18:04:58.613]                   NAME <- NAMES[[kk]]
[18:04:58.613]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.613]                     next
[18:04:58.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.613]                 }
[18:04:58.613]                 NAMES <- toupper(added)
[18:04:58.613]                 for (kk in seq_along(NAMES)) {
[18:04:58.613]                   name <- added[[kk]]
[18:04:58.613]                   NAME <- NAMES[[kk]]
[18:04:58.613]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.613]                     next
[18:04:58.613]                   args[[name]] <- ""
[18:04:58.613]                 }
[18:04:58.613]                 NAMES <- toupper(removed)
[18:04:58.613]                 for (kk in seq_along(NAMES)) {
[18:04:58.613]                   name <- removed[[kk]]
[18:04:58.613]                   NAME <- NAMES[[kk]]
[18:04:58.613]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.613]                     next
[18:04:58.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.613]                 }
[18:04:58.613]                 if (length(args) > 0) 
[18:04:58.613]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.613]             }
[18:04:58.613]             else {
[18:04:58.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.613]             }
[18:04:58.613]             {
[18:04:58.613]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.613]                   0L) {
[18:04:58.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.613]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.613]                   base::options(opts)
[18:04:58.613]                 }
[18:04:58.613]                 {
[18:04:58.613]                   {
[18:04:58.613]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.613]                     NULL
[18:04:58.613]                   }
[18:04:58.613]                   options(future.plan = NULL)
[18:04:58.613]                   if (is.na(NA_character_)) 
[18:04:58.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.613]                     .init = FALSE)
[18:04:58.613]                 }
[18:04:58.613]             }
[18:04:58.613]         }
[18:04:58.613]     })
[18:04:58.613]     if (TRUE) {
[18:04:58.613]         base::sink(type = "output", split = FALSE)
[18:04:58.613]         if (TRUE) {
[18:04:58.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.613]         }
[18:04:58.613]         else {
[18:04:58.613]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.613]         }
[18:04:58.613]         base::close(...future.stdout)
[18:04:58.613]         ...future.stdout <- NULL
[18:04:58.613]     }
[18:04:58.613]     ...future.result$conditions <- ...future.conditions
[18:04:58.613]     ...future.result$finished <- base::Sys.time()
[18:04:58.613]     ...future.result
[18:04:58.613] }
[18:04:58.619] assign_globals() ...
[18:04:58.619] List of 1
[18:04:58.619]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5b9576f133e0> 
[18:04:58.619]  - attr(*, "where")=List of 1
[18:04:58.619]   ..$ a:<environment: R_EmptyEnv> 
[18:04:58.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:58.619]  - attr(*, "resolved")= logi TRUE
[18:04:58.619]  - attr(*, "total_size")= num 1650112
[18:04:58.619]  - attr(*, "already-done")= logi TRUE
[18:04:58.625] - copied ‘a’ to environment
[18:04:58.626] assign_globals() ... done
[18:04:58.626] requestCore(): workers = 2
[18:04:58.632] MulticoreFuture started
[18:04:58.633] - Launch lazy future ... done
[18:04:58.635] plan(): Setting new future strategy stack:
[18:04:58.633] run() for ‘MulticoreFuture’ ... done
[18:04:58.636] result() for MulticoreFuture ...
[18:04:58.635] List of future strategies:
[18:04:58.635] 1. sequential:
[18:04:58.635]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.635]    - tweaked: FALSE
[18:04:58.635]    - call: NULL
[18:04:58.640] plan(): nbrOfWorkers() = 1
[18:04:58.647] plan(): Setting new future strategy stack:
[18:04:58.648] List of future strategies:
[18:04:58.648] 1. multicore:
[18:04:58.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.648]    - tweaked: FALSE
[18:04:58.648]    - call: plan(strategy)
[18:04:58.658] plan(): nbrOfWorkers() = 2
[18:04:58.660] result() for MulticoreFuture ...
[18:04:58.660] result() for MulticoreFuture ... done
[18:04:58.661] signalConditions() ...
[18:04:58.662]  - include = ‘immediateCondition’
[18:04:58.662]  - exclude = 
[18:04:58.663]  - resignal = FALSE
[18:04:58.663]  - Number of conditions: 4
[18:04:58.663] signalConditions() ... done
[18:04:58.664] result() for MulticoreFuture ... done
[18:04:58.666] result() for MulticoreFuture ...
[18:04:58.666] result() for MulticoreFuture ... done
[18:04:58.667] signalConditions() ...
[18:04:58.667]  - include = ‘immediateCondition’
[18:04:58.667]  - exclude = 
[18:04:58.667]  - resignal = FALSE
[18:04:58.668]  - Number of conditions: 4
[18:04:58.668] signalConditions() ... done
[18:04:58.668] Future state: ‘finished’
[18:04:58.669] result() for MulticoreFuture ...
[18:04:58.669] result() for MulticoreFuture ... done
[18:04:58.669] signalConditions() ...
[18:04:58.669]  - include = ‘condition’
[18:04:58.670]  - exclude = ‘immediateCondition’
[18:04:58.670]  - resignal = TRUE
[18:04:58.670]  - Number of conditions: 4
[18:04:58.670]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.643] result() for MulticoreFuture ...
[18:04:58.671]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.644] result() for MulticoreFuture ... done
[18:04:58.671]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.644] result() for MulticoreFuture ...
[18:04:58.672]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.645] result() for MulticoreFuture ... done
[18:04:58.672] signalConditions() ... done
value(b) = 2
[18:04:58.673] result() for MulticoreFuture ...
[18:04:58.673] result() for MulticoreFuture ... done
[18:04:58.674] result() for MulticoreFuture ...
[18:04:58.674] result() for MulticoreFuture ... done
[18:04:58.674] signalConditions() ...
[18:04:58.675]  - include = ‘immediateCondition’
[18:04:58.675]  - exclude = 
[18:04:58.675]  - resignal = FALSE
[18:04:58.675]  - Number of conditions: 4
[18:04:58.676] signalConditions() ... done
[18:04:58.676] Future state: ‘finished’
[18:04:58.676] result() for MulticoreFuture ...
[18:04:58.676] result() for MulticoreFuture ... done
[18:04:58.677] signalConditions() ...
[18:04:58.677]  - include = ‘condition’
[18:04:58.677]  - exclude = ‘immediateCondition’
[18:04:58.677]  - resignal = TRUE
[18:04:58.678]  - Number of conditions: 4
[18:04:58.678]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.643] result() for MulticoreFuture ...
[18:04:58.678]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.644] result() for MulticoreFuture ... done
[18:04:58.679]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.644] result() for MulticoreFuture ...
[18:04:58.679]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.645] result() for MulticoreFuture ... done
[18:04:58.680] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.680] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.681] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.682] 
[18:04:58.682] Searching for globals ... DONE
[18:04:58.683] - globals: [0] <none>
[18:04:58.683] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.684] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.684] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.691] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:04:58.691] Searching for globals ... DONE
[18:04:58.692] Resolving globals: TRUE
[18:04:58.692] Resolving any globals that are futures ...
[18:04:58.692] - globals: [3] ‘+’, ‘value’, ‘a’
[18:04:58.692] Resolving any globals that are futures ... DONE
[18:04:58.693] Resolving futures part of globals (recursively) ...
[18:04:58.694] resolve() on list ...
[18:04:58.694]  recursive: 99
[18:04:58.694]  length: 1
[18:04:58.695]  elements: ‘a’
[18:04:58.695] run() for ‘Future’ ...
[18:04:58.695] - state: ‘created’
[18:04:58.696] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.703] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.703]   - Field: ‘label’
[18:04:58.704]   - Field: ‘local’
[18:04:58.704]   - Field: ‘owner’
[18:04:58.705]   - Field: ‘envir’
[18:04:58.705]   - Field: ‘workers’
[18:04:58.705]   - Field: ‘packages’
[18:04:58.706]   - Field: ‘gc’
[18:04:58.706]   - Field: ‘job’
[18:04:58.706]   - Field: ‘conditions’
[18:04:58.706]   - Field: ‘expr’
[18:04:58.707]   - Field: ‘uuid’
[18:04:58.707]   - Field: ‘seed’
[18:04:58.707]   - Field: ‘version’
[18:04:58.707]   - Field: ‘result’
[18:04:58.708]   - Field: ‘asynchronous’
[18:04:58.708]   - Field: ‘calls’
[18:04:58.708]   - Field: ‘globals’
[18:04:58.708]   - Field: ‘stdout’
[18:04:58.709]   - Field: ‘earlySignal’
[18:04:58.709]   - Field: ‘lazy’
[18:04:58.709]   - Field: ‘state’
[18:04:58.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.710] - Launch lazy future ...
[18:04:58.711] Packages needed by the future expression (n = 0): <none>
[18:04:58.711] Packages needed by future strategies (n = 0): <none>
[18:04:58.712] {
[18:04:58.712]     {
[18:04:58.712]         {
[18:04:58.712]             ...future.startTime <- base::Sys.time()
[18:04:58.712]             {
[18:04:58.712]                 {
[18:04:58.712]                   {
[18:04:58.712]                     {
[18:04:58.712]                       base::local({
[18:04:58.712]                         has_future <- base::requireNamespace("future", 
[18:04:58.712]                           quietly = TRUE)
[18:04:58.712]                         if (has_future) {
[18:04:58.712]                           ns <- base::getNamespace("future")
[18:04:58.712]                           version <- ns[[".package"]][["version"]]
[18:04:58.712]                           if (is.null(version)) 
[18:04:58.712]                             version <- utils::packageVersion("future")
[18:04:58.712]                         }
[18:04:58.712]                         else {
[18:04:58.712]                           version <- NULL
[18:04:58.712]                         }
[18:04:58.712]                         if (!has_future || version < "1.8.0") {
[18:04:58.712]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.712]                             "", base::R.version$version.string), 
[18:04:58.712]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:58.712]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:58.712]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.712]                               "release", "version")], collapse = " "), 
[18:04:58.712]                             hostname = base::Sys.info()[["nodename"]])
[18:04:58.712]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.712]                             info)
[18:04:58.712]                           info <- base::paste(info, collapse = "; ")
[18:04:58.712]                           if (!has_future) {
[18:04:58.712]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.712]                               info)
[18:04:58.712]                           }
[18:04:58.712]                           else {
[18:04:58.712]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.712]                               info, version)
[18:04:58.712]                           }
[18:04:58.712]                           base::stop(msg)
[18:04:58.712]                         }
[18:04:58.712]                       })
[18:04:58.712]                     }
[18:04:58.712]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.712]                     base::options(mc.cores = 1L)
[18:04:58.712]                   }
[18:04:58.712]                   ...future.strategy.old <- future::plan("list")
[18:04:58.712]                   options(future.plan = NULL)
[18:04:58.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.712]                 }
[18:04:58.712]                 ...future.workdir <- getwd()
[18:04:58.712]             }
[18:04:58.712]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.712]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.712]         }
[18:04:58.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.712]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.712]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.712]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.712]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.712]             base::names(...future.oldOptions))
[18:04:58.712]     }
[18:04:58.712]     if (FALSE) {
[18:04:58.712]     }
[18:04:58.712]     else {
[18:04:58.712]         if (TRUE) {
[18:04:58.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.712]                 open = "w")
[18:04:58.712]         }
[18:04:58.712]         else {
[18:04:58.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.712]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.712]         }
[18:04:58.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.712]             base::sink(type = "output", split = FALSE)
[18:04:58.712]             base::close(...future.stdout)
[18:04:58.712]         }, add = TRUE)
[18:04:58.712]     }
[18:04:58.712]     ...future.frame <- base::sys.nframe()
[18:04:58.712]     ...future.conditions <- base::list()
[18:04:58.712]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.712]     if (FALSE) {
[18:04:58.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.712]     }
[18:04:58.712]     ...future.result <- base::tryCatch({
[18:04:58.712]         base::withCallingHandlers({
[18:04:58.712]             ...future.value <- base::withVisible(base::local({
[18:04:58.712]                 withCallingHandlers({
[18:04:58.712]                   1
[18:04:58.712]                 }, immediateCondition = function(cond) {
[18:04:58.712]                   save_rds <- function (object, pathname, ...) 
[18:04:58.712]                   {
[18:04:58.712]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.712]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.712]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.712]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.712]                         fi_tmp[["mtime"]])
[18:04:58.712]                     }
[18:04:58.712]                     tryCatch({
[18:04:58.712]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.712]                     }, error = function(ex) {
[18:04:58.712]                       msg <- conditionMessage(ex)
[18:04:58.712]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.712]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.712]                         fi_tmp[["mtime"]], msg)
[18:04:58.712]                       ex$message <- msg
[18:04:58.712]                       stop(ex)
[18:04:58.712]                     })
[18:04:58.712]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.712]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.712]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.712]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.712]                       fi <- file.info(pathname)
[18:04:58.712]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.712]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.712]                         fi[["size"]], fi[["mtime"]])
[18:04:58.712]                       stop(msg)
[18:04:58.712]                     }
[18:04:58.712]                     invisible(pathname)
[18:04:58.712]                   }
[18:04:58.712]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.712]                     rootPath = tempdir()) 
[18:04:58.712]                   {
[18:04:58.712]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.712]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.712]                       tmpdir = path, fileext = ".rds")
[18:04:58.712]                     save_rds(obj, file)
[18:04:58.712]                   }
[18:04:58.712]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.712]                   {
[18:04:58.712]                     inherits <- base::inherits
[18:04:58.712]                     invokeRestart <- base::invokeRestart
[18:04:58.712]                     is.null <- base::is.null
[18:04:58.712]                     muffled <- FALSE
[18:04:58.712]                     if (inherits(cond, "message")) {
[18:04:58.712]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.712]                       if (muffled) 
[18:04:58.712]                         invokeRestart("muffleMessage")
[18:04:58.712]                     }
[18:04:58.712]                     else if (inherits(cond, "warning")) {
[18:04:58.712]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.712]                       if (muffled) 
[18:04:58.712]                         invokeRestart("muffleWarning")
[18:04:58.712]                     }
[18:04:58.712]                     else if (inherits(cond, "condition")) {
[18:04:58.712]                       if (!is.null(pattern)) {
[18:04:58.712]                         computeRestarts <- base::computeRestarts
[18:04:58.712]                         grepl <- base::grepl
[18:04:58.712]                         restarts <- computeRestarts(cond)
[18:04:58.712]                         for (restart in restarts) {
[18:04:58.712]                           name <- restart$name
[18:04:58.712]                           if (is.null(name)) 
[18:04:58.712]                             next
[18:04:58.712]                           if (!grepl(pattern, name)) 
[18:04:58.712]                             next
[18:04:58.712]                           invokeRestart(restart)
[18:04:58.712]                           muffled <- TRUE
[18:04:58.712]                           break
[18:04:58.712]                         }
[18:04:58.712]                       }
[18:04:58.712]                     }
[18:04:58.712]                     invisible(muffled)
[18:04:58.712]                   }
[18:04:58.712]                   muffleCondition(cond)
[18:04:58.712]                 })
[18:04:58.712]             }))
[18:04:58.712]             future::FutureResult(value = ...future.value$value, 
[18:04:58.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.712]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.712]                     ...future.globalenv.names))
[18:04:58.712]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.712]         }, condition = base::local({
[18:04:58.712]             c <- base::c
[18:04:58.712]             inherits <- base::inherits
[18:04:58.712]             invokeRestart <- base::invokeRestart
[18:04:58.712]             length <- base::length
[18:04:58.712]             list <- base::list
[18:04:58.712]             seq.int <- base::seq.int
[18:04:58.712]             signalCondition <- base::signalCondition
[18:04:58.712]             sys.calls <- base::sys.calls
[18:04:58.712]             `[[` <- base::`[[`
[18:04:58.712]             `+` <- base::`+`
[18:04:58.712]             `<<-` <- base::`<<-`
[18:04:58.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.712]                   3L)]
[18:04:58.712]             }
[18:04:58.712]             function(cond) {
[18:04:58.712]                 is_error <- inherits(cond, "error")
[18:04:58.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.712]                   NULL)
[18:04:58.712]                 if (is_error) {
[18:04:58.712]                   sessionInformation <- function() {
[18:04:58.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.712]                       search = base::search(), system = base::Sys.info())
[18:04:58.712]                   }
[18:04:58.712]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.712]                     cond$call), session = sessionInformation(), 
[18:04:58.712]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.712]                   signalCondition(cond)
[18:04:58.712]                 }
[18:04:58.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.712]                 "immediateCondition"))) {
[18:04:58.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.712]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.712]                   if (TRUE && !signal) {
[18:04:58.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.712]                     {
[18:04:58.712]                       inherits <- base::inherits
[18:04:58.712]                       invokeRestart <- base::invokeRestart
[18:04:58.712]                       is.null <- base::is.null
[18:04:58.712]                       muffled <- FALSE
[18:04:58.712]                       if (inherits(cond, "message")) {
[18:04:58.712]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.712]                         if (muffled) 
[18:04:58.712]                           invokeRestart("muffleMessage")
[18:04:58.712]                       }
[18:04:58.712]                       else if (inherits(cond, "warning")) {
[18:04:58.712]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.712]                         if (muffled) 
[18:04:58.712]                           invokeRestart("muffleWarning")
[18:04:58.712]                       }
[18:04:58.712]                       else if (inherits(cond, "condition")) {
[18:04:58.712]                         if (!is.null(pattern)) {
[18:04:58.712]                           computeRestarts <- base::computeRestarts
[18:04:58.712]                           grepl <- base::grepl
[18:04:58.712]                           restarts <- computeRestarts(cond)
[18:04:58.712]                           for (restart in restarts) {
[18:04:58.712]                             name <- restart$name
[18:04:58.712]                             if (is.null(name)) 
[18:04:58.712]                               next
[18:04:58.712]                             if (!grepl(pattern, name)) 
[18:04:58.712]                               next
[18:04:58.712]                             invokeRestart(restart)
[18:04:58.712]                             muffled <- TRUE
[18:04:58.712]                             break
[18:04:58.712]                           }
[18:04:58.712]                         }
[18:04:58.712]                       }
[18:04:58.712]                       invisible(muffled)
[18:04:58.712]                     }
[18:04:58.712]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.712]                   }
[18:04:58.712]                 }
[18:04:58.712]                 else {
[18:04:58.712]                   if (TRUE) {
[18:04:58.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.712]                     {
[18:04:58.712]                       inherits <- base::inherits
[18:04:58.712]                       invokeRestart <- base::invokeRestart
[18:04:58.712]                       is.null <- base::is.null
[18:04:58.712]                       muffled <- FALSE
[18:04:58.712]                       if (inherits(cond, "message")) {
[18:04:58.712]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.712]                         if (muffled) 
[18:04:58.712]                           invokeRestart("muffleMessage")
[18:04:58.712]                       }
[18:04:58.712]                       else if (inherits(cond, "warning")) {
[18:04:58.712]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.712]                         if (muffled) 
[18:04:58.712]                           invokeRestart("muffleWarning")
[18:04:58.712]                       }
[18:04:58.712]                       else if (inherits(cond, "condition")) {
[18:04:58.712]                         if (!is.null(pattern)) {
[18:04:58.712]                           computeRestarts <- base::computeRestarts
[18:04:58.712]                           grepl <- base::grepl
[18:04:58.712]                           restarts <- computeRestarts(cond)
[18:04:58.712]                           for (restart in restarts) {
[18:04:58.712]                             name <- restart$name
[18:04:58.712]                             if (is.null(name)) 
[18:04:58.712]                               next
[18:04:58.712]                             if (!grepl(pattern, name)) 
[18:04:58.712]                               next
[18:04:58.712]                             invokeRestart(restart)
[18:04:58.712]                             muffled <- TRUE
[18:04:58.712]                             break
[18:04:58.712]                           }
[18:04:58.712]                         }
[18:04:58.712]                       }
[18:04:58.712]                       invisible(muffled)
[18:04:58.712]                     }
[18:04:58.712]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.712]                   }
[18:04:58.712]                 }
[18:04:58.712]             }
[18:04:58.712]         }))
[18:04:58.712]     }, error = function(ex) {
[18:04:58.712]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.712]                 ...future.rng), started = ...future.startTime, 
[18:04:58.712]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.712]             version = "1.8"), class = "FutureResult")
[18:04:58.712]     }, finally = {
[18:04:58.712]         if (!identical(...future.workdir, getwd())) 
[18:04:58.712]             setwd(...future.workdir)
[18:04:58.712]         {
[18:04:58.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.712]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.712]             }
[18:04:58.712]             base::options(...future.oldOptions)
[18:04:58.712]             if (.Platform$OS.type == "windows") {
[18:04:58.712]                 old_names <- names(...future.oldEnvVars)
[18:04:58.712]                 envs <- base::Sys.getenv()
[18:04:58.712]                 names <- names(envs)
[18:04:58.712]                 common <- intersect(names, old_names)
[18:04:58.712]                 added <- setdiff(names, old_names)
[18:04:58.712]                 removed <- setdiff(old_names, names)
[18:04:58.712]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.712]                   envs[common]]
[18:04:58.712]                 NAMES <- toupper(changed)
[18:04:58.712]                 args <- list()
[18:04:58.712]                 for (kk in seq_along(NAMES)) {
[18:04:58.712]                   name <- changed[[kk]]
[18:04:58.712]                   NAME <- NAMES[[kk]]
[18:04:58.712]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.712]                     next
[18:04:58.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.712]                 }
[18:04:58.712]                 NAMES <- toupper(added)
[18:04:58.712]                 for (kk in seq_along(NAMES)) {
[18:04:58.712]                   name <- added[[kk]]
[18:04:58.712]                   NAME <- NAMES[[kk]]
[18:04:58.712]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.712]                     next
[18:04:58.712]                   args[[name]] <- ""
[18:04:58.712]                 }
[18:04:58.712]                 NAMES <- toupper(removed)
[18:04:58.712]                 for (kk in seq_along(NAMES)) {
[18:04:58.712]                   name <- removed[[kk]]
[18:04:58.712]                   NAME <- NAMES[[kk]]
[18:04:58.712]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.712]                     next
[18:04:58.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.712]                 }
[18:04:58.712]                 if (length(args) > 0) 
[18:04:58.712]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.712]             }
[18:04:58.712]             else {
[18:04:58.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.712]             }
[18:04:58.712]             {
[18:04:58.712]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.712]                   0L) {
[18:04:58.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.712]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.712]                   base::options(opts)
[18:04:58.712]                 }
[18:04:58.712]                 {
[18:04:58.712]                   {
[18:04:58.712]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.712]                     NULL
[18:04:58.712]                   }
[18:04:58.712]                   options(future.plan = NULL)
[18:04:58.712]                   if (is.na(NA_character_)) 
[18:04:58.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.712]                     .init = FALSE)
[18:04:58.712]                 }
[18:04:58.712]             }
[18:04:58.712]         }
[18:04:58.712]     })
[18:04:58.712]     if (TRUE) {
[18:04:58.712]         base::sink(type = "output", split = FALSE)
[18:04:58.712]         if (TRUE) {
[18:04:58.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.712]         }
[18:04:58.712]         else {
[18:04:58.712]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.712]         }
[18:04:58.712]         base::close(...future.stdout)
[18:04:58.712]         ...future.stdout <- NULL
[18:04:58.712]     }
[18:04:58.712]     ...future.result$conditions <- ...future.conditions
[18:04:58.712]     ...future.result$finished <- base::Sys.time()
[18:04:58.712]     ...future.result
[18:04:58.712] }
[18:04:58.717] requestCore(): workers = 2
[18:04:58.722] MulticoreFuture started
[18:04:58.723] - Launch lazy future ... done
[18:04:58.725] run() for ‘MulticoreFuture’ ... done
[18:04:58.727] plan(): Setting new future strategy stack:
[18:04:58.728] List of future strategies:
[18:04:58.728] 1. sequential:
[18:04:58.728]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.728]    - tweaked: FALSE
[18:04:58.728]    - call: NULL
[18:04:58.731] plan(): nbrOfWorkers() = 1
[18:04:58.736] plan(): Setting new future strategy stack:
[18:04:58.736] List of future strategies:
[18:04:58.736] 1. multicore:
[18:04:58.736]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.736]    - tweaked: FALSE
[18:04:58.736]    - call: plan(strategy)
[18:04:58.747] plan(): nbrOfWorkers() = 2
[18:04:58.749] Future #1
[18:04:58.749] result() for MulticoreFuture ...
[18:04:58.752] result() for MulticoreFuture ...
[18:04:58.752] result() for MulticoreFuture ... done
[18:04:58.752] result() for MulticoreFuture ... done
[18:04:58.753] result() for MulticoreFuture ...
[18:04:58.755] result() for MulticoreFuture ... done
[18:04:58.756] A MulticoreFuture was resolved
[18:04:58.756]  length: 0 (resolved future 1)
[18:04:58.756] resolve() on list ... DONE
[18:04:58.757] - globals: [1] ‘a’
[18:04:58.758] Resolving futures part of globals (recursively) ... DONE
[18:04:58.764] The total size of the 1 globals is 1.57 MiB (1650112 bytes)
[18:04:58.766] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[18:04:58.766] - globals: [1] ‘a’
[18:04:58.766] - packages: [1] ‘future’
[18:04:58.767] getGlobalsAndPackages() ... DONE
[18:04:58.767] run() for ‘Future’ ...
[18:04:58.768] - state: ‘created’
[18:04:58.768] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.775] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.776] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.776]   - Field: ‘label’
[18:04:58.777]   - Field: ‘local’
[18:04:58.777]   - Field: ‘owner’
[18:04:58.777]   - Field: ‘envir’
[18:04:58.777]   - Field: ‘workers’
[18:04:58.778]   - Field: ‘packages’
[18:04:58.778]   - Field: ‘gc’
[18:04:58.778]   - Field: ‘job’
[18:04:58.779]   - Field: ‘conditions’
[18:04:58.779]   - Field: ‘expr’
[18:04:58.779]   - Field: ‘uuid’
[18:04:58.779]   - Field: ‘seed’
[18:04:58.780]   - Field: ‘version’
[18:04:58.780]   - Field: ‘result’
[18:04:58.780]   - Field: ‘asynchronous’
[18:04:58.780]   - Field: ‘calls’
[18:04:58.780]   - Field: ‘globals’
[18:04:58.781]   - Field: ‘stdout’
[18:04:58.781]   - Field: ‘earlySignal’
[18:04:58.781]   - Field: ‘lazy’
[18:04:58.781]   - Field: ‘state’
[18:04:58.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.782] - Launch lazy future ...
[18:04:58.783] Packages needed by the future expression (n = 1): ‘future’
[18:04:58.783] Packages needed by future strategies (n = 0): <none>
[18:04:58.784] {
[18:04:58.784]     {
[18:04:58.784]         {
[18:04:58.784]             ...future.startTime <- base::Sys.time()
[18:04:58.784]             {
[18:04:58.784]                 {
[18:04:58.784]                   {
[18:04:58.784]                     {
[18:04:58.784]                       {
[18:04:58.784]                         base::local({
[18:04:58.784]                           has_future <- base::requireNamespace("future", 
[18:04:58.784]                             quietly = TRUE)
[18:04:58.784]                           if (has_future) {
[18:04:58.784]                             ns <- base::getNamespace("future")
[18:04:58.784]                             version <- ns[[".package"]][["version"]]
[18:04:58.784]                             if (is.null(version)) 
[18:04:58.784]                               version <- utils::packageVersion("future")
[18:04:58.784]                           }
[18:04:58.784]                           else {
[18:04:58.784]                             version <- NULL
[18:04:58.784]                           }
[18:04:58.784]                           if (!has_future || version < "1.8.0") {
[18:04:58.784]                             info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.784]                               "", base::R.version$version.string), 
[18:04:58.784]                               platform = base::sprintf("%s (%s-bit)", 
[18:04:58.784]                                 base::R.version$platform, 8 * 
[18:04:58.784]                                   base::.Machine$sizeof.pointer), 
[18:04:58.784]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.784]                                 "release", "version")], collapse = " "), 
[18:04:58.784]                               hostname = base::Sys.info()[["nodename"]])
[18:04:58.784]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.784]                               info)
[18:04:58.784]                             info <- base::paste(info, collapse = "; ")
[18:04:58.784]                             if (!has_future) {
[18:04:58.784]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.784]                                 info)
[18:04:58.784]                             }
[18:04:58.784]                             else {
[18:04:58.784]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.784]                                 info, version)
[18:04:58.784]                             }
[18:04:58.784]                             base::stop(msg)
[18:04:58.784]                           }
[18:04:58.784]                         })
[18:04:58.784]                       }
[18:04:58.784]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.784]                       base::options(mc.cores = 1L)
[18:04:58.784]                     }
[18:04:58.784]                     base::local({
[18:04:58.784]                       for (pkg in "future") {
[18:04:58.784]                         base::loadNamespace(pkg)
[18:04:58.784]                         base::library(pkg, character.only = TRUE)
[18:04:58.784]                       }
[18:04:58.784]                     })
[18:04:58.784]                   }
[18:04:58.784]                   ...future.strategy.old <- future::plan("list")
[18:04:58.784]                   options(future.plan = NULL)
[18:04:58.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.784]                 }
[18:04:58.784]                 ...future.workdir <- getwd()
[18:04:58.784]             }
[18:04:58.784]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.784]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.784]         }
[18:04:58.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.784]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.784]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.784]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.784]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.784]             base::names(...future.oldOptions))
[18:04:58.784]     }
[18:04:58.784]     if (FALSE) {
[18:04:58.784]     }
[18:04:58.784]     else {
[18:04:58.784]         if (TRUE) {
[18:04:58.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.784]                 open = "w")
[18:04:58.784]         }
[18:04:58.784]         else {
[18:04:58.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.784]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.784]         }
[18:04:58.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.784]             base::sink(type = "output", split = FALSE)
[18:04:58.784]             base::close(...future.stdout)
[18:04:58.784]         }, add = TRUE)
[18:04:58.784]     }
[18:04:58.784]     ...future.frame <- base::sys.nframe()
[18:04:58.784]     ...future.conditions <- base::list()
[18:04:58.784]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.784]     if (FALSE) {
[18:04:58.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.784]     }
[18:04:58.784]     ...future.result <- base::tryCatch({
[18:04:58.784]         base::withCallingHandlers({
[18:04:58.784]             ...future.value <- base::withVisible(base::local({
[18:04:58.784]                 withCallingHandlers({
[18:04:58.784]                   value(a) + 1
[18:04:58.784]                 }, immediateCondition = function(cond) {
[18:04:58.784]                   save_rds <- function (object, pathname, ...) 
[18:04:58.784]                   {
[18:04:58.784]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.784]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.784]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.784]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.784]                         fi_tmp[["mtime"]])
[18:04:58.784]                     }
[18:04:58.784]                     tryCatch({
[18:04:58.784]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.784]                     }, error = function(ex) {
[18:04:58.784]                       msg <- conditionMessage(ex)
[18:04:58.784]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.784]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.784]                         fi_tmp[["mtime"]], msg)
[18:04:58.784]                       ex$message <- msg
[18:04:58.784]                       stop(ex)
[18:04:58.784]                     })
[18:04:58.784]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.784]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.784]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.784]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.784]                       fi <- file.info(pathname)
[18:04:58.784]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.784]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.784]                         fi[["size"]], fi[["mtime"]])
[18:04:58.784]                       stop(msg)
[18:04:58.784]                     }
[18:04:58.784]                     invisible(pathname)
[18:04:58.784]                   }
[18:04:58.784]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.784]                     rootPath = tempdir()) 
[18:04:58.784]                   {
[18:04:58.784]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.784]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.784]                       tmpdir = path, fileext = ".rds")
[18:04:58.784]                     save_rds(obj, file)
[18:04:58.784]                   }
[18:04:58.784]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.784]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.784]                   {
[18:04:58.784]                     inherits <- base::inherits
[18:04:58.784]                     invokeRestart <- base::invokeRestart
[18:04:58.784]                     is.null <- base::is.null
[18:04:58.784]                     muffled <- FALSE
[18:04:58.784]                     if (inherits(cond, "message")) {
[18:04:58.784]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.784]                       if (muffled) 
[18:04:58.784]                         invokeRestart("muffleMessage")
[18:04:58.784]                     }
[18:04:58.784]                     else if (inherits(cond, "warning")) {
[18:04:58.784]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.784]                       if (muffled) 
[18:04:58.784]                         invokeRestart("muffleWarning")
[18:04:58.784]                     }
[18:04:58.784]                     else if (inherits(cond, "condition")) {
[18:04:58.784]                       if (!is.null(pattern)) {
[18:04:58.784]                         computeRestarts <- base::computeRestarts
[18:04:58.784]                         grepl <- base::grepl
[18:04:58.784]                         restarts <- computeRestarts(cond)
[18:04:58.784]                         for (restart in restarts) {
[18:04:58.784]                           name <- restart$name
[18:04:58.784]                           if (is.null(name)) 
[18:04:58.784]                             next
[18:04:58.784]                           if (!grepl(pattern, name)) 
[18:04:58.784]                             next
[18:04:58.784]                           invokeRestart(restart)
[18:04:58.784]                           muffled <- TRUE
[18:04:58.784]                           break
[18:04:58.784]                         }
[18:04:58.784]                       }
[18:04:58.784]                     }
[18:04:58.784]                     invisible(muffled)
[18:04:58.784]                   }
[18:04:58.784]                   muffleCondition(cond)
[18:04:58.784]                 })
[18:04:58.784]             }))
[18:04:58.784]             future::FutureResult(value = ...future.value$value, 
[18:04:58.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.784]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.784]                     ...future.globalenv.names))
[18:04:58.784]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.784]         }, condition = base::local({
[18:04:58.784]             c <- base::c
[18:04:58.784]             inherits <- base::inherits
[18:04:58.784]             invokeRestart <- base::invokeRestart
[18:04:58.784]             length <- base::length
[18:04:58.784]             list <- base::list
[18:04:58.784]             seq.int <- base::seq.int
[18:04:58.784]             signalCondition <- base::signalCondition
[18:04:58.784]             sys.calls <- base::sys.calls
[18:04:58.784]             `[[` <- base::`[[`
[18:04:58.784]             `+` <- base::`+`
[18:04:58.784]             `<<-` <- base::`<<-`
[18:04:58.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.784]                   3L)]
[18:04:58.784]             }
[18:04:58.784]             function(cond) {
[18:04:58.784]                 is_error <- inherits(cond, "error")
[18:04:58.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.784]                   NULL)
[18:04:58.784]                 if (is_error) {
[18:04:58.784]                   sessionInformation <- function() {
[18:04:58.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.784]                       search = base::search(), system = base::Sys.info())
[18:04:58.784]                   }
[18:04:58.784]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.784]                     cond$call), session = sessionInformation(), 
[18:04:58.784]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.784]                   signalCondition(cond)
[18:04:58.784]                 }
[18:04:58.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.784]                 "immediateCondition"))) {
[18:04:58.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.784]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.784]                   if (TRUE && !signal) {
[18:04:58.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.784]                     {
[18:04:58.784]                       inherits <- base::inherits
[18:04:58.784]                       invokeRestart <- base::invokeRestart
[18:04:58.784]                       is.null <- base::is.null
[18:04:58.784]                       muffled <- FALSE
[18:04:58.784]                       if (inherits(cond, "message")) {
[18:04:58.784]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.784]                         if (muffled) 
[18:04:58.784]                           invokeRestart("muffleMessage")
[18:04:58.784]                       }
[18:04:58.784]                       else if (inherits(cond, "warning")) {
[18:04:58.784]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.784]                         if (muffled) 
[18:04:58.784]                           invokeRestart("muffleWarning")
[18:04:58.784]                       }
[18:04:58.784]                       else if (inherits(cond, "condition")) {
[18:04:58.784]                         if (!is.null(pattern)) {
[18:04:58.784]                           computeRestarts <- base::computeRestarts
[18:04:58.784]                           grepl <- base::grepl
[18:04:58.784]                           restarts <- computeRestarts(cond)
[18:04:58.784]                           for (restart in restarts) {
[18:04:58.784]                             name <- restart$name
[18:04:58.784]                             if (is.null(name)) 
[18:04:58.784]                               next
[18:04:58.784]                             if (!grepl(pattern, name)) 
[18:04:58.784]                               next
[18:04:58.784]                             invokeRestart(restart)
[18:04:58.784]                             muffled <- TRUE
[18:04:58.784]                             break
[18:04:58.784]                           }
[18:04:58.784]                         }
[18:04:58.784]                       }
[18:04:58.784]                       invisible(muffled)
[18:04:58.784]                     }
[18:04:58.784]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.784]                   }
[18:04:58.784]                 }
[18:04:58.784]                 else {
[18:04:58.784]                   if (TRUE) {
[18:04:58.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.784]                     {
[18:04:58.784]                       inherits <- base::inherits
[18:04:58.784]                       invokeRestart <- base::invokeRestart
[18:04:58.784]                       is.null <- base::is.null
[18:04:58.784]                       muffled <- FALSE
[18:04:58.784]                       if (inherits(cond, "message")) {
[18:04:58.784]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.784]                         if (muffled) 
[18:04:58.784]                           invokeRestart("muffleMessage")
[18:04:58.784]                       }
[18:04:58.784]                       else if (inherits(cond, "warning")) {
[18:04:58.784]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.784]                         if (muffled) 
[18:04:58.784]                           invokeRestart("muffleWarning")
[18:04:58.784]                       }
[18:04:58.784]                       else if (inherits(cond, "condition")) {
[18:04:58.784]                         if (!is.null(pattern)) {
[18:04:58.784]                           computeRestarts <- base::computeRestarts
[18:04:58.784]                           grepl <- base::grepl
[18:04:58.784]                           restarts <- computeRestarts(cond)
[18:04:58.784]                           for (restart in restarts) {
[18:04:58.784]                             name <- restart$name
[18:04:58.784]                             if (is.null(name)) 
[18:04:58.784]                               next
[18:04:58.784]                             if (!grepl(pattern, name)) 
[18:04:58.784]                               next
[18:04:58.784]                             invokeRestart(restart)
[18:04:58.784]                             muffled <- TRUE
[18:04:58.784]                             break
[18:04:58.784]                           }
[18:04:58.784]                         }
[18:04:58.784]                       }
[18:04:58.784]                       invisible(muffled)
[18:04:58.784]                     }
[18:04:58.784]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.784]                   }
[18:04:58.784]                 }
[18:04:58.784]             }
[18:04:58.784]         }))
[18:04:58.784]     }, error = function(ex) {
[18:04:58.784]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.784]                 ...future.rng), started = ...future.startTime, 
[18:04:58.784]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.784]             version = "1.8"), class = "FutureResult")
[18:04:58.784]     }, finally = {
[18:04:58.784]         if (!identical(...future.workdir, getwd())) 
[18:04:58.784]             setwd(...future.workdir)
[18:04:58.784]         {
[18:04:58.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.784]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.784]             }
[18:04:58.784]             base::options(...future.oldOptions)
[18:04:58.784]             if (.Platform$OS.type == "windows") {
[18:04:58.784]                 old_names <- names(...future.oldEnvVars)
[18:04:58.784]                 envs <- base::Sys.getenv()
[18:04:58.784]                 names <- names(envs)
[18:04:58.784]                 common <- intersect(names, old_names)
[18:04:58.784]                 added <- setdiff(names, old_names)
[18:04:58.784]                 removed <- setdiff(old_names, names)
[18:04:58.784]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.784]                   envs[common]]
[18:04:58.784]                 NAMES <- toupper(changed)
[18:04:58.784]                 args <- list()
[18:04:58.784]                 for (kk in seq_along(NAMES)) {
[18:04:58.784]                   name <- changed[[kk]]
[18:04:58.784]                   NAME <- NAMES[[kk]]
[18:04:58.784]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.784]                     next
[18:04:58.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.784]                 }
[18:04:58.784]                 NAMES <- toupper(added)
[18:04:58.784]                 for (kk in seq_along(NAMES)) {
[18:04:58.784]                   name <- added[[kk]]
[18:04:58.784]                   NAME <- NAMES[[kk]]
[18:04:58.784]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.784]                     next
[18:04:58.784]                   args[[name]] <- ""
[18:04:58.784]                 }
[18:04:58.784]                 NAMES <- toupper(removed)
[18:04:58.784]                 for (kk in seq_along(NAMES)) {
[18:04:58.784]                   name <- removed[[kk]]
[18:04:58.784]                   NAME <- NAMES[[kk]]
[18:04:58.784]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.784]                     next
[18:04:58.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.784]                 }
[18:04:58.784]                 if (length(args) > 0) 
[18:04:58.784]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.784]             }
[18:04:58.784]             else {
[18:04:58.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.784]             }
[18:04:58.784]             {
[18:04:58.784]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.784]                   0L) {
[18:04:58.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.784]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.784]                   base::options(opts)
[18:04:58.784]                 }
[18:04:58.784]                 {
[18:04:58.784]                   {
[18:04:58.784]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.784]                     NULL
[18:04:58.784]                   }
[18:04:58.784]                   options(future.plan = NULL)
[18:04:58.784]                   if (is.na(NA_character_)) 
[18:04:58.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.784]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.784]                     .init = FALSE)
[18:04:58.784]                 }
[18:04:58.784]             }
[18:04:58.784]         }
[18:04:58.784]     })
[18:04:58.784]     if (TRUE) {
[18:04:58.784]         base::sink(type = "output", split = FALSE)
[18:04:58.784]         if (TRUE) {
[18:04:58.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.784]         }
[18:04:58.784]         else {
[18:04:58.784]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.784]         }
[18:04:58.784]         base::close(...future.stdout)
[18:04:58.784]         ...future.stdout <- NULL
[18:04:58.784]     }
[18:04:58.784]     ...future.result$conditions <- ...future.conditions
[18:04:58.784]     ...future.result$finished <- base::Sys.time()
[18:04:58.784]     ...future.result
[18:04:58.784] }
[18:04:58.790] assign_globals() ...
[18:04:58.790] List of 1
[18:04:58.790]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5b9577954348> 
[18:04:58.790]  - attr(*, "where")=List of 1
[18:04:58.790]   ..$ a:<environment: R_EmptyEnv> 
[18:04:58.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:58.790]  - attr(*, "resolved")= logi TRUE
[18:04:58.790]  - attr(*, "total_size")= num 1650112
[18:04:58.790]  - attr(*, "already-done")= logi TRUE
[18:04:58.797] - copied ‘a’ to environment
[18:04:58.797] assign_globals() ... done
[18:04:58.797] requestCore(): workers = 2
[18:04:58.803] MulticoreFuture started
[18:04:58.804] - Launch lazy future ... done
[18:04:58.806] plan(): Setting new future strategy stack:
[18:04:58.807] run() for ‘MulticoreFuture’ ... done
[18:04:58.807] result() for MulticoreFuture ...
[18:04:58.807] List of future strategies:
[18:04:58.807] 1. sequential:
[18:04:58.807]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.807]    - tweaked: FALSE
[18:04:58.807]    - call: NULL
[18:04:58.812] plan(): nbrOfWorkers() = 1
[18:04:58.819] plan(): Setting new future strategy stack:
[18:04:58.819] List of future strategies:
[18:04:58.819] 1. multicore:
[18:04:58.819]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.819]    - tweaked: FALSE
[18:04:58.819]    - call: plan(strategy)
[18:04:58.839] plan(): nbrOfWorkers() = 2
[18:04:58.840] result() for MulticoreFuture ...
[18:04:58.841] result() for MulticoreFuture ... done
[18:04:58.841] signalConditions() ...
[18:04:58.843]  - include = ‘immediateCondition’
[18:04:58.844]  - exclude = 
[18:04:58.844]  - resignal = FALSE
[18:04:58.844]  - Number of conditions: 4
[18:04:58.844] signalConditions() ... done
[18:04:58.845] result() for MulticoreFuture ... done
[18:04:58.847] result() for MulticoreFuture ...
[18:04:58.847] result() for MulticoreFuture ... done
[18:04:58.847] signalConditions() ...
[18:04:58.848]  - include = ‘immediateCondition’
[18:04:58.848]  - exclude = 
[18:04:58.848]  - resignal = FALSE
[18:04:58.848]  - Number of conditions: 4
[18:04:58.849] signalConditions() ... done
[18:04:58.853] Future state: ‘finished’
[18:04:58.854] result() for MulticoreFuture ...
[18:04:58.855] result() for MulticoreFuture ... done
[18:04:58.855] signalConditions() ...
[18:04:58.855]  - include = ‘condition’
[18:04:58.856]  - exclude = ‘immediateCondition’
[18:04:58.856]  - resignal = TRUE
[18:04:58.856]  - Number of conditions: 4
[18:04:58.856]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.814] result() for MulticoreFuture ...
[18:04:58.857]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.815] result() for MulticoreFuture ... done
[18:04:58.857]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.816] result() for MulticoreFuture ...
[18:04:58.857]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.816] result() for MulticoreFuture ... done
[18:04:58.858] signalConditions() ... done
value(b) = 2
[18:04:58.858] result() for MulticoreFuture ...
[18:04:58.858] result() for MulticoreFuture ... done
[18:04:58.859] result() for MulticoreFuture ...
[18:04:58.859] result() for MulticoreFuture ... done
[18:04:58.859] signalConditions() ...
[18:04:58.859]  - include = ‘immediateCondition’
[18:04:58.860]  - exclude = 
[18:04:58.860]  - resignal = FALSE
[18:04:58.860]  - Number of conditions: 4
[18:04:58.861] signalConditions() ... done
[18:04:58.861] Future state: ‘finished’
[18:04:58.861] result() for MulticoreFuture ...
[18:04:58.862] result() for MulticoreFuture ... done
[18:04:58.862] signalConditions() ...
[18:04:58.862]  - include = ‘condition’
[18:04:58.862]  - exclude = ‘immediateCondition’
[18:04:58.862]  - resignal = TRUE
[18:04:58.863]  - Number of conditions: 4
[18:04:58.863]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.814] result() for MulticoreFuture ...
[18:04:58.863]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.815] result() for MulticoreFuture ... done
[18:04:58.864]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.816] result() for MulticoreFuture ...
[18:04:58.864]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:58.816] result() for MulticoreFuture ... done
[18:04:58.864] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.865] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.866] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.869] - globals found: [2] ‘{’, ‘pkg’
[18:04:58.869] Searching for globals ... DONE
[18:04:58.869] Resolving globals: TRUE
[18:04:58.870] Resolving any globals that are futures ...
[18:04:58.870] - globals: [2] ‘{’, ‘pkg’
[18:04:58.870] Resolving any globals that are futures ... DONE
[18:04:58.871] Resolving futures part of globals (recursively) ...
[18:04:58.872] resolve() on list ...
[18:04:58.872]  recursive: 99
[18:04:58.872]  length: 1
[18:04:58.873]  elements: ‘pkg’
[18:04:58.873]  length: 0 (resolved future 1)
[18:04:58.873] resolve() on list ... DONE
[18:04:58.873] - globals: [1] ‘pkg’
[18:04:58.874] Resolving futures part of globals (recursively) ... DONE
[18:04:58.874] The total size of the 1 globals is 112 bytes (112 bytes)
[18:04:58.875] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[18:04:58.875] - globals: [1] ‘pkg’
[18:04:58.876] 
[18:04:58.876] getGlobalsAndPackages() ... DONE
[18:04:58.877] Packages needed by the future expression (n = 0): <none>
[18:04:58.877] Packages needed by future strategies (n = 0): <none>
[18:04:58.878] {
[18:04:58.878]     {
[18:04:58.878]         {
[18:04:58.878]             ...future.startTime <- base::Sys.time()
[18:04:58.878]             {
[18:04:58.878]                 {
[18:04:58.878]                   {
[18:04:58.878]                     base::local({
[18:04:58.878]                       has_future <- base::requireNamespace("future", 
[18:04:58.878]                         quietly = TRUE)
[18:04:58.878]                       if (has_future) {
[18:04:58.878]                         ns <- base::getNamespace("future")
[18:04:58.878]                         version <- ns[[".package"]][["version"]]
[18:04:58.878]                         if (is.null(version)) 
[18:04:58.878]                           version <- utils::packageVersion("future")
[18:04:58.878]                       }
[18:04:58.878]                       else {
[18:04:58.878]                         version <- NULL
[18:04:58.878]                       }
[18:04:58.878]                       if (!has_future || version < "1.8.0") {
[18:04:58.878]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.878]                           "", base::R.version$version.string), 
[18:04:58.878]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:58.878]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:58.878]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.878]                             "release", "version")], collapse = " "), 
[18:04:58.878]                           hostname = base::Sys.info()[["nodename"]])
[18:04:58.878]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.878]                           info)
[18:04:58.878]                         info <- base::paste(info, collapse = "; ")
[18:04:58.878]                         if (!has_future) {
[18:04:58.878]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.878]                             info)
[18:04:58.878]                         }
[18:04:58.878]                         else {
[18:04:58.878]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.878]                             info, version)
[18:04:58.878]                         }
[18:04:58.878]                         base::stop(msg)
[18:04:58.878]                       }
[18:04:58.878]                     })
[18:04:58.878]                   }
[18:04:58.878]                   ...future.strategy.old <- future::plan("list")
[18:04:58.878]                   options(future.plan = NULL)
[18:04:58.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.878]                 }
[18:04:58.878]                 ...future.workdir <- getwd()
[18:04:58.878]             }
[18:04:58.878]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.878]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.878]         }
[18:04:58.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.878]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.878]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.878]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.878]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.878]             base::names(...future.oldOptions))
[18:04:58.878]     }
[18:04:58.878]     if (FALSE) {
[18:04:58.878]     }
[18:04:58.878]     else {
[18:04:58.878]         if (TRUE) {
[18:04:58.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.878]                 open = "w")
[18:04:58.878]         }
[18:04:58.878]         else {
[18:04:58.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.878]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.878]         }
[18:04:58.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.878]             base::sink(type = "output", split = FALSE)
[18:04:58.878]             base::close(...future.stdout)
[18:04:58.878]         }, add = TRUE)
[18:04:58.878]     }
[18:04:58.878]     ...future.frame <- base::sys.nframe()
[18:04:58.878]     ...future.conditions <- base::list()
[18:04:58.878]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.878]     if (FALSE) {
[18:04:58.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.878]     }
[18:04:58.878]     ...future.result <- base::tryCatch({
[18:04:58.878]         base::withCallingHandlers({
[18:04:58.878]             ...future.value <- base::withVisible(base::local({
[18:04:58.878]                 pkg
[18:04:58.878]             }))
[18:04:58.878]             future::FutureResult(value = ...future.value$value, 
[18:04:58.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.878]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.878]                     ...future.globalenv.names))
[18:04:58.878]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.878]         }, condition = base::local({
[18:04:58.878]             c <- base::c
[18:04:58.878]             inherits <- base::inherits
[18:04:58.878]             invokeRestart <- base::invokeRestart
[18:04:58.878]             length <- base::length
[18:04:58.878]             list <- base::list
[18:04:58.878]             seq.int <- base::seq.int
[18:04:58.878]             signalCondition <- base::signalCondition
[18:04:58.878]             sys.calls <- base::sys.calls
[18:04:58.878]             `[[` <- base::`[[`
[18:04:58.878]             `+` <- base::`+`
[18:04:58.878]             `<<-` <- base::`<<-`
[18:04:58.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.878]                   3L)]
[18:04:58.878]             }
[18:04:58.878]             function(cond) {
[18:04:58.878]                 is_error <- inherits(cond, "error")
[18:04:58.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.878]                   NULL)
[18:04:58.878]                 if (is_error) {
[18:04:58.878]                   sessionInformation <- function() {
[18:04:58.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.878]                       search = base::search(), system = base::Sys.info())
[18:04:58.878]                   }
[18:04:58.878]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.878]                     cond$call), session = sessionInformation(), 
[18:04:58.878]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.878]                   signalCondition(cond)
[18:04:58.878]                 }
[18:04:58.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.878]                 "immediateCondition"))) {
[18:04:58.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.878]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.878]                   if (TRUE && !signal) {
[18:04:58.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.878]                     {
[18:04:58.878]                       inherits <- base::inherits
[18:04:58.878]                       invokeRestart <- base::invokeRestart
[18:04:58.878]                       is.null <- base::is.null
[18:04:58.878]                       muffled <- FALSE
[18:04:58.878]                       if (inherits(cond, "message")) {
[18:04:58.878]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.878]                         if (muffled) 
[18:04:58.878]                           invokeRestart("muffleMessage")
[18:04:58.878]                       }
[18:04:58.878]                       else if (inherits(cond, "warning")) {
[18:04:58.878]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.878]                         if (muffled) 
[18:04:58.878]                           invokeRestart("muffleWarning")
[18:04:58.878]                       }
[18:04:58.878]                       else if (inherits(cond, "condition")) {
[18:04:58.878]                         if (!is.null(pattern)) {
[18:04:58.878]                           computeRestarts <- base::computeRestarts
[18:04:58.878]                           grepl <- base::grepl
[18:04:58.878]                           restarts <- computeRestarts(cond)
[18:04:58.878]                           for (restart in restarts) {
[18:04:58.878]                             name <- restart$name
[18:04:58.878]                             if (is.null(name)) 
[18:04:58.878]                               next
[18:04:58.878]                             if (!grepl(pattern, name)) 
[18:04:58.878]                               next
[18:04:58.878]                             invokeRestart(restart)
[18:04:58.878]                             muffled <- TRUE
[18:04:58.878]                             break
[18:04:58.878]                           }
[18:04:58.878]                         }
[18:04:58.878]                       }
[18:04:58.878]                       invisible(muffled)
[18:04:58.878]                     }
[18:04:58.878]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.878]                   }
[18:04:58.878]                 }
[18:04:58.878]                 else {
[18:04:58.878]                   if (TRUE) {
[18:04:58.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.878]                     {
[18:04:58.878]                       inherits <- base::inherits
[18:04:58.878]                       invokeRestart <- base::invokeRestart
[18:04:58.878]                       is.null <- base::is.null
[18:04:58.878]                       muffled <- FALSE
[18:04:58.878]                       if (inherits(cond, "message")) {
[18:04:58.878]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.878]                         if (muffled) 
[18:04:58.878]                           invokeRestart("muffleMessage")
[18:04:58.878]                       }
[18:04:58.878]                       else if (inherits(cond, "warning")) {
[18:04:58.878]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.878]                         if (muffled) 
[18:04:58.878]                           invokeRestart("muffleWarning")
[18:04:58.878]                       }
[18:04:58.878]                       else if (inherits(cond, "condition")) {
[18:04:58.878]                         if (!is.null(pattern)) {
[18:04:58.878]                           computeRestarts <- base::computeRestarts
[18:04:58.878]                           grepl <- base::grepl
[18:04:58.878]                           restarts <- computeRestarts(cond)
[18:04:58.878]                           for (restart in restarts) {
[18:04:58.878]                             name <- restart$name
[18:04:58.878]                             if (is.null(name)) 
[18:04:58.878]                               next
[18:04:58.878]                             if (!grepl(pattern, name)) 
[18:04:58.878]                               next
[18:04:58.878]                             invokeRestart(restart)
[18:04:58.878]                             muffled <- TRUE
[18:04:58.878]                             break
[18:04:58.878]                           }
[18:04:58.878]                         }
[18:04:58.878]                       }
[18:04:58.878]                       invisible(muffled)
[18:04:58.878]                     }
[18:04:58.878]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.878]                   }
[18:04:58.878]                 }
[18:04:58.878]             }
[18:04:58.878]         }))
[18:04:58.878]     }, error = function(ex) {
[18:04:58.878]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.878]                 ...future.rng), started = ...future.startTime, 
[18:04:58.878]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.878]             version = "1.8"), class = "FutureResult")
[18:04:58.878]     }, finally = {
[18:04:58.878]         if (!identical(...future.workdir, getwd())) 
[18:04:58.878]             setwd(...future.workdir)
[18:04:58.878]         {
[18:04:58.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.878]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.878]             }
[18:04:58.878]             base::options(...future.oldOptions)
[18:04:58.878]             if (.Platform$OS.type == "windows") {
[18:04:58.878]                 old_names <- names(...future.oldEnvVars)
[18:04:58.878]                 envs <- base::Sys.getenv()
[18:04:58.878]                 names <- names(envs)
[18:04:58.878]                 common <- intersect(names, old_names)
[18:04:58.878]                 added <- setdiff(names, old_names)
[18:04:58.878]                 removed <- setdiff(old_names, names)
[18:04:58.878]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.878]                   envs[common]]
[18:04:58.878]                 NAMES <- toupper(changed)
[18:04:58.878]                 args <- list()
[18:04:58.878]                 for (kk in seq_along(NAMES)) {
[18:04:58.878]                   name <- changed[[kk]]
[18:04:58.878]                   NAME <- NAMES[[kk]]
[18:04:58.878]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.878]                     next
[18:04:58.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.878]                 }
[18:04:58.878]                 NAMES <- toupper(added)
[18:04:58.878]                 for (kk in seq_along(NAMES)) {
[18:04:58.878]                   name <- added[[kk]]
[18:04:58.878]                   NAME <- NAMES[[kk]]
[18:04:58.878]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.878]                     next
[18:04:58.878]                   args[[name]] <- ""
[18:04:58.878]                 }
[18:04:58.878]                 NAMES <- toupper(removed)
[18:04:58.878]                 for (kk in seq_along(NAMES)) {
[18:04:58.878]                   name <- removed[[kk]]
[18:04:58.878]                   NAME <- NAMES[[kk]]
[18:04:58.878]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.878]                     next
[18:04:58.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.878]                 }
[18:04:58.878]                 if (length(args) > 0) 
[18:04:58.878]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.878]             }
[18:04:58.878]             else {
[18:04:58.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.878]             }
[18:04:58.878]             {
[18:04:58.878]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.878]                   0L) {
[18:04:58.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.878]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.878]                   base::options(opts)
[18:04:58.878]                 }
[18:04:58.878]                 {
[18:04:58.878]                   {
[18:04:58.878]                     NULL
[18:04:58.878]                     RNGkind("Mersenne-Twister")
[18:04:58.878]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:58.878]                       inherits = FALSE)
[18:04:58.878]                   }
[18:04:58.878]                   options(future.plan = NULL)
[18:04:58.878]                   if (is.na(NA_character_)) 
[18:04:58.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.878]                     .init = FALSE)
[18:04:58.878]                 }
[18:04:58.878]             }
[18:04:58.878]         }
[18:04:58.878]     })
[18:04:58.878]     if (TRUE) {
[18:04:58.878]         base::sink(type = "output", split = FALSE)
[18:04:58.878]         if (TRUE) {
[18:04:58.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.878]         }
[18:04:58.878]         else {
[18:04:58.878]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.878]         }
[18:04:58.878]         base::close(...future.stdout)
[18:04:58.878]         ...future.stdout <- NULL
[18:04:58.878]     }
[18:04:58.878]     ...future.result$conditions <- ...future.conditions
[18:04:58.878]     ...future.result$finished <- base::Sys.time()
[18:04:58.878]     ...future.result
[18:04:58.878] }
[18:04:58.882] assign_globals() ...
[18:04:58.882] List of 1
[18:04:58.882]  $ pkg: chr "foo"
[18:04:58.882]  - attr(*, "where")=List of 1
[18:04:58.882]   ..$ pkg:<environment: R_EmptyEnv> 
[18:04:58.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:58.882]  - attr(*, "resolved")= logi TRUE
[18:04:58.882]  - attr(*, "total_size")= num 112
[18:04:58.888] - copied ‘pkg’ to environment
[18:04:58.888] assign_globals() ... done
[18:04:58.888] plan(): Setting new future strategy stack:
[18:04:58.889] List of future strategies:
[18:04:58.889] 1. sequential:
[18:04:58.889]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.889]    - tweaked: FALSE
[18:04:58.889]    - call: NULL
[18:04:58.890] plan(): nbrOfWorkers() = 1
[18:04:58.892] plan(): Setting new future strategy stack:
[18:04:58.892] List of future strategies:
[18:04:58.892] 1. multicore:
[18:04:58.892]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.892]    - tweaked: FALSE
[18:04:58.892]    - call: plan(strategy)
[18:04:58.899] plan(): nbrOfWorkers() = 2
[18:04:58.899] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.901] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.901] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.906] - globals found: [3] ‘{’, ‘<-’, ‘+’
[18:04:58.906] Searching for globals ... DONE
[18:04:58.906] Resolving globals: TRUE
[18:04:58.907] Resolving any globals that are futures ...
[18:04:58.907] - globals: [3] ‘{’, ‘<-’, ‘+’
[18:04:58.907] Resolving any globals that are futures ... DONE
[18:04:58.908] 
[18:04:58.908] 
[18:04:58.909] getGlobalsAndPackages() ... DONE
[18:04:58.909] run() for ‘Future’ ...
[18:04:58.909] - state: ‘created’
[18:04:58.910] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.917] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.917]   - Field: ‘label’
[18:04:58.917]   - Field: ‘local’
[18:04:58.918]   - Field: ‘owner’
[18:04:58.918]   - Field: ‘envir’
[18:04:58.918]   - Field: ‘workers’
[18:04:58.918]   - Field: ‘packages’
[18:04:58.919]   - Field: ‘gc’
[18:04:58.919]   - Field: ‘job’
[18:04:58.919]   - Field: ‘conditions’
[18:04:58.919]   - Field: ‘expr’
[18:04:58.919]   - Field: ‘uuid’
[18:04:58.920]   - Field: ‘seed’
[18:04:58.920]   - Field: ‘version’
[18:04:58.920]   - Field: ‘result’
[18:04:58.920]   - Field: ‘asynchronous’
[18:04:58.920]   - Field: ‘calls’
[18:04:58.921]   - Field: ‘globals’
[18:04:58.921]   - Field: ‘stdout’
[18:04:58.921]   - Field: ‘earlySignal’
[18:04:58.921]   - Field: ‘lazy’
[18:04:58.922]   - Field: ‘state’
[18:04:58.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.922] - Launch lazy future ...
[18:04:58.923] Packages needed by the future expression (n = 0): <none>
[18:04:58.923] Packages needed by future strategies (n = 0): <none>
[18:04:58.924] {
[18:04:58.924]     {
[18:04:58.924]         {
[18:04:58.924]             ...future.startTime <- base::Sys.time()
[18:04:58.924]             {
[18:04:58.924]                 {
[18:04:58.924]                   {
[18:04:58.924]                     {
[18:04:58.924]                       base::local({
[18:04:58.924]                         has_future <- base::requireNamespace("future", 
[18:04:58.924]                           quietly = TRUE)
[18:04:58.924]                         if (has_future) {
[18:04:58.924]                           ns <- base::getNamespace("future")
[18:04:58.924]                           version <- ns[[".package"]][["version"]]
[18:04:58.924]                           if (is.null(version)) 
[18:04:58.924]                             version <- utils::packageVersion("future")
[18:04:58.924]                         }
[18:04:58.924]                         else {
[18:04:58.924]                           version <- NULL
[18:04:58.924]                         }
[18:04:58.924]                         if (!has_future || version < "1.8.0") {
[18:04:58.924]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.924]                             "", base::R.version$version.string), 
[18:04:58.924]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:58.924]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:58.924]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.924]                               "release", "version")], collapse = " "), 
[18:04:58.924]                             hostname = base::Sys.info()[["nodename"]])
[18:04:58.924]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.924]                             info)
[18:04:58.924]                           info <- base::paste(info, collapse = "; ")
[18:04:58.924]                           if (!has_future) {
[18:04:58.924]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.924]                               info)
[18:04:58.924]                           }
[18:04:58.924]                           else {
[18:04:58.924]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.924]                               info, version)
[18:04:58.924]                           }
[18:04:58.924]                           base::stop(msg)
[18:04:58.924]                         }
[18:04:58.924]                       })
[18:04:58.924]                     }
[18:04:58.924]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.924]                     base::options(mc.cores = 1L)
[18:04:58.924]                   }
[18:04:58.924]                   ...future.strategy.old <- future::plan("list")
[18:04:58.924]                   options(future.plan = NULL)
[18:04:58.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.924]                 }
[18:04:58.924]                 ...future.workdir <- getwd()
[18:04:58.924]             }
[18:04:58.924]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.924]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.924]         }
[18:04:58.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.924]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.924]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.924]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.924]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.924]             base::names(...future.oldOptions))
[18:04:58.924]     }
[18:04:58.924]     if (FALSE) {
[18:04:58.924]     }
[18:04:58.924]     else {
[18:04:58.924]         if (TRUE) {
[18:04:58.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.924]                 open = "w")
[18:04:58.924]         }
[18:04:58.924]         else {
[18:04:58.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.924]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.924]         }
[18:04:58.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.924]             base::sink(type = "output", split = FALSE)
[18:04:58.924]             base::close(...future.stdout)
[18:04:58.924]         }, add = TRUE)
[18:04:58.924]     }
[18:04:58.924]     ...future.frame <- base::sys.nframe()
[18:04:58.924]     ...future.conditions <- base::list()
[18:04:58.924]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.924]     if (FALSE) {
[18:04:58.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.924]     }
[18:04:58.924]     ...future.result <- base::tryCatch({
[18:04:58.924]         base::withCallingHandlers({
[18:04:58.924]             ...future.value <- base::withVisible(base::local({
[18:04:58.924]                 withCallingHandlers({
[18:04:58.924]                   {
[18:04:58.924]                     x <- 0
[18:04:58.924]                     x <- x + 1
[18:04:58.924]                     x
[18:04:58.924]                   }
[18:04:58.924]                 }, immediateCondition = function(cond) {
[18:04:58.924]                   save_rds <- function (object, pathname, ...) 
[18:04:58.924]                   {
[18:04:58.924]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.924]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.924]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.924]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.924]                         fi_tmp[["mtime"]])
[18:04:58.924]                     }
[18:04:58.924]                     tryCatch({
[18:04:58.924]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.924]                     }, error = function(ex) {
[18:04:58.924]                       msg <- conditionMessage(ex)
[18:04:58.924]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.924]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.924]                         fi_tmp[["mtime"]], msg)
[18:04:58.924]                       ex$message <- msg
[18:04:58.924]                       stop(ex)
[18:04:58.924]                     })
[18:04:58.924]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.924]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.924]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.924]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.924]                       fi <- file.info(pathname)
[18:04:58.924]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.924]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.924]                         fi[["size"]], fi[["mtime"]])
[18:04:58.924]                       stop(msg)
[18:04:58.924]                     }
[18:04:58.924]                     invisible(pathname)
[18:04:58.924]                   }
[18:04:58.924]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.924]                     rootPath = tempdir()) 
[18:04:58.924]                   {
[18:04:58.924]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.924]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.924]                       tmpdir = path, fileext = ".rds")
[18:04:58.924]                     save_rds(obj, file)
[18:04:58.924]                   }
[18:04:58.924]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.924]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.924]                   {
[18:04:58.924]                     inherits <- base::inherits
[18:04:58.924]                     invokeRestart <- base::invokeRestart
[18:04:58.924]                     is.null <- base::is.null
[18:04:58.924]                     muffled <- FALSE
[18:04:58.924]                     if (inherits(cond, "message")) {
[18:04:58.924]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.924]                       if (muffled) 
[18:04:58.924]                         invokeRestart("muffleMessage")
[18:04:58.924]                     }
[18:04:58.924]                     else if (inherits(cond, "warning")) {
[18:04:58.924]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.924]                       if (muffled) 
[18:04:58.924]                         invokeRestart("muffleWarning")
[18:04:58.924]                     }
[18:04:58.924]                     else if (inherits(cond, "condition")) {
[18:04:58.924]                       if (!is.null(pattern)) {
[18:04:58.924]                         computeRestarts <- base::computeRestarts
[18:04:58.924]                         grepl <- base::grepl
[18:04:58.924]                         restarts <- computeRestarts(cond)
[18:04:58.924]                         for (restart in restarts) {
[18:04:58.924]                           name <- restart$name
[18:04:58.924]                           if (is.null(name)) 
[18:04:58.924]                             next
[18:04:58.924]                           if (!grepl(pattern, name)) 
[18:04:58.924]                             next
[18:04:58.924]                           invokeRestart(restart)
[18:04:58.924]                           muffled <- TRUE
[18:04:58.924]                           break
[18:04:58.924]                         }
[18:04:58.924]                       }
[18:04:58.924]                     }
[18:04:58.924]                     invisible(muffled)
[18:04:58.924]                   }
[18:04:58.924]                   muffleCondition(cond)
[18:04:58.924]                 })
[18:04:58.924]             }))
[18:04:58.924]             future::FutureResult(value = ...future.value$value, 
[18:04:58.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.924]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.924]                     ...future.globalenv.names))
[18:04:58.924]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.924]         }, condition = base::local({
[18:04:58.924]             c <- base::c
[18:04:58.924]             inherits <- base::inherits
[18:04:58.924]             invokeRestart <- base::invokeRestart
[18:04:58.924]             length <- base::length
[18:04:58.924]             list <- base::list
[18:04:58.924]             seq.int <- base::seq.int
[18:04:58.924]             signalCondition <- base::signalCondition
[18:04:58.924]             sys.calls <- base::sys.calls
[18:04:58.924]             `[[` <- base::`[[`
[18:04:58.924]             `+` <- base::`+`
[18:04:58.924]             `<<-` <- base::`<<-`
[18:04:58.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.924]                   3L)]
[18:04:58.924]             }
[18:04:58.924]             function(cond) {
[18:04:58.924]                 is_error <- inherits(cond, "error")
[18:04:58.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.924]                   NULL)
[18:04:58.924]                 if (is_error) {
[18:04:58.924]                   sessionInformation <- function() {
[18:04:58.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.924]                       search = base::search(), system = base::Sys.info())
[18:04:58.924]                   }
[18:04:58.924]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.924]                     cond$call), session = sessionInformation(), 
[18:04:58.924]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.924]                   signalCondition(cond)
[18:04:58.924]                 }
[18:04:58.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.924]                 "immediateCondition"))) {
[18:04:58.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.924]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.924]                   if (TRUE && !signal) {
[18:04:58.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.924]                     {
[18:04:58.924]                       inherits <- base::inherits
[18:04:58.924]                       invokeRestart <- base::invokeRestart
[18:04:58.924]                       is.null <- base::is.null
[18:04:58.924]                       muffled <- FALSE
[18:04:58.924]                       if (inherits(cond, "message")) {
[18:04:58.924]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.924]                         if (muffled) 
[18:04:58.924]                           invokeRestart("muffleMessage")
[18:04:58.924]                       }
[18:04:58.924]                       else if (inherits(cond, "warning")) {
[18:04:58.924]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.924]                         if (muffled) 
[18:04:58.924]                           invokeRestart("muffleWarning")
[18:04:58.924]                       }
[18:04:58.924]                       else if (inherits(cond, "condition")) {
[18:04:58.924]                         if (!is.null(pattern)) {
[18:04:58.924]                           computeRestarts <- base::computeRestarts
[18:04:58.924]                           grepl <- base::grepl
[18:04:58.924]                           restarts <- computeRestarts(cond)
[18:04:58.924]                           for (restart in restarts) {
[18:04:58.924]                             name <- restart$name
[18:04:58.924]                             if (is.null(name)) 
[18:04:58.924]                               next
[18:04:58.924]                             if (!grepl(pattern, name)) 
[18:04:58.924]                               next
[18:04:58.924]                             invokeRestart(restart)
[18:04:58.924]                             muffled <- TRUE
[18:04:58.924]                             break
[18:04:58.924]                           }
[18:04:58.924]                         }
[18:04:58.924]                       }
[18:04:58.924]                       invisible(muffled)
[18:04:58.924]                     }
[18:04:58.924]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.924]                   }
[18:04:58.924]                 }
[18:04:58.924]                 else {
[18:04:58.924]                   if (TRUE) {
[18:04:58.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.924]                     {
[18:04:58.924]                       inherits <- base::inherits
[18:04:58.924]                       invokeRestart <- base::invokeRestart
[18:04:58.924]                       is.null <- base::is.null
[18:04:58.924]                       muffled <- FALSE
[18:04:58.924]                       if (inherits(cond, "message")) {
[18:04:58.924]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.924]                         if (muffled) 
[18:04:58.924]                           invokeRestart("muffleMessage")
[18:04:58.924]                       }
[18:04:58.924]                       else if (inherits(cond, "warning")) {
[18:04:58.924]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.924]                         if (muffled) 
[18:04:58.924]                           invokeRestart("muffleWarning")
[18:04:58.924]                       }
[18:04:58.924]                       else if (inherits(cond, "condition")) {
[18:04:58.924]                         if (!is.null(pattern)) {
[18:04:58.924]                           computeRestarts <- base::computeRestarts
[18:04:58.924]                           grepl <- base::grepl
[18:04:58.924]                           restarts <- computeRestarts(cond)
[18:04:58.924]                           for (restart in restarts) {
[18:04:58.924]                             name <- restart$name
[18:04:58.924]                             if (is.null(name)) 
[18:04:58.924]                               next
[18:04:58.924]                             if (!grepl(pattern, name)) 
[18:04:58.924]                               next
[18:04:58.924]                             invokeRestart(restart)
[18:04:58.924]                             muffled <- TRUE
[18:04:58.924]                             break
[18:04:58.924]                           }
[18:04:58.924]                         }
[18:04:58.924]                       }
[18:04:58.924]                       invisible(muffled)
[18:04:58.924]                     }
[18:04:58.924]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.924]                   }
[18:04:58.924]                 }
[18:04:58.924]             }
[18:04:58.924]         }))
[18:04:58.924]     }, error = function(ex) {
[18:04:58.924]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.924]                 ...future.rng), started = ...future.startTime, 
[18:04:58.924]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.924]             version = "1.8"), class = "FutureResult")
[18:04:58.924]     }, finally = {
[18:04:58.924]         if (!identical(...future.workdir, getwd())) 
[18:04:58.924]             setwd(...future.workdir)
[18:04:58.924]         {
[18:04:58.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.924]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.924]             }
[18:04:58.924]             base::options(...future.oldOptions)
[18:04:58.924]             if (.Platform$OS.type == "windows") {
[18:04:58.924]                 old_names <- names(...future.oldEnvVars)
[18:04:58.924]                 envs <- base::Sys.getenv()
[18:04:58.924]                 names <- names(envs)
[18:04:58.924]                 common <- intersect(names, old_names)
[18:04:58.924]                 added <- setdiff(names, old_names)
[18:04:58.924]                 removed <- setdiff(old_names, names)
[18:04:58.924]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.924]                   envs[common]]
[18:04:58.924]                 NAMES <- toupper(changed)
[18:04:58.924]                 args <- list()
[18:04:58.924]                 for (kk in seq_along(NAMES)) {
[18:04:58.924]                   name <- changed[[kk]]
[18:04:58.924]                   NAME <- NAMES[[kk]]
[18:04:58.924]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.924]                     next
[18:04:58.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.924]                 }
[18:04:58.924]                 NAMES <- toupper(added)
[18:04:58.924]                 for (kk in seq_along(NAMES)) {
[18:04:58.924]                   name <- added[[kk]]
[18:04:58.924]                   NAME <- NAMES[[kk]]
[18:04:58.924]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.924]                     next
[18:04:58.924]                   args[[name]] <- ""
[18:04:58.924]                 }
[18:04:58.924]                 NAMES <- toupper(removed)
[18:04:58.924]                 for (kk in seq_along(NAMES)) {
[18:04:58.924]                   name <- removed[[kk]]
[18:04:58.924]                   NAME <- NAMES[[kk]]
[18:04:58.924]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.924]                     next
[18:04:58.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.924]                 }
[18:04:58.924]                 if (length(args) > 0) 
[18:04:58.924]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.924]             }
[18:04:58.924]             else {
[18:04:58.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.924]             }
[18:04:58.924]             {
[18:04:58.924]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.924]                   0L) {
[18:04:58.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.924]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.924]                   base::options(opts)
[18:04:58.924]                 }
[18:04:58.924]                 {
[18:04:58.924]                   {
[18:04:58.924]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.924]                     NULL
[18:04:58.924]                   }
[18:04:58.924]                   options(future.plan = NULL)
[18:04:58.924]                   if (is.na(NA_character_)) 
[18:04:58.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.924]                     .init = FALSE)
[18:04:58.924]                 }
[18:04:58.924]             }
[18:04:58.924]         }
[18:04:58.924]     })
[18:04:58.924]     if (TRUE) {
[18:04:58.924]         base::sink(type = "output", split = FALSE)
[18:04:58.924]         if (TRUE) {
[18:04:58.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.924]         }
[18:04:58.924]         else {
[18:04:58.924]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.924]         }
[18:04:58.924]         base::close(...future.stdout)
[18:04:58.924]         ...future.stdout <- NULL
[18:04:58.924]     }
[18:04:58.924]     ...future.result$conditions <- ...future.conditions
[18:04:58.924]     ...future.result$finished <- base::Sys.time()
[18:04:58.924]     ...future.result
[18:04:58.924] }
[18:04:58.932] requestCore(): workers = 2
[18:04:58.936] MulticoreFuture started
[18:04:58.937] - Launch lazy future ... done
[18:04:58.937] run() for ‘MulticoreFuture’ ... done
[18:04:58.938] result() for MulticoreFuture ...
[18:04:58.940] plan(): Setting new future strategy stack:
[18:04:58.941] List of future strategies:
[18:04:58.941] 1. sequential:
[18:04:58.941]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:58.941]    - tweaked: FALSE
[18:04:58.941]    - call: NULL
[18:04:58.943] plan(): nbrOfWorkers() = 1
[18:04:58.947] plan(): Setting new future strategy stack:
[18:04:58.948] List of future strategies:
[18:04:58.948] 1. multicore:
[18:04:58.948]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:58.948]    - tweaked: FALSE
[18:04:58.948]    - call: plan(strategy)
[18:04:58.959] plan(): nbrOfWorkers() = 2
[18:04:58.961] result() for MulticoreFuture ...
[18:04:58.961] result() for MulticoreFuture ... done
[18:04:58.962] result() for MulticoreFuture ... done
[18:04:58.964] result() for MulticoreFuture ...
[18:04:58.964] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:58.965] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:58.967] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:58.972] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[18:04:58.973] Searching for globals ... DONE
[18:04:58.973] Resolving globals: TRUE
[18:04:58.973] Resolving any globals that are futures ...
[18:04:58.974] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[18:04:58.974] Resolving any globals that are futures ... DONE
[18:04:58.975] Resolving futures part of globals (recursively) ...
[18:04:58.976] resolve() on list ...
[18:04:58.976]  recursive: 99
[18:04:58.977]  length: 1
[18:04:58.977]  elements: ‘x’
[18:04:58.977]  length: 0 (resolved future 1)
[18:04:58.978] resolve() on list ... DONE
[18:04:58.978] - globals: [1] ‘x’
[18:04:58.978] Resolving futures part of globals (recursively) ... DONE
[18:04:58.979] The total size of the 1 globals is 56 bytes (56 bytes)
[18:04:58.980] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[18:04:58.980] - globals: [1] ‘x’
[18:04:58.980] 
[18:04:58.981] getGlobalsAndPackages() ... DONE
[18:04:58.981] run() for ‘Future’ ...
[18:04:58.981] - state: ‘created’
[18:04:58.982] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:58.989] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:58.989] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:58.990]   - Field: ‘label’
[18:04:58.990]   - Field: ‘local’
[18:04:58.990]   - Field: ‘owner’
[18:04:58.990]   - Field: ‘envir’
[18:04:58.991]   - Field: ‘workers’
[18:04:58.991]   - Field: ‘packages’
[18:04:58.991]   - Field: ‘gc’
[18:04:58.991]   - Field: ‘job’
[18:04:58.992]   - Field: ‘conditions’
[18:04:58.992]   - Field: ‘expr’
[18:04:58.992]   - Field: ‘uuid’
[18:04:58.992]   - Field: ‘seed’
[18:04:58.992]   - Field: ‘version’
[18:04:58.993]   - Field: ‘result’
[18:04:58.993]   - Field: ‘asynchronous’
[18:04:58.993]   - Field: ‘calls’
[18:04:58.993]   - Field: ‘globals’
[18:04:58.994]   - Field: ‘stdout’
[18:04:58.994]   - Field: ‘earlySignal’
[18:04:58.994]   - Field: ‘lazy’
[18:04:58.994]   - Field: ‘state’
[18:04:58.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:58.995] - Launch lazy future ...
[18:04:58.995] Packages needed by the future expression (n = 0): <none>
[18:04:58.996] Packages needed by future strategies (n = 0): <none>
[18:04:58.997] {
[18:04:58.997]     {
[18:04:58.997]         {
[18:04:58.997]             ...future.startTime <- base::Sys.time()
[18:04:58.997]             {
[18:04:58.997]                 {
[18:04:58.997]                   {
[18:04:58.997]                     {
[18:04:58.997]                       base::local({
[18:04:58.997]                         has_future <- base::requireNamespace("future", 
[18:04:58.997]                           quietly = TRUE)
[18:04:58.997]                         if (has_future) {
[18:04:58.997]                           ns <- base::getNamespace("future")
[18:04:58.997]                           version <- ns[[".package"]][["version"]]
[18:04:58.997]                           if (is.null(version)) 
[18:04:58.997]                             version <- utils::packageVersion("future")
[18:04:58.997]                         }
[18:04:58.997]                         else {
[18:04:58.997]                           version <- NULL
[18:04:58.997]                         }
[18:04:58.997]                         if (!has_future || version < "1.8.0") {
[18:04:58.997]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:58.997]                             "", base::R.version$version.string), 
[18:04:58.997]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:58.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:58.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:58.997]                               "release", "version")], collapse = " "), 
[18:04:58.997]                             hostname = base::Sys.info()[["nodename"]])
[18:04:58.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:58.997]                             info)
[18:04:58.997]                           info <- base::paste(info, collapse = "; ")
[18:04:58.997]                           if (!has_future) {
[18:04:58.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:58.997]                               info)
[18:04:58.997]                           }
[18:04:58.997]                           else {
[18:04:58.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:58.997]                               info, version)
[18:04:58.997]                           }
[18:04:58.997]                           base::stop(msg)
[18:04:58.997]                         }
[18:04:58.997]                       })
[18:04:58.997]                     }
[18:04:58.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:58.997]                     base::options(mc.cores = 1L)
[18:04:58.997]                   }
[18:04:58.997]                   ...future.strategy.old <- future::plan("list")
[18:04:58.997]                   options(future.plan = NULL)
[18:04:58.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:58.997]                 }
[18:04:58.997]                 ...future.workdir <- getwd()
[18:04:58.997]             }
[18:04:58.997]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:58.997]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:58.997]         }
[18:04:58.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:58.997]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:58.997]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:58.997]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:58.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:58.997]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:58.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:58.997]             base::names(...future.oldOptions))
[18:04:58.997]     }
[18:04:58.997]     if (FALSE) {
[18:04:58.997]     }
[18:04:58.997]     else {
[18:04:58.997]         if (TRUE) {
[18:04:58.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:58.997]                 open = "w")
[18:04:58.997]         }
[18:04:58.997]         else {
[18:04:58.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:58.997]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:58.997]         }
[18:04:58.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:58.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:58.997]             base::sink(type = "output", split = FALSE)
[18:04:58.997]             base::close(...future.stdout)
[18:04:58.997]         }, add = TRUE)
[18:04:58.997]     }
[18:04:58.997]     ...future.frame <- base::sys.nframe()
[18:04:58.997]     ...future.conditions <- base::list()
[18:04:58.997]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:58.997]     if (FALSE) {
[18:04:58.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:58.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:58.997]     }
[18:04:58.997]     ...future.result <- base::tryCatch({
[18:04:58.997]         base::withCallingHandlers({
[18:04:58.997]             ...future.value <- base::withVisible(base::local({
[18:04:58.997]                 withCallingHandlers({
[18:04:58.997]                   {
[18:04:58.997]                     x <- x + 1
[18:04:58.997]                     x
[18:04:58.997]                   }
[18:04:58.997]                 }, immediateCondition = function(cond) {
[18:04:58.997]                   save_rds <- function (object, pathname, ...) 
[18:04:58.997]                   {
[18:04:58.997]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:58.997]                     if (file_test("-f", pathname_tmp)) {
[18:04:58.997]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.997]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:58.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.997]                         fi_tmp[["mtime"]])
[18:04:58.997]                     }
[18:04:58.997]                     tryCatch({
[18:04:58.997]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:58.997]                     }, error = function(ex) {
[18:04:58.997]                       msg <- conditionMessage(ex)
[18:04:58.997]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.997]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:58.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.997]                         fi_tmp[["mtime"]], msg)
[18:04:58.997]                       ex$message <- msg
[18:04:58.997]                       stop(ex)
[18:04:58.997]                     })
[18:04:58.997]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:58.997]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:58.997]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:58.997]                       fi_tmp <- file.info(pathname_tmp)
[18:04:58.997]                       fi <- file.info(pathname)
[18:04:58.997]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:58.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:58.997]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:58.997]                         fi[["size"]], fi[["mtime"]])
[18:04:58.997]                       stop(msg)
[18:04:58.997]                     }
[18:04:58.997]                     invisible(pathname)
[18:04:58.997]                   }
[18:04:58.997]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:58.997]                     rootPath = tempdir()) 
[18:04:58.997]                   {
[18:04:58.997]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:58.997]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:58.997]                       tmpdir = path, fileext = ".rds")
[18:04:58.997]                     save_rds(obj, file)
[18:04:58.997]                   }
[18:04:58.997]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:58.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.997]                   {
[18:04:58.997]                     inherits <- base::inherits
[18:04:58.997]                     invokeRestart <- base::invokeRestart
[18:04:58.997]                     is.null <- base::is.null
[18:04:58.997]                     muffled <- FALSE
[18:04:58.997]                     if (inherits(cond, "message")) {
[18:04:58.997]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:58.997]                       if (muffled) 
[18:04:58.997]                         invokeRestart("muffleMessage")
[18:04:58.997]                     }
[18:04:58.997]                     else if (inherits(cond, "warning")) {
[18:04:58.997]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:58.997]                       if (muffled) 
[18:04:58.997]                         invokeRestart("muffleWarning")
[18:04:58.997]                     }
[18:04:58.997]                     else if (inherits(cond, "condition")) {
[18:04:58.997]                       if (!is.null(pattern)) {
[18:04:58.997]                         computeRestarts <- base::computeRestarts
[18:04:58.997]                         grepl <- base::grepl
[18:04:58.997]                         restarts <- computeRestarts(cond)
[18:04:58.997]                         for (restart in restarts) {
[18:04:58.997]                           name <- restart$name
[18:04:58.997]                           if (is.null(name)) 
[18:04:58.997]                             next
[18:04:58.997]                           if (!grepl(pattern, name)) 
[18:04:58.997]                             next
[18:04:58.997]                           invokeRestart(restart)
[18:04:58.997]                           muffled <- TRUE
[18:04:58.997]                           break
[18:04:58.997]                         }
[18:04:58.997]                       }
[18:04:58.997]                     }
[18:04:58.997]                     invisible(muffled)
[18:04:58.997]                   }
[18:04:58.997]                   muffleCondition(cond)
[18:04:58.997]                 })
[18:04:58.997]             }))
[18:04:58.997]             future::FutureResult(value = ...future.value$value, 
[18:04:58.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.997]                   ...future.rng), globalenv = if (FALSE) 
[18:04:58.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:58.997]                     ...future.globalenv.names))
[18:04:58.997]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:58.997]         }, condition = base::local({
[18:04:58.997]             c <- base::c
[18:04:58.997]             inherits <- base::inherits
[18:04:58.997]             invokeRestart <- base::invokeRestart
[18:04:58.997]             length <- base::length
[18:04:58.997]             list <- base::list
[18:04:58.997]             seq.int <- base::seq.int
[18:04:58.997]             signalCondition <- base::signalCondition
[18:04:58.997]             sys.calls <- base::sys.calls
[18:04:58.997]             `[[` <- base::`[[`
[18:04:58.997]             `+` <- base::`+`
[18:04:58.997]             `<<-` <- base::`<<-`
[18:04:58.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:58.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:58.997]                   3L)]
[18:04:58.997]             }
[18:04:58.997]             function(cond) {
[18:04:58.997]                 is_error <- inherits(cond, "error")
[18:04:58.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:58.997]                   NULL)
[18:04:58.997]                 if (is_error) {
[18:04:58.997]                   sessionInformation <- function() {
[18:04:58.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:58.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:58.997]                       search = base::search(), system = base::Sys.info())
[18:04:58.997]                   }
[18:04:58.997]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:58.997]                     cond$call), session = sessionInformation(), 
[18:04:58.997]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:58.997]                   signalCondition(cond)
[18:04:58.997]                 }
[18:04:58.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:58.997]                 "immediateCondition"))) {
[18:04:58.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:58.997]                   ...future.conditions[[length(...future.conditions) + 
[18:04:58.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:58.997]                   if (TRUE && !signal) {
[18:04:58.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.997]                     {
[18:04:58.997]                       inherits <- base::inherits
[18:04:58.997]                       invokeRestart <- base::invokeRestart
[18:04:58.997]                       is.null <- base::is.null
[18:04:58.997]                       muffled <- FALSE
[18:04:58.997]                       if (inherits(cond, "message")) {
[18:04:58.997]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.997]                         if (muffled) 
[18:04:58.997]                           invokeRestart("muffleMessage")
[18:04:58.997]                       }
[18:04:58.997]                       else if (inherits(cond, "warning")) {
[18:04:58.997]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.997]                         if (muffled) 
[18:04:58.997]                           invokeRestart("muffleWarning")
[18:04:58.997]                       }
[18:04:58.997]                       else if (inherits(cond, "condition")) {
[18:04:58.997]                         if (!is.null(pattern)) {
[18:04:58.997]                           computeRestarts <- base::computeRestarts
[18:04:58.997]                           grepl <- base::grepl
[18:04:58.997]                           restarts <- computeRestarts(cond)
[18:04:58.997]                           for (restart in restarts) {
[18:04:58.997]                             name <- restart$name
[18:04:58.997]                             if (is.null(name)) 
[18:04:58.997]                               next
[18:04:58.997]                             if (!grepl(pattern, name)) 
[18:04:58.997]                               next
[18:04:58.997]                             invokeRestart(restart)
[18:04:58.997]                             muffled <- TRUE
[18:04:58.997]                             break
[18:04:58.997]                           }
[18:04:58.997]                         }
[18:04:58.997]                       }
[18:04:58.997]                       invisible(muffled)
[18:04:58.997]                     }
[18:04:58.997]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.997]                   }
[18:04:58.997]                 }
[18:04:58.997]                 else {
[18:04:58.997]                   if (TRUE) {
[18:04:58.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:58.997]                     {
[18:04:58.997]                       inherits <- base::inherits
[18:04:58.997]                       invokeRestart <- base::invokeRestart
[18:04:58.997]                       is.null <- base::is.null
[18:04:58.997]                       muffled <- FALSE
[18:04:58.997]                       if (inherits(cond, "message")) {
[18:04:58.997]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:58.997]                         if (muffled) 
[18:04:58.997]                           invokeRestart("muffleMessage")
[18:04:58.997]                       }
[18:04:58.997]                       else if (inherits(cond, "warning")) {
[18:04:58.997]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:58.997]                         if (muffled) 
[18:04:58.997]                           invokeRestart("muffleWarning")
[18:04:58.997]                       }
[18:04:58.997]                       else if (inherits(cond, "condition")) {
[18:04:58.997]                         if (!is.null(pattern)) {
[18:04:58.997]                           computeRestarts <- base::computeRestarts
[18:04:58.997]                           grepl <- base::grepl
[18:04:58.997]                           restarts <- computeRestarts(cond)
[18:04:58.997]                           for (restart in restarts) {
[18:04:58.997]                             name <- restart$name
[18:04:58.997]                             if (is.null(name)) 
[18:04:58.997]                               next
[18:04:58.997]                             if (!grepl(pattern, name)) 
[18:04:58.997]                               next
[18:04:58.997]                             invokeRestart(restart)
[18:04:58.997]                             muffled <- TRUE
[18:04:58.997]                             break
[18:04:58.997]                           }
[18:04:58.997]                         }
[18:04:58.997]                       }
[18:04:58.997]                       invisible(muffled)
[18:04:58.997]                     }
[18:04:58.997]                     muffleCondition(cond, pattern = "^muffle")
[18:04:58.997]                   }
[18:04:58.997]                 }
[18:04:58.997]             }
[18:04:58.997]         }))
[18:04:58.997]     }, error = function(ex) {
[18:04:58.997]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:58.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:58.997]                 ...future.rng), started = ...future.startTime, 
[18:04:58.997]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:58.997]             version = "1.8"), class = "FutureResult")
[18:04:58.997]     }, finally = {
[18:04:58.997]         if (!identical(...future.workdir, getwd())) 
[18:04:58.997]             setwd(...future.workdir)
[18:04:58.997]         {
[18:04:58.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:58.997]                 ...future.oldOptions$nwarnings <- NULL
[18:04:58.997]             }
[18:04:58.997]             base::options(...future.oldOptions)
[18:04:58.997]             if (.Platform$OS.type == "windows") {
[18:04:58.997]                 old_names <- names(...future.oldEnvVars)
[18:04:58.997]                 envs <- base::Sys.getenv()
[18:04:58.997]                 names <- names(envs)
[18:04:58.997]                 common <- intersect(names, old_names)
[18:04:58.997]                 added <- setdiff(names, old_names)
[18:04:58.997]                 removed <- setdiff(old_names, names)
[18:04:58.997]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:58.997]                   envs[common]]
[18:04:58.997]                 NAMES <- toupper(changed)
[18:04:58.997]                 args <- list()
[18:04:58.997]                 for (kk in seq_along(NAMES)) {
[18:04:58.997]                   name <- changed[[kk]]
[18:04:58.997]                   NAME <- NAMES[[kk]]
[18:04:58.997]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.997]                     next
[18:04:58.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.997]                 }
[18:04:58.997]                 NAMES <- toupper(added)
[18:04:58.997]                 for (kk in seq_along(NAMES)) {
[18:04:58.997]                   name <- added[[kk]]
[18:04:58.997]                   NAME <- NAMES[[kk]]
[18:04:58.997]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.997]                     next
[18:04:58.997]                   args[[name]] <- ""
[18:04:58.997]                 }
[18:04:58.997]                 NAMES <- toupper(removed)
[18:04:58.997]                 for (kk in seq_along(NAMES)) {
[18:04:58.997]                   name <- removed[[kk]]
[18:04:58.997]                   NAME <- NAMES[[kk]]
[18:04:58.997]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:58.997]                     next
[18:04:58.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:58.997]                 }
[18:04:58.997]                 if (length(args) > 0) 
[18:04:58.997]                   base::do.call(base::Sys.setenv, args = args)
[18:04:58.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:58.997]             }
[18:04:58.997]             else {
[18:04:58.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:58.997]             }
[18:04:58.997]             {
[18:04:58.997]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:58.997]                   0L) {
[18:04:58.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:58.997]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:58.997]                   base::options(opts)
[18:04:58.997]                 }
[18:04:58.997]                 {
[18:04:58.997]                   {
[18:04:58.997]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:58.997]                     NULL
[18:04:58.997]                   }
[18:04:58.997]                   options(future.plan = NULL)
[18:04:58.997]                   if (is.na(NA_character_)) 
[18:04:58.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:58.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:58.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:58.997]                     .init = FALSE)
[18:04:58.997]                 }
[18:04:58.997]             }
[18:04:58.997]         }
[18:04:58.997]     })
[18:04:58.997]     if (TRUE) {
[18:04:58.997]         base::sink(type = "output", split = FALSE)
[18:04:58.997]         if (TRUE) {
[18:04:58.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:58.997]         }
[18:04:58.997]         else {
[18:04:58.997]             ...future.result["stdout"] <- base::list(NULL)
[18:04:58.997]         }
[18:04:58.997]         base::close(...future.stdout)
[18:04:58.997]         ...future.stdout <- NULL
[18:04:58.997]     }
[18:04:58.997]     ...future.result$conditions <- ...future.conditions
[18:04:58.997]     ...future.result$finished <- base::Sys.time()
[18:04:58.997]     ...future.result
[18:04:58.997] }
[18:04:59.002] assign_globals() ...
[18:04:59.002] List of 1
[18:04:59.002]  $ x: num 1
[18:04:59.002]  - attr(*, "where")=List of 1
[18:04:59.002]   ..$ x:<environment: R_EmptyEnv> 
[18:04:59.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:59.002]  - attr(*, "resolved")= logi TRUE
[18:04:59.002]  - attr(*, "total_size")= num 56
[18:04:59.002]  - attr(*, "already-done")= logi TRUE
[18:04:59.008] - copied ‘x’ to environment
[18:04:59.008] assign_globals() ... done
[18:04:59.008] requestCore(): workers = 2
[18:04:59.012] MulticoreFuture started
[18:04:59.013] - Launch lazy future ... done
[18:04:59.013] run() for ‘MulticoreFuture’ ... done
[18:04:59.014] plan(): Setting new future strategy stack:
[18:04:59.014] result() for MulticoreFuture ...
[18:04:59.014] List of future strategies:
[18:04:59.014] 1. sequential:
[18:04:59.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:59.014]    - tweaked: FALSE
[18:04:59.014]    - call: NULL
[18:04:59.016] plan(): nbrOfWorkers() = 1
[18:04:59.021] plan(): Setting new future strategy stack:
[18:04:59.021] List of future strategies:
[18:04:59.021] 1. multicore:
[18:04:59.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:59.021]    - tweaked: FALSE
[18:04:59.021]    - call: plan(strategy)
[18:04:59.031] plan(): nbrOfWorkers() = 2
[18:04:59.033] result() for MulticoreFuture ...
[18:04:59.033] result() for MulticoreFuture ... done
[18:04:59.033] result() for MulticoreFuture ... done
[18:04:59.034] result() for MulticoreFuture ...
[18:04:59.034] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:59.035] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:59.035] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:04:59.040] - globals found: [3] ‘{’, ‘<-’, ‘x’
[18:04:59.041] Searching for globals ... DONE
[18:04:59.041] Resolving globals: TRUE
[18:04:59.041] Resolving any globals that are futures ...
[18:04:59.041] - globals: [3] ‘{’, ‘<-’, ‘x’
[18:04:59.042] Resolving any globals that are futures ... DONE
[18:04:59.042] Resolving futures part of globals (recursively) ...
[18:04:59.043] resolve() on list ...
[18:04:59.043]  recursive: 99
[18:04:59.044]  length: 1
[18:04:59.044]  elements: ‘x’
[18:04:59.044]  length: 0 (resolved future 1)
[18:04:59.044] resolve() on list ... DONE
[18:04:59.045] - globals: [1] ‘x’
[18:04:59.045] Resolving futures part of globals (recursively) ... DONE
[18:04:59.045] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[18:04:59.046] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[18:04:59.047] - globals: [1] ‘x’
[18:04:59.047] 
[18:04:59.047] getGlobalsAndPackages() ... DONE
[18:04:59.048] run() for ‘Future’ ...
[18:04:59.048] - state: ‘created’
[18:04:59.048] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:59.056] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:59.056] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:59.060]   - Field: ‘label’
[18:04:59.061]   - Field: ‘local’
[18:04:59.061]   - Field: ‘owner’
[18:04:59.061]   - Field: ‘envir’
[18:04:59.062]   - Field: ‘workers’
[18:04:59.062]   - Field: ‘packages’
[18:04:59.062]   - Field: ‘gc’
[18:04:59.062]   - Field: ‘job’
[18:04:59.063]   - Field: ‘conditions’
[18:04:59.063]   - Field: ‘expr’
[18:04:59.063]   - Field: ‘uuid’
[18:04:59.063]   - Field: ‘seed’
[18:04:59.064]   - Field: ‘version’
[18:04:59.064]   - Field: ‘result’
[18:04:59.064]   - Field: ‘asynchronous’
[18:04:59.064]   - Field: ‘calls’
[18:04:59.065]   - Field: ‘globals’
[18:04:59.065]   - Field: ‘stdout’
[18:04:59.065]   - Field: ‘earlySignal’
[18:04:59.065]   - Field: ‘lazy’
[18:04:59.065]   - Field: ‘state’
[18:04:59.066] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:59.066] - Launch lazy future ...
[18:04:59.067] Packages needed by the future expression (n = 0): <none>
[18:04:59.067] Packages needed by future strategies (n = 0): <none>
[18:04:59.068] {
[18:04:59.068]     {
[18:04:59.068]         {
[18:04:59.068]             ...future.startTime <- base::Sys.time()
[18:04:59.068]             {
[18:04:59.068]                 {
[18:04:59.068]                   {
[18:04:59.068]                     {
[18:04:59.068]                       base::local({
[18:04:59.068]                         has_future <- base::requireNamespace("future", 
[18:04:59.068]                           quietly = TRUE)
[18:04:59.068]                         if (has_future) {
[18:04:59.068]                           ns <- base::getNamespace("future")
[18:04:59.068]                           version <- ns[[".package"]][["version"]]
[18:04:59.068]                           if (is.null(version)) 
[18:04:59.068]                             version <- utils::packageVersion("future")
[18:04:59.068]                         }
[18:04:59.068]                         else {
[18:04:59.068]                           version <- NULL
[18:04:59.068]                         }
[18:04:59.068]                         if (!has_future || version < "1.8.0") {
[18:04:59.068]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:59.068]                             "", base::R.version$version.string), 
[18:04:59.068]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:59.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:59.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:59.068]                               "release", "version")], collapse = " "), 
[18:04:59.068]                             hostname = base::Sys.info()[["nodename"]])
[18:04:59.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:59.068]                             info)
[18:04:59.068]                           info <- base::paste(info, collapse = "; ")
[18:04:59.068]                           if (!has_future) {
[18:04:59.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:59.068]                               info)
[18:04:59.068]                           }
[18:04:59.068]                           else {
[18:04:59.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:59.068]                               info, version)
[18:04:59.068]                           }
[18:04:59.068]                           base::stop(msg)
[18:04:59.068]                         }
[18:04:59.068]                       })
[18:04:59.068]                     }
[18:04:59.068]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:59.068]                     base::options(mc.cores = 1L)
[18:04:59.068]                   }
[18:04:59.068]                   ...future.strategy.old <- future::plan("list")
[18:04:59.068]                   options(future.plan = NULL)
[18:04:59.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:59.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:59.068]                 }
[18:04:59.068]                 ...future.workdir <- getwd()
[18:04:59.068]             }
[18:04:59.068]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:59.068]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:59.068]         }
[18:04:59.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:59.068]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:59.068]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:59.068]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:59.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:59.068]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:59.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:59.068]             base::names(...future.oldOptions))
[18:04:59.068]     }
[18:04:59.068]     if (FALSE) {
[18:04:59.068]     }
[18:04:59.068]     else {
[18:04:59.068]         if (TRUE) {
[18:04:59.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:59.068]                 open = "w")
[18:04:59.068]         }
[18:04:59.068]         else {
[18:04:59.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:59.068]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:59.068]         }
[18:04:59.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:59.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:59.068]             base::sink(type = "output", split = FALSE)
[18:04:59.068]             base::close(...future.stdout)
[18:04:59.068]         }, add = TRUE)
[18:04:59.068]     }
[18:04:59.068]     ...future.frame <- base::sys.nframe()
[18:04:59.068]     ...future.conditions <- base::list()
[18:04:59.068]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:59.068]     if (FALSE) {
[18:04:59.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:59.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:59.068]     }
[18:04:59.068]     ...future.result <- base::tryCatch({
[18:04:59.068]         base::withCallingHandlers({
[18:04:59.068]             ...future.value <- base::withVisible(base::local({
[18:04:59.068]                 withCallingHandlers({
[18:04:59.068]                   {
[18:04:59.068]                     x <- x()
[18:04:59.068]                     x
[18:04:59.068]                   }
[18:04:59.068]                 }, immediateCondition = function(cond) {
[18:04:59.068]                   save_rds <- function (object, pathname, ...) 
[18:04:59.068]                   {
[18:04:59.068]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:59.068]                     if (file_test("-f", pathname_tmp)) {
[18:04:59.068]                       fi_tmp <- file.info(pathname_tmp)
[18:04:59.068]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:59.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:59.068]                         fi_tmp[["mtime"]])
[18:04:59.068]                     }
[18:04:59.068]                     tryCatch({
[18:04:59.068]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:59.068]                     }, error = function(ex) {
[18:04:59.068]                       msg <- conditionMessage(ex)
[18:04:59.068]                       fi_tmp <- file.info(pathname_tmp)
[18:04:59.068]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:59.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:59.068]                         fi_tmp[["mtime"]], msg)
[18:04:59.068]                       ex$message <- msg
[18:04:59.068]                       stop(ex)
[18:04:59.068]                     })
[18:04:59.068]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:59.068]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:59.068]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:59.068]                       fi_tmp <- file.info(pathname_tmp)
[18:04:59.068]                       fi <- file.info(pathname)
[18:04:59.068]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:59.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:59.068]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:59.068]                         fi[["size"]], fi[["mtime"]])
[18:04:59.068]                       stop(msg)
[18:04:59.068]                     }
[18:04:59.068]                     invisible(pathname)
[18:04:59.068]                   }
[18:04:59.068]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:59.068]                     rootPath = tempdir()) 
[18:04:59.068]                   {
[18:04:59.068]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:59.068]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:59.068]                       tmpdir = path, fileext = ".rds")
[18:04:59.068]                     save_rds(obj, file)
[18:04:59.068]                   }
[18:04:59.068]                   saveImmediateCondition(cond, path = "/tmp/RtmpVIdzug/.future/immediateConditions")
[18:04:59.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:59.068]                   {
[18:04:59.068]                     inherits <- base::inherits
[18:04:59.068]                     invokeRestart <- base::invokeRestart
[18:04:59.068]                     is.null <- base::is.null
[18:04:59.068]                     muffled <- FALSE
[18:04:59.068]                     if (inherits(cond, "message")) {
[18:04:59.068]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:59.068]                       if (muffled) 
[18:04:59.068]                         invokeRestart("muffleMessage")
[18:04:59.068]                     }
[18:04:59.068]                     else if (inherits(cond, "warning")) {
[18:04:59.068]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:59.068]                       if (muffled) 
[18:04:59.068]                         invokeRestart("muffleWarning")
[18:04:59.068]                     }
[18:04:59.068]                     else if (inherits(cond, "condition")) {
[18:04:59.068]                       if (!is.null(pattern)) {
[18:04:59.068]                         computeRestarts <- base::computeRestarts
[18:04:59.068]                         grepl <- base::grepl
[18:04:59.068]                         restarts <- computeRestarts(cond)
[18:04:59.068]                         for (restart in restarts) {
[18:04:59.068]                           name <- restart$name
[18:04:59.068]                           if (is.null(name)) 
[18:04:59.068]                             next
[18:04:59.068]                           if (!grepl(pattern, name)) 
[18:04:59.068]                             next
[18:04:59.068]                           invokeRestart(restart)
[18:04:59.068]                           muffled <- TRUE
[18:04:59.068]                           break
[18:04:59.068]                         }
[18:04:59.068]                       }
[18:04:59.068]                     }
[18:04:59.068]                     invisible(muffled)
[18:04:59.068]                   }
[18:04:59.068]                   muffleCondition(cond)
[18:04:59.068]                 })
[18:04:59.068]             }))
[18:04:59.068]             future::FutureResult(value = ...future.value$value, 
[18:04:59.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:59.068]                   ...future.rng), globalenv = if (FALSE) 
[18:04:59.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:59.068]                     ...future.globalenv.names))
[18:04:59.068]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:59.068]         }, condition = base::local({
[18:04:59.068]             c <- base::c
[18:04:59.068]             inherits <- base::inherits
[18:04:59.068]             invokeRestart <- base::invokeRestart
[18:04:59.068]             length <- base::length
[18:04:59.068]             list <- base::list
[18:04:59.068]             seq.int <- base::seq.int
[18:04:59.068]             signalCondition <- base::signalCondition
[18:04:59.068]             sys.calls <- base::sys.calls
[18:04:59.068]             `[[` <- base::`[[`
[18:04:59.068]             `+` <- base::`+`
[18:04:59.068]             `<<-` <- base::`<<-`
[18:04:59.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:59.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:59.068]                   3L)]
[18:04:59.068]             }
[18:04:59.068]             function(cond) {
[18:04:59.068]                 is_error <- inherits(cond, "error")
[18:04:59.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:59.068]                   NULL)
[18:04:59.068]                 if (is_error) {
[18:04:59.068]                   sessionInformation <- function() {
[18:04:59.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:59.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:59.068]                       search = base::search(), system = base::Sys.info())
[18:04:59.068]                   }
[18:04:59.068]                   ...future.conditions[[length(...future.conditions) + 
[18:04:59.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:59.068]                     cond$call), session = sessionInformation(), 
[18:04:59.068]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:59.068]                   signalCondition(cond)
[18:04:59.068]                 }
[18:04:59.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:59.068]                 "immediateCondition"))) {
[18:04:59.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:59.068]                   ...future.conditions[[length(...future.conditions) + 
[18:04:59.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:59.068]                   if (TRUE && !signal) {
[18:04:59.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:59.068]                     {
[18:04:59.068]                       inherits <- base::inherits
[18:04:59.068]                       invokeRestart <- base::invokeRestart
[18:04:59.068]                       is.null <- base::is.null
[18:04:59.068]                       muffled <- FALSE
[18:04:59.068]                       if (inherits(cond, "message")) {
[18:04:59.068]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:59.068]                         if (muffled) 
[18:04:59.068]                           invokeRestart("muffleMessage")
[18:04:59.068]                       }
[18:04:59.068]                       else if (inherits(cond, "warning")) {
[18:04:59.068]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:59.068]                         if (muffled) 
[18:04:59.068]                           invokeRestart("muffleWarning")
[18:04:59.068]                       }
[18:04:59.068]                       else if (inherits(cond, "condition")) {
[18:04:59.068]                         if (!is.null(pattern)) {
[18:04:59.068]                           computeRestarts <- base::computeRestarts
[18:04:59.068]                           grepl <- base::grepl
[18:04:59.068]                           restarts <- computeRestarts(cond)
[18:04:59.068]                           for (restart in restarts) {
[18:04:59.068]                             name <- restart$name
[18:04:59.068]                             if (is.null(name)) 
[18:04:59.068]                               next
[18:04:59.068]                             if (!grepl(pattern, name)) 
[18:04:59.068]                               next
[18:04:59.068]                             invokeRestart(restart)
[18:04:59.068]                             muffled <- TRUE
[18:04:59.068]                             break
[18:04:59.068]                           }
[18:04:59.068]                         }
[18:04:59.068]                       }
[18:04:59.068]                       invisible(muffled)
[18:04:59.068]                     }
[18:04:59.068]                     muffleCondition(cond, pattern = "^muffle")
[18:04:59.068]                   }
[18:04:59.068]                 }
[18:04:59.068]                 else {
[18:04:59.068]                   if (TRUE) {
[18:04:59.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:59.068]                     {
[18:04:59.068]                       inherits <- base::inherits
[18:04:59.068]                       invokeRestart <- base::invokeRestart
[18:04:59.068]                       is.null <- base::is.null
[18:04:59.068]                       muffled <- FALSE
[18:04:59.068]                       if (inherits(cond, "message")) {
[18:04:59.068]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:59.068]                         if (muffled) 
[18:04:59.068]                           invokeRestart("muffleMessage")
[18:04:59.068]                       }
[18:04:59.068]                       else if (inherits(cond, "warning")) {
[18:04:59.068]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:59.068]                         if (muffled) 
[18:04:59.068]                           invokeRestart("muffleWarning")
[18:04:59.068]                       }
[18:04:59.068]                       else if (inherits(cond, "condition")) {
[18:04:59.068]                         if (!is.null(pattern)) {
[18:04:59.068]                           computeRestarts <- base::computeRestarts
[18:04:59.068]                           grepl <- base::grepl
[18:04:59.068]                           restarts <- computeRestarts(cond)
[18:04:59.068]                           for (restart in restarts) {
[18:04:59.068]                             name <- restart$name
[18:04:59.068]                             if (is.null(name)) 
[18:04:59.068]                               next
[18:04:59.068]                             if (!grepl(pattern, name)) 
[18:04:59.068]                               next
[18:04:59.068]                             invokeRestart(restart)
[18:04:59.068]                             muffled <- TRUE
[18:04:59.068]                             break
[18:04:59.068]                           }
[18:04:59.068]                         }
[18:04:59.068]                       }
[18:04:59.068]                       invisible(muffled)
[18:04:59.068]                     }
[18:04:59.068]                     muffleCondition(cond, pattern = "^muffle")
[18:04:59.068]                   }
[18:04:59.068]                 }
[18:04:59.068]             }
[18:04:59.068]         }))
[18:04:59.068]     }, error = function(ex) {
[18:04:59.068]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:59.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:59.068]                 ...future.rng), started = ...future.startTime, 
[18:04:59.068]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:59.068]             version = "1.8"), class = "FutureResult")
[18:04:59.068]     }, finally = {
[18:04:59.068]         if (!identical(...future.workdir, getwd())) 
[18:04:59.068]             setwd(...future.workdir)
[18:04:59.068]         {
[18:04:59.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:59.068]                 ...future.oldOptions$nwarnings <- NULL
[18:04:59.068]             }
[18:04:59.068]             base::options(...future.oldOptions)
[18:04:59.068]             if (.Platform$OS.type == "windows") {
[18:04:59.068]                 old_names <- names(...future.oldEnvVars)
[18:04:59.068]                 envs <- base::Sys.getenv()
[18:04:59.068]                 names <- names(envs)
[18:04:59.068]                 common <- intersect(names, old_names)
[18:04:59.068]                 added <- setdiff(names, old_names)
[18:04:59.068]                 removed <- setdiff(old_names, names)
[18:04:59.068]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:59.068]                   envs[common]]
[18:04:59.068]                 NAMES <- toupper(changed)
[18:04:59.068]                 args <- list()
[18:04:59.068]                 for (kk in seq_along(NAMES)) {
[18:04:59.068]                   name <- changed[[kk]]
[18:04:59.068]                   NAME <- NAMES[[kk]]
[18:04:59.068]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:59.068]                     next
[18:04:59.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:59.068]                 }
[18:04:59.068]                 NAMES <- toupper(added)
[18:04:59.068]                 for (kk in seq_along(NAMES)) {
[18:04:59.068]                   name <- added[[kk]]
[18:04:59.068]                   NAME <- NAMES[[kk]]
[18:04:59.068]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:59.068]                     next
[18:04:59.068]                   args[[name]] <- ""
[18:04:59.068]                 }
[18:04:59.068]                 NAMES <- toupper(removed)
[18:04:59.068]                 for (kk in seq_along(NAMES)) {
[18:04:59.068]                   name <- removed[[kk]]
[18:04:59.068]                   NAME <- NAMES[[kk]]
[18:04:59.068]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:59.068]                     next
[18:04:59.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:59.068]                 }
[18:04:59.068]                 if (length(args) > 0) 
[18:04:59.068]                   base::do.call(base::Sys.setenv, args = args)
[18:04:59.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:59.068]             }
[18:04:59.068]             else {
[18:04:59.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:59.068]             }
[18:04:59.068]             {
[18:04:59.068]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:59.068]                   0L) {
[18:04:59.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:59.068]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:59.068]                   base::options(opts)
[18:04:59.068]                 }
[18:04:59.068]                 {
[18:04:59.068]                   {
[18:04:59.068]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:59.068]                     NULL
[18:04:59.068]                   }
[18:04:59.068]                   options(future.plan = NULL)
[18:04:59.068]                   if (is.na(NA_character_)) 
[18:04:59.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:59.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:59.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:59.068]                     .init = FALSE)
[18:04:59.068]                 }
[18:04:59.068]             }
[18:04:59.068]         }
[18:04:59.068]     })
[18:04:59.068]     if (TRUE) {
[18:04:59.068]         base::sink(type = "output", split = FALSE)
[18:04:59.068]         if (TRUE) {
[18:04:59.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:59.068]         }
[18:04:59.068]         else {
[18:04:59.068]             ...future.result["stdout"] <- base::list(NULL)
[18:04:59.068]         }
[18:04:59.068]         base::close(...future.stdout)
[18:04:59.068]         ...future.stdout <- NULL
[18:04:59.068]     }
[18:04:59.068]     ...future.result$conditions <- ...future.conditions
[18:04:59.068]     ...future.result$finished <- base::Sys.time()
[18:04:59.068]     ...future.result
[18:04:59.068] }
[18:04:59.072] assign_globals() ...
[18:04:59.073] List of 1
[18:04:59.073]  $ x:function ()  
[18:04:59.073]  - attr(*, "where")=List of 1
[18:04:59.073]   ..$ x:<environment: R_EmptyEnv> 
[18:04:59.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:59.073]  - attr(*, "resolved")= logi TRUE
[18:04:59.073]  - attr(*, "total_size")= num 1032
[18:04:59.073]  - attr(*, "already-done")= logi TRUE
[18:04:59.079] - reassign environment for ‘x’
[18:04:59.079] - copied ‘x’ to environment
[18:04:59.079] assign_globals() ... done
[18:04:59.080] requestCore(): workers = 2
[18:04:59.083] MulticoreFuture started
[18:04:59.084] - Launch lazy future ... done
[18:04:59.085] run() for ‘MulticoreFuture’ ... done
[18:04:59.085] plan(): Setting new future strategy stack:
[18:04:59.086] result() for MulticoreFuture ...
[18:04:59.086] List of future strategies:
[18:04:59.086] 1. sequential:
[18:04:59.086]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:59.086]    - tweaked: FALSE
[18:04:59.086]    - call: NULL
[18:04:59.089] plan(): nbrOfWorkers() = 1
[18:04:59.094] plan(): Setting new future strategy stack:
[18:04:59.095] List of future strategies:
[18:04:59.095] 1. multicore:
[18:04:59.095]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:59.095]    - tweaked: FALSE
[18:04:59.095]    - call: plan(strategy)
[18:04:59.106] plan(): nbrOfWorkers() = 2
[18:04:59.108] result() for MulticoreFuture ...
[18:04:59.109] result() for MulticoreFuture ... done
[18:04:59.109] result() for MulticoreFuture ... done
[18:04:59.109] result() for MulticoreFuture ...
[18:04:59.110] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[18:04:59.111] plan(): Setting new future strategy stack:
[18:04:59.111] List of future strategies:
[18:04:59.111] 1. multisession:
[18:04:59.111]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:59.111]    - tweaked: FALSE
[18:04:59.111]    - call: plan(strategy)
[18:04:59.112] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:04:59.113] multisession:
[18:04:59.113] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:59.113] - tweaked: FALSE
[18:04:59.113] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:04:59.125] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:59.126] Not searching for globals
[18:04:59.126] - globals: [0] <none>
[18:04:59.126] getGlobalsAndPackages() ... DONE
[18:04:59.127] [local output] makeClusterPSOCK() ...
[18:04:59.196] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:04:59.198] [local output] Base port: 11195
[18:04:59.199] [local output] Getting setup options for 2 cluster nodes ...
[18:04:59.199] [local output]  - Node 1 of 2 ...
[18:04:59.200] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:59.201] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpVIdzug/worker.rank=1.parallelly.parent=325165.4f62d457298a.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpVIdzug/worker.rank=1.parallelly.parent=325165.4f62d457298a.pid")'’
[18:04:59.464] - Possible to infer worker's PID: TRUE
[18:04:59.464] [local output] Rscript port: 11195

[18:04:59.465] [local output]  - Node 2 of 2 ...
[18:04:59.468] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:59.469] [local output] Rscript port: 11195

[18:04:59.470] [local output] Getting setup options for 2 cluster nodes ... done
[18:04:59.470] [local output]  - Parallel setup requested for some PSOCK nodes
[18:04:59.472] [local output] Setting up PSOCK nodes in parallel
[18:04:59.472] List of 36
[18:04:59.472]  $ worker          : chr "localhost"
[18:04:59.472]   ..- attr(*, "localhost")= logi TRUE
[18:04:59.472]  $ master          : chr "localhost"
[18:04:59.472]  $ port            : int 11195
[18:04:59.472]  $ connectTimeout  : num 120
[18:04:59.472]  $ timeout         : num 2592000
[18:04:59.472]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:04:59.472]  $ homogeneous     : logi TRUE
[18:04:59.472]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:04:59.472]  $ rscript_envs    : NULL
[18:04:59.472]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:59.472]  $ rscript_startup : NULL
[18:04:59.472]  $ rscript_sh      : chr "sh"
[18:04:59.472]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:59.472]  $ methods         : logi TRUE
[18:04:59.472]  $ socketOptions   : chr "no-delay"
[18:04:59.472]  $ useXDR          : logi FALSE
[18:04:59.472]  $ outfile         : chr "/dev/null"
[18:04:59.472]  $ renice          : int NA
[18:04:59.472]  $ rshcmd          : NULL
[18:04:59.472]  $ user            : chr(0) 
[18:04:59.472]  $ revtunnel       : logi FALSE
[18:04:59.472]  $ rshlogfile      : NULL
[18:04:59.472]  $ rshopts         : chr(0) 
[18:04:59.472]  $ rank            : int 1
[18:04:59.472]  $ manual          : logi FALSE
[18:04:59.472]  $ dryrun          : logi FALSE
[18:04:59.472]  $ quiet           : logi FALSE
[18:04:59.472]  $ setup_strategy  : chr "parallel"
[18:04:59.472]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:59.472]  $ pidfile         : chr "/tmp/RtmpVIdzug/worker.rank=1.parallelly.parent=325165.4f62d457298a.pid"
[18:04:59.472]  $ rshcmd_label    : NULL
[18:04:59.472]  $ rsh_call        : NULL
[18:04:59.472]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:59.472]  $ localMachine    : logi TRUE
[18:04:59.472]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:04:59.472]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:04:59.472]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:04:59.472]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:04:59.472]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:04:59.472]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:04:59.472]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:04:59.472]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:04:59.472]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:04:59.472]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:04:59.472]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:04:59.472]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:04:59.472]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:04:59.472]  $ arguments       :List of 28
[18:04:59.472]   ..$ worker          : chr "localhost"
[18:04:59.472]   ..$ master          : NULL
[18:04:59.472]   ..$ port            : int 11195
[18:04:59.472]   ..$ connectTimeout  : num 120
[18:04:59.472]   ..$ timeout         : num 2592000
[18:04:59.472]   ..$ rscript         : NULL
[18:04:59.472]   ..$ homogeneous     : NULL
[18:04:59.472]   ..$ rscript_args    : NULL
[18:04:59.472]   ..$ rscript_envs    : NULL
[18:04:59.472]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:59.472]   ..$ rscript_startup : NULL
[18:04:59.472]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:04:59.472]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:59.472]   ..$ methods         : logi TRUE
[18:04:59.472]   ..$ socketOptions   : chr "no-delay"
[18:04:59.472]   ..$ useXDR          : logi FALSE
[18:04:59.472]   ..$ outfile         : chr "/dev/null"
[18:04:59.472]   ..$ renice          : int NA
[18:04:59.472]   ..$ rshcmd          : NULL
[18:04:59.472]   ..$ user            : NULL
[18:04:59.472]   ..$ revtunnel       : logi NA
[18:04:59.472]   ..$ rshlogfile      : NULL
[18:04:59.472]   ..$ rshopts         : NULL
[18:04:59.472]   ..$ rank            : int 1
[18:04:59.472]   ..$ manual          : logi FALSE
[18:04:59.472]   ..$ dryrun          : logi FALSE
[18:04:59.472]   ..$ quiet           : logi FALSE
[18:04:59.472]   ..$ setup_strategy  : chr "parallel"
[18:04:59.472]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:04:59.511] [local output] System call to launch all workers:
[18:04:59.511] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpVIdzug/worker.rank=1.parallelly.parent=325165.4f62d457298a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11195 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:04:59.511] [local output] Starting PSOCK main server
[18:04:59.520] [local output] Workers launched
[18:04:59.520] [local output] Waiting for workers to connect back
[18:04:59.520]  - [local output] 0 workers out of 2 ready
[18:04:59.871]  - [local output] 0 workers out of 2 ready
[18:04:59.872]  - [local output] 1 workers out of 2 ready
[18:04:59.890]  - [local output] 1 workers out of 2 ready
[18:04:59.890]  - [local output] 2 workers out of 2 ready
[18:04:59.890] [local output] Launching of workers completed
[18:04:59.891] [local output] Collecting session information from workers
[18:04:59.893] [local output]  - Worker #1 of 2
[18:04:59.894] [local output]  - Worker #2 of 2
[18:04:59.894] [local output] makeClusterPSOCK() ... done
[18:04:59.914] Packages needed by the future expression (n = 0): <none>
[18:04:59.915] Packages needed by future strategies (n = 0): <none>
[18:04:59.916] {
[18:04:59.916]     {
[18:04:59.916]         {
[18:04:59.916]             ...future.startTime <- base::Sys.time()
[18:04:59.916]             {
[18:04:59.916]                 {
[18:04:59.916]                   {
[18:04:59.916]                     {
[18:04:59.916]                       base::local({
[18:04:59.916]                         has_future <- base::requireNamespace("future", 
[18:04:59.916]                           quietly = TRUE)
[18:04:59.916]                         if (has_future) {
[18:04:59.916]                           ns <- base::getNamespace("future")
[18:04:59.916]                           version <- ns[[".package"]][["version"]]
[18:04:59.916]                           if (is.null(version)) 
[18:04:59.916]                             version <- utils::packageVersion("future")
[18:04:59.916]                         }
[18:04:59.916]                         else {
[18:04:59.916]                           version <- NULL
[18:04:59.916]                         }
[18:04:59.916]                         if (!has_future || version < "1.8.0") {
[18:04:59.916]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:59.916]                             "", base::R.version$version.string), 
[18:04:59.916]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:59.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:59.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:59.916]                               "release", "version")], collapse = " "), 
[18:04:59.916]                             hostname = base::Sys.info()[["nodename"]])
[18:04:59.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:59.916]                             info)
[18:04:59.916]                           info <- base::paste(info, collapse = "; ")
[18:04:59.916]                           if (!has_future) {
[18:04:59.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:59.916]                               info)
[18:04:59.916]                           }
[18:04:59.916]                           else {
[18:04:59.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:59.916]                               info, version)
[18:04:59.916]                           }
[18:04:59.916]                           base::stop(msg)
[18:04:59.916]                         }
[18:04:59.916]                       })
[18:04:59.916]                     }
[18:04:59.916]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:59.916]                     base::options(mc.cores = 1L)
[18:04:59.916]                   }
[18:04:59.916]                   ...future.strategy.old <- future::plan("list")
[18:04:59.916]                   options(future.plan = NULL)
[18:04:59.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:59.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:59.916]                 }
[18:04:59.916]                 ...future.workdir <- getwd()
[18:04:59.916]             }
[18:04:59.916]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:59.916]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:59.916]         }
[18:04:59.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:59.916]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:04:59.916]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:59.916]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:04:59.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:59.916]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:59.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:59.916]             base::names(...future.oldOptions))
[18:04:59.916]     }
[18:04:59.916]     if (FALSE) {
[18:04:59.916]     }
[18:04:59.916]     else {
[18:04:59.916]         if (TRUE) {
[18:04:59.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:59.916]                 open = "w")
[18:04:59.916]         }
[18:04:59.916]         else {
[18:04:59.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:59.916]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:59.916]         }
[18:04:59.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:59.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:59.916]             base::sink(type = "output", split = FALSE)
[18:04:59.916]             base::close(...future.stdout)
[18:04:59.916]         }, add = TRUE)
[18:04:59.916]     }
[18:04:59.916]     ...future.frame <- base::sys.nframe()
[18:04:59.916]     ...future.conditions <- base::list()
[18:04:59.916]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:59.916]     if (FALSE) {
[18:04:59.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:59.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:59.916]     }
[18:04:59.916]     ...future.result <- base::tryCatch({
[18:04:59.916]         base::withCallingHandlers({
[18:04:59.916]             ...future.value <- base::withVisible(base::local({
[18:04:59.916]                 ...future.makeSendCondition <- base::local({
[18:04:59.916]                   sendCondition <- NULL
[18:04:59.916]                   function(frame = 1L) {
[18:04:59.916]                     if (is.function(sendCondition)) 
[18:04:59.916]                       return(sendCondition)
[18:04:59.916]                     ns <- getNamespace("parallel")
[18:04:59.916]                     if (exists("sendData", mode = "function", 
[18:04:59.916]                       envir = ns)) {
[18:04:59.916]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:59.916]                         envir = ns)
[18:04:59.916]                       envir <- sys.frame(frame)
[18:04:59.916]                       master <- NULL
[18:04:59.916]                       while (!identical(envir, .GlobalEnv) && 
[18:04:59.916]                         !identical(envir, emptyenv())) {
[18:04:59.916]                         if (exists("master", mode = "list", envir = envir, 
[18:04:59.916]                           inherits = FALSE)) {
[18:04:59.916]                           master <- get("master", mode = "list", 
[18:04:59.916]                             envir = envir, inherits = FALSE)
[18:04:59.916]                           if (inherits(master, c("SOCKnode", 
[18:04:59.916]                             "SOCK0node"))) {
[18:04:59.916]                             sendCondition <<- function(cond) {
[18:04:59.916]                               data <- list(type = "VALUE", value = cond, 
[18:04:59.916]                                 success = TRUE)
[18:04:59.916]                               parallel_sendData(master, data)
[18:04:59.916]                             }
[18:04:59.916]                             return(sendCondition)
[18:04:59.916]                           }
[18:04:59.916]                         }
[18:04:59.916]                         frame <- frame + 1L
[18:04:59.916]                         envir <- sys.frame(frame)
[18:04:59.916]                       }
[18:04:59.916]                     }
[18:04:59.916]                     sendCondition <<- function(cond) NULL
[18:04:59.916]                   }
[18:04:59.916]                 })
[18:04:59.916]                 withCallingHandlers({
[18:04:59.916]                   NA
[18:04:59.916]                 }, immediateCondition = function(cond) {
[18:04:59.916]                   sendCondition <- ...future.makeSendCondition()
[18:04:59.916]                   sendCondition(cond)
[18:04:59.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:59.916]                   {
[18:04:59.916]                     inherits <- base::inherits
[18:04:59.916]                     invokeRestart <- base::invokeRestart
[18:04:59.916]                     is.null <- base::is.null
[18:04:59.916]                     muffled <- FALSE
[18:04:59.916]                     if (inherits(cond, "message")) {
[18:04:59.916]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:59.916]                       if (muffled) 
[18:04:59.916]                         invokeRestart("muffleMessage")
[18:04:59.916]                     }
[18:04:59.916]                     else if (inherits(cond, "warning")) {
[18:04:59.916]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:59.916]                       if (muffled) 
[18:04:59.916]                         invokeRestart("muffleWarning")
[18:04:59.916]                     }
[18:04:59.916]                     else if (inherits(cond, "condition")) {
[18:04:59.916]                       if (!is.null(pattern)) {
[18:04:59.916]                         computeRestarts <- base::computeRestarts
[18:04:59.916]                         grepl <- base::grepl
[18:04:59.916]                         restarts <- computeRestarts(cond)
[18:04:59.916]                         for (restart in restarts) {
[18:04:59.916]                           name <- restart$name
[18:04:59.916]                           if (is.null(name)) 
[18:04:59.916]                             next
[18:04:59.916]                           if (!grepl(pattern, name)) 
[18:04:59.916]                             next
[18:04:59.916]                           invokeRestart(restart)
[18:04:59.916]                           muffled <- TRUE
[18:04:59.916]                           break
[18:04:59.916]                         }
[18:04:59.916]                       }
[18:04:59.916]                     }
[18:04:59.916]                     invisible(muffled)
[18:04:59.916]                   }
[18:04:59.916]                   muffleCondition(cond)
[18:04:59.916]                 })
[18:04:59.916]             }))
[18:04:59.916]             future::FutureResult(value = ...future.value$value, 
[18:04:59.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:59.916]                   ...future.rng), globalenv = if (FALSE) 
[18:04:59.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:59.916]                     ...future.globalenv.names))
[18:04:59.916]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:59.916]         }, condition = base::local({
[18:04:59.916]             c <- base::c
[18:04:59.916]             inherits <- base::inherits
[18:04:59.916]             invokeRestart <- base::invokeRestart
[18:04:59.916]             length <- base::length
[18:04:59.916]             list <- base::list
[18:04:59.916]             seq.int <- base::seq.int
[18:04:59.916]             signalCondition <- base::signalCondition
[18:04:59.916]             sys.calls <- base::sys.calls
[18:04:59.916]             `[[` <- base::`[[`
[18:04:59.916]             `+` <- base::`+`
[18:04:59.916]             `<<-` <- base::`<<-`
[18:04:59.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:59.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:59.916]                   3L)]
[18:04:59.916]             }
[18:04:59.916]             function(cond) {
[18:04:59.916]                 is_error <- inherits(cond, "error")
[18:04:59.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:59.916]                   NULL)
[18:04:59.916]                 if (is_error) {
[18:04:59.916]                   sessionInformation <- function() {
[18:04:59.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:59.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:59.916]                       search = base::search(), system = base::Sys.info())
[18:04:59.916]                   }
[18:04:59.916]                   ...future.conditions[[length(...future.conditions) + 
[18:04:59.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:59.916]                     cond$call), session = sessionInformation(), 
[18:04:59.916]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:59.916]                   signalCondition(cond)
[18:04:59.916]                 }
[18:04:59.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:59.916]                 "immediateCondition"))) {
[18:04:59.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:59.916]                   ...future.conditions[[length(...future.conditions) + 
[18:04:59.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:59.916]                   if (TRUE && !signal) {
[18:04:59.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:59.916]                     {
[18:04:59.916]                       inherits <- base::inherits
[18:04:59.916]                       invokeRestart <- base::invokeRestart
[18:04:59.916]                       is.null <- base::is.null
[18:04:59.916]                       muffled <- FALSE
[18:04:59.916]                       if (inherits(cond, "message")) {
[18:04:59.916]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:59.916]                         if (muffled) 
[18:04:59.916]                           invokeRestart("muffleMessage")
[18:04:59.916]                       }
[18:04:59.916]                       else if (inherits(cond, "warning")) {
[18:04:59.916]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:59.916]                         if (muffled) 
[18:04:59.916]                           invokeRestart("muffleWarning")
[18:04:59.916]                       }
[18:04:59.916]                       else if (inherits(cond, "condition")) {
[18:04:59.916]                         if (!is.null(pattern)) {
[18:04:59.916]                           computeRestarts <- base::computeRestarts
[18:04:59.916]                           grepl <- base::grepl
[18:04:59.916]                           restarts <- computeRestarts(cond)
[18:04:59.916]                           for (restart in restarts) {
[18:04:59.916]                             name <- restart$name
[18:04:59.916]                             if (is.null(name)) 
[18:04:59.916]                               next
[18:04:59.916]                             if (!grepl(pattern, name)) 
[18:04:59.916]                               next
[18:04:59.916]                             invokeRestart(restart)
[18:04:59.916]                             muffled <- TRUE
[18:04:59.916]                             break
[18:04:59.916]                           }
[18:04:59.916]                         }
[18:04:59.916]                       }
[18:04:59.916]                       invisible(muffled)
[18:04:59.916]                     }
[18:04:59.916]                     muffleCondition(cond, pattern = "^muffle")
[18:04:59.916]                   }
[18:04:59.916]                 }
[18:04:59.916]                 else {
[18:04:59.916]                   if (TRUE) {
[18:04:59.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:59.916]                     {
[18:04:59.916]                       inherits <- base::inherits
[18:04:59.916]                       invokeRestart <- base::invokeRestart
[18:04:59.916]                       is.null <- base::is.null
[18:04:59.916]                       muffled <- FALSE
[18:04:59.916]                       if (inherits(cond, "message")) {
[18:04:59.916]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:59.916]                         if (muffled) 
[18:04:59.916]                           invokeRestart("muffleMessage")
[18:04:59.916]                       }
[18:04:59.916]                       else if (inherits(cond, "warning")) {
[18:04:59.916]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:59.916]                         if (muffled) 
[18:04:59.916]                           invokeRestart("muffleWarning")
[18:04:59.916]                       }
[18:04:59.916]                       else if (inherits(cond, "condition")) {
[18:04:59.916]                         if (!is.null(pattern)) {
[18:04:59.916]                           computeRestarts <- base::computeRestarts
[18:04:59.916]                           grepl <- base::grepl
[18:04:59.916]                           restarts <- computeRestarts(cond)
[18:04:59.916]                           for (restart in restarts) {
[18:04:59.916]                             name <- restart$name
[18:04:59.916]                             if (is.null(name)) 
[18:04:59.916]                               next
[18:04:59.916]                             if (!grepl(pattern, name)) 
[18:04:59.916]                               next
[18:04:59.916]                             invokeRestart(restart)
[18:04:59.916]                             muffled <- TRUE
[18:04:59.916]                             break
[18:04:59.916]                           }
[18:04:59.916]                         }
[18:04:59.916]                       }
[18:04:59.916]                       invisible(muffled)
[18:04:59.916]                     }
[18:04:59.916]                     muffleCondition(cond, pattern = "^muffle")
[18:04:59.916]                   }
[18:04:59.916]                 }
[18:04:59.916]             }
[18:04:59.916]         }))
[18:04:59.916]     }, error = function(ex) {
[18:04:59.916]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:59.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:59.916]                 ...future.rng), started = ...future.startTime, 
[18:04:59.916]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:59.916]             version = "1.8"), class = "FutureResult")
[18:04:59.916]     }, finally = {
[18:04:59.916]         if (!identical(...future.workdir, getwd())) 
[18:04:59.916]             setwd(...future.workdir)
[18:04:59.916]         {
[18:04:59.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:59.916]                 ...future.oldOptions$nwarnings <- NULL
[18:04:59.916]             }
[18:04:59.916]             base::options(...future.oldOptions)
[18:04:59.916]             if (.Platform$OS.type == "windows") {
[18:04:59.916]                 old_names <- names(...future.oldEnvVars)
[18:04:59.916]                 envs <- base::Sys.getenv()
[18:04:59.916]                 names <- names(envs)
[18:04:59.916]                 common <- intersect(names, old_names)
[18:04:59.916]                 added <- setdiff(names, old_names)
[18:04:59.916]                 removed <- setdiff(old_names, names)
[18:04:59.916]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:59.916]                   envs[common]]
[18:04:59.916]                 NAMES <- toupper(changed)
[18:04:59.916]                 args <- list()
[18:04:59.916]                 for (kk in seq_along(NAMES)) {
[18:04:59.916]                   name <- changed[[kk]]
[18:04:59.916]                   NAME <- NAMES[[kk]]
[18:04:59.916]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:59.916]                     next
[18:04:59.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:59.916]                 }
[18:04:59.916]                 NAMES <- toupper(added)
[18:04:59.916]                 for (kk in seq_along(NAMES)) {
[18:04:59.916]                   name <- added[[kk]]
[18:04:59.916]                   NAME <- NAMES[[kk]]
[18:04:59.916]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:59.916]                     next
[18:04:59.916]                   args[[name]] <- ""
[18:04:59.916]                 }
[18:04:59.916]                 NAMES <- toupper(removed)
[18:04:59.916]                 for (kk in seq_along(NAMES)) {
[18:04:59.916]                   name <- removed[[kk]]
[18:04:59.916]                   NAME <- NAMES[[kk]]
[18:04:59.916]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:59.916]                     next
[18:04:59.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:59.916]                 }
[18:04:59.916]                 if (length(args) > 0) 
[18:04:59.916]                   base::do.call(base::Sys.setenv, args = args)
[18:04:59.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:59.916]             }
[18:04:59.916]             else {
[18:04:59.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:59.916]             }
[18:04:59.916]             {
[18:04:59.916]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:59.916]                   0L) {
[18:04:59.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:59.916]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:59.916]                   base::options(opts)
[18:04:59.916]                 }
[18:04:59.916]                 {
[18:04:59.916]                   {
[18:04:59.916]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:59.916]                     NULL
[18:04:59.916]                   }
[18:04:59.916]                   options(future.plan = NULL)
[18:04:59.916]                   if (is.na(NA_character_)) 
[18:04:59.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:59.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:59.916]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:59.916]                     .init = FALSE)
[18:04:59.916]                 }
[18:04:59.916]             }
[18:04:59.916]         }
[18:04:59.916]     })
[18:04:59.916]     if (TRUE) {
[18:04:59.916]         base::sink(type = "output", split = FALSE)
[18:04:59.916]         if (TRUE) {
[18:04:59.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:59.916]         }
[18:04:59.916]         else {
[18:04:59.916]             ...future.result["stdout"] <- base::list(NULL)
[18:04:59.916]         }
[18:04:59.916]         base::close(...future.stdout)
[18:04:59.916]         ...future.stdout <- NULL
[18:04:59.916]     }
[18:04:59.916]     ...future.result$conditions <- ...future.conditions
[18:04:59.916]     ...future.result$finished <- base::Sys.time()
[18:04:59.916]     ...future.result
[18:04:59.916] }
[18:05:00.020] MultisessionFuture started
[18:05:00.020] result() for ClusterFuture ...
[18:05:00.021] receiveMessageFromWorker() for ClusterFuture ...
[18:05:00.021] - Validating connection of MultisessionFuture
[18:05:00.087] - received message: FutureResult
[18:05:00.088] - Received FutureResult
[18:05:00.088] - Erased future from FutureRegistry
[18:05:00.089] result() for ClusterFuture ...
[18:05:00.089] - result already collected: FutureResult
[18:05:00.089] result() for ClusterFuture ... done
[18:05:00.090] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:00.090] result() for ClusterFuture ... done
[18:05:00.090] result() for ClusterFuture ...
[18:05:00.091] - result already collected: FutureResult
[18:05:00.091] result() for ClusterFuture ... done
[18:05:00.091] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:05:00.099] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.100] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.101] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.105] - globals found: [3] ‘{’, ‘<-’, ‘*’
[18:05:00.105] Searching for globals ... DONE
[18:05:00.105] Resolving globals: TRUE
[18:05:00.106] Resolving any globals that are futures ...
[18:05:00.106] - globals: [3] ‘{’, ‘<-’, ‘*’
[18:05:00.106] Resolving any globals that are futures ... DONE
[18:05:00.107] 
[18:05:00.107] 
[18:05:00.108] getGlobalsAndPackages() ... DONE
[18:05:00.108] run() for ‘Future’ ...
[18:05:00.108] - state: ‘created’
[18:05:00.109] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:00.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:00.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:00.139]   - Field: ‘node’
[18:05:00.139]   - Field: ‘label’
[18:05:00.139]   - Field: ‘local’
[18:05:00.139]   - Field: ‘owner’
[18:05:00.140]   - Field: ‘envir’
[18:05:00.140]   - Field: ‘workers’
[18:05:00.140]   - Field: ‘packages’
[18:05:00.140]   - Field: ‘gc’
[18:05:00.140]   - Field: ‘conditions’
[18:05:00.141]   - Field: ‘persistent’
[18:05:00.141]   - Field: ‘expr’
[18:05:00.141]   - Field: ‘uuid’
[18:05:00.142]   - Field: ‘seed’
[18:05:00.142]   - Field: ‘version’
[18:05:00.142]   - Field: ‘result’
[18:05:00.142]   - Field: ‘asynchronous’
[18:05:00.143]   - Field: ‘calls’
[18:05:00.143]   - Field: ‘globals’
[18:05:00.143]   - Field: ‘stdout’
[18:05:00.144]   - Field: ‘earlySignal’
[18:05:00.144]   - Field: ‘lazy’
[18:05:00.144]   - Field: ‘state’
[18:05:00.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:00.145] - Launch lazy future ...
[18:05:00.145] Packages needed by the future expression (n = 0): <none>
[18:05:00.146] Packages needed by future strategies (n = 0): <none>
[18:05:00.147] {
[18:05:00.147]     {
[18:05:00.147]         {
[18:05:00.147]             ...future.startTime <- base::Sys.time()
[18:05:00.147]             {
[18:05:00.147]                 {
[18:05:00.147]                   {
[18:05:00.147]                     {
[18:05:00.147]                       base::local({
[18:05:00.147]                         has_future <- base::requireNamespace("future", 
[18:05:00.147]                           quietly = TRUE)
[18:05:00.147]                         if (has_future) {
[18:05:00.147]                           ns <- base::getNamespace("future")
[18:05:00.147]                           version <- ns[[".package"]][["version"]]
[18:05:00.147]                           if (is.null(version)) 
[18:05:00.147]                             version <- utils::packageVersion("future")
[18:05:00.147]                         }
[18:05:00.147]                         else {
[18:05:00.147]                           version <- NULL
[18:05:00.147]                         }
[18:05:00.147]                         if (!has_future || version < "1.8.0") {
[18:05:00.147]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:00.147]                             "", base::R.version$version.string), 
[18:05:00.147]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:00.147]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:00.147]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:00.147]                               "release", "version")], collapse = " "), 
[18:05:00.147]                             hostname = base::Sys.info()[["nodename"]])
[18:05:00.147]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:00.147]                             info)
[18:05:00.147]                           info <- base::paste(info, collapse = "; ")
[18:05:00.147]                           if (!has_future) {
[18:05:00.147]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:00.147]                               info)
[18:05:00.147]                           }
[18:05:00.147]                           else {
[18:05:00.147]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:00.147]                               info, version)
[18:05:00.147]                           }
[18:05:00.147]                           base::stop(msg)
[18:05:00.147]                         }
[18:05:00.147]                       })
[18:05:00.147]                     }
[18:05:00.147]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:00.147]                     base::options(mc.cores = 1L)
[18:05:00.147]                   }
[18:05:00.147]                   ...future.strategy.old <- future::plan("list")
[18:05:00.147]                   options(future.plan = NULL)
[18:05:00.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:00.147]                 }
[18:05:00.147]                 ...future.workdir <- getwd()
[18:05:00.147]             }
[18:05:00.147]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:00.147]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:00.147]         }
[18:05:00.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:00.147]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:00.147]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:00.147]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:00.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:00.147]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:00.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:00.147]             base::names(...future.oldOptions))
[18:05:00.147]     }
[18:05:00.147]     if (FALSE) {
[18:05:00.147]     }
[18:05:00.147]     else {
[18:05:00.147]         if (TRUE) {
[18:05:00.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:00.147]                 open = "w")
[18:05:00.147]         }
[18:05:00.147]         else {
[18:05:00.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:00.147]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:00.147]         }
[18:05:00.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:00.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:00.147]             base::sink(type = "output", split = FALSE)
[18:05:00.147]             base::close(...future.stdout)
[18:05:00.147]         }, add = TRUE)
[18:05:00.147]     }
[18:05:00.147]     ...future.frame <- base::sys.nframe()
[18:05:00.147]     ...future.conditions <- base::list()
[18:05:00.147]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:00.147]     if (FALSE) {
[18:05:00.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:00.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:00.147]     }
[18:05:00.147]     ...future.result <- base::tryCatch({
[18:05:00.147]         base::withCallingHandlers({
[18:05:00.147]             ...future.value <- base::withVisible(base::local({
[18:05:00.147]                 ...future.makeSendCondition <- base::local({
[18:05:00.147]                   sendCondition <- NULL
[18:05:00.147]                   function(frame = 1L) {
[18:05:00.147]                     if (is.function(sendCondition)) 
[18:05:00.147]                       return(sendCondition)
[18:05:00.147]                     ns <- getNamespace("parallel")
[18:05:00.147]                     if (exists("sendData", mode = "function", 
[18:05:00.147]                       envir = ns)) {
[18:05:00.147]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:00.147]                         envir = ns)
[18:05:00.147]                       envir <- sys.frame(frame)
[18:05:00.147]                       master <- NULL
[18:05:00.147]                       while (!identical(envir, .GlobalEnv) && 
[18:05:00.147]                         !identical(envir, emptyenv())) {
[18:05:00.147]                         if (exists("master", mode = "list", envir = envir, 
[18:05:00.147]                           inherits = FALSE)) {
[18:05:00.147]                           master <- get("master", mode = "list", 
[18:05:00.147]                             envir = envir, inherits = FALSE)
[18:05:00.147]                           if (inherits(master, c("SOCKnode", 
[18:05:00.147]                             "SOCK0node"))) {
[18:05:00.147]                             sendCondition <<- function(cond) {
[18:05:00.147]                               data <- list(type = "VALUE", value = cond, 
[18:05:00.147]                                 success = TRUE)
[18:05:00.147]                               parallel_sendData(master, data)
[18:05:00.147]                             }
[18:05:00.147]                             return(sendCondition)
[18:05:00.147]                           }
[18:05:00.147]                         }
[18:05:00.147]                         frame <- frame + 1L
[18:05:00.147]                         envir <- sys.frame(frame)
[18:05:00.147]                       }
[18:05:00.147]                     }
[18:05:00.147]                     sendCondition <<- function(cond) NULL
[18:05:00.147]                   }
[18:05:00.147]                 })
[18:05:00.147]                 withCallingHandlers({
[18:05:00.147]                   {
[18:05:00.147]                     b <- a
[18:05:00.147]                     a <- 2
[18:05:00.147]                     a * b
[18:05:00.147]                   }
[18:05:00.147]                 }, immediateCondition = function(cond) {
[18:05:00.147]                   sendCondition <- ...future.makeSendCondition()
[18:05:00.147]                   sendCondition(cond)
[18:05:00.147]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.147]                   {
[18:05:00.147]                     inherits <- base::inherits
[18:05:00.147]                     invokeRestart <- base::invokeRestart
[18:05:00.147]                     is.null <- base::is.null
[18:05:00.147]                     muffled <- FALSE
[18:05:00.147]                     if (inherits(cond, "message")) {
[18:05:00.147]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:00.147]                       if (muffled) 
[18:05:00.147]                         invokeRestart("muffleMessage")
[18:05:00.147]                     }
[18:05:00.147]                     else if (inherits(cond, "warning")) {
[18:05:00.147]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:00.147]                       if (muffled) 
[18:05:00.147]                         invokeRestart("muffleWarning")
[18:05:00.147]                     }
[18:05:00.147]                     else if (inherits(cond, "condition")) {
[18:05:00.147]                       if (!is.null(pattern)) {
[18:05:00.147]                         computeRestarts <- base::computeRestarts
[18:05:00.147]                         grepl <- base::grepl
[18:05:00.147]                         restarts <- computeRestarts(cond)
[18:05:00.147]                         for (restart in restarts) {
[18:05:00.147]                           name <- restart$name
[18:05:00.147]                           if (is.null(name)) 
[18:05:00.147]                             next
[18:05:00.147]                           if (!grepl(pattern, name)) 
[18:05:00.147]                             next
[18:05:00.147]                           invokeRestart(restart)
[18:05:00.147]                           muffled <- TRUE
[18:05:00.147]                           break
[18:05:00.147]                         }
[18:05:00.147]                       }
[18:05:00.147]                     }
[18:05:00.147]                     invisible(muffled)
[18:05:00.147]                   }
[18:05:00.147]                   muffleCondition(cond)
[18:05:00.147]                 })
[18:05:00.147]             }))
[18:05:00.147]             future::FutureResult(value = ...future.value$value, 
[18:05:00.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.147]                   ...future.rng), globalenv = if (FALSE) 
[18:05:00.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:00.147]                     ...future.globalenv.names))
[18:05:00.147]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:00.147]         }, condition = base::local({
[18:05:00.147]             c <- base::c
[18:05:00.147]             inherits <- base::inherits
[18:05:00.147]             invokeRestart <- base::invokeRestart
[18:05:00.147]             length <- base::length
[18:05:00.147]             list <- base::list
[18:05:00.147]             seq.int <- base::seq.int
[18:05:00.147]             signalCondition <- base::signalCondition
[18:05:00.147]             sys.calls <- base::sys.calls
[18:05:00.147]             `[[` <- base::`[[`
[18:05:00.147]             `+` <- base::`+`
[18:05:00.147]             `<<-` <- base::`<<-`
[18:05:00.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:00.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:00.147]                   3L)]
[18:05:00.147]             }
[18:05:00.147]             function(cond) {
[18:05:00.147]                 is_error <- inherits(cond, "error")
[18:05:00.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:00.147]                   NULL)
[18:05:00.147]                 if (is_error) {
[18:05:00.147]                   sessionInformation <- function() {
[18:05:00.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:00.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:00.147]                       search = base::search(), system = base::Sys.info())
[18:05:00.147]                   }
[18:05:00.147]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:00.147]                     cond$call), session = sessionInformation(), 
[18:05:00.147]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:00.147]                   signalCondition(cond)
[18:05:00.147]                 }
[18:05:00.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:00.147]                 "immediateCondition"))) {
[18:05:00.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:00.147]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:00.147]                   if (TRUE && !signal) {
[18:05:00.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.147]                     {
[18:05:00.147]                       inherits <- base::inherits
[18:05:00.147]                       invokeRestart <- base::invokeRestart
[18:05:00.147]                       is.null <- base::is.null
[18:05:00.147]                       muffled <- FALSE
[18:05:00.147]                       if (inherits(cond, "message")) {
[18:05:00.147]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.147]                         if (muffled) 
[18:05:00.147]                           invokeRestart("muffleMessage")
[18:05:00.147]                       }
[18:05:00.147]                       else if (inherits(cond, "warning")) {
[18:05:00.147]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.147]                         if (muffled) 
[18:05:00.147]                           invokeRestart("muffleWarning")
[18:05:00.147]                       }
[18:05:00.147]                       else if (inherits(cond, "condition")) {
[18:05:00.147]                         if (!is.null(pattern)) {
[18:05:00.147]                           computeRestarts <- base::computeRestarts
[18:05:00.147]                           grepl <- base::grepl
[18:05:00.147]                           restarts <- computeRestarts(cond)
[18:05:00.147]                           for (restart in restarts) {
[18:05:00.147]                             name <- restart$name
[18:05:00.147]                             if (is.null(name)) 
[18:05:00.147]                               next
[18:05:00.147]                             if (!grepl(pattern, name)) 
[18:05:00.147]                               next
[18:05:00.147]                             invokeRestart(restart)
[18:05:00.147]                             muffled <- TRUE
[18:05:00.147]                             break
[18:05:00.147]                           }
[18:05:00.147]                         }
[18:05:00.147]                       }
[18:05:00.147]                       invisible(muffled)
[18:05:00.147]                     }
[18:05:00.147]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.147]                   }
[18:05:00.147]                 }
[18:05:00.147]                 else {
[18:05:00.147]                   if (TRUE) {
[18:05:00.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.147]                     {
[18:05:00.147]                       inherits <- base::inherits
[18:05:00.147]                       invokeRestart <- base::invokeRestart
[18:05:00.147]                       is.null <- base::is.null
[18:05:00.147]                       muffled <- FALSE
[18:05:00.147]                       if (inherits(cond, "message")) {
[18:05:00.147]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.147]                         if (muffled) 
[18:05:00.147]                           invokeRestart("muffleMessage")
[18:05:00.147]                       }
[18:05:00.147]                       else if (inherits(cond, "warning")) {
[18:05:00.147]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.147]                         if (muffled) 
[18:05:00.147]                           invokeRestart("muffleWarning")
[18:05:00.147]                       }
[18:05:00.147]                       else if (inherits(cond, "condition")) {
[18:05:00.147]                         if (!is.null(pattern)) {
[18:05:00.147]                           computeRestarts <- base::computeRestarts
[18:05:00.147]                           grepl <- base::grepl
[18:05:00.147]                           restarts <- computeRestarts(cond)
[18:05:00.147]                           for (restart in restarts) {
[18:05:00.147]                             name <- restart$name
[18:05:00.147]                             if (is.null(name)) 
[18:05:00.147]                               next
[18:05:00.147]                             if (!grepl(pattern, name)) 
[18:05:00.147]                               next
[18:05:00.147]                             invokeRestart(restart)
[18:05:00.147]                             muffled <- TRUE
[18:05:00.147]                             break
[18:05:00.147]                           }
[18:05:00.147]                         }
[18:05:00.147]                       }
[18:05:00.147]                       invisible(muffled)
[18:05:00.147]                     }
[18:05:00.147]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.147]                   }
[18:05:00.147]                 }
[18:05:00.147]             }
[18:05:00.147]         }))
[18:05:00.147]     }, error = function(ex) {
[18:05:00.147]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:00.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.147]                 ...future.rng), started = ...future.startTime, 
[18:05:00.147]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:00.147]             version = "1.8"), class = "FutureResult")
[18:05:00.147]     }, finally = {
[18:05:00.147]         if (!identical(...future.workdir, getwd())) 
[18:05:00.147]             setwd(...future.workdir)
[18:05:00.147]         {
[18:05:00.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:00.147]                 ...future.oldOptions$nwarnings <- NULL
[18:05:00.147]             }
[18:05:00.147]             base::options(...future.oldOptions)
[18:05:00.147]             if (.Platform$OS.type == "windows") {
[18:05:00.147]                 old_names <- names(...future.oldEnvVars)
[18:05:00.147]                 envs <- base::Sys.getenv()
[18:05:00.147]                 names <- names(envs)
[18:05:00.147]                 common <- intersect(names, old_names)
[18:05:00.147]                 added <- setdiff(names, old_names)
[18:05:00.147]                 removed <- setdiff(old_names, names)
[18:05:00.147]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:00.147]                   envs[common]]
[18:05:00.147]                 NAMES <- toupper(changed)
[18:05:00.147]                 args <- list()
[18:05:00.147]                 for (kk in seq_along(NAMES)) {
[18:05:00.147]                   name <- changed[[kk]]
[18:05:00.147]                   NAME <- NAMES[[kk]]
[18:05:00.147]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.147]                     next
[18:05:00.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.147]                 }
[18:05:00.147]                 NAMES <- toupper(added)
[18:05:00.147]                 for (kk in seq_along(NAMES)) {
[18:05:00.147]                   name <- added[[kk]]
[18:05:00.147]                   NAME <- NAMES[[kk]]
[18:05:00.147]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.147]                     next
[18:05:00.147]                   args[[name]] <- ""
[18:05:00.147]                 }
[18:05:00.147]                 NAMES <- toupper(removed)
[18:05:00.147]                 for (kk in seq_along(NAMES)) {
[18:05:00.147]                   name <- removed[[kk]]
[18:05:00.147]                   NAME <- NAMES[[kk]]
[18:05:00.147]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.147]                     next
[18:05:00.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.147]                 }
[18:05:00.147]                 if (length(args) > 0) 
[18:05:00.147]                   base::do.call(base::Sys.setenv, args = args)
[18:05:00.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:00.147]             }
[18:05:00.147]             else {
[18:05:00.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:00.147]             }
[18:05:00.147]             {
[18:05:00.147]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:00.147]                   0L) {
[18:05:00.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:00.147]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:00.147]                   base::options(opts)
[18:05:00.147]                 }
[18:05:00.147]                 {
[18:05:00.147]                   {
[18:05:00.147]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:00.147]                     NULL
[18:05:00.147]                   }
[18:05:00.147]                   options(future.plan = NULL)
[18:05:00.147]                   if (is.na(NA_character_)) 
[18:05:00.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:00.147]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:00.147]                     .init = FALSE)
[18:05:00.147]                 }
[18:05:00.147]             }
[18:05:00.147]         }
[18:05:00.147]     })
[18:05:00.147]     if (TRUE) {
[18:05:00.147]         base::sink(type = "output", split = FALSE)
[18:05:00.147]         if (TRUE) {
[18:05:00.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:00.147]         }
[18:05:00.147]         else {
[18:05:00.147]             ...future.result["stdout"] <- base::list(NULL)
[18:05:00.147]         }
[18:05:00.147]         base::close(...future.stdout)
[18:05:00.147]         ...future.stdout <- NULL
[18:05:00.147]     }
[18:05:00.147]     ...future.result$conditions <- ...future.conditions
[18:05:00.147]     ...future.result$finished <- base::Sys.time()
[18:05:00.147]     ...future.result
[18:05:00.147] }
[18:05:00.154] MultisessionFuture started
[18:05:00.154] - Launch lazy future ... done
[18:05:00.154] run() for ‘MultisessionFuture’ ... done
[18:05:00.155] result() for ClusterFuture ...
[18:05:00.155] receiveMessageFromWorker() for ClusterFuture ...
[18:05:00.156] - Validating connection of MultisessionFuture
[18:05:00.200] - received message: FutureResult
[18:05:00.200] - Received FutureResult
[18:05:00.200] - Erased future from FutureRegistry
[18:05:00.201] result() for ClusterFuture ...
[18:05:00.201] - result already collected: FutureResult
[18:05:00.201] result() for ClusterFuture ... done
[18:05:00.202] signalConditions() ...
[18:05:00.202]  - include = ‘immediateCondition’
[18:05:00.202]  - exclude = 
[18:05:00.202]  - resignal = FALSE
[18:05:00.203]  - Number of conditions: 1
[18:05:00.203] signalConditions() ... done
[18:05:00.203] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:00.204] result() for ClusterFuture ... done
[18:05:00.204] result() for ClusterFuture ...
[18:05:00.204] - result already collected: FutureResult
[18:05:00.204] result() for ClusterFuture ... done
[18:05:00.205] signalConditions() ...
[18:05:00.205]  - include = ‘immediateCondition’
[18:05:00.205]  - exclude = 
[18:05:00.205]  - resignal = FALSE
[18:05:00.206]  - Number of conditions: 1
[18:05:00.206] signalConditions() ... done
[18:05:00.206] Future state: ‘finished’
[18:05:00.207] result() for ClusterFuture ...
[18:05:00.207] - result already collected: FutureResult
[18:05:00.207] result() for ClusterFuture ... done
[18:05:00.208] signalConditions() ...
[18:05:00.208]  - include = ‘condition’
[18:05:00.208]  - exclude = ‘immediateCondition’
[18:05:00.208]  - resignal = TRUE
[18:05:00.209]  - Number of conditions: 1
[18:05:00.209]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:05:00.209] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.8.0-48-generic" "#48-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 14:04:52 UTC 2024" "99adafdbb12a" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-21 18:05:00"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.250] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.251] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.255] - globals found: [3] ‘{’, ‘<-’, ‘*’
[18:05:00.255] Searching for globals ... DONE
[18:05:00.256] Resolving globals: TRUE
[18:05:00.256] Resolving any globals that are futures ...
[18:05:00.256] - globals: [3] ‘{’, ‘<-’, ‘*’
[18:05:00.256] Resolving any globals that are futures ... DONE
[18:05:00.257] 
[18:05:00.258] 
[18:05:00.258] getGlobalsAndPackages() ... DONE
[18:05:00.259] run() for ‘Future’ ...
[18:05:00.259] - state: ‘created’
[18:05:00.259] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:00.286] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:00.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:00.287]   - Field: ‘node’
[18:05:00.287]   - Field: ‘label’
[18:05:00.287]   - Field: ‘local’
[18:05:00.287]   - Field: ‘owner’
[18:05:00.287]   - Field: ‘envir’
[18:05:00.288]   - Field: ‘workers’
[18:05:00.288]   - Field: ‘packages’
[18:05:00.288]   - Field: ‘gc’
[18:05:00.288]   - Field: ‘conditions’
[18:05:00.289]   - Field: ‘persistent’
[18:05:00.289]   - Field: ‘expr’
[18:05:00.289]   - Field: ‘uuid’
[18:05:00.289]   - Field: ‘seed’
[18:05:00.289]   - Field: ‘version’
[18:05:00.290]   - Field: ‘result’
[18:05:00.290]   - Field: ‘asynchronous’
[18:05:00.290]   - Field: ‘calls’
[18:05:00.290]   - Field: ‘globals’
[18:05:00.291]   - Field: ‘stdout’
[18:05:00.291]   - Field: ‘earlySignal’
[18:05:00.291]   - Field: ‘lazy’
[18:05:00.291]   - Field: ‘state’
[18:05:00.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:00.292] - Launch lazy future ...
[18:05:00.292] Packages needed by the future expression (n = 0): <none>
[18:05:00.293] Packages needed by future strategies (n = 0): <none>
[18:05:00.294] {
[18:05:00.294]     {
[18:05:00.294]         {
[18:05:00.294]             ...future.startTime <- base::Sys.time()
[18:05:00.294]             {
[18:05:00.294]                 {
[18:05:00.294]                   {
[18:05:00.294]                     {
[18:05:00.294]                       base::local({
[18:05:00.294]                         has_future <- base::requireNamespace("future", 
[18:05:00.294]                           quietly = TRUE)
[18:05:00.294]                         if (has_future) {
[18:05:00.294]                           ns <- base::getNamespace("future")
[18:05:00.294]                           version <- ns[[".package"]][["version"]]
[18:05:00.294]                           if (is.null(version)) 
[18:05:00.294]                             version <- utils::packageVersion("future")
[18:05:00.294]                         }
[18:05:00.294]                         else {
[18:05:00.294]                           version <- NULL
[18:05:00.294]                         }
[18:05:00.294]                         if (!has_future || version < "1.8.0") {
[18:05:00.294]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:00.294]                             "", base::R.version$version.string), 
[18:05:00.294]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:00.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:00.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:00.294]                               "release", "version")], collapse = " "), 
[18:05:00.294]                             hostname = base::Sys.info()[["nodename"]])
[18:05:00.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:00.294]                             info)
[18:05:00.294]                           info <- base::paste(info, collapse = "; ")
[18:05:00.294]                           if (!has_future) {
[18:05:00.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:00.294]                               info)
[18:05:00.294]                           }
[18:05:00.294]                           else {
[18:05:00.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:00.294]                               info, version)
[18:05:00.294]                           }
[18:05:00.294]                           base::stop(msg)
[18:05:00.294]                         }
[18:05:00.294]                       })
[18:05:00.294]                     }
[18:05:00.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:00.294]                     base::options(mc.cores = 1L)
[18:05:00.294]                   }
[18:05:00.294]                   ...future.strategy.old <- future::plan("list")
[18:05:00.294]                   options(future.plan = NULL)
[18:05:00.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:00.294]                 }
[18:05:00.294]                 ...future.workdir <- getwd()
[18:05:00.294]             }
[18:05:00.294]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:00.294]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:00.294]         }
[18:05:00.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:00.294]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:00.294]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:00.294]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:00.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:00.294]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:00.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:00.294]             base::names(...future.oldOptions))
[18:05:00.294]     }
[18:05:00.294]     if (FALSE) {
[18:05:00.294]     }
[18:05:00.294]     else {
[18:05:00.294]         if (TRUE) {
[18:05:00.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:00.294]                 open = "w")
[18:05:00.294]         }
[18:05:00.294]         else {
[18:05:00.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:00.294]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:00.294]         }
[18:05:00.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:00.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:00.294]             base::sink(type = "output", split = FALSE)
[18:05:00.294]             base::close(...future.stdout)
[18:05:00.294]         }, add = TRUE)
[18:05:00.294]     }
[18:05:00.294]     ...future.frame <- base::sys.nframe()
[18:05:00.294]     ...future.conditions <- base::list()
[18:05:00.294]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:00.294]     if (FALSE) {
[18:05:00.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:00.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:00.294]     }
[18:05:00.294]     ...future.result <- base::tryCatch({
[18:05:00.294]         base::withCallingHandlers({
[18:05:00.294]             ...future.value <- base::withVisible(base::local({
[18:05:00.294]                 ...future.makeSendCondition <- base::local({
[18:05:00.294]                   sendCondition <- NULL
[18:05:00.294]                   function(frame = 1L) {
[18:05:00.294]                     if (is.function(sendCondition)) 
[18:05:00.294]                       return(sendCondition)
[18:05:00.294]                     ns <- getNamespace("parallel")
[18:05:00.294]                     if (exists("sendData", mode = "function", 
[18:05:00.294]                       envir = ns)) {
[18:05:00.294]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:00.294]                         envir = ns)
[18:05:00.294]                       envir <- sys.frame(frame)
[18:05:00.294]                       master <- NULL
[18:05:00.294]                       while (!identical(envir, .GlobalEnv) && 
[18:05:00.294]                         !identical(envir, emptyenv())) {
[18:05:00.294]                         if (exists("master", mode = "list", envir = envir, 
[18:05:00.294]                           inherits = FALSE)) {
[18:05:00.294]                           master <- get("master", mode = "list", 
[18:05:00.294]                             envir = envir, inherits = FALSE)
[18:05:00.294]                           if (inherits(master, c("SOCKnode", 
[18:05:00.294]                             "SOCK0node"))) {
[18:05:00.294]                             sendCondition <<- function(cond) {
[18:05:00.294]                               data <- list(type = "VALUE", value = cond, 
[18:05:00.294]                                 success = TRUE)
[18:05:00.294]                               parallel_sendData(master, data)
[18:05:00.294]                             }
[18:05:00.294]                             return(sendCondition)
[18:05:00.294]                           }
[18:05:00.294]                         }
[18:05:00.294]                         frame <- frame + 1L
[18:05:00.294]                         envir <- sys.frame(frame)
[18:05:00.294]                       }
[18:05:00.294]                     }
[18:05:00.294]                     sendCondition <<- function(cond) NULL
[18:05:00.294]                   }
[18:05:00.294]                 })
[18:05:00.294]                 withCallingHandlers({
[18:05:00.294]                   {
[18:05:00.294]                     b <- a
[18:05:00.294]                     a <- 2
[18:05:00.294]                     a * b
[18:05:00.294]                   }
[18:05:00.294]                 }, immediateCondition = function(cond) {
[18:05:00.294]                   sendCondition <- ...future.makeSendCondition()
[18:05:00.294]                   sendCondition(cond)
[18:05:00.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.294]                   {
[18:05:00.294]                     inherits <- base::inherits
[18:05:00.294]                     invokeRestart <- base::invokeRestart
[18:05:00.294]                     is.null <- base::is.null
[18:05:00.294]                     muffled <- FALSE
[18:05:00.294]                     if (inherits(cond, "message")) {
[18:05:00.294]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:00.294]                       if (muffled) 
[18:05:00.294]                         invokeRestart("muffleMessage")
[18:05:00.294]                     }
[18:05:00.294]                     else if (inherits(cond, "warning")) {
[18:05:00.294]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:00.294]                       if (muffled) 
[18:05:00.294]                         invokeRestart("muffleWarning")
[18:05:00.294]                     }
[18:05:00.294]                     else if (inherits(cond, "condition")) {
[18:05:00.294]                       if (!is.null(pattern)) {
[18:05:00.294]                         computeRestarts <- base::computeRestarts
[18:05:00.294]                         grepl <- base::grepl
[18:05:00.294]                         restarts <- computeRestarts(cond)
[18:05:00.294]                         for (restart in restarts) {
[18:05:00.294]                           name <- restart$name
[18:05:00.294]                           if (is.null(name)) 
[18:05:00.294]                             next
[18:05:00.294]                           if (!grepl(pattern, name)) 
[18:05:00.294]                             next
[18:05:00.294]                           invokeRestart(restart)
[18:05:00.294]                           muffled <- TRUE
[18:05:00.294]                           break
[18:05:00.294]                         }
[18:05:00.294]                       }
[18:05:00.294]                     }
[18:05:00.294]                     invisible(muffled)
[18:05:00.294]                   }
[18:05:00.294]                   muffleCondition(cond)
[18:05:00.294]                 })
[18:05:00.294]             }))
[18:05:00.294]             future::FutureResult(value = ...future.value$value, 
[18:05:00.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.294]                   ...future.rng), globalenv = if (FALSE) 
[18:05:00.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:00.294]                     ...future.globalenv.names))
[18:05:00.294]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:00.294]         }, condition = base::local({
[18:05:00.294]             c <- base::c
[18:05:00.294]             inherits <- base::inherits
[18:05:00.294]             invokeRestart <- base::invokeRestart
[18:05:00.294]             length <- base::length
[18:05:00.294]             list <- base::list
[18:05:00.294]             seq.int <- base::seq.int
[18:05:00.294]             signalCondition <- base::signalCondition
[18:05:00.294]             sys.calls <- base::sys.calls
[18:05:00.294]             `[[` <- base::`[[`
[18:05:00.294]             `+` <- base::`+`
[18:05:00.294]             `<<-` <- base::`<<-`
[18:05:00.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:00.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:00.294]                   3L)]
[18:05:00.294]             }
[18:05:00.294]             function(cond) {
[18:05:00.294]                 is_error <- inherits(cond, "error")
[18:05:00.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:00.294]                   NULL)
[18:05:00.294]                 if (is_error) {
[18:05:00.294]                   sessionInformation <- function() {
[18:05:00.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:00.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:00.294]                       search = base::search(), system = base::Sys.info())
[18:05:00.294]                   }
[18:05:00.294]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:00.294]                     cond$call), session = sessionInformation(), 
[18:05:00.294]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:00.294]                   signalCondition(cond)
[18:05:00.294]                 }
[18:05:00.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:00.294]                 "immediateCondition"))) {
[18:05:00.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:00.294]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:00.294]                   if (TRUE && !signal) {
[18:05:00.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.294]                     {
[18:05:00.294]                       inherits <- base::inherits
[18:05:00.294]                       invokeRestart <- base::invokeRestart
[18:05:00.294]                       is.null <- base::is.null
[18:05:00.294]                       muffled <- FALSE
[18:05:00.294]                       if (inherits(cond, "message")) {
[18:05:00.294]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.294]                         if (muffled) 
[18:05:00.294]                           invokeRestart("muffleMessage")
[18:05:00.294]                       }
[18:05:00.294]                       else if (inherits(cond, "warning")) {
[18:05:00.294]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.294]                         if (muffled) 
[18:05:00.294]                           invokeRestart("muffleWarning")
[18:05:00.294]                       }
[18:05:00.294]                       else if (inherits(cond, "condition")) {
[18:05:00.294]                         if (!is.null(pattern)) {
[18:05:00.294]                           computeRestarts <- base::computeRestarts
[18:05:00.294]                           grepl <- base::grepl
[18:05:00.294]                           restarts <- computeRestarts(cond)
[18:05:00.294]                           for (restart in restarts) {
[18:05:00.294]                             name <- restart$name
[18:05:00.294]                             if (is.null(name)) 
[18:05:00.294]                               next
[18:05:00.294]                             if (!grepl(pattern, name)) 
[18:05:00.294]                               next
[18:05:00.294]                             invokeRestart(restart)
[18:05:00.294]                             muffled <- TRUE
[18:05:00.294]                             break
[18:05:00.294]                           }
[18:05:00.294]                         }
[18:05:00.294]                       }
[18:05:00.294]                       invisible(muffled)
[18:05:00.294]                     }
[18:05:00.294]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.294]                   }
[18:05:00.294]                 }
[18:05:00.294]                 else {
[18:05:00.294]                   if (TRUE) {
[18:05:00.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.294]                     {
[18:05:00.294]                       inherits <- base::inherits
[18:05:00.294]                       invokeRestart <- base::invokeRestart
[18:05:00.294]                       is.null <- base::is.null
[18:05:00.294]                       muffled <- FALSE
[18:05:00.294]                       if (inherits(cond, "message")) {
[18:05:00.294]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.294]                         if (muffled) 
[18:05:00.294]                           invokeRestart("muffleMessage")
[18:05:00.294]                       }
[18:05:00.294]                       else if (inherits(cond, "warning")) {
[18:05:00.294]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.294]                         if (muffled) 
[18:05:00.294]                           invokeRestart("muffleWarning")
[18:05:00.294]                       }
[18:05:00.294]                       else if (inherits(cond, "condition")) {
[18:05:00.294]                         if (!is.null(pattern)) {
[18:05:00.294]                           computeRestarts <- base::computeRestarts
[18:05:00.294]                           grepl <- base::grepl
[18:05:00.294]                           restarts <- computeRestarts(cond)
[18:05:00.294]                           for (restart in restarts) {
[18:05:00.294]                             name <- restart$name
[18:05:00.294]                             if (is.null(name)) 
[18:05:00.294]                               next
[18:05:00.294]                             if (!grepl(pattern, name)) 
[18:05:00.294]                               next
[18:05:00.294]                             invokeRestart(restart)
[18:05:00.294]                             muffled <- TRUE
[18:05:00.294]                             break
[18:05:00.294]                           }
[18:05:00.294]                         }
[18:05:00.294]                       }
[18:05:00.294]                       invisible(muffled)
[18:05:00.294]                     }
[18:05:00.294]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.294]                   }
[18:05:00.294]                 }
[18:05:00.294]             }
[18:05:00.294]         }))
[18:05:00.294]     }, error = function(ex) {
[18:05:00.294]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:00.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.294]                 ...future.rng), started = ...future.startTime, 
[18:05:00.294]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:00.294]             version = "1.8"), class = "FutureResult")
[18:05:00.294]     }, finally = {
[18:05:00.294]         if (!identical(...future.workdir, getwd())) 
[18:05:00.294]             setwd(...future.workdir)
[18:05:00.294]         {
[18:05:00.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:00.294]                 ...future.oldOptions$nwarnings <- NULL
[18:05:00.294]             }
[18:05:00.294]             base::options(...future.oldOptions)
[18:05:00.294]             if (.Platform$OS.type == "windows") {
[18:05:00.294]                 old_names <- names(...future.oldEnvVars)
[18:05:00.294]                 envs <- base::Sys.getenv()
[18:05:00.294]                 names <- names(envs)
[18:05:00.294]                 common <- intersect(names, old_names)
[18:05:00.294]                 added <- setdiff(names, old_names)
[18:05:00.294]                 removed <- setdiff(old_names, names)
[18:05:00.294]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:00.294]                   envs[common]]
[18:05:00.294]                 NAMES <- toupper(changed)
[18:05:00.294]                 args <- list()
[18:05:00.294]                 for (kk in seq_along(NAMES)) {
[18:05:00.294]                   name <- changed[[kk]]
[18:05:00.294]                   NAME <- NAMES[[kk]]
[18:05:00.294]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.294]                     next
[18:05:00.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.294]                 }
[18:05:00.294]                 NAMES <- toupper(added)
[18:05:00.294]                 for (kk in seq_along(NAMES)) {
[18:05:00.294]                   name <- added[[kk]]
[18:05:00.294]                   NAME <- NAMES[[kk]]
[18:05:00.294]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.294]                     next
[18:05:00.294]                   args[[name]] <- ""
[18:05:00.294]                 }
[18:05:00.294]                 NAMES <- toupper(removed)
[18:05:00.294]                 for (kk in seq_along(NAMES)) {
[18:05:00.294]                   name <- removed[[kk]]
[18:05:00.294]                   NAME <- NAMES[[kk]]
[18:05:00.294]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.294]                     next
[18:05:00.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.294]                 }
[18:05:00.294]                 if (length(args) > 0) 
[18:05:00.294]                   base::do.call(base::Sys.setenv, args = args)
[18:05:00.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:00.294]             }
[18:05:00.294]             else {
[18:05:00.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:00.294]             }
[18:05:00.294]             {
[18:05:00.294]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:00.294]                   0L) {
[18:05:00.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:00.294]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:00.294]                   base::options(opts)
[18:05:00.294]                 }
[18:05:00.294]                 {
[18:05:00.294]                   {
[18:05:00.294]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:00.294]                     NULL
[18:05:00.294]                   }
[18:05:00.294]                   options(future.plan = NULL)
[18:05:00.294]                   if (is.na(NA_character_)) 
[18:05:00.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:00.294]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:00.294]                     .init = FALSE)
[18:05:00.294]                 }
[18:05:00.294]             }
[18:05:00.294]         }
[18:05:00.294]     })
[18:05:00.294]     if (TRUE) {
[18:05:00.294]         base::sink(type = "output", split = FALSE)
[18:05:00.294]         if (TRUE) {
[18:05:00.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:00.294]         }
[18:05:00.294]         else {
[18:05:00.294]             ...future.result["stdout"] <- base::list(NULL)
[18:05:00.294]         }
[18:05:00.294]         base::close(...future.stdout)
[18:05:00.294]         ...future.stdout <- NULL
[18:05:00.294]     }
[18:05:00.294]     ...future.result$conditions <- ...future.conditions
[18:05:00.294]     ...future.result$finished <- base::Sys.time()
[18:05:00.294]     ...future.result
[18:05:00.294] }
[18:05:00.300] MultisessionFuture started
[18:05:00.301] - Launch lazy future ... done
[18:05:00.301] run() for ‘MultisessionFuture’ ... done
[18:05:00.301] result() for ClusterFuture ...
[18:05:00.302] receiveMessageFromWorker() for ClusterFuture ...
[18:05:00.302] - Validating connection of MultisessionFuture
[18:05:00.350] - received message: FutureResult
[18:05:00.353] - Received FutureResult
[18:05:00.354] - Erased future from FutureRegistry
[18:05:00.354] result() for ClusterFuture ...
[18:05:00.354] - result already collected: FutureResult
[18:05:00.354] result() for ClusterFuture ... done
[18:05:00.354] signalConditions() ...
[18:05:00.354]  - include = ‘immediateCondition’
[18:05:00.355]  - exclude = 
[18:05:00.355]  - resignal = FALSE
[18:05:00.355]  - Number of conditions: 1
[18:05:00.355] signalConditions() ... done
[18:05:00.355] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:00.356] result() for ClusterFuture ... done
[18:05:00.356] result() for ClusterFuture ...
[18:05:00.356] - result already collected: FutureResult
[18:05:00.356] result() for ClusterFuture ... done
[18:05:00.356] signalConditions() ...
[18:05:00.356]  - include = ‘immediateCondition’
[18:05:00.357]  - exclude = 
[18:05:00.357]  - resignal = FALSE
[18:05:00.357]  - Number of conditions: 1
[18:05:00.357] signalConditions() ... done
[18:05:00.357] Future state: ‘finished’
[18:05:00.358] result() for ClusterFuture ...
[18:05:00.358] - result already collected: FutureResult
[18:05:00.358] result() for ClusterFuture ... done
[18:05:00.358] signalConditions() ...
[18:05:00.358]  - include = ‘condition’
[18:05:00.359]  - exclude = ‘immediateCondition’
[18:05:00.359]  - resignal = TRUE
[18:05:00.359]  - Number of conditions: 1
[18:05:00.359]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:05:00.359] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.8.0-48-generic" "#48-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 14:04:52 UTC 2024" "99adafdbb12a" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-21 18:05:00"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.389] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.390] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.392] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.393] Searching for globals ... DONE
[18:05:00.393] Resolving globals: TRUE
[18:05:00.393] Resolving any globals that are futures ...
[18:05:00.393] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.394] Resolving any globals that are futures ... DONE
[18:05:00.394] Resolving futures part of globals (recursively) ...
[18:05:00.395] resolve() on list ...
[18:05:00.395]  recursive: 99
[18:05:00.395]  length: 1
[18:05:00.395]  elements: ‘ii’
[18:05:00.395]  length: 0 (resolved future 1)
[18:05:00.396] resolve() on list ... DONE
[18:05:00.396] - globals: [1] ‘ii’
[18:05:00.396] Resolving futures part of globals (recursively) ... DONE
[18:05:00.396] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:00.397] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:00.397] - globals: [1] ‘ii’
[18:05:00.397] 
[18:05:00.398] getGlobalsAndPackages() ... DONE
[18:05:00.398] run() for ‘Future’ ...
[18:05:00.398] - state: ‘created’
[18:05:00.399] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:00.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:00.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:00.423]   - Field: ‘node’
[18:05:00.423]   - Field: ‘label’
[18:05:00.423]   - Field: ‘local’
[18:05:00.424]   - Field: ‘owner’
[18:05:00.424]   - Field: ‘envir’
[18:05:00.424]   - Field: ‘workers’
[18:05:00.424]   - Field: ‘packages’
[18:05:00.424]   - Field: ‘gc’
[18:05:00.425]   - Field: ‘conditions’
[18:05:00.425]   - Field: ‘persistent’
[18:05:00.425]   - Field: ‘expr’
[18:05:00.425]   - Field: ‘uuid’
[18:05:00.425]   - Field: ‘seed’
[18:05:00.426]   - Field: ‘version’
[18:05:00.426]   - Field: ‘result’
[18:05:00.426]   - Field: ‘asynchronous’
[18:05:00.426]   - Field: ‘calls’
[18:05:00.426]   - Field: ‘globals’
[18:05:00.427]   - Field: ‘stdout’
[18:05:00.427]   - Field: ‘earlySignal’
[18:05:00.427]   - Field: ‘lazy’
[18:05:00.427]   - Field: ‘state’
[18:05:00.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:00.428] - Launch lazy future ...
[18:05:00.428] Packages needed by the future expression (n = 0): <none>
[18:05:00.428] Packages needed by future strategies (n = 0): <none>
[18:05:00.429] {
[18:05:00.429]     {
[18:05:00.429]         {
[18:05:00.429]             ...future.startTime <- base::Sys.time()
[18:05:00.429]             {
[18:05:00.429]                 {
[18:05:00.429]                   {
[18:05:00.429]                     {
[18:05:00.429]                       base::local({
[18:05:00.429]                         has_future <- base::requireNamespace("future", 
[18:05:00.429]                           quietly = TRUE)
[18:05:00.429]                         if (has_future) {
[18:05:00.429]                           ns <- base::getNamespace("future")
[18:05:00.429]                           version <- ns[[".package"]][["version"]]
[18:05:00.429]                           if (is.null(version)) 
[18:05:00.429]                             version <- utils::packageVersion("future")
[18:05:00.429]                         }
[18:05:00.429]                         else {
[18:05:00.429]                           version <- NULL
[18:05:00.429]                         }
[18:05:00.429]                         if (!has_future || version < "1.8.0") {
[18:05:00.429]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:00.429]                             "", base::R.version$version.string), 
[18:05:00.429]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:00.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:00.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:00.429]                               "release", "version")], collapse = " "), 
[18:05:00.429]                             hostname = base::Sys.info()[["nodename"]])
[18:05:00.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:00.429]                             info)
[18:05:00.429]                           info <- base::paste(info, collapse = "; ")
[18:05:00.429]                           if (!has_future) {
[18:05:00.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:00.429]                               info)
[18:05:00.429]                           }
[18:05:00.429]                           else {
[18:05:00.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:00.429]                               info, version)
[18:05:00.429]                           }
[18:05:00.429]                           base::stop(msg)
[18:05:00.429]                         }
[18:05:00.429]                       })
[18:05:00.429]                     }
[18:05:00.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:00.429]                     base::options(mc.cores = 1L)
[18:05:00.429]                   }
[18:05:00.429]                   ...future.strategy.old <- future::plan("list")
[18:05:00.429]                   options(future.plan = NULL)
[18:05:00.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:00.429]                 }
[18:05:00.429]                 ...future.workdir <- getwd()
[18:05:00.429]             }
[18:05:00.429]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:00.429]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:00.429]         }
[18:05:00.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:00.429]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:00.429]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:00.429]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:00.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:00.429]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:00.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:00.429]             base::names(...future.oldOptions))
[18:05:00.429]     }
[18:05:00.429]     if (FALSE) {
[18:05:00.429]     }
[18:05:00.429]     else {
[18:05:00.429]         if (TRUE) {
[18:05:00.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:00.429]                 open = "w")
[18:05:00.429]         }
[18:05:00.429]         else {
[18:05:00.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:00.429]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:00.429]         }
[18:05:00.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:00.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:00.429]             base::sink(type = "output", split = FALSE)
[18:05:00.429]             base::close(...future.stdout)
[18:05:00.429]         }, add = TRUE)
[18:05:00.429]     }
[18:05:00.429]     ...future.frame <- base::sys.nframe()
[18:05:00.429]     ...future.conditions <- base::list()
[18:05:00.429]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:00.429]     if (FALSE) {
[18:05:00.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:00.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:00.429]     }
[18:05:00.429]     ...future.result <- base::tryCatch({
[18:05:00.429]         base::withCallingHandlers({
[18:05:00.429]             ...future.value <- base::withVisible(base::local({
[18:05:00.429]                 ...future.makeSendCondition <- base::local({
[18:05:00.429]                   sendCondition <- NULL
[18:05:00.429]                   function(frame = 1L) {
[18:05:00.429]                     if (is.function(sendCondition)) 
[18:05:00.429]                       return(sendCondition)
[18:05:00.429]                     ns <- getNamespace("parallel")
[18:05:00.429]                     if (exists("sendData", mode = "function", 
[18:05:00.429]                       envir = ns)) {
[18:05:00.429]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:00.429]                         envir = ns)
[18:05:00.429]                       envir <- sys.frame(frame)
[18:05:00.429]                       master <- NULL
[18:05:00.429]                       while (!identical(envir, .GlobalEnv) && 
[18:05:00.429]                         !identical(envir, emptyenv())) {
[18:05:00.429]                         if (exists("master", mode = "list", envir = envir, 
[18:05:00.429]                           inherits = FALSE)) {
[18:05:00.429]                           master <- get("master", mode = "list", 
[18:05:00.429]                             envir = envir, inherits = FALSE)
[18:05:00.429]                           if (inherits(master, c("SOCKnode", 
[18:05:00.429]                             "SOCK0node"))) {
[18:05:00.429]                             sendCondition <<- function(cond) {
[18:05:00.429]                               data <- list(type = "VALUE", value = cond, 
[18:05:00.429]                                 success = TRUE)
[18:05:00.429]                               parallel_sendData(master, data)
[18:05:00.429]                             }
[18:05:00.429]                             return(sendCondition)
[18:05:00.429]                           }
[18:05:00.429]                         }
[18:05:00.429]                         frame <- frame + 1L
[18:05:00.429]                         envir <- sys.frame(frame)
[18:05:00.429]                       }
[18:05:00.429]                     }
[18:05:00.429]                     sendCondition <<- function(cond) NULL
[18:05:00.429]                   }
[18:05:00.429]                 })
[18:05:00.429]                 withCallingHandlers({
[18:05:00.429]                   {
[18:05:00.429]                     b <- a * ii
[18:05:00.429]                     a <- 0
[18:05:00.429]                     b
[18:05:00.429]                   }
[18:05:00.429]                 }, immediateCondition = function(cond) {
[18:05:00.429]                   sendCondition <- ...future.makeSendCondition()
[18:05:00.429]                   sendCondition(cond)
[18:05:00.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.429]                   {
[18:05:00.429]                     inherits <- base::inherits
[18:05:00.429]                     invokeRestart <- base::invokeRestart
[18:05:00.429]                     is.null <- base::is.null
[18:05:00.429]                     muffled <- FALSE
[18:05:00.429]                     if (inherits(cond, "message")) {
[18:05:00.429]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:00.429]                       if (muffled) 
[18:05:00.429]                         invokeRestart("muffleMessage")
[18:05:00.429]                     }
[18:05:00.429]                     else if (inherits(cond, "warning")) {
[18:05:00.429]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:00.429]                       if (muffled) 
[18:05:00.429]                         invokeRestart("muffleWarning")
[18:05:00.429]                     }
[18:05:00.429]                     else if (inherits(cond, "condition")) {
[18:05:00.429]                       if (!is.null(pattern)) {
[18:05:00.429]                         computeRestarts <- base::computeRestarts
[18:05:00.429]                         grepl <- base::grepl
[18:05:00.429]                         restarts <- computeRestarts(cond)
[18:05:00.429]                         for (restart in restarts) {
[18:05:00.429]                           name <- restart$name
[18:05:00.429]                           if (is.null(name)) 
[18:05:00.429]                             next
[18:05:00.429]                           if (!grepl(pattern, name)) 
[18:05:00.429]                             next
[18:05:00.429]                           invokeRestart(restart)
[18:05:00.429]                           muffled <- TRUE
[18:05:00.429]                           break
[18:05:00.429]                         }
[18:05:00.429]                       }
[18:05:00.429]                     }
[18:05:00.429]                     invisible(muffled)
[18:05:00.429]                   }
[18:05:00.429]                   muffleCondition(cond)
[18:05:00.429]                 })
[18:05:00.429]             }))
[18:05:00.429]             future::FutureResult(value = ...future.value$value, 
[18:05:00.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.429]                   ...future.rng), globalenv = if (FALSE) 
[18:05:00.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:00.429]                     ...future.globalenv.names))
[18:05:00.429]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:00.429]         }, condition = base::local({
[18:05:00.429]             c <- base::c
[18:05:00.429]             inherits <- base::inherits
[18:05:00.429]             invokeRestart <- base::invokeRestart
[18:05:00.429]             length <- base::length
[18:05:00.429]             list <- base::list
[18:05:00.429]             seq.int <- base::seq.int
[18:05:00.429]             signalCondition <- base::signalCondition
[18:05:00.429]             sys.calls <- base::sys.calls
[18:05:00.429]             `[[` <- base::`[[`
[18:05:00.429]             `+` <- base::`+`
[18:05:00.429]             `<<-` <- base::`<<-`
[18:05:00.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:00.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:00.429]                   3L)]
[18:05:00.429]             }
[18:05:00.429]             function(cond) {
[18:05:00.429]                 is_error <- inherits(cond, "error")
[18:05:00.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:00.429]                   NULL)
[18:05:00.429]                 if (is_error) {
[18:05:00.429]                   sessionInformation <- function() {
[18:05:00.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:00.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:00.429]                       search = base::search(), system = base::Sys.info())
[18:05:00.429]                   }
[18:05:00.429]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:00.429]                     cond$call), session = sessionInformation(), 
[18:05:00.429]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:00.429]                   signalCondition(cond)
[18:05:00.429]                 }
[18:05:00.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:00.429]                 "immediateCondition"))) {
[18:05:00.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:00.429]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:00.429]                   if (TRUE && !signal) {
[18:05:00.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.429]                     {
[18:05:00.429]                       inherits <- base::inherits
[18:05:00.429]                       invokeRestart <- base::invokeRestart
[18:05:00.429]                       is.null <- base::is.null
[18:05:00.429]                       muffled <- FALSE
[18:05:00.429]                       if (inherits(cond, "message")) {
[18:05:00.429]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.429]                         if (muffled) 
[18:05:00.429]                           invokeRestart("muffleMessage")
[18:05:00.429]                       }
[18:05:00.429]                       else if (inherits(cond, "warning")) {
[18:05:00.429]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.429]                         if (muffled) 
[18:05:00.429]                           invokeRestart("muffleWarning")
[18:05:00.429]                       }
[18:05:00.429]                       else if (inherits(cond, "condition")) {
[18:05:00.429]                         if (!is.null(pattern)) {
[18:05:00.429]                           computeRestarts <- base::computeRestarts
[18:05:00.429]                           grepl <- base::grepl
[18:05:00.429]                           restarts <- computeRestarts(cond)
[18:05:00.429]                           for (restart in restarts) {
[18:05:00.429]                             name <- restart$name
[18:05:00.429]                             if (is.null(name)) 
[18:05:00.429]                               next
[18:05:00.429]                             if (!grepl(pattern, name)) 
[18:05:00.429]                               next
[18:05:00.429]                             invokeRestart(restart)
[18:05:00.429]                             muffled <- TRUE
[18:05:00.429]                             break
[18:05:00.429]                           }
[18:05:00.429]                         }
[18:05:00.429]                       }
[18:05:00.429]                       invisible(muffled)
[18:05:00.429]                     }
[18:05:00.429]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.429]                   }
[18:05:00.429]                 }
[18:05:00.429]                 else {
[18:05:00.429]                   if (TRUE) {
[18:05:00.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.429]                     {
[18:05:00.429]                       inherits <- base::inherits
[18:05:00.429]                       invokeRestart <- base::invokeRestart
[18:05:00.429]                       is.null <- base::is.null
[18:05:00.429]                       muffled <- FALSE
[18:05:00.429]                       if (inherits(cond, "message")) {
[18:05:00.429]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.429]                         if (muffled) 
[18:05:00.429]                           invokeRestart("muffleMessage")
[18:05:00.429]                       }
[18:05:00.429]                       else if (inherits(cond, "warning")) {
[18:05:00.429]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.429]                         if (muffled) 
[18:05:00.429]                           invokeRestart("muffleWarning")
[18:05:00.429]                       }
[18:05:00.429]                       else if (inherits(cond, "condition")) {
[18:05:00.429]                         if (!is.null(pattern)) {
[18:05:00.429]                           computeRestarts <- base::computeRestarts
[18:05:00.429]                           grepl <- base::grepl
[18:05:00.429]                           restarts <- computeRestarts(cond)
[18:05:00.429]                           for (restart in restarts) {
[18:05:00.429]                             name <- restart$name
[18:05:00.429]                             if (is.null(name)) 
[18:05:00.429]                               next
[18:05:00.429]                             if (!grepl(pattern, name)) 
[18:05:00.429]                               next
[18:05:00.429]                             invokeRestart(restart)
[18:05:00.429]                             muffled <- TRUE
[18:05:00.429]                             break
[18:05:00.429]                           }
[18:05:00.429]                         }
[18:05:00.429]                       }
[18:05:00.429]                       invisible(muffled)
[18:05:00.429]                     }
[18:05:00.429]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.429]                   }
[18:05:00.429]                 }
[18:05:00.429]             }
[18:05:00.429]         }))
[18:05:00.429]     }, error = function(ex) {
[18:05:00.429]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:00.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.429]                 ...future.rng), started = ...future.startTime, 
[18:05:00.429]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:00.429]             version = "1.8"), class = "FutureResult")
[18:05:00.429]     }, finally = {
[18:05:00.429]         if (!identical(...future.workdir, getwd())) 
[18:05:00.429]             setwd(...future.workdir)
[18:05:00.429]         {
[18:05:00.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:00.429]                 ...future.oldOptions$nwarnings <- NULL
[18:05:00.429]             }
[18:05:00.429]             base::options(...future.oldOptions)
[18:05:00.429]             if (.Platform$OS.type == "windows") {
[18:05:00.429]                 old_names <- names(...future.oldEnvVars)
[18:05:00.429]                 envs <- base::Sys.getenv()
[18:05:00.429]                 names <- names(envs)
[18:05:00.429]                 common <- intersect(names, old_names)
[18:05:00.429]                 added <- setdiff(names, old_names)
[18:05:00.429]                 removed <- setdiff(old_names, names)
[18:05:00.429]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:00.429]                   envs[common]]
[18:05:00.429]                 NAMES <- toupper(changed)
[18:05:00.429]                 args <- list()
[18:05:00.429]                 for (kk in seq_along(NAMES)) {
[18:05:00.429]                   name <- changed[[kk]]
[18:05:00.429]                   NAME <- NAMES[[kk]]
[18:05:00.429]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.429]                     next
[18:05:00.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.429]                 }
[18:05:00.429]                 NAMES <- toupper(added)
[18:05:00.429]                 for (kk in seq_along(NAMES)) {
[18:05:00.429]                   name <- added[[kk]]
[18:05:00.429]                   NAME <- NAMES[[kk]]
[18:05:00.429]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.429]                     next
[18:05:00.429]                   args[[name]] <- ""
[18:05:00.429]                 }
[18:05:00.429]                 NAMES <- toupper(removed)
[18:05:00.429]                 for (kk in seq_along(NAMES)) {
[18:05:00.429]                   name <- removed[[kk]]
[18:05:00.429]                   NAME <- NAMES[[kk]]
[18:05:00.429]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.429]                     next
[18:05:00.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.429]                 }
[18:05:00.429]                 if (length(args) > 0) 
[18:05:00.429]                   base::do.call(base::Sys.setenv, args = args)
[18:05:00.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:00.429]             }
[18:05:00.429]             else {
[18:05:00.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:00.429]             }
[18:05:00.429]             {
[18:05:00.429]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:00.429]                   0L) {
[18:05:00.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:00.429]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:00.429]                   base::options(opts)
[18:05:00.429]                 }
[18:05:00.429]                 {
[18:05:00.429]                   {
[18:05:00.429]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:00.429]                     NULL
[18:05:00.429]                   }
[18:05:00.429]                   options(future.plan = NULL)
[18:05:00.429]                   if (is.na(NA_character_)) 
[18:05:00.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:00.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:00.429]                     .init = FALSE)
[18:05:00.429]                 }
[18:05:00.429]             }
[18:05:00.429]         }
[18:05:00.429]     })
[18:05:00.429]     if (TRUE) {
[18:05:00.429]         base::sink(type = "output", split = FALSE)
[18:05:00.429]         if (TRUE) {
[18:05:00.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:00.429]         }
[18:05:00.429]         else {
[18:05:00.429]             ...future.result["stdout"] <- base::list(NULL)
[18:05:00.429]         }
[18:05:00.429]         base::close(...future.stdout)
[18:05:00.429]         ...future.stdout <- NULL
[18:05:00.429]     }
[18:05:00.429]     ...future.result$conditions <- ...future.conditions
[18:05:00.429]     ...future.result$finished <- base::Sys.time()
[18:05:00.429]     ...future.result
[18:05:00.429] }
[18:05:00.434] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:05:00.434] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[18:05:00.435] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[18:05:00.435] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:05:00.436] MultisessionFuture started
[18:05:00.437] - Launch lazy future ... done
[18:05:00.437] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.438] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.438] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.441] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.441] Searching for globals ... DONE
[18:05:00.441] Resolving globals: TRUE
[18:05:00.442] Resolving any globals that are futures ...
[18:05:00.442] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.442] Resolving any globals that are futures ... DONE
[18:05:00.443] Resolving futures part of globals (recursively) ...
[18:05:00.443] resolve() on list ...
[18:05:00.443]  recursive: 99
[18:05:00.444]  length: 1
[18:05:00.444]  elements: ‘ii’
[18:05:00.444]  length: 0 (resolved future 1)
[18:05:00.444] resolve() on list ... DONE
[18:05:00.444] - globals: [1] ‘ii’
[18:05:00.445] Resolving futures part of globals (recursively) ... DONE
[18:05:00.445] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:00.445] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:00.446] - globals: [1] ‘ii’
[18:05:00.446] 
[18:05:00.446] getGlobalsAndPackages() ... DONE
[18:05:00.447] run() for ‘Future’ ...
[18:05:00.447] - state: ‘created’
[18:05:00.447] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:00.471] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:00.471] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:00.471]   - Field: ‘node’
[18:05:00.472]   - Field: ‘label’
[18:05:00.472]   - Field: ‘local’
[18:05:00.472]   - Field: ‘owner’
[18:05:00.472]   - Field: ‘envir’
[18:05:00.472]   - Field: ‘workers’
[18:05:00.473]   - Field: ‘packages’
[18:05:00.473]   - Field: ‘gc’
[18:05:00.473]   - Field: ‘conditions’
[18:05:00.473]   - Field: ‘persistent’
[18:05:00.473]   - Field: ‘expr’
[18:05:00.474]   - Field: ‘uuid’
[18:05:00.474]   - Field: ‘seed’
[18:05:00.474]   - Field: ‘version’
[18:05:00.474]   - Field: ‘result’
[18:05:00.474]   - Field: ‘asynchronous’
[18:05:00.475]   - Field: ‘calls’
[18:05:00.475]   - Field: ‘globals’
[18:05:00.475]   - Field: ‘stdout’
[18:05:00.475]   - Field: ‘earlySignal’
[18:05:00.475]   - Field: ‘lazy’
[18:05:00.476]   - Field: ‘state’
[18:05:00.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:00.476] - Launch lazy future ...
[18:05:00.477] Packages needed by the future expression (n = 0): <none>
[18:05:00.477] Packages needed by future strategies (n = 0): <none>
[18:05:00.478] {
[18:05:00.478]     {
[18:05:00.478]         {
[18:05:00.478]             ...future.startTime <- base::Sys.time()
[18:05:00.478]             {
[18:05:00.478]                 {
[18:05:00.478]                   {
[18:05:00.478]                     {
[18:05:00.478]                       base::local({
[18:05:00.478]                         has_future <- base::requireNamespace("future", 
[18:05:00.478]                           quietly = TRUE)
[18:05:00.478]                         if (has_future) {
[18:05:00.478]                           ns <- base::getNamespace("future")
[18:05:00.478]                           version <- ns[[".package"]][["version"]]
[18:05:00.478]                           if (is.null(version)) 
[18:05:00.478]                             version <- utils::packageVersion("future")
[18:05:00.478]                         }
[18:05:00.478]                         else {
[18:05:00.478]                           version <- NULL
[18:05:00.478]                         }
[18:05:00.478]                         if (!has_future || version < "1.8.0") {
[18:05:00.478]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:00.478]                             "", base::R.version$version.string), 
[18:05:00.478]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:00.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:00.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:00.478]                               "release", "version")], collapse = " "), 
[18:05:00.478]                             hostname = base::Sys.info()[["nodename"]])
[18:05:00.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:00.478]                             info)
[18:05:00.478]                           info <- base::paste(info, collapse = "; ")
[18:05:00.478]                           if (!has_future) {
[18:05:00.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:00.478]                               info)
[18:05:00.478]                           }
[18:05:00.478]                           else {
[18:05:00.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:00.478]                               info, version)
[18:05:00.478]                           }
[18:05:00.478]                           base::stop(msg)
[18:05:00.478]                         }
[18:05:00.478]                       })
[18:05:00.478]                     }
[18:05:00.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:00.478]                     base::options(mc.cores = 1L)
[18:05:00.478]                   }
[18:05:00.478]                   ...future.strategy.old <- future::plan("list")
[18:05:00.478]                   options(future.plan = NULL)
[18:05:00.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:00.478]                 }
[18:05:00.478]                 ...future.workdir <- getwd()
[18:05:00.478]             }
[18:05:00.478]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:00.478]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:00.478]         }
[18:05:00.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:00.478]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:00.478]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:00.478]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:00.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:00.478]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:00.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:00.478]             base::names(...future.oldOptions))
[18:05:00.478]     }
[18:05:00.478]     if (FALSE) {
[18:05:00.478]     }
[18:05:00.478]     else {
[18:05:00.478]         if (TRUE) {
[18:05:00.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:00.478]                 open = "w")
[18:05:00.478]         }
[18:05:00.478]         else {
[18:05:00.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:00.478]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:00.478]         }
[18:05:00.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:00.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:00.478]             base::sink(type = "output", split = FALSE)
[18:05:00.478]             base::close(...future.stdout)
[18:05:00.478]         }, add = TRUE)
[18:05:00.478]     }
[18:05:00.478]     ...future.frame <- base::sys.nframe()
[18:05:00.478]     ...future.conditions <- base::list()
[18:05:00.478]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:00.478]     if (FALSE) {
[18:05:00.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:00.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:00.478]     }
[18:05:00.478]     ...future.result <- base::tryCatch({
[18:05:00.478]         base::withCallingHandlers({
[18:05:00.478]             ...future.value <- base::withVisible(base::local({
[18:05:00.478]                 ...future.makeSendCondition <- base::local({
[18:05:00.478]                   sendCondition <- NULL
[18:05:00.478]                   function(frame = 1L) {
[18:05:00.478]                     if (is.function(sendCondition)) 
[18:05:00.478]                       return(sendCondition)
[18:05:00.478]                     ns <- getNamespace("parallel")
[18:05:00.478]                     if (exists("sendData", mode = "function", 
[18:05:00.478]                       envir = ns)) {
[18:05:00.478]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:00.478]                         envir = ns)
[18:05:00.478]                       envir <- sys.frame(frame)
[18:05:00.478]                       master <- NULL
[18:05:00.478]                       while (!identical(envir, .GlobalEnv) && 
[18:05:00.478]                         !identical(envir, emptyenv())) {
[18:05:00.478]                         if (exists("master", mode = "list", envir = envir, 
[18:05:00.478]                           inherits = FALSE)) {
[18:05:00.478]                           master <- get("master", mode = "list", 
[18:05:00.478]                             envir = envir, inherits = FALSE)
[18:05:00.478]                           if (inherits(master, c("SOCKnode", 
[18:05:00.478]                             "SOCK0node"))) {
[18:05:00.478]                             sendCondition <<- function(cond) {
[18:05:00.478]                               data <- list(type = "VALUE", value = cond, 
[18:05:00.478]                                 success = TRUE)
[18:05:00.478]                               parallel_sendData(master, data)
[18:05:00.478]                             }
[18:05:00.478]                             return(sendCondition)
[18:05:00.478]                           }
[18:05:00.478]                         }
[18:05:00.478]                         frame <- frame + 1L
[18:05:00.478]                         envir <- sys.frame(frame)
[18:05:00.478]                       }
[18:05:00.478]                     }
[18:05:00.478]                     sendCondition <<- function(cond) NULL
[18:05:00.478]                   }
[18:05:00.478]                 })
[18:05:00.478]                 withCallingHandlers({
[18:05:00.478]                   {
[18:05:00.478]                     b <- a * ii
[18:05:00.478]                     a <- 0
[18:05:00.478]                     b
[18:05:00.478]                   }
[18:05:00.478]                 }, immediateCondition = function(cond) {
[18:05:00.478]                   sendCondition <- ...future.makeSendCondition()
[18:05:00.478]                   sendCondition(cond)
[18:05:00.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.478]                   {
[18:05:00.478]                     inherits <- base::inherits
[18:05:00.478]                     invokeRestart <- base::invokeRestart
[18:05:00.478]                     is.null <- base::is.null
[18:05:00.478]                     muffled <- FALSE
[18:05:00.478]                     if (inherits(cond, "message")) {
[18:05:00.478]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:00.478]                       if (muffled) 
[18:05:00.478]                         invokeRestart("muffleMessage")
[18:05:00.478]                     }
[18:05:00.478]                     else if (inherits(cond, "warning")) {
[18:05:00.478]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:00.478]                       if (muffled) 
[18:05:00.478]                         invokeRestart("muffleWarning")
[18:05:00.478]                     }
[18:05:00.478]                     else if (inherits(cond, "condition")) {
[18:05:00.478]                       if (!is.null(pattern)) {
[18:05:00.478]                         computeRestarts <- base::computeRestarts
[18:05:00.478]                         grepl <- base::grepl
[18:05:00.478]                         restarts <- computeRestarts(cond)
[18:05:00.478]                         for (restart in restarts) {
[18:05:00.478]                           name <- restart$name
[18:05:00.478]                           if (is.null(name)) 
[18:05:00.478]                             next
[18:05:00.478]                           if (!grepl(pattern, name)) 
[18:05:00.478]                             next
[18:05:00.478]                           invokeRestart(restart)
[18:05:00.478]                           muffled <- TRUE
[18:05:00.478]                           break
[18:05:00.478]                         }
[18:05:00.478]                       }
[18:05:00.478]                     }
[18:05:00.478]                     invisible(muffled)
[18:05:00.478]                   }
[18:05:00.478]                   muffleCondition(cond)
[18:05:00.478]                 })
[18:05:00.478]             }))
[18:05:00.478]             future::FutureResult(value = ...future.value$value, 
[18:05:00.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.478]                   ...future.rng), globalenv = if (FALSE) 
[18:05:00.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:00.478]                     ...future.globalenv.names))
[18:05:00.478]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:00.478]         }, condition = base::local({
[18:05:00.478]             c <- base::c
[18:05:00.478]             inherits <- base::inherits
[18:05:00.478]             invokeRestart <- base::invokeRestart
[18:05:00.478]             length <- base::length
[18:05:00.478]             list <- base::list
[18:05:00.478]             seq.int <- base::seq.int
[18:05:00.478]             signalCondition <- base::signalCondition
[18:05:00.478]             sys.calls <- base::sys.calls
[18:05:00.478]             `[[` <- base::`[[`
[18:05:00.478]             `+` <- base::`+`
[18:05:00.478]             `<<-` <- base::`<<-`
[18:05:00.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:00.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:00.478]                   3L)]
[18:05:00.478]             }
[18:05:00.478]             function(cond) {
[18:05:00.478]                 is_error <- inherits(cond, "error")
[18:05:00.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:00.478]                   NULL)
[18:05:00.478]                 if (is_error) {
[18:05:00.478]                   sessionInformation <- function() {
[18:05:00.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:00.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:00.478]                       search = base::search(), system = base::Sys.info())
[18:05:00.478]                   }
[18:05:00.478]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:00.478]                     cond$call), session = sessionInformation(), 
[18:05:00.478]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:00.478]                   signalCondition(cond)
[18:05:00.478]                 }
[18:05:00.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:00.478]                 "immediateCondition"))) {
[18:05:00.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:00.478]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:00.478]                   if (TRUE && !signal) {
[18:05:00.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.478]                     {
[18:05:00.478]                       inherits <- base::inherits
[18:05:00.478]                       invokeRestart <- base::invokeRestart
[18:05:00.478]                       is.null <- base::is.null
[18:05:00.478]                       muffled <- FALSE
[18:05:00.478]                       if (inherits(cond, "message")) {
[18:05:00.478]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.478]                         if (muffled) 
[18:05:00.478]                           invokeRestart("muffleMessage")
[18:05:00.478]                       }
[18:05:00.478]                       else if (inherits(cond, "warning")) {
[18:05:00.478]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.478]                         if (muffled) 
[18:05:00.478]                           invokeRestart("muffleWarning")
[18:05:00.478]                       }
[18:05:00.478]                       else if (inherits(cond, "condition")) {
[18:05:00.478]                         if (!is.null(pattern)) {
[18:05:00.478]                           computeRestarts <- base::computeRestarts
[18:05:00.478]                           grepl <- base::grepl
[18:05:00.478]                           restarts <- computeRestarts(cond)
[18:05:00.478]                           for (restart in restarts) {
[18:05:00.478]                             name <- restart$name
[18:05:00.478]                             if (is.null(name)) 
[18:05:00.478]                               next
[18:05:00.478]                             if (!grepl(pattern, name)) 
[18:05:00.478]                               next
[18:05:00.478]                             invokeRestart(restart)
[18:05:00.478]                             muffled <- TRUE
[18:05:00.478]                             break
[18:05:00.478]                           }
[18:05:00.478]                         }
[18:05:00.478]                       }
[18:05:00.478]                       invisible(muffled)
[18:05:00.478]                     }
[18:05:00.478]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.478]                   }
[18:05:00.478]                 }
[18:05:00.478]                 else {
[18:05:00.478]                   if (TRUE) {
[18:05:00.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.478]                     {
[18:05:00.478]                       inherits <- base::inherits
[18:05:00.478]                       invokeRestart <- base::invokeRestart
[18:05:00.478]                       is.null <- base::is.null
[18:05:00.478]                       muffled <- FALSE
[18:05:00.478]                       if (inherits(cond, "message")) {
[18:05:00.478]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.478]                         if (muffled) 
[18:05:00.478]                           invokeRestart("muffleMessage")
[18:05:00.478]                       }
[18:05:00.478]                       else if (inherits(cond, "warning")) {
[18:05:00.478]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.478]                         if (muffled) 
[18:05:00.478]                           invokeRestart("muffleWarning")
[18:05:00.478]                       }
[18:05:00.478]                       else if (inherits(cond, "condition")) {
[18:05:00.478]                         if (!is.null(pattern)) {
[18:05:00.478]                           computeRestarts <- base::computeRestarts
[18:05:00.478]                           grepl <- base::grepl
[18:05:00.478]                           restarts <- computeRestarts(cond)
[18:05:00.478]                           for (restart in restarts) {
[18:05:00.478]                             name <- restart$name
[18:05:00.478]                             if (is.null(name)) 
[18:05:00.478]                               next
[18:05:00.478]                             if (!grepl(pattern, name)) 
[18:05:00.478]                               next
[18:05:00.478]                             invokeRestart(restart)
[18:05:00.478]                             muffled <- TRUE
[18:05:00.478]                             break
[18:05:00.478]                           }
[18:05:00.478]                         }
[18:05:00.478]                       }
[18:05:00.478]                       invisible(muffled)
[18:05:00.478]                     }
[18:05:00.478]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.478]                   }
[18:05:00.478]                 }
[18:05:00.478]             }
[18:05:00.478]         }))
[18:05:00.478]     }, error = function(ex) {
[18:05:00.478]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:00.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.478]                 ...future.rng), started = ...future.startTime, 
[18:05:00.478]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:00.478]             version = "1.8"), class = "FutureResult")
[18:05:00.478]     }, finally = {
[18:05:00.478]         if (!identical(...future.workdir, getwd())) 
[18:05:00.478]             setwd(...future.workdir)
[18:05:00.478]         {
[18:05:00.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:00.478]                 ...future.oldOptions$nwarnings <- NULL
[18:05:00.478]             }
[18:05:00.478]             base::options(...future.oldOptions)
[18:05:00.478]             if (.Platform$OS.type == "windows") {
[18:05:00.478]                 old_names <- names(...future.oldEnvVars)
[18:05:00.478]                 envs <- base::Sys.getenv()
[18:05:00.478]                 names <- names(envs)
[18:05:00.478]                 common <- intersect(names, old_names)
[18:05:00.478]                 added <- setdiff(names, old_names)
[18:05:00.478]                 removed <- setdiff(old_names, names)
[18:05:00.478]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:00.478]                   envs[common]]
[18:05:00.478]                 NAMES <- toupper(changed)
[18:05:00.478]                 args <- list()
[18:05:00.478]                 for (kk in seq_along(NAMES)) {
[18:05:00.478]                   name <- changed[[kk]]
[18:05:00.478]                   NAME <- NAMES[[kk]]
[18:05:00.478]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.478]                     next
[18:05:00.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.478]                 }
[18:05:00.478]                 NAMES <- toupper(added)
[18:05:00.478]                 for (kk in seq_along(NAMES)) {
[18:05:00.478]                   name <- added[[kk]]
[18:05:00.478]                   NAME <- NAMES[[kk]]
[18:05:00.478]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.478]                     next
[18:05:00.478]                   args[[name]] <- ""
[18:05:00.478]                 }
[18:05:00.478]                 NAMES <- toupper(removed)
[18:05:00.478]                 for (kk in seq_along(NAMES)) {
[18:05:00.478]                   name <- removed[[kk]]
[18:05:00.478]                   NAME <- NAMES[[kk]]
[18:05:00.478]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.478]                     next
[18:05:00.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.478]                 }
[18:05:00.478]                 if (length(args) > 0) 
[18:05:00.478]                   base::do.call(base::Sys.setenv, args = args)
[18:05:00.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:00.478]             }
[18:05:00.478]             else {
[18:05:00.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:00.478]             }
[18:05:00.478]             {
[18:05:00.478]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:00.478]                   0L) {
[18:05:00.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:00.478]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:00.478]                   base::options(opts)
[18:05:00.478]                 }
[18:05:00.478]                 {
[18:05:00.478]                   {
[18:05:00.478]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:00.478]                     NULL
[18:05:00.478]                   }
[18:05:00.478]                   options(future.plan = NULL)
[18:05:00.478]                   if (is.na(NA_character_)) 
[18:05:00.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:00.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:00.478]                     .init = FALSE)
[18:05:00.478]                 }
[18:05:00.478]             }
[18:05:00.478]         }
[18:05:00.478]     })
[18:05:00.478]     if (TRUE) {
[18:05:00.478]         base::sink(type = "output", split = FALSE)
[18:05:00.478]         if (TRUE) {
[18:05:00.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:00.478]         }
[18:05:00.478]         else {
[18:05:00.478]             ...future.result["stdout"] <- base::list(NULL)
[18:05:00.478]         }
[18:05:00.478]         base::close(...future.stdout)
[18:05:00.478]         ...future.stdout <- NULL
[18:05:00.478]     }
[18:05:00.478]     ...future.result$conditions <- ...future.conditions
[18:05:00.478]     ...future.result$finished <- base::Sys.time()
[18:05:00.478]     ...future.result
[18:05:00.478] }
[18:05:00.580] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[18:05:00.580] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[18:05:00.581] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[18:05:00.581] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[18:05:00.582] MultisessionFuture started
[18:05:00.582] - Launch lazy future ... done
[18:05:00.583] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.584] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.584] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.587] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.587] Searching for globals ... DONE
[18:05:00.587] Resolving globals: TRUE
[18:05:00.587] Resolving any globals that are futures ...
[18:05:00.588] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.588] Resolving any globals that are futures ... DONE
[18:05:00.589] Resolving futures part of globals (recursively) ...
[18:05:00.589] resolve() on list ...
[18:05:00.589]  recursive: 99
[18:05:00.589]  length: 1
[18:05:00.590]  elements: ‘ii’
[18:05:00.590]  length: 0 (resolved future 1)
[18:05:00.590] resolve() on list ... DONE
[18:05:00.590] - globals: [1] ‘ii’
[18:05:00.590] Resolving futures part of globals (recursively) ... DONE
[18:05:00.591] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:00.591] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:00.592] - globals: [1] ‘ii’
[18:05:00.592] 
[18:05:00.592] getGlobalsAndPackages() ... DONE
[18:05:00.592] run() for ‘Future’ ...
[18:05:00.593] - state: ‘created’
[18:05:00.593] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:00.617] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:00.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:00.617]   - Field: ‘node’
[18:05:00.617]   - Field: ‘label’
[18:05:00.618]   - Field: ‘local’
[18:05:00.618]   - Field: ‘owner’
[18:05:00.618]   - Field: ‘envir’
[18:05:00.618]   - Field: ‘workers’
[18:05:00.618]   - Field: ‘packages’
[18:05:00.619]   - Field: ‘gc’
[18:05:00.619]   - Field: ‘conditions’
[18:05:00.619]   - Field: ‘persistent’
[18:05:00.619]   - Field: ‘expr’
[18:05:00.619]   - Field: ‘uuid’
[18:05:00.620]   - Field: ‘seed’
[18:05:00.620]   - Field: ‘version’
[18:05:00.620]   - Field: ‘result’
[18:05:00.620]   - Field: ‘asynchronous’
[18:05:00.620]   - Field: ‘calls’
[18:05:00.620]   - Field: ‘globals’
[18:05:00.621]   - Field: ‘stdout’
[18:05:00.621]   - Field: ‘earlySignal’
[18:05:00.621]   - Field: ‘lazy’
[18:05:00.621]   - Field: ‘state’
[18:05:00.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:00.622] - Launch lazy future ...
[18:05:00.622] Packages needed by the future expression (n = 0): <none>
[18:05:00.622] Packages needed by future strategies (n = 0): <none>
[18:05:00.623] {
[18:05:00.623]     {
[18:05:00.623]         {
[18:05:00.623]             ...future.startTime <- base::Sys.time()
[18:05:00.623]             {
[18:05:00.623]                 {
[18:05:00.623]                   {
[18:05:00.623]                     {
[18:05:00.623]                       base::local({
[18:05:00.623]                         has_future <- base::requireNamespace("future", 
[18:05:00.623]                           quietly = TRUE)
[18:05:00.623]                         if (has_future) {
[18:05:00.623]                           ns <- base::getNamespace("future")
[18:05:00.623]                           version <- ns[[".package"]][["version"]]
[18:05:00.623]                           if (is.null(version)) 
[18:05:00.623]                             version <- utils::packageVersion("future")
[18:05:00.623]                         }
[18:05:00.623]                         else {
[18:05:00.623]                           version <- NULL
[18:05:00.623]                         }
[18:05:00.623]                         if (!has_future || version < "1.8.0") {
[18:05:00.623]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:00.623]                             "", base::R.version$version.string), 
[18:05:00.623]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:00.623]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:00.623]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:00.623]                               "release", "version")], collapse = " "), 
[18:05:00.623]                             hostname = base::Sys.info()[["nodename"]])
[18:05:00.623]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:00.623]                             info)
[18:05:00.623]                           info <- base::paste(info, collapse = "; ")
[18:05:00.623]                           if (!has_future) {
[18:05:00.623]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:00.623]                               info)
[18:05:00.623]                           }
[18:05:00.623]                           else {
[18:05:00.623]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:00.623]                               info, version)
[18:05:00.623]                           }
[18:05:00.623]                           base::stop(msg)
[18:05:00.623]                         }
[18:05:00.623]                       })
[18:05:00.623]                     }
[18:05:00.623]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:00.623]                     base::options(mc.cores = 1L)
[18:05:00.623]                   }
[18:05:00.623]                   ...future.strategy.old <- future::plan("list")
[18:05:00.623]                   options(future.plan = NULL)
[18:05:00.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:00.623]                 }
[18:05:00.623]                 ...future.workdir <- getwd()
[18:05:00.623]             }
[18:05:00.623]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:00.623]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:00.623]         }
[18:05:00.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:00.623]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:00.623]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:00.623]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:00.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:00.623]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:00.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:00.623]             base::names(...future.oldOptions))
[18:05:00.623]     }
[18:05:00.623]     if (FALSE) {
[18:05:00.623]     }
[18:05:00.623]     else {
[18:05:00.623]         if (TRUE) {
[18:05:00.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:00.623]                 open = "w")
[18:05:00.623]         }
[18:05:00.623]         else {
[18:05:00.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:00.623]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:00.623]         }
[18:05:00.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:00.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:00.623]             base::sink(type = "output", split = FALSE)
[18:05:00.623]             base::close(...future.stdout)
[18:05:00.623]         }, add = TRUE)
[18:05:00.623]     }
[18:05:00.623]     ...future.frame <- base::sys.nframe()
[18:05:00.623]     ...future.conditions <- base::list()
[18:05:00.623]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:00.623]     if (FALSE) {
[18:05:00.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:00.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:00.623]     }
[18:05:00.623]     ...future.result <- base::tryCatch({
[18:05:00.623]         base::withCallingHandlers({
[18:05:00.623]             ...future.value <- base::withVisible(base::local({
[18:05:00.623]                 ...future.makeSendCondition <- base::local({
[18:05:00.623]                   sendCondition <- NULL
[18:05:00.623]                   function(frame = 1L) {
[18:05:00.623]                     if (is.function(sendCondition)) 
[18:05:00.623]                       return(sendCondition)
[18:05:00.623]                     ns <- getNamespace("parallel")
[18:05:00.623]                     if (exists("sendData", mode = "function", 
[18:05:00.623]                       envir = ns)) {
[18:05:00.623]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:00.623]                         envir = ns)
[18:05:00.623]                       envir <- sys.frame(frame)
[18:05:00.623]                       master <- NULL
[18:05:00.623]                       while (!identical(envir, .GlobalEnv) && 
[18:05:00.623]                         !identical(envir, emptyenv())) {
[18:05:00.623]                         if (exists("master", mode = "list", envir = envir, 
[18:05:00.623]                           inherits = FALSE)) {
[18:05:00.623]                           master <- get("master", mode = "list", 
[18:05:00.623]                             envir = envir, inherits = FALSE)
[18:05:00.623]                           if (inherits(master, c("SOCKnode", 
[18:05:00.623]                             "SOCK0node"))) {
[18:05:00.623]                             sendCondition <<- function(cond) {
[18:05:00.623]                               data <- list(type = "VALUE", value = cond, 
[18:05:00.623]                                 success = TRUE)
[18:05:00.623]                               parallel_sendData(master, data)
[18:05:00.623]                             }
[18:05:00.623]                             return(sendCondition)
[18:05:00.623]                           }
[18:05:00.623]                         }
[18:05:00.623]                         frame <- frame + 1L
[18:05:00.623]                         envir <- sys.frame(frame)
[18:05:00.623]                       }
[18:05:00.623]                     }
[18:05:00.623]                     sendCondition <<- function(cond) NULL
[18:05:00.623]                   }
[18:05:00.623]                 })
[18:05:00.623]                 withCallingHandlers({
[18:05:00.623]                   {
[18:05:00.623]                     b <- a * ii
[18:05:00.623]                     a <- 0
[18:05:00.623]                     b
[18:05:00.623]                   }
[18:05:00.623]                 }, immediateCondition = function(cond) {
[18:05:00.623]                   sendCondition <- ...future.makeSendCondition()
[18:05:00.623]                   sendCondition(cond)
[18:05:00.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.623]                   {
[18:05:00.623]                     inherits <- base::inherits
[18:05:00.623]                     invokeRestart <- base::invokeRestart
[18:05:00.623]                     is.null <- base::is.null
[18:05:00.623]                     muffled <- FALSE
[18:05:00.623]                     if (inherits(cond, "message")) {
[18:05:00.623]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:00.623]                       if (muffled) 
[18:05:00.623]                         invokeRestart("muffleMessage")
[18:05:00.623]                     }
[18:05:00.623]                     else if (inherits(cond, "warning")) {
[18:05:00.623]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:00.623]                       if (muffled) 
[18:05:00.623]                         invokeRestart("muffleWarning")
[18:05:00.623]                     }
[18:05:00.623]                     else if (inherits(cond, "condition")) {
[18:05:00.623]                       if (!is.null(pattern)) {
[18:05:00.623]                         computeRestarts <- base::computeRestarts
[18:05:00.623]                         grepl <- base::grepl
[18:05:00.623]                         restarts <- computeRestarts(cond)
[18:05:00.623]                         for (restart in restarts) {
[18:05:00.623]                           name <- restart$name
[18:05:00.623]                           if (is.null(name)) 
[18:05:00.623]                             next
[18:05:00.623]                           if (!grepl(pattern, name)) 
[18:05:00.623]                             next
[18:05:00.623]                           invokeRestart(restart)
[18:05:00.623]                           muffled <- TRUE
[18:05:00.623]                           break
[18:05:00.623]                         }
[18:05:00.623]                       }
[18:05:00.623]                     }
[18:05:00.623]                     invisible(muffled)
[18:05:00.623]                   }
[18:05:00.623]                   muffleCondition(cond)
[18:05:00.623]                 })
[18:05:00.623]             }))
[18:05:00.623]             future::FutureResult(value = ...future.value$value, 
[18:05:00.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.623]                   ...future.rng), globalenv = if (FALSE) 
[18:05:00.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:00.623]                     ...future.globalenv.names))
[18:05:00.623]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:00.623]         }, condition = base::local({
[18:05:00.623]             c <- base::c
[18:05:00.623]             inherits <- base::inherits
[18:05:00.623]             invokeRestart <- base::invokeRestart
[18:05:00.623]             length <- base::length
[18:05:00.623]             list <- base::list
[18:05:00.623]             seq.int <- base::seq.int
[18:05:00.623]             signalCondition <- base::signalCondition
[18:05:00.623]             sys.calls <- base::sys.calls
[18:05:00.623]             `[[` <- base::`[[`
[18:05:00.623]             `+` <- base::`+`
[18:05:00.623]             `<<-` <- base::`<<-`
[18:05:00.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:00.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:00.623]                   3L)]
[18:05:00.623]             }
[18:05:00.623]             function(cond) {
[18:05:00.623]                 is_error <- inherits(cond, "error")
[18:05:00.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:00.623]                   NULL)
[18:05:00.623]                 if (is_error) {
[18:05:00.623]                   sessionInformation <- function() {
[18:05:00.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:00.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:00.623]                       search = base::search(), system = base::Sys.info())
[18:05:00.623]                   }
[18:05:00.623]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:00.623]                     cond$call), session = sessionInformation(), 
[18:05:00.623]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:00.623]                   signalCondition(cond)
[18:05:00.623]                 }
[18:05:00.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:00.623]                 "immediateCondition"))) {
[18:05:00.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:00.623]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:00.623]                   if (TRUE && !signal) {
[18:05:00.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.623]                     {
[18:05:00.623]                       inherits <- base::inherits
[18:05:00.623]                       invokeRestart <- base::invokeRestart
[18:05:00.623]                       is.null <- base::is.null
[18:05:00.623]                       muffled <- FALSE
[18:05:00.623]                       if (inherits(cond, "message")) {
[18:05:00.623]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.623]                         if (muffled) 
[18:05:00.623]                           invokeRestart("muffleMessage")
[18:05:00.623]                       }
[18:05:00.623]                       else if (inherits(cond, "warning")) {
[18:05:00.623]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.623]                         if (muffled) 
[18:05:00.623]                           invokeRestart("muffleWarning")
[18:05:00.623]                       }
[18:05:00.623]                       else if (inherits(cond, "condition")) {
[18:05:00.623]                         if (!is.null(pattern)) {
[18:05:00.623]                           computeRestarts <- base::computeRestarts
[18:05:00.623]                           grepl <- base::grepl
[18:05:00.623]                           restarts <- computeRestarts(cond)
[18:05:00.623]                           for (restart in restarts) {
[18:05:00.623]                             name <- restart$name
[18:05:00.623]                             if (is.null(name)) 
[18:05:00.623]                               next
[18:05:00.623]                             if (!grepl(pattern, name)) 
[18:05:00.623]                               next
[18:05:00.623]                             invokeRestart(restart)
[18:05:00.623]                             muffled <- TRUE
[18:05:00.623]                             break
[18:05:00.623]                           }
[18:05:00.623]                         }
[18:05:00.623]                       }
[18:05:00.623]                       invisible(muffled)
[18:05:00.623]                     }
[18:05:00.623]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.623]                   }
[18:05:00.623]                 }
[18:05:00.623]                 else {
[18:05:00.623]                   if (TRUE) {
[18:05:00.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.623]                     {
[18:05:00.623]                       inherits <- base::inherits
[18:05:00.623]                       invokeRestart <- base::invokeRestart
[18:05:00.623]                       is.null <- base::is.null
[18:05:00.623]                       muffled <- FALSE
[18:05:00.623]                       if (inherits(cond, "message")) {
[18:05:00.623]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.623]                         if (muffled) 
[18:05:00.623]                           invokeRestart("muffleMessage")
[18:05:00.623]                       }
[18:05:00.623]                       else if (inherits(cond, "warning")) {
[18:05:00.623]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.623]                         if (muffled) 
[18:05:00.623]                           invokeRestart("muffleWarning")
[18:05:00.623]                       }
[18:05:00.623]                       else if (inherits(cond, "condition")) {
[18:05:00.623]                         if (!is.null(pattern)) {
[18:05:00.623]                           computeRestarts <- base::computeRestarts
[18:05:00.623]                           grepl <- base::grepl
[18:05:00.623]                           restarts <- computeRestarts(cond)
[18:05:00.623]                           for (restart in restarts) {
[18:05:00.623]                             name <- restart$name
[18:05:00.623]                             if (is.null(name)) 
[18:05:00.623]                               next
[18:05:00.623]                             if (!grepl(pattern, name)) 
[18:05:00.623]                               next
[18:05:00.623]                             invokeRestart(restart)
[18:05:00.623]                             muffled <- TRUE
[18:05:00.623]                             break
[18:05:00.623]                           }
[18:05:00.623]                         }
[18:05:00.623]                       }
[18:05:00.623]                       invisible(muffled)
[18:05:00.623]                     }
[18:05:00.623]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.623]                   }
[18:05:00.623]                 }
[18:05:00.623]             }
[18:05:00.623]         }))
[18:05:00.623]     }, error = function(ex) {
[18:05:00.623]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:00.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.623]                 ...future.rng), started = ...future.startTime, 
[18:05:00.623]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:00.623]             version = "1.8"), class = "FutureResult")
[18:05:00.623]     }, finally = {
[18:05:00.623]         if (!identical(...future.workdir, getwd())) 
[18:05:00.623]             setwd(...future.workdir)
[18:05:00.623]         {
[18:05:00.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:00.623]                 ...future.oldOptions$nwarnings <- NULL
[18:05:00.623]             }
[18:05:00.623]             base::options(...future.oldOptions)
[18:05:00.623]             if (.Platform$OS.type == "windows") {
[18:05:00.623]                 old_names <- names(...future.oldEnvVars)
[18:05:00.623]                 envs <- base::Sys.getenv()
[18:05:00.623]                 names <- names(envs)
[18:05:00.623]                 common <- intersect(names, old_names)
[18:05:00.623]                 added <- setdiff(names, old_names)
[18:05:00.623]                 removed <- setdiff(old_names, names)
[18:05:00.623]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:00.623]                   envs[common]]
[18:05:00.623]                 NAMES <- toupper(changed)
[18:05:00.623]                 args <- list()
[18:05:00.623]                 for (kk in seq_along(NAMES)) {
[18:05:00.623]                   name <- changed[[kk]]
[18:05:00.623]                   NAME <- NAMES[[kk]]
[18:05:00.623]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.623]                     next
[18:05:00.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.623]                 }
[18:05:00.623]                 NAMES <- toupper(added)
[18:05:00.623]                 for (kk in seq_along(NAMES)) {
[18:05:00.623]                   name <- added[[kk]]
[18:05:00.623]                   NAME <- NAMES[[kk]]
[18:05:00.623]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.623]                     next
[18:05:00.623]                   args[[name]] <- ""
[18:05:00.623]                 }
[18:05:00.623]                 NAMES <- toupper(removed)
[18:05:00.623]                 for (kk in seq_along(NAMES)) {
[18:05:00.623]                   name <- removed[[kk]]
[18:05:00.623]                   NAME <- NAMES[[kk]]
[18:05:00.623]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.623]                     next
[18:05:00.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.623]                 }
[18:05:00.623]                 if (length(args) > 0) 
[18:05:00.623]                   base::do.call(base::Sys.setenv, args = args)
[18:05:00.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:00.623]             }
[18:05:00.623]             else {
[18:05:00.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:00.623]             }
[18:05:00.623]             {
[18:05:00.623]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:00.623]                   0L) {
[18:05:00.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:00.623]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:00.623]                   base::options(opts)
[18:05:00.623]                 }
[18:05:00.623]                 {
[18:05:00.623]                   {
[18:05:00.623]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:00.623]                     NULL
[18:05:00.623]                   }
[18:05:00.623]                   options(future.plan = NULL)
[18:05:00.623]                   if (is.na(NA_character_)) 
[18:05:00.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:00.623]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:00.623]                     .init = FALSE)
[18:05:00.623]                 }
[18:05:00.623]             }
[18:05:00.623]         }
[18:05:00.623]     })
[18:05:00.623]     if (TRUE) {
[18:05:00.623]         base::sink(type = "output", split = FALSE)
[18:05:00.623]         if (TRUE) {
[18:05:00.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:00.623]         }
[18:05:00.623]         else {
[18:05:00.623]             ...future.result["stdout"] <- base::list(NULL)
[18:05:00.623]         }
[18:05:00.623]         base::close(...future.stdout)
[18:05:00.623]         ...future.stdout <- NULL
[18:05:00.623]     }
[18:05:00.623]     ...future.result$conditions <- ...future.conditions
[18:05:00.623]     ...future.result$finished <- base::Sys.time()
[18:05:00.623]     ...future.result
[18:05:00.623] }
[18:05:00.627] Poll #1 (0): usedNodes() = 2, workers = 2
[18:05:00.639] receiveMessageFromWorker() for ClusterFuture ...
[18:05:00.640] - Validating connection of MultisessionFuture
[18:05:00.640] - received message: FutureResult
[18:05:00.641] - Received FutureResult
[18:05:00.641] - Erased future from FutureRegistry
[18:05:00.641] result() for ClusterFuture ...
[18:05:00.641] - result already collected: FutureResult
[18:05:00.641] result() for ClusterFuture ... done
[18:05:00.642] signalConditions() ...
[18:05:00.642]  - include = ‘immediateCondition’
[18:05:00.642]  - exclude = 
[18:05:00.642]  - resignal = FALSE
[18:05:00.642]  - Number of conditions: 1
[18:05:00.643] signalConditions() ... done
[18:05:00.643] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:00.643] result() for ClusterFuture ...
[18:05:00.643] - result already collected: FutureResult
[18:05:00.643] result() for ClusterFuture ... done
[18:05:00.644] result() for ClusterFuture ...
[18:05:00.644] - result already collected: FutureResult
[18:05:00.644] result() for ClusterFuture ... done
[18:05:00.644] signalConditions() ...
[18:05:00.644]  - include = ‘immediateCondition’
[18:05:00.644]  - exclude = 
[18:05:00.645]  - resignal = FALSE
[18:05:00.645]  - Number of conditions: 1
[18:05:00.645] signalConditions() ... done
[18:05:00.646] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:05:00.647] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[18:05:00.647] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[18:05:00.648] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:05:00.648] MultisessionFuture started
[18:05:00.649] - Launch lazy future ... done
[18:05:00.649] run() for ‘MultisessionFuture’ ... done
[18:05:00.649] result() for ClusterFuture ...
[18:05:00.650] - result already collected: FutureResult
[18:05:00.650] result() for ClusterFuture ... done
[18:05:00.651] result() for ClusterFuture ...
[18:05:00.651] - result already collected: FutureResult
[18:05:00.651] result() for ClusterFuture ... done
[18:05:00.651] signalConditions() ...
[18:05:00.651]  - include = ‘immediateCondition’
[18:05:00.652]  - exclude = 
[18:05:00.652]  - resignal = FALSE
[18:05:00.652]  - Number of conditions: 1
[18:05:00.652] signalConditions() ... done
[18:05:00.652] Future state: ‘finished’
[18:05:00.653] result() for ClusterFuture ...
[18:05:00.653] - result already collected: FutureResult
[18:05:00.653] result() for ClusterFuture ... done
[18:05:00.653] signalConditions() ...
[18:05:00.653]  - include = ‘condition’
[18:05:00.654]  - exclude = ‘immediateCondition’
[18:05:00.654]  - resignal = TRUE
[18:05:00.654]  - Number of conditions: 1
[18:05:00.654]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:05:00.654] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.8.0-48-generic" "#48-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 14:04:52 UTC 2024" "99adafdbb12a" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-21 18:05:00"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.685] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.685] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.688] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.688] Searching for globals ... DONE
[18:05:00.688] Resolving globals: TRUE
[18:05:00.689] Resolving any globals that are futures ...
[18:05:00.690] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.690] Resolving any globals that are futures ... DONE
[18:05:00.691] Resolving futures part of globals (recursively) ...
[18:05:00.691] resolve() on list ...
[18:05:00.691]  recursive: 99
[18:05:00.692]  length: 1
[18:05:00.692]  elements: ‘ii’
[18:05:00.692]  length: 0 (resolved future 1)
[18:05:00.692] resolve() on list ... DONE
[18:05:00.692] - globals: [1] ‘ii’
[18:05:00.693] Resolving futures part of globals (recursively) ... DONE
[18:05:00.693] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:00.694] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:00.694] - globals: [1] ‘ii’
[18:05:00.694] 
[18:05:00.694] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.695] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.696] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.698] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.699] Searching for globals ... DONE
[18:05:00.699] Resolving globals: TRUE
[18:05:00.699] Resolving any globals that are futures ...
[18:05:00.699] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.700] Resolving any globals that are futures ... DONE
[18:05:00.700] Resolving futures part of globals (recursively) ...
[18:05:00.701] resolve() on list ...
[18:05:00.701]  recursive: 99
[18:05:00.701]  length: 1
[18:05:00.701]  elements: ‘ii’
[18:05:00.701]  length: 0 (resolved future 1)
[18:05:00.702] resolve() on list ... DONE
[18:05:00.702] - globals: [1] ‘ii’
[18:05:00.702] Resolving futures part of globals (recursively) ... DONE
[18:05:00.702] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:00.703] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:00.703] - globals: [1] ‘ii’
[18:05:00.703] 
[18:05:00.704] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.705] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.705] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.708] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.708] Searching for globals ... DONE
[18:05:00.708] Resolving globals: TRUE
[18:05:00.708] Resolving any globals that are futures ...
[18:05:00.709] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[18:05:00.709] Resolving any globals that are futures ... DONE
[18:05:00.709] Resolving futures part of globals (recursively) ...
[18:05:00.710] resolve() on list ...
[18:05:00.710]  recursive: 99
[18:05:00.710]  length: 1
[18:05:00.710]  elements: ‘ii’
[18:05:00.711]  length: 0 (resolved future 1)
[18:05:00.711] resolve() on list ... DONE
[18:05:00.711] - globals: [1] ‘ii’
[18:05:00.711] Resolving futures part of globals (recursively) ... DONE
[18:05:00.712] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:00.712] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[18:05:00.712] - globals: [1] ‘ii’
[18:05:00.713] 
[18:05:00.713] getGlobalsAndPackages() ... DONE
[18:05:00.714] run() for ‘Future’ ...
[18:05:00.714] - state: ‘created’
[18:05:00.714] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:00.737] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:00.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:00.738]   - Field: ‘node’
[18:05:00.738]   - Field: ‘label’
[18:05:00.738]   - Field: ‘local’
[18:05:00.738]   - Field: ‘owner’
[18:05:00.739]   - Field: ‘envir’
[18:05:00.739]   - Field: ‘workers’
[18:05:00.739]   - Field: ‘packages’
[18:05:00.739]   - Field: ‘gc’
[18:05:00.739]   - Field: ‘conditions’
[18:05:00.740]   - Field: ‘persistent’
[18:05:00.740]   - Field: ‘expr’
[18:05:00.740]   - Field: ‘uuid’
[18:05:00.740]   - Field: ‘seed’
[18:05:00.740]   - Field: ‘version’
[18:05:00.741]   - Field: ‘result’
[18:05:00.741]   - Field: ‘asynchronous’
[18:05:00.741]   - Field: ‘calls’
[18:05:00.741]   - Field: ‘globals’
[18:05:00.741]   - Field: ‘stdout’
[18:05:00.742]   - Field: ‘earlySignal’
[18:05:00.742]   - Field: ‘lazy’
[18:05:00.742]   - Field: ‘state’
[18:05:00.742] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:00.742] - Launch lazy future ...
[18:05:00.743] Packages needed by the future expression (n = 0): <none>
[18:05:00.743] Packages needed by future strategies (n = 0): <none>
[18:05:00.744] {
[18:05:00.744]     {
[18:05:00.744]         {
[18:05:00.744]             ...future.startTime <- base::Sys.time()
[18:05:00.744]             {
[18:05:00.744]                 {
[18:05:00.744]                   {
[18:05:00.744]                     {
[18:05:00.744]                       base::local({
[18:05:00.744]                         has_future <- base::requireNamespace("future", 
[18:05:00.744]                           quietly = TRUE)
[18:05:00.744]                         if (has_future) {
[18:05:00.744]                           ns <- base::getNamespace("future")
[18:05:00.744]                           version <- ns[[".package"]][["version"]]
[18:05:00.744]                           if (is.null(version)) 
[18:05:00.744]                             version <- utils::packageVersion("future")
[18:05:00.744]                         }
[18:05:00.744]                         else {
[18:05:00.744]                           version <- NULL
[18:05:00.744]                         }
[18:05:00.744]                         if (!has_future || version < "1.8.0") {
[18:05:00.744]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:00.744]                             "", base::R.version$version.string), 
[18:05:00.744]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:00.744]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:00.744]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:00.744]                               "release", "version")], collapse = " "), 
[18:05:00.744]                             hostname = base::Sys.info()[["nodename"]])
[18:05:00.744]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:00.744]                             info)
[18:05:00.744]                           info <- base::paste(info, collapse = "; ")
[18:05:00.744]                           if (!has_future) {
[18:05:00.744]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:00.744]                               info)
[18:05:00.744]                           }
[18:05:00.744]                           else {
[18:05:00.744]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:00.744]                               info, version)
[18:05:00.744]                           }
[18:05:00.744]                           base::stop(msg)
[18:05:00.744]                         }
[18:05:00.744]                       })
[18:05:00.744]                     }
[18:05:00.744]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:00.744]                     base::options(mc.cores = 1L)
[18:05:00.744]                   }
[18:05:00.744]                   ...future.strategy.old <- future::plan("list")
[18:05:00.744]                   options(future.plan = NULL)
[18:05:00.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:00.744]                 }
[18:05:00.744]                 ...future.workdir <- getwd()
[18:05:00.744]             }
[18:05:00.744]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:00.744]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:00.744]         }
[18:05:00.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:00.744]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:00.744]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:00.744]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:00.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:00.744]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:00.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:00.744]             base::names(...future.oldOptions))
[18:05:00.744]     }
[18:05:00.744]     if (FALSE) {
[18:05:00.744]     }
[18:05:00.744]     else {
[18:05:00.744]         if (TRUE) {
[18:05:00.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:00.744]                 open = "w")
[18:05:00.744]         }
[18:05:00.744]         else {
[18:05:00.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:00.744]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:00.744]         }
[18:05:00.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:00.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:00.744]             base::sink(type = "output", split = FALSE)
[18:05:00.744]             base::close(...future.stdout)
[18:05:00.744]         }, add = TRUE)
[18:05:00.744]     }
[18:05:00.744]     ...future.frame <- base::sys.nframe()
[18:05:00.744]     ...future.conditions <- base::list()
[18:05:00.744]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:00.744]     if (FALSE) {
[18:05:00.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:00.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:00.744]     }
[18:05:00.744]     ...future.result <- base::tryCatch({
[18:05:00.744]         base::withCallingHandlers({
[18:05:00.744]             ...future.value <- base::withVisible(base::local({
[18:05:00.744]                 ...future.makeSendCondition <- base::local({
[18:05:00.744]                   sendCondition <- NULL
[18:05:00.744]                   function(frame = 1L) {
[18:05:00.744]                     if (is.function(sendCondition)) 
[18:05:00.744]                       return(sendCondition)
[18:05:00.744]                     ns <- getNamespace("parallel")
[18:05:00.744]                     if (exists("sendData", mode = "function", 
[18:05:00.744]                       envir = ns)) {
[18:05:00.744]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:00.744]                         envir = ns)
[18:05:00.744]                       envir <- sys.frame(frame)
[18:05:00.744]                       master <- NULL
[18:05:00.744]                       while (!identical(envir, .GlobalEnv) && 
[18:05:00.744]                         !identical(envir, emptyenv())) {
[18:05:00.744]                         if (exists("master", mode = "list", envir = envir, 
[18:05:00.744]                           inherits = FALSE)) {
[18:05:00.744]                           master <- get("master", mode = "list", 
[18:05:00.744]                             envir = envir, inherits = FALSE)
[18:05:00.744]                           if (inherits(master, c("SOCKnode", 
[18:05:00.744]                             "SOCK0node"))) {
[18:05:00.744]                             sendCondition <<- function(cond) {
[18:05:00.744]                               data <- list(type = "VALUE", value = cond, 
[18:05:00.744]                                 success = TRUE)
[18:05:00.744]                               parallel_sendData(master, data)
[18:05:00.744]                             }
[18:05:00.744]                             return(sendCondition)
[18:05:00.744]                           }
[18:05:00.744]                         }
[18:05:00.744]                         frame <- frame + 1L
[18:05:00.744]                         envir <- sys.frame(frame)
[18:05:00.744]                       }
[18:05:00.744]                     }
[18:05:00.744]                     sendCondition <<- function(cond) NULL
[18:05:00.744]                   }
[18:05:00.744]                 })
[18:05:00.744]                 withCallingHandlers({
[18:05:00.744]                   {
[18:05:00.744]                     b <- a * ii
[18:05:00.744]                     a <- 0
[18:05:00.744]                     b
[18:05:00.744]                   }
[18:05:00.744]                 }, immediateCondition = function(cond) {
[18:05:00.744]                   sendCondition <- ...future.makeSendCondition()
[18:05:00.744]                   sendCondition(cond)
[18:05:00.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.744]                   {
[18:05:00.744]                     inherits <- base::inherits
[18:05:00.744]                     invokeRestart <- base::invokeRestart
[18:05:00.744]                     is.null <- base::is.null
[18:05:00.744]                     muffled <- FALSE
[18:05:00.744]                     if (inherits(cond, "message")) {
[18:05:00.744]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:00.744]                       if (muffled) 
[18:05:00.744]                         invokeRestart("muffleMessage")
[18:05:00.744]                     }
[18:05:00.744]                     else if (inherits(cond, "warning")) {
[18:05:00.744]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:00.744]                       if (muffled) 
[18:05:00.744]                         invokeRestart("muffleWarning")
[18:05:00.744]                     }
[18:05:00.744]                     else if (inherits(cond, "condition")) {
[18:05:00.744]                       if (!is.null(pattern)) {
[18:05:00.744]                         computeRestarts <- base::computeRestarts
[18:05:00.744]                         grepl <- base::grepl
[18:05:00.744]                         restarts <- computeRestarts(cond)
[18:05:00.744]                         for (restart in restarts) {
[18:05:00.744]                           name <- restart$name
[18:05:00.744]                           if (is.null(name)) 
[18:05:00.744]                             next
[18:05:00.744]                           if (!grepl(pattern, name)) 
[18:05:00.744]                             next
[18:05:00.744]                           invokeRestart(restart)
[18:05:00.744]                           muffled <- TRUE
[18:05:00.744]                           break
[18:05:00.744]                         }
[18:05:00.744]                       }
[18:05:00.744]                     }
[18:05:00.744]                     invisible(muffled)
[18:05:00.744]                   }
[18:05:00.744]                   muffleCondition(cond)
[18:05:00.744]                 })
[18:05:00.744]             }))
[18:05:00.744]             future::FutureResult(value = ...future.value$value, 
[18:05:00.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.744]                   ...future.rng), globalenv = if (FALSE) 
[18:05:00.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:00.744]                     ...future.globalenv.names))
[18:05:00.744]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:00.744]         }, condition = base::local({
[18:05:00.744]             c <- base::c
[18:05:00.744]             inherits <- base::inherits
[18:05:00.744]             invokeRestart <- base::invokeRestart
[18:05:00.744]             length <- base::length
[18:05:00.744]             list <- base::list
[18:05:00.744]             seq.int <- base::seq.int
[18:05:00.744]             signalCondition <- base::signalCondition
[18:05:00.744]             sys.calls <- base::sys.calls
[18:05:00.744]             `[[` <- base::`[[`
[18:05:00.744]             `+` <- base::`+`
[18:05:00.744]             `<<-` <- base::`<<-`
[18:05:00.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:00.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:00.744]                   3L)]
[18:05:00.744]             }
[18:05:00.744]             function(cond) {
[18:05:00.744]                 is_error <- inherits(cond, "error")
[18:05:00.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:00.744]                   NULL)
[18:05:00.744]                 if (is_error) {
[18:05:00.744]                   sessionInformation <- function() {
[18:05:00.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:00.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:00.744]                       search = base::search(), system = base::Sys.info())
[18:05:00.744]                   }
[18:05:00.744]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:00.744]                     cond$call), session = sessionInformation(), 
[18:05:00.744]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:00.744]                   signalCondition(cond)
[18:05:00.744]                 }
[18:05:00.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:00.744]                 "immediateCondition"))) {
[18:05:00.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:00.744]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:00.744]                   if (TRUE && !signal) {
[18:05:00.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.744]                     {
[18:05:00.744]                       inherits <- base::inherits
[18:05:00.744]                       invokeRestart <- base::invokeRestart
[18:05:00.744]                       is.null <- base::is.null
[18:05:00.744]                       muffled <- FALSE
[18:05:00.744]                       if (inherits(cond, "message")) {
[18:05:00.744]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.744]                         if (muffled) 
[18:05:00.744]                           invokeRestart("muffleMessage")
[18:05:00.744]                       }
[18:05:00.744]                       else if (inherits(cond, "warning")) {
[18:05:00.744]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.744]                         if (muffled) 
[18:05:00.744]                           invokeRestart("muffleWarning")
[18:05:00.744]                       }
[18:05:00.744]                       else if (inherits(cond, "condition")) {
[18:05:00.744]                         if (!is.null(pattern)) {
[18:05:00.744]                           computeRestarts <- base::computeRestarts
[18:05:00.744]                           grepl <- base::grepl
[18:05:00.744]                           restarts <- computeRestarts(cond)
[18:05:00.744]                           for (restart in restarts) {
[18:05:00.744]                             name <- restart$name
[18:05:00.744]                             if (is.null(name)) 
[18:05:00.744]                               next
[18:05:00.744]                             if (!grepl(pattern, name)) 
[18:05:00.744]                               next
[18:05:00.744]                             invokeRestart(restart)
[18:05:00.744]                             muffled <- TRUE
[18:05:00.744]                             break
[18:05:00.744]                           }
[18:05:00.744]                         }
[18:05:00.744]                       }
[18:05:00.744]                       invisible(muffled)
[18:05:00.744]                     }
[18:05:00.744]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.744]                   }
[18:05:00.744]                 }
[18:05:00.744]                 else {
[18:05:00.744]                   if (TRUE) {
[18:05:00.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.744]                     {
[18:05:00.744]                       inherits <- base::inherits
[18:05:00.744]                       invokeRestart <- base::invokeRestart
[18:05:00.744]                       is.null <- base::is.null
[18:05:00.744]                       muffled <- FALSE
[18:05:00.744]                       if (inherits(cond, "message")) {
[18:05:00.744]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.744]                         if (muffled) 
[18:05:00.744]                           invokeRestart("muffleMessage")
[18:05:00.744]                       }
[18:05:00.744]                       else if (inherits(cond, "warning")) {
[18:05:00.744]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.744]                         if (muffled) 
[18:05:00.744]                           invokeRestart("muffleWarning")
[18:05:00.744]                       }
[18:05:00.744]                       else if (inherits(cond, "condition")) {
[18:05:00.744]                         if (!is.null(pattern)) {
[18:05:00.744]                           computeRestarts <- base::computeRestarts
[18:05:00.744]                           grepl <- base::grepl
[18:05:00.744]                           restarts <- computeRestarts(cond)
[18:05:00.744]                           for (restart in restarts) {
[18:05:00.744]                             name <- restart$name
[18:05:00.744]                             if (is.null(name)) 
[18:05:00.744]                               next
[18:05:00.744]                             if (!grepl(pattern, name)) 
[18:05:00.744]                               next
[18:05:00.744]                             invokeRestart(restart)
[18:05:00.744]                             muffled <- TRUE
[18:05:00.744]                             break
[18:05:00.744]                           }
[18:05:00.744]                         }
[18:05:00.744]                       }
[18:05:00.744]                       invisible(muffled)
[18:05:00.744]                     }
[18:05:00.744]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.744]                   }
[18:05:00.744]                 }
[18:05:00.744]             }
[18:05:00.744]         }))
[18:05:00.744]     }, error = function(ex) {
[18:05:00.744]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:00.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.744]                 ...future.rng), started = ...future.startTime, 
[18:05:00.744]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:00.744]             version = "1.8"), class = "FutureResult")
[18:05:00.744]     }, finally = {
[18:05:00.744]         if (!identical(...future.workdir, getwd())) 
[18:05:00.744]             setwd(...future.workdir)
[18:05:00.744]         {
[18:05:00.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:00.744]                 ...future.oldOptions$nwarnings <- NULL
[18:05:00.744]             }
[18:05:00.744]             base::options(...future.oldOptions)
[18:05:00.744]             if (.Platform$OS.type == "windows") {
[18:05:00.744]                 old_names <- names(...future.oldEnvVars)
[18:05:00.744]                 envs <- base::Sys.getenv()
[18:05:00.744]                 names <- names(envs)
[18:05:00.744]                 common <- intersect(names, old_names)
[18:05:00.744]                 added <- setdiff(names, old_names)
[18:05:00.744]                 removed <- setdiff(old_names, names)
[18:05:00.744]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:00.744]                   envs[common]]
[18:05:00.744]                 NAMES <- toupper(changed)
[18:05:00.744]                 args <- list()
[18:05:00.744]                 for (kk in seq_along(NAMES)) {
[18:05:00.744]                   name <- changed[[kk]]
[18:05:00.744]                   NAME <- NAMES[[kk]]
[18:05:00.744]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.744]                     next
[18:05:00.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.744]                 }
[18:05:00.744]                 NAMES <- toupper(added)
[18:05:00.744]                 for (kk in seq_along(NAMES)) {
[18:05:00.744]                   name <- added[[kk]]
[18:05:00.744]                   NAME <- NAMES[[kk]]
[18:05:00.744]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.744]                     next
[18:05:00.744]                   args[[name]] <- ""
[18:05:00.744]                 }
[18:05:00.744]                 NAMES <- toupper(removed)
[18:05:00.744]                 for (kk in seq_along(NAMES)) {
[18:05:00.744]                   name <- removed[[kk]]
[18:05:00.744]                   NAME <- NAMES[[kk]]
[18:05:00.744]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.744]                     next
[18:05:00.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.744]                 }
[18:05:00.744]                 if (length(args) > 0) 
[18:05:00.744]                   base::do.call(base::Sys.setenv, args = args)
[18:05:00.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:00.744]             }
[18:05:00.744]             else {
[18:05:00.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:00.744]             }
[18:05:00.744]             {
[18:05:00.744]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:00.744]                   0L) {
[18:05:00.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:00.744]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:00.744]                   base::options(opts)
[18:05:00.744]                 }
[18:05:00.744]                 {
[18:05:00.744]                   {
[18:05:00.744]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:00.744]                     NULL
[18:05:00.744]                   }
[18:05:00.744]                   options(future.plan = NULL)
[18:05:00.744]                   if (is.na(NA_character_)) 
[18:05:00.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:00.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:00.744]                     .init = FALSE)
[18:05:00.744]                 }
[18:05:00.744]             }
[18:05:00.744]         }
[18:05:00.744]     })
[18:05:00.744]     if (TRUE) {
[18:05:00.744]         base::sink(type = "output", split = FALSE)
[18:05:00.744]         if (TRUE) {
[18:05:00.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:00.744]         }
[18:05:00.744]         else {
[18:05:00.744]             ...future.result["stdout"] <- base::list(NULL)
[18:05:00.744]         }
[18:05:00.744]         base::close(...future.stdout)
[18:05:00.744]         ...future.stdout <- NULL
[18:05:00.744]     }
[18:05:00.744]     ...future.result$conditions <- ...future.conditions
[18:05:00.744]     ...future.result$finished <- base::Sys.time()
[18:05:00.744]     ...future.result
[18:05:00.744] }
[18:05:00.748] Poll #1 (0): usedNodes() = 2, workers = 2
[18:05:00.760] receiveMessageFromWorker() for ClusterFuture ...
[18:05:00.760] - Validating connection of MultisessionFuture
[18:05:00.761] - received message: FutureResult
[18:05:00.761] - Received FutureResult
[18:05:00.761] - Erased future from FutureRegistry
[18:05:00.761] result() for ClusterFuture ...
[18:05:00.762] - result already collected: FutureResult
[18:05:00.762] result() for ClusterFuture ... done
[18:05:00.762] signalConditions() ...
[18:05:00.762]  - include = ‘immediateCondition’
[18:05:00.762]  - exclude = 
[18:05:00.762]  - resignal = FALSE
[18:05:00.763]  - Number of conditions: 1
[18:05:00.763] signalConditions() ... done
[18:05:00.763] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:00.763] result() for ClusterFuture ...
[18:05:00.763] - result already collected: FutureResult
[18:05:00.764] result() for ClusterFuture ... done
[18:05:00.764] result() for ClusterFuture ...
[18:05:00.764] - result already collected: FutureResult
[18:05:00.764] result() for ClusterFuture ... done
[18:05:00.764] signalConditions() ...
[18:05:00.764]  - include = ‘immediateCondition’
[18:05:00.765]  - exclude = 
[18:05:00.765]  - resignal = FALSE
[18:05:00.765]  - Number of conditions: 1
[18:05:00.765] signalConditions() ... done
[18:05:00.766] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[18:05:00.767] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[18:05:00.768] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[18:05:00.768] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[18:05:00.769] MultisessionFuture started
[18:05:00.769] - Launch lazy future ... done
[18:05:00.769] run() for ‘MultisessionFuture’ ... done
[18:05:00.769] result() for ClusterFuture ...
[18:05:00.770] receiveMessageFromWorker() for ClusterFuture ...
[18:05:00.770] - Validating connection of MultisessionFuture
[18:05:00.813] - received message: FutureResult
[18:05:00.814] - Received FutureResult
[18:05:00.814] - Erased future from FutureRegistry
[18:05:00.814] result() for ClusterFuture ...
[18:05:00.815] - result already collected: FutureResult
[18:05:00.815] result() for ClusterFuture ... done
[18:05:00.815] signalConditions() ...
[18:05:00.815]  - include = ‘immediateCondition’
[18:05:00.815]  - exclude = 
[18:05:00.815]  - resignal = FALSE
[18:05:00.816]  - Number of conditions: 1
[18:05:00.816] signalConditions() ... done
[18:05:00.816] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:00.816] result() for ClusterFuture ... done
[18:05:00.816] result() for ClusterFuture ...
[18:05:00.817] - result already collected: FutureResult
[18:05:00.817] result() for ClusterFuture ... done
[18:05:00.817] signalConditions() ...
[18:05:00.817]  - include = ‘immediateCondition’
[18:05:00.817]  - exclude = 
[18:05:00.817]  - resignal = FALSE
[18:05:00.818]  - Number of conditions: 1
[18:05:00.818] signalConditions() ... done
[18:05:00.818] Future state: ‘finished’
[18:05:00.818] result() for ClusterFuture ...
[18:05:00.818] - result already collected: FutureResult
[18:05:00.819] result() for ClusterFuture ... done
[18:05:00.819] signalConditions() ...
[18:05:00.819]  - include = ‘condition’
[18:05:00.819]  - exclude = ‘immediateCondition’
[18:05:00.819]  - resignal = TRUE
[18:05:00.820]  - Number of conditions: 1
[18:05:00.820]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:05:00.820] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.8.0-48-generic" "#48-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 27 14:04:52 UTC 2024" "99adafdbb12a" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-21 18:05:00"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.849] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.849] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.851] 
[18:05:00.851] Searching for globals ... DONE
[18:05:00.851] - globals: [0] <none>
[18:05:00.851] getGlobalsAndPackages() ... DONE
[18:05:00.852] run() for ‘Future’ ...
[18:05:00.852] - state: ‘created’
[18:05:00.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:00.876] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:00.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:00.876]   - Field: ‘node’
[18:05:00.877]   - Field: ‘label’
[18:05:00.877]   - Field: ‘local’
[18:05:00.877]   - Field: ‘owner’
[18:05:00.877]   - Field: ‘envir’
[18:05:00.877]   - Field: ‘workers’
[18:05:00.878]   - Field: ‘packages’
[18:05:00.878]   - Field: ‘gc’
[18:05:00.878]   - Field: ‘conditions’
[18:05:00.878]   - Field: ‘persistent’
[18:05:00.878]   - Field: ‘expr’
[18:05:00.879]   - Field: ‘uuid’
[18:05:00.879]   - Field: ‘seed’
[18:05:00.879]   - Field: ‘version’
[18:05:00.879]   - Field: ‘result’
[18:05:00.879]   - Field: ‘asynchronous’
[18:05:00.879]   - Field: ‘calls’
[18:05:00.880]   - Field: ‘globals’
[18:05:00.880]   - Field: ‘stdout’
[18:05:00.880]   - Field: ‘earlySignal’
[18:05:00.880]   - Field: ‘lazy’
[18:05:00.880]   - Field: ‘state’
[18:05:00.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:00.881] - Launch lazy future ...
[18:05:00.881] Packages needed by the future expression (n = 0): <none>
[18:05:00.882] Packages needed by future strategies (n = 0): <none>
[18:05:00.882] {
[18:05:00.882]     {
[18:05:00.882]         {
[18:05:00.882]             ...future.startTime <- base::Sys.time()
[18:05:00.882]             {
[18:05:00.882]                 {
[18:05:00.882]                   {
[18:05:00.882]                     {
[18:05:00.882]                       base::local({
[18:05:00.882]                         has_future <- base::requireNamespace("future", 
[18:05:00.882]                           quietly = TRUE)
[18:05:00.882]                         if (has_future) {
[18:05:00.882]                           ns <- base::getNamespace("future")
[18:05:00.882]                           version <- ns[[".package"]][["version"]]
[18:05:00.882]                           if (is.null(version)) 
[18:05:00.882]                             version <- utils::packageVersion("future")
[18:05:00.882]                         }
[18:05:00.882]                         else {
[18:05:00.882]                           version <- NULL
[18:05:00.882]                         }
[18:05:00.882]                         if (!has_future || version < "1.8.0") {
[18:05:00.882]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:00.882]                             "", base::R.version$version.string), 
[18:05:00.882]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:00.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:00.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:00.882]                               "release", "version")], collapse = " "), 
[18:05:00.882]                             hostname = base::Sys.info()[["nodename"]])
[18:05:00.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:00.882]                             info)
[18:05:00.882]                           info <- base::paste(info, collapse = "; ")
[18:05:00.882]                           if (!has_future) {
[18:05:00.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:00.882]                               info)
[18:05:00.882]                           }
[18:05:00.882]                           else {
[18:05:00.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:00.882]                               info, version)
[18:05:00.882]                           }
[18:05:00.882]                           base::stop(msg)
[18:05:00.882]                         }
[18:05:00.882]                       })
[18:05:00.882]                     }
[18:05:00.882]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:00.882]                     base::options(mc.cores = 1L)
[18:05:00.882]                   }
[18:05:00.882]                   ...future.strategy.old <- future::plan("list")
[18:05:00.882]                   options(future.plan = NULL)
[18:05:00.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:00.882]                 }
[18:05:00.882]                 ...future.workdir <- getwd()
[18:05:00.882]             }
[18:05:00.882]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:00.882]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:00.882]         }
[18:05:00.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:00.882]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:00.882]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:00.882]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:00.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:00.882]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:00.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:00.882]             base::names(...future.oldOptions))
[18:05:00.882]     }
[18:05:00.882]     if (FALSE) {
[18:05:00.882]     }
[18:05:00.882]     else {
[18:05:00.882]         if (TRUE) {
[18:05:00.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:00.882]                 open = "w")
[18:05:00.882]         }
[18:05:00.882]         else {
[18:05:00.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:00.882]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:00.882]         }
[18:05:00.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:00.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:00.882]             base::sink(type = "output", split = FALSE)
[18:05:00.882]             base::close(...future.stdout)
[18:05:00.882]         }, add = TRUE)
[18:05:00.882]     }
[18:05:00.882]     ...future.frame <- base::sys.nframe()
[18:05:00.882]     ...future.conditions <- base::list()
[18:05:00.882]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:00.882]     if (FALSE) {
[18:05:00.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:00.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:00.882]     }
[18:05:00.882]     ...future.result <- base::tryCatch({
[18:05:00.882]         base::withCallingHandlers({
[18:05:00.882]             ...future.value <- base::withVisible(base::local({
[18:05:00.882]                 ...future.makeSendCondition <- base::local({
[18:05:00.882]                   sendCondition <- NULL
[18:05:00.882]                   function(frame = 1L) {
[18:05:00.882]                     if (is.function(sendCondition)) 
[18:05:00.882]                       return(sendCondition)
[18:05:00.882]                     ns <- getNamespace("parallel")
[18:05:00.882]                     if (exists("sendData", mode = "function", 
[18:05:00.882]                       envir = ns)) {
[18:05:00.882]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:00.882]                         envir = ns)
[18:05:00.882]                       envir <- sys.frame(frame)
[18:05:00.882]                       master <- NULL
[18:05:00.882]                       while (!identical(envir, .GlobalEnv) && 
[18:05:00.882]                         !identical(envir, emptyenv())) {
[18:05:00.882]                         if (exists("master", mode = "list", envir = envir, 
[18:05:00.882]                           inherits = FALSE)) {
[18:05:00.882]                           master <- get("master", mode = "list", 
[18:05:00.882]                             envir = envir, inherits = FALSE)
[18:05:00.882]                           if (inherits(master, c("SOCKnode", 
[18:05:00.882]                             "SOCK0node"))) {
[18:05:00.882]                             sendCondition <<- function(cond) {
[18:05:00.882]                               data <- list(type = "VALUE", value = cond, 
[18:05:00.882]                                 success = TRUE)
[18:05:00.882]                               parallel_sendData(master, data)
[18:05:00.882]                             }
[18:05:00.882]                             return(sendCondition)
[18:05:00.882]                           }
[18:05:00.882]                         }
[18:05:00.882]                         frame <- frame + 1L
[18:05:00.882]                         envir <- sys.frame(frame)
[18:05:00.882]                       }
[18:05:00.882]                     }
[18:05:00.882]                     sendCondition <<- function(cond) NULL
[18:05:00.882]                   }
[18:05:00.882]                 })
[18:05:00.882]                 withCallingHandlers({
[18:05:00.882]                   1
[18:05:00.882]                 }, immediateCondition = function(cond) {
[18:05:00.882]                   sendCondition <- ...future.makeSendCondition()
[18:05:00.882]                   sendCondition(cond)
[18:05:00.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.882]                   {
[18:05:00.882]                     inherits <- base::inherits
[18:05:00.882]                     invokeRestart <- base::invokeRestart
[18:05:00.882]                     is.null <- base::is.null
[18:05:00.882]                     muffled <- FALSE
[18:05:00.882]                     if (inherits(cond, "message")) {
[18:05:00.882]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:00.882]                       if (muffled) 
[18:05:00.882]                         invokeRestart("muffleMessage")
[18:05:00.882]                     }
[18:05:00.882]                     else if (inherits(cond, "warning")) {
[18:05:00.882]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:00.882]                       if (muffled) 
[18:05:00.882]                         invokeRestart("muffleWarning")
[18:05:00.882]                     }
[18:05:00.882]                     else if (inherits(cond, "condition")) {
[18:05:00.882]                       if (!is.null(pattern)) {
[18:05:00.882]                         computeRestarts <- base::computeRestarts
[18:05:00.882]                         grepl <- base::grepl
[18:05:00.882]                         restarts <- computeRestarts(cond)
[18:05:00.882]                         for (restart in restarts) {
[18:05:00.882]                           name <- restart$name
[18:05:00.882]                           if (is.null(name)) 
[18:05:00.882]                             next
[18:05:00.882]                           if (!grepl(pattern, name)) 
[18:05:00.882]                             next
[18:05:00.882]                           invokeRestart(restart)
[18:05:00.882]                           muffled <- TRUE
[18:05:00.882]                           break
[18:05:00.882]                         }
[18:05:00.882]                       }
[18:05:00.882]                     }
[18:05:00.882]                     invisible(muffled)
[18:05:00.882]                   }
[18:05:00.882]                   muffleCondition(cond)
[18:05:00.882]                 })
[18:05:00.882]             }))
[18:05:00.882]             future::FutureResult(value = ...future.value$value, 
[18:05:00.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.882]                   ...future.rng), globalenv = if (FALSE) 
[18:05:00.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:00.882]                     ...future.globalenv.names))
[18:05:00.882]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:00.882]         }, condition = base::local({
[18:05:00.882]             c <- base::c
[18:05:00.882]             inherits <- base::inherits
[18:05:00.882]             invokeRestart <- base::invokeRestart
[18:05:00.882]             length <- base::length
[18:05:00.882]             list <- base::list
[18:05:00.882]             seq.int <- base::seq.int
[18:05:00.882]             signalCondition <- base::signalCondition
[18:05:00.882]             sys.calls <- base::sys.calls
[18:05:00.882]             `[[` <- base::`[[`
[18:05:00.882]             `+` <- base::`+`
[18:05:00.882]             `<<-` <- base::`<<-`
[18:05:00.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:00.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:00.882]                   3L)]
[18:05:00.882]             }
[18:05:00.882]             function(cond) {
[18:05:00.882]                 is_error <- inherits(cond, "error")
[18:05:00.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:00.882]                   NULL)
[18:05:00.882]                 if (is_error) {
[18:05:00.882]                   sessionInformation <- function() {
[18:05:00.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:00.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:00.882]                       search = base::search(), system = base::Sys.info())
[18:05:00.882]                   }
[18:05:00.882]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:00.882]                     cond$call), session = sessionInformation(), 
[18:05:00.882]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:00.882]                   signalCondition(cond)
[18:05:00.882]                 }
[18:05:00.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:00.882]                 "immediateCondition"))) {
[18:05:00.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:00.882]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:00.882]                   if (TRUE && !signal) {
[18:05:00.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.882]                     {
[18:05:00.882]                       inherits <- base::inherits
[18:05:00.882]                       invokeRestart <- base::invokeRestart
[18:05:00.882]                       is.null <- base::is.null
[18:05:00.882]                       muffled <- FALSE
[18:05:00.882]                       if (inherits(cond, "message")) {
[18:05:00.882]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.882]                         if (muffled) 
[18:05:00.882]                           invokeRestart("muffleMessage")
[18:05:00.882]                       }
[18:05:00.882]                       else if (inherits(cond, "warning")) {
[18:05:00.882]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.882]                         if (muffled) 
[18:05:00.882]                           invokeRestart("muffleWarning")
[18:05:00.882]                       }
[18:05:00.882]                       else if (inherits(cond, "condition")) {
[18:05:00.882]                         if (!is.null(pattern)) {
[18:05:00.882]                           computeRestarts <- base::computeRestarts
[18:05:00.882]                           grepl <- base::grepl
[18:05:00.882]                           restarts <- computeRestarts(cond)
[18:05:00.882]                           for (restart in restarts) {
[18:05:00.882]                             name <- restart$name
[18:05:00.882]                             if (is.null(name)) 
[18:05:00.882]                               next
[18:05:00.882]                             if (!grepl(pattern, name)) 
[18:05:00.882]                               next
[18:05:00.882]                             invokeRestart(restart)
[18:05:00.882]                             muffled <- TRUE
[18:05:00.882]                             break
[18:05:00.882]                           }
[18:05:00.882]                         }
[18:05:00.882]                       }
[18:05:00.882]                       invisible(muffled)
[18:05:00.882]                     }
[18:05:00.882]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.882]                   }
[18:05:00.882]                 }
[18:05:00.882]                 else {
[18:05:00.882]                   if (TRUE) {
[18:05:00.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.882]                     {
[18:05:00.882]                       inherits <- base::inherits
[18:05:00.882]                       invokeRestart <- base::invokeRestart
[18:05:00.882]                       is.null <- base::is.null
[18:05:00.882]                       muffled <- FALSE
[18:05:00.882]                       if (inherits(cond, "message")) {
[18:05:00.882]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.882]                         if (muffled) 
[18:05:00.882]                           invokeRestart("muffleMessage")
[18:05:00.882]                       }
[18:05:00.882]                       else if (inherits(cond, "warning")) {
[18:05:00.882]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.882]                         if (muffled) 
[18:05:00.882]                           invokeRestart("muffleWarning")
[18:05:00.882]                       }
[18:05:00.882]                       else if (inherits(cond, "condition")) {
[18:05:00.882]                         if (!is.null(pattern)) {
[18:05:00.882]                           computeRestarts <- base::computeRestarts
[18:05:00.882]                           grepl <- base::grepl
[18:05:00.882]                           restarts <- computeRestarts(cond)
[18:05:00.882]                           for (restart in restarts) {
[18:05:00.882]                             name <- restart$name
[18:05:00.882]                             if (is.null(name)) 
[18:05:00.882]                               next
[18:05:00.882]                             if (!grepl(pattern, name)) 
[18:05:00.882]                               next
[18:05:00.882]                             invokeRestart(restart)
[18:05:00.882]                             muffled <- TRUE
[18:05:00.882]                             break
[18:05:00.882]                           }
[18:05:00.882]                         }
[18:05:00.882]                       }
[18:05:00.882]                       invisible(muffled)
[18:05:00.882]                     }
[18:05:00.882]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.882]                   }
[18:05:00.882]                 }
[18:05:00.882]             }
[18:05:00.882]         }))
[18:05:00.882]     }, error = function(ex) {
[18:05:00.882]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:00.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.882]                 ...future.rng), started = ...future.startTime, 
[18:05:00.882]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:00.882]             version = "1.8"), class = "FutureResult")
[18:05:00.882]     }, finally = {
[18:05:00.882]         if (!identical(...future.workdir, getwd())) 
[18:05:00.882]             setwd(...future.workdir)
[18:05:00.882]         {
[18:05:00.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:00.882]                 ...future.oldOptions$nwarnings <- NULL
[18:05:00.882]             }
[18:05:00.882]             base::options(...future.oldOptions)
[18:05:00.882]             if (.Platform$OS.type == "windows") {
[18:05:00.882]                 old_names <- names(...future.oldEnvVars)
[18:05:00.882]                 envs <- base::Sys.getenv()
[18:05:00.882]                 names <- names(envs)
[18:05:00.882]                 common <- intersect(names, old_names)
[18:05:00.882]                 added <- setdiff(names, old_names)
[18:05:00.882]                 removed <- setdiff(old_names, names)
[18:05:00.882]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:00.882]                   envs[common]]
[18:05:00.882]                 NAMES <- toupper(changed)
[18:05:00.882]                 args <- list()
[18:05:00.882]                 for (kk in seq_along(NAMES)) {
[18:05:00.882]                   name <- changed[[kk]]
[18:05:00.882]                   NAME <- NAMES[[kk]]
[18:05:00.882]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.882]                     next
[18:05:00.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.882]                 }
[18:05:00.882]                 NAMES <- toupper(added)
[18:05:00.882]                 for (kk in seq_along(NAMES)) {
[18:05:00.882]                   name <- added[[kk]]
[18:05:00.882]                   NAME <- NAMES[[kk]]
[18:05:00.882]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.882]                     next
[18:05:00.882]                   args[[name]] <- ""
[18:05:00.882]                 }
[18:05:00.882]                 NAMES <- toupper(removed)
[18:05:00.882]                 for (kk in seq_along(NAMES)) {
[18:05:00.882]                   name <- removed[[kk]]
[18:05:00.882]                   NAME <- NAMES[[kk]]
[18:05:00.882]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.882]                     next
[18:05:00.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.882]                 }
[18:05:00.882]                 if (length(args) > 0) 
[18:05:00.882]                   base::do.call(base::Sys.setenv, args = args)
[18:05:00.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:00.882]             }
[18:05:00.882]             else {
[18:05:00.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:00.882]             }
[18:05:00.882]             {
[18:05:00.882]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:00.882]                   0L) {
[18:05:00.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:00.882]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:00.882]                   base::options(opts)
[18:05:00.882]                 }
[18:05:00.882]                 {
[18:05:00.882]                   {
[18:05:00.882]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:00.882]                     NULL
[18:05:00.882]                   }
[18:05:00.882]                   options(future.plan = NULL)
[18:05:00.882]                   if (is.na(NA_character_)) 
[18:05:00.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:00.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:00.882]                     .init = FALSE)
[18:05:00.882]                 }
[18:05:00.882]             }
[18:05:00.882]         }
[18:05:00.882]     })
[18:05:00.882]     if (TRUE) {
[18:05:00.882]         base::sink(type = "output", split = FALSE)
[18:05:00.882]         if (TRUE) {
[18:05:00.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:00.882]         }
[18:05:00.882]         else {
[18:05:00.882]             ...future.result["stdout"] <- base::list(NULL)
[18:05:00.882]         }
[18:05:00.882]         base::close(...future.stdout)
[18:05:00.882]         ...future.stdout <- NULL
[18:05:00.882]     }
[18:05:00.882]     ...future.result$conditions <- ...future.conditions
[18:05:00.882]     ...future.result$finished <- base::Sys.time()
[18:05:00.882]     ...future.result
[18:05:00.882] }
[18:05:00.888] MultisessionFuture started
[18:05:00.888] - Launch lazy future ... done
[18:05:00.889] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:00.889] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:00.890] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:00.892] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:05:00.892] Searching for globals ... DONE
[18:05:00.892] Resolving globals: TRUE
[18:05:00.893] Resolving any globals that are futures ...
[18:05:00.893] - globals: [3] ‘+’, ‘value’, ‘a’
[18:05:00.893] Resolving any globals that are futures ... DONE
[18:05:00.894] Resolving futures part of globals (recursively) ...
[18:05:00.894] resolve() on list ...
[18:05:00.894]  recursive: 99
[18:05:00.894]  length: 1
[18:05:00.895]  elements: ‘a’
[18:05:00.938] receiveMessageFromWorker() for ClusterFuture ...
[18:05:00.938] - Validating connection of MultisessionFuture
[18:05:00.938] - received message: FutureResult
[18:05:00.939] - Received FutureResult
[18:05:00.939] - Erased future from FutureRegistry
[18:05:00.939] result() for ClusterFuture ...
[18:05:00.939] - result already collected: FutureResult
[18:05:00.940] result() for ClusterFuture ... done
[18:05:00.940] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:00.940] Future #1
[18:05:00.940] result() for ClusterFuture ...
[18:05:00.941] - result already collected: FutureResult
[18:05:00.941] result() for ClusterFuture ... done
[18:05:00.941] result() for ClusterFuture ...
[18:05:00.941] - result already collected: FutureResult
[18:05:00.941] result() for ClusterFuture ... done
[18:05:00.942] A MultisessionFuture was resolved
[18:05:00.942]  length: 0 (resolved future 1)
[18:05:00.942] resolve() on list ... DONE
[18:05:00.942] - globals: [1] ‘a’
[18:05:00.943] Resolving futures part of globals (recursively) ... DONE
[18:05:00.945] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[18:05:00.946] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[18:05:00.946] - globals: [1] ‘a’
[18:05:00.946] - packages: [1] ‘future’
[18:05:00.946] getGlobalsAndPackages() ... DONE
[18:05:00.947] run() for ‘Future’ ...
[18:05:00.947] - state: ‘created’
[18:05:00.948] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:00.976] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:00.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:00.977]   - Field: ‘node’
[18:05:00.977]   - Field: ‘label’
[18:05:00.977]   - Field: ‘local’
[18:05:00.978]   - Field: ‘owner’
[18:05:00.978]   - Field: ‘envir’
[18:05:00.978]   - Field: ‘workers’
[18:05:00.978]   - Field: ‘packages’
[18:05:00.979]   - Field: ‘gc’
[18:05:00.979]   - Field: ‘conditions’
[18:05:00.979]   - Field: ‘persistent’
[18:05:00.979]   - Field: ‘expr’
[18:05:00.979]   - Field: ‘uuid’
[18:05:00.980]   - Field: ‘seed’
[18:05:00.980]   - Field: ‘version’
[18:05:00.980]   - Field: ‘result’
[18:05:00.980]   - Field: ‘asynchronous’
[18:05:00.980]   - Field: ‘calls’
[18:05:00.981]   - Field: ‘globals’
[18:05:00.981]   - Field: ‘stdout’
[18:05:00.981]   - Field: ‘earlySignal’
[18:05:00.981]   - Field: ‘lazy’
[18:05:00.981]   - Field: ‘state’
[18:05:00.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:00.982] - Launch lazy future ...
[18:05:00.982] Packages needed by the future expression (n = 1): ‘future’
[18:05:00.983] Packages needed by future strategies (n = 0): <none>
[18:05:00.984] {
[18:05:00.984]     {
[18:05:00.984]         {
[18:05:00.984]             ...future.startTime <- base::Sys.time()
[18:05:00.984]             {
[18:05:00.984]                 {
[18:05:00.984]                   {
[18:05:00.984]                     {
[18:05:00.984]                       {
[18:05:00.984]                         base::local({
[18:05:00.984]                           has_future <- base::requireNamespace("future", 
[18:05:00.984]                             quietly = TRUE)
[18:05:00.984]                           if (has_future) {
[18:05:00.984]                             ns <- base::getNamespace("future")
[18:05:00.984]                             version <- ns[[".package"]][["version"]]
[18:05:00.984]                             if (is.null(version)) 
[18:05:00.984]                               version <- utils::packageVersion("future")
[18:05:00.984]                           }
[18:05:00.984]                           else {
[18:05:00.984]                             version <- NULL
[18:05:00.984]                           }
[18:05:00.984]                           if (!has_future || version < "1.8.0") {
[18:05:00.984]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:00.984]                               "", base::R.version$version.string), 
[18:05:00.984]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:00.984]                                 base::R.version$platform, 8 * 
[18:05:00.984]                                   base::.Machine$sizeof.pointer), 
[18:05:00.984]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:00.984]                                 "release", "version")], collapse = " "), 
[18:05:00.984]                               hostname = base::Sys.info()[["nodename"]])
[18:05:00.984]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:00.984]                               info)
[18:05:00.984]                             info <- base::paste(info, collapse = "; ")
[18:05:00.984]                             if (!has_future) {
[18:05:00.984]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:00.984]                                 info)
[18:05:00.984]                             }
[18:05:00.984]                             else {
[18:05:00.984]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:00.984]                                 info, version)
[18:05:00.984]                             }
[18:05:00.984]                             base::stop(msg)
[18:05:00.984]                           }
[18:05:00.984]                         })
[18:05:00.984]                       }
[18:05:00.984]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:00.984]                       base::options(mc.cores = 1L)
[18:05:00.984]                     }
[18:05:00.984]                     base::local({
[18:05:00.984]                       for (pkg in "future") {
[18:05:00.984]                         base::loadNamespace(pkg)
[18:05:00.984]                         base::library(pkg, character.only = TRUE)
[18:05:00.984]                       }
[18:05:00.984]                     })
[18:05:00.984]                   }
[18:05:00.984]                   ...future.strategy.old <- future::plan("list")
[18:05:00.984]                   options(future.plan = NULL)
[18:05:00.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:00.984]                 }
[18:05:00.984]                 ...future.workdir <- getwd()
[18:05:00.984]             }
[18:05:00.984]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:00.984]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:00.984]         }
[18:05:00.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:00.984]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:00.984]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:00.984]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:00.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:00.984]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:00.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:00.984]             base::names(...future.oldOptions))
[18:05:00.984]     }
[18:05:00.984]     if (FALSE) {
[18:05:00.984]     }
[18:05:00.984]     else {
[18:05:00.984]         if (TRUE) {
[18:05:00.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:00.984]                 open = "w")
[18:05:00.984]         }
[18:05:00.984]         else {
[18:05:00.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:00.984]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:00.984]         }
[18:05:00.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:00.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:00.984]             base::sink(type = "output", split = FALSE)
[18:05:00.984]             base::close(...future.stdout)
[18:05:00.984]         }, add = TRUE)
[18:05:00.984]     }
[18:05:00.984]     ...future.frame <- base::sys.nframe()
[18:05:00.984]     ...future.conditions <- base::list()
[18:05:00.984]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:00.984]     if (FALSE) {
[18:05:00.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:00.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:00.984]     }
[18:05:00.984]     ...future.result <- base::tryCatch({
[18:05:00.984]         base::withCallingHandlers({
[18:05:00.984]             ...future.value <- base::withVisible(base::local({
[18:05:00.984]                 ...future.makeSendCondition <- base::local({
[18:05:00.984]                   sendCondition <- NULL
[18:05:00.984]                   function(frame = 1L) {
[18:05:00.984]                     if (is.function(sendCondition)) 
[18:05:00.984]                       return(sendCondition)
[18:05:00.984]                     ns <- getNamespace("parallel")
[18:05:00.984]                     if (exists("sendData", mode = "function", 
[18:05:00.984]                       envir = ns)) {
[18:05:00.984]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:00.984]                         envir = ns)
[18:05:00.984]                       envir <- sys.frame(frame)
[18:05:00.984]                       master <- NULL
[18:05:00.984]                       while (!identical(envir, .GlobalEnv) && 
[18:05:00.984]                         !identical(envir, emptyenv())) {
[18:05:00.984]                         if (exists("master", mode = "list", envir = envir, 
[18:05:00.984]                           inherits = FALSE)) {
[18:05:00.984]                           master <- get("master", mode = "list", 
[18:05:00.984]                             envir = envir, inherits = FALSE)
[18:05:00.984]                           if (inherits(master, c("SOCKnode", 
[18:05:00.984]                             "SOCK0node"))) {
[18:05:00.984]                             sendCondition <<- function(cond) {
[18:05:00.984]                               data <- list(type = "VALUE", value = cond, 
[18:05:00.984]                                 success = TRUE)
[18:05:00.984]                               parallel_sendData(master, data)
[18:05:00.984]                             }
[18:05:00.984]                             return(sendCondition)
[18:05:00.984]                           }
[18:05:00.984]                         }
[18:05:00.984]                         frame <- frame + 1L
[18:05:00.984]                         envir <- sys.frame(frame)
[18:05:00.984]                       }
[18:05:00.984]                     }
[18:05:00.984]                     sendCondition <<- function(cond) NULL
[18:05:00.984]                   }
[18:05:00.984]                 })
[18:05:00.984]                 withCallingHandlers({
[18:05:00.984]                   value(a) + 1
[18:05:00.984]                 }, immediateCondition = function(cond) {
[18:05:00.984]                   sendCondition <- ...future.makeSendCondition()
[18:05:00.984]                   sendCondition(cond)
[18:05:00.984]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.984]                   {
[18:05:00.984]                     inherits <- base::inherits
[18:05:00.984]                     invokeRestart <- base::invokeRestart
[18:05:00.984]                     is.null <- base::is.null
[18:05:00.984]                     muffled <- FALSE
[18:05:00.984]                     if (inherits(cond, "message")) {
[18:05:00.984]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:00.984]                       if (muffled) 
[18:05:00.984]                         invokeRestart("muffleMessage")
[18:05:00.984]                     }
[18:05:00.984]                     else if (inherits(cond, "warning")) {
[18:05:00.984]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:00.984]                       if (muffled) 
[18:05:00.984]                         invokeRestart("muffleWarning")
[18:05:00.984]                     }
[18:05:00.984]                     else if (inherits(cond, "condition")) {
[18:05:00.984]                       if (!is.null(pattern)) {
[18:05:00.984]                         computeRestarts <- base::computeRestarts
[18:05:00.984]                         grepl <- base::grepl
[18:05:00.984]                         restarts <- computeRestarts(cond)
[18:05:00.984]                         for (restart in restarts) {
[18:05:00.984]                           name <- restart$name
[18:05:00.984]                           if (is.null(name)) 
[18:05:00.984]                             next
[18:05:00.984]                           if (!grepl(pattern, name)) 
[18:05:00.984]                             next
[18:05:00.984]                           invokeRestart(restart)
[18:05:00.984]                           muffled <- TRUE
[18:05:00.984]                           break
[18:05:00.984]                         }
[18:05:00.984]                       }
[18:05:00.984]                     }
[18:05:00.984]                     invisible(muffled)
[18:05:00.984]                   }
[18:05:00.984]                   muffleCondition(cond)
[18:05:00.984]                 })
[18:05:00.984]             }))
[18:05:00.984]             future::FutureResult(value = ...future.value$value, 
[18:05:00.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.984]                   ...future.rng), globalenv = if (FALSE) 
[18:05:00.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:00.984]                     ...future.globalenv.names))
[18:05:00.984]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:00.984]         }, condition = base::local({
[18:05:00.984]             c <- base::c
[18:05:00.984]             inherits <- base::inherits
[18:05:00.984]             invokeRestart <- base::invokeRestart
[18:05:00.984]             length <- base::length
[18:05:00.984]             list <- base::list
[18:05:00.984]             seq.int <- base::seq.int
[18:05:00.984]             signalCondition <- base::signalCondition
[18:05:00.984]             sys.calls <- base::sys.calls
[18:05:00.984]             `[[` <- base::`[[`
[18:05:00.984]             `+` <- base::`+`
[18:05:00.984]             `<<-` <- base::`<<-`
[18:05:00.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:00.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:00.984]                   3L)]
[18:05:00.984]             }
[18:05:00.984]             function(cond) {
[18:05:00.984]                 is_error <- inherits(cond, "error")
[18:05:00.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:00.984]                   NULL)
[18:05:00.984]                 if (is_error) {
[18:05:00.984]                   sessionInformation <- function() {
[18:05:00.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:00.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:00.984]                       search = base::search(), system = base::Sys.info())
[18:05:00.984]                   }
[18:05:00.984]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:00.984]                     cond$call), session = sessionInformation(), 
[18:05:00.984]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:00.984]                   signalCondition(cond)
[18:05:00.984]                 }
[18:05:00.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:00.984]                 "immediateCondition"))) {
[18:05:00.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:00.984]                   ...future.conditions[[length(...future.conditions) + 
[18:05:00.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:00.984]                   if (TRUE && !signal) {
[18:05:00.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.984]                     {
[18:05:00.984]                       inherits <- base::inherits
[18:05:00.984]                       invokeRestart <- base::invokeRestart
[18:05:00.984]                       is.null <- base::is.null
[18:05:00.984]                       muffled <- FALSE
[18:05:00.984]                       if (inherits(cond, "message")) {
[18:05:00.984]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.984]                         if (muffled) 
[18:05:00.984]                           invokeRestart("muffleMessage")
[18:05:00.984]                       }
[18:05:00.984]                       else if (inherits(cond, "warning")) {
[18:05:00.984]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.984]                         if (muffled) 
[18:05:00.984]                           invokeRestart("muffleWarning")
[18:05:00.984]                       }
[18:05:00.984]                       else if (inherits(cond, "condition")) {
[18:05:00.984]                         if (!is.null(pattern)) {
[18:05:00.984]                           computeRestarts <- base::computeRestarts
[18:05:00.984]                           grepl <- base::grepl
[18:05:00.984]                           restarts <- computeRestarts(cond)
[18:05:00.984]                           for (restart in restarts) {
[18:05:00.984]                             name <- restart$name
[18:05:00.984]                             if (is.null(name)) 
[18:05:00.984]                               next
[18:05:00.984]                             if (!grepl(pattern, name)) 
[18:05:00.984]                               next
[18:05:00.984]                             invokeRestart(restart)
[18:05:00.984]                             muffled <- TRUE
[18:05:00.984]                             break
[18:05:00.984]                           }
[18:05:00.984]                         }
[18:05:00.984]                       }
[18:05:00.984]                       invisible(muffled)
[18:05:00.984]                     }
[18:05:00.984]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.984]                   }
[18:05:00.984]                 }
[18:05:00.984]                 else {
[18:05:00.984]                   if (TRUE) {
[18:05:00.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:00.984]                     {
[18:05:00.984]                       inherits <- base::inherits
[18:05:00.984]                       invokeRestart <- base::invokeRestart
[18:05:00.984]                       is.null <- base::is.null
[18:05:00.984]                       muffled <- FALSE
[18:05:00.984]                       if (inherits(cond, "message")) {
[18:05:00.984]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:00.984]                         if (muffled) 
[18:05:00.984]                           invokeRestart("muffleMessage")
[18:05:00.984]                       }
[18:05:00.984]                       else if (inherits(cond, "warning")) {
[18:05:00.984]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:00.984]                         if (muffled) 
[18:05:00.984]                           invokeRestart("muffleWarning")
[18:05:00.984]                       }
[18:05:00.984]                       else if (inherits(cond, "condition")) {
[18:05:00.984]                         if (!is.null(pattern)) {
[18:05:00.984]                           computeRestarts <- base::computeRestarts
[18:05:00.984]                           grepl <- base::grepl
[18:05:00.984]                           restarts <- computeRestarts(cond)
[18:05:00.984]                           for (restart in restarts) {
[18:05:00.984]                             name <- restart$name
[18:05:00.984]                             if (is.null(name)) 
[18:05:00.984]                               next
[18:05:00.984]                             if (!grepl(pattern, name)) 
[18:05:00.984]                               next
[18:05:00.984]                             invokeRestart(restart)
[18:05:00.984]                             muffled <- TRUE
[18:05:00.984]                             break
[18:05:00.984]                           }
[18:05:00.984]                         }
[18:05:00.984]                       }
[18:05:00.984]                       invisible(muffled)
[18:05:00.984]                     }
[18:05:00.984]                     muffleCondition(cond, pattern = "^muffle")
[18:05:00.984]                   }
[18:05:00.984]                 }
[18:05:00.984]             }
[18:05:00.984]         }))
[18:05:00.984]     }, error = function(ex) {
[18:05:00.984]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:00.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:00.984]                 ...future.rng), started = ...future.startTime, 
[18:05:00.984]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:00.984]             version = "1.8"), class = "FutureResult")
[18:05:00.984]     }, finally = {
[18:05:00.984]         if (!identical(...future.workdir, getwd())) 
[18:05:00.984]             setwd(...future.workdir)
[18:05:00.984]         {
[18:05:00.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:00.984]                 ...future.oldOptions$nwarnings <- NULL
[18:05:00.984]             }
[18:05:00.984]             base::options(...future.oldOptions)
[18:05:00.984]             if (.Platform$OS.type == "windows") {
[18:05:00.984]                 old_names <- names(...future.oldEnvVars)
[18:05:00.984]                 envs <- base::Sys.getenv()
[18:05:00.984]                 names <- names(envs)
[18:05:00.984]                 common <- intersect(names, old_names)
[18:05:00.984]                 added <- setdiff(names, old_names)
[18:05:00.984]                 removed <- setdiff(old_names, names)
[18:05:00.984]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:00.984]                   envs[common]]
[18:05:00.984]                 NAMES <- toupper(changed)
[18:05:00.984]                 args <- list()
[18:05:00.984]                 for (kk in seq_along(NAMES)) {
[18:05:00.984]                   name <- changed[[kk]]
[18:05:00.984]                   NAME <- NAMES[[kk]]
[18:05:00.984]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.984]                     next
[18:05:00.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.984]                 }
[18:05:00.984]                 NAMES <- toupper(added)
[18:05:00.984]                 for (kk in seq_along(NAMES)) {
[18:05:00.984]                   name <- added[[kk]]
[18:05:00.984]                   NAME <- NAMES[[kk]]
[18:05:00.984]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.984]                     next
[18:05:00.984]                   args[[name]] <- ""
[18:05:00.984]                 }
[18:05:00.984]                 NAMES <- toupper(removed)
[18:05:00.984]                 for (kk in seq_along(NAMES)) {
[18:05:00.984]                   name <- removed[[kk]]
[18:05:00.984]                   NAME <- NAMES[[kk]]
[18:05:00.984]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:00.984]                     next
[18:05:00.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:00.984]                 }
[18:05:00.984]                 if (length(args) > 0) 
[18:05:00.984]                   base::do.call(base::Sys.setenv, args = args)
[18:05:00.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:00.984]             }
[18:05:00.984]             else {
[18:05:00.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:00.984]             }
[18:05:00.984]             {
[18:05:00.984]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:00.984]                   0L) {
[18:05:00.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:00.984]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:00.984]                   base::options(opts)
[18:05:00.984]                 }
[18:05:00.984]                 {
[18:05:00.984]                   {
[18:05:00.984]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:00.984]                     NULL
[18:05:00.984]                   }
[18:05:00.984]                   options(future.plan = NULL)
[18:05:00.984]                   if (is.na(NA_character_)) 
[18:05:00.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:00.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:00.984]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:00.984]                     .init = FALSE)
[18:05:00.984]                 }
[18:05:00.984]             }
[18:05:00.984]         }
[18:05:00.984]     })
[18:05:00.984]     if (TRUE) {
[18:05:00.984]         base::sink(type = "output", split = FALSE)
[18:05:00.984]         if (TRUE) {
[18:05:00.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:00.984]         }
[18:05:00.984]         else {
[18:05:00.984]             ...future.result["stdout"] <- base::list(NULL)
[18:05:00.984]         }
[18:05:00.984]         base::close(...future.stdout)
[18:05:00.984]         ...future.stdout <- NULL
[18:05:00.984]     }
[18:05:00.984]     ...future.result$conditions <- ...future.conditions
[18:05:00.984]     ...future.result$finished <- base::Sys.time()
[18:05:00.984]     ...future.result
[18:05:00.984] }
[18:05:00.991] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[18:05:00.993] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[18:05:01.052] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[18:05:01.052] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[18:05:01.053] MultisessionFuture started
[18:05:01.053] - Launch lazy future ... done
[18:05:01.053] run() for ‘MultisessionFuture’ ... done
[18:05:01.054] result() for ClusterFuture ...
[18:05:01.054] receiveMessageFromWorker() for ClusterFuture ...
[18:05:01.054] - Validating connection of MultisessionFuture
[18:05:01.102] - received message: FutureResult
[18:05:01.103] - Received FutureResult
[18:05:01.103] - Erased future from FutureRegistry
[18:05:01.103] result() for ClusterFuture ...
[18:05:01.103] - result already collected: FutureResult
[18:05:01.103] result() for ClusterFuture ... done
[18:05:01.104] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:01.104] result() for ClusterFuture ... done
[18:05:01.104] result() for ClusterFuture ...
[18:05:01.104] - result already collected: FutureResult
[18:05:01.104] result() for ClusterFuture ... done
value(b) = 2
[18:05:01.105] result() for ClusterFuture ...
[18:05:01.105] - result already collected: FutureResult
[18:05:01.105] result() for ClusterFuture ... done
[18:05:01.105] result() for ClusterFuture ...
[18:05:01.106] - result already collected: FutureResult
[18:05:01.106] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:01.106] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:01.107] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:01.108] 
[18:05:01.108] Searching for globals ... DONE
[18:05:01.108] - globals: [0] <none>
[18:05:01.108] getGlobalsAndPackages() ... DONE
[18:05:01.109] run() for ‘Future’ ...
[18:05:01.109] - state: ‘created’
[18:05:01.109] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:01.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:01.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:01.132]   - Field: ‘node’
[18:05:01.132]   - Field: ‘label’
[18:05:01.132]   - Field: ‘local’
[18:05:01.133]   - Field: ‘owner’
[18:05:01.133]   - Field: ‘envir’
[18:05:01.133]   - Field: ‘workers’
[18:05:01.133]   - Field: ‘packages’
[18:05:01.133]   - Field: ‘gc’
[18:05:01.134]   - Field: ‘conditions’
[18:05:01.134]   - Field: ‘persistent’
[18:05:01.134]   - Field: ‘expr’
[18:05:01.134]   - Field: ‘uuid’
[18:05:01.134]   - Field: ‘seed’
[18:05:01.134]   - Field: ‘version’
[18:05:01.135]   - Field: ‘result’
[18:05:01.135]   - Field: ‘asynchronous’
[18:05:01.135]   - Field: ‘calls’
[18:05:01.135]   - Field: ‘globals’
[18:05:01.135]   - Field: ‘stdout’
[18:05:01.136]   - Field: ‘earlySignal’
[18:05:01.136]   - Field: ‘lazy’
[18:05:01.136]   - Field: ‘state’
[18:05:01.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:01.136] - Launch lazy future ...
[18:05:01.137] Packages needed by the future expression (n = 0): <none>
[18:05:01.137] Packages needed by future strategies (n = 0): <none>
[18:05:01.138] {
[18:05:01.138]     {
[18:05:01.138]         {
[18:05:01.138]             ...future.startTime <- base::Sys.time()
[18:05:01.138]             {
[18:05:01.138]                 {
[18:05:01.138]                   {
[18:05:01.138]                     {
[18:05:01.138]                       base::local({
[18:05:01.138]                         has_future <- base::requireNamespace("future", 
[18:05:01.138]                           quietly = TRUE)
[18:05:01.138]                         if (has_future) {
[18:05:01.138]                           ns <- base::getNamespace("future")
[18:05:01.138]                           version <- ns[[".package"]][["version"]]
[18:05:01.138]                           if (is.null(version)) 
[18:05:01.138]                             version <- utils::packageVersion("future")
[18:05:01.138]                         }
[18:05:01.138]                         else {
[18:05:01.138]                           version <- NULL
[18:05:01.138]                         }
[18:05:01.138]                         if (!has_future || version < "1.8.0") {
[18:05:01.138]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:01.138]                             "", base::R.version$version.string), 
[18:05:01.138]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:01.138]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:01.138]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:01.138]                               "release", "version")], collapse = " "), 
[18:05:01.138]                             hostname = base::Sys.info()[["nodename"]])
[18:05:01.138]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:01.138]                             info)
[18:05:01.138]                           info <- base::paste(info, collapse = "; ")
[18:05:01.138]                           if (!has_future) {
[18:05:01.138]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:01.138]                               info)
[18:05:01.138]                           }
[18:05:01.138]                           else {
[18:05:01.138]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:01.138]                               info, version)
[18:05:01.138]                           }
[18:05:01.138]                           base::stop(msg)
[18:05:01.138]                         }
[18:05:01.138]                       })
[18:05:01.138]                     }
[18:05:01.138]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:01.138]                     base::options(mc.cores = 1L)
[18:05:01.138]                   }
[18:05:01.138]                   ...future.strategy.old <- future::plan("list")
[18:05:01.138]                   options(future.plan = NULL)
[18:05:01.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:01.138]                 }
[18:05:01.138]                 ...future.workdir <- getwd()
[18:05:01.138]             }
[18:05:01.138]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:01.138]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:01.138]         }
[18:05:01.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:01.138]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:01.138]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:01.138]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:01.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:01.138]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:01.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:01.138]             base::names(...future.oldOptions))
[18:05:01.138]     }
[18:05:01.138]     if (FALSE) {
[18:05:01.138]     }
[18:05:01.138]     else {
[18:05:01.138]         if (TRUE) {
[18:05:01.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:01.138]                 open = "w")
[18:05:01.138]         }
[18:05:01.138]         else {
[18:05:01.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:01.138]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:01.138]         }
[18:05:01.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:01.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:01.138]             base::sink(type = "output", split = FALSE)
[18:05:01.138]             base::close(...future.stdout)
[18:05:01.138]         }, add = TRUE)
[18:05:01.138]     }
[18:05:01.138]     ...future.frame <- base::sys.nframe()
[18:05:01.138]     ...future.conditions <- base::list()
[18:05:01.138]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:01.138]     if (FALSE) {
[18:05:01.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:01.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:01.138]     }
[18:05:01.138]     ...future.result <- base::tryCatch({
[18:05:01.138]         base::withCallingHandlers({
[18:05:01.138]             ...future.value <- base::withVisible(base::local({
[18:05:01.138]                 ...future.makeSendCondition <- base::local({
[18:05:01.138]                   sendCondition <- NULL
[18:05:01.138]                   function(frame = 1L) {
[18:05:01.138]                     if (is.function(sendCondition)) 
[18:05:01.138]                       return(sendCondition)
[18:05:01.138]                     ns <- getNamespace("parallel")
[18:05:01.138]                     if (exists("sendData", mode = "function", 
[18:05:01.138]                       envir = ns)) {
[18:05:01.138]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:01.138]                         envir = ns)
[18:05:01.138]                       envir <- sys.frame(frame)
[18:05:01.138]                       master <- NULL
[18:05:01.138]                       while (!identical(envir, .GlobalEnv) && 
[18:05:01.138]                         !identical(envir, emptyenv())) {
[18:05:01.138]                         if (exists("master", mode = "list", envir = envir, 
[18:05:01.138]                           inherits = FALSE)) {
[18:05:01.138]                           master <- get("master", mode = "list", 
[18:05:01.138]                             envir = envir, inherits = FALSE)
[18:05:01.138]                           if (inherits(master, c("SOCKnode", 
[18:05:01.138]                             "SOCK0node"))) {
[18:05:01.138]                             sendCondition <<- function(cond) {
[18:05:01.138]                               data <- list(type = "VALUE", value = cond, 
[18:05:01.138]                                 success = TRUE)
[18:05:01.138]                               parallel_sendData(master, data)
[18:05:01.138]                             }
[18:05:01.138]                             return(sendCondition)
[18:05:01.138]                           }
[18:05:01.138]                         }
[18:05:01.138]                         frame <- frame + 1L
[18:05:01.138]                         envir <- sys.frame(frame)
[18:05:01.138]                       }
[18:05:01.138]                     }
[18:05:01.138]                     sendCondition <<- function(cond) NULL
[18:05:01.138]                   }
[18:05:01.138]                 })
[18:05:01.138]                 withCallingHandlers({
[18:05:01.138]                   1
[18:05:01.138]                 }, immediateCondition = function(cond) {
[18:05:01.138]                   sendCondition <- ...future.makeSendCondition()
[18:05:01.138]                   sendCondition(cond)
[18:05:01.138]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.138]                   {
[18:05:01.138]                     inherits <- base::inherits
[18:05:01.138]                     invokeRestart <- base::invokeRestart
[18:05:01.138]                     is.null <- base::is.null
[18:05:01.138]                     muffled <- FALSE
[18:05:01.138]                     if (inherits(cond, "message")) {
[18:05:01.138]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:01.138]                       if (muffled) 
[18:05:01.138]                         invokeRestart("muffleMessage")
[18:05:01.138]                     }
[18:05:01.138]                     else if (inherits(cond, "warning")) {
[18:05:01.138]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:01.138]                       if (muffled) 
[18:05:01.138]                         invokeRestart("muffleWarning")
[18:05:01.138]                     }
[18:05:01.138]                     else if (inherits(cond, "condition")) {
[18:05:01.138]                       if (!is.null(pattern)) {
[18:05:01.138]                         computeRestarts <- base::computeRestarts
[18:05:01.138]                         grepl <- base::grepl
[18:05:01.138]                         restarts <- computeRestarts(cond)
[18:05:01.138]                         for (restart in restarts) {
[18:05:01.138]                           name <- restart$name
[18:05:01.138]                           if (is.null(name)) 
[18:05:01.138]                             next
[18:05:01.138]                           if (!grepl(pattern, name)) 
[18:05:01.138]                             next
[18:05:01.138]                           invokeRestart(restart)
[18:05:01.138]                           muffled <- TRUE
[18:05:01.138]                           break
[18:05:01.138]                         }
[18:05:01.138]                       }
[18:05:01.138]                     }
[18:05:01.138]                     invisible(muffled)
[18:05:01.138]                   }
[18:05:01.138]                   muffleCondition(cond)
[18:05:01.138]                 })
[18:05:01.138]             }))
[18:05:01.138]             future::FutureResult(value = ...future.value$value, 
[18:05:01.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.138]                   ...future.rng), globalenv = if (FALSE) 
[18:05:01.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:01.138]                     ...future.globalenv.names))
[18:05:01.138]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:01.138]         }, condition = base::local({
[18:05:01.138]             c <- base::c
[18:05:01.138]             inherits <- base::inherits
[18:05:01.138]             invokeRestart <- base::invokeRestart
[18:05:01.138]             length <- base::length
[18:05:01.138]             list <- base::list
[18:05:01.138]             seq.int <- base::seq.int
[18:05:01.138]             signalCondition <- base::signalCondition
[18:05:01.138]             sys.calls <- base::sys.calls
[18:05:01.138]             `[[` <- base::`[[`
[18:05:01.138]             `+` <- base::`+`
[18:05:01.138]             `<<-` <- base::`<<-`
[18:05:01.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:01.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:01.138]                   3L)]
[18:05:01.138]             }
[18:05:01.138]             function(cond) {
[18:05:01.138]                 is_error <- inherits(cond, "error")
[18:05:01.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:01.138]                   NULL)
[18:05:01.138]                 if (is_error) {
[18:05:01.138]                   sessionInformation <- function() {
[18:05:01.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:01.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:01.138]                       search = base::search(), system = base::Sys.info())
[18:05:01.138]                   }
[18:05:01.138]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:01.138]                     cond$call), session = sessionInformation(), 
[18:05:01.138]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:01.138]                   signalCondition(cond)
[18:05:01.138]                 }
[18:05:01.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:01.138]                 "immediateCondition"))) {
[18:05:01.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:01.138]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:01.138]                   if (TRUE && !signal) {
[18:05:01.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.138]                     {
[18:05:01.138]                       inherits <- base::inherits
[18:05:01.138]                       invokeRestart <- base::invokeRestart
[18:05:01.138]                       is.null <- base::is.null
[18:05:01.138]                       muffled <- FALSE
[18:05:01.138]                       if (inherits(cond, "message")) {
[18:05:01.138]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.138]                         if (muffled) 
[18:05:01.138]                           invokeRestart("muffleMessage")
[18:05:01.138]                       }
[18:05:01.138]                       else if (inherits(cond, "warning")) {
[18:05:01.138]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.138]                         if (muffled) 
[18:05:01.138]                           invokeRestart("muffleWarning")
[18:05:01.138]                       }
[18:05:01.138]                       else if (inherits(cond, "condition")) {
[18:05:01.138]                         if (!is.null(pattern)) {
[18:05:01.138]                           computeRestarts <- base::computeRestarts
[18:05:01.138]                           grepl <- base::grepl
[18:05:01.138]                           restarts <- computeRestarts(cond)
[18:05:01.138]                           for (restart in restarts) {
[18:05:01.138]                             name <- restart$name
[18:05:01.138]                             if (is.null(name)) 
[18:05:01.138]                               next
[18:05:01.138]                             if (!grepl(pattern, name)) 
[18:05:01.138]                               next
[18:05:01.138]                             invokeRestart(restart)
[18:05:01.138]                             muffled <- TRUE
[18:05:01.138]                             break
[18:05:01.138]                           }
[18:05:01.138]                         }
[18:05:01.138]                       }
[18:05:01.138]                       invisible(muffled)
[18:05:01.138]                     }
[18:05:01.138]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.138]                   }
[18:05:01.138]                 }
[18:05:01.138]                 else {
[18:05:01.138]                   if (TRUE) {
[18:05:01.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.138]                     {
[18:05:01.138]                       inherits <- base::inherits
[18:05:01.138]                       invokeRestart <- base::invokeRestart
[18:05:01.138]                       is.null <- base::is.null
[18:05:01.138]                       muffled <- FALSE
[18:05:01.138]                       if (inherits(cond, "message")) {
[18:05:01.138]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.138]                         if (muffled) 
[18:05:01.138]                           invokeRestart("muffleMessage")
[18:05:01.138]                       }
[18:05:01.138]                       else if (inherits(cond, "warning")) {
[18:05:01.138]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.138]                         if (muffled) 
[18:05:01.138]                           invokeRestart("muffleWarning")
[18:05:01.138]                       }
[18:05:01.138]                       else if (inherits(cond, "condition")) {
[18:05:01.138]                         if (!is.null(pattern)) {
[18:05:01.138]                           computeRestarts <- base::computeRestarts
[18:05:01.138]                           grepl <- base::grepl
[18:05:01.138]                           restarts <- computeRestarts(cond)
[18:05:01.138]                           for (restart in restarts) {
[18:05:01.138]                             name <- restart$name
[18:05:01.138]                             if (is.null(name)) 
[18:05:01.138]                               next
[18:05:01.138]                             if (!grepl(pattern, name)) 
[18:05:01.138]                               next
[18:05:01.138]                             invokeRestart(restart)
[18:05:01.138]                             muffled <- TRUE
[18:05:01.138]                             break
[18:05:01.138]                           }
[18:05:01.138]                         }
[18:05:01.138]                       }
[18:05:01.138]                       invisible(muffled)
[18:05:01.138]                     }
[18:05:01.138]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.138]                   }
[18:05:01.138]                 }
[18:05:01.138]             }
[18:05:01.138]         }))
[18:05:01.138]     }, error = function(ex) {
[18:05:01.138]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:01.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.138]                 ...future.rng), started = ...future.startTime, 
[18:05:01.138]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:01.138]             version = "1.8"), class = "FutureResult")
[18:05:01.138]     }, finally = {
[18:05:01.138]         if (!identical(...future.workdir, getwd())) 
[18:05:01.138]             setwd(...future.workdir)
[18:05:01.138]         {
[18:05:01.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:01.138]                 ...future.oldOptions$nwarnings <- NULL
[18:05:01.138]             }
[18:05:01.138]             base::options(...future.oldOptions)
[18:05:01.138]             if (.Platform$OS.type == "windows") {
[18:05:01.138]                 old_names <- names(...future.oldEnvVars)
[18:05:01.138]                 envs <- base::Sys.getenv()
[18:05:01.138]                 names <- names(envs)
[18:05:01.138]                 common <- intersect(names, old_names)
[18:05:01.138]                 added <- setdiff(names, old_names)
[18:05:01.138]                 removed <- setdiff(old_names, names)
[18:05:01.138]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:01.138]                   envs[common]]
[18:05:01.138]                 NAMES <- toupper(changed)
[18:05:01.138]                 args <- list()
[18:05:01.138]                 for (kk in seq_along(NAMES)) {
[18:05:01.138]                   name <- changed[[kk]]
[18:05:01.138]                   NAME <- NAMES[[kk]]
[18:05:01.138]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.138]                     next
[18:05:01.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.138]                 }
[18:05:01.138]                 NAMES <- toupper(added)
[18:05:01.138]                 for (kk in seq_along(NAMES)) {
[18:05:01.138]                   name <- added[[kk]]
[18:05:01.138]                   NAME <- NAMES[[kk]]
[18:05:01.138]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.138]                     next
[18:05:01.138]                   args[[name]] <- ""
[18:05:01.138]                 }
[18:05:01.138]                 NAMES <- toupper(removed)
[18:05:01.138]                 for (kk in seq_along(NAMES)) {
[18:05:01.138]                   name <- removed[[kk]]
[18:05:01.138]                   NAME <- NAMES[[kk]]
[18:05:01.138]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.138]                     next
[18:05:01.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.138]                 }
[18:05:01.138]                 if (length(args) > 0) 
[18:05:01.138]                   base::do.call(base::Sys.setenv, args = args)
[18:05:01.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:01.138]             }
[18:05:01.138]             else {
[18:05:01.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:01.138]             }
[18:05:01.138]             {
[18:05:01.138]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:01.138]                   0L) {
[18:05:01.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:01.138]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:01.138]                   base::options(opts)
[18:05:01.138]                 }
[18:05:01.138]                 {
[18:05:01.138]                   {
[18:05:01.138]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:01.138]                     NULL
[18:05:01.138]                   }
[18:05:01.138]                   options(future.plan = NULL)
[18:05:01.138]                   if (is.na(NA_character_)) 
[18:05:01.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:01.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:01.138]                     .init = FALSE)
[18:05:01.138]                 }
[18:05:01.138]             }
[18:05:01.138]         }
[18:05:01.138]     })
[18:05:01.138]     if (TRUE) {
[18:05:01.138]         base::sink(type = "output", split = FALSE)
[18:05:01.138]         if (TRUE) {
[18:05:01.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:01.138]         }
[18:05:01.138]         else {
[18:05:01.138]             ...future.result["stdout"] <- base::list(NULL)
[18:05:01.138]         }
[18:05:01.138]         base::close(...future.stdout)
[18:05:01.138]         ...future.stdout <- NULL
[18:05:01.138]     }
[18:05:01.138]     ...future.result$conditions <- ...future.conditions
[18:05:01.138]     ...future.result$finished <- base::Sys.time()
[18:05:01.138]     ...future.result
[18:05:01.138] }
[18:05:01.144] MultisessionFuture started
[18:05:01.144] - Launch lazy future ... done
[18:05:01.144] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:01.145] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:01.145] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:01.147] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:05:01.148] Searching for globals ... DONE
[18:05:01.148] Resolving globals: TRUE
[18:05:01.148] Resolving any globals that are futures ...
[18:05:01.148] - globals: [3] ‘+’, ‘value’, ‘a’
[18:05:01.148] Resolving any globals that are futures ... DONE
[18:05:01.149] Resolving futures part of globals (recursively) ...
[18:05:01.150] resolve() on list ...
[18:05:01.150]  recursive: 99
[18:05:01.150]  length: 1
[18:05:01.150]  elements: ‘a’
[18:05:01.194] receiveMessageFromWorker() for ClusterFuture ...
[18:05:01.194] - Validating connection of MultisessionFuture
[18:05:01.195] - received message: FutureResult
[18:05:01.195] - Received FutureResult
[18:05:01.196] - Erased future from FutureRegistry
[18:05:01.196] result() for ClusterFuture ...
[18:05:01.196] - result already collected: FutureResult
[18:05:01.196] result() for ClusterFuture ... done
[18:05:01.197] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:01.197] Future #1
[18:05:01.197] result() for ClusterFuture ...
[18:05:01.197] - result already collected: FutureResult
[18:05:01.198] result() for ClusterFuture ... done
[18:05:01.198] result() for ClusterFuture ...
[18:05:01.198] - result already collected: FutureResult
[18:05:01.199] result() for ClusterFuture ... done
[18:05:01.199] A MultisessionFuture was resolved
[18:05:01.199]  length: 0 (resolved future 1)
[18:05:01.200] resolve() on list ... DONE
[18:05:01.200] - globals: [1] ‘a’
[18:05:01.200] Resolving futures part of globals (recursively) ... DONE
[18:05:01.203] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[18:05:01.204] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[18:05:01.204] - globals: [1] ‘a’
[18:05:01.204] - packages: [1] ‘future’
[18:05:01.205] getGlobalsAndPackages() ... DONE
[18:05:01.206] run() for ‘Future’ ...
[18:05:01.206] - state: ‘created’
[18:05:01.206] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:01.233] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:01.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:01.234]   - Field: ‘node’
[18:05:01.234]   - Field: ‘label’
[18:05:01.234]   - Field: ‘local’
[18:05:01.235]   - Field: ‘owner’
[18:05:01.235]   - Field: ‘envir’
[18:05:01.235]   - Field: ‘workers’
[18:05:01.235]   - Field: ‘packages’
[18:05:01.235]   - Field: ‘gc’
[18:05:01.236]   - Field: ‘conditions’
[18:05:01.236]   - Field: ‘persistent’
[18:05:01.236]   - Field: ‘expr’
[18:05:01.236]   - Field: ‘uuid’
[18:05:01.236]   - Field: ‘seed’
[18:05:01.237]   - Field: ‘version’
[18:05:01.237]   - Field: ‘result’
[18:05:01.237]   - Field: ‘asynchronous’
[18:05:01.237]   - Field: ‘calls’
[18:05:01.238]   - Field: ‘globals’
[18:05:01.238]   - Field: ‘stdout’
[18:05:01.238]   - Field: ‘earlySignal’
[18:05:01.238]   - Field: ‘lazy’
[18:05:01.238]   - Field: ‘state’
[18:05:01.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:01.239] - Launch lazy future ...
[18:05:01.239] Packages needed by the future expression (n = 1): ‘future’
[18:05:01.240] Packages needed by future strategies (n = 0): <none>
[18:05:01.241] {
[18:05:01.241]     {
[18:05:01.241]         {
[18:05:01.241]             ...future.startTime <- base::Sys.time()
[18:05:01.241]             {
[18:05:01.241]                 {
[18:05:01.241]                   {
[18:05:01.241]                     {
[18:05:01.241]                       {
[18:05:01.241]                         base::local({
[18:05:01.241]                           has_future <- base::requireNamespace("future", 
[18:05:01.241]                             quietly = TRUE)
[18:05:01.241]                           if (has_future) {
[18:05:01.241]                             ns <- base::getNamespace("future")
[18:05:01.241]                             version <- ns[[".package"]][["version"]]
[18:05:01.241]                             if (is.null(version)) 
[18:05:01.241]                               version <- utils::packageVersion("future")
[18:05:01.241]                           }
[18:05:01.241]                           else {
[18:05:01.241]                             version <- NULL
[18:05:01.241]                           }
[18:05:01.241]                           if (!has_future || version < "1.8.0") {
[18:05:01.241]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:01.241]                               "", base::R.version$version.string), 
[18:05:01.241]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:01.241]                                 base::R.version$platform, 8 * 
[18:05:01.241]                                   base::.Machine$sizeof.pointer), 
[18:05:01.241]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:01.241]                                 "release", "version")], collapse = " "), 
[18:05:01.241]                               hostname = base::Sys.info()[["nodename"]])
[18:05:01.241]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:01.241]                               info)
[18:05:01.241]                             info <- base::paste(info, collapse = "; ")
[18:05:01.241]                             if (!has_future) {
[18:05:01.241]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:01.241]                                 info)
[18:05:01.241]                             }
[18:05:01.241]                             else {
[18:05:01.241]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:01.241]                                 info, version)
[18:05:01.241]                             }
[18:05:01.241]                             base::stop(msg)
[18:05:01.241]                           }
[18:05:01.241]                         })
[18:05:01.241]                       }
[18:05:01.241]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:01.241]                       base::options(mc.cores = 1L)
[18:05:01.241]                     }
[18:05:01.241]                     base::local({
[18:05:01.241]                       for (pkg in "future") {
[18:05:01.241]                         base::loadNamespace(pkg)
[18:05:01.241]                         base::library(pkg, character.only = TRUE)
[18:05:01.241]                       }
[18:05:01.241]                     })
[18:05:01.241]                   }
[18:05:01.241]                   ...future.strategy.old <- future::plan("list")
[18:05:01.241]                   options(future.plan = NULL)
[18:05:01.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:01.241]                 }
[18:05:01.241]                 ...future.workdir <- getwd()
[18:05:01.241]             }
[18:05:01.241]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:01.241]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:01.241]         }
[18:05:01.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:01.241]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:01.241]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:01.241]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:01.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:01.241]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:01.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:01.241]             base::names(...future.oldOptions))
[18:05:01.241]     }
[18:05:01.241]     if (FALSE) {
[18:05:01.241]     }
[18:05:01.241]     else {
[18:05:01.241]         if (TRUE) {
[18:05:01.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:01.241]                 open = "w")
[18:05:01.241]         }
[18:05:01.241]         else {
[18:05:01.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:01.241]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:01.241]         }
[18:05:01.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:01.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:01.241]             base::sink(type = "output", split = FALSE)
[18:05:01.241]             base::close(...future.stdout)
[18:05:01.241]         }, add = TRUE)
[18:05:01.241]     }
[18:05:01.241]     ...future.frame <- base::sys.nframe()
[18:05:01.241]     ...future.conditions <- base::list()
[18:05:01.241]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:01.241]     if (FALSE) {
[18:05:01.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:01.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:01.241]     }
[18:05:01.241]     ...future.result <- base::tryCatch({
[18:05:01.241]         base::withCallingHandlers({
[18:05:01.241]             ...future.value <- base::withVisible(base::local({
[18:05:01.241]                 ...future.makeSendCondition <- base::local({
[18:05:01.241]                   sendCondition <- NULL
[18:05:01.241]                   function(frame = 1L) {
[18:05:01.241]                     if (is.function(sendCondition)) 
[18:05:01.241]                       return(sendCondition)
[18:05:01.241]                     ns <- getNamespace("parallel")
[18:05:01.241]                     if (exists("sendData", mode = "function", 
[18:05:01.241]                       envir = ns)) {
[18:05:01.241]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:01.241]                         envir = ns)
[18:05:01.241]                       envir <- sys.frame(frame)
[18:05:01.241]                       master <- NULL
[18:05:01.241]                       while (!identical(envir, .GlobalEnv) && 
[18:05:01.241]                         !identical(envir, emptyenv())) {
[18:05:01.241]                         if (exists("master", mode = "list", envir = envir, 
[18:05:01.241]                           inherits = FALSE)) {
[18:05:01.241]                           master <- get("master", mode = "list", 
[18:05:01.241]                             envir = envir, inherits = FALSE)
[18:05:01.241]                           if (inherits(master, c("SOCKnode", 
[18:05:01.241]                             "SOCK0node"))) {
[18:05:01.241]                             sendCondition <<- function(cond) {
[18:05:01.241]                               data <- list(type = "VALUE", value = cond, 
[18:05:01.241]                                 success = TRUE)
[18:05:01.241]                               parallel_sendData(master, data)
[18:05:01.241]                             }
[18:05:01.241]                             return(sendCondition)
[18:05:01.241]                           }
[18:05:01.241]                         }
[18:05:01.241]                         frame <- frame + 1L
[18:05:01.241]                         envir <- sys.frame(frame)
[18:05:01.241]                       }
[18:05:01.241]                     }
[18:05:01.241]                     sendCondition <<- function(cond) NULL
[18:05:01.241]                   }
[18:05:01.241]                 })
[18:05:01.241]                 withCallingHandlers({
[18:05:01.241]                   value(a) + 1
[18:05:01.241]                 }, immediateCondition = function(cond) {
[18:05:01.241]                   sendCondition <- ...future.makeSendCondition()
[18:05:01.241]                   sendCondition(cond)
[18:05:01.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.241]                   {
[18:05:01.241]                     inherits <- base::inherits
[18:05:01.241]                     invokeRestart <- base::invokeRestart
[18:05:01.241]                     is.null <- base::is.null
[18:05:01.241]                     muffled <- FALSE
[18:05:01.241]                     if (inherits(cond, "message")) {
[18:05:01.241]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:01.241]                       if (muffled) 
[18:05:01.241]                         invokeRestart("muffleMessage")
[18:05:01.241]                     }
[18:05:01.241]                     else if (inherits(cond, "warning")) {
[18:05:01.241]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:01.241]                       if (muffled) 
[18:05:01.241]                         invokeRestart("muffleWarning")
[18:05:01.241]                     }
[18:05:01.241]                     else if (inherits(cond, "condition")) {
[18:05:01.241]                       if (!is.null(pattern)) {
[18:05:01.241]                         computeRestarts <- base::computeRestarts
[18:05:01.241]                         grepl <- base::grepl
[18:05:01.241]                         restarts <- computeRestarts(cond)
[18:05:01.241]                         for (restart in restarts) {
[18:05:01.241]                           name <- restart$name
[18:05:01.241]                           if (is.null(name)) 
[18:05:01.241]                             next
[18:05:01.241]                           if (!grepl(pattern, name)) 
[18:05:01.241]                             next
[18:05:01.241]                           invokeRestart(restart)
[18:05:01.241]                           muffled <- TRUE
[18:05:01.241]                           break
[18:05:01.241]                         }
[18:05:01.241]                       }
[18:05:01.241]                     }
[18:05:01.241]                     invisible(muffled)
[18:05:01.241]                   }
[18:05:01.241]                   muffleCondition(cond)
[18:05:01.241]                 })
[18:05:01.241]             }))
[18:05:01.241]             future::FutureResult(value = ...future.value$value, 
[18:05:01.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.241]                   ...future.rng), globalenv = if (FALSE) 
[18:05:01.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:01.241]                     ...future.globalenv.names))
[18:05:01.241]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:01.241]         }, condition = base::local({
[18:05:01.241]             c <- base::c
[18:05:01.241]             inherits <- base::inherits
[18:05:01.241]             invokeRestart <- base::invokeRestart
[18:05:01.241]             length <- base::length
[18:05:01.241]             list <- base::list
[18:05:01.241]             seq.int <- base::seq.int
[18:05:01.241]             signalCondition <- base::signalCondition
[18:05:01.241]             sys.calls <- base::sys.calls
[18:05:01.241]             `[[` <- base::`[[`
[18:05:01.241]             `+` <- base::`+`
[18:05:01.241]             `<<-` <- base::`<<-`
[18:05:01.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:01.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:01.241]                   3L)]
[18:05:01.241]             }
[18:05:01.241]             function(cond) {
[18:05:01.241]                 is_error <- inherits(cond, "error")
[18:05:01.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:01.241]                   NULL)
[18:05:01.241]                 if (is_error) {
[18:05:01.241]                   sessionInformation <- function() {
[18:05:01.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:01.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:01.241]                       search = base::search(), system = base::Sys.info())
[18:05:01.241]                   }
[18:05:01.241]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:01.241]                     cond$call), session = sessionInformation(), 
[18:05:01.241]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:01.241]                   signalCondition(cond)
[18:05:01.241]                 }
[18:05:01.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:01.241]                 "immediateCondition"))) {
[18:05:01.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:01.241]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:01.241]                   if (TRUE && !signal) {
[18:05:01.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.241]                     {
[18:05:01.241]                       inherits <- base::inherits
[18:05:01.241]                       invokeRestart <- base::invokeRestart
[18:05:01.241]                       is.null <- base::is.null
[18:05:01.241]                       muffled <- FALSE
[18:05:01.241]                       if (inherits(cond, "message")) {
[18:05:01.241]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.241]                         if (muffled) 
[18:05:01.241]                           invokeRestart("muffleMessage")
[18:05:01.241]                       }
[18:05:01.241]                       else if (inherits(cond, "warning")) {
[18:05:01.241]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.241]                         if (muffled) 
[18:05:01.241]                           invokeRestart("muffleWarning")
[18:05:01.241]                       }
[18:05:01.241]                       else if (inherits(cond, "condition")) {
[18:05:01.241]                         if (!is.null(pattern)) {
[18:05:01.241]                           computeRestarts <- base::computeRestarts
[18:05:01.241]                           grepl <- base::grepl
[18:05:01.241]                           restarts <- computeRestarts(cond)
[18:05:01.241]                           for (restart in restarts) {
[18:05:01.241]                             name <- restart$name
[18:05:01.241]                             if (is.null(name)) 
[18:05:01.241]                               next
[18:05:01.241]                             if (!grepl(pattern, name)) 
[18:05:01.241]                               next
[18:05:01.241]                             invokeRestart(restart)
[18:05:01.241]                             muffled <- TRUE
[18:05:01.241]                             break
[18:05:01.241]                           }
[18:05:01.241]                         }
[18:05:01.241]                       }
[18:05:01.241]                       invisible(muffled)
[18:05:01.241]                     }
[18:05:01.241]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.241]                   }
[18:05:01.241]                 }
[18:05:01.241]                 else {
[18:05:01.241]                   if (TRUE) {
[18:05:01.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.241]                     {
[18:05:01.241]                       inherits <- base::inherits
[18:05:01.241]                       invokeRestart <- base::invokeRestart
[18:05:01.241]                       is.null <- base::is.null
[18:05:01.241]                       muffled <- FALSE
[18:05:01.241]                       if (inherits(cond, "message")) {
[18:05:01.241]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.241]                         if (muffled) 
[18:05:01.241]                           invokeRestart("muffleMessage")
[18:05:01.241]                       }
[18:05:01.241]                       else if (inherits(cond, "warning")) {
[18:05:01.241]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.241]                         if (muffled) 
[18:05:01.241]                           invokeRestart("muffleWarning")
[18:05:01.241]                       }
[18:05:01.241]                       else if (inherits(cond, "condition")) {
[18:05:01.241]                         if (!is.null(pattern)) {
[18:05:01.241]                           computeRestarts <- base::computeRestarts
[18:05:01.241]                           grepl <- base::grepl
[18:05:01.241]                           restarts <- computeRestarts(cond)
[18:05:01.241]                           for (restart in restarts) {
[18:05:01.241]                             name <- restart$name
[18:05:01.241]                             if (is.null(name)) 
[18:05:01.241]                               next
[18:05:01.241]                             if (!grepl(pattern, name)) 
[18:05:01.241]                               next
[18:05:01.241]                             invokeRestart(restart)
[18:05:01.241]                             muffled <- TRUE
[18:05:01.241]                             break
[18:05:01.241]                           }
[18:05:01.241]                         }
[18:05:01.241]                       }
[18:05:01.241]                       invisible(muffled)
[18:05:01.241]                     }
[18:05:01.241]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.241]                   }
[18:05:01.241]                 }
[18:05:01.241]             }
[18:05:01.241]         }))
[18:05:01.241]     }, error = function(ex) {
[18:05:01.241]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:01.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.241]                 ...future.rng), started = ...future.startTime, 
[18:05:01.241]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:01.241]             version = "1.8"), class = "FutureResult")
[18:05:01.241]     }, finally = {
[18:05:01.241]         if (!identical(...future.workdir, getwd())) 
[18:05:01.241]             setwd(...future.workdir)
[18:05:01.241]         {
[18:05:01.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:01.241]                 ...future.oldOptions$nwarnings <- NULL
[18:05:01.241]             }
[18:05:01.241]             base::options(...future.oldOptions)
[18:05:01.241]             if (.Platform$OS.type == "windows") {
[18:05:01.241]                 old_names <- names(...future.oldEnvVars)
[18:05:01.241]                 envs <- base::Sys.getenv()
[18:05:01.241]                 names <- names(envs)
[18:05:01.241]                 common <- intersect(names, old_names)
[18:05:01.241]                 added <- setdiff(names, old_names)
[18:05:01.241]                 removed <- setdiff(old_names, names)
[18:05:01.241]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:01.241]                   envs[common]]
[18:05:01.241]                 NAMES <- toupper(changed)
[18:05:01.241]                 args <- list()
[18:05:01.241]                 for (kk in seq_along(NAMES)) {
[18:05:01.241]                   name <- changed[[kk]]
[18:05:01.241]                   NAME <- NAMES[[kk]]
[18:05:01.241]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.241]                     next
[18:05:01.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.241]                 }
[18:05:01.241]                 NAMES <- toupper(added)
[18:05:01.241]                 for (kk in seq_along(NAMES)) {
[18:05:01.241]                   name <- added[[kk]]
[18:05:01.241]                   NAME <- NAMES[[kk]]
[18:05:01.241]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.241]                     next
[18:05:01.241]                   args[[name]] <- ""
[18:05:01.241]                 }
[18:05:01.241]                 NAMES <- toupper(removed)
[18:05:01.241]                 for (kk in seq_along(NAMES)) {
[18:05:01.241]                   name <- removed[[kk]]
[18:05:01.241]                   NAME <- NAMES[[kk]]
[18:05:01.241]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.241]                     next
[18:05:01.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.241]                 }
[18:05:01.241]                 if (length(args) > 0) 
[18:05:01.241]                   base::do.call(base::Sys.setenv, args = args)
[18:05:01.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:01.241]             }
[18:05:01.241]             else {
[18:05:01.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:01.241]             }
[18:05:01.241]             {
[18:05:01.241]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:01.241]                   0L) {
[18:05:01.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:01.241]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:01.241]                   base::options(opts)
[18:05:01.241]                 }
[18:05:01.241]                 {
[18:05:01.241]                   {
[18:05:01.241]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:01.241]                     NULL
[18:05:01.241]                   }
[18:05:01.241]                   options(future.plan = NULL)
[18:05:01.241]                   if (is.na(NA_character_)) 
[18:05:01.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:01.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:01.241]                     .init = FALSE)
[18:05:01.241]                 }
[18:05:01.241]             }
[18:05:01.241]         }
[18:05:01.241]     })
[18:05:01.241]     if (TRUE) {
[18:05:01.241]         base::sink(type = "output", split = FALSE)
[18:05:01.241]         if (TRUE) {
[18:05:01.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:01.241]         }
[18:05:01.241]         else {
[18:05:01.241]             ...future.result["stdout"] <- base::list(NULL)
[18:05:01.241]         }
[18:05:01.241]         base::close(...future.stdout)
[18:05:01.241]         ...future.stdout <- NULL
[18:05:01.241]     }
[18:05:01.241]     ...future.result$conditions <- ...future.conditions
[18:05:01.241]     ...future.result$finished <- base::Sys.time()
[18:05:01.241]     ...future.result
[18:05:01.241] }
[18:05:01.246] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[18:05:01.249] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[18:05:01.310] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[18:05:01.310] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[18:05:01.311] MultisessionFuture started
[18:05:01.311] - Launch lazy future ... done
[18:05:01.312] run() for ‘MultisessionFuture’ ... done
[18:05:01.312] result() for ClusterFuture ...
[18:05:01.312] receiveMessageFromWorker() for ClusterFuture ...
[18:05:01.313] - Validating connection of MultisessionFuture
[18:05:01.356] - received message: FutureResult
[18:05:01.357] - Received FutureResult
[18:05:01.357] - Erased future from FutureRegistry
[18:05:01.357] result() for ClusterFuture ...
[18:05:01.357] - result already collected: FutureResult
[18:05:01.358] result() for ClusterFuture ... done
[18:05:01.358] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:01.358] result() for ClusterFuture ... done
[18:05:01.358] result() for ClusterFuture ...
[18:05:01.358] - result already collected: FutureResult
[18:05:01.359] result() for ClusterFuture ... done
value(b) = 2
[18:05:01.359] result() for ClusterFuture ...
[18:05:01.359] - result already collected: FutureResult
[18:05:01.360] result() for ClusterFuture ... done
[18:05:01.360] result() for ClusterFuture ...
[18:05:01.360] - result already collected: FutureResult
[18:05:01.360] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:01.361] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:01.361] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:01.362] 
[18:05:01.363] Searching for globals ... DONE
[18:05:01.363] - globals: [0] <none>
[18:05:01.363] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:01.364] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:01.364] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:01.366] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:05:01.366] Searching for globals ... DONE
[18:05:01.367] Resolving globals: TRUE
[18:05:01.368] Resolving any globals that are futures ...
[18:05:01.368] - globals: [3] ‘+’, ‘value’, ‘a’
[18:05:01.369] Resolving any globals that are futures ... DONE
[18:05:01.372] Resolving futures part of globals (recursively) ...
[18:05:01.372] resolve() on list ...
[18:05:01.372]  recursive: 99
[18:05:01.373]  length: 1
[18:05:01.374]  elements: ‘a’
[18:05:01.374] run() for ‘Future’ ...
[18:05:01.375] - state: ‘created’
[18:05:01.375] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:01.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:01.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:01.402]   - Field: ‘node’
[18:05:01.402]   - Field: ‘label’
[18:05:01.402]   - Field: ‘local’
[18:05:01.402]   - Field: ‘owner’
[18:05:01.402]   - Field: ‘envir’
[18:05:01.403]   - Field: ‘workers’
[18:05:01.403]   - Field: ‘packages’
[18:05:01.403]   - Field: ‘gc’
[18:05:01.403]   - Field: ‘conditions’
[18:05:01.403]   - Field: ‘persistent’
[18:05:01.404]   - Field: ‘expr’
[18:05:01.404]   - Field: ‘uuid’
[18:05:01.404]   - Field: ‘seed’
[18:05:01.404]   - Field: ‘version’
[18:05:01.404]   - Field: ‘result’
[18:05:01.405]   - Field: ‘asynchronous’
[18:05:01.405]   - Field: ‘calls’
[18:05:01.405]   - Field: ‘globals’
[18:05:01.405]   - Field: ‘stdout’
[18:05:01.405]   - Field: ‘earlySignal’
[18:05:01.406]   - Field: ‘lazy’
[18:05:01.406]   - Field: ‘state’
[18:05:01.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:01.406] - Launch lazy future ...
[18:05:01.407] Packages needed by the future expression (n = 0): <none>
[18:05:01.407] Packages needed by future strategies (n = 0): <none>
[18:05:01.408] {
[18:05:01.408]     {
[18:05:01.408]         {
[18:05:01.408]             ...future.startTime <- base::Sys.time()
[18:05:01.408]             {
[18:05:01.408]                 {
[18:05:01.408]                   {
[18:05:01.408]                     {
[18:05:01.408]                       base::local({
[18:05:01.408]                         has_future <- base::requireNamespace("future", 
[18:05:01.408]                           quietly = TRUE)
[18:05:01.408]                         if (has_future) {
[18:05:01.408]                           ns <- base::getNamespace("future")
[18:05:01.408]                           version <- ns[[".package"]][["version"]]
[18:05:01.408]                           if (is.null(version)) 
[18:05:01.408]                             version <- utils::packageVersion("future")
[18:05:01.408]                         }
[18:05:01.408]                         else {
[18:05:01.408]                           version <- NULL
[18:05:01.408]                         }
[18:05:01.408]                         if (!has_future || version < "1.8.0") {
[18:05:01.408]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:01.408]                             "", base::R.version$version.string), 
[18:05:01.408]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:01.408]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:01.408]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:01.408]                               "release", "version")], collapse = " "), 
[18:05:01.408]                             hostname = base::Sys.info()[["nodename"]])
[18:05:01.408]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:01.408]                             info)
[18:05:01.408]                           info <- base::paste(info, collapse = "; ")
[18:05:01.408]                           if (!has_future) {
[18:05:01.408]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:01.408]                               info)
[18:05:01.408]                           }
[18:05:01.408]                           else {
[18:05:01.408]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:01.408]                               info, version)
[18:05:01.408]                           }
[18:05:01.408]                           base::stop(msg)
[18:05:01.408]                         }
[18:05:01.408]                       })
[18:05:01.408]                     }
[18:05:01.408]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:01.408]                     base::options(mc.cores = 1L)
[18:05:01.408]                   }
[18:05:01.408]                   ...future.strategy.old <- future::plan("list")
[18:05:01.408]                   options(future.plan = NULL)
[18:05:01.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:01.408]                 }
[18:05:01.408]                 ...future.workdir <- getwd()
[18:05:01.408]             }
[18:05:01.408]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:01.408]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:01.408]         }
[18:05:01.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:01.408]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:01.408]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:01.408]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:01.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:01.408]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:01.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:01.408]             base::names(...future.oldOptions))
[18:05:01.408]     }
[18:05:01.408]     if (FALSE) {
[18:05:01.408]     }
[18:05:01.408]     else {
[18:05:01.408]         if (TRUE) {
[18:05:01.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:01.408]                 open = "w")
[18:05:01.408]         }
[18:05:01.408]         else {
[18:05:01.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:01.408]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:01.408]         }
[18:05:01.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:01.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:01.408]             base::sink(type = "output", split = FALSE)
[18:05:01.408]             base::close(...future.stdout)
[18:05:01.408]         }, add = TRUE)
[18:05:01.408]     }
[18:05:01.408]     ...future.frame <- base::sys.nframe()
[18:05:01.408]     ...future.conditions <- base::list()
[18:05:01.408]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:01.408]     if (FALSE) {
[18:05:01.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:01.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:01.408]     }
[18:05:01.408]     ...future.result <- base::tryCatch({
[18:05:01.408]         base::withCallingHandlers({
[18:05:01.408]             ...future.value <- base::withVisible(base::local({
[18:05:01.408]                 ...future.makeSendCondition <- base::local({
[18:05:01.408]                   sendCondition <- NULL
[18:05:01.408]                   function(frame = 1L) {
[18:05:01.408]                     if (is.function(sendCondition)) 
[18:05:01.408]                       return(sendCondition)
[18:05:01.408]                     ns <- getNamespace("parallel")
[18:05:01.408]                     if (exists("sendData", mode = "function", 
[18:05:01.408]                       envir = ns)) {
[18:05:01.408]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:01.408]                         envir = ns)
[18:05:01.408]                       envir <- sys.frame(frame)
[18:05:01.408]                       master <- NULL
[18:05:01.408]                       while (!identical(envir, .GlobalEnv) && 
[18:05:01.408]                         !identical(envir, emptyenv())) {
[18:05:01.408]                         if (exists("master", mode = "list", envir = envir, 
[18:05:01.408]                           inherits = FALSE)) {
[18:05:01.408]                           master <- get("master", mode = "list", 
[18:05:01.408]                             envir = envir, inherits = FALSE)
[18:05:01.408]                           if (inherits(master, c("SOCKnode", 
[18:05:01.408]                             "SOCK0node"))) {
[18:05:01.408]                             sendCondition <<- function(cond) {
[18:05:01.408]                               data <- list(type = "VALUE", value = cond, 
[18:05:01.408]                                 success = TRUE)
[18:05:01.408]                               parallel_sendData(master, data)
[18:05:01.408]                             }
[18:05:01.408]                             return(sendCondition)
[18:05:01.408]                           }
[18:05:01.408]                         }
[18:05:01.408]                         frame <- frame + 1L
[18:05:01.408]                         envir <- sys.frame(frame)
[18:05:01.408]                       }
[18:05:01.408]                     }
[18:05:01.408]                     sendCondition <<- function(cond) NULL
[18:05:01.408]                   }
[18:05:01.408]                 })
[18:05:01.408]                 withCallingHandlers({
[18:05:01.408]                   1
[18:05:01.408]                 }, immediateCondition = function(cond) {
[18:05:01.408]                   sendCondition <- ...future.makeSendCondition()
[18:05:01.408]                   sendCondition(cond)
[18:05:01.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.408]                   {
[18:05:01.408]                     inherits <- base::inherits
[18:05:01.408]                     invokeRestart <- base::invokeRestart
[18:05:01.408]                     is.null <- base::is.null
[18:05:01.408]                     muffled <- FALSE
[18:05:01.408]                     if (inherits(cond, "message")) {
[18:05:01.408]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:01.408]                       if (muffled) 
[18:05:01.408]                         invokeRestart("muffleMessage")
[18:05:01.408]                     }
[18:05:01.408]                     else if (inherits(cond, "warning")) {
[18:05:01.408]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:01.408]                       if (muffled) 
[18:05:01.408]                         invokeRestart("muffleWarning")
[18:05:01.408]                     }
[18:05:01.408]                     else if (inherits(cond, "condition")) {
[18:05:01.408]                       if (!is.null(pattern)) {
[18:05:01.408]                         computeRestarts <- base::computeRestarts
[18:05:01.408]                         grepl <- base::grepl
[18:05:01.408]                         restarts <- computeRestarts(cond)
[18:05:01.408]                         for (restart in restarts) {
[18:05:01.408]                           name <- restart$name
[18:05:01.408]                           if (is.null(name)) 
[18:05:01.408]                             next
[18:05:01.408]                           if (!grepl(pattern, name)) 
[18:05:01.408]                             next
[18:05:01.408]                           invokeRestart(restart)
[18:05:01.408]                           muffled <- TRUE
[18:05:01.408]                           break
[18:05:01.408]                         }
[18:05:01.408]                       }
[18:05:01.408]                     }
[18:05:01.408]                     invisible(muffled)
[18:05:01.408]                   }
[18:05:01.408]                   muffleCondition(cond)
[18:05:01.408]                 })
[18:05:01.408]             }))
[18:05:01.408]             future::FutureResult(value = ...future.value$value, 
[18:05:01.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.408]                   ...future.rng), globalenv = if (FALSE) 
[18:05:01.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:01.408]                     ...future.globalenv.names))
[18:05:01.408]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:01.408]         }, condition = base::local({
[18:05:01.408]             c <- base::c
[18:05:01.408]             inherits <- base::inherits
[18:05:01.408]             invokeRestart <- base::invokeRestart
[18:05:01.408]             length <- base::length
[18:05:01.408]             list <- base::list
[18:05:01.408]             seq.int <- base::seq.int
[18:05:01.408]             signalCondition <- base::signalCondition
[18:05:01.408]             sys.calls <- base::sys.calls
[18:05:01.408]             `[[` <- base::`[[`
[18:05:01.408]             `+` <- base::`+`
[18:05:01.408]             `<<-` <- base::`<<-`
[18:05:01.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:01.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:01.408]                   3L)]
[18:05:01.408]             }
[18:05:01.408]             function(cond) {
[18:05:01.408]                 is_error <- inherits(cond, "error")
[18:05:01.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:01.408]                   NULL)
[18:05:01.408]                 if (is_error) {
[18:05:01.408]                   sessionInformation <- function() {
[18:05:01.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:01.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:01.408]                       search = base::search(), system = base::Sys.info())
[18:05:01.408]                   }
[18:05:01.408]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:01.408]                     cond$call), session = sessionInformation(), 
[18:05:01.408]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:01.408]                   signalCondition(cond)
[18:05:01.408]                 }
[18:05:01.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:01.408]                 "immediateCondition"))) {
[18:05:01.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:01.408]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:01.408]                   if (TRUE && !signal) {
[18:05:01.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.408]                     {
[18:05:01.408]                       inherits <- base::inherits
[18:05:01.408]                       invokeRestart <- base::invokeRestart
[18:05:01.408]                       is.null <- base::is.null
[18:05:01.408]                       muffled <- FALSE
[18:05:01.408]                       if (inherits(cond, "message")) {
[18:05:01.408]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.408]                         if (muffled) 
[18:05:01.408]                           invokeRestart("muffleMessage")
[18:05:01.408]                       }
[18:05:01.408]                       else if (inherits(cond, "warning")) {
[18:05:01.408]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.408]                         if (muffled) 
[18:05:01.408]                           invokeRestart("muffleWarning")
[18:05:01.408]                       }
[18:05:01.408]                       else if (inherits(cond, "condition")) {
[18:05:01.408]                         if (!is.null(pattern)) {
[18:05:01.408]                           computeRestarts <- base::computeRestarts
[18:05:01.408]                           grepl <- base::grepl
[18:05:01.408]                           restarts <- computeRestarts(cond)
[18:05:01.408]                           for (restart in restarts) {
[18:05:01.408]                             name <- restart$name
[18:05:01.408]                             if (is.null(name)) 
[18:05:01.408]                               next
[18:05:01.408]                             if (!grepl(pattern, name)) 
[18:05:01.408]                               next
[18:05:01.408]                             invokeRestart(restart)
[18:05:01.408]                             muffled <- TRUE
[18:05:01.408]                             break
[18:05:01.408]                           }
[18:05:01.408]                         }
[18:05:01.408]                       }
[18:05:01.408]                       invisible(muffled)
[18:05:01.408]                     }
[18:05:01.408]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.408]                   }
[18:05:01.408]                 }
[18:05:01.408]                 else {
[18:05:01.408]                   if (TRUE) {
[18:05:01.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.408]                     {
[18:05:01.408]                       inherits <- base::inherits
[18:05:01.408]                       invokeRestart <- base::invokeRestart
[18:05:01.408]                       is.null <- base::is.null
[18:05:01.408]                       muffled <- FALSE
[18:05:01.408]                       if (inherits(cond, "message")) {
[18:05:01.408]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.408]                         if (muffled) 
[18:05:01.408]                           invokeRestart("muffleMessage")
[18:05:01.408]                       }
[18:05:01.408]                       else if (inherits(cond, "warning")) {
[18:05:01.408]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.408]                         if (muffled) 
[18:05:01.408]                           invokeRestart("muffleWarning")
[18:05:01.408]                       }
[18:05:01.408]                       else if (inherits(cond, "condition")) {
[18:05:01.408]                         if (!is.null(pattern)) {
[18:05:01.408]                           computeRestarts <- base::computeRestarts
[18:05:01.408]                           grepl <- base::grepl
[18:05:01.408]                           restarts <- computeRestarts(cond)
[18:05:01.408]                           for (restart in restarts) {
[18:05:01.408]                             name <- restart$name
[18:05:01.408]                             if (is.null(name)) 
[18:05:01.408]                               next
[18:05:01.408]                             if (!grepl(pattern, name)) 
[18:05:01.408]                               next
[18:05:01.408]                             invokeRestart(restart)
[18:05:01.408]                             muffled <- TRUE
[18:05:01.408]                             break
[18:05:01.408]                           }
[18:05:01.408]                         }
[18:05:01.408]                       }
[18:05:01.408]                       invisible(muffled)
[18:05:01.408]                     }
[18:05:01.408]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.408]                   }
[18:05:01.408]                 }
[18:05:01.408]             }
[18:05:01.408]         }))
[18:05:01.408]     }, error = function(ex) {
[18:05:01.408]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:01.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.408]                 ...future.rng), started = ...future.startTime, 
[18:05:01.408]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:01.408]             version = "1.8"), class = "FutureResult")
[18:05:01.408]     }, finally = {
[18:05:01.408]         if (!identical(...future.workdir, getwd())) 
[18:05:01.408]             setwd(...future.workdir)
[18:05:01.408]         {
[18:05:01.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:01.408]                 ...future.oldOptions$nwarnings <- NULL
[18:05:01.408]             }
[18:05:01.408]             base::options(...future.oldOptions)
[18:05:01.408]             if (.Platform$OS.type == "windows") {
[18:05:01.408]                 old_names <- names(...future.oldEnvVars)
[18:05:01.408]                 envs <- base::Sys.getenv()
[18:05:01.408]                 names <- names(envs)
[18:05:01.408]                 common <- intersect(names, old_names)
[18:05:01.408]                 added <- setdiff(names, old_names)
[18:05:01.408]                 removed <- setdiff(old_names, names)
[18:05:01.408]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:01.408]                   envs[common]]
[18:05:01.408]                 NAMES <- toupper(changed)
[18:05:01.408]                 args <- list()
[18:05:01.408]                 for (kk in seq_along(NAMES)) {
[18:05:01.408]                   name <- changed[[kk]]
[18:05:01.408]                   NAME <- NAMES[[kk]]
[18:05:01.408]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.408]                     next
[18:05:01.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.408]                 }
[18:05:01.408]                 NAMES <- toupper(added)
[18:05:01.408]                 for (kk in seq_along(NAMES)) {
[18:05:01.408]                   name <- added[[kk]]
[18:05:01.408]                   NAME <- NAMES[[kk]]
[18:05:01.408]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.408]                     next
[18:05:01.408]                   args[[name]] <- ""
[18:05:01.408]                 }
[18:05:01.408]                 NAMES <- toupper(removed)
[18:05:01.408]                 for (kk in seq_along(NAMES)) {
[18:05:01.408]                   name <- removed[[kk]]
[18:05:01.408]                   NAME <- NAMES[[kk]]
[18:05:01.408]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.408]                     next
[18:05:01.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.408]                 }
[18:05:01.408]                 if (length(args) > 0) 
[18:05:01.408]                   base::do.call(base::Sys.setenv, args = args)
[18:05:01.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:01.408]             }
[18:05:01.408]             else {
[18:05:01.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:01.408]             }
[18:05:01.408]             {
[18:05:01.408]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:01.408]                   0L) {
[18:05:01.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:01.408]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:01.408]                   base::options(opts)
[18:05:01.408]                 }
[18:05:01.408]                 {
[18:05:01.408]                   {
[18:05:01.408]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:01.408]                     NULL
[18:05:01.408]                   }
[18:05:01.408]                   options(future.plan = NULL)
[18:05:01.408]                   if (is.na(NA_character_)) 
[18:05:01.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:01.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:01.408]                     .init = FALSE)
[18:05:01.408]                 }
[18:05:01.408]             }
[18:05:01.408]         }
[18:05:01.408]     })
[18:05:01.408]     if (TRUE) {
[18:05:01.408]         base::sink(type = "output", split = FALSE)
[18:05:01.408]         if (TRUE) {
[18:05:01.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:01.408]         }
[18:05:01.408]         else {
[18:05:01.408]             ...future.result["stdout"] <- base::list(NULL)
[18:05:01.408]         }
[18:05:01.408]         base::close(...future.stdout)
[18:05:01.408]         ...future.stdout <- NULL
[18:05:01.408]     }
[18:05:01.408]     ...future.result$conditions <- ...future.conditions
[18:05:01.408]     ...future.result$finished <- base::Sys.time()
[18:05:01.408]     ...future.result
[18:05:01.408] }
[18:05:01.414] MultisessionFuture started
[18:05:01.414] - Launch lazy future ... done
[18:05:01.414] run() for ‘MultisessionFuture’ ... done
[18:05:01.458] receiveMessageFromWorker() for ClusterFuture ...
[18:05:01.459] - Validating connection of MultisessionFuture
[18:05:01.459] - received message: FutureResult
[18:05:01.459] - Received FutureResult
[18:05:01.460] - Erased future from FutureRegistry
[18:05:01.460] result() for ClusterFuture ...
[18:05:01.460] - result already collected: FutureResult
[18:05:01.460] result() for ClusterFuture ... done
[18:05:01.460] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:01.461] Future #1
[18:05:01.461] result() for ClusterFuture ...
[18:05:01.461] - result already collected: FutureResult
[18:05:01.461] result() for ClusterFuture ... done
[18:05:01.462] result() for ClusterFuture ...
[18:05:01.462] - result already collected: FutureResult
[18:05:01.462] result() for ClusterFuture ... done
[18:05:01.462] A MultisessionFuture was resolved
[18:05:01.463]  length: 0 (resolved future 1)
[18:05:01.463] resolve() on list ... DONE
[18:05:01.463] - globals: [1] ‘a’
[18:05:01.463] Resolving futures part of globals (recursively) ... DONE
[18:05:01.466] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[18:05:01.467] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[18:05:01.467] - globals: [1] ‘a’
[18:05:01.467] - packages: [1] ‘future’
[18:05:01.467] getGlobalsAndPackages() ... DONE
[18:05:01.468] run() for ‘Future’ ...
[18:05:01.468] - state: ‘created’
[18:05:01.469] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:01.494] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:01.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:01.495]   - Field: ‘node’
[18:05:01.495]   - Field: ‘label’
[18:05:01.495]   - Field: ‘local’
[18:05:01.496]   - Field: ‘owner’
[18:05:01.496]   - Field: ‘envir’
[18:05:01.496]   - Field: ‘workers’
[18:05:01.496]   - Field: ‘packages’
[18:05:01.496]   - Field: ‘gc’
[18:05:01.497]   - Field: ‘conditions’
[18:05:01.497]   - Field: ‘persistent’
[18:05:01.497]   - Field: ‘expr’
[18:05:01.497]   - Field: ‘uuid’
[18:05:01.497]   - Field: ‘seed’
[18:05:01.498]   - Field: ‘version’
[18:05:01.498]   - Field: ‘result’
[18:05:01.498]   - Field: ‘asynchronous’
[18:05:01.498]   - Field: ‘calls’
[18:05:01.498]   - Field: ‘globals’
[18:05:01.499]   - Field: ‘stdout’
[18:05:01.499]   - Field: ‘earlySignal’
[18:05:01.499]   - Field: ‘lazy’
[18:05:01.499]   - Field: ‘state’
[18:05:01.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:01.500] - Launch lazy future ...
[18:05:01.500] Packages needed by the future expression (n = 1): ‘future’
[18:05:01.501] Packages needed by future strategies (n = 0): <none>
[18:05:01.501] {
[18:05:01.501]     {
[18:05:01.501]         {
[18:05:01.501]             ...future.startTime <- base::Sys.time()
[18:05:01.501]             {
[18:05:01.501]                 {
[18:05:01.501]                   {
[18:05:01.501]                     {
[18:05:01.501]                       {
[18:05:01.501]                         base::local({
[18:05:01.501]                           has_future <- base::requireNamespace("future", 
[18:05:01.501]                             quietly = TRUE)
[18:05:01.501]                           if (has_future) {
[18:05:01.501]                             ns <- base::getNamespace("future")
[18:05:01.501]                             version <- ns[[".package"]][["version"]]
[18:05:01.501]                             if (is.null(version)) 
[18:05:01.501]                               version <- utils::packageVersion("future")
[18:05:01.501]                           }
[18:05:01.501]                           else {
[18:05:01.501]                             version <- NULL
[18:05:01.501]                           }
[18:05:01.501]                           if (!has_future || version < "1.8.0") {
[18:05:01.501]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:01.501]                               "", base::R.version$version.string), 
[18:05:01.501]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:01.501]                                 base::R.version$platform, 8 * 
[18:05:01.501]                                   base::.Machine$sizeof.pointer), 
[18:05:01.501]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:01.501]                                 "release", "version")], collapse = " "), 
[18:05:01.501]                               hostname = base::Sys.info()[["nodename"]])
[18:05:01.501]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:01.501]                               info)
[18:05:01.501]                             info <- base::paste(info, collapse = "; ")
[18:05:01.501]                             if (!has_future) {
[18:05:01.501]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:01.501]                                 info)
[18:05:01.501]                             }
[18:05:01.501]                             else {
[18:05:01.501]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:01.501]                                 info, version)
[18:05:01.501]                             }
[18:05:01.501]                             base::stop(msg)
[18:05:01.501]                           }
[18:05:01.501]                         })
[18:05:01.501]                       }
[18:05:01.501]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:01.501]                       base::options(mc.cores = 1L)
[18:05:01.501]                     }
[18:05:01.501]                     base::local({
[18:05:01.501]                       for (pkg in "future") {
[18:05:01.501]                         base::loadNamespace(pkg)
[18:05:01.501]                         base::library(pkg, character.only = TRUE)
[18:05:01.501]                       }
[18:05:01.501]                     })
[18:05:01.501]                   }
[18:05:01.501]                   ...future.strategy.old <- future::plan("list")
[18:05:01.501]                   options(future.plan = NULL)
[18:05:01.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:01.501]                 }
[18:05:01.501]                 ...future.workdir <- getwd()
[18:05:01.501]             }
[18:05:01.501]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:01.501]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:01.501]         }
[18:05:01.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:01.501]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:01.501]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:01.501]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:01.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:01.501]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:01.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:01.501]             base::names(...future.oldOptions))
[18:05:01.501]     }
[18:05:01.501]     if (FALSE) {
[18:05:01.501]     }
[18:05:01.501]     else {
[18:05:01.501]         if (TRUE) {
[18:05:01.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:01.501]                 open = "w")
[18:05:01.501]         }
[18:05:01.501]         else {
[18:05:01.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:01.501]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:01.501]         }
[18:05:01.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:01.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:01.501]             base::sink(type = "output", split = FALSE)
[18:05:01.501]             base::close(...future.stdout)
[18:05:01.501]         }, add = TRUE)
[18:05:01.501]     }
[18:05:01.501]     ...future.frame <- base::sys.nframe()
[18:05:01.501]     ...future.conditions <- base::list()
[18:05:01.501]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:01.501]     if (FALSE) {
[18:05:01.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:01.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:01.501]     }
[18:05:01.501]     ...future.result <- base::tryCatch({
[18:05:01.501]         base::withCallingHandlers({
[18:05:01.501]             ...future.value <- base::withVisible(base::local({
[18:05:01.501]                 ...future.makeSendCondition <- base::local({
[18:05:01.501]                   sendCondition <- NULL
[18:05:01.501]                   function(frame = 1L) {
[18:05:01.501]                     if (is.function(sendCondition)) 
[18:05:01.501]                       return(sendCondition)
[18:05:01.501]                     ns <- getNamespace("parallel")
[18:05:01.501]                     if (exists("sendData", mode = "function", 
[18:05:01.501]                       envir = ns)) {
[18:05:01.501]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:01.501]                         envir = ns)
[18:05:01.501]                       envir <- sys.frame(frame)
[18:05:01.501]                       master <- NULL
[18:05:01.501]                       while (!identical(envir, .GlobalEnv) && 
[18:05:01.501]                         !identical(envir, emptyenv())) {
[18:05:01.501]                         if (exists("master", mode = "list", envir = envir, 
[18:05:01.501]                           inherits = FALSE)) {
[18:05:01.501]                           master <- get("master", mode = "list", 
[18:05:01.501]                             envir = envir, inherits = FALSE)
[18:05:01.501]                           if (inherits(master, c("SOCKnode", 
[18:05:01.501]                             "SOCK0node"))) {
[18:05:01.501]                             sendCondition <<- function(cond) {
[18:05:01.501]                               data <- list(type = "VALUE", value = cond, 
[18:05:01.501]                                 success = TRUE)
[18:05:01.501]                               parallel_sendData(master, data)
[18:05:01.501]                             }
[18:05:01.501]                             return(sendCondition)
[18:05:01.501]                           }
[18:05:01.501]                         }
[18:05:01.501]                         frame <- frame + 1L
[18:05:01.501]                         envir <- sys.frame(frame)
[18:05:01.501]                       }
[18:05:01.501]                     }
[18:05:01.501]                     sendCondition <<- function(cond) NULL
[18:05:01.501]                   }
[18:05:01.501]                 })
[18:05:01.501]                 withCallingHandlers({
[18:05:01.501]                   value(a) + 1
[18:05:01.501]                 }, immediateCondition = function(cond) {
[18:05:01.501]                   sendCondition <- ...future.makeSendCondition()
[18:05:01.501]                   sendCondition(cond)
[18:05:01.501]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.501]                   {
[18:05:01.501]                     inherits <- base::inherits
[18:05:01.501]                     invokeRestart <- base::invokeRestart
[18:05:01.501]                     is.null <- base::is.null
[18:05:01.501]                     muffled <- FALSE
[18:05:01.501]                     if (inherits(cond, "message")) {
[18:05:01.501]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:01.501]                       if (muffled) 
[18:05:01.501]                         invokeRestart("muffleMessage")
[18:05:01.501]                     }
[18:05:01.501]                     else if (inherits(cond, "warning")) {
[18:05:01.501]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:01.501]                       if (muffled) 
[18:05:01.501]                         invokeRestart("muffleWarning")
[18:05:01.501]                     }
[18:05:01.501]                     else if (inherits(cond, "condition")) {
[18:05:01.501]                       if (!is.null(pattern)) {
[18:05:01.501]                         computeRestarts <- base::computeRestarts
[18:05:01.501]                         grepl <- base::grepl
[18:05:01.501]                         restarts <- computeRestarts(cond)
[18:05:01.501]                         for (restart in restarts) {
[18:05:01.501]                           name <- restart$name
[18:05:01.501]                           if (is.null(name)) 
[18:05:01.501]                             next
[18:05:01.501]                           if (!grepl(pattern, name)) 
[18:05:01.501]                             next
[18:05:01.501]                           invokeRestart(restart)
[18:05:01.501]                           muffled <- TRUE
[18:05:01.501]                           break
[18:05:01.501]                         }
[18:05:01.501]                       }
[18:05:01.501]                     }
[18:05:01.501]                     invisible(muffled)
[18:05:01.501]                   }
[18:05:01.501]                   muffleCondition(cond)
[18:05:01.501]                 })
[18:05:01.501]             }))
[18:05:01.501]             future::FutureResult(value = ...future.value$value, 
[18:05:01.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.501]                   ...future.rng), globalenv = if (FALSE) 
[18:05:01.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:01.501]                     ...future.globalenv.names))
[18:05:01.501]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:01.501]         }, condition = base::local({
[18:05:01.501]             c <- base::c
[18:05:01.501]             inherits <- base::inherits
[18:05:01.501]             invokeRestart <- base::invokeRestart
[18:05:01.501]             length <- base::length
[18:05:01.501]             list <- base::list
[18:05:01.501]             seq.int <- base::seq.int
[18:05:01.501]             signalCondition <- base::signalCondition
[18:05:01.501]             sys.calls <- base::sys.calls
[18:05:01.501]             `[[` <- base::`[[`
[18:05:01.501]             `+` <- base::`+`
[18:05:01.501]             `<<-` <- base::`<<-`
[18:05:01.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:01.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:01.501]                   3L)]
[18:05:01.501]             }
[18:05:01.501]             function(cond) {
[18:05:01.501]                 is_error <- inherits(cond, "error")
[18:05:01.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:01.501]                   NULL)
[18:05:01.501]                 if (is_error) {
[18:05:01.501]                   sessionInformation <- function() {
[18:05:01.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:01.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:01.501]                       search = base::search(), system = base::Sys.info())
[18:05:01.501]                   }
[18:05:01.501]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:01.501]                     cond$call), session = sessionInformation(), 
[18:05:01.501]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:01.501]                   signalCondition(cond)
[18:05:01.501]                 }
[18:05:01.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:01.501]                 "immediateCondition"))) {
[18:05:01.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:01.501]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:01.501]                   if (TRUE && !signal) {
[18:05:01.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.501]                     {
[18:05:01.501]                       inherits <- base::inherits
[18:05:01.501]                       invokeRestart <- base::invokeRestart
[18:05:01.501]                       is.null <- base::is.null
[18:05:01.501]                       muffled <- FALSE
[18:05:01.501]                       if (inherits(cond, "message")) {
[18:05:01.501]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.501]                         if (muffled) 
[18:05:01.501]                           invokeRestart("muffleMessage")
[18:05:01.501]                       }
[18:05:01.501]                       else if (inherits(cond, "warning")) {
[18:05:01.501]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.501]                         if (muffled) 
[18:05:01.501]                           invokeRestart("muffleWarning")
[18:05:01.501]                       }
[18:05:01.501]                       else if (inherits(cond, "condition")) {
[18:05:01.501]                         if (!is.null(pattern)) {
[18:05:01.501]                           computeRestarts <- base::computeRestarts
[18:05:01.501]                           grepl <- base::grepl
[18:05:01.501]                           restarts <- computeRestarts(cond)
[18:05:01.501]                           for (restart in restarts) {
[18:05:01.501]                             name <- restart$name
[18:05:01.501]                             if (is.null(name)) 
[18:05:01.501]                               next
[18:05:01.501]                             if (!grepl(pattern, name)) 
[18:05:01.501]                               next
[18:05:01.501]                             invokeRestart(restart)
[18:05:01.501]                             muffled <- TRUE
[18:05:01.501]                             break
[18:05:01.501]                           }
[18:05:01.501]                         }
[18:05:01.501]                       }
[18:05:01.501]                       invisible(muffled)
[18:05:01.501]                     }
[18:05:01.501]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.501]                   }
[18:05:01.501]                 }
[18:05:01.501]                 else {
[18:05:01.501]                   if (TRUE) {
[18:05:01.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.501]                     {
[18:05:01.501]                       inherits <- base::inherits
[18:05:01.501]                       invokeRestart <- base::invokeRestart
[18:05:01.501]                       is.null <- base::is.null
[18:05:01.501]                       muffled <- FALSE
[18:05:01.501]                       if (inherits(cond, "message")) {
[18:05:01.501]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.501]                         if (muffled) 
[18:05:01.501]                           invokeRestart("muffleMessage")
[18:05:01.501]                       }
[18:05:01.501]                       else if (inherits(cond, "warning")) {
[18:05:01.501]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.501]                         if (muffled) 
[18:05:01.501]                           invokeRestart("muffleWarning")
[18:05:01.501]                       }
[18:05:01.501]                       else if (inherits(cond, "condition")) {
[18:05:01.501]                         if (!is.null(pattern)) {
[18:05:01.501]                           computeRestarts <- base::computeRestarts
[18:05:01.501]                           grepl <- base::grepl
[18:05:01.501]                           restarts <- computeRestarts(cond)
[18:05:01.501]                           for (restart in restarts) {
[18:05:01.501]                             name <- restart$name
[18:05:01.501]                             if (is.null(name)) 
[18:05:01.501]                               next
[18:05:01.501]                             if (!grepl(pattern, name)) 
[18:05:01.501]                               next
[18:05:01.501]                             invokeRestart(restart)
[18:05:01.501]                             muffled <- TRUE
[18:05:01.501]                             break
[18:05:01.501]                           }
[18:05:01.501]                         }
[18:05:01.501]                       }
[18:05:01.501]                       invisible(muffled)
[18:05:01.501]                     }
[18:05:01.501]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.501]                   }
[18:05:01.501]                 }
[18:05:01.501]             }
[18:05:01.501]         }))
[18:05:01.501]     }, error = function(ex) {
[18:05:01.501]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:01.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.501]                 ...future.rng), started = ...future.startTime, 
[18:05:01.501]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:01.501]             version = "1.8"), class = "FutureResult")
[18:05:01.501]     }, finally = {
[18:05:01.501]         if (!identical(...future.workdir, getwd())) 
[18:05:01.501]             setwd(...future.workdir)
[18:05:01.501]         {
[18:05:01.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:01.501]                 ...future.oldOptions$nwarnings <- NULL
[18:05:01.501]             }
[18:05:01.501]             base::options(...future.oldOptions)
[18:05:01.501]             if (.Platform$OS.type == "windows") {
[18:05:01.501]                 old_names <- names(...future.oldEnvVars)
[18:05:01.501]                 envs <- base::Sys.getenv()
[18:05:01.501]                 names <- names(envs)
[18:05:01.501]                 common <- intersect(names, old_names)
[18:05:01.501]                 added <- setdiff(names, old_names)
[18:05:01.501]                 removed <- setdiff(old_names, names)
[18:05:01.501]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:01.501]                   envs[common]]
[18:05:01.501]                 NAMES <- toupper(changed)
[18:05:01.501]                 args <- list()
[18:05:01.501]                 for (kk in seq_along(NAMES)) {
[18:05:01.501]                   name <- changed[[kk]]
[18:05:01.501]                   NAME <- NAMES[[kk]]
[18:05:01.501]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.501]                     next
[18:05:01.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.501]                 }
[18:05:01.501]                 NAMES <- toupper(added)
[18:05:01.501]                 for (kk in seq_along(NAMES)) {
[18:05:01.501]                   name <- added[[kk]]
[18:05:01.501]                   NAME <- NAMES[[kk]]
[18:05:01.501]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.501]                     next
[18:05:01.501]                   args[[name]] <- ""
[18:05:01.501]                 }
[18:05:01.501]                 NAMES <- toupper(removed)
[18:05:01.501]                 for (kk in seq_along(NAMES)) {
[18:05:01.501]                   name <- removed[[kk]]
[18:05:01.501]                   NAME <- NAMES[[kk]]
[18:05:01.501]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.501]                     next
[18:05:01.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.501]                 }
[18:05:01.501]                 if (length(args) > 0) 
[18:05:01.501]                   base::do.call(base::Sys.setenv, args = args)
[18:05:01.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:01.501]             }
[18:05:01.501]             else {
[18:05:01.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:01.501]             }
[18:05:01.501]             {
[18:05:01.501]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:01.501]                   0L) {
[18:05:01.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:01.501]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:01.501]                   base::options(opts)
[18:05:01.501]                 }
[18:05:01.501]                 {
[18:05:01.501]                   {
[18:05:01.501]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:01.501]                     NULL
[18:05:01.501]                   }
[18:05:01.501]                   options(future.plan = NULL)
[18:05:01.501]                   if (is.na(NA_character_)) 
[18:05:01.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:01.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:01.501]                     .init = FALSE)
[18:05:01.501]                 }
[18:05:01.501]             }
[18:05:01.501]         }
[18:05:01.501]     })
[18:05:01.501]     if (TRUE) {
[18:05:01.501]         base::sink(type = "output", split = FALSE)
[18:05:01.501]         if (TRUE) {
[18:05:01.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:01.501]         }
[18:05:01.501]         else {
[18:05:01.501]             ...future.result["stdout"] <- base::list(NULL)
[18:05:01.501]         }
[18:05:01.501]         base::close(...future.stdout)
[18:05:01.501]         ...future.stdout <- NULL
[18:05:01.501]     }
[18:05:01.501]     ...future.result$conditions <- ...future.conditions
[18:05:01.501]     ...future.result$finished <- base::Sys.time()
[18:05:01.501]     ...future.result
[18:05:01.501] }
[18:05:01.507] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[18:05:01.509] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[18:05:01.569] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[18:05:01.569] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[18:05:01.570] MultisessionFuture started
[18:05:01.571] - Launch lazy future ... done
[18:05:01.571] run() for ‘MultisessionFuture’ ... done
[18:05:01.571] result() for ClusterFuture ...
[18:05:01.571] receiveMessageFromWorker() for ClusterFuture ...
[18:05:01.572] - Validating connection of MultisessionFuture
[18:05:01.616] - received message: FutureResult
[18:05:01.616] - Received FutureResult
[18:05:01.617] - Erased future from FutureRegistry
[18:05:01.617] result() for ClusterFuture ...
[18:05:01.617] - result already collected: FutureResult
[18:05:01.617] result() for ClusterFuture ... done
[18:05:01.617] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:01.618] result() for ClusterFuture ... done
[18:05:01.618] result() for ClusterFuture ...
[18:05:01.618] - result already collected: FutureResult
[18:05:01.618] result() for ClusterFuture ... done
value(b) = 2
[18:05:01.619] result() for ClusterFuture ...
[18:05:01.619] - result already collected: FutureResult
[18:05:01.619] result() for ClusterFuture ... done
[18:05:01.620] result() for ClusterFuture ...
[18:05:01.620] - result already collected: FutureResult
[18:05:01.620] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:01.620] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:01.621] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:01.622] 
[18:05:01.622] Searching for globals ... DONE
[18:05:01.623] - globals: [0] <none>
[18:05:01.623] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:01.624] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:01.624] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:01.626] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:05:01.627] Searching for globals ... DONE
[18:05:01.627] Resolving globals: TRUE
[18:05:01.627] Resolving any globals that are futures ...
[18:05:01.627] - globals: [3] ‘+’, ‘value’, ‘a’
[18:05:01.628] Resolving any globals that are futures ... DONE
[18:05:01.628] Resolving futures part of globals (recursively) ...
[18:05:01.629] resolve() on list ...
[18:05:01.629]  recursive: 99
[18:05:01.630]  length: 1
[18:05:01.630]  elements: ‘a’
[18:05:01.630] run() for ‘Future’ ...
[18:05:01.630] - state: ‘created’
[18:05:01.631] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:01.659] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:01.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:01.660]   - Field: ‘node’
[18:05:01.660]   - Field: ‘label’
[18:05:01.661]   - Field: ‘local’
[18:05:01.661]   - Field: ‘owner’
[18:05:01.661]   - Field: ‘envir’
[18:05:01.661]   - Field: ‘workers’
[18:05:01.661]   - Field: ‘packages’
[18:05:01.662]   - Field: ‘gc’
[18:05:01.662]   - Field: ‘conditions’
[18:05:01.662]   - Field: ‘persistent’
[18:05:01.665]   - Field: ‘expr’
[18:05:01.666]   - Field: ‘uuid’
[18:05:01.666]   - Field: ‘seed’
[18:05:01.666]   - Field: ‘version’
[18:05:01.666]   - Field: ‘result’
[18:05:01.666]   - Field: ‘asynchronous’
[18:05:01.667]   - Field: ‘calls’
[18:05:01.667]   - Field: ‘globals’
[18:05:01.667]   - Field: ‘stdout’
[18:05:01.667]   - Field: ‘earlySignal’
[18:05:01.667]   - Field: ‘lazy’
[18:05:01.668]   - Field: ‘state’
[18:05:01.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:01.668] - Launch lazy future ...
[18:05:01.669] Packages needed by the future expression (n = 0): <none>
[18:05:01.669] Packages needed by future strategies (n = 0): <none>
[18:05:01.670] {
[18:05:01.670]     {
[18:05:01.670]         {
[18:05:01.670]             ...future.startTime <- base::Sys.time()
[18:05:01.670]             {
[18:05:01.670]                 {
[18:05:01.670]                   {
[18:05:01.670]                     {
[18:05:01.670]                       base::local({
[18:05:01.670]                         has_future <- base::requireNamespace("future", 
[18:05:01.670]                           quietly = TRUE)
[18:05:01.670]                         if (has_future) {
[18:05:01.670]                           ns <- base::getNamespace("future")
[18:05:01.670]                           version <- ns[[".package"]][["version"]]
[18:05:01.670]                           if (is.null(version)) 
[18:05:01.670]                             version <- utils::packageVersion("future")
[18:05:01.670]                         }
[18:05:01.670]                         else {
[18:05:01.670]                           version <- NULL
[18:05:01.670]                         }
[18:05:01.670]                         if (!has_future || version < "1.8.0") {
[18:05:01.670]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:01.670]                             "", base::R.version$version.string), 
[18:05:01.670]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:01.670]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:01.670]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:01.670]                               "release", "version")], collapse = " "), 
[18:05:01.670]                             hostname = base::Sys.info()[["nodename"]])
[18:05:01.670]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:01.670]                             info)
[18:05:01.670]                           info <- base::paste(info, collapse = "; ")
[18:05:01.670]                           if (!has_future) {
[18:05:01.670]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:01.670]                               info)
[18:05:01.670]                           }
[18:05:01.670]                           else {
[18:05:01.670]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:01.670]                               info, version)
[18:05:01.670]                           }
[18:05:01.670]                           base::stop(msg)
[18:05:01.670]                         }
[18:05:01.670]                       })
[18:05:01.670]                     }
[18:05:01.670]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:01.670]                     base::options(mc.cores = 1L)
[18:05:01.670]                   }
[18:05:01.670]                   ...future.strategy.old <- future::plan("list")
[18:05:01.670]                   options(future.plan = NULL)
[18:05:01.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:01.670]                 }
[18:05:01.670]                 ...future.workdir <- getwd()
[18:05:01.670]             }
[18:05:01.670]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:01.670]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:01.670]         }
[18:05:01.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:01.670]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:01.670]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:01.670]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:01.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:01.670]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:01.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:01.670]             base::names(...future.oldOptions))
[18:05:01.670]     }
[18:05:01.670]     if (FALSE) {
[18:05:01.670]     }
[18:05:01.670]     else {
[18:05:01.670]         if (TRUE) {
[18:05:01.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:01.670]                 open = "w")
[18:05:01.670]         }
[18:05:01.670]         else {
[18:05:01.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:01.670]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:01.670]         }
[18:05:01.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:01.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:01.670]             base::sink(type = "output", split = FALSE)
[18:05:01.670]             base::close(...future.stdout)
[18:05:01.670]         }, add = TRUE)
[18:05:01.670]     }
[18:05:01.670]     ...future.frame <- base::sys.nframe()
[18:05:01.670]     ...future.conditions <- base::list()
[18:05:01.670]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:01.670]     if (FALSE) {
[18:05:01.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:01.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:01.670]     }
[18:05:01.670]     ...future.result <- base::tryCatch({
[18:05:01.670]         base::withCallingHandlers({
[18:05:01.670]             ...future.value <- base::withVisible(base::local({
[18:05:01.670]                 ...future.makeSendCondition <- base::local({
[18:05:01.670]                   sendCondition <- NULL
[18:05:01.670]                   function(frame = 1L) {
[18:05:01.670]                     if (is.function(sendCondition)) 
[18:05:01.670]                       return(sendCondition)
[18:05:01.670]                     ns <- getNamespace("parallel")
[18:05:01.670]                     if (exists("sendData", mode = "function", 
[18:05:01.670]                       envir = ns)) {
[18:05:01.670]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:01.670]                         envir = ns)
[18:05:01.670]                       envir <- sys.frame(frame)
[18:05:01.670]                       master <- NULL
[18:05:01.670]                       while (!identical(envir, .GlobalEnv) && 
[18:05:01.670]                         !identical(envir, emptyenv())) {
[18:05:01.670]                         if (exists("master", mode = "list", envir = envir, 
[18:05:01.670]                           inherits = FALSE)) {
[18:05:01.670]                           master <- get("master", mode = "list", 
[18:05:01.670]                             envir = envir, inherits = FALSE)
[18:05:01.670]                           if (inherits(master, c("SOCKnode", 
[18:05:01.670]                             "SOCK0node"))) {
[18:05:01.670]                             sendCondition <<- function(cond) {
[18:05:01.670]                               data <- list(type = "VALUE", value = cond, 
[18:05:01.670]                                 success = TRUE)
[18:05:01.670]                               parallel_sendData(master, data)
[18:05:01.670]                             }
[18:05:01.670]                             return(sendCondition)
[18:05:01.670]                           }
[18:05:01.670]                         }
[18:05:01.670]                         frame <- frame + 1L
[18:05:01.670]                         envir <- sys.frame(frame)
[18:05:01.670]                       }
[18:05:01.670]                     }
[18:05:01.670]                     sendCondition <<- function(cond) NULL
[18:05:01.670]                   }
[18:05:01.670]                 })
[18:05:01.670]                 withCallingHandlers({
[18:05:01.670]                   1
[18:05:01.670]                 }, immediateCondition = function(cond) {
[18:05:01.670]                   sendCondition <- ...future.makeSendCondition()
[18:05:01.670]                   sendCondition(cond)
[18:05:01.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.670]                   {
[18:05:01.670]                     inherits <- base::inherits
[18:05:01.670]                     invokeRestart <- base::invokeRestart
[18:05:01.670]                     is.null <- base::is.null
[18:05:01.670]                     muffled <- FALSE
[18:05:01.670]                     if (inherits(cond, "message")) {
[18:05:01.670]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:01.670]                       if (muffled) 
[18:05:01.670]                         invokeRestart("muffleMessage")
[18:05:01.670]                     }
[18:05:01.670]                     else if (inherits(cond, "warning")) {
[18:05:01.670]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:01.670]                       if (muffled) 
[18:05:01.670]                         invokeRestart("muffleWarning")
[18:05:01.670]                     }
[18:05:01.670]                     else if (inherits(cond, "condition")) {
[18:05:01.670]                       if (!is.null(pattern)) {
[18:05:01.670]                         computeRestarts <- base::computeRestarts
[18:05:01.670]                         grepl <- base::grepl
[18:05:01.670]                         restarts <- computeRestarts(cond)
[18:05:01.670]                         for (restart in restarts) {
[18:05:01.670]                           name <- restart$name
[18:05:01.670]                           if (is.null(name)) 
[18:05:01.670]                             next
[18:05:01.670]                           if (!grepl(pattern, name)) 
[18:05:01.670]                             next
[18:05:01.670]                           invokeRestart(restart)
[18:05:01.670]                           muffled <- TRUE
[18:05:01.670]                           break
[18:05:01.670]                         }
[18:05:01.670]                       }
[18:05:01.670]                     }
[18:05:01.670]                     invisible(muffled)
[18:05:01.670]                   }
[18:05:01.670]                   muffleCondition(cond)
[18:05:01.670]                 })
[18:05:01.670]             }))
[18:05:01.670]             future::FutureResult(value = ...future.value$value, 
[18:05:01.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.670]                   ...future.rng), globalenv = if (FALSE) 
[18:05:01.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:01.670]                     ...future.globalenv.names))
[18:05:01.670]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:01.670]         }, condition = base::local({
[18:05:01.670]             c <- base::c
[18:05:01.670]             inherits <- base::inherits
[18:05:01.670]             invokeRestart <- base::invokeRestart
[18:05:01.670]             length <- base::length
[18:05:01.670]             list <- base::list
[18:05:01.670]             seq.int <- base::seq.int
[18:05:01.670]             signalCondition <- base::signalCondition
[18:05:01.670]             sys.calls <- base::sys.calls
[18:05:01.670]             `[[` <- base::`[[`
[18:05:01.670]             `+` <- base::`+`
[18:05:01.670]             `<<-` <- base::`<<-`
[18:05:01.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:01.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:01.670]                   3L)]
[18:05:01.670]             }
[18:05:01.670]             function(cond) {
[18:05:01.670]                 is_error <- inherits(cond, "error")
[18:05:01.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:01.670]                   NULL)
[18:05:01.670]                 if (is_error) {
[18:05:01.670]                   sessionInformation <- function() {
[18:05:01.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:01.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:01.670]                       search = base::search(), system = base::Sys.info())
[18:05:01.670]                   }
[18:05:01.670]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:01.670]                     cond$call), session = sessionInformation(), 
[18:05:01.670]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:01.670]                   signalCondition(cond)
[18:05:01.670]                 }
[18:05:01.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:01.670]                 "immediateCondition"))) {
[18:05:01.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:01.670]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:01.670]                   if (TRUE && !signal) {
[18:05:01.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.670]                     {
[18:05:01.670]                       inherits <- base::inherits
[18:05:01.670]                       invokeRestart <- base::invokeRestart
[18:05:01.670]                       is.null <- base::is.null
[18:05:01.670]                       muffled <- FALSE
[18:05:01.670]                       if (inherits(cond, "message")) {
[18:05:01.670]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.670]                         if (muffled) 
[18:05:01.670]                           invokeRestart("muffleMessage")
[18:05:01.670]                       }
[18:05:01.670]                       else if (inherits(cond, "warning")) {
[18:05:01.670]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.670]                         if (muffled) 
[18:05:01.670]                           invokeRestart("muffleWarning")
[18:05:01.670]                       }
[18:05:01.670]                       else if (inherits(cond, "condition")) {
[18:05:01.670]                         if (!is.null(pattern)) {
[18:05:01.670]                           computeRestarts <- base::computeRestarts
[18:05:01.670]                           grepl <- base::grepl
[18:05:01.670]                           restarts <- computeRestarts(cond)
[18:05:01.670]                           for (restart in restarts) {
[18:05:01.670]                             name <- restart$name
[18:05:01.670]                             if (is.null(name)) 
[18:05:01.670]                               next
[18:05:01.670]                             if (!grepl(pattern, name)) 
[18:05:01.670]                               next
[18:05:01.670]                             invokeRestart(restart)
[18:05:01.670]                             muffled <- TRUE
[18:05:01.670]                             break
[18:05:01.670]                           }
[18:05:01.670]                         }
[18:05:01.670]                       }
[18:05:01.670]                       invisible(muffled)
[18:05:01.670]                     }
[18:05:01.670]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.670]                   }
[18:05:01.670]                 }
[18:05:01.670]                 else {
[18:05:01.670]                   if (TRUE) {
[18:05:01.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.670]                     {
[18:05:01.670]                       inherits <- base::inherits
[18:05:01.670]                       invokeRestart <- base::invokeRestart
[18:05:01.670]                       is.null <- base::is.null
[18:05:01.670]                       muffled <- FALSE
[18:05:01.670]                       if (inherits(cond, "message")) {
[18:05:01.670]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.670]                         if (muffled) 
[18:05:01.670]                           invokeRestart("muffleMessage")
[18:05:01.670]                       }
[18:05:01.670]                       else if (inherits(cond, "warning")) {
[18:05:01.670]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.670]                         if (muffled) 
[18:05:01.670]                           invokeRestart("muffleWarning")
[18:05:01.670]                       }
[18:05:01.670]                       else if (inherits(cond, "condition")) {
[18:05:01.670]                         if (!is.null(pattern)) {
[18:05:01.670]                           computeRestarts <- base::computeRestarts
[18:05:01.670]                           grepl <- base::grepl
[18:05:01.670]                           restarts <- computeRestarts(cond)
[18:05:01.670]                           for (restart in restarts) {
[18:05:01.670]                             name <- restart$name
[18:05:01.670]                             if (is.null(name)) 
[18:05:01.670]                               next
[18:05:01.670]                             if (!grepl(pattern, name)) 
[18:05:01.670]                               next
[18:05:01.670]                             invokeRestart(restart)
[18:05:01.670]                             muffled <- TRUE
[18:05:01.670]                             break
[18:05:01.670]                           }
[18:05:01.670]                         }
[18:05:01.670]                       }
[18:05:01.670]                       invisible(muffled)
[18:05:01.670]                     }
[18:05:01.670]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.670]                   }
[18:05:01.670]                 }
[18:05:01.670]             }
[18:05:01.670]         }))
[18:05:01.670]     }, error = function(ex) {
[18:05:01.670]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:01.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.670]                 ...future.rng), started = ...future.startTime, 
[18:05:01.670]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:01.670]             version = "1.8"), class = "FutureResult")
[18:05:01.670]     }, finally = {
[18:05:01.670]         if (!identical(...future.workdir, getwd())) 
[18:05:01.670]             setwd(...future.workdir)
[18:05:01.670]         {
[18:05:01.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:01.670]                 ...future.oldOptions$nwarnings <- NULL
[18:05:01.670]             }
[18:05:01.670]             base::options(...future.oldOptions)
[18:05:01.670]             if (.Platform$OS.type == "windows") {
[18:05:01.670]                 old_names <- names(...future.oldEnvVars)
[18:05:01.670]                 envs <- base::Sys.getenv()
[18:05:01.670]                 names <- names(envs)
[18:05:01.670]                 common <- intersect(names, old_names)
[18:05:01.670]                 added <- setdiff(names, old_names)
[18:05:01.670]                 removed <- setdiff(old_names, names)
[18:05:01.670]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:01.670]                   envs[common]]
[18:05:01.670]                 NAMES <- toupper(changed)
[18:05:01.670]                 args <- list()
[18:05:01.670]                 for (kk in seq_along(NAMES)) {
[18:05:01.670]                   name <- changed[[kk]]
[18:05:01.670]                   NAME <- NAMES[[kk]]
[18:05:01.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.670]                     next
[18:05:01.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.670]                 }
[18:05:01.670]                 NAMES <- toupper(added)
[18:05:01.670]                 for (kk in seq_along(NAMES)) {
[18:05:01.670]                   name <- added[[kk]]
[18:05:01.670]                   NAME <- NAMES[[kk]]
[18:05:01.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.670]                     next
[18:05:01.670]                   args[[name]] <- ""
[18:05:01.670]                 }
[18:05:01.670]                 NAMES <- toupper(removed)
[18:05:01.670]                 for (kk in seq_along(NAMES)) {
[18:05:01.670]                   name <- removed[[kk]]
[18:05:01.670]                   NAME <- NAMES[[kk]]
[18:05:01.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.670]                     next
[18:05:01.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.670]                 }
[18:05:01.670]                 if (length(args) > 0) 
[18:05:01.670]                   base::do.call(base::Sys.setenv, args = args)
[18:05:01.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:01.670]             }
[18:05:01.670]             else {
[18:05:01.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:01.670]             }
[18:05:01.670]             {
[18:05:01.670]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:01.670]                   0L) {
[18:05:01.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:01.670]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:01.670]                   base::options(opts)
[18:05:01.670]                 }
[18:05:01.670]                 {
[18:05:01.670]                   {
[18:05:01.670]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:01.670]                     NULL
[18:05:01.670]                   }
[18:05:01.670]                   options(future.plan = NULL)
[18:05:01.670]                   if (is.na(NA_character_)) 
[18:05:01.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:01.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:01.670]                     .init = FALSE)
[18:05:01.670]                 }
[18:05:01.670]             }
[18:05:01.670]         }
[18:05:01.670]     })
[18:05:01.670]     if (TRUE) {
[18:05:01.670]         base::sink(type = "output", split = FALSE)
[18:05:01.670]         if (TRUE) {
[18:05:01.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:01.670]         }
[18:05:01.670]         else {
[18:05:01.670]             ...future.result["stdout"] <- base::list(NULL)
[18:05:01.670]         }
[18:05:01.670]         base::close(...future.stdout)
[18:05:01.670]         ...future.stdout <- NULL
[18:05:01.670]     }
[18:05:01.670]     ...future.result$conditions <- ...future.conditions
[18:05:01.670]     ...future.result$finished <- base::Sys.time()
[18:05:01.670]     ...future.result
[18:05:01.670] }
[18:05:01.676] MultisessionFuture started
[18:05:01.676] - Launch lazy future ... done
[18:05:01.677] run() for ‘MultisessionFuture’ ... done
[18:05:01.720] receiveMessageFromWorker() for ClusterFuture ...
[18:05:01.721] - Validating connection of MultisessionFuture
[18:05:01.721] - received message: FutureResult
[18:05:01.722] - Received FutureResult
[18:05:01.722] - Erased future from FutureRegistry
[18:05:01.722] result() for ClusterFuture ...
[18:05:01.723] - result already collected: FutureResult
[18:05:01.723] result() for ClusterFuture ... done
[18:05:01.723] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:01.724] Future #1
[18:05:01.724] result() for ClusterFuture ...
[18:05:01.724] - result already collected: FutureResult
[18:05:01.724] result() for ClusterFuture ... done
[18:05:01.725] result() for ClusterFuture ...
[18:05:01.725] - result already collected: FutureResult
[18:05:01.725] result() for ClusterFuture ... done
[18:05:01.726] A MultisessionFuture was resolved
[18:05:01.726]  length: 0 (resolved future 1)
[18:05:01.727] resolve() on list ... DONE
[18:05:01.727] - globals: [1] ‘a’
[18:05:01.727] Resolving futures part of globals (recursively) ... DONE
[18:05:01.730] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[18:05:01.731] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[18:05:01.732] - globals: [1] ‘a’
[18:05:01.732] - packages: [1] ‘future’
[18:05:01.732] getGlobalsAndPackages() ... DONE
[18:05:01.733] run() for ‘Future’ ...
[18:05:01.733] - state: ‘created’
[18:05:01.734] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:01.760] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:01.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:01.761]   - Field: ‘node’
[18:05:01.761]   - Field: ‘label’
[18:05:01.761]   - Field: ‘local’
[18:05:01.761]   - Field: ‘owner’
[18:05:01.762]   - Field: ‘envir’
[18:05:01.762]   - Field: ‘workers’
[18:05:01.762]   - Field: ‘packages’
[18:05:01.762]   - Field: ‘gc’
[18:05:01.762]   - Field: ‘conditions’
[18:05:01.763]   - Field: ‘persistent’
[18:05:01.763]   - Field: ‘expr’
[18:05:01.763]   - Field: ‘uuid’
[18:05:01.763]   - Field: ‘seed’
[18:05:01.763]   - Field: ‘version’
[18:05:01.764]   - Field: ‘result’
[18:05:01.764]   - Field: ‘asynchronous’
[18:05:01.764]   - Field: ‘calls’
[18:05:01.764]   - Field: ‘globals’
[18:05:01.765]   - Field: ‘stdout’
[18:05:01.765]   - Field: ‘earlySignal’
[18:05:01.765]   - Field: ‘lazy’
[18:05:01.765]   - Field: ‘state’
[18:05:01.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:01.766] - Launch lazy future ...
[18:05:01.766] Packages needed by the future expression (n = 1): ‘future’
[18:05:01.766] Packages needed by future strategies (n = 0): <none>
[18:05:01.767] {
[18:05:01.767]     {
[18:05:01.767]         {
[18:05:01.767]             ...future.startTime <- base::Sys.time()
[18:05:01.767]             {
[18:05:01.767]                 {
[18:05:01.767]                   {
[18:05:01.767]                     {
[18:05:01.767]                       {
[18:05:01.767]                         base::local({
[18:05:01.767]                           has_future <- base::requireNamespace("future", 
[18:05:01.767]                             quietly = TRUE)
[18:05:01.767]                           if (has_future) {
[18:05:01.767]                             ns <- base::getNamespace("future")
[18:05:01.767]                             version <- ns[[".package"]][["version"]]
[18:05:01.767]                             if (is.null(version)) 
[18:05:01.767]                               version <- utils::packageVersion("future")
[18:05:01.767]                           }
[18:05:01.767]                           else {
[18:05:01.767]                             version <- NULL
[18:05:01.767]                           }
[18:05:01.767]                           if (!has_future || version < "1.8.0") {
[18:05:01.767]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:01.767]                               "", base::R.version$version.string), 
[18:05:01.767]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:01.767]                                 base::R.version$platform, 8 * 
[18:05:01.767]                                   base::.Machine$sizeof.pointer), 
[18:05:01.767]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:01.767]                                 "release", "version")], collapse = " "), 
[18:05:01.767]                               hostname = base::Sys.info()[["nodename"]])
[18:05:01.767]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:01.767]                               info)
[18:05:01.767]                             info <- base::paste(info, collapse = "; ")
[18:05:01.767]                             if (!has_future) {
[18:05:01.767]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:01.767]                                 info)
[18:05:01.767]                             }
[18:05:01.767]                             else {
[18:05:01.767]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:01.767]                                 info, version)
[18:05:01.767]                             }
[18:05:01.767]                             base::stop(msg)
[18:05:01.767]                           }
[18:05:01.767]                         })
[18:05:01.767]                       }
[18:05:01.767]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:01.767]                       base::options(mc.cores = 1L)
[18:05:01.767]                     }
[18:05:01.767]                     base::local({
[18:05:01.767]                       for (pkg in "future") {
[18:05:01.767]                         base::loadNamespace(pkg)
[18:05:01.767]                         base::library(pkg, character.only = TRUE)
[18:05:01.767]                       }
[18:05:01.767]                     })
[18:05:01.767]                   }
[18:05:01.767]                   ...future.strategy.old <- future::plan("list")
[18:05:01.767]                   options(future.plan = NULL)
[18:05:01.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:01.767]                 }
[18:05:01.767]                 ...future.workdir <- getwd()
[18:05:01.767]             }
[18:05:01.767]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:01.767]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:01.767]         }
[18:05:01.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:01.767]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:01.767]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:01.767]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:01.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:01.767]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:01.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:01.767]             base::names(...future.oldOptions))
[18:05:01.767]     }
[18:05:01.767]     if (FALSE) {
[18:05:01.767]     }
[18:05:01.767]     else {
[18:05:01.767]         if (TRUE) {
[18:05:01.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:01.767]                 open = "w")
[18:05:01.767]         }
[18:05:01.767]         else {
[18:05:01.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:01.767]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:01.767]         }
[18:05:01.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:01.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:01.767]             base::sink(type = "output", split = FALSE)
[18:05:01.767]             base::close(...future.stdout)
[18:05:01.767]         }, add = TRUE)
[18:05:01.767]     }
[18:05:01.767]     ...future.frame <- base::sys.nframe()
[18:05:01.767]     ...future.conditions <- base::list()
[18:05:01.767]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:01.767]     if (FALSE) {
[18:05:01.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:01.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:01.767]     }
[18:05:01.767]     ...future.result <- base::tryCatch({
[18:05:01.767]         base::withCallingHandlers({
[18:05:01.767]             ...future.value <- base::withVisible(base::local({
[18:05:01.767]                 ...future.makeSendCondition <- base::local({
[18:05:01.767]                   sendCondition <- NULL
[18:05:01.767]                   function(frame = 1L) {
[18:05:01.767]                     if (is.function(sendCondition)) 
[18:05:01.767]                       return(sendCondition)
[18:05:01.767]                     ns <- getNamespace("parallel")
[18:05:01.767]                     if (exists("sendData", mode = "function", 
[18:05:01.767]                       envir = ns)) {
[18:05:01.767]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:01.767]                         envir = ns)
[18:05:01.767]                       envir <- sys.frame(frame)
[18:05:01.767]                       master <- NULL
[18:05:01.767]                       while (!identical(envir, .GlobalEnv) && 
[18:05:01.767]                         !identical(envir, emptyenv())) {
[18:05:01.767]                         if (exists("master", mode = "list", envir = envir, 
[18:05:01.767]                           inherits = FALSE)) {
[18:05:01.767]                           master <- get("master", mode = "list", 
[18:05:01.767]                             envir = envir, inherits = FALSE)
[18:05:01.767]                           if (inherits(master, c("SOCKnode", 
[18:05:01.767]                             "SOCK0node"))) {
[18:05:01.767]                             sendCondition <<- function(cond) {
[18:05:01.767]                               data <- list(type = "VALUE", value = cond, 
[18:05:01.767]                                 success = TRUE)
[18:05:01.767]                               parallel_sendData(master, data)
[18:05:01.767]                             }
[18:05:01.767]                             return(sendCondition)
[18:05:01.767]                           }
[18:05:01.767]                         }
[18:05:01.767]                         frame <- frame + 1L
[18:05:01.767]                         envir <- sys.frame(frame)
[18:05:01.767]                       }
[18:05:01.767]                     }
[18:05:01.767]                     sendCondition <<- function(cond) NULL
[18:05:01.767]                   }
[18:05:01.767]                 })
[18:05:01.767]                 withCallingHandlers({
[18:05:01.767]                   value(a) + 1
[18:05:01.767]                 }, immediateCondition = function(cond) {
[18:05:01.767]                   sendCondition <- ...future.makeSendCondition()
[18:05:01.767]                   sendCondition(cond)
[18:05:01.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.767]                   {
[18:05:01.767]                     inherits <- base::inherits
[18:05:01.767]                     invokeRestart <- base::invokeRestart
[18:05:01.767]                     is.null <- base::is.null
[18:05:01.767]                     muffled <- FALSE
[18:05:01.767]                     if (inherits(cond, "message")) {
[18:05:01.767]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:01.767]                       if (muffled) 
[18:05:01.767]                         invokeRestart("muffleMessage")
[18:05:01.767]                     }
[18:05:01.767]                     else if (inherits(cond, "warning")) {
[18:05:01.767]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:01.767]                       if (muffled) 
[18:05:01.767]                         invokeRestart("muffleWarning")
[18:05:01.767]                     }
[18:05:01.767]                     else if (inherits(cond, "condition")) {
[18:05:01.767]                       if (!is.null(pattern)) {
[18:05:01.767]                         computeRestarts <- base::computeRestarts
[18:05:01.767]                         grepl <- base::grepl
[18:05:01.767]                         restarts <- computeRestarts(cond)
[18:05:01.767]                         for (restart in restarts) {
[18:05:01.767]                           name <- restart$name
[18:05:01.767]                           if (is.null(name)) 
[18:05:01.767]                             next
[18:05:01.767]                           if (!grepl(pattern, name)) 
[18:05:01.767]                             next
[18:05:01.767]                           invokeRestart(restart)
[18:05:01.767]                           muffled <- TRUE
[18:05:01.767]                           break
[18:05:01.767]                         }
[18:05:01.767]                       }
[18:05:01.767]                     }
[18:05:01.767]                     invisible(muffled)
[18:05:01.767]                   }
[18:05:01.767]                   muffleCondition(cond)
[18:05:01.767]                 })
[18:05:01.767]             }))
[18:05:01.767]             future::FutureResult(value = ...future.value$value, 
[18:05:01.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.767]                   ...future.rng), globalenv = if (FALSE) 
[18:05:01.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:01.767]                     ...future.globalenv.names))
[18:05:01.767]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:01.767]         }, condition = base::local({
[18:05:01.767]             c <- base::c
[18:05:01.767]             inherits <- base::inherits
[18:05:01.767]             invokeRestart <- base::invokeRestart
[18:05:01.767]             length <- base::length
[18:05:01.767]             list <- base::list
[18:05:01.767]             seq.int <- base::seq.int
[18:05:01.767]             signalCondition <- base::signalCondition
[18:05:01.767]             sys.calls <- base::sys.calls
[18:05:01.767]             `[[` <- base::`[[`
[18:05:01.767]             `+` <- base::`+`
[18:05:01.767]             `<<-` <- base::`<<-`
[18:05:01.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:01.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:01.767]                   3L)]
[18:05:01.767]             }
[18:05:01.767]             function(cond) {
[18:05:01.767]                 is_error <- inherits(cond, "error")
[18:05:01.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:01.767]                   NULL)
[18:05:01.767]                 if (is_error) {
[18:05:01.767]                   sessionInformation <- function() {
[18:05:01.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:01.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:01.767]                       search = base::search(), system = base::Sys.info())
[18:05:01.767]                   }
[18:05:01.767]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:01.767]                     cond$call), session = sessionInformation(), 
[18:05:01.767]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:01.767]                   signalCondition(cond)
[18:05:01.767]                 }
[18:05:01.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:01.767]                 "immediateCondition"))) {
[18:05:01.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:01.767]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:01.767]                   if (TRUE && !signal) {
[18:05:01.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.767]                     {
[18:05:01.767]                       inherits <- base::inherits
[18:05:01.767]                       invokeRestart <- base::invokeRestart
[18:05:01.767]                       is.null <- base::is.null
[18:05:01.767]                       muffled <- FALSE
[18:05:01.767]                       if (inherits(cond, "message")) {
[18:05:01.767]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.767]                         if (muffled) 
[18:05:01.767]                           invokeRestart("muffleMessage")
[18:05:01.767]                       }
[18:05:01.767]                       else if (inherits(cond, "warning")) {
[18:05:01.767]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.767]                         if (muffled) 
[18:05:01.767]                           invokeRestart("muffleWarning")
[18:05:01.767]                       }
[18:05:01.767]                       else if (inherits(cond, "condition")) {
[18:05:01.767]                         if (!is.null(pattern)) {
[18:05:01.767]                           computeRestarts <- base::computeRestarts
[18:05:01.767]                           grepl <- base::grepl
[18:05:01.767]                           restarts <- computeRestarts(cond)
[18:05:01.767]                           for (restart in restarts) {
[18:05:01.767]                             name <- restart$name
[18:05:01.767]                             if (is.null(name)) 
[18:05:01.767]                               next
[18:05:01.767]                             if (!grepl(pattern, name)) 
[18:05:01.767]                               next
[18:05:01.767]                             invokeRestart(restart)
[18:05:01.767]                             muffled <- TRUE
[18:05:01.767]                             break
[18:05:01.767]                           }
[18:05:01.767]                         }
[18:05:01.767]                       }
[18:05:01.767]                       invisible(muffled)
[18:05:01.767]                     }
[18:05:01.767]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.767]                   }
[18:05:01.767]                 }
[18:05:01.767]                 else {
[18:05:01.767]                   if (TRUE) {
[18:05:01.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.767]                     {
[18:05:01.767]                       inherits <- base::inherits
[18:05:01.767]                       invokeRestart <- base::invokeRestart
[18:05:01.767]                       is.null <- base::is.null
[18:05:01.767]                       muffled <- FALSE
[18:05:01.767]                       if (inherits(cond, "message")) {
[18:05:01.767]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.767]                         if (muffled) 
[18:05:01.767]                           invokeRestart("muffleMessage")
[18:05:01.767]                       }
[18:05:01.767]                       else if (inherits(cond, "warning")) {
[18:05:01.767]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.767]                         if (muffled) 
[18:05:01.767]                           invokeRestart("muffleWarning")
[18:05:01.767]                       }
[18:05:01.767]                       else if (inherits(cond, "condition")) {
[18:05:01.767]                         if (!is.null(pattern)) {
[18:05:01.767]                           computeRestarts <- base::computeRestarts
[18:05:01.767]                           grepl <- base::grepl
[18:05:01.767]                           restarts <- computeRestarts(cond)
[18:05:01.767]                           for (restart in restarts) {
[18:05:01.767]                             name <- restart$name
[18:05:01.767]                             if (is.null(name)) 
[18:05:01.767]                               next
[18:05:01.767]                             if (!grepl(pattern, name)) 
[18:05:01.767]                               next
[18:05:01.767]                             invokeRestart(restart)
[18:05:01.767]                             muffled <- TRUE
[18:05:01.767]                             break
[18:05:01.767]                           }
[18:05:01.767]                         }
[18:05:01.767]                       }
[18:05:01.767]                       invisible(muffled)
[18:05:01.767]                     }
[18:05:01.767]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.767]                   }
[18:05:01.767]                 }
[18:05:01.767]             }
[18:05:01.767]         }))
[18:05:01.767]     }, error = function(ex) {
[18:05:01.767]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:01.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.767]                 ...future.rng), started = ...future.startTime, 
[18:05:01.767]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:01.767]             version = "1.8"), class = "FutureResult")
[18:05:01.767]     }, finally = {
[18:05:01.767]         if (!identical(...future.workdir, getwd())) 
[18:05:01.767]             setwd(...future.workdir)
[18:05:01.767]         {
[18:05:01.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:01.767]                 ...future.oldOptions$nwarnings <- NULL
[18:05:01.767]             }
[18:05:01.767]             base::options(...future.oldOptions)
[18:05:01.767]             if (.Platform$OS.type == "windows") {
[18:05:01.767]                 old_names <- names(...future.oldEnvVars)
[18:05:01.767]                 envs <- base::Sys.getenv()
[18:05:01.767]                 names <- names(envs)
[18:05:01.767]                 common <- intersect(names, old_names)
[18:05:01.767]                 added <- setdiff(names, old_names)
[18:05:01.767]                 removed <- setdiff(old_names, names)
[18:05:01.767]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:01.767]                   envs[common]]
[18:05:01.767]                 NAMES <- toupper(changed)
[18:05:01.767]                 args <- list()
[18:05:01.767]                 for (kk in seq_along(NAMES)) {
[18:05:01.767]                   name <- changed[[kk]]
[18:05:01.767]                   NAME <- NAMES[[kk]]
[18:05:01.767]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.767]                     next
[18:05:01.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.767]                 }
[18:05:01.767]                 NAMES <- toupper(added)
[18:05:01.767]                 for (kk in seq_along(NAMES)) {
[18:05:01.767]                   name <- added[[kk]]
[18:05:01.767]                   NAME <- NAMES[[kk]]
[18:05:01.767]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.767]                     next
[18:05:01.767]                   args[[name]] <- ""
[18:05:01.767]                 }
[18:05:01.767]                 NAMES <- toupper(removed)
[18:05:01.767]                 for (kk in seq_along(NAMES)) {
[18:05:01.767]                   name <- removed[[kk]]
[18:05:01.767]                   NAME <- NAMES[[kk]]
[18:05:01.767]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.767]                     next
[18:05:01.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.767]                 }
[18:05:01.767]                 if (length(args) > 0) 
[18:05:01.767]                   base::do.call(base::Sys.setenv, args = args)
[18:05:01.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:01.767]             }
[18:05:01.767]             else {
[18:05:01.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:01.767]             }
[18:05:01.767]             {
[18:05:01.767]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:01.767]                   0L) {
[18:05:01.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:01.767]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:01.767]                   base::options(opts)
[18:05:01.767]                 }
[18:05:01.767]                 {
[18:05:01.767]                   {
[18:05:01.767]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:01.767]                     NULL
[18:05:01.767]                   }
[18:05:01.767]                   options(future.plan = NULL)
[18:05:01.767]                   if (is.na(NA_character_)) 
[18:05:01.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:01.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:01.767]                     .init = FALSE)
[18:05:01.767]                 }
[18:05:01.767]             }
[18:05:01.767]         }
[18:05:01.767]     })
[18:05:01.767]     if (TRUE) {
[18:05:01.767]         base::sink(type = "output", split = FALSE)
[18:05:01.767]         if (TRUE) {
[18:05:01.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:01.767]         }
[18:05:01.767]         else {
[18:05:01.767]             ...future.result["stdout"] <- base::list(NULL)
[18:05:01.767]         }
[18:05:01.767]         base::close(...future.stdout)
[18:05:01.767]         ...future.stdout <- NULL
[18:05:01.767]     }
[18:05:01.767]     ...future.result$conditions <- ...future.conditions
[18:05:01.767]     ...future.result$finished <- base::Sys.time()
[18:05:01.767]     ...future.result
[18:05:01.767] }
[18:05:01.773] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[18:05:01.775] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[18:05:01.834] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[18:05:01.835] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[18:05:01.836] MultisessionFuture started
[18:05:01.836] - Launch lazy future ... done
[18:05:01.836] run() for ‘MultisessionFuture’ ... done
[18:05:01.837] result() for ClusterFuture ...
[18:05:01.837] receiveMessageFromWorker() for ClusterFuture ...
[18:05:01.837] - Validating connection of MultisessionFuture
[18:05:01.881] - received message: FutureResult
[18:05:01.882] - Received FutureResult
[18:05:01.882] - Erased future from FutureRegistry
[18:05:01.882] result() for ClusterFuture ...
[18:05:01.883] - result already collected: FutureResult
[18:05:01.883] result() for ClusterFuture ... done
[18:05:01.883] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:01.883] result() for ClusterFuture ... done
[18:05:01.884] result() for ClusterFuture ...
[18:05:01.884] - result already collected: FutureResult
[18:05:01.884] result() for ClusterFuture ... done
value(b) = 2
[18:05:01.885] result() for ClusterFuture ...
[18:05:01.885] - result already collected: FutureResult
[18:05:01.885] result() for ClusterFuture ... done
[18:05:01.885] result() for ClusterFuture ...
[18:05:01.886] - result already collected: FutureResult
[18:05:01.886] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:01.887] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:01.887] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[18:05:01.889] - globals found: [2] ‘{’, ‘pkg’
[18:05:01.889] Searching for globals ... DONE
[18:05:01.890] Resolving globals: TRUE
[18:05:01.890] Resolving any globals that are futures ...
[18:05:01.890] - globals: [2] ‘{’, ‘pkg’
[18:05:01.890] Resolving any globals that are futures ... DONE
[18:05:01.891] Resolving futures part of globals (recursively) ...
[18:05:01.892] resolve() on list ...
[18:05:01.892]  recursive: 99
[18:05:01.892]  length: 1
[18:05:01.892]  elements: ‘pkg’
[18:05:01.893]  length: 0 (resolved future 1)
[18:05:01.893] resolve() on list ... DONE
[18:05:01.893] - globals: [1] ‘pkg’
[18:05:01.893] Resolving futures part of globals (recursively) ... DONE
[18:05:01.894] The total size of the 1 globals is 112 bytes (112 bytes)
[18:05:01.894] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[18:05:01.895] - globals: [1] ‘pkg’
[18:05:01.895] 
[18:05:01.895] getGlobalsAndPackages() ... DONE
[18:05:01.896] Packages needed by the future expression (n = 0): <none>
[18:05:01.896] Packages needed by future strategies (n = 0): <none>
[18:05:01.897] {
[18:05:01.897]     {
[18:05:01.897]         {
[18:05:01.897]             ...future.startTime <- base::Sys.time()
[18:05:01.897]             {
[18:05:01.897]                 {
[18:05:01.897]                   {
[18:05:01.897]                     base::local({
[18:05:01.897]                       has_future <- base::requireNamespace("future", 
[18:05:01.897]                         quietly = TRUE)
[18:05:01.897]                       if (has_future) {
[18:05:01.897]                         ns <- base::getNamespace("future")
[18:05:01.897]                         version <- ns[[".package"]][["version"]]
[18:05:01.897]                         if (is.null(version)) 
[18:05:01.897]                           version <- utils::packageVersion("future")
[18:05:01.897]                       }
[18:05:01.897]                       else {
[18:05:01.897]                         version <- NULL
[18:05:01.897]                       }
[18:05:01.897]                       if (!has_future || version < "1.8.0") {
[18:05:01.897]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:01.897]                           "", base::R.version$version.string), 
[18:05:01.897]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:01.897]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:01.897]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:01.897]                             "release", "version")], collapse = " "), 
[18:05:01.897]                           hostname = base::Sys.info()[["nodename"]])
[18:05:01.897]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:01.897]                           info)
[18:05:01.897]                         info <- base::paste(info, collapse = "; ")
[18:05:01.897]                         if (!has_future) {
[18:05:01.897]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:01.897]                             info)
[18:05:01.897]                         }
[18:05:01.897]                         else {
[18:05:01.897]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:01.897]                             info, version)
[18:05:01.897]                         }
[18:05:01.897]                         base::stop(msg)
[18:05:01.897]                       }
[18:05:01.897]                     })
[18:05:01.897]                   }
[18:05:01.897]                   ...future.strategy.old <- future::plan("list")
[18:05:01.897]                   options(future.plan = NULL)
[18:05:01.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:01.897]                 }
[18:05:01.897]                 ...future.workdir <- getwd()
[18:05:01.897]             }
[18:05:01.897]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:01.897]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:01.897]         }
[18:05:01.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:01.897]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[18:05:01.897]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:01.897]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:01.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:01.897]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:01.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:01.897]             base::names(...future.oldOptions))
[18:05:01.897]     }
[18:05:01.897]     if (FALSE) {
[18:05:01.897]     }
[18:05:01.897]     else {
[18:05:01.897]         if (TRUE) {
[18:05:01.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:01.897]                 open = "w")
[18:05:01.897]         }
[18:05:01.897]         else {
[18:05:01.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:01.897]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:01.897]         }
[18:05:01.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:01.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:01.897]             base::sink(type = "output", split = FALSE)
[18:05:01.897]             base::close(...future.stdout)
[18:05:01.897]         }, add = TRUE)
[18:05:01.897]     }
[18:05:01.897]     ...future.frame <- base::sys.nframe()
[18:05:01.897]     ...future.conditions <- base::list()
[18:05:01.897]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:01.897]     if (FALSE) {
[18:05:01.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:01.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:01.897]     }
[18:05:01.897]     ...future.result <- base::tryCatch({
[18:05:01.897]         base::withCallingHandlers({
[18:05:01.897]             ...future.value <- base::withVisible(base::local({
[18:05:01.897]                 pkg
[18:05:01.897]             }))
[18:05:01.897]             future::FutureResult(value = ...future.value$value, 
[18:05:01.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.897]                   ...future.rng), globalenv = if (FALSE) 
[18:05:01.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:01.897]                     ...future.globalenv.names))
[18:05:01.897]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:01.897]         }, condition = base::local({
[18:05:01.897]             c <- base::c
[18:05:01.897]             inherits <- base::inherits
[18:05:01.897]             invokeRestart <- base::invokeRestart
[18:05:01.897]             length <- base::length
[18:05:01.897]             list <- base::list
[18:05:01.897]             seq.int <- base::seq.int
[18:05:01.897]             signalCondition <- base::signalCondition
[18:05:01.897]             sys.calls <- base::sys.calls
[18:05:01.897]             `[[` <- base::`[[`
[18:05:01.897]             `+` <- base::`+`
[18:05:01.897]             `<<-` <- base::`<<-`
[18:05:01.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:01.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:01.897]                   3L)]
[18:05:01.897]             }
[18:05:01.897]             function(cond) {
[18:05:01.897]                 is_error <- inherits(cond, "error")
[18:05:01.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:01.897]                   NULL)
[18:05:01.897]                 if (is_error) {
[18:05:01.897]                   sessionInformation <- function() {
[18:05:01.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:01.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:01.897]                       search = base::search(), system = base::Sys.info())
[18:05:01.897]                   }
[18:05:01.897]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:01.897]                     cond$call), session = sessionInformation(), 
[18:05:01.897]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:01.897]                   signalCondition(cond)
[18:05:01.897]                 }
[18:05:01.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:01.897]                 "immediateCondition"))) {
[18:05:01.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:01.897]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:01.897]                   if (TRUE && !signal) {
[18:05:01.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.897]                     {
[18:05:01.897]                       inherits <- base::inherits
[18:05:01.897]                       invokeRestart <- base::invokeRestart
[18:05:01.897]                       is.null <- base::is.null
[18:05:01.897]                       muffled <- FALSE
[18:05:01.897]                       if (inherits(cond, "message")) {
[18:05:01.897]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.897]                         if (muffled) 
[18:05:01.897]                           invokeRestart("muffleMessage")
[18:05:01.897]                       }
[18:05:01.897]                       else if (inherits(cond, "warning")) {
[18:05:01.897]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.897]                         if (muffled) 
[18:05:01.897]                           invokeRestart("muffleWarning")
[18:05:01.897]                       }
[18:05:01.897]                       else if (inherits(cond, "condition")) {
[18:05:01.897]                         if (!is.null(pattern)) {
[18:05:01.897]                           computeRestarts <- base::computeRestarts
[18:05:01.897]                           grepl <- base::grepl
[18:05:01.897]                           restarts <- computeRestarts(cond)
[18:05:01.897]                           for (restart in restarts) {
[18:05:01.897]                             name <- restart$name
[18:05:01.897]                             if (is.null(name)) 
[18:05:01.897]                               next
[18:05:01.897]                             if (!grepl(pattern, name)) 
[18:05:01.897]                               next
[18:05:01.897]                             invokeRestart(restart)
[18:05:01.897]                             muffled <- TRUE
[18:05:01.897]                             break
[18:05:01.897]                           }
[18:05:01.897]                         }
[18:05:01.897]                       }
[18:05:01.897]                       invisible(muffled)
[18:05:01.897]                     }
[18:05:01.897]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.897]                   }
[18:05:01.897]                 }
[18:05:01.897]                 else {
[18:05:01.897]                   if (TRUE) {
[18:05:01.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.897]                     {
[18:05:01.897]                       inherits <- base::inherits
[18:05:01.897]                       invokeRestart <- base::invokeRestart
[18:05:01.897]                       is.null <- base::is.null
[18:05:01.897]                       muffled <- FALSE
[18:05:01.897]                       if (inherits(cond, "message")) {
[18:05:01.897]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.897]                         if (muffled) 
[18:05:01.897]                           invokeRestart("muffleMessage")
[18:05:01.897]                       }
[18:05:01.897]                       else if (inherits(cond, "warning")) {
[18:05:01.897]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.897]                         if (muffled) 
[18:05:01.897]                           invokeRestart("muffleWarning")
[18:05:01.897]                       }
[18:05:01.897]                       else if (inherits(cond, "condition")) {
[18:05:01.897]                         if (!is.null(pattern)) {
[18:05:01.897]                           computeRestarts <- base::computeRestarts
[18:05:01.897]                           grepl <- base::grepl
[18:05:01.897]                           restarts <- computeRestarts(cond)
[18:05:01.897]                           for (restart in restarts) {
[18:05:01.897]                             name <- restart$name
[18:05:01.897]                             if (is.null(name)) 
[18:05:01.897]                               next
[18:05:01.897]                             if (!grepl(pattern, name)) 
[18:05:01.897]                               next
[18:05:01.897]                             invokeRestart(restart)
[18:05:01.897]                             muffled <- TRUE
[18:05:01.897]                             break
[18:05:01.897]                           }
[18:05:01.897]                         }
[18:05:01.897]                       }
[18:05:01.897]                       invisible(muffled)
[18:05:01.897]                     }
[18:05:01.897]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.897]                   }
[18:05:01.897]                 }
[18:05:01.897]             }
[18:05:01.897]         }))
[18:05:01.897]     }, error = function(ex) {
[18:05:01.897]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:01.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.897]                 ...future.rng), started = ...future.startTime, 
[18:05:01.897]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:01.897]             version = "1.8"), class = "FutureResult")
[18:05:01.897]     }, finally = {
[18:05:01.897]         if (!identical(...future.workdir, getwd())) 
[18:05:01.897]             setwd(...future.workdir)
[18:05:01.897]         {
[18:05:01.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:01.897]                 ...future.oldOptions$nwarnings <- NULL
[18:05:01.897]             }
[18:05:01.897]             base::options(...future.oldOptions)
[18:05:01.897]             if (.Platform$OS.type == "windows") {
[18:05:01.897]                 old_names <- names(...future.oldEnvVars)
[18:05:01.897]                 envs <- base::Sys.getenv()
[18:05:01.897]                 names <- names(envs)
[18:05:01.897]                 common <- intersect(names, old_names)
[18:05:01.897]                 added <- setdiff(names, old_names)
[18:05:01.897]                 removed <- setdiff(old_names, names)
[18:05:01.897]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:01.897]                   envs[common]]
[18:05:01.897]                 NAMES <- toupper(changed)
[18:05:01.897]                 args <- list()
[18:05:01.897]                 for (kk in seq_along(NAMES)) {
[18:05:01.897]                   name <- changed[[kk]]
[18:05:01.897]                   NAME <- NAMES[[kk]]
[18:05:01.897]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.897]                     next
[18:05:01.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.897]                 }
[18:05:01.897]                 NAMES <- toupper(added)
[18:05:01.897]                 for (kk in seq_along(NAMES)) {
[18:05:01.897]                   name <- added[[kk]]
[18:05:01.897]                   NAME <- NAMES[[kk]]
[18:05:01.897]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.897]                     next
[18:05:01.897]                   args[[name]] <- ""
[18:05:01.897]                 }
[18:05:01.897]                 NAMES <- toupper(removed)
[18:05:01.897]                 for (kk in seq_along(NAMES)) {
[18:05:01.897]                   name <- removed[[kk]]
[18:05:01.897]                   NAME <- NAMES[[kk]]
[18:05:01.897]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.897]                     next
[18:05:01.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.897]                 }
[18:05:01.897]                 if (length(args) > 0) 
[18:05:01.897]                   base::do.call(base::Sys.setenv, args = args)
[18:05:01.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:01.897]             }
[18:05:01.897]             else {
[18:05:01.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:01.897]             }
[18:05:01.897]             {
[18:05:01.897]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:01.897]                   0L) {
[18:05:01.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:01.897]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:01.897]                   base::options(opts)
[18:05:01.897]                 }
[18:05:01.897]                 {
[18:05:01.897]                   {
[18:05:01.897]                     NULL
[18:05:01.897]                     RNGkind("Mersenne-Twister")
[18:05:01.897]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:01.897]                       inherits = FALSE)
[18:05:01.897]                   }
[18:05:01.897]                   options(future.plan = NULL)
[18:05:01.897]                   if (is.na(NA_character_)) 
[18:05:01.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:01.897]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:01.897]                     .init = FALSE)
[18:05:01.897]                 }
[18:05:01.897]             }
[18:05:01.897]         }
[18:05:01.897]     })
[18:05:01.897]     if (TRUE) {
[18:05:01.897]         base::sink(type = "output", split = FALSE)
[18:05:01.897]         if (TRUE) {
[18:05:01.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:01.897]         }
[18:05:01.897]         else {
[18:05:01.897]             ...future.result["stdout"] <- base::list(NULL)
[18:05:01.897]         }
[18:05:01.897]         base::close(...future.stdout)
[18:05:01.897]         ...future.stdout <- NULL
[18:05:01.897]     }
[18:05:01.897]     ...future.result$conditions <- ...future.conditions
[18:05:01.897]     ...future.result$finished <- base::Sys.time()
[18:05:01.897]     ...future.result
[18:05:01.897] }
[18:05:01.900] assign_globals() ...
[18:05:01.901] List of 1
[18:05:01.901]  $ pkg: chr "foo"
[18:05:01.901]  - attr(*, "where")=List of 1
[18:05:01.901]   ..$ pkg:<environment: R_EmptyEnv> 
[18:05:01.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:01.901]  - attr(*, "resolved")= logi TRUE
[18:05:01.901]  - attr(*, "total_size")= num 112
[18:05:01.905] - copied ‘pkg’ to environment
[18:05:01.905] assign_globals() ... done
[18:05:01.906] plan(): Setting new future strategy stack:
[18:05:01.906] List of future strategies:
[18:05:01.906] 1. sequential:
[18:05:01.906]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:01.906]    - tweaked: FALSE
[18:05:01.906]    - call: NULL
[18:05:01.907] plan(): nbrOfWorkers() = 1
[18:05:01.909] plan(): Setting new future strategy stack:
[18:05:01.909] List of future strategies:
[18:05:01.909] 1. multisession:
[18:05:01.909]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:01.909]    - tweaked: FALSE
[18:05:01.909]    - call: plan(strategy)
[18:05:01.916] plan(): nbrOfWorkers() = 2
[18:05:01.916] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:01.918] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:01.919] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:01.923] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:05:01.924] Searching for globals ... DONE
[18:05:01.924] Resolving globals: TRUE
[18:05:01.924] Resolving any globals that are futures ...
[18:05:01.924] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:05:01.925] Resolving any globals that are futures ... DONE
[18:05:01.925] Resolving futures part of globals (recursively) ...
[18:05:01.926] resolve() on list ...
[18:05:01.926]  recursive: 99
[18:05:01.926]  length: 1
[18:05:01.927]  elements: ‘a’
[18:05:01.927]  length: 0 (resolved future 1)
[18:05:01.927] resolve() on list ... DONE
[18:05:01.927] - globals: [1] ‘a’
[18:05:01.928] Resolving futures part of globals (recursively) ... DONE
[18:05:01.928] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:01.929] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:05:01.929] - globals: [1] ‘a’
[18:05:01.929] 
[18:05:01.929] getGlobalsAndPackages() ... DONE
[18:05:01.930] run() for ‘Future’ ...
[18:05:01.930] - state: ‘created’
[18:05:01.931] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:01.954] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:01.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:01.955]   - Field: ‘node’
[18:05:01.955]   - Field: ‘label’
[18:05:01.955]   - Field: ‘local’
[18:05:01.956]   - Field: ‘owner’
[18:05:01.956]   - Field: ‘envir’
[18:05:01.956]   - Field: ‘workers’
[18:05:01.956]   - Field: ‘packages’
[18:05:01.956]   - Field: ‘gc’
[18:05:01.957]   - Field: ‘conditions’
[18:05:01.957]   - Field: ‘persistent’
[18:05:01.957]   - Field: ‘expr’
[18:05:01.957]   - Field: ‘uuid’
[18:05:01.957]   - Field: ‘seed’
[18:05:01.958]   - Field: ‘version’
[18:05:01.958]   - Field: ‘result’
[18:05:01.958]   - Field: ‘asynchronous’
[18:05:01.958]   - Field: ‘calls’
[18:05:01.958]   - Field: ‘globals’
[18:05:01.959]   - Field: ‘stdout’
[18:05:01.959]   - Field: ‘earlySignal’
[18:05:01.959]   - Field: ‘lazy’
[18:05:01.959]   - Field: ‘state’
[18:05:01.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:01.960] - Launch lazy future ...
[18:05:01.960] Packages needed by the future expression (n = 0): <none>
[18:05:01.960] Packages needed by future strategies (n = 0): <none>
[18:05:01.961] {
[18:05:01.961]     {
[18:05:01.961]         {
[18:05:01.961]             ...future.startTime <- base::Sys.time()
[18:05:01.961]             {
[18:05:01.961]                 {
[18:05:01.961]                   {
[18:05:01.961]                     {
[18:05:01.961]                       base::local({
[18:05:01.961]                         has_future <- base::requireNamespace("future", 
[18:05:01.961]                           quietly = TRUE)
[18:05:01.961]                         if (has_future) {
[18:05:01.961]                           ns <- base::getNamespace("future")
[18:05:01.961]                           version <- ns[[".package"]][["version"]]
[18:05:01.961]                           if (is.null(version)) 
[18:05:01.961]                             version <- utils::packageVersion("future")
[18:05:01.961]                         }
[18:05:01.961]                         else {
[18:05:01.961]                           version <- NULL
[18:05:01.961]                         }
[18:05:01.961]                         if (!has_future || version < "1.8.0") {
[18:05:01.961]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:01.961]                             "", base::R.version$version.string), 
[18:05:01.961]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:01.961]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:01.961]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:01.961]                               "release", "version")], collapse = " "), 
[18:05:01.961]                             hostname = base::Sys.info()[["nodename"]])
[18:05:01.961]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:01.961]                             info)
[18:05:01.961]                           info <- base::paste(info, collapse = "; ")
[18:05:01.961]                           if (!has_future) {
[18:05:01.961]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:01.961]                               info)
[18:05:01.961]                           }
[18:05:01.961]                           else {
[18:05:01.961]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:01.961]                               info, version)
[18:05:01.961]                           }
[18:05:01.961]                           base::stop(msg)
[18:05:01.961]                         }
[18:05:01.961]                       })
[18:05:01.961]                     }
[18:05:01.961]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:01.961]                     base::options(mc.cores = 1L)
[18:05:01.961]                   }
[18:05:01.961]                   ...future.strategy.old <- future::plan("list")
[18:05:01.961]                   options(future.plan = NULL)
[18:05:01.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:01.961]                 }
[18:05:01.961]                 ...future.workdir <- getwd()
[18:05:01.961]             }
[18:05:01.961]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:01.961]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:01.961]         }
[18:05:01.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:01.961]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:01.961]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:01.961]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:01.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:01.961]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:01.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:01.961]             base::names(...future.oldOptions))
[18:05:01.961]     }
[18:05:01.961]     if (FALSE) {
[18:05:01.961]     }
[18:05:01.961]     else {
[18:05:01.961]         if (TRUE) {
[18:05:01.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:01.961]                 open = "w")
[18:05:01.961]         }
[18:05:01.961]         else {
[18:05:01.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:01.961]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:01.961]         }
[18:05:01.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:01.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:01.961]             base::sink(type = "output", split = FALSE)
[18:05:01.961]             base::close(...future.stdout)
[18:05:01.961]         }, add = TRUE)
[18:05:01.961]     }
[18:05:01.961]     ...future.frame <- base::sys.nframe()
[18:05:01.961]     ...future.conditions <- base::list()
[18:05:01.961]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:01.961]     if (FALSE) {
[18:05:01.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:01.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:01.961]     }
[18:05:01.961]     ...future.result <- base::tryCatch({
[18:05:01.961]         base::withCallingHandlers({
[18:05:01.961]             ...future.value <- base::withVisible(base::local({
[18:05:01.961]                 ...future.makeSendCondition <- base::local({
[18:05:01.961]                   sendCondition <- NULL
[18:05:01.961]                   function(frame = 1L) {
[18:05:01.961]                     if (is.function(sendCondition)) 
[18:05:01.961]                       return(sendCondition)
[18:05:01.961]                     ns <- getNamespace("parallel")
[18:05:01.961]                     if (exists("sendData", mode = "function", 
[18:05:01.961]                       envir = ns)) {
[18:05:01.961]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:01.961]                         envir = ns)
[18:05:01.961]                       envir <- sys.frame(frame)
[18:05:01.961]                       master <- NULL
[18:05:01.961]                       while (!identical(envir, .GlobalEnv) && 
[18:05:01.961]                         !identical(envir, emptyenv())) {
[18:05:01.961]                         if (exists("master", mode = "list", envir = envir, 
[18:05:01.961]                           inherits = FALSE)) {
[18:05:01.961]                           master <- get("master", mode = "list", 
[18:05:01.961]                             envir = envir, inherits = FALSE)
[18:05:01.961]                           if (inherits(master, c("SOCKnode", 
[18:05:01.961]                             "SOCK0node"))) {
[18:05:01.961]                             sendCondition <<- function(cond) {
[18:05:01.961]                               data <- list(type = "VALUE", value = cond, 
[18:05:01.961]                                 success = TRUE)
[18:05:01.961]                               parallel_sendData(master, data)
[18:05:01.961]                             }
[18:05:01.961]                             return(sendCondition)
[18:05:01.961]                           }
[18:05:01.961]                         }
[18:05:01.961]                         frame <- frame + 1L
[18:05:01.961]                         envir <- sys.frame(frame)
[18:05:01.961]                       }
[18:05:01.961]                     }
[18:05:01.961]                     sendCondition <<- function(cond) NULL
[18:05:01.961]                   }
[18:05:01.961]                 })
[18:05:01.961]                 withCallingHandlers({
[18:05:01.961]                   {
[18:05:01.961]                     b <- a
[18:05:01.961]                     a <- 2
[18:05:01.961]                     a * b
[18:05:01.961]                   }
[18:05:01.961]                 }, immediateCondition = function(cond) {
[18:05:01.961]                   sendCondition <- ...future.makeSendCondition()
[18:05:01.961]                   sendCondition(cond)
[18:05:01.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.961]                   {
[18:05:01.961]                     inherits <- base::inherits
[18:05:01.961]                     invokeRestart <- base::invokeRestart
[18:05:01.961]                     is.null <- base::is.null
[18:05:01.961]                     muffled <- FALSE
[18:05:01.961]                     if (inherits(cond, "message")) {
[18:05:01.961]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:01.961]                       if (muffled) 
[18:05:01.961]                         invokeRestart("muffleMessage")
[18:05:01.961]                     }
[18:05:01.961]                     else if (inherits(cond, "warning")) {
[18:05:01.961]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:01.961]                       if (muffled) 
[18:05:01.961]                         invokeRestart("muffleWarning")
[18:05:01.961]                     }
[18:05:01.961]                     else if (inherits(cond, "condition")) {
[18:05:01.961]                       if (!is.null(pattern)) {
[18:05:01.961]                         computeRestarts <- base::computeRestarts
[18:05:01.961]                         grepl <- base::grepl
[18:05:01.961]                         restarts <- computeRestarts(cond)
[18:05:01.961]                         for (restart in restarts) {
[18:05:01.961]                           name <- restart$name
[18:05:01.961]                           if (is.null(name)) 
[18:05:01.961]                             next
[18:05:01.961]                           if (!grepl(pattern, name)) 
[18:05:01.961]                             next
[18:05:01.961]                           invokeRestart(restart)
[18:05:01.961]                           muffled <- TRUE
[18:05:01.961]                           break
[18:05:01.961]                         }
[18:05:01.961]                       }
[18:05:01.961]                     }
[18:05:01.961]                     invisible(muffled)
[18:05:01.961]                   }
[18:05:01.961]                   muffleCondition(cond)
[18:05:01.961]                 })
[18:05:01.961]             }))
[18:05:01.961]             future::FutureResult(value = ...future.value$value, 
[18:05:01.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.961]                   ...future.rng), globalenv = if (FALSE) 
[18:05:01.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:01.961]                     ...future.globalenv.names))
[18:05:01.961]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:01.961]         }, condition = base::local({
[18:05:01.961]             c <- base::c
[18:05:01.961]             inherits <- base::inherits
[18:05:01.961]             invokeRestart <- base::invokeRestart
[18:05:01.961]             length <- base::length
[18:05:01.961]             list <- base::list
[18:05:01.961]             seq.int <- base::seq.int
[18:05:01.961]             signalCondition <- base::signalCondition
[18:05:01.961]             sys.calls <- base::sys.calls
[18:05:01.961]             `[[` <- base::`[[`
[18:05:01.961]             `+` <- base::`+`
[18:05:01.961]             `<<-` <- base::`<<-`
[18:05:01.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:01.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:01.961]                   3L)]
[18:05:01.961]             }
[18:05:01.961]             function(cond) {
[18:05:01.961]                 is_error <- inherits(cond, "error")
[18:05:01.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:01.961]                   NULL)
[18:05:01.961]                 if (is_error) {
[18:05:01.961]                   sessionInformation <- function() {
[18:05:01.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:01.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:01.961]                       search = base::search(), system = base::Sys.info())
[18:05:01.961]                   }
[18:05:01.961]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:01.961]                     cond$call), session = sessionInformation(), 
[18:05:01.961]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:01.961]                   signalCondition(cond)
[18:05:01.961]                 }
[18:05:01.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:01.961]                 "immediateCondition"))) {
[18:05:01.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:01.961]                   ...future.conditions[[length(...future.conditions) + 
[18:05:01.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:01.961]                   if (TRUE && !signal) {
[18:05:01.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.961]                     {
[18:05:01.961]                       inherits <- base::inherits
[18:05:01.961]                       invokeRestart <- base::invokeRestart
[18:05:01.961]                       is.null <- base::is.null
[18:05:01.961]                       muffled <- FALSE
[18:05:01.961]                       if (inherits(cond, "message")) {
[18:05:01.961]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.961]                         if (muffled) 
[18:05:01.961]                           invokeRestart("muffleMessage")
[18:05:01.961]                       }
[18:05:01.961]                       else if (inherits(cond, "warning")) {
[18:05:01.961]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.961]                         if (muffled) 
[18:05:01.961]                           invokeRestart("muffleWarning")
[18:05:01.961]                       }
[18:05:01.961]                       else if (inherits(cond, "condition")) {
[18:05:01.961]                         if (!is.null(pattern)) {
[18:05:01.961]                           computeRestarts <- base::computeRestarts
[18:05:01.961]                           grepl <- base::grepl
[18:05:01.961]                           restarts <- computeRestarts(cond)
[18:05:01.961]                           for (restart in restarts) {
[18:05:01.961]                             name <- restart$name
[18:05:01.961]                             if (is.null(name)) 
[18:05:01.961]                               next
[18:05:01.961]                             if (!grepl(pattern, name)) 
[18:05:01.961]                               next
[18:05:01.961]                             invokeRestart(restart)
[18:05:01.961]                             muffled <- TRUE
[18:05:01.961]                             break
[18:05:01.961]                           }
[18:05:01.961]                         }
[18:05:01.961]                       }
[18:05:01.961]                       invisible(muffled)
[18:05:01.961]                     }
[18:05:01.961]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.961]                   }
[18:05:01.961]                 }
[18:05:01.961]                 else {
[18:05:01.961]                   if (TRUE) {
[18:05:01.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:01.961]                     {
[18:05:01.961]                       inherits <- base::inherits
[18:05:01.961]                       invokeRestart <- base::invokeRestart
[18:05:01.961]                       is.null <- base::is.null
[18:05:01.961]                       muffled <- FALSE
[18:05:01.961]                       if (inherits(cond, "message")) {
[18:05:01.961]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:01.961]                         if (muffled) 
[18:05:01.961]                           invokeRestart("muffleMessage")
[18:05:01.961]                       }
[18:05:01.961]                       else if (inherits(cond, "warning")) {
[18:05:01.961]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:01.961]                         if (muffled) 
[18:05:01.961]                           invokeRestart("muffleWarning")
[18:05:01.961]                       }
[18:05:01.961]                       else if (inherits(cond, "condition")) {
[18:05:01.961]                         if (!is.null(pattern)) {
[18:05:01.961]                           computeRestarts <- base::computeRestarts
[18:05:01.961]                           grepl <- base::grepl
[18:05:01.961]                           restarts <- computeRestarts(cond)
[18:05:01.961]                           for (restart in restarts) {
[18:05:01.961]                             name <- restart$name
[18:05:01.961]                             if (is.null(name)) 
[18:05:01.961]                               next
[18:05:01.961]                             if (!grepl(pattern, name)) 
[18:05:01.961]                               next
[18:05:01.961]                             invokeRestart(restart)
[18:05:01.961]                             muffled <- TRUE
[18:05:01.961]                             break
[18:05:01.961]                           }
[18:05:01.961]                         }
[18:05:01.961]                       }
[18:05:01.961]                       invisible(muffled)
[18:05:01.961]                     }
[18:05:01.961]                     muffleCondition(cond, pattern = "^muffle")
[18:05:01.961]                   }
[18:05:01.961]                 }
[18:05:01.961]             }
[18:05:01.961]         }))
[18:05:01.961]     }, error = function(ex) {
[18:05:01.961]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:01.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:01.961]                 ...future.rng), started = ...future.startTime, 
[18:05:01.961]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:01.961]             version = "1.8"), class = "FutureResult")
[18:05:01.961]     }, finally = {
[18:05:01.961]         if (!identical(...future.workdir, getwd())) 
[18:05:01.961]             setwd(...future.workdir)
[18:05:01.961]         {
[18:05:01.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:01.961]                 ...future.oldOptions$nwarnings <- NULL
[18:05:01.961]             }
[18:05:01.961]             base::options(...future.oldOptions)
[18:05:01.961]             if (.Platform$OS.type == "windows") {
[18:05:01.961]                 old_names <- names(...future.oldEnvVars)
[18:05:01.961]                 envs <- base::Sys.getenv()
[18:05:01.961]                 names <- names(envs)
[18:05:01.961]                 common <- intersect(names, old_names)
[18:05:01.961]                 added <- setdiff(names, old_names)
[18:05:01.961]                 removed <- setdiff(old_names, names)
[18:05:01.961]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:01.961]                   envs[common]]
[18:05:01.961]                 NAMES <- toupper(changed)
[18:05:01.961]                 args <- list()
[18:05:01.961]                 for (kk in seq_along(NAMES)) {
[18:05:01.961]                   name <- changed[[kk]]
[18:05:01.961]                   NAME <- NAMES[[kk]]
[18:05:01.961]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.961]                     next
[18:05:01.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.961]                 }
[18:05:01.961]                 NAMES <- toupper(added)
[18:05:01.961]                 for (kk in seq_along(NAMES)) {
[18:05:01.961]                   name <- added[[kk]]
[18:05:01.961]                   NAME <- NAMES[[kk]]
[18:05:01.961]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.961]                     next
[18:05:01.961]                   args[[name]] <- ""
[18:05:01.961]                 }
[18:05:01.961]                 NAMES <- toupper(removed)
[18:05:01.961]                 for (kk in seq_along(NAMES)) {
[18:05:01.961]                   name <- removed[[kk]]
[18:05:01.961]                   NAME <- NAMES[[kk]]
[18:05:01.961]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:01.961]                     next
[18:05:01.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:01.961]                 }
[18:05:01.961]                 if (length(args) > 0) 
[18:05:01.961]                   base::do.call(base::Sys.setenv, args = args)
[18:05:01.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:01.961]             }
[18:05:01.961]             else {
[18:05:01.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:01.961]             }
[18:05:01.961]             {
[18:05:01.961]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:01.961]                   0L) {
[18:05:01.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:01.961]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:01.961]                   base::options(opts)
[18:05:01.961]                 }
[18:05:01.961]                 {
[18:05:01.961]                   {
[18:05:01.961]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:01.961]                     NULL
[18:05:01.961]                   }
[18:05:01.961]                   options(future.plan = NULL)
[18:05:01.961]                   if (is.na(NA_character_)) 
[18:05:01.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:01.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:01.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:01.961]                     .init = FALSE)
[18:05:01.961]                 }
[18:05:01.961]             }
[18:05:01.961]         }
[18:05:01.961]     })
[18:05:01.961]     if (TRUE) {
[18:05:01.961]         base::sink(type = "output", split = FALSE)
[18:05:01.961]         if (TRUE) {
[18:05:01.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:01.961]         }
[18:05:01.961]         else {
[18:05:01.961]             ...future.result["stdout"] <- base::list(NULL)
[18:05:01.961]         }
[18:05:01.961]         base::close(...future.stdout)
[18:05:01.961]         ...future.stdout <- NULL
[18:05:01.961]     }
[18:05:01.961]     ...future.result$conditions <- ...future.conditions
[18:05:01.961]     ...future.result$finished <- base::Sys.time()
[18:05:01.961]     ...future.result
[18:05:01.961] }
[18:05:01.966] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[18:05:01.966] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[18:05:01.967] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[18:05:01.968] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[18:05:01.969] MultisessionFuture started
[18:05:01.969] - Launch lazy future ... done
[18:05:01.969] run() for ‘MultisessionFuture’ ... done
[18:05:01.969] result() for ClusterFuture ...
[18:05:01.970] receiveMessageFromWorker() for ClusterFuture ...
[18:05:01.970] - Validating connection of MultisessionFuture
[18:05:02.013] - received message: FutureResult
[18:05:02.014] - Received FutureResult
[18:05:02.014] - Erased future from FutureRegistry
[18:05:02.014] result() for ClusterFuture ...
[18:05:02.014] - result already collected: FutureResult
[18:05:02.015] result() for ClusterFuture ... done
[18:05:02.015] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.015] result() for ClusterFuture ... done
[18:05:02.015] result() for ClusterFuture ...
[18:05:02.015] - result already collected: FutureResult
[18:05:02.016] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.017] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.017] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.021] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:05:02.021] Searching for globals ... DONE
[18:05:02.021] Resolving globals: TRUE
[18:05:02.022] Resolving any globals that are futures ...
[18:05:02.022] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[18:05:02.022] Resolving any globals that are futures ... DONE
[18:05:02.023] Resolving futures part of globals (recursively) ...
[18:05:02.023] resolve() on list ...
[18:05:02.023]  recursive: 99
[18:05:02.023]  length: 1
[18:05:02.024]  elements: ‘a’
[18:05:02.024]  length: 0 (resolved future 1)
[18:05:02.024] resolve() on list ... DONE
[18:05:02.024] - globals: [1] ‘a’
[18:05:02.025] Resolving futures part of globals (recursively) ... DONE
[18:05:02.025] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:02.026] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[18:05:02.026] - globals: [1] ‘a’
[18:05:02.026] 
[18:05:02.026] getGlobalsAndPackages() ... DONE
[18:05:02.027] run() for ‘Future’ ...
[18:05:02.027] - state: ‘created’
[18:05:02.027] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.053]   - Field: ‘node’
[18:05:02.053]   - Field: ‘label’
[18:05:02.053]   - Field: ‘local’
[18:05:02.053]   - Field: ‘owner’
[18:05:02.054]   - Field: ‘envir’
[18:05:02.054]   - Field: ‘workers’
[18:05:02.054]   - Field: ‘packages’
[18:05:02.054]   - Field: ‘gc’
[18:05:02.054]   - Field: ‘conditions’
[18:05:02.055]   - Field: ‘persistent’
[18:05:02.055]   - Field: ‘expr’
[18:05:02.055]   - Field: ‘uuid’
[18:05:02.055]   - Field: ‘seed’
[18:05:02.055]   - Field: ‘version’
[18:05:02.056]   - Field: ‘result’
[18:05:02.056]   - Field: ‘asynchronous’
[18:05:02.056]   - Field: ‘calls’
[18:05:02.056]   - Field: ‘globals’
[18:05:02.056]   - Field: ‘stdout’
[18:05:02.057]   - Field: ‘earlySignal’
[18:05:02.057]   - Field: ‘lazy’
[18:05:02.057]   - Field: ‘state’
[18:05:02.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.057] - Launch lazy future ...
[18:05:02.058] Packages needed by the future expression (n = 0): <none>
[18:05:02.058] Packages needed by future strategies (n = 0): <none>
[18:05:02.059] {
[18:05:02.059]     {
[18:05:02.059]         {
[18:05:02.059]             ...future.startTime <- base::Sys.time()
[18:05:02.059]             {
[18:05:02.059]                 {
[18:05:02.059]                   {
[18:05:02.059]                     {
[18:05:02.059]                       base::local({
[18:05:02.059]                         has_future <- base::requireNamespace("future", 
[18:05:02.059]                           quietly = TRUE)
[18:05:02.059]                         if (has_future) {
[18:05:02.059]                           ns <- base::getNamespace("future")
[18:05:02.059]                           version <- ns[[".package"]][["version"]]
[18:05:02.059]                           if (is.null(version)) 
[18:05:02.059]                             version <- utils::packageVersion("future")
[18:05:02.059]                         }
[18:05:02.059]                         else {
[18:05:02.059]                           version <- NULL
[18:05:02.059]                         }
[18:05:02.059]                         if (!has_future || version < "1.8.0") {
[18:05:02.059]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.059]                             "", base::R.version$version.string), 
[18:05:02.059]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:02.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:02.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.059]                               "release", "version")], collapse = " "), 
[18:05:02.059]                             hostname = base::Sys.info()[["nodename"]])
[18:05:02.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.059]                             info)
[18:05:02.059]                           info <- base::paste(info, collapse = "; ")
[18:05:02.059]                           if (!has_future) {
[18:05:02.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.059]                               info)
[18:05:02.059]                           }
[18:05:02.059]                           else {
[18:05:02.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.059]                               info, version)
[18:05:02.059]                           }
[18:05:02.059]                           base::stop(msg)
[18:05:02.059]                         }
[18:05:02.059]                       })
[18:05:02.059]                     }
[18:05:02.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.059]                     base::options(mc.cores = 1L)
[18:05:02.059]                   }
[18:05:02.059]                   ...future.strategy.old <- future::plan("list")
[18:05:02.059]                   options(future.plan = NULL)
[18:05:02.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.059]                 }
[18:05:02.059]                 ...future.workdir <- getwd()
[18:05:02.059]             }
[18:05:02.059]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.059]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.059]         }
[18:05:02.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.059]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.059]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.059]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.059]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.059]             base::names(...future.oldOptions))
[18:05:02.059]     }
[18:05:02.059]     if (FALSE) {
[18:05:02.059]     }
[18:05:02.059]     else {
[18:05:02.059]         if (TRUE) {
[18:05:02.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.059]                 open = "w")
[18:05:02.059]         }
[18:05:02.059]         else {
[18:05:02.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.059]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.059]         }
[18:05:02.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.059]             base::sink(type = "output", split = FALSE)
[18:05:02.059]             base::close(...future.stdout)
[18:05:02.059]         }, add = TRUE)
[18:05:02.059]     }
[18:05:02.059]     ...future.frame <- base::sys.nframe()
[18:05:02.059]     ...future.conditions <- base::list()
[18:05:02.059]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.059]     if (FALSE) {
[18:05:02.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.059]     }
[18:05:02.059]     ...future.result <- base::tryCatch({
[18:05:02.059]         base::withCallingHandlers({
[18:05:02.059]             ...future.value <- base::withVisible(base::local({
[18:05:02.059]                 ...future.makeSendCondition <- base::local({
[18:05:02.059]                   sendCondition <- NULL
[18:05:02.059]                   function(frame = 1L) {
[18:05:02.059]                     if (is.function(sendCondition)) 
[18:05:02.059]                       return(sendCondition)
[18:05:02.059]                     ns <- getNamespace("parallel")
[18:05:02.059]                     if (exists("sendData", mode = "function", 
[18:05:02.059]                       envir = ns)) {
[18:05:02.059]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.059]                         envir = ns)
[18:05:02.059]                       envir <- sys.frame(frame)
[18:05:02.059]                       master <- NULL
[18:05:02.059]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.059]                         !identical(envir, emptyenv())) {
[18:05:02.059]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.059]                           inherits = FALSE)) {
[18:05:02.059]                           master <- get("master", mode = "list", 
[18:05:02.059]                             envir = envir, inherits = FALSE)
[18:05:02.059]                           if (inherits(master, c("SOCKnode", 
[18:05:02.059]                             "SOCK0node"))) {
[18:05:02.059]                             sendCondition <<- function(cond) {
[18:05:02.059]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.059]                                 success = TRUE)
[18:05:02.059]                               parallel_sendData(master, data)
[18:05:02.059]                             }
[18:05:02.059]                             return(sendCondition)
[18:05:02.059]                           }
[18:05:02.059]                         }
[18:05:02.059]                         frame <- frame + 1L
[18:05:02.059]                         envir <- sys.frame(frame)
[18:05:02.059]                       }
[18:05:02.059]                     }
[18:05:02.059]                     sendCondition <<- function(cond) NULL
[18:05:02.059]                   }
[18:05:02.059]                 })
[18:05:02.059]                 withCallingHandlers({
[18:05:02.059]                   {
[18:05:02.059]                     b <- a
[18:05:02.059]                     a <- 2
[18:05:02.059]                     a * b
[18:05:02.059]                   }
[18:05:02.059]                 }, immediateCondition = function(cond) {
[18:05:02.059]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.059]                   sendCondition(cond)
[18:05:02.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.059]                   {
[18:05:02.059]                     inherits <- base::inherits
[18:05:02.059]                     invokeRestart <- base::invokeRestart
[18:05:02.059]                     is.null <- base::is.null
[18:05:02.059]                     muffled <- FALSE
[18:05:02.059]                     if (inherits(cond, "message")) {
[18:05:02.059]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.059]                       if (muffled) 
[18:05:02.059]                         invokeRestart("muffleMessage")
[18:05:02.059]                     }
[18:05:02.059]                     else if (inherits(cond, "warning")) {
[18:05:02.059]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.059]                       if (muffled) 
[18:05:02.059]                         invokeRestart("muffleWarning")
[18:05:02.059]                     }
[18:05:02.059]                     else if (inherits(cond, "condition")) {
[18:05:02.059]                       if (!is.null(pattern)) {
[18:05:02.059]                         computeRestarts <- base::computeRestarts
[18:05:02.059]                         grepl <- base::grepl
[18:05:02.059]                         restarts <- computeRestarts(cond)
[18:05:02.059]                         for (restart in restarts) {
[18:05:02.059]                           name <- restart$name
[18:05:02.059]                           if (is.null(name)) 
[18:05:02.059]                             next
[18:05:02.059]                           if (!grepl(pattern, name)) 
[18:05:02.059]                             next
[18:05:02.059]                           invokeRestart(restart)
[18:05:02.059]                           muffled <- TRUE
[18:05:02.059]                           break
[18:05:02.059]                         }
[18:05:02.059]                       }
[18:05:02.059]                     }
[18:05:02.059]                     invisible(muffled)
[18:05:02.059]                   }
[18:05:02.059]                   muffleCondition(cond)
[18:05:02.059]                 })
[18:05:02.059]             }))
[18:05:02.059]             future::FutureResult(value = ...future.value$value, 
[18:05:02.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.059]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.059]                     ...future.globalenv.names))
[18:05:02.059]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.059]         }, condition = base::local({
[18:05:02.059]             c <- base::c
[18:05:02.059]             inherits <- base::inherits
[18:05:02.059]             invokeRestart <- base::invokeRestart
[18:05:02.059]             length <- base::length
[18:05:02.059]             list <- base::list
[18:05:02.059]             seq.int <- base::seq.int
[18:05:02.059]             signalCondition <- base::signalCondition
[18:05:02.059]             sys.calls <- base::sys.calls
[18:05:02.059]             `[[` <- base::`[[`
[18:05:02.059]             `+` <- base::`+`
[18:05:02.059]             `<<-` <- base::`<<-`
[18:05:02.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.059]                   3L)]
[18:05:02.059]             }
[18:05:02.059]             function(cond) {
[18:05:02.059]                 is_error <- inherits(cond, "error")
[18:05:02.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.059]                   NULL)
[18:05:02.059]                 if (is_error) {
[18:05:02.059]                   sessionInformation <- function() {
[18:05:02.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.059]                       search = base::search(), system = base::Sys.info())
[18:05:02.059]                   }
[18:05:02.059]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.059]                     cond$call), session = sessionInformation(), 
[18:05:02.059]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.059]                   signalCondition(cond)
[18:05:02.059]                 }
[18:05:02.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.059]                 "immediateCondition"))) {
[18:05:02.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.059]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.059]                   if (TRUE && !signal) {
[18:05:02.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.059]                     {
[18:05:02.059]                       inherits <- base::inherits
[18:05:02.059]                       invokeRestart <- base::invokeRestart
[18:05:02.059]                       is.null <- base::is.null
[18:05:02.059]                       muffled <- FALSE
[18:05:02.059]                       if (inherits(cond, "message")) {
[18:05:02.059]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.059]                         if (muffled) 
[18:05:02.059]                           invokeRestart("muffleMessage")
[18:05:02.059]                       }
[18:05:02.059]                       else if (inherits(cond, "warning")) {
[18:05:02.059]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.059]                         if (muffled) 
[18:05:02.059]                           invokeRestart("muffleWarning")
[18:05:02.059]                       }
[18:05:02.059]                       else if (inherits(cond, "condition")) {
[18:05:02.059]                         if (!is.null(pattern)) {
[18:05:02.059]                           computeRestarts <- base::computeRestarts
[18:05:02.059]                           grepl <- base::grepl
[18:05:02.059]                           restarts <- computeRestarts(cond)
[18:05:02.059]                           for (restart in restarts) {
[18:05:02.059]                             name <- restart$name
[18:05:02.059]                             if (is.null(name)) 
[18:05:02.059]                               next
[18:05:02.059]                             if (!grepl(pattern, name)) 
[18:05:02.059]                               next
[18:05:02.059]                             invokeRestart(restart)
[18:05:02.059]                             muffled <- TRUE
[18:05:02.059]                             break
[18:05:02.059]                           }
[18:05:02.059]                         }
[18:05:02.059]                       }
[18:05:02.059]                       invisible(muffled)
[18:05:02.059]                     }
[18:05:02.059]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.059]                   }
[18:05:02.059]                 }
[18:05:02.059]                 else {
[18:05:02.059]                   if (TRUE) {
[18:05:02.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.059]                     {
[18:05:02.059]                       inherits <- base::inherits
[18:05:02.059]                       invokeRestart <- base::invokeRestart
[18:05:02.059]                       is.null <- base::is.null
[18:05:02.059]                       muffled <- FALSE
[18:05:02.059]                       if (inherits(cond, "message")) {
[18:05:02.059]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.059]                         if (muffled) 
[18:05:02.059]                           invokeRestart("muffleMessage")
[18:05:02.059]                       }
[18:05:02.059]                       else if (inherits(cond, "warning")) {
[18:05:02.059]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.059]                         if (muffled) 
[18:05:02.059]                           invokeRestart("muffleWarning")
[18:05:02.059]                       }
[18:05:02.059]                       else if (inherits(cond, "condition")) {
[18:05:02.059]                         if (!is.null(pattern)) {
[18:05:02.059]                           computeRestarts <- base::computeRestarts
[18:05:02.059]                           grepl <- base::grepl
[18:05:02.059]                           restarts <- computeRestarts(cond)
[18:05:02.059]                           for (restart in restarts) {
[18:05:02.059]                             name <- restart$name
[18:05:02.059]                             if (is.null(name)) 
[18:05:02.059]                               next
[18:05:02.059]                             if (!grepl(pattern, name)) 
[18:05:02.059]                               next
[18:05:02.059]                             invokeRestart(restart)
[18:05:02.059]                             muffled <- TRUE
[18:05:02.059]                             break
[18:05:02.059]                           }
[18:05:02.059]                         }
[18:05:02.059]                       }
[18:05:02.059]                       invisible(muffled)
[18:05:02.059]                     }
[18:05:02.059]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.059]                   }
[18:05:02.059]                 }
[18:05:02.059]             }
[18:05:02.059]         }))
[18:05:02.059]     }, error = function(ex) {
[18:05:02.059]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.059]                 ...future.rng), started = ...future.startTime, 
[18:05:02.059]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.059]             version = "1.8"), class = "FutureResult")
[18:05:02.059]     }, finally = {
[18:05:02.059]         if (!identical(...future.workdir, getwd())) 
[18:05:02.059]             setwd(...future.workdir)
[18:05:02.059]         {
[18:05:02.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.059]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.059]             }
[18:05:02.059]             base::options(...future.oldOptions)
[18:05:02.059]             if (.Platform$OS.type == "windows") {
[18:05:02.059]                 old_names <- names(...future.oldEnvVars)
[18:05:02.059]                 envs <- base::Sys.getenv()
[18:05:02.059]                 names <- names(envs)
[18:05:02.059]                 common <- intersect(names, old_names)
[18:05:02.059]                 added <- setdiff(names, old_names)
[18:05:02.059]                 removed <- setdiff(old_names, names)
[18:05:02.059]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.059]                   envs[common]]
[18:05:02.059]                 NAMES <- toupper(changed)
[18:05:02.059]                 args <- list()
[18:05:02.059]                 for (kk in seq_along(NAMES)) {
[18:05:02.059]                   name <- changed[[kk]]
[18:05:02.059]                   NAME <- NAMES[[kk]]
[18:05:02.059]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.059]                     next
[18:05:02.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.059]                 }
[18:05:02.059]                 NAMES <- toupper(added)
[18:05:02.059]                 for (kk in seq_along(NAMES)) {
[18:05:02.059]                   name <- added[[kk]]
[18:05:02.059]                   NAME <- NAMES[[kk]]
[18:05:02.059]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.059]                     next
[18:05:02.059]                   args[[name]] <- ""
[18:05:02.059]                 }
[18:05:02.059]                 NAMES <- toupper(removed)
[18:05:02.059]                 for (kk in seq_along(NAMES)) {
[18:05:02.059]                   name <- removed[[kk]]
[18:05:02.059]                   NAME <- NAMES[[kk]]
[18:05:02.059]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.059]                     next
[18:05:02.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.059]                 }
[18:05:02.059]                 if (length(args) > 0) 
[18:05:02.059]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.059]             }
[18:05:02.059]             else {
[18:05:02.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.059]             }
[18:05:02.059]             {
[18:05:02.059]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.059]                   0L) {
[18:05:02.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.059]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.059]                   base::options(opts)
[18:05:02.059]                 }
[18:05:02.059]                 {
[18:05:02.059]                   {
[18:05:02.059]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.059]                     NULL
[18:05:02.059]                   }
[18:05:02.059]                   options(future.plan = NULL)
[18:05:02.059]                   if (is.na(NA_character_)) 
[18:05:02.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.059]                     .init = FALSE)
[18:05:02.059]                 }
[18:05:02.059]             }
[18:05:02.059]         }
[18:05:02.059]     })
[18:05:02.059]     if (TRUE) {
[18:05:02.059]         base::sink(type = "output", split = FALSE)
[18:05:02.059]         if (TRUE) {
[18:05:02.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.059]         }
[18:05:02.059]         else {
[18:05:02.059]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.059]         }
[18:05:02.059]         base::close(...future.stdout)
[18:05:02.059]         ...future.stdout <- NULL
[18:05:02.059]     }
[18:05:02.059]     ...future.result$conditions <- ...future.conditions
[18:05:02.059]     ...future.result$finished <- base::Sys.time()
[18:05:02.059]     ...future.result
[18:05:02.059] }
[18:05:02.064] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[18:05:02.064] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[18:05:02.065] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[18:05:02.065] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[18:05:02.066] MultisessionFuture started
[18:05:02.067] - Launch lazy future ... done
[18:05:02.067] run() for ‘MultisessionFuture’ ... done
[18:05:02.067] result() for ClusterFuture ...
[18:05:02.067] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.068] - Validating connection of MultisessionFuture
[18:05:02.112] - received message: FutureResult
[18:05:02.112] - Received FutureResult
[18:05:02.113] - Erased future from FutureRegistry
[18:05:02.113] result() for ClusterFuture ...
[18:05:02.113] - result already collected: FutureResult
[18:05:02.113] result() for ClusterFuture ... done
[18:05:02.114] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.114] result() for ClusterFuture ... done
[18:05:02.114] result() for ClusterFuture ...
[18:05:02.114] - result already collected: FutureResult
[18:05:02.114] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.116] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.116] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.121] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.121] Searching for globals ... DONE
[18:05:02.121] Resolving globals: TRUE
[18:05:02.121] Resolving any globals that are futures ...
[18:05:02.122] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.122] Resolving any globals that are futures ... DONE
[18:05:02.123] Resolving futures part of globals (recursively) ...
[18:05:02.123] resolve() on list ...
[18:05:02.123]  recursive: 99
[18:05:02.124]  length: 2
[18:05:02.124]  elements: ‘a’, ‘ii’
[18:05:02.124]  length: 1 (resolved future 1)
[18:05:02.124]  length: 0 (resolved future 2)
[18:05:02.125] resolve() on list ... DONE
[18:05:02.125] - globals: [2] ‘a’, ‘ii’
[18:05:02.125] Resolving futures part of globals (recursively) ... DONE
[18:05:02.126] The total size of the 2 globals is 112 bytes (112 bytes)
[18:05:02.127] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:05:02.127] - globals: [2] ‘a’, ‘ii’
[18:05:02.127] 
[18:05:02.127] getGlobalsAndPackages() ... DONE
[18:05:02.128] run() for ‘Future’ ...
[18:05:02.128] - state: ‘created’
[18:05:02.128] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.153] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.153]   - Field: ‘node’
[18:05:02.154]   - Field: ‘label’
[18:05:02.154]   - Field: ‘local’
[18:05:02.154]   - Field: ‘owner’
[18:05:02.154]   - Field: ‘envir’
[18:05:02.154]   - Field: ‘workers’
[18:05:02.155]   - Field: ‘packages’
[18:05:02.155]   - Field: ‘gc’
[18:05:02.155]   - Field: ‘conditions’
[18:05:02.155]   - Field: ‘persistent’
[18:05:02.160]   - Field: ‘expr’
[18:05:02.160]   - Field: ‘uuid’
[18:05:02.160]   - Field: ‘seed’
[18:05:02.160]   - Field: ‘version’
[18:05:02.161]   - Field: ‘result’
[18:05:02.161]   - Field: ‘asynchronous’
[18:05:02.161]   - Field: ‘calls’
[18:05:02.161]   - Field: ‘globals’
[18:05:02.161]   - Field: ‘stdout’
[18:05:02.162]   - Field: ‘earlySignal’
[18:05:02.162]   - Field: ‘lazy’
[18:05:02.162]   - Field: ‘state’
[18:05:02.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.162] - Launch lazy future ...
[18:05:02.163] Packages needed by the future expression (n = 0): <none>
[18:05:02.163] Packages needed by future strategies (n = 0): <none>
[18:05:02.164] {
[18:05:02.164]     {
[18:05:02.164]         {
[18:05:02.164]             ...future.startTime <- base::Sys.time()
[18:05:02.164]             {
[18:05:02.164]                 {
[18:05:02.164]                   {
[18:05:02.164]                     {
[18:05:02.164]                       base::local({
[18:05:02.164]                         has_future <- base::requireNamespace("future", 
[18:05:02.164]                           quietly = TRUE)
[18:05:02.164]                         if (has_future) {
[18:05:02.164]                           ns <- base::getNamespace("future")
[18:05:02.164]                           version <- ns[[".package"]][["version"]]
[18:05:02.164]                           if (is.null(version)) 
[18:05:02.164]                             version <- utils::packageVersion("future")
[18:05:02.164]                         }
[18:05:02.164]                         else {
[18:05:02.164]                           version <- NULL
[18:05:02.164]                         }
[18:05:02.164]                         if (!has_future || version < "1.8.0") {
[18:05:02.164]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.164]                             "", base::R.version$version.string), 
[18:05:02.164]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:02.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:02.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.164]                               "release", "version")], collapse = " "), 
[18:05:02.164]                             hostname = base::Sys.info()[["nodename"]])
[18:05:02.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.164]                             info)
[18:05:02.164]                           info <- base::paste(info, collapse = "; ")
[18:05:02.164]                           if (!has_future) {
[18:05:02.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.164]                               info)
[18:05:02.164]                           }
[18:05:02.164]                           else {
[18:05:02.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.164]                               info, version)
[18:05:02.164]                           }
[18:05:02.164]                           base::stop(msg)
[18:05:02.164]                         }
[18:05:02.164]                       })
[18:05:02.164]                     }
[18:05:02.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.164]                     base::options(mc.cores = 1L)
[18:05:02.164]                   }
[18:05:02.164]                   ...future.strategy.old <- future::plan("list")
[18:05:02.164]                   options(future.plan = NULL)
[18:05:02.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.164]                 }
[18:05:02.164]                 ...future.workdir <- getwd()
[18:05:02.164]             }
[18:05:02.164]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.164]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.164]         }
[18:05:02.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.164]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.164]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.164]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.164]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.164]             base::names(...future.oldOptions))
[18:05:02.164]     }
[18:05:02.164]     if (FALSE) {
[18:05:02.164]     }
[18:05:02.164]     else {
[18:05:02.164]         if (TRUE) {
[18:05:02.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.164]                 open = "w")
[18:05:02.164]         }
[18:05:02.164]         else {
[18:05:02.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.164]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.164]         }
[18:05:02.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.164]             base::sink(type = "output", split = FALSE)
[18:05:02.164]             base::close(...future.stdout)
[18:05:02.164]         }, add = TRUE)
[18:05:02.164]     }
[18:05:02.164]     ...future.frame <- base::sys.nframe()
[18:05:02.164]     ...future.conditions <- base::list()
[18:05:02.164]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.164]     if (FALSE) {
[18:05:02.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.164]     }
[18:05:02.164]     ...future.result <- base::tryCatch({
[18:05:02.164]         base::withCallingHandlers({
[18:05:02.164]             ...future.value <- base::withVisible(base::local({
[18:05:02.164]                 ...future.makeSendCondition <- base::local({
[18:05:02.164]                   sendCondition <- NULL
[18:05:02.164]                   function(frame = 1L) {
[18:05:02.164]                     if (is.function(sendCondition)) 
[18:05:02.164]                       return(sendCondition)
[18:05:02.164]                     ns <- getNamespace("parallel")
[18:05:02.164]                     if (exists("sendData", mode = "function", 
[18:05:02.164]                       envir = ns)) {
[18:05:02.164]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.164]                         envir = ns)
[18:05:02.164]                       envir <- sys.frame(frame)
[18:05:02.164]                       master <- NULL
[18:05:02.164]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.164]                         !identical(envir, emptyenv())) {
[18:05:02.164]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.164]                           inherits = FALSE)) {
[18:05:02.164]                           master <- get("master", mode = "list", 
[18:05:02.164]                             envir = envir, inherits = FALSE)
[18:05:02.164]                           if (inherits(master, c("SOCKnode", 
[18:05:02.164]                             "SOCK0node"))) {
[18:05:02.164]                             sendCondition <<- function(cond) {
[18:05:02.164]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.164]                                 success = TRUE)
[18:05:02.164]                               parallel_sendData(master, data)
[18:05:02.164]                             }
[18:05:02.164]                             return(sendCondition)
[18:05:02.164]                           }
[18:05:02.164]                         }
[18:05:02.164]                         frame <- frame + 1L
[18:05:02.164]                         envir <- sys.frame(frame)
[18:05:02.164]                       }
[18:05:02.164]                     }
[18:05:02.164]                     sendCondition <<- function(cond) NULL
[18:05:02.164]                   }
[18:05:02.164]                 })
[18:05:02.164]                 withCallingHandlers({
[18:05:02.164]                   {
[18:05:02.164]                     b <- a * ii
[18:05:02.164]                     a <- 0
[18:05:02.164]                     b
[18:05:02.164]                   }
[18:05:02.164]                 }, immediateCondition = function(cond) {
[18:05:02.164]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.164]                   sendCondition(cond)
[18:05:02.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.164]                   {
[18:05:02.164]                     inherits <- base::inherits
[18:05:02.164]                     invokeRestart <- base::invokeRestart
[18:05:02.164]                     is.null <- base::is.null
[18:05:02.164]                     muffled <- FALSE
[18:05:02.164]                     if (inherits(cond, "message")) {
[18:05:02.164]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.164]                       if (muffled) 
[18:05:02.164]                         invokeRestart("muffleMessage")
[18:05:02.164]                     }
[18:05:02.164]                     else if (inherits(cond, "warning")) {
[18:05:02.164]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.164]                       if (muffled) 
[18:05:02.164]                         invokeRestart("muffleWarning")
[18:05:02.164]                     }
[18:05:02.164]                     else if (inherits(cond, "condition")) {
[18:05:02.164]                       if (!is.null(pattern)) {
[18:05:02.164]                         computeRestarts <- base::computeRestarts
[18:05:02.164]                         grepl <- base::grepl
[18:05:02.164]                         restarts <- computeRestarts(cond)
[18:05:02.164]                         for (restart in restarts) {
[18:05:02.164]                           name <- restart$name
[18:05:02.164]                           if (is.null(name)) 
[18:05:02.164]                             next
[18:05:02.164]                           if (!grepl(pattern, name)) 
[18:05:02.164]                             next
[18:05:02.164]                           invokeRestart(restart)
[18:05:02.164]                           muffled <- TRUE
[18:05:02.164]                           break
[18:05:02.164]                         }
[18:05:02.164]                       }
[18:05:02.164]                     }
[18:05:02.164]                     invisible(muffled)
[18:05:02.164]                   }
[18:05:02.164]                   muffleCondition(cond)
[18:05:02.164]                 })
[18:05:02.164]             }))
[18:05:02.164]             future::FutureResult(value = ...future.value$value, 
[18:05:02.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.164]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.164]                     ...future.globalenv.names))
[18:05:02.164]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.164]         }, condition = base::local({
[18:05:02.164]             c <- base::c
[18:05:02.164]             inherits <- base::inherits
[18:05:02.164]             invokeRestart <- base::invokeRestart
[18:05:02.164]             length <- base::length
[18:05:02.164]             list <- base::list
[18:05:02.164]             seq.int <- base::seq.int
[18:05:02.164]             signalCondition <- base::signalCondition
[18:05:02.164]             sys.calls <- base::sys.calls
[18:05:02.164]             `[[` <- base::`[[`
[18:05:02.164]             `+` <- base::`+`
[18:05:02.164]             `<<-` <- base::`<<-`
[18:05:02.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.164]                   3L)]
[18:05:02.164]             }
[18:05:02.164]             function(cond) {
[18:05:02.164]                 is_error <- inherits(cond, "error")
[18:05:02.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.164]                   NULL)
[18:05:02.164]                 if (is_error) {
[18:05:02.164]                   sessionInformation <- function() {
[18:05:02.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.164]                       search = base::search(), system = base::Sys.info())
[18:05:02.164]                   }
[18:05:02.164]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.164]                     cond$call), session = sessionInformation(), 
[18:05:02.164]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.164]                   signalCondition(cond)
[18:05:02.164]                 }
[18:05:02.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.164]                 "immediateCondition"))) {
[18:05:02.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.164]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.164]                   if (TRUE && !signal) {
[18:05:02.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.164]                     {
[18:05:02.164]                       inherits <- base::inherits
[18:05:02.164]                       invokeRestart <- base::invokeRestart
[18:05:02.164]                       is.null <- base::is.null
[18:05:02.164]                       muffled <- FALSE
[18:05:02.164]                       if (inherits(cond, "message")) {
[18:05:02.164]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.164]                         if (muffled) 
[18:05:02.164]                           invokeRestart("muffleMessage")
[18:05:02.164]                       }
[18:05:02.164]                       else if (inherits(cond, "warning")) {
[18:05:02.164]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.164]                         if (muffled) 
[18:05:02.164]                           invokeRestart("muffleWarning")
[18:05:02.164]                       }
[18:05:02.164]                       else if (inherits(cond, "condition")) {
[18:05:02.164]                         if (!is.null(pattern)) {
[18:05:02.164]                           computeRestarts <- base::computeRestarts
[18:05:02.164]                           grepl <- base::grepl
[18:05:02.164]                           restarts <- computeRestarts(cond)
[18:05:02.164]                           for (restart in restarts) {
[18:05:02.164]                             name <- restart$name
[18:05:02.164]                             if (is.null(name)) 
[18:05:02.164]                               next
[18:05:02.164]                             if (!grepl(pattern, name)) 
[18:05:02.164]                               next
[18:05:02.164]                             invokeRestart(restart)
[18:05:02.164]                             muffled <- TRUE
[18:05:02.164]                             break
[18:05:02.164]                           }
[18:05:02.164]                         }
[18:05:02.164]                       }
[18:05:02.164]                       invisible(muffled)
[18:05:02.164]                     }
[18:05:02.164]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.164]                   }
[18:05:02.164]                 }
[18:05:02.164]                 else {
[18:05:02.164]                   if (TRUE) {
[18:05:02.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.164]                     {
[18:05:02.164]                       inherits <- base::inherits
[18:05:02.164]                       invokeRestart <- base::invokeRestart
[18:05:02.164]                       is.null <- base::is.null
[18:05:02.164]                       muffled <- FALSE
[18:05:02.164]                       if (inherits(cond, "message")) {
[18:05:02.164]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.164]                         if (muffled) 
[18:05:02.164]                           invokeRestart("muffleMessage")
[18:05:02.164]                       }
[18:05:02.164]                       else if (inherits(cond, "warning")) {
[18:05:02.164]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.164]                         if (muffled) 
[18:05:02.164]                           invokeRestart("muffleWarning")
[18:05:02.164]                       }
[18:05:02.164]                       else if (inherits(cond, "condition")) {
[18:05:02.164]                         if (!is.null(pattern)) {
[18:05:02.164]                           computeRestarts <- base::computeRestarts
[18:05:02.164]                           grepl <- base::grepl
[18:05:02.164]                           restarts <- computeRestarts(cond)
[18:05:02.164]                           for (restart in restarts) {
[18:05:02.164]                             name <- restart$name
[18:05:02.164]                             if (is.null(name)) 
[18:05:02.164]                               next
[18:05:02.164]                             if (!grepl(pattern, name)) 
[18:05:02.164]                               next
[18:05:02.164]                             invokeRestart(restart)
[18:05:02.164]                             muffled <- TRUE
[18:05:02.164]                             break
[18:05:02.164]                           }
[18:05:02.164]                         }
[18:05:02.164]                       }
[18:05:02.164]                       invisible(muffled)
[18:05:02.164]                     }
[18:05:02.164]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.164]                   }
[18:05:02.164]                 }
[18:05:02.164]             }
[18:05:02.164]         }))
[18:05:02.164]     }, error = function(ex) {
[18:05:02.164]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.164]                 ...future.rng), started = ...future.startTime, 
[18:05:02.164]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.164]             version = "1.8"), class = "FutureResult")
[18:05:02.164]     }, finally = {
[18:05:02.164]         if (!identical(...future.workdir, getwd())) 
[18:05:02.164]             setwd(...future.workdir)
[18:05:02.164]         {
[18:05:02.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.164]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.164]             }
[18:05:02.164]             base::options(...future.oldOptions)
[18:05:02.164]             if (.Platform$OS.type == "windows") {
[18:05:02.164]                 old_names <- names(...future.oldEnvVars)
[18:05:02.164]                 envs <- base::Sys.getenv()
[18:05:02.164]                 names <- names(envs)
[18:05:02.164]                 common <- intersect(names, old_names)
[18:05:02.164]                 added <- setdiff(names, old_names)
[18:05:02.164]                 removed <- setdiff(old_names, names)
[18:05:02.164]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.164]                   envs[common]]
[18:05:02.164]                 NAMES <- toupper(changed)
[18:05:02.164]                 args <- list()
[18:05:02.164]                 for (kk in seq_along(NAMES)) {
[18:05:02.164]                   name <- changed[[kk]]
[18:05:02.164]                   NAME <- NAMES[[kk]]
[18:05:02.164]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.164]                     next
[18:05:02.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.164]                 }
[18:05:02.164]                 NAMES <- toupper(added)
[18:05:02.164]                 for (kk in seq_along(NAMES)) {
[18:05:02.164]                   name <- added[[kk]]
[18:05:02.164]                   NAME <- NAMES[[kk]]
[18:05:02.164]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.164]                     next
[18:05:02.164]                   args[[name]] <- ""
[18:05:02.164]                 }
[18:05:02.164]                 NAMES <- toupper(removed)
[18:05:02.164]                 for (kk in seq_along(NAMES)) {
[18:05:02.164]                   name <- removed[[kk]]
[18:05:02.164]                   NAME <- NAMES[[kk]]
[18:05:02.164]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.164]                     next
[18:05:02.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.164]                 }
[18:05:02.164]                 if (length(args) > 0) 
[18:05:02.164]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.164]             }
[18:05:02.164]             else {
[18:05:02.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.164]             }
[18:05:02.164]             {
[18:05:02.164]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.164]                   0L) {
[18:05:02.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.164]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.164]                   base::options(opts)
[18:05:02.164]                 }
[18:05:02.164]                 {
[18:05:02.164]                   {
[18:05:02.164]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.164]                     NULL
[18:05:02.164]                   }
[18:05:02.164]                   options(future.plan = NULL)
[18:05:02.164]                   if (is.na(NA_character_)) 
[18:05:02.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.164]                     .init = FALSE)
[18:05:02.164]                 }
[18:05:02.164]             }
[18:05:02.164]         }
[18:05:02.164]     })
[18:05:02.164]     if (TRUE) {
[18:05:02.164]         base::sink(type = "output", split = FALSE)
[18:05:02.164]         if (TRUE) {
[18:05:02.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.164]         }
[18:05:02.164]         else {
[18:05:02.164]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.164]         }
[18:05:02.164]         base::close(...future.stdout)
[18:05:02.164]         ...future.stdout <- NULL
[18:05:02.164]     }
[18:05:02.164]     ...future.result$conditions <- ...future.conditions
[18:05:02.164]     ...future.result$finished <- base::Sys.time()
[18:05:02.164]     ...future.result
[18:05:02.164] }
[18:05:02.169] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[18:05:02.170] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[18:05:02.170] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[18:05:02.171] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[18:05:02.172] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[18:05:02.172] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[18:05:02.173] MultisessionFuture started
[18:05:02.173] - Launch lazy future ... done
[18:05:02.173] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.174] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.175] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.179] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.179] Searching for globals ... DONE
[18:05:02.180] Resolving globals: TRUE
[18:05:02.180] Resolving any globals that are futures ...
[18:05:02.180] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.180] Resolving any globals that are futures ... DONE
[18:05:02.181] Resolving futures part of globals (recursively) ...
[18:05:02.182] resolve() on list ...
[18:05:02.182]  recursive: 99
[18:05:02.182]  length: 2
[18:05:02.182]  elements: ‘a’, ‘ii’
[18:05:02.183]  length: 1 (resolved future 1)
[18:05:02.183]  length: 0 (resolved future 2)
[18:05:02.183] resolve() on list ... DONE
[18:05:02.183] - globals: [2] ‘a’, ‘ii’
[18:05:02.183] Resolving futures part of globals (recursively) ... DONE
[18:05:02.184] The total size of the 2 globals is 112 bytes (112 bytes)
[18:05:02.185] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:05:02.185] - globals: [2] ‘a’, ‘ii’
[18:05:02.185] 
[18:05:02.185] getGlobalsAndPackages() ... DONE
[18:05:02.186] run() for ‘Future’ ...
[18:05:02.186] - state: ‘created’
[18:05:02.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.209] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.209]   - Field: ‘node’
[18:05:02.210]   - Field: ‘label’
[18:05:02.210]   - Field: ‘local’
[18:05:02.210]   - Field: ‘owner’
[18:05:02.210]   - Field: ‘envir’
[18:05:02.210]   - Field: ‘workers’
[18:05:02.211]   - Field: ‘packages’
[18:05:02.211]   - Field: ‘gc’
[18:05:02.211]   - Field: ‘conditions’
[18:05:02.211]   - Field: ‘persistent’
[18:05:02.211]   - Field: ‘expr’
[18:05:02.212]   - Field: ‘uuid’
[18:05:02.212]   - Field: ‘seed’
[18:05:02.212]   - Field: ‘version’
[18:05:02.212]   - Field: ‘result’
[18:05:02.212]   - Field: ‘asynchronous’
[18:05:02.213]   - Field: ‘calls’
[18:05:02.213]   - Field: ‘globals’
[18:05:02.213]   - Field: ‘stdout’
[18:05:02.213]   - Field: ‘earlySignal’
[18:05:02.213]   - Field: ‘lazy’
[18:05:02.214]   - Field: ‘state’
[18:05:02.214] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.214] - Launch lazy future ...
[18:05:02.214] Packages needed by the future expression (n = 0): <none>
[18:05:02.215] Packages needed by future strategies (n = 0): <none>
[18:05:02.216] {
[18:05:02.216]     {
[18:05:02.216]         {
[18:05:02.216]             ...future.startTime <- base::Sys.time()
[18:05:02.216]             {
[18:05:02.216]                 {
[18:05:02.216]                   {
[18:05:02.216]                     {
[18:05:02.216]                       base::local({
[18:05:02.216]                         has_future <- base::requireNamespace("future", 
[18:05:02.216]                           quietly = TRUE)
[18:05:02.216]                         if (has_future) {
[18:05:02.216]                           ns <- base::getNamespace("future")
[18:05:02.216]                           version <- ns[[".package"]][["version"]]
[18:05:02.216]                           if (is.null(version)) 
[18:05:02.216]                             version <- utils::packageVersion("future")
[18:05:02.216]                         }
[18:05:02.216]                         else {
[18:05:02.216]                           version <- NULL
[18:05:02.216]                         }
[18:05:02.216]                         if (!has_future || version < "1.8.0") {
[18:05:02.216]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.216]                             "", base::R.version$version.string), 
[18:05:02.216]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:02.216]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:02.216]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.216]                               "release", "version")], collapse = " "), 
[18:05:02.216]                             hostname = base::Sys.info()[["nodename"]])
[18:05:02.216]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.216]                             info)
[18:05:02.216]                           info <- base::paste(info, collapse = "; ")
[18:05:02.216]                           if (!has_future) {
[18:05:02.216]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.216]                               info)
[18:05:02.216]                           }
[18:05:02.216]                           else {
[18:05:02.216]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.216]                               info, version)
[18:05:02.216]                           }
[18:05:02.216]                           base::stop(msg)
[18:05:02.216]                         }
[18:05:02.216]                       })
[18:05:02.216]                     }
[18:05:02.216]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.216]                     base::options(mc.cores = 1L)
[18:05:02.216]                   }
[18:05:02.216]                   ...future.strategy.old <- future::plan("list")
[18:05:02.216]                   options(future.plan = NULL)
[18:05:02.216]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.216]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.216]                 }
[18:05:02.216]                 ...future.workdir <- getwd()
[18:05:02.216]             }
[18:05:02.216]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.216]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.216]         }
[18:05:02.216]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.216]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.216]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.216]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.216]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.216]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.216]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.216]             base::names(...future.oldOptions))
[18:05:02.216]     }
[18:05:02.216]     if (FALSE) {
[18:05:02.216]     }
[18:05:02.216]     else {
[18:05:02.216]         if (TRUE) {
[18:05:02.216]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.216]                 open = "w")
[18:05:02.216]         }
[18:05:02.216]         else {
[18:05:02.216]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.216]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.216]         }
[18:05:02.216]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.216]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.216]             base::sink(type = "output", split = FALSE)
[18:05:02.216]             base::close(...future.stdout)
[18:05:02.216]         }, add = TRUE)
[18:05:02.216]     }
[18:05:02.216]     ...future.frame <- base::sys.nframe()
[18:05:02.216]     ...future.conditions <- base::list()
[18:05:02.216]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.216]     if (FALSE) {
[18:05:02.216]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.216]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.216]     }
[18:05:02.216]     ...future.result <- base::tryCatch({
[18:05:02.216]         base::withCallingHandlers({
[18:05:02.216]             ...future.value <- base::withVisible(base::local({
[18:05:02.216]                 ...future.makeSendCondition <- base::local({
[18:05:02.216]                   sendCondition <- NULL
[18:05:02.216]                   function(frame = 1L) {
[18:05:02.216]                     if (is.function(sendCondition)) 
[18:05:02.216]                       return(sendCondition)
[18:05:02.216]                     ns <- getNamespace("parallel")
[18:05:02.216]                     if (exists("sendData", mode = "function", 
[18:05:02.216]                       envir = ns)) {
[18:05:02.216]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.216]                         envir = ns)
[18:05:02.216]                       envir <- sys.frame(frame)
[18:05:02.216]                       master <- NULL
[18:05:02.216]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.216]                         !identical(envir, emptyenv())) {
[18:05:02.216]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.216]                           inherits = FALSE)) {
[18:05:02.216]                           master <- get("master", mode = "list", 
[18:05:02.216]                             envir = envir, inherits = FALSE)
[18:05:02.216]                           if (inherits(master, c("SOCKnode", 
[18:05:02.216]                             "SOCK0node"))) {
[18:05:02.216]                             sendCondition <<- function(cond) {
[18:05:02.216]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.216]                                 success = TRUE)
[18:05:02.216]                               parallel_sendData(master, data)
[18:05:02.216]                             }
[18:05:02.216]                             return(sendCondition)
[18:05:02.216]                           }
[18:05:02.216]                         }
[18:05:02.216]                         frame <- frame + 1L
[18:05:02.216]                         envir <- sys.frame(frame)
[18:05:02.216]                       }
[18:05:02.216]                     }
[18:05:02.216]                     sendCondition <<- function(cond) NULL
[18:05:02.216]                   }
[18:05:02.216]                 })
[18:05:02.216]                 withCallingHandlers({
[18:05:02.216]                   {
[18:05:02.216]                     b <- a * ii
[18:05:02.216]                     a <- 0
[18:05:02.216]                     b
[18:05:02.216]                   }
[18:05:02.216]                 }, immediateCondition = function(cond) {
[18:05:02.216]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.216]                   sendCondition(cond)
[18:05:02.216]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.216]                   {
[18:05:02.216]                     inherits <- base::inherits
[18:05:02.216]                     invokeRestart <- base::invokeRestart
[18:05:02.216]                     is.null <- base::is.null
[18:05:02.216]                     muffled <- FALSE
[18:05:02.216]                     if (inherits(cond, "message")) {
[18:05:02.216]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.216]                       if (muffled) 
[18:05:02.216]                         invokeRestart("muffleMessage")
[18:05:02.216]                     }
[18:05:02.216]                     else if (inherits(cond, "warning")) {
[18:05:02.216]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.216]                       if (muffled) 
[18:05:02.216]                         invokeRestart("muffleWarning")
[18:05:02.216]                     }
[18:05:02.216]                     else if (inherits(cond, "condition")) {
[18:05:02.216]                       if (!is.null(pattern)) {
[18:05:02.216]                         computeRestarts <- base::computeRestarts
[18:05:02.216]                         grepl <- base::grepl
[18:05:02.216]                         restarts <- computeRestarts(cond)
[18:05:02.216]                         for (restart in restarts) {
[18:05:02.216]                           name <- restart$name
[18:05:02.216]                           if (is.null(name)) 
[18:05:02.216]                             next
[18:05:02.216]                           if (!grepl(pattern, name)) 
[18:05:02.216]                             next
[18:05:02.216]                           invokeRestart(restart)
[18:05:02.216]                           muffled <- TRUE
[18:05:02.216]                           break
[18:05:02.216]                         }
[18:05:02.216]                       }
[18:05:02.216]                     }
[18:05:02.216]                     invisible(muffled)
[18:05:02.216]                   }
[18:05:02.216]                   muffleCondition(cond)
[18:05:02.216]                 })
[18:05:02.216]             }))
[18:05:02.216]             future::FutureResult(value = ...future.value$value, 
[18:05:02.216]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.216]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.216]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.216]                     ...future.globalenv.names))
[18:05:02.216]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.216]         }, condition = base::local({
[18:05:02.216]             c <- base::c
[18:05:02.216]             inherits <- base::inherits
[18:05:02.216]             invokeRestart <- base::invokeRestart
[18:05:02.216]             length <- base::length
[18:05:02.216]             list <- base::list
[18:05:02.216]             seq.int <- base::seq.int
[18:05:02.216]             signalCondition <- base::signalCondition
[18:05:02.216]             sys.calls <- base::sys.calls
[18:05:02.216]             `[[` <- base::`[[`
[18:05:02.216]             `+` <- base::`+`
[18:05:02.216]             `<<-` <- base::`<<-`
[18:05:02.216]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.216]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.216]                   3L)]
[18:05:02.216]             }
[18:05:02.216]             function(cond) {
[18:05:02.216]                 is_error <- inherits(cond, "error")
[18:05:02.216]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.216]                   NULL)
[18:05:02.216]                 if (is_error) {
[18:05:02.216]                   sessionInformation <- function() {
[18:05:02.216]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.216]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.216]                       search = base::search(), system = base::Sys.info())
[18:05:02.216]                   }
[18:05:02.216]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.216]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.216]                     cond$call), session = sessionInformation(), 
[18:05:02.216]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.216]                   signalCondition(cond)
[18:05:02.216]                 }
[18:05:02.216]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.216]                 "immediateCondition"))) {
[18:05:02.216]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.216]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.216]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.216]                   if (TRUE && !signal) {
[18:05:02.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.216]                     {
[18:05:02.216]                       inherits <- base::inherits
[18:05:02.216]                       invokeRestart <- base::invokeRestart
[18:05:02.216]                       is.null <- base::is.null
[18:05:02.216]                       muffled <- FALSE
[18:05:02.216]                       if (inherits(cond, "message")) {
[18:05:02.216]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.216]                         if (muffled) 
[18:05:02.216]                           invokeRestart("muffleMessage")
[18:05:02.216]                       }
[18:05:02.216]                       else if (inherits(cond, "warning")) {
[18:05:02.216]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.216]                         if (muffled) 
[18:05:02.216]                           invokeRestart("muffleWarning")
[18:05:02.216]                       }
[18:05:02.216]                       else if (inherits(cond, "condition")) {
[18:05:02.216]                         if (!is.null(pattern)) {
[18:05:02.216]                           computeRestarts <- base::computeRestarts
[18:05:02.216]                           grepl <- base::grepl
[18:05:02.216]                           restarts <- computeRestarts(cond)
[18:05:02.216]                           for (restart in restarts) {
[18:05:02.216]                             name <- restart$name
[18:05:02.216]                             if (is.null(name)) 
[18:05:02.216]                               next
[18:05:02.216]                             if (!grepl(pattern, name)) 
[18:05:02.216]                               next
[18:05:02.216]                             invokeRestart(restart)
[18:05:02.216]                             muffled <- TRUE
[18:05:02.216]                             break
[18:05:02.216]                           }
[18:05:02.216]                         }
[18:05:02.216]                       }
[18:05:02.216]                       invisible(muffled)
[18:05:02.216]                     }
[18:05:02.216]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.216]                   }
[18:05:02.216]                 }
[18:05:02.216]                 else {
[18:05:02.216]                   if (TRUE) {
[18:05:02.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.216]                     {
[18:05:02.216]                       inherits <- base::inherits
[18:05:02.216]                       invokeRestart <- base::invokeRestart
[18:05:02.216]                       is.null <- base::is.null
[18:05:02.216]                       muffled <- FALSE
[18:05:02.216]                       if (inherits(cond, "message")) {
[18:05:02.216]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.216]                         if (muffled) 
[18:05:02.216]                           invokeRestart("muffleMessage")
[18:05:02.216]                       }
[18:05:02.216]                       else if (inherits(cond, "warning")) {
[18:05:02.216]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.216]                         if (muffled) 
[18:05:02.216]                           invokeRestart("muffleWarning")
[18:05:02.216]                       }
[18:05:02.216]                       else if (inherits(cond, "condition")) {
[18:05:02.216]                         if (!is.null(pattern)) {
[18:05:02.216]                           computeRestarts <- base::computeRestarts
[18:05:02.216]                           grepl <- base::grepl
[18:05:02.216]                           restarts <- computeRestarts(cond)
[18:05:02.216]                           for (restart in restarts) {
[18:05:02.216]                             name <- restart$name
[18:05:02.216]                             if (is.null(name)) 
[18:05:02.216]                               next
[18:05:02.216]                             if (!grepl(pattern, name)) 
[18:05:02.216]                               next
[18:05:02.216]                             invokeRestart(restart)
[18:05:02.216]                             muffled <- TRUE
[18:05:02.216]                             break
[18:05:02.216]                           }
[18:05:02.216]                         }
[18:05:02.216]                       }
[18:05:02.216]                       invisible(muffled)
[18:05:02.216]                     }
[18:05:02.216]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.216]                   }
[18:05:02.216]                 }
[18:05:02.216]             }
[18:05:02.216]         }))
[18:05:02.216]     }, error = function(ex) {
[18:05:02.216]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.216]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.216]                 ...future.rng), started = ...future.startTime, 
[18:05:02.216]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.216]             version = "1.8"), class = "FutureResult")
[18:05:02.216]     }, finally = {
[18:05:02.216]         if (!identical(...future.workdir, getwd())) 
[18:05:02.216]             setwd(...future.workdir)
[18:05:02.216]         {
[18:05:02.216]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.216]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.216]             }
[18:05:02.216]             base::options(...future.oldOptions)
[18:05:02.216]             if (.Platform$OS.type == "windows") {
[18:05:02.216]                 old_names <- names(...future.oldEnvVars)
[18:05:02.216]                 envs <- base::Sys.getenv()
[18:05:02.216]                 names <- names(envs)
[18:05:02.216]                 common <- intersect(names, old_names)
[18:05:02.216]                 added <- setdiff(names, old_names)
[18:05:02.216]                 removed <- setdiff(old_names, names)
[18:05:02.216]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.216]                   envs[common]]
[18:05:02.216]                 NAMES <- toupper(changed)
[18:05:02.216]                 args <- list()
[18:05:02.216]                 for (kk in seq_along(NAMES)) {
[18:05:02.216]                   name <- changed[[kk]]
[18:05:02.216]                   NAME <- NAMES[[kk]]
[18:05:02.216]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.216]                     next
[18:05:02.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.216]                 }
[18:05:02.216]                 NAMES <- toupper(added)
[18:05:02.216]                 for (kk in seq_along(NAMES)) {
[18:05:02.216]                   name <- added[[kk]]
[18:05:02.216]                   NAME <- NAMES[[kk]]
[18:05:02.216]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.216]                     next
[18:05:02.216]                   args[[name]] <- ""
[18:05:02.216]                 }
[18:05:02.216]                 NAMES <- toupper(removed)
[18:05:02.216]                 for (kk in seq_along(NAMES)) {
[18:05:02.216]                   name <- removed[[kk]]
[18:05:02.216]                   NAME <- NAMES[[kk]]
[18:05:02.216]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.216]                     next
[18:05:02.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.216]                 }
[18:05:02.216]                 if (length(args) > 0) 
[18:05:02.216]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.216]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.216]             }
[18:05:02.216]             else {
[18:05:02.216]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.216]             }
[18:05:02.216]             {
[18:05:02.216]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.216]                   0L) {
[18:05:02.216]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.216]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.216]                   base::options(opts)
[18:05:02.216]                 }
[18:05:02.216]                 {
[18:05:02.216]                   {
[18:05:02.216]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.216]                     NULL
[18:05:02.216]                   }
[18:05:02.216]                   options(future.plan = NULL)
[18:05:02.216]                   if (is.na(NA_character_)) 
[18:05:02.216]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.216]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.216]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.216]                     .init = FALSE)
[18:05:02.216]                 }
[18:05:02.216]             }
[18:05:02.216]         }
[18:05:02.216]     })
[18:05:02.216]     if (TRUE) {
[18:05:02.216]         base::sink(type = "output", split = FALSE)
[18:05:02.216]         if (TRUE) {
[18:05:02.216]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.216]         }
[18:05:02.216]         else {
[18:05:02.216]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.216]         }
[18:05:02.216]         base::close(...future.stdout)
[18:05:02.216]         ...future.stdout <- NULL
[18:05:02.216]     }
[18:05:02.216]     ...future.result$conditions <- ...future.conditions
[18:05:02.216]     ...future.result$finished <- base::Sys.time()
[18:05:02.216]     ...future.result
[18:05:02.216] }
[18:05:02.220] Poll #1 (0): usedNodes() = 2, workers = 2
[18:05:02.231] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.231] - Validating connection of MultisessionFuture
[18:05:02.232] - received message: FutureResult
[18:05:02.232] - Received FutureResult
[18:05:02.232] - Erased future from FutureRegistry
[18:05:02.232] result() for ClusterFuture ...
[18:05:02.233] - result already collected: FutureResult
[18:05:02.233] result() for ClusterFuture ... done
[18:05:02.233] signalConditions() ...
[18:05:02.233]  - include = ‘immediateCondition’
[18:05:02.233]  - exclude = 
[18:05:02.234]  - resignal = FALSE
[18:05:02.234]  - Number of conditions: 1
[18:05:02.234] signalConditions() ... done
[18:05:02.234] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.234] result() for ClusterFuture ...
[18:05:02.234] - result already collected: FutureResult
[18:05:02.235] result() for ClusterFuture ... done
[18:05:02.235] result() for ClusterFuture ...
[18:05:02.235] - result already collected: FutureResult
[18:05:02.235] result() for ClusterFuture ... done
[18:05:02.235] signalConditions() ...
[18:05:02.236]  - include = ‘immediateCondition’
[18:05:02.236]  - exclude = 
[18:05:02.236]  - resignal = FALSE
[18:05:02.236]  - Number of conditions: 1
[18:05:02.236] signalConditions() ... done
[18:05:02.238] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[18:05:02.238] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[18:05:02.239] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[18:05:02.239] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[18:05:02.240] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[18:05:02.240] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[18:05:02.241] MultisessionFuture started
[18:05:02.241] - Launch lazy future ... done
[18:05:02.241] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.242] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.243] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.247] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.247] Searching for globals ... DONE
[18:05:02.247] Resolving globals: TRUE
[18:05:02.247] Resolving any globals that are futures ...
[18:05:02.248] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.248] Resolving any globals that are futures ... DONE
[18:05:02.248] Resolving futures part of globals (recursively) ...
[18:05:02.249] resolve() on list ...
[18:05:02.249]  recursive: 99
[18:05:02.249]  length: 2
[18:05:02.250]  elements: ‘a’, ‘ii’
[18:05:02.250]  length: 1 (resolved future 1)
[18:05:02.250]  length: 0 (resolved future 2)
[18:05:02.250] resolve() on list ... DONE
[18:05:02.250] - globals: [2] ‘a’, ‘ii’
[18:05:02.251] Resolving futures part of globals (recursively) ... DONE
[18:05:02.251] The total size of the 2 globals is 112 bytes (112 bytes)
[18:05:02.252] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:05:02.252] - globals: [2] ‘a’, ‘ii’
[18:05:02.252] 
[18:05:02.252] getGlobalsAndPackages() ... DONE
[18:05:02.253] run() for ‘Future’ ...
[18:05:02.253] - state: ‘created’
[18:05:02.253] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.278]   - Field: ‘node’
[18:05:02.278]   - Field: ‘label’
[18:05:02.279]   - Field: ‘local’
[18:05:02.279]   - Field: ‘owner’
[18:05:02.279]   - Field: ‘envir’
[18:05:02.279]   - Field: ‘workers’
[18:05:02.279]   - Field: ‘packages’
[18:05:02.280]   - Field: ‘gc’
[18:05:02.280]   - Field: ‘conditions’
[18:05:02.280]   - Field: ‘persistent’
[18:05:02.280]   - Field: ‘expr’
[18:05:02.280]   - Field: ‘uuid’
[18:05:02.281]   - Field: ‘seed’
[18:05:02.281]   - Field: ‘version’
[18:05:02.281]   - Field: ‘result’
[18:05:02.281]   - Field: ‘asynchronous’
[18:05:02.281]   - Field: ‘calls’
[18:05:02.282]   - Field: ‘globals’
[18:05:02.282]   - Field: ‘stdout’
[18:05:02.282]   - Field: ‘earlySignal’
[18:05:02.282]   - Field: ‘lazy’
[18:05:02.282]   - Field: ‘state’
[18:05:02.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.283] - Launch lazy future ...
[18:05:02.283] Packages needed by the future expression (n = 0): <none>
[18:05:02.284] Packages needed by future strategies (n = 0): <none>
[18:05:02.284] {
[18:05:02.284]     {
[18:05:02.284]         {
[18:05:02.284]             ...future.startTime <- base::Sys.time()
[18:05:02.284]             {
[18:05:02.284]                 {
[18:05:02.284]                   {
[18:05:02.284]                     {
[18:05:02.284]                       base::local({
[18:05:02.284]                         has_future <- base::requireNamespace("future", 
[18:05:02.284]                           quietly = TRUE)
[18:05:02.284]                         if (has_future) {
[18:05:02.284]                           ns <- base::getNamespace("future")
[18:05:02.284]                           version <- ns[[".package"]][["version"]]
[18:05:02.284]                           if (is.null(version)) 
[18:05:02.284]                             version <- utils::packageVersion("future")
[18:05:02.284]                         }
[18:05:02.284]                         else {
[18:05:02.284]                           version <- NULL
[18:05:02.284]                         }
[18:05:02.284]                         if (!has_future || version < "1.8.0") {
[18:05:02.284]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.284]                             "", base::R.version$version.string), 
[18:05:02.284]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:02.284]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:02.284]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.284]                               "release", "version")], collapse = " "), 
[18:05:02.284]                             hostname = base::Sys.info()[["nodename"]])
[18:05:02.284]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.284]                             info)
[18:05:02.284]                           info <- base::paste(info, collapse = "; ")
[18:05:02.284]                           if (!has_future) {
[18:05:02.284]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.284]                               info)
[18:05:02.284]                           }
[18:05:02.284]                           else {
[18:05:02.284]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.284]                               info, version)
[18:05:02.284]                           }
[18:05:02.284]                           base::stop(msg)
[18:05:02.284]                         }
[18:05:02.284]                       })
[18:05:02.284]                     }
[18:05:02.284]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.284]                     base::options(mc.cores = 1L)
[18:05:02.284]                   }
[18:05:02.284]                   ...future.strategy.old <- future::plan("list")
[18:05:02.284]                   options(future.plan = NULL)
[18:05:02.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.284]                 }
[18:05:02.284]                 ...future.workdir <- getwd()
[18:05:02.284]             }
[18:05:02.284]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.284]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.284]         }
[18:05:02.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.284]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.284]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.284]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.284]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.284]             base::names(...future.oldOptions))
[18:05:02.284]     }
[18:05:02.284]     if (FALSE) {
[18:05:02.284]     }
[18:05:02.284]     else {
[18:05:02.284]         if (TRUE) {
[18:05:02.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.284]                 open = "w")
[18:05:02.284]         }
[18:05:02.284]         else {
[18:05:02.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.284]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.284]         }
[18:05:02.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.284]             base::sink(type = "output", split = FALSE)
[18:05:02.284]             base::close(...future.stdout)
[18:05:02.284]         }, add = TRUE)
[18:05:02.284]     }
[18:05:02.284]     ...future.frame <- base::sys.nframe()
[18:05:02.284]     ...future.conditions <- base::list()
[18:05:02.284]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.284]     if (FALSE) {
[18:05:02.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.284]     }
[18:05:02.284]     ...future.result <- base::tryCatch({
[18:05:02.284]         base::withCallingHandlers({
[18:05:02.284]             ...future.value <- base::withVisible(base::local({
[18:05:02.284]                 ...future.makeSendCondition <- base::local({
[18:05:02.284]                   sendCondition <- NULL
[18:05:02.284]                   function(frame = 1L) {
[18:05:02.284]                     if (is.function(sendCondition)) 
[18:05:02.284]                       return(sendCondition)
[18:05:02.284]                     ns <- getNamespace("parallel")
[18:05:02.284]                     if (exists("sendData", mode = "function", 
[18:05:02.284]                       envir = ns)) {
[18:05:02.284]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.284]                         envir = ns)
[18:05:02.284]                       envir <- sys.frame(frame)
[18:05:02.284]                       master <- NULL
[18:05:02.284]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.284]                         !identical(envir, emptyenv())) {
[18:05:02.284]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.284]                           inherits = FALSE)) {
[18:05:02.284]                           master <- get("master", mode = "list", 
[18:05:02.284]                             envir = envir, inherits = FALSE)
[18:05:02.284]                           if (inherits(master, c("SOCKnode", 
[18:05:02.284]                             "SOCK0node"))) {
[18:05:02.284]                             sendCondition <<- function(cond) {
[18:05:02.284]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.284]                                 success = TRUE)
[18:05:02.284]                               parallel_sendData(master, data)
[18:05:02.284]                             }
[18:05:02.284]                             return(sendCondition)
[18:05:02.284]                           }
[18:05:02.284]                         }
[18:05:02.284]                         frame <- frame + 1L
[18:05:02.284]                         envir <- sys.frame(frame)
[18:05:02.284]                       }
[18:05:02.284]                     }
[18:05:02.284]                     sendCondition <<- function(cond) NULL
[18:05:02.284]                   }
[18:05:02.284]                 })
[18:05:02.284]                 withCallingHandlers({
[18:05:02.284]                   {
[18:05:02.284]                     b <- a * ii
[18:05:02.284]                     a <- 0
[18:05:02.284]                     b
[18:05:02.284]                   }
[18:05:02.284]                 }, immediateCondition = function(cond) {
[18:05:02.284]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.284]                   sendCondition(cond)
[18:05:02.284]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.284]                   {
[18:05:02.284]                     inherits <- base::inherits
[18:05:02.284]                     invokeRestart <- base::invokeRestart
[18:05:02.284]                     is.null <- base::is.null
[18:05:02.284]                     muffled <- FALSE
[18:05:02.284]                     if (inherits(cond, "message")) {
[18:05:02.284]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.284]                       if (muffled) 
[18:05:02.284]                         invokeRestart("muffleMessage")
[18:05:02.284]                     }
[18:05:02.284]                     else if (inherits(cond, "warning")) {
[18:05:02.284]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.284]                       if (muffled) 
[18:05:02.284]                         invokeRestart("muffleWarning")
[18:05:02.284]                     }
[18:05:02.284]                     else if (inherits(cond, "condition")) {
[18:05:02.284]                       if (!is.null(pattern)) {
[18:05:02.284]                         computeRestarts <- base::computeRestarts
[18:05:02.284]                         grepl <- base::grepl
[18:05:02.284]                         restarts <- computeRestarts(cond)
[18:05:02.284]                         for (restart in restarts) {
[18:05:02.284]                           name <- restart$name
[18:05:02.284]                           if (is.null(name)) 
[18:05:02.284]                             next
[18:05:02.284]                           if (!grepl(pattern, name)) 
[18:05:02.284]                             next
[18:05:02.284]                           invokeRestart(restart)
[18:05:02.284]                           muffled <- TRUE
[18:05:02.284]                           break
[18:05:02.284]                         }
[18:05:02.284]                       }
[18:05:02.284]                     }
[18:05:02.284]                     invisible(muffled)
[18:05:02.284]                   }
[18:05:02.284]                   muffleCondition(cond)
[18:05:02.284]                 })
[18:05:02.284]             }))
[18:05:02.284]             future::FutureResult(value = ...future.value$value, 
[18:05:02.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.284]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.284]                     ...future.globalenv.names))
[18:05:02.284]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.284]         }, condition = base::local({
[18:05:02.284]             c <- base::c
[18:05:02.284]             inherits <- base::inherits
[18:05:02.284]             invokeRestart <- base::invokeRestart
[18:05:02.284]             length <- base::length
[18:05:02.284]             list <- base::list
[18:05:02.284]             seq.int <- base::seq.int
[18:05:02.284]             signalCondition <- base::signalCondition
[18:05:02.284]             sys.calls <- base::sys.calls
[18:05:02.284]             `[[` <- base::`[[`
[18:05:02.284]             `+` <- base::`+`
[18:05:02.284]             `<<-` <- base::`<<-`
[18:05:02.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.284]                   3L)]
[18:05:02.284]             }
[18:05:02.284]             function(cond) {
[18:05:02.284]                 is_error <- inherits(cond, "error")
[18:05:02.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.284]                   NULL)
[18:05:02.284]                 if (is_error) {
[18:05:02.284]                   sessionInformation <- function() {
[18:05:02.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.284]                       search = base::search(), system = base::Sys.info())
[18:05:02.284]                   }
[18:05:02.284]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.284]                     cond$call), session = sessionInformation(), 
[18:05:02.284]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.284]                   signalCondition(cond)
[18:05:02.284]                 }
[18:05:02.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.284]                 "immediateCondition"))) {
[18:05:02.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.284]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.284]                   if (TRUE && !signal) {
[18:05:02.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.284]                     {
[18:05:02.284]                       inherits <- base::inherits
[18:05:02.284]                       invokeRestart <- base::invokeRestart
[18:05:02.284]                       is.null <- base::is.null
[18:05:02.284]                       muffled <- FALSE
[18:05:02.284]                       if (inherits(cond, "message")) {
[18:05:02.284]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.284]                         if (muffled) 
[18:05:02.284]                           invokeRestart("muffleMessage")
[18:05:02.284]                       }
[18:05:02.284]                       else if (inherits(cond, "warning")) {
[18:05:02.284]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.284]                         if (muffled) 
[18:05:02.284]                           invokeRestart("muffleWarning")
[18:05:02.284]                       }
[18:05:02.284]                       else if (inherits(cond, "condition")) {
[18:05:02.284]                         if (!is.null(pattern)) {
[18:05:02.284]                           computeRestarts <- base::computeRestarts
[18:05:02.284]                           grepl <- base::grepl
[18:05:02.284]                           restarts <- computeRestarts(cond)
[18:05:02.284]                           for (restart in restarts) {
[18:05:02.284]                             name <- restart$name
[18:05:02.284]                             if (is.null(name)) 
[18:05:02.284]                               next
[18:05:02.284]                             if (!grepl(pattern, name)) 
[18:05:02.284]                               next
[18:05:02.284]                             invokeRestart(restart)
[18:05:02.284]                             muffled <- TRUE
[18:05:02.284]                             break
[18:05:02.284]                           }
[18:05:02.284]                         }
[18:05:02.284]                       }
[18:05:02.284]                       invisible(muffled)
[18:05:02.284]                     }
[18:05:02.284]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.284]                   }
[18:05:02.284]                 }
[18:05:02.284]                 else {
[18:05:02.284]                   if (TRUE) {
[18:05:02.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.284]                     {
[18:05:02.284]                       inherits <- base::inherits
[18:05:02.284]                       invokeRestart <- base::invokeRestart
[18:05:02.284]                       is.null <- base::is.null
[18:05:02.284]                       muffled <- FALSE
[18:05:02.284]                       if (inherits(cond, "message")) {
[18:05:02.284]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.284]                         if (muffled) 
[18:05:02.284]                           invokeRestart("muffleMessage")
[18:05:02.284]                       }
[18:05:02.284]                       else if (inherits(cond, "warning")) {
[18:05:02.284]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.284]                         if (muffled) 
[18:05:02.284]                           invokeRestart("muffleWarning")
[18:05:02.284]                       }
[18:05:02.284]                       else if (inherits(cond, "condition")) {
[18:05:02.284]                         if (!is.null(pattern)) {
[18:05:02.284]                           computeRestarts <- base::computeRestarts
[18:05:02.284]                           grepl <- base::grepl
[18:05:02.284]                           restarts <- computeRestarts(cond)
[18:05:02.284]                           for (restart in restarts) {
[18:05:02.284]                             name <- restart$name
[18:05:02.284]                             if (is.null(name)) 
[18:05:02.284]                               next
[18:05:02.284]                             if (!grepl(pattern, name)) 
[18:05:02.284]                               next
[18:05:02.284]                             invokeRestart(restart)
[18:05:02.284]                             muffled <- TRUE
[18:05:02.284]                             break
[18:05:02.284]                           }
[18:05:02.284]                         }
[18:05:02.284]                       }
[18:05:02.284]                       invisible(muffled)
[18:05:02.284]                     }
[18:05:02.284]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.284]                   }
[18:05:02.284]                 }
[18:05:02.284]             }
[18:05:02.284]         }))
[18:05:02.284]     }, error = function(ex) {
[18:05:02.284]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.284]                 ...future.rng), started = ...future.startTime, 
[18:05:02.284]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.284]             version = "1.8"), class = "FutureResult")
[18:05:02.284]     }, finally = {
[18:05:02.284]         if (!identical(...future.workdir, getwd())) 
[18:05:02.284]             setwd(...future.workdir)
[18:05:02.284]         {
[18:05:02.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.284]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.284]             }
[18:05:02.284]             base::options(...future.oldOptions)
[18:05:02.284]             if (.Platform$OS.type == "windows") {
[18:05:02.284]                 old_names <- names(...future.oldEnvVars)
[18:05:02.284]                 envs <- base::Sys.getenv()
[18:05:02.284]                 names <- names(envs)
[18:05:02.284]                 common <- intersect(names, old_names)
[18:05:02.284]                 added <- setdiff(names, old_names)
[18:05:02.284]                 removed <- setdiff(old_names, names)
[18:05:02.284]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.284]                   envs[common]]
[18:05:02.284]                 NAMES <- toupper(changed)
[18:05:02.284]                 args <- list()
[18:05:02.284]                 for (kk in seq_along(NAMES)) {
[18:05:02.284]                   name <- changed[[kk]]
[18:05:02.284]                   NAME <- NAMES[[kk]]
[18:05:02.284]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.284]                     next
[18:05:02.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.284]                 }
[18:05:02.284]                 NAMES <- toupper(added)
[18:05:02.284]                 for (kk in seq_along(NAMES)) {
[18:05:02.284]                   name <- added[[kk]]
[18:05:02.284]                   NAME <- NAMES[[kk]]
[18:05:02.284]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.284]                     next
[18:05:02.284]                   args[[name]] <- ""
[18:05:02.284]                 }
[18:05:02.284]                 NAMES <- toupper(removed)
[18:05:02.284]                 for (kk in seq_along(NAMES)) {
[18:05:02.284]                   name <- removed[[kk]]
[18:05:02.284]                   NAME <- NAMES[[kk]]
[18:05:02.284]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.284]                     next
[18:05:02.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.284]                 }
[18:05:02.284]                 if (length(args) > 0) 
[18:05:02.284]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.284]             }
[18:05:02.284]             else {
[18:05:02.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.284]             }
[18:05:02.284]             {
[18:05:02.284]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.284]                   0L) {
[18:05:02.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.284]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.284]                   base::options(opts)
[18:05:02.284]                 }
[18:05:02.284]                 {
[18:05:02.284]                   {
[18:05:02.284]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.284]                     NULL
[18:05:02.284]                   }
[18:05:02.284]                   options(future.plan = NULL)
[18:05:02.284]                   if (is.na(NA_character_)) 
[18:05:02.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.284]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.284]                     .init = FALSE)
[18:05:02.284]                 }
[18:05:02.284]             }
[18:05:02.284]         }
[18:05:02.284]     })
[18:05:02.284]     if (TRUE) {
[18:05:02.284]         base::sink(type = "output", split = FALSE)
[18:05:02.284]         if (TRUE) {
[18:05:02.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.284]         }
[18:05:02.284]         else {
[18:05:02.284]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.284]         }
[18:05:02.284]         base::close(...future.stdout)
[18:05:02.284]         ...future.stdout <- NULL
[18:05:02.284]     }
[18:05:02.284]     ...future.result$conditions <- ...future.conditions
[18:05:02.284]     ...future.result$finished <- base::Sys.time()
[18:05:02.284]     ...future.result
[18:05:02.284] }
[18:05:02.288] Poll #1 (0): usedNodes() = 2, workers = 2
[18:05:02.300] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.300] - Validating connection of MultisessionFuture
[18:05:02.300] - received message: FutureResult
[18:05:02.301] - Received FutureResult
[18:05:02.301] - Erased future from FutureRegistry
[18:05:02.301] result() for ClusterFuture ...
[18:05:02.301] - result already collected: FutureResult
[18:05:02.301] result() for ClusterFuture ... done
[18:05:02.302] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.302] result() for ClusterFuture ...
[18:05:02.302] - result already collected: FutureResult
[18:05:02.302] result() for ClusterFuture ... done
[18:05:02.302] result() for ClusterFuture ...
[18:05:02.302] - result already collected: FutureResult
[18:05:02.303] result() for ClusterFuture ... done
[18:05:02.304] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[18:05:02.304] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[18:05:02.305] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[18:05:02.306] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[18:05:02.306] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[18:05:02.307] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[18:05:02.309] MultisessionFuture started
[18:05:02.310] - Launch lazy future ... done
[18:05:02.310] run() for ‘MultisessionFuture’ ... done
[18:05:02.310] result() for ClusterFuture ...
[18:05:02.311] - result already collected: FutureResult
[18:05:02.311] result() for ClusterFuture ... done
[18:05:02.311] result() for ClusterFuture ...
[18:05:02.311] - result already collected: FutureResult
[18:05:02.311] result() for ClusterFuture ... done
[18:05:02.312] result() for ClusterFuture ...
[18:05:02.312] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.312] - Validating connection of MultisessionFuture
[18:05:02.312] - received message: FutureResult
[18:05:02.313] - Received FutureResult
[18:05:02.313] - Erased future from FutureRegistry
[18:05:02.313] result() for ClusterFuture ...
[18:05:02.313] - result already collected: FutureResult
[18:05:02.313] result() for ClusterFuture ... done
[18:05:02.314] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.314] result() for ClusterFuture ... done
[18:05:02.314] result() for ClusterFuture ...
[18:05:02.314] - result already collected: FutureResult
[18:05:02.314] result() for ClusterFuture ... done
[18:05:02.315] result() for ClusterFuture ...
[18:05:02.315] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.315] - Validating connection of MultisessionFuture
[18:05:02.354] - received message: FutureResult
[18:05:02.355] - Received FutureResult
[18:05:02.355] - Erased future from FutureRegistry
[18:05:02.355] result() for ClusterFuture ...
[18:05:02.355] - result already collected: FutureResult
[18:05:02.356] result() for ClusterFuture ... done
[18:05:02.356] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.356] result() for ClusterFuture ... done
[18:05:02.356] result() for ClusterFuture ...
[18:05:02.356] - result already collected: FutureResult
[18:05:02.357] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.358] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.358] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.362] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.362] Searching for globals ... DONE
[18:05:02.362] Resolving globals: TRUE
[18:05:02.363] Resolving any globals that are futures ...
[18:05:02.363] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.363] Resolving any globals that are futures ... DONE
[18:05:02.364] Resolving futures part of globals (recursively) ...
[18:05:02.364] resolve() on list ...
[18:05:02.364]  recursive: 99
[18:05:02.365]  length: 2
[18:05:02.365]  elements: ‘a’, ‘ii’
[18:05:02.365]  length: 1 (resolved future 1)
[18:05:02.365]  length: 0 (resolved future 2)
[18:05:02.366] resolve() on list ... DONE
[18:05:02.366] - globals: [2] ‘a’, ‘ii’
[18:05:02.366] Resolving futures part of globals (recursively) ... DONE
[18:05:02.366] The total size of the 2 globals is 112 bytes (112 bytes)
[18:05:02.367] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:05:02.367] - globals: [2] ‘a’, ‘ii’
[18:05:02.368] 
[18:05:02.368] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.369] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.370] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.374] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.374] Searching for globals ... DONE
[18:05:02.374] Resolving globals: TRUE
[18:05:02.375] Resolving any globals that are futures ...
[18:05:02.375] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.375] Resolving any globals that are futures ... DONE
[18:05:02.376] Resolving futures part of globals (recursively) ...
[18:05:02.376] resolve() on list ...
[18:05:02.376]  recursive: 99
[18:05:02.377]  length: 2
[18:05:02.377]  elements: ‘a’, ‘ii’
[18:05:02.377]  length: 1 (resolved future 1)
[18:05:02.377]  length: 0 (resolved future 2)
[18:05:02.377] resolve() on list ... DONE
[18:05:02.378] - globals: [2] ‘a’, ‘ii’
[18:05:02.378] Resolving futures part of globals (recursively) ... DONE
[18:05:02.378] The total size of the 2 globals is 112 bytes (112 bytes)
[18:05:02.379] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:05:02.379] - globals: [2] ‘a’, ‘ii’
[18:05:02.379] 
[18:05:02.379] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.381] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.381] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.385] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.385] Searching for globals ... DONE
[18:05:02.385] Resolving globals: TRUE
[18:05:02.386] Resolving any globals that are futures ...
[18:05:02.386] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[18:05:02.386] Resolving any globals that are futures ... DONE
[18:05:02.387] Resolving futures part of globals (recursively) ...
[18:05:02.387] resolve() on list ...
[18:05:02.387]  recursive: 99
[18:05:02.387]  length: 2
[18:05:02.388]  elements: ‘a’, ‘ii’
[18:05:02.388]  length: 1 (resolved future 1)
[18:05:02.388]  length: 0 (resolved future 2)
[18:05:02.388] resolve() on list ... DONE
[18:05:02.388] - globals: [2] ‘a’, ‘ii’
[18:05:02.389] Resolving futures part of globals (recursively) ... DONE
[18:05:02.389] The total size of the 2 globals is 112 bytes (112 bytes)
[18:05:02.390] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[18:05:02.390] - globals: [2] ‘a’, ‘ii’
[18:05:02.390] 
[18:05:02.390] getGlobalsAndPackages() ... DONE
[18:05:02.391] run() for ‘Future’ ...
[18:05:02.391] - state: ‘created’
[18:05:02.392] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.416] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.417] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.417]   - Field: ‘node’
[18:05:02.417]   - Field: ‘label’
[18:05:02.417]   - Field: ‘local’
[18:05:02.418]   - Field: ‘owner’
[18:05:02.418]   - Field: ‘envir’
[18:05:02.418]   - Field: ‘workers’
[18:05:02.418]   - Field: ‘packages’
[18:05:02.418]   - Field: ‘gc’
[18:05:02.419]   - Field: ‘conditions’
[18:05:02.419]   - Field: ‘persistent’
[18:05:02.419]   - Field: ‘expr’
[18:05:02.419]   - Field: ‘uuid’
[18:05:02.419]   - Field: ‘seed’
[18:05:02.420]   - Field: ‘version’
[18:05:02.420]   - Field: ‘result’
[18:05:02.420]   - Field: ‘asynchronous’
[18:05:02.420]   - Field: ‘calls’
[18:05:02.420]   - Field: ‘globals’
[18:05:02.421]   - Field: ‘stdout’
[18:05:02.421]   - Field: ‘earlySignal’
[18:05:02.421]   - Field: ‘lazy’
[18:05:02.421]   - Field: ‘state’
[18:05:02.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.422] - Launch lazy future ...
[18:05:02.422] Packages needed by the future expression (n = 0): <none>
[18:05:02.422] Packages needed by future strategies (n = 0): <none>
[18:05:02.423] {
[18:05:02.423]     {
[18:05:02.423]         {
[18:05:02.423]             ...future.startTime <- base::Sys.time()
[18:05:02.423]             {
[18:05:02.423]                 {
[18:05:02.423]                   {
[18:05:02.423]                     {
[18:05:02.423]                       base::local({
[18:05:02.423]                         has_future <- base::requireNamespace("future", 
[18:05:02.423]                           quietly = TRUE)
[18:05:02.423]                         if (has_future) {
[18:05:02.423]                           ns <- base::getNamespace("future")
[18:05:02.423]                           version <- ns[[".package"]][["version"]]
[18:05:02.423]                           if (is.null(version)) 
[18:05:02.423]                             version <- utils::packageVersion("future")
[18:05:02.423]                         }
[18:05:02.423]                         else {
[18:05:02.423]                           version <- NULL
[18:05:02.423]                         }
[18:05:02.423]                         if (!has_future || version < "1.8.0") {
[18:05:02.423]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.423]                             "", base::R.version$version.string), 
[18:05:02.423]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:02.423]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:02.423]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.423]                               "release", "version")], collapse = " "), 
[18:05:02.423]                             hostname = base::Sys.info()[["nodename"]])
[18:05:02.423]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.423]                             info)
[18:05:02.423]                           info <- base::paste(info, collapse = "; ")
[18:05:02.423]                           if (!has_future) {
[18:05:02.423]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.423]                               info)
[18:05:02.423]                           }
[18:05:02.423]                           else {
[18:05:02.423]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.423]                               info, version)
[18:05:02.423]                           }
[18:05:02.423]                           base::stop(msg)
[18:05:02.423]                         }
[18:05:02.423]                       })
[18:05:02.423]                     }
[18:05:02.423]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.423]                     base::options(mc.cores = 1L)
[18:05:02.423]                   }
[18:05:02.423]                   ...future.strategy.old <- future::plan("list")
[18:05:02.423]                   options(future.plan = NULL)
[18:05:02.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.423]                 }
[18:05:02.423]                 ...future.workdir <- getwd()
[18:05:02.423]             }
[18:05:02.423]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.423]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.423]         }
[18:05:02.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.423]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.423]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.423]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.423]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.423]             base::names(...future.oldOptions))
[18:05:02.423]     }
[18:05:02.423]     if (FALSE) {
[18:05:02.423]     }
[18:05:02.423]     else {
[18:05:02.423]         if (TRUE) {
[18:05:02.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.423]                 open = "w")
[18:05:02.423]         }
[18:05:02.423]         else {
[18:05:02.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.423]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.423]         }
[18:05:02.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.423]             base::sink(type = "output", split = FALSE)
[18:05:02.423]             base::close(...future.stdout)
[18:05:02.423]         }, add = TRUE)
[18:05:02.423]     }
[18:05:02.423]     ...future.frame <- base::sys.nframe()
[18:05:02.423]     ...future.conditions <- base::list()
[18:05:02.423]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.423]     if (FALSE) {
[18:05:02.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.423]     }
[18:05:02.423]     ...future.result <- base::tryCatch({
[18:05:02.423]         base::withCallingHandlers({
[18:05:02.423]             ...future.value <- base::withVisible(base::local({
[18:05:02.423]                 ...future.makeSendCondition <- base::local({
[18:05:02.423]                   sendCondition <- NULL
[18:05:02.423]                   function(frame = 1L) {
[18:05:02.423]                     if (is.function(sendCondition)) 
[18:05:02.423]                       return(sendCondition)
[18:05:02.423]                     ns <- getNamespace("parallel")
[18:05:02.423]                     if (exists("sendData", mode = "function", 
[18:05:02.423]                       envir = ns)) {
[18:05:02.423]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.423]                         envir = ns)
[18:05:02.423]                       envir <- sys.frame(frame)
[18:05:02.423]                       master <- NULL
[18:05:02.423]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.423]                         !identical(envir, emptyenv())) {
[18:05:02.423]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.423]                           inherits = FALSE)) {
[18:05:02.423]                           master <- get("master", mode = "list", 
[18:05:02.423]                             envir = envir, inherits = FALSE)
[18:05:02.423]                           if (inherits(master, c("SOCKnode", 
[18:05:02.423]                             "SOCK0node"))) {
[18:05:02.423]                             sendCondition <<- function(cond) {
[18:05:02.423]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.423]                                 success = TRUE)
[18:05:02.423]                               parallel_sendData(master, data)
[18:05:02.423]                             }
[18:05:02.423]                             return(sendCondition)
[18:05:02.423]                           }
[18:05:02.423]                         }
[18:05:02.423]                         frame <- frame + 1L
[18:05:02.423]                         envir <- sys.frame(frame)
[18:05:02.423]                       }
[18:05:02.423]                     }
[18:05:02.423]                     sendCondition <<- function(cond) NULL
[18:05:02.423]                   }
[18:05:02.423]                 })
[18:05:02.423]                 withCallingHandlers({
[18:05:02.423]                   {
[18:05:02.423]                     b <- a * ii
[18:05:02.423]                     a <- 0
[18:05:02.423]                     b
[18:05:02.423]                   }
[18:05:02.423]                 }, immediateCondition = function(cond) {
[18:05:02.423]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.423]                   sendCondition(cond)
[18:05:02.423]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.423]                   {
[18:05:02.423]                     inherits <- base::inherits
[18:05:02.423]                     invokeRestart <- base::invokeRestart
[18:05:02.423]                     is.null <- base::is.null
[18:05:02.423]                     muffled <- FALSE
[18:05:02.423]                     if (inherits(cond, "message")) {
[18:05:02.423]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.423]                       if (muffled) 
[18:05:02.423]                         invokeRestart("muffleMessage")
[18:05:02.423]                     }
[18:05:02.423]                     else if (inherits(cond, "warning")) {
[18:05:02.423]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.423]                       if (muffled) 
[18:05:02.423]                         invokeRestart("muffleWarning")
[18:05:02.423]                     }
[18:05:02.423]                     else if (inherits(cond, "condition")) {
[18:05:02.423]                       if (!is.null(pattern)) {
[18:05:02.423]                         computeRestarts <- base::computeRestarts
[18:05:02.423]                         grepl <- base::grepl
[18:05:02.423]                         restarts <- computeRestarts(cond)
[18:05:02.423]                         for (restart in restarts) {
[18:05:02.423]                           name <- restart$name
[18:05:02.423]                           if (is.null(name)) 
[18:05:02.423]                             next
[18:05:02.423]                           if (!grepl(pattern, name)) 
[18:05:02.423]                             next
[18:05:02.423]                           invokeRestart(restart)
[18:05:02.423]                           muffled <- TRUE
[18:05:02.423]                           break
[18:05:02.423]                         }
[18:05:02.423]                       }
[18:05:02.423]                     }
[18:05:02.423]                     invisible(muffled)
[18:05:02.423]                   }
[18:05:02.423]                   muffleCondition(cond)
[18:05:02.423]                 })
[18:05:02.423]             }))
[18:05:02.423]             future::FutureResult(value = ...future.value$value, 
[18:05:02.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.423]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.423]                     ...future.globalenv.names))
[18:05:02.423]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.423]         }, condition = base::local({
[18:05:02.423]             c <- base::c
[18:05:02.423]             inherits <- base::inherits
[18:05:02.423]             invokeRestart <- base::invokeRestart
[18:05:02.423]             length <- base::length
[18:05:02.423]             list <- base::list
[18:05:02.423]             seq.int <- base::seq.int
[18:05:02.423]             signalCondition <- base::signalCondition
[18:05:02.423]             sys.calls <- base::sys.calls
[18:05:02.423]             `[[` <- base::`[[`
[18:05:02.423]             `+` <- base::`+`
[18:05:02.423]             `<<-` <- base::`<<-`
[18:05:02.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.423]                   3L)]
[18:05:02.423]             }
[18:05:02.423]             function(cond) {
[18:05:02.423]                 is_error <- inherits(cond, "error")
[18:05:02.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.423]                   NULL)
[18:05:02.423]                 if (is_error) {
[18:05:02.423]                   sessionInformation <- function() {
[18:05:02.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.423]                       search = base::search(), system = base::Sys.info())
[18:05:02.423]                   }
[18:05:02.423]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.423]                     cond$call), session = sessionInformation(), 
[18:05:02.423]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.423]                   signalCondition(cond)
[18:05:02.423]                 }
[18:05:02.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.423]                 "immediateCondition"))) {
[18:05:02.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.423]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.423]                   if (TRUE && !signal) {
[18:05:02.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.423]                     {
[18:05:02.423]                       inherits <- base::inherits
[18:05:02.423]                       invokeRestart <- base::invokeRestart
[18:05:02.423]                       is.null <- base::is.null
[18:05:02.423]                       muffled <- FALSE
[18:05:02.423]                       if (inherits(cond, "message")) {
[18:05:02.423]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.423]                         if (muffled) 
[18:05:02.423]                           invokeRestart("muffleMessage")
[18:05:02.423]                       }
[18:05:02.423]                       else if (inherits(cond, "warning")) {
[18:05:02.423]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.423]                         if (muffled) 
[18:05:02.423]                           invokeRestart("muffleWarning")
[18:05:02.423]                       }
[18:05:02.423]                       else if (inherits(cond, "condition")) {
[18:05:02.423]                         if (!is.null(pattern)) {
[18:05:02.423]                           computeRestarts <- base::computeRestarts
[18:05:02.423]                           grepl <- base::grepl
[18:05:02.423]                           restarts <- computeRestarts(cond)
[18:05:02.423]                           for (restart in restarts) {
[18:05:02.423]                             name <- restart$name
[18:05:02.423]                             if (is.null(name)) 
[18:05:02.423]                               next
[18:05:02.423]                             if (!grepl(pattern, name)) 
[18:05:02.423]                               next
[18:05:02.423]                             invokeRestart(restart)
[18:05:02.423]                             muffled <- TRUE
[18:05:02.423]                             break
[18:05:02.423]                           }
[18:05:02.423]                         }
[18:05:02.423]                       }
[18:05:02.423]                       invisible(muffled)
[18:05:02.423]                     }
[18:05:02.423]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.423]                   }
[18:05:02.423]                 }
[18:05:02.423]                 else {
[18:05:02.423]                   if (TRUE) {
[18:05:02.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.423]                     {
[18:05:02.423]                       inherits <- base::inherits
[18:05:02.423]                       invokeRestart <- base::invokeRestart
[18:05:02.423]                       is.null <- base::is.null
[18:05:02.423]                       muffled <- FALSE
[18:05:02.423]                       if (inherits(cond, "message")) {
[18:05:02.423]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.423]                         if (muffled) 
[18:05:02.423]                           invokeRestart("muffleMessage")
[18:05:02.423]                       }
[18:05:02.423]                       else if (inherits(cond, "warning")) {
[18:05:02.423]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.423]                         if (muffled) 
[18:05:02.423]                           invokeRestart("muffleWarning")
[18:05:02.423]                       }
[18:05:02.423]                       else if (inherits(cond, "condition")) {
[18:05:02.423]                         if (!is.null(pattern)) {
[18:05:02.423]                           computeRestarts <- base::computeRestarts
[18:05:02.423]                           grepl <- base::grepl
[18:05:02.423]                           restarts <- computeRestarts(cond)
[18:05:02.423]                           for (restart in restarts) {
[18:05:02.423]                             name <- restart$name
[18:05:02.423]                             if (is.null(name)) 
[18:05:02.423]                               next
[18:05:02.423]                             if (!grepl(pattern, name)) 
[18:05:02.423]                               next
[18:05:02.423]                             invokeRestart(restart)
[18:05:02.423]                             muffled <- TRUE
[18:05:02.423]                             break
[18:05:02.423]                           }
[18:05:02.423]                         }
[18:05:02.423]                       }
[18:05:02.423]                       invisible(muffled)
[18:05:02.423]                     }
[18:05:02.423]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.423]                   }
[18:05:02.423]                 }
[18:05:02.423]             }
[18:05:02.423]         }))
[18:05:02.423]     }, error = function(ex) {
[18:05:02.423]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.423]                 ...future.rng), started = ...future.startTime, 
[18:05:02.423]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.423]             version = "1.8"), class = "FutureResult")
[18:05:02.423]     }, finally = {
[18:05:02.423]         if (!identical(...future.workdir, getwd())) 
[18:05:02.423]             setwd(...future.workdir)
[18:05:02.423]         {
[18:05:02.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.423]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.423]             }
[18:05:02.423]             base::options(...future.oldOptions)
[18:05:02.423]             if (.Platform$OS.type == "windows") {
[18:05:02.423]                 old_names <- names(...future.oldEnvVars)
[18:05:02.423]                 envs <- base::Sys.getenv()
[18:05:02.423]                 names <- names(envs)
[18:05:02.423]                 common <- intersect(names, old_names)
[18:05:02.423]                 added <- setdiff(names, old_names)
[18:05:02.423]                 removed <- setdiff(old_names, names)
[18:05:02.423]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.423]                   envs[common]]
[18:05:02.423]                 NAMES <- toupper(changed)
[18:05:02.423]                 args <- list()
[18:05:02.423]                 for (kk in seq_along(NAMES)) {
[18:05:02.423]                   name <- changed[[kk]]
[18:05:02.423]                   NAME <- NAMES[[kk]]
[18:05:02.423]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.423]                     next
[18:05:02.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.423]                 }
[18:05:02.423]                 NAMES <- toupper(added)
[18:05:02.423]                 for (kk in seq_along(NAMES)) {
[18:05:02.423]                   name <- added[[kk]]
[18:05:02.423]                   NAME <- NAMES[[kk]]
[18:05:02.423]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.423]                     next
[18:05:02.423]                   args[[name]] <- ""
[18:05:02.423]                 }
[18:05:02.423]                 NAMES <- toupper(removed)
[18:05:02.423]                 for (kk in seq_along(NAMES)) {
[18:05:02.423]                   name <- removed[[kk]]
[18:05:02.423]                   NAME <- NAMES[[kk]]
[18:05:02.423]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.423]                     next
[18:05:02.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.423]                 }
[18:05:02.423]                 if (length(args) > 0) 
[18:05:02.423]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.423]             }
[18:05:02.423]             else {
[18:05:02.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.423]             }
[18:05:02.423]             {
[18:05:02.423]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.423]                   0L) {
[18:05:02.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.423]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.423]                   base::options(opts)
[18:05:02.423]                 }
[18:05:02.423]                 {
[18:05:02.423]                   {
[18:05:02.423]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.423]                     NULL
[18:05:02.423]                   }
[18:05:02.423]                   options(future.plan = NULL)
[18:05:02.423]                   if (is.na(NA_character_)) 
[18:05:02.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.423]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.423]                     .init = FALSE)
[18:05:02.423]                 }
[18:05:02.423]             }
[18:05:02.423]         }
[18:05:02.423]     })
[18:05:02.423]     if (TRUE) {
[18:05:02.423]         base::sink(type = "output", split = FALSE)
[18:05:02.423]         if (TRUE) {
[18:05:02.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.423]         }
[18:05:02.423]         else {
[18:05:02.423]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.423]         }
[18:05:02.423]         base::close(...future.stdout)
[18:05:02.423]         ...future.stdout <- NULL
[18:05:02.423]     }
[18:05:02.423]     ...future.result$conditions <- ...future.conditions
[18:05:02.423]     ...future.result$finished <- base::Sys.time()
[18:05:02.423]     ...future.result
[18:05:02.423] }
[18:05:02.428] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[18:05:02.428] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[18:05:02.429] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[18:05:02.429] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[18:05:02.431] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[18:05:02.431] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[18:05:02.432] MultisessionFuture started
[18:05:02.432] - Launch lazy future ... done
[18:05:02.432] run() for ‘MultisessionFuture’ ... done
[18:05:02.433] result() for ClusterFuture ...
[18:05:02.433] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.433] - Validating connection of MultisessionFuture
[18:05:02.475] - received message: FutureResult
[18:05:02.476] - Received FutureResult
[18:05:02.476] - Erased future from FutureRegistry
[18:05:02.476] result() for ClusterFuture ...
[18:05:02.476] - result already collected: FutureResult
[18:05:02.477] result() for ClusterFuture ... done
[18:05:02.477] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.477] result() for ClusterFuture ... done
[18:05:02.477] result() for ClusterFuture ...
[18:05:02.477] - result already collected: FutureResult
[18:05:02.477] result() for ClusterFuture ... done
[18:05:02.478] run() for ‘Future’ ...
[18:05:02.478] - state: ‘created’
[18:05:02.478] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.504] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.504] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.504]   - Field: ‘node’
[18:05:02.504]   - Field: ‘label’
[18:05:02.505]   - Field: ‘local’
[18:05:02.505]   - Field: ‘owner’
[18:05:02.505]   - Field: ‘envir’
[18:05:02.505]   - Field: ‘workers’
[18:05:02.505]   - Field: ‘packages’
[18:05:02.506]   - Field: ‘gc’
[18:05:02.506]   - Field: ‘conditions’
[18:05:02.506]   - Field: ‘persistent’
[18:05:02.507]   - Field: ‘expr’
[18:05:02.507]   - Field: ‘uuid’
[18:05:02.507]   - Field: ‘seed’
[18:05:02.507]   - Field: ‘version’
[18:05:02.507]   - Field: ‘result’
[18:05:02.508]   - Field: ‘asynchronous’
[18:05:02.508]   - Field: ‘calls’
[18:05:02.508]   - Field: ‘globals’
[18:05:02.508]   - Field: ‘stdout’
[18:05:02.508]   - Field: ‘earlySignal’
[18:05:02.509]   - Field: ‘lazy’
[18:05:02.509]   - Field: ‘state’
[18:05:02.509] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.509] - Launch lazy future ...
[18:05:02.510] Packages needed by the future expression (n = 0): <none>
[18:05:02.510] Packages needed by future strategies (n = 0): <none>
[18:05:02.511] {
[18:05:02.511]     {
[18:05:02.511]         {
[18:05:02.511]             ...future.startTime <- base::Sys.time()
[18:05:02.511]             {
[18:05:02.511]                 {
[18:05:02.511]                   {
[18:05:02.511]                     {
[18:05:02.511]                       base::local({
[18:05:02.511]                         has_future <- base::requireNamespace("future", 
[18:05:02.511]                           quietly = TRUE)
[18:05:02.511]                         if (has_future) {
[18:05:02.511]                           ns <- base::getNamespace("future")
[18:05:02.511]                           version <- ns[[".package"]][["version"]]
[18:05:02.511]                           if (is.null(version)) 
[18:05:02.511]                             version <- utils::packageVersion("future")
[18:05:02.511]                         }
[18:05:02.511]                         else {
[18:05:02.511]                           version <- NULL
[18:05:02.511]                         }
[18:05:02.511]                         if (!has_future || version < "1.8.0") {
[18:05:02.511]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.511]                             "", base::R.version$version.string), 
[18:05:02.511]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:02.511]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:02.511]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.511]                               "release", "version")], collapse = " "), 
[18:05:02.511]                             hostname = base::Sys.info()[["nodename"]])
[18:05:02.511]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.511]                             info)
[18:05:02.511]                           info <- base::paste(info, collapse = "; ")
[18:05:02.511]                           if (!has_future) {
[18:05:02.511]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.511]                               info)
[18:05:02.511]                           }
[18:05:02.511]                           else {
[18:05:02.511]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.511]                               info, version)
[18:05:02.511]                           }
[18:05:02.511]                           base::stop(msg)
[18:05:02.511]                         }
[18:05:02.511]                       })
[18:05:02.511]                     }
[18:05:02.511]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.511]                     base::options(mc.cores = 1L)
[18:05:02.511]                   }
[18:05:02.511]                   ...future.strategy.old <- future::plan("list")
[18:05:02.511]                   options(future.plan = NULL)
[18:05:02.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.511]                 }
[18:05:02.511]                 ...future.workdir <- getwd()
[18:05:02.511]             }
[18:05:02.511]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.511]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.511]         }
[18:05:02.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.511]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.511]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.511]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.511]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.511]             base::names(...future.oldOptions))
[18:05:02.511]     }
[18:05:02.511]     if (FALSE) {
[18:05:02.511]     }
[18:05:02.511]     else {
[18:05:02.511]         if (TRUE) {
[18:05:02.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.511]                 open = "w")
[18:05:02.511]         }
[18:05:02.511]         else {
[18:05:02.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.511]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.511]         }
[18:05:02.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.511]             base::sink(type = "output", split = FALSE)
[18:05:02.511]             base::close(...future.stdout)
[18:05:02.511]         }, add = TRUE)
[18:05:02.511]     }
[18:05:02.511]     ...future.frame <- base::sys.nframe()
[18:05:02.511]     ...future.conditions <- base::list()
[18:05:02.511]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.511]     if (FALSE) {
[18:05:02.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.511]     }
[18:05:02.511]     ...future.result <- base::tryCatch({
[18:05:02.511]         base::withCallingHandlers({
[18:05:02.511]             ...future.value <- base::withVisible(base::local({
[18:05:02.511]                 ...future.makeSendCondition <- base::local({
[18:05:02.511]                   sendCondition <- NULL
[18:05:02.511]                   function(frame = 1L) {
[18:05:02.511]                     if (is.function(sendCondition)) 
[18:05:02.511]                       return(sendCondition)
[18:05:02.511]                     ns <- getNamespace("parallel")
[18:05:02.511]                     if (exists("sendData", mode = "function", 
[18:05:02.511]                       envir = ns)) {
[18:05:02.511]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.511]                         envir = ns)
[18:05:02.511]                       envir <- sys.frame(frame)
[18:05:02.511]                       master <- NULL
[18:05:02.511]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.511]                         !identical(envir, emptyenv())) {
[18:05:02.511]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.511]                           inherits = FALSE)) {
[18:05:02.511]                           master <- get("master", mode = "list", 
[18:05:02.511]                             envir = envir, inherits = FALSE)
[18:05:02.511]                           if (inherits(master, c("SOCKnode", 
[18:05:02.511]                             "SOCK0node"))) {
[18:05:02.511]                             sendCondition <<- function(cond) {
[18:05:02.511]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.511]                                 success = TRUE)
[18:05:02.511]                               parallel_sendData(master, data)
[18:05:02.511]                             }
[18:05:02.511]                             return(sendCondition)
[18:05:02.511]                           }
[18:05:02.511]                         }
[18:05:02.511]                         frame <- frame + 1L
[18:05:02.511]                         envir <- sys.frame(frame)
[18:05:02.511]                       }
[18:05:02.511]                     }
[18:05:02.511]                     sendCondition <<- function(cond) NULL
[18:05:02.511]                   }
[18:05:02.511]                 })
[18:05:02.511]                 withCallingHandlers({
[18:05:02.511]                   {
[18:05:02.511]                     b <- a * ii
[18:05:02.511]                     a <- 0
[18:05:02.511]                     b
[18:05:02.511]                   }
[18:05:02.511]                 }, immediateCondition = function(cond) {
[18:05:02.511]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.511]                   sendCondition(cond)
[18:05:02.511]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.511]                   {
[18:05:02.511]                     inherits <- base::inherits
[18:05:02.511]                     invokeRestart <- base::invokeRestart
[18:05:02.511]                     is.null <- base::is.null
[18:05:02.511]                     muffled <- FALSE
[18:05:02.511]                     if (inherits(cond, "message")) {
[18:05:02.511]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.511]                       if (muffled) 
[18:05:02.511]                         invokeRestart("muffleMessage")
[18:05:02.511]                     }
[18:05:02.511]                     else if (inherits(cond, "warning")) {
[18:05:02.511]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.511]                       if (muffled) 
[18:05:02.511]                         invokeRestart("muffleWarning")
[18:05:02.511]                     }
[18:05:02.511]                     else if (inherits(cond, "condition")) {
[18:05:02.511]                       if (!is.null(pattern)) {
[18:05:02.511]                         computeRestarts <- base::computeRestarts
[18:05:02.511]                         grepl <- base::grepl
[18:05:02.511]                         restarts <- computeRestarts(cond)
[18:05:02.511]                         for (restart in restarts) {
[18:05:02.511]                           name <- restart$name
[18:05:02.511]                           if (is.null(name)) 
[18:05:02.511]                             next
[18:05:02.511]                           if (!grepl(pattern, name)) 
[18:05:02.511]                             next
[18:05:02.511]                           invokeRestart(restart)
[18:05:02.511]                           muffled <- TRUE
[18:05:02.511]                           break
[18:05:02.511]                         }
[18:05:02.511]                       }
[18:05:02.511]                     }
[18:05:02.511]                     invisible(muffled)
[18:05:02.511]                   }
[18:05:02.511]                   muffleCondition(cond)
[18:05:02.511]                 })
[18:05:02.511]             }))
[18:05:02.511]             future::FutureResult(value = ...future.value$value, 
[18:05:02.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.511]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.511]                     ...future.globalenv.names))
[18:05:02.511]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.511]         }, condition = base::local({
[18:05:02.511]             c <- base::c
[18:05:02.511]             inherits <- base::inherits
[18:05:02.511]             invokeRestart <- base::invokeRestart
[18:05:02.511]             length <- base::length
[18:05:02.511]             list <- base::list
[18:05:02.511]             seq.int <- base::seq.int
[18:05:02.511]             signalCondition <- base::signalCondition
[18:05:02.511]             sys.calls <- base::sys.calls
[18:05:02.511]             `[[` <- base::`[[`
[18:05:02.511]             `+` <- base::`+`
[18:05:02.511]             `<<-` <- base::`<<-`
[18:05:02.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.511]                   3L)]
[18:05:02.511]             }
[18:05:02.511]             function(cond) {
[18:05:02.511]                 is_error <- inherits(cond, "error")
[18:05:02.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.511]                   NULL)
[18:05:02.511]                 if (is_error) {
[18:05:02.511]                   sessionInformation <- function() {
[18:05:02.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.511]                       search = base::search(), system = base::Sys.info())
[18:05:02.511]                   }
[18:05:02.511]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.511]                     cond$call), session = sessionInformation(), 
[18:05:02.511]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.511]                   signalCondition(cond)
[18:05:02.511]                 }
[18:05:02.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.511]                 "immediateCondition"))) {
[18:05:02.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.511]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.511]                   if (TRUE && !signal) {
[18:05:02.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.511]                     {
[18:05:02.511]                       inherits <- base::inherits
[18:05:02.511]                       invokeRestart <- base::invokeRestart
[18:05:02.511]                       is.null <- base::is.null
[18:05:02.511]                       muffled <- FALSE
[18:05:02.511]                       if (inherits(cond, "message")) {
[18:05:02.511]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.511]                         if (muffled) 
[18:05:02.511]                           invokeRestart("muffleMessage")
[18:05:02.511]                       }
[18:05:02.511]                       else if (inherits(cond, "warning")) {
[18:05:02.511]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.511]                         if (muffled) 
[18:05:02.511]                           invokeRestart("muffleWarning")
[18:05:02.511]                       }
[18:05:02.511]                       else if (inherits(cond, "condition")) {
[18:05:02.511]                         if (!is.null(pattern)) {
[18:05:02.511]                           computeRestarts <- base::computeRestarts
[18:05:02.511]                           grepl <- base::grepl
[18:05:02.511]                           restarts <- computeRestarts(cond)
[18:05:02.511]                           for (restart in restarts) {
[18:05:02.511]                             name <- restart$name
[18:05:02.511]                             if (is.null(name)) 
[18:05:02.511]                               next
[18:05:02.511]                             if (!grepl(pattern, name)) 
[18:05:02.511]                               next
[18:05:02.511]                             invokeRestart(restart)
[18:05:02.511]                             muffled <- TRUE
[18:05:02.511]                             break
[18:05:02.511]                           }
[18:05:02.511]                         }
[18:05:02.511]                       }
[18:05:02.511]                       invisible(muffled)
[18:05:02.511]                     }
[18:05:02.511]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.511]                   }
[18:05:02.511]                 }
[18:05:02.511]                 else {
[18:05:02.511]                   if (TRUE) {
[18:05:02.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.511]                     {
[18:05:02.511]                       inherits <- base::inherits
[18:05:02.511]                       invokeRestart <- base::invokeRestart
[18:05:02.511]                       is.null <- base::is.null
[18:05:02.511]                       muffled <- FALSE
[18:05:02.511]                       if (inherits(cond, "message")) {
[18:05:02.511]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.511]                         if (muffled) 
[18:05:02.511]                           invokeRestart("muffleMessage")
[18:05:02.511]                       }
[18:05:02.511]                       else if (inherits(cond, "warning")) {
[18:05:02.511]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.511]                         if (muffled) 
[18:05:02.511]                           invokeRestart("muffleWarning")
[18:05:02.511]                       }
[18:05:02.511]                       else if (inherits(cond, "condition")) {
[18:05:02.511]                         if (!is.null(pattern)) {
[18:05:02.511]                           computeRestarts <- base::computeRestarts
[18:05:02.511]                           grepl <- base::grepl
[18:05:02.511]                           restarts <- computeRestarts(cond)
[18:05:02.511]                           for (restart in restarts) {
[18:05:02.511]                             name <- restart$name
[18:05:02.511]                             if (is.null(name)) 
[18:05:02.511]                               next
[18:05:02.511]                             if (!grepl(pattern, name)) 
[18:05:02.511]                               next
[18:05:02.511]                             invokeRestart(restart)
[18:05:02.511]                             muffled <- TRUE
[18:05:02.511]                             break
[18:05:02.511]                           }
[18:05:02.511]                         }
[18:05:02.511]                       }
[18:05:02.511]                       invisible(muffled)
[18:05:02.511]                     }
[18:05:02.511]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.511]                   }
[18:05:02.511]                 }
[18:05:02.511]             }
[18:05:02.511]         }))
[18:05:02.511]     }, error = function(ex) {
[18:05:02.511]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.511]                 ...future.rng), started = ...future.startTime, 
[18:05:02.511]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.511]             version = "1.8"), class = "FutureResult")
[18:05:02.511]     }, finally = {
[18:05:02.511]         if (!identical(...future.workdir, getwd())) 
[18:05:02.511]             setwd(...future.workdir)
[18:05:02.511]         {
[18:05:02.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.511]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.511]             }
[18:05:02.511]             base::options(...future.oldOptions)
[18:05:02.511]             if (.Platform$OS.type == "windows") {
[18:05:02.511]                 old_names <- names(...future.oldEnvVars)
[18:05:02.511]                 envs <- base::Sys.getenv()
[18:05:02.511]                 names <- names(envs)
[18:05:02.511]                 common <- intersect(names, old_names)
[18:05:02.511]                 added <- setdiff(names, old_names)
[18:05:02.511]                 removed <- setdiff(old_names, names)
[18:05:02.511]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.511]                   envs[common]]
[18:05:02.511]                 NAMES <- toupper(changed)
[18:05:02.511]                 args <- list()
[18:05:02.511]                 for (kk in seq_along(NAMES)) {
[18:05:02.511]                   name <- changed[[kk]]
[18:05:02.511]                   NAME <- NAMES[[kk]]
[18:05:02.511]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.511]                     next
[18:05:02.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.511]                 }
[18:05:02.511]                 NAMES <- toupper(added)
[18:05:02.511]                 for (kk in seq_along(NAMES)) {
[18:05:02.511]                   name <- added[[kk]]
[18:05:02.511]                   NAME <- NAMES[[kk]]
[18:05:02.511]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.511]                     next
[18:05:02.511]                   args[[name]] <- ""
[18:05:02.511]                 }
[18:05:02.511]                 NAMES <- toupper(removed)
[18:05:02.511]                 for (kk in seq_along(NAMES)) {
[18:05:02.511]                   name <- removed[[kk]]
[18:05:02.511]                   NAME <- NAMES[[kk]]
[18:05:02.511]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.511]                     next
[18:05:02.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.511]                 }
[18:05:02.511]                 if (length(args) > 0) 
[18:05:02.511]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.511]             }
[18:05:02.511]             else {
[18:05:02.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.511]             }
[18:05:02.511]             {
[18:05:02.511]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.511]                   0L) {
[18:05:02.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.511]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.511]                   base::options(opts)
[18:05:02.511]                 }
[18:05:02.511]                 {
[18:05:02.511]                   {
[18:05:02.511]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.511]                     NULL
[18:05:02.511]                   }
[18:05:02.511]                   options(future.plan = NULL)
[18:05:02.511]                   if (is.na(NA_character_)) 
[18:05:02.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.511]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.511]                     .init = FALSE)
[18:05:02.511]                 }
[18:05:02.511]             }
[18:05:02.511]         }
[18:05:02.511]     })
[18:05:02.511]     if (TRUE) {
[18:05:02.511]         base::sink(type = "output", split = FALSE)
[18:05:02.511]         if (TRUE) {
[18:05:02.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.511]         }
[18:05:02.511]         else {
[18:05:02.511]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.511]         }
[18:05:02.511]         base::close(...future.stdout)
[18:05:02.511]         ...future.stdout <- NULL
[18:05:02.511]     }
[18:05:02.511]     ...future.result$conditions <- ...future.conditions
[18:05:02.511]     ...future.result$finished <- base::Sys.time()
[18:05:02.511]     ...future.result
[18:05:02.511] }
[18:05:02.516] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[18:05:02.516] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[18:05:02.517] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[18:05:02.517] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[18:05:02.518] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[18:05:02.518] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[18:05:02.519] MultisessionFuture started
[18:05:02.519] - Launch lazy future ... done
[18:05:02.520] run() for ‘MultisessionFuture’ ... done
[18:05:02.520] result() for ClusterFuture ...
[18:05:02.520] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.520] - Validating connection of MultisessionFuture
[18:05:02.563] - received message: FutureResult
[18:05:02.564] - Received FutureResult
[18:05:02.564] - Erased future from FutureRegistry
[18:05:02.564] result() for ClusterFuture ...
[18:05:02.564] - result already collected: FutureResult
[18:05:02.565] result() for ClusterFuture ... done
[18:05:02.565] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.565] result() for ClusterFuture ... done
[18:05:02.565] result() for ClusterFuture ...
[18:05:02.565] - result already collected: FutureResult
[18:05:02.566] result() for ClusterFuture ... done
[18:05:02.566] run() for ‘Future’ ...
[18:05:02.566] - state: ‘created’
[18:05:02.567] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.592] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.593]   - Field: ‘node’
[18:05:02.593]   - Field: ‘label’
[18:05:02.593]   - Field: ‘local’
[18:05:02.594]   - Field: ‘owner’
[18:05:02.594]   - Field: ‘envir’
[18:05:02.594]   - Field: ‘workers’
[18:05:02.594]   - Field: ‘packages’
[18:05:02.595]   - Field: ‘gc’
[18:05:02.595]   - Field: ‘conditions’
[18:05:02.595]   - Field: ‘persistent’
[18:05:02.595]   - Field: ‘expr’
[18:05:02.595]   - Field: ‘uuid’
[18:05:02.596]   - Field: ‘seed’
[18:05:02.596]   - Field: ‘version’
[18:05:02.596]   - Field: ‘result’
[18:05:02.596]   - Field: ‘asynchronous’
[18:05:02.597]   - Field: ‘calls’
[18:05:02.597]   - Field: ‘globals’
[18:05:02.597]   - Field: ‘stdout’
[18:05:02.597]   - Field: ‘earlySignal’
[18:05:02.597]   - Field: ‘lazy’
[18:05:02.598]   - Field: ‘state’
[18:05:02.598] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.598] - Launch lazy future ...
[18:05:02.599] Packages needed by the future expression (n = 0): <none>
[18:05:02.599] Packages needed by future strategies (n = 0): <none>
[18:05:02.600] {
[18:05:02.600]     {
[18:05:02.600]         {
[18:05:02.600]             ...future.startTime <- base::Sys.time()
[18:05:02.600]             {
[18:05:02.600]                 {
[18:05:02.600]                   {
[18:05:02.600]                     {
[18:05:02.600]                       base::local({
[18:05:02.600]                         has_future <- base::requireNamespace("future", 
[18:05:02.600]                           quietly = TRUE)
[18:05:02.600]                         if (has_future) {
[18:05:02.600]                           ns <- base::getNamespace("future")
[18:05:02.600]                           version <- ns[[".package"]][["version"]]
[18:05:02.600]                           if (is.null(version)) 
[18:05:02.600]                             version <- utils::packageVersion("future")
[18:05:02.600]                         }
[18:05:02.600]                         else {
[18:05:02.600]                           version <- NULL
[18:05:02.600]                         }
[18:05:02.600]                         if (!has_future || version < "1.8.0") {
[18:05:02.600]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.600]                             "", base::R.version$version.string), 
[18:05:02.600]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:02.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:02.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.600]                               "release", "version")], collapse = " "), 
[18:05:02.600]                             hostname = base::Sys.info()[["nodename"]])
[18:05:02.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.600]                             info)
[18:05:02.600]                           info <- base::paste(info, collapse = "; ")
[18:05:02.600]                           if (!has_future) {
[18:05:02.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.600]                               info)
[18:05:02.600]                           }
[18:05:02.600]                           else {
[18:05:02.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.600]                               info, version)
[18:05:02.600]                           }
[18:05:02.600]                           base::stop(msg)
[18:05:02.600]                         }
[18:05:02.600]                       })
[18:05:02.600]                     }
[18:05:02.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.600]                     base::options(mc.cores = 1L)
[18:05:02.600]                   }
[18:05:02.600]                   ...future.strategy.old <- future::plan("list")
[18:05:02.600]                   options(future.plan = NULL)
[18:05:02.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.600]                 }
[18:05:02.600]                 ...future.workdir <- getwd()
[18:05:02.600]             }
[18:05:02.600]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.600]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.600]         }
[18:05:02.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.600]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.600]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.600]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.600]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.600]             base::names(...future.oldOptions))
[18:05:02.600]     }
[18:05:02.600]     if (FALSE) {
[18:05:02.600]     }
[18:05:02.600]     else {
[18:05:02.600]         if (TRUE) {
[18:05:02.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.600]                 open = "w")
[18:05:02.600]         }
[18:05:02.600]         else {
[18:05:02.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.600]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.600]         }
[18:05:02.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.600]             base::sink(type = "output", split = FALSE)
[18:05:02.600]             base::close(...future.stdout)
[18:05:02.600]         }, add = TRUE)
[18:05:02.600]     }
[18:05:02.600]     ...future.frame <- base::sys.nframe()
[18:05:02.600]     ...future.conditions <- base::list()
[18:05:02.600]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.600]     if (FALSE) {
[18:05:02.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.600]     }
[18:05:02.600]     ...future.result <- base::tryCatch({
[18:05:02.600]         base::withCallingHandlers({
[18:05:02.600]             ...future.value <- base::withVisible(base::local({
[18:05:02.600]                 ...future.makeSendCondition <- base::local({
[18:05:02.600]                   sendCondition <- NULL
[18:05:02.600]                   function(frame = 1L) {
[18:05:02.600]                     if (is.function(sendCondition)) 
[18:05:02.600]                       return(sendCondition)
[18:05:02.600]                     ns <- getNamespace("parallel")
[18:05:02.600]                     if (exists("sendData", mode = "function", 
[18:05:02.600]                       envir = ns)) {
[18:05:02.600]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.600]                         envir = ns)
[18:05:02.600]                       envir <- sys.frame(frame)
[18:05:02.600]                       master <- NULL
[18:05:02.600]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.600]                         !identical(envir, emptyenv())) {
[18:05:02.600]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.600]                           inherits = FALSE)) {
[18:05:02.600]                           master <- get("master", mode = "list", 
[18:05:02.600]                             envir = envir, inherits = FALSE)
[18:05:02.600]                           if (inherits(master, c("SOCKnode", 
[18:05:02.600]                             "SOCK0node"))) {
[18:05:02.600]                             sendCondition <<- function(cond) {
[18:05:02.600]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.600]                                 success = TRUE)
[18:05:02.600]                               parallel_sendData(master, data)
[18:05:02.600]                             }
[18:05:02.600]                             return(sendCondition)
[18:05:02.600]                           }
[18:05:02.600]                         }
[18:05:02.600]                         frame <- frame + 1L
[18:05:02.600]                         envir <- sys.frame(frame)
[18:05:02.600]                       }
[18:05:02.600]                     }
[18:05:02.600]                     sendCondition <<- function(cond) NULL
[18:05:02.600]                   }
[18:05:02.600]                 })
[18:05:02.600]                 withCallingHandlers({
[18:05:02.600]                   {
[18:05:02.600]                     b <- a * ii
[18:05:02.600]                     a <- 0
[18:05:02.600]                     b
[18:05:02.600]                   }
[18:05:02.600]                 }, immediateCondition = function(cond) {
[18:05:02.600]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.600]                   sendCondition(cond)
[18:05:02.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.600]                   {
[18:05:02.600]                     inherits <- base::inherits
[18:05:02.600]                     invokeRestart <- base::invokeRestart
[18:05:02.600]                     is.null <- base::is.null
[18:05:02.600]                     muffled <- FALSE
[18:05:02.600]                     if (inherits(cond, "message")) {
[18:05:02.600]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.600]                       if (muffled) 
[18:05:02.600]                         invokeRestart("muffleMessage")
[18:05:02.600]                     }
[18:05:02.600]                     else if (inherits(cond, "warning")) {
[18:05:02.600]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.600]                       if (muffled) 
[18:05:02.600]                         invokeRestart("muffleWarning")
[18:05:02.600]                     }
[18:05:02.600]                     else if (inherits(cond, "condition")) {
[18:05:02.600]                       if (!is.null(pattern)) {
[18:05:02.600]                         computeRestarts <- base::computeRestarts
[18:05:02.600]                         grepl <- base::grepl
[18:05:02.600]                         restarts <- computeRestarts(cond)
[18:05:02.600]                         for (restart in restarts) {
[18:05:02.600]                           name <- restart$name
[18:05:02.600]                           if (is.null(name)) 
[18:05:02.600]                             next
[18:05:02.600]                           if (!grepl(pattern, name)) 
[18:05:02.600]                             next
[18:05:02.600]                           invokeRestart(restart)
[18:05:02.600]                           muffled <- TRUE
[18:05:02.600]                           break
[18:05:02.600]                         }
[18:05:02.600]                       }
[18:05:02.600]                     }
[18:05:02.600]                     invisible(muffled)
[18:05:02.600]                   }
[18:05:02.600]                   muffleCondition(cond)
[18:05:02.600]                 })
[18:05:02.600]             }))
[18:05:02.600]             future::FutureResult(value = ...future.value$value, 
[18:05:02.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.600]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.600]                     ...future.globalenv.names))
[18:05:02.600]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.600]         }, condition = base::local({
[18:05:02.600]             c <- base::c
[18:05:02.600]             inherits <- base::inherits
[18:05:02.600]             invokeRestart <- base::invokeRestart
[18:05:02.600]             length <- base::length
[18:05:02.600]             list <- base::list
[18:05:02.600]             seq.int <- base::seq.int
[18:05:02.600]             signalCondition <- base::signalCondition
[18:05:02.600]             sys.calls <- base::sys.calls
[18:05:02.600]             `[[` <- base::`[[`
[18:05:02.600]             `+` <- base::`+`
[18:05:02.600]             `<<-` <- base::`<<-`
[18:05:02.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.600]                   3L)]
[18:05:02.600]             }
[18:05:02.600]             function(cond) {
[18:05:02.600]                 is_error <- inherits(cond, "error")
[18:05:02.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.600]                   NULL)
[18:05:02.600]                 if (is_error) {
[18:05:02.600]                   sessionInformation <- function() {
[18:05:02.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.600]                       search = base::search(), system = base::Sys.info())
[18:05:02.600]                   }
[18:05:02.600]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.600]                     cond$call), session = sessionInformation(), 
[18:05:02.600]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.600]                   signalCondition(cond)
[18:05:02.600]                 }
[18:05:02.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.600]                 "immediateCondition"))) {
[18:05:02.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.600]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.600]                   if (TRUE && !signal) {
[18:05:02.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.600]                     {
[18:05:02.600]                       inherits <- base::inherits
[18:05:02.600]                       invokeRestart <- base::invokeRestart
[18:05:02.600]                       is.null <- base::is.null
[18:05:02.600]                       muffled <- FALSE
[18:05:02.600]                       if (inherits(cond, "message")) {
[18:05:02.600]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.600]                         if (muffled) 
[18:05:02.600]                           invokeRestart("muffleMessage")
[18:05:02.600]                       }
[18:05:02.600]                       else if (inherits(cond, "warning")) {
[18:05:02.600]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.600]                         if (muffled) 
[18:05:02.600]                           invokeRestart("muffleWarning")
[18:05:02.600]                       }
[18:05:02.600]                       else if (inherits(cond, "condition")) {
[18:05:02.600]                         if (!is.null(pattern)) {
[18:05:02.600]                           computeRestarts <- base::computeRestarts
[18:05:02.600]                           grepl <- base::grepl
[18:05:02.600]                           restarts <- computeRestarts(cond)
[18:05:02.600]                           for (restart in restarts) {
[18:05:02.600]                             name <- restart$name
[18:05:02.600]                             if (is.null(name)) 
[18:05:02.600]                               next
[18:05:02.600]                             if (!grepl(pattern, name)) 
[18:05:02.600]                               next
[18:05:02.600]                             invokeRestart(restart)
[18:05:02.600]                             muffled <- TRUE
[18:05:02.600]                             break
[18:05:02.600]                           }
[18:05:02.600]                         }
[18:05:02.600]                       }
[18:05:02.600]                       invisible(muffled)
[18:05:02.600]                     }
[18:05:02.600]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.600]                   }
[18:05:02.600]                 }
[18:05:02.600]                 else {
[18:05:02.600]                   if (TRUE) {
[18:05:02.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.600]                     {
[18:05:02.600]                       inherits <- base::inherits
[18:05:02.600]                       invokeRestart <- base::invokeRestart
[18:05:02.600]                       is.null <- base::is.null
[18:05:02.600]                       muffled <- FALSE
[18:05:02.600]                       if (inherits(cond, "message")) {
[18:05:02.600]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.600]                         if (muffled) 
[18:05:02.600]                           invokeRestart("muffleMessage")
[18:05:02.600]                       }
[18:05:02.600]                       else if (inherits(cond, "warning")) {
[18:05:02.600]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.600]                         if (muffled) 
[18:05:02.600]                           invokeRestart("muffleWarning")
[18:05:02.600]                       }
[18:05:02.600]                       else if (inherits(cond, "condition")) {
[18:05:02.600]                         if (!is.null(pattern)) {
[18:05:02.600]                           computeRestarts <- base::computeRestarts
[18:05:02.600]                           grepl <- base::grepl
[18:05:02.600]                           restarts <- computeRestarts(cond)
[18:05:02.600]                           for (restart in restarts) {
[18:05:02.600]                             name <- restart$name
[18:05:02.600]                             if (is.null(name)) 
[18:05:02.600]                               next
[18:05:02.600]                             if (!grepl(pattern, name)) 
[18:05:02.600]                               next
[18:05:02.600]                             invokeRestart(restart)
[18:05:02.600]                             muffled <- TRUE
[18:05:02.600]                             break
[18:05:02.600]                           }
[18:05:02.600]                         }
[18:05:02.600]                       }
[18:05:02.600]                       invisible(muffled)
[18:05:02.600]                     }
[18:05:02.600]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.600]                   }
[18:05:02.600]                 }
[18:05:02.600]             }
[18:05:02.600]         }))
[18:05:02.600]     }, error = function(ex) {
[18:05:02.600]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.600]                 ...future.rng), started = ...future.startTime, 
[18:05:02.600]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.600]             version = "1.8"), class = "FutureResult")
[18:05:02.600]     }, finally = {
[18:05:02.600]         if (!identical(...future.workdir, getwd())) 
[18:05:02.600]             setwd(...future.workdir)
[18:05:02.600]         {
[18:05:02.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.600]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.600]             }
[18:05:02.600]             base::options(...future.oldOptions)
[18:05:02.600]             if (.Platform$OS.type == "windows") {
[18:05:02.600]                 old_names <- names(...future.oldEnvVars)
[18:05:02.600]                 envs <- base::Sys.getenv()
[18:05:02.600]                 names <- names(envs)
[18:05:02.600]                 common <- intersect(names, old_names)
[18:05:02.600]                 added <- setdiff(names, old_names)
[18:05:02.600]                 removed <- setdiff(old_names, names)
[18:05:02.600]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.600]                   envs[common]]
[18:05:02.600]                 NAMES <- toupper(changed)
[18:05:02.600]                 args <- list()
[18:05:02.600]                 for (kk in seq_along(NAMES)) {
[18:05:02.600]                   name <- changed[[kk]]
[18:05:02.600]                   NAME <- NAMES[[kk]]
[18:05:02.600]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.600]                     next
[18:05:02.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.600]                 }
[18:05:02.600]                 NAMES <- toupper(added)
[18:05:02.600]                 for (kk in seq_along(NAMES)) {
[18:05:02.600]                   name <- added[[kk]]
[18:05:02.600]                   NAME <- NAMES[[kk]]
[18:05:02.600]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.600]                     next
[18:05:02.600]                   args[[name]] <- ""
[18:05:02.600]                 }
[18:05:02.600]                 NAMES <- toupper(removed)
[18:05:02.600]                 for (kk in seq_along(NAMES)) {
[18:05:02.600]                   name <- removed[[kk]]
[18:05:02.600]                   NAME <- NAMES[[kk]]
[18:05:02.600]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.600]                     next
[18:05:02.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.600]                 }
[18:05:02.600]                 if (length(args) > 0) 
[18:05:02.600]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.600]             }
[18:05:02.600]             else {
[18:05:02.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.600]             }
[18:05:02.600]             {
[18:05:02.600]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.600]                   0L) {
[18:05:02.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.600]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.600]                   base::options(opts)
[18:05:02.600]                 }
[18:05:02.600]                 {
[18:05:02.600]                   {
[18:05:02.600]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.600]                     NULL
[18:05:02.600]                   }
[18:05:02.600]                   options(future.plan = NULL)
[18:05:02.600]                   if (is.na(NA_character_)) 
[18:05:02.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.600]                     .init = FALSE)
[18:05:02.600]                 }
[18:05:02.600]             }
[18:05:02.600]         }
[18:05:02.600]     })
[18:05:02.600]     if (TRUE) {
[18:05:02.600]         base::sink(type = "output", split = FALSE)
[18:05:02.600]         if (TRUE) {
[18:05:02.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.600]         }
[18:05:02.600]         else {
[18:05:02.600]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.600]         }
[18:05:02.600]         base::close(...future.stdout)
[18:05:02.600]         ...future.stdout <- NULL
[18:05:02.600]     }
[18:05:02.600]     ...future.result$conditions <- ...future.conditions
[18:05:02.600]     ...future.result$finished <- base::Sys.time()
[18:05:02.600]     ...future.result
[18:05:02.600] }
[18:05:02.605] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[18:05:02.606] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[18:05:02.606] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[18:05:02.607] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[18:05:02.608] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[18:05:02.609] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[18:05:02.610] MultisessionFuture started
[18:05:02.610] - Launch lazy future ... done
[18:05:02.610] run() for ‘MultisessionFuture’ ... done
[18:05:02.611] result() for ClusterFuture ...
[18:05:02.611] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.611] - Validating connection of MultisessionFuture
[18:05:02.653] - received message: FutureResult
[18:05:02.654] - Received FutureResult
[18:05:02.654] - Erased future from FutureRegistry
[18:05:02.654] result() for ClusterFuture ...
[18:05:02.655] - result already collected: FutureResult
[18:05:02.655] result() for ClusterFuture ... done
[18:05:02.655] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.655] result() for ClusterFuture ... done
[18:05:02.656] result() for ClusterFuture ...
[18:05:02.656] - result already collected: FutureResult
[18:05:02.656] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.657] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.657] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.658] 
[18:05:02.659] Searching for globals ... DONE
[18:05:02.659] - globals: [0] <none>
[18:05:02.659] getGlobalsAndPackages() ... DONE
[18:05:02.660] run() for ‘Future’ ...
[18:05:02.660] - state: ‘created’
[18:05:02.660] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.686] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.686]   - Field: ‘node’
[18:05:02.687]   - Field: ‘label’
[18:05:02.687]   - Field: ‘local’
[18:05:02.687]   - Field: ‘owner’
[18:05:02.687]   - Field: ‘envir’
[18:05:02.688]   - Field: ‘workers’
[18:05:02.688]   - Field: ‘packages’
[18:05:02.688]   - Field: ‘gc’
[18:05:02.688]   - Field: ‘conditions’
[18:05:02.688]   - Field: ‘persistent’
[18:05:02.689]   - Field: ‘expr’
[18:05:02.689]   - Field: ‘uuid’
[18:05:02.689]   - Field: ‘seed’
[18:05:02.689]   - Field: ‘version’
[18:05:02.689]   - Field: ‘result’
[18:05:02.689]   - Field: ‘asynchronous’
[18:05:02.690]   - Field: ‘calls’
[18:05:02.690]   - Field: ‘globals’
[18:05:02.690]   - Field: ‘stdout’
[18:05:02.690]   - Field: ‘earlySignal’
[18:05:02.690]   - Field: ‘lazy’
[18:05:02.691]   - Field: ‘state’
[18:05:02.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.691] - Launch lazy future ...
[18:05:02.692] Packages needed by the future expression (n = 0): <none>
[18:05:02.692] Packages needed by future strategies (n = 0): <none>
[18:05:02.693] {
[18:05:02.693]     {
[18:05:02.693]         {
[18:05:02.693]             ...future.startTime <- base::Sys.time()
[18:05:02.693]             {
[18:05:02.693]                 {
[18:05:02.693]                   {
[18:05:02.693]                     {
[18:05:02.693]                       base::local({
[18:05:02.693]                         has_future <- base::requireNamespace("future", 
[18:05:02.693]                           quietly = TRUE)
[18:05:02.693]                         if (has_future) {
[18:05:02.693]                           ns <- base::getNamespace("future")
[18:05:02.693]                           version <- ns[[".package"]][["version"]]
[18:05:02.693]                           if (is.null(version)) 
[18:05:02.693]                             version <- utils::packageVersion("future")
[18:05:02.693]                         }
[18:05:02.693]                         else {
[18:05:02.693]                           version <- NULL
[18:05:02.693]                         }
[18:05:02.693]                         if (!has_future || version < "1.8.0") {
[18:05:02.693]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.693]                             "", base::R.version$version.string), 
[18:05:02.693]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:02.693]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:02.693]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.693]                               "release", "version")], collapse = " "), 
[18:05:02.693]                             hostname = base::Sys.info()[["nodename"]])
[18:05:02.693]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.693]                             info)
[18:05:02.693]                           info <- base::paste(info, collapse = "; ")
[18:05:02.693]                           if (!has_future) {
[18:05:02.693]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.693]                               info)
[18:05:02.693]                           }
[18:05:02.693]                           else {
[18:05:02.693]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.693]                               info, version)
[18:05:02.693]                           }
[18:05:02.693]                           base::stop(msg)
[18:05:02.693]                         }
[18:05:02.693]                       })
[18:05:02.693]                     }
[18:05:02.693]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.693]                     base::options(mc.cores = 1L)
[18:05:02.693]                   }
[18:05:02.693]                   ...future.strategy.old <- future::plan("list")
[18:05:02.693]                   options(future.plan = NULL)
[18:05:02.693]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.693]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.693]                 }
[18:05:02.693]                 ...future.workdir <- getwd()
[18:05:02.693]             }
[18:05:02.693]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.693]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.693]         }
[18:05:02.693]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.693]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.693]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.693]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.693]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.693]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.693]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.693]             base::names(...future.oldOptions))
[18:05:02.693]     }
[18:05:02.693]     if (FALSE) {
[18:05:02.693]     }
[18:05:02.693]     else {
[18:05:02.693]         if (TRUE) {
[18:05:02.693]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.693]                 open = "w")
[18:05:02.693]         }
[18:05:02.693]         else {
[18:05:02.693]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.693]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.693]         }
[18:05:02.693]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.693]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.693]             base::sink(type = "output", split = FALSE)
[18:05:02.693]             base::close(...future.stdout)
[18:05:02.693]         }, add = TRUE)
[18:05:02.693]     }
[18:05:02.693]     ...future.frame <- base::sys.nframe()
[18:05:02.693]     ...future.conditions <- base::list()
[18:05:02.693]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.693]     if (FALSE) {
[18:05:02.693]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.693]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.693]     }
[18:05:02.693]     ...future.result <- base::tryCatch({
[18:05:02.693]         base::withCallingHandlers({
[18:05:02.693]             ...future.value <- base::withVisible(base::local({
[18:05:02.693]                 ...future.makeSendCondition <- base::local({
[18:05:02.693]                   sendCondition <- NULL
[18:05:02.693]                   function(frame = 1L) {
[18:05:02.693]                     if (is.function(sendCondition)) 
[18:05:02.693]                       return(sendCondition)
[18:05:02.693]                     ns <- getNamespace("parallel")
[18:05:02.693]                     if (exists("sendData", mode = "function", 
[18:05:02.693]                       envir = ns)) {
[18:05:02.693]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.693]                         envir = ns)
[18:05:02.693]                       envir <- sys.frame(frame)
[18:05:02.693]                       master <- NULL
[18:05:02.693]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.693]                         !identical(envir, emptyenv())) {
[18:05:02.693]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.693]                           inherits = FALSE)) {
[18:05:02.693]                           master <- get("master", mode = "list", 
[18:05:02.693]                             envir = envir, inherits = FALSE)
[18:05:02.693]                           if (inherits(master, c("SOCKnode", 
[18:05:02.693]                             "SOCK0node"))) {
[18:05:02.693]                             sendCondition <<- function(cond) {
[18:05:02.693]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.693]                                 success = TRUE)
[18:05:02.693]                               parallel_sendData(master, data)
[18:05:02.693]                             }
[18:05:02.693]                             return(sendCondition)
[18:05:02.693]                           }
[18:05:02.693]                         }
[18:05:02.693]                         frame <- frame + 1L
[18:05:02.693]                         envir <- sys.frame(frame)
[18:05:02.693]                       }
[18:05:02.693]                     }
[18:05:02.693]                     sendCondition <<- function(cond) NULL
[18:05:02.693]                   }
[18:05:02.693]                 })
[18:05:02.693]                 withCallingHandlers({
[18:05:02.693]                   1
[18:05:02.693]                 }, immediateCondition = function(cond) {
[18:05:02.693]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.693]                   sendCondition(cond)
[18:05:02.693]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.693]                   {
[18:05:02.693]                     inherits <- base::inherits
[18:05:02.693]                     invokeRestart <- base::invokeRestart
[18:05:02.693]                     is.null <- base::is.null
[18:05:02.693]                     muffled <- FALSE
[18:05:02.693]                     if (inherits(cond, "message")) {
[18:05:02.693]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.693]                       if (muffled) 
[18:05:02.693]                         invokeRestart("muffleMessage")
[18:05:02.693]                     }
[18:05:02.693]                     else if (inherits(cond, "warning")) {
[18:05:02.693]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.693]                       if (muffled) 
[18:05:02.693]                         invokeRestart("muffleWarning")
[18:05:02.693]                     }
[18:05:02.693]                     else if (inherits(cond, "condition")) {
[18:05:02.693]                       if (!is.null(pattern)) {
[18:05:02.693]                         computeRestarts <- base::computeRestarts
[18:05:02.693]                         grepl <- base::grepl
[18:05:02.693]                         restarts <- computeRestarts(cond)
[18:05:02.693]                         for (restart in restarts) {
[18:05:02.693]                           name <- restart$name
[18:05:02.693]                           if (is.null(name)) 
[18:05:02.693]                             next
[18:05:02.693]                           if (!grepl(pattern, name)) 
[18:05:02.693]                             next
[18:05:02.693]                           invokeRestart(restart)
[18:05:02.693]                           muffled <- TRUE
[18:05:02.693]                           break
[18:05:02.693]                         }
[18:05:02.693]                       }
[18:05:02.693]                     }
[18:05:02.693]                     invisible(muffled)
[18:05:02.693]                   }
[18:05:02.693]                   muffleCondition(cond)
[18:05:02.693]                 })
[18:05:02.693]             }))
[18:05:02.693]             future::FutureResult(value = ...future.value$value, 
[18:05:02.693]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.693]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.693]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.693]                     ...future.globalenv.names))
[18:05:02.693]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.693]         }, condition = base::local({
[18:05:02.693]             c <- base::c
[18:05:02.693]             inherits <- base::inherits
[18:05:02.693]             invokeRestart <- base::invokeRestart
[18:05:02.693]             length <- base::length
[18:05:02.693]             list <- base::list
[18:05:02.693]             seq.int <- base::seq.int
[18:05:02.693]             signalCondition <- base::signalCondition
[18:05:02.693]             sys.calls <- base::sys.calls
[18:05:02.693]             `[[` <- base::`[[`
[18:05:02.693]             `+` <- base::`+`
[18:05:02.693]             `<<-` <- base::`<<-`
[18:05:02.693]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.693]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.693]                   3L)]
[18:05:02.693]             }
[18:05:02.693]             function(cond) {
[18:05:02.693]                 is_error <- inherits(cond, "error")
[18:05:02.693]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.693]                   NULL)
[18:05:02.693]                 if (is_error) {
[18:05:02.693]                   sessionInformation <- function() {
[18:05:02.693]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.693]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.693]                       search = base::search(), system = base::Sys.info())
[18:05:02.693]                   }
[18:05:02.693]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.693]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.693]                     cond$call), session = sessionInformation(), 
[18:05:02.693]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.693]                   signalCondition(cond)
[18:05:02.693]                 }
[18:05:02.693]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.693]                 "immediateCondition"))) {
[18:05:02.693]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.693]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.693]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.693]                   if (TRUE && !signal) {
[18:05:02.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.693]                     {
[18:05:02.693]                       inherits <- base::inherits
[18:05:02.693]                       invokeRestart <- base::invokeRestart
[18:05:02.693]                       is.null <- base::is.null
[18:05:02.693]                       muffled <- FALSE
[18:05:02.693]                       if (inherits(cond, "message")) {
[18:05:02.693]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.693]                         if (muffled) 
[18:05:02.693]                           invokeRestart("muffleMessage")
[18:05:02.693]                       }
[18:05:02.693]                       else if (inherits(cond, "warning")) {
[18:05:02.693]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.693]                         if (muffled) 
[18:05:02.693]                           invokeRestart("muffleWarning")
[18:05:02.693]                       }
[18:05:02.693]                       else if (inherits(cond, "condition")) {
[18:05:02.693]                         if (!is.null(pattern)) {
[18:05:02.693]                           computeRestarts <- base::computeRestarts
[18:05:02.693]                           grepl <- base::grepl
[18:05:02.693]                           restarts <- computeRestarts(cond)
[18:05:02.693]                           for (restart in restarts) {
[18:05:02.693]                             name <- restart$name
[18:05:02.693]                             if (is.null(name)) 
[18:05:02.693]                               next
[18:05:02.693]                             if (!grepl(pattern, name)) 
[18:05:02.693]                               next
[18:05:02.693]                             invokeRestart(restart)
[18:05:02.693]                             muffled <- TRUE
[18:05:02.693]                             break
[18:05:02.693]                           }
[18:05:02.693]                         }
[18:05:02.693]                       }
[18:05:02.693]                       invisible(muffled)
[18:05:02.693]                     }
[18:05:02.693]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.693]                   }
[18:05:02.693]                 }
[18:05:02.693]                 else {
[18:05:02.693]                   if (TRUE) {
[18:05:02.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.693]                     {
[18:05:02.693]                       inherits <- base::inherits
[18:05:02.693]                       invokeRestart <- base::invokeRestart
[18:05:02.693]                       is.null <- base::is.null
[18:05:02.693]                       muffled <- FALSE
[18:05:02.693]                       if (inherits(cond, "message")) {
[18:05:02.693]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.693]                         if (muffled) 
[18:05:02.693]                           invokeRestart("muffleMessage")
[18:05:02.693]                       }
[18:05:02.693]                       else if (inherits(cond, "warning")) {
[18:05:02.693]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.693]                         if (muffled) 
[18:05:02.693]                           invokeRestart("muffleWarning")
[18:05:02.693]                       }
[18:05:02.693]                       else if (inherits(cond, "condition")) {
[18:05:02.693]                         if (!is.null(pattern)) {
[18:05:02.693]                           computeRestarts <- base::computeRestarts
[18:05:02.693]                           grepl <- base::grepl
[18:05:02.693]                           restarts <- computeRestarts(cond)
[18:05:02.693]                           for (restart in restarts) {
[18:05:02.693]                             name <- restart$name
[18:05:02.693]                             if (is.null(name)) 
[18:05:02.693]                               next
[18:05:02.693]                             if (!grepl(pattern, name)) 
[18:05:02.693]                               next
[18:05:02.693]                             invokeRestart(restart)
[18:05:02.693]                             muffled <- TRUE
[18:05:02.693]                             break
[18:05:02.693]                           }
[18:05:02.693]                         }
[18:05:02.693]                       }
[18:05:02.693]                       invisible(muffled)
[18:05:02.693]                     }
[18:05:02.693]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.693]                   }
[18:05:02.693]                 }
[18:05:02.693]             }
[18:05:02.693]         }))
[18:05:02.693]     }, error = function(ex) {
[18:05:02.693]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.693]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.693]                 ...future.rng), started = ...future.startTime, 
[18:05:02.693]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.693]             version = "1.8"), class = "FutureResult")
[18:05:02.693]     }, finally = {
[18:05:02.693]         if (!identical(...future.workdir, getwd())) 
[18:05:02.693]             setwd(...future.workdir)
[18:05:02.693]         {
[18:05:02.693]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.693]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.693]             }
[18:05:02.693]             base::options(...future.oldOptions)
[18:05:02.693]             if (.Platform$OS.type == "windows") {
[18:05:02.693]                 old_names <- names(...future.oldEnvVars)
[18:05:02.693]                 envs <- base::Sys.getenv()
[18:05:02.693]                 names <- names(envs)
[18:05:02.693]                 common <- intersect(names, old_names)
[18:05:02.693]                 added <- setdiff(names, old_names)
[18:05:02.693]                 removed <- setdiff(old_names, names)
[18:05:02.693]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.693]                   envs[common]]
[18:05:02.693]                 NAMES <- toupper(changed)
[18:05:02.693]                 args <- list()
[18:05:02.693]                 for (kk in seq_along(NAMES)) {
[18:05:02.693]                   name <- changed[[kk]]
[18:05:02.693]                   NAME <- NAMES[[kk]]
[18:05:02.693]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.693]                     next
[18:05:02.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.693]                 }
[18:05:02.693]                 NAMES <- toupper(added)
[18:05:02.693]                 for (kk in seq_along(NAMES)) {
[18:05:02.693]                   name <- added[[kk]]
[18:05:02.693]                   NAME <- NAMES[[kk]]
[18:05:02.693]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.693]                     next
[18:05:02.693]                   args[[name]] <- ""
[18:05:02.693]                 }
[18:05:02.693]                 NAMES <- toupper(removed)
[18:05:02.693]                 for (kk in seq_along(NAMES)) {
[18:05:02.693]                   name <- removed[[kk]]
[18:05:02.693]                   NAME <- NAMES[[kk]]
[18:05:02.693]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.693]                     next
[18:05:02.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.693]                 }
[18:05:02.693]                 if (length(args) > 0) 
[18:05:02.693]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.693]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.693]             }
[18:05:02.693]             else {
[18:05:02.693]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.693]             }
[18:05:02.693]             {
[18:05:02.693]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.693]                   0L) {
[18:05:02.693]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.693]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.693]                   base::options(opts)
[18:05:02.693]                 }
[18:05:02.693]                 {
[18:05:02.693]                   {
[18:05:02.693]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.693]                     NULL
[18:05:02.693]                   }
[18:05:02.693]                   options(future.plan = NULL)
[18:05:02.693]                   if (is.na(NA_character_)) 
[18:05:02.693]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.693]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.693]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.693]                     .init = FALSE)
[18:05:02.693]                 }
[18:05:02.693]             }
[18:05:02.693]         }
[18:05:02.693]     })
[18:05:02.693]     if (TRUE) {
[18:05:02.693]         base::sink(type = "output", split = FALSE)
[18:05:02.693]         if (TRUE) {
[18:05:02.693]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.693]         }
[18:05:02.693]         else {
[18:05:02.693]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.693]         }
[18:05:02.693]         base::close(...future.stdout)
[18:05:02.693]         ...future.stdout <- NULL
[18:05:02.693]     }
[18:05:02.693]     ...future.result$conditions <- ...future.conditions
[18:05:02.693]     ...future.result$finished <- base::Sys.time()
[18:05:02.693]     ...future.result
[18:05:02.693] }
[18:05:02.698] MultisessionFuture started
[18:05:02.699] - Launch lazy future ... done
[18:05:02.699] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.699] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.700] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.702] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:05:02.702] Searching for globals ... DONE
[18:05:02.702] Resolving globals: TRUE
[18:05:02.702] Resolving any globals that are futures ...
[18:05:02.703] - globals: [3] ‘+’, ‘value’, ‘a’
[18:05:02.703] Resolving any globals that are futures ... DONE
[18:05:02.703] Resolving futures part of globals (recursively) ...
[18:05:02.704] resolve() on list ...
[18:05:02.704]  recursive: 99
[18:05:02.704]  length: 1
[18:05:02.705]  elements: ‘a’
[18:05:02.749] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.749] - Validating connection of MultisessionFuture
[18:05:02.749] - received message: FutureResult
[18:05:02.750] - Received FutureResult
[18:05:02.750] - Erased future from FutureRegistry
[18:05:02.750] result() for ClusterFuture ...
[18:05:02.751] - result already collected: FutureResult
[18:05:02.751] result() for ClusterFuture ... done
[18:05:02.751] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.751] Future #1
[18:05:02.751] result() for ClusterFuture ...
[18:05:02.752] - result already collected: FutureResult
[18:05:02.752] result() for ClusterFuture ... done
[18:05:02.752] result() for ClusterFuture ...
[18:05:02.752] - result already collected: FutureResult
[18:05:02.753] result() for ClusterFuture ... done
[18:05:02.753] A MultisessionFuture was resolved
[18:05:02.753]  length: 0 (resolved future 1)
[18:05:02.753] resolve() on list ... DONE
[18:05:02.754] - globals: [1] ‘a’
[18:05:02.754] Resolving futures part of globals (recursively) ... DONE
[18:05:02.759] The total size of the 1 globals is 1.57 MiB (1649664 bytes)
[18:05:02.759] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[18:05:02.760] - globals: [1] ‘a’
[18:05:02.760] - packages: [1] ‘future’
[18:05:02.760] getGlobalsAndPackages() ... DONE
[18:05:02.761] run() for ‘Future’ ...
[18:05:02.761] - state: ‘created’
[18:05:02.761] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.788] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.788]   - Field: ‘node’
[18:05:02.789]   - Field: ‘label’
[18:05:02.789]   - Field: ‘local’
[18:05:02.789]   - Field: ‘owner’
[18:05:02.789]   - Field: ‘envir’
[18:05:02.790]   - Field: ‘workers’
[18:05:02.790]   - Field: ‘packages’
[18:05:02.790]   - Field: ‘gc’
[18:05:02.790]   - Field: ‘conditions’
[18:05:02.790]   - Field: ‘persistent’
[18:05:02.791]   - Field: ‘expr’
[18:05:02.791]   - Field: ‘uuid’
[18:05:02.791]   - Field: ‘seed’
[18:05:02.791]   - Field: ‘version’
[18:05:02.791]   - Field: ‘result’
[18:05:02.792]   - Field: ‘asynchronous’
[18:05:02.792]   - Field: ‘calls’
[18:05:02.792]   - Field: ‘globals’
[18:05:02.792]   - Field: ‘stdout’
[18:05:02.792]   - Field: ‘earlySignal’
[18:05:02.793]   - Field: ‘lazy’
[18:05:02.793]   - Field: ‘state’
[18:05:02.793] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.793] - Launch lazy future ...
[18:05:02.794] Packages needed by the future expression (n = 1): ‘future’
[18:05:02.794] Packages needed by future strategies (n = 0): <none>
[18:05:02.795] {
[18:05:02.795]     {
[18:05:02.795]         {
[18:05:02.795]             ...future.startTime <- base::Sys.time()
[18:05:02.795]             {
[18:05:02.795]                 {
[18:05:02.795]                   {
[18:05:02.795]                     {
[18:05:02.795]                       {
[18:05:02.795]                         base::local({
[18:05:02.795]                           has_future <- base::requireNamespace("future", 
[18:05:02.795]                             quietly = TRUE)
[18:05:02.795]                           if (has_future) {
[18:05:02.795]                             ns <- base::getNamespace("future")
[18:05:02.795]                             version <- ns[[".package"]][["version"]]
[18:05:02.795]                             if (is.null(version)) 
[18:05:02.795]                               version <- utils::packageVersion("future")
[18:05:02.795]                           }
[18:05:02.795]                           else {
[18:05:02.795]                             version <- NULL
[18:05:02.795]                           }
[18:05:02.795]                           if (!has_future || version < "1.8.0") {
[18:05:02.795]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.795]                               "", base::R.version$version.string), 
[18:05:02.795]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:02.795]                                 base::R.version$platform, 8 * 
[18:05:02.795]                                   base::.Machine$sizeof.pointer), 
[18:05:02.795]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.795]                                 "release", "version")], collapse = " "), 
[18:05:02.795]                               hostname = base::Sys.info()[["nodename"]])
[18:05:02.795]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.795]                               info)
[18:05:02.795]                             info <- base::paste(info, collapse = "; ")
[18:05:02.795]                             if (!has_future) {
[18:05:02.795]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.795]                                 info)
[18:05:02.795]                             }
[18:05:02.795]                             else {
[18:05:02.795]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.795]                                 info, version)
[18:05:02.795]                             }
[18:05:02.795]                             base::stop(msg)
[18:05:02.795]                           }
[18:05:02.795]                         })
[18:05:02.795]                       }
[18:05:02.795]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.795]                       base::options(mc.cores = 1L)
[18:05:02.795]                     }
[18:05:02.795]                     base::local({
[18:05:02.795]                       for (pkg in "future") {
[18:05:02.795]                         base::loadNamespace(pkg)
[18:05:02.795]                         base::library(pkg, character.only = TRUE)
[18:05:02.795]                       }
[18:05:02.795]                     })
[18:05:02.795]                   }
[18:05:02.795]                   ...future.strategy.old <- future::plan("list")
[18:05:02.795]                   options(future.plan = NULL)
[18:05:02.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.795]                 }
[18:05:02.795]                 ...future.workdir <- getwd()
[18:05:02.795]             }
[18:05:02.795]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.795]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.795]         }
[18:05:02.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.795]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.795]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.795]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.795]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.795]             base::names(...future.oldOptions))
[18:05:02.795]     }
[18:05:02.795]     if (FALSE) {
[18:05:02.795]     }
[18:05:02.795]     else {
[18:05:02.795]         if (TRUE) {
[18:05:02.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.795]                 open = "w")
[18:05:02.795]         }
[18:05:02.795]         else {
[18:05:02.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.795]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.795]         }
[18:05:02.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.795]             base::sink(type = "output", split = FALSE)
[18:05:02.795]             base::close(...future.stdout)
[18:05:02.795]         }, add = TRUE)
[18:05:02.795]     }
[18:05:02.795]     ...future.frame <- base::sys.nframe()
[18:05:02.795]     ...future.conditions <- base::list()
[18:05:02.795]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.795]     if (FALSE) {
[18:05:02.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.795]     }
[18:05:02.795]     ...future.result <- base::tryCatch({
[18:05:02.795]         base::withCallingHandlers({
[18:05:02.795]             ...future.value <- base::withVisible(base::local({
[18:05:02.795]                 ...future.makeSendCondition <- base::local({
[18:05:02.795]                   sendCondition <- NULL
[18:05:02.795]                   function(frame = 1L) {
[18:05:02.795]                     if (is.function(sendCondition)) 
[18:05:02.795]                       return(sendCondition)
[18:05:02.795]                     ns <- getNamespace("parallel")
[18:05:02.795]                     if (exists("sendData", mode = "function", 
[18:05:02.795]                       envir = ns)) {
[18:05:02.795]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.795]                         envir = ns)
[18:05:02.795]                       envir <- sys.frame(frame)
[18:05:02.795]                       master <- NULL
[18:05:02.795]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.795]                         !identical(envir, emptyenv())) {
[18:05:02.795]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.795]                           inherits = FALSE)) {
[18:05:02.795]                           master <- get("master", mode = "list", 
[18:05:02.795]                             envir = envir, inherits = FALSE)
[18:05:02.795]                           if (inherits(master, c("SOCKnode", 
[18:05:02.795]                             "SOCK0node"))) {
[18:05:02.795]                             sendCondition <<- function(cond) {
[18:05:02.795]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.795]                                 success = TRUE)
[18:05:02.795]                               parallel_sendData(master, data)
[18:05:02.795]                             }
[18:05:02.795]                             return(sendCondition)
[18:05:02.795]                           }
[18:05:02.795]                         }
[18:05:02.795]                         frame <- frame + 1L
[18:05:02.795]                         envir <- sys.frame(frame)
[18:05:02.795]                       }
[18:05:02.795]                     }
[18:05:02.795]                     sendCondition <<- function(cond) NULL
[18:05:02.795]                   }
[18:05:02.795]                 })
[18:05:02.795]                 withCallingHandlers({
[18:05:02.795]                   value(a) + 1
[18:05:02.795]                 }, immediateCondition = function(cond) {
[18:05:02.795]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.795]                   sendCondition(cond)
[18:05:02.795]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.795]                   {
[18:05:02.795]                     inherits <- base::inherits
[18:05:02.795]                     invokeRestart <- base::invokeRestart
[18:05:02.795]                     is.null <- base::is.null
[18:05:02.795]                     muffled <- FALSE
[18:05:02.795]                     if (inherits(cond, "message")) {
[18:05:02.795]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.795]                       if (muffled) 
[18:05:02.795]                         invokeRestart("muffleMessage")
[18:05:02.795]                     }
[18:05:02.795]                     else if (inherits(cond, "warning")) {
[18:05:02.795]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.795]                       if (muffled) 
[18:05:02.795]                         invokeRestart("muffleWarning")
[18:05:02.795]                     }
[18:05:02.795]                     else if (inherits(cond, "condition")) {
[18:05:02.795]                       if (!is.null(pattern)) {
[18:05:02.795]                         computeRestarts <- base::computeRestarts
[18:05:02.795]                         grepl <- base::grepl
[18:05:02.795]                         restarts <- computeRestarts(cond)
[18:05:02.795]                         for (restart in restarts) {
[18:05:02.795]                           name <- restart$name
[18:05:02.795]                           if (is.null(name)) 
[18:05:02.795]                             next
[18:05:02.795]                           if (!grepl(pattern, name)) 
[18:05:02.795]                             next
[18:05:02.795]                           invokeRestart(restart)
[18:05:02.795]                           muffled <- TRUE
[18:05:02.795]                           break
[18:05:02.795]                         }
[18:05:02.795]                       }
[18:05:02.795]                     }
[18:05:02.795]                     invisible(muffled)
[18:05:02.795]                   }
[18:05:02.795]                   muffleCondition(cond)
[18:05:02.795]                 })
[18:05:02.795]             }))
[18:05:02.795]             future::FutureResult(value = ...future.value$value, 
[18:05:02.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.795]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.795]                     ...future.globalenv.names))
[18:05:02.795]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.795]         }, condition = base::local({
[18:05:02.795]             c <- base::c
[18:05:02.795]             inherits <- base::inherits
[18:05:02.795]             invokeRestart <- base::invokeRestart
[18:05:02.795]             length <- base::length
[18:05:02.795]             list <- base::list
[18:05:02.795]             seq.int <- base::seq.int
[18:05:02.795]             signalCondition <- base::signalCondition
[18:05:02.795]             sys.calls <- base::sys.calls
[18:05:02.795]             `[[` <- base::`[[`
[18:05:02.795]             `+` <- base::`+`
[18:05:02.795]             `<<-` <- base::`<<-`
[18:05:02.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.795]                   3L)]
[18:05:02.795]             }
[18:05:02.795]             function(cond) {
[18:05:02.795]                 is_error <- inherits(cond, "error")
[18:05:02.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.795]                   NULL)
[18:05:02.795]                 if (is_error) {
[18:05:02.795]                   sessionInformation <- function() {
[18:05:02.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.795]                       search = base::search(), system = base::Sys.info())
[18:05:02.795]                   }
[18:05:02.795]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.795]                     cond$call), session = sessionInformation(), 
[18:05:02.795]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.795]                   signalCondition(cond)
[18:05:02.795]                 }
[18:05:02.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.795]                 "immediateCondition"))) {
[18:05:02.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.795]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.795]                   if (TRUE && !signal) {
[18:05:02.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.795]                     {
[18:05:02.795]                       inherits <- base::inherits
[18:05:02.795]                       invokeRestart <- base::invokeRestart
[18:05:02.795]                       is.null <- base::is.null
[18:05:02.795]                       muffled <- FALSE
[18:05:02.795]                       if (inherits(cond, "message")) {
[18:05:02.795]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.795]                         if (muffled) 
[18:05:02.795]                           invokeRestart("muffleMessage")
[18:05:02.795]                       }
[18:05:02.795]                       else if (inherits(cond, "warning")) {
[18:05:02.795]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.795]                         if (muffled) 
[18:05:02.795]                           invokeRestart("muffleWarning")
[18:05:02.795]                       }
[18:05:02.795]                       else if (inherits(cond, "condition")) {
[18:05:02.795]                         if (!is.null(pattern)) {
[18:05:02.795]                           computeRestarts <- base::computeRestarts
[18:05:02.795]                           grepl <- base::grepl
[18:05:02.795]                           restarts <- computeRestarts(cond)
[18:05:02.795]                           for (restart in restarts) {
[18:05:02.795]                             name <- restart$name
[18:05:02.795]                             if (is.null(name)) 
[18:05:02.795]                               next
[18:05:02.795]                             if (!grepl(pattern, name)) 
[18:05:02.795]                               next
[18:05:02.795]                             invokeRestart(restart)
[18:05:02.795]                             muffled <- TRUE
[18:05:02.795]                             break
[18:05:02.795]                           }
[18:05:02.795]                         }
[18:05:02.795]                       }
[18:05:02.795]                       invisible(muffled)
[18:05:02.795]                     }
[18:05:02.795]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.795]                   }
[18:05:02.795]                 }
[18:05:02.795]                 else {
[18:05:02.795]                   if (TRUE) {
[18:05:02.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.795]                     {
[18:05:02.795]                       inherits <- base::inherits
[18:05:02.795]                       invokeRestart <- base::invokeRestart
[18:05:02.795]                       is.null <- base::is.null
[18:05:02.795]                       muffled <- FALSE
[18:05:02.795]                       if (inherits(cond, "message")) {
[18:05:02.795]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.795]                         if (muffled) 
[18:05:02.795]                           invokeRestart("muffleMessage")
[18:05:02.795]                       }
[18:05:02.795]                       else if (inherits(cond, "warning")) {
[18:05:02.795]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.795]                         if (muffled) 
[18:05:02.795]                           invokeRestart("muffleWarning")
[18:05:02.795]                       }
[18:05:02.795]                       else if (inherits(cond, "condition")) {
[18:05:02.795]                         if (!is.null(pattern)) {
[18:05:02.795]                           computeRestarts <- base::computeRestarts
[18:05:02.795]                           grepl <- base::grepl
[18:05:02.795]                           restarts <- computeRestarts(cond)
[18:05:02.795]                           for (restart in restarts) {
[18:05:02.795]                             name <- restart$name
[18:05:02.795]                             if (is.null(name)) 
[18:05:02.795]                               next
[18:05:02.795]                             if (!grepl(pattern, name)) 
[18:05:02.795]                               next
[18:05:02.795]                             invokeRestart(restart)
[18:05:02.795]                             muffled <- TRUE
[18:05:02.795]                             break
[18:05:02.795]                           }
[18:05:02.795]                         }
[18:05:02.795]                       }
[18:05:02.795]                       invisible(muffled)
[18:05:02.795]                     }
[18:05:02.795]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.795]                   }
[18:05:02.795]                 }
[18:05:02.795]             }
[18:05:02.795]         }))
[18:05:02.795]     }, error = function(ex) {
[18:05:02.795]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.795]                 ...future.rng), started = ...future.startTime, 
[18:05:02.795]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.795]             version = "1.8"), class = "FutureResult")
[18:05:02.795]     }, finally = {
[18:05:02.795]         if (!identical(...future.workdir, getwd())) 
[18:05:02.795]             setwd(...future.workdir)
[18:05:02.795]         {
[18:05:02.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.795]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.795]             }
[18:05:02.795]             base::options(...future.oldOptions)
[18:05:02.795]             if (.Platform$OS.type == "windows") {
[18:05:02.795]                 old_names <- names(...future.oldEnvVars)
[18:05:02.795]                 envs <- base::Sys.getenv()
[18:05:02.795]                 names <- names(envs)
[18:05:02.795]                 common <- intersect(names, old_names)
[18:05:02.795]                 added <- setdiff(names, old_names)
[18:05:02.795]                 removed <- setdiff(old_names, names)
[18:05:02.795]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.795]                   envs[common]]
[18:05:02.795]                 NAMES <- toupper(changed)
[18:05:02.795]                 args <- list()
[18:05:02.795]                 for (kk in seq_along(NAMES)) {
[18:05:02.795]                   name <- changed[[kk]]
[18:05:02.795]                   NAME <- NAMES[[kk]]
[18:05:02.795]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.795]                     next
[18:05:02.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.795]                 }
[18:05:02.795]                 NAMES <- toupper(added)
[18:05:02.795]                 for (kk in seq_along(NAMES)) {
[18:05:02.795]                   name <- added[[kk]]
[18:05:02.795]                   NAME <- NAMES[[kk]]
[18:05:02.795]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.795]                     next
[18:05:02.795]                   args[[name]] <- ""
[18:05:02.795]                 }
[18:05:02.795]                 NAMES <- toupper(removed)
[18:05:02.795]                 for (kk in seq_along(NAMES)) {
[18:05:02.795]                   name <- removed[[kk]]
[18:05:02.795]                   NAME <- NAMES[[kk]]
[18:05:02.795]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.795]                     next
[18:05:02.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.795]                 }
[18:05:02.795]                 if (length(args) > 0) 
[18:05:02.795]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.795]             }
[18:05:02.795]             else {
[18:05:02.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.795]             }
[18:05:02.795]             {
[18:05:02.795]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.795]                   0L) {
[18:05:02.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.795]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.795]                   base::options(opts)
[18:05:02.795]                 }
[18:05:02.795]                 {
[18:05:02.795]                   {
[18:05:02.795]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.795]                     NULL
[18:05:02.795]                   }
[18:05:02.795]                   options(future.plan = NULL)
[18:05:02.795]                   if (is.na(NA_character_)) 
[18:05:02.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.795]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.795]                     .init = FALSE)
[18:05:02.795]                 }
[18:05:02.795]             }
[18:05:02.795]         }
[18:05:02.795]     })
[18:05:02.795]     if (TRUE) {
[18:05:02.795]         base::sink(type = "output", split = FALSE)
[18:05:02.795]         if (TRUE) {
[18:05:02.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.795]         }
[18:05:02.795]         else {
[18:05:02.795]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.795]         }
[18:05:02.795]         base::close(...future.stdout)
[18:05:02.795]         ...future.stdout <- NULL
[18:05:02.795]     }
[18:05:02.795]     ...future.result$conditions <- ...future.conditions
[18:05:02.795]     ...future.result$finished <- base::Sys.time()
[18:05:02.795]     ...future.result
[18:05:02.795] }
[18:05:02.800] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[18:05:02.804] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[18:05:02.863] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[18:05:02.864] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[18:05:02.865] MultisessionFuture started
[18:05:02.865] - Launch lazy future ... done
[18:05:02.865] run() for ‘MultisessionFuture’ ... done
[18:05:02.866] result() for ClusterFuture ...
[18:05:02.866] receiveMessageFromWorker() for ClusterFuture ...
[18:05:02.866] - Validating connection of MultisessionFuture
[18:05:02.919] - received message: FutureResult
[18:05:02.919] - Received FutureResult
[18:05:02.920] - Erased future from FutureRegistry
[18:05:02.920] result() for ClusterFuture ...
[18:05:02.920] - result already collected: FutureResult
[18:05:02.920] result() for ClusterFuture ... done
[18:05:02.921] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:02.921] result() for ClusterFuture ... done
[18:05:02.921] result() for ClusterFuture ...
[18:05:02.921] - result already collected: FutureResult
[18:05:02.921] result() for ClusterFuture ... done
value(b) = 2
[18:05:02.922] result() for ClusterFuture ...
[18:05:02.922] - result already collected: FutureResult
[18:05:02.922] result() for ClusterFuture ... done
[18:05:02.923] result() for ClusterFuture ...
[18:05:02.923] - result already collected: FutureResult
[18:05:02.923] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.924] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.924] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.925] 
[18:05:02.925] Searching for globals ... DONE
[18:05:02.925] - globals: [0] <none>
[18:05:02.926] getGlobalsAndPackages() ... DONE
[18:05:02.926] run() for ‘Future’ ...
[18:05:02.926] - state: ‘created’
[18:05:02.927] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:02.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:02.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:02.955]   - Field: ‘node’
[18:05:02.956]   - Field: ‘label’
[18:05:02.956]   - Field: ‘local’
[18:05:02.956]   - Field: ‘owner’
[18:05:02.956]   - Field: ‘envir’
[18:05:02.957]   - Field: ‘workers’
[18:05:02.957]   - Field: ‘packages’
[18:05:02.957]   - Field: ‘gc’
[18:05:02.957]   - Field: ‘conditions’
[18:05:02.957]   - Field: ‘persistent’
[18:05:02.958]   - Field: ‘expr’
[18:05:02.958]   - Field: ‘uuid’
[18:05:02.958]   - Field: ‘seed’
[18:05:02.958]   - Field: ‘version’
[18:05:02.959]   - Field: ‘result’
[18:05:02.959]   - Field: ‘asynchronous’
[18:05:02.959]   - Field: ‘calls’
[18:05:02.959]   - Field: ‘globals’
[18:05:02.959]   - Field: ‘stdout’
[18:05:02.960]   - Field: ‘earlySignal’
[18:05:02.960]   - Field: ‘lazy’
[18:05:02.960]   - Field: ‘state’
[18:05:02.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:02.961] - Launch lazy future ...
[18:05:02.961] Packages needed by the future expression (n = 0): <none>
[18:05:02.961] Packages needed by future strategies (n = 0): <none>
[18:05:02.962] {
[18:05:02.962]     {
[18:05:02.962]         {
[18:05:02.962]             ...future.startTime <- base::Sys.time()
[18:05:02.962]             {
[18:05:02.962]                 {
[18:05:02.962]                   {
[18:05:02.962]                     {
[18:05:02.962]                       base::local({
[18:05:02.962]                         has_future <- base::requireNamespace("future", 
[18:05:02.962]                           quietly = TRUE)
[18:05:02.962]                         if (has_future) {
[18:05:02.962]                           ns <- base::getNamespace("future")
[18:05:02.962]                           version <- ns[[".package"]][["version"]]
[18:05:02.962]                           if (is.null(version)) 
[18:05:02.962]                             version <- utils::packageVersion("future")
[18:05:02.962]                         }
[18:05:02.962]                         else {
[18:05:02.962]                           version <- NULL
[18:05:02.962]                         }
[18:05:02.962]                         if (!has_future || version < "1.8.0") {
[18:05:02.962]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:02.962]                             "", base::R.version$version.string), 
[18:05:02.962]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:02.962]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:02.962]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:02.962]                               "release", "version")], collapse = " "), 
[18:05:02.962]                             hostname = base::Sys.info()[["nodename"]])
[18:05:02.962]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:02.962]                             info)
[18:05:02.962]                           info <- base::paste(info, collapse = "; ")
[18:05:02.962]                           if (!has_future) {
[18:05:02.962]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:02.962]                               info)
[18:05:02.962]                           }
[18:05:02.962]                           else {
[18:05:02.962]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:02.962]                               info, version)
[18:05:02.962]                           }
[18:05:02.962]                           base::stop(msg)
[18:05:02.962]                         }
[18:05:02.962]                       })
[18:05:02.962]                     }
[18:05:02.962]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:02.962]                     base::options(mc.cores = 1L)
[18:05:02.962]                   }
[18:05:02.962]                   ...future.strategy.old <- future::plan("list")
[18:05:02.962]                   options(future.plan = NULL)
[18:05:02.962]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.962]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:02.962]                 }
[18:05:02.962]                 ...future.workdir <- getwd()
[18:05:02.962]             }
[18:05:02.962]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:02.962]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:02.962]         }
[18:05:02.962]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:02.962]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:02.962]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:02.962]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:02.962]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:02.962]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:02.962]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:02.962]             base::names(...future.oldOptions))
[18:05:02.962]     }
[18:05:02.962]     if (FALSE) {
[18:05:02.962]     }
[18:05:02.962]     else {
[18:05:02.962]         if (TRUE) {
[18:05:02.962]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:02.962]                 open = "w")
[18:05:02.962]         }
[18:05:02.962]         else {
[18:05:02.962]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:02.962]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:02.962]         }
[18:05:02.962]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:02.962]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:02.962]             base::sink(type = "output", split = FALSE)
[18:05:02.962]             base::close(...future.stdout)
[18:05:02.962]         }, add = TRUE)
[18:05:02.962]     }
[18:05:02.962]     ...future.frame <- base::sys.nframe()
[18:05:02.962]     ...future.conditions <- base::list()
[18:05:02.962]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:02.962]     if (FALSE) {
[18:05:02.962]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:02.962]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:02.962]     }
[18:05:02.962]     ...future.result <- base::tryCatch({
[18:05:02.962]         base::withCallingHandlers({
[18:05:02.962]             ...future.value <- base::withVisible(base::local({
[18:05:02.962]                 ...future.makeSendCondition <- base::local({
[18:05:02.962]                   sendCondition <- NULL
[18:05:02.962]                   function(frame = 1L) {
[18:05:02.962]                     if (is.function(sendCondition)) 
[18:05:02.962]                       return(sendCondition)
[18:05:02.962]                     ns <- getNamespace("parallel")
[18:05:02.962]                     if (exists("sendData", mode = "function", 
[18:05:02.962]                       envir = ns)) {
[18:05:02.962]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:02.962]                         envir = ns)
[18:05:02.962]                       envir <- sys.frame(frame)
[18:05:02.962]                       master <- NULL
[18:05:02.962]                       while (!identical(envir, .GlobalEnv) && 
[18:05:02.962]                         !identical(envir, emptyenv())) {
[18:05:02.962]                         if (exists("master", mode = "list", envir = envir, 
[18:05:02.962]                           inherits = FALSE)) {
[18:05:02.962]                           master <- get("master", mode = "list", 
[18:05:02.962]                             envir = envir, inherits = FALSE)
[18:05:02.962]                           if (inherits(master, c("SOCKnode", 
[18:05:02.962]                             "SOCK0node"))) {
[18:05:02.962]                             sendCondition <<- function(cond) {
[18:05:02.962]                               data <- list(type = "VALUE", value = cond, 
[18:05:02.962]                                 success = TRUE)
[18:05:02.962]                               parallel_sendData(master, data)
[18:05:02.962]                             }
[18:05:02.962]                             return(sendCondition)
[18:05:02.962]                           }
[18:05:02.962]                         }
[18:05:02.962]                         frame <- frame + 1L
[18:05:02.962]                         envir <- sys.frame(frame)
[18:05:02.962]                       }
[18:05:02.962]                     }
[18:05:02.962]                     sendCondition <<- function(cond) NULL
[18:05:02.962]                   }
[18:05:02.962]                 })
[18:05:02.962]                 withCallingHandlers({
[18:05:02.962]                   1
[18:05:02.962]                 }, immediateCondition = function(cond) {
[18:05:02.962]                   sendCondition <- ...future.makeSendCondition()
[18:05:02.962]                   sendCondition(cond)
[18:05:02.962]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.962]                   {
[18:05:02.962]                     inherits <- base::inherits
[18:05:02.962]                     invokeRestart <- base::invokeRestart
[18:05:02.962]                     is.null <- base::is.null
[18:05:02.962]                     muffled <- FALSE
[18:05:02.962]                     if (inherits(cond, "message")) {
[18:05:02.962]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:02.962]                       if (muffled) 
[18:05:02.962]                         invokeRestart("muffleMessage")
[18:05:02.962]                     }
[18:05:02.962]                     else if (inherits(cond, "warning")) {
[18:05:02.962]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:02.962]                       if (muffled) 
[18:05:02.962]                         invokeRestart("muffleWarning")
[18:05:02.962]                     }
[18:05:02.962]                     else if (inherits(cond, "condition")) {
[18:05:02.962]                       if (!is.null(pattern)) {
[18:05:02.962]                         computeRestarts <- base::computeRestarts
[18:05:02.962]                         grepl <- base::grepl
[18:05:02.962]                         restarts <- computeRestarts(cond)
[18:05:02.962]                         for (restart in restarts) {
[18:05:02.962]                           name <- restart$name
[18:05:02.962]                           if (is.null(name)) 
[18:05:02.962]                             next
[18:05:02.962]                           if (!grepl(pattern, name)) 
[18:05:02.962]                             next
[18:05:02.962]                           invokeRestart(restart)
[18:05:02.962]                           muffled <- TRUE
[18:05:02.962]                           break
[18:05:02.962]                         }
[18:05:02.962]                       }
[18:05:02.962]                     }
[18:05:02.962]                     invisible(muffled)
[18:05:02.962]                   }
[18:05:02.962]                   muffleCondition(cond)
[18:05:02.962]                 })
[18:05:02.962]             }))
[18:05:02.962]             future::FutureResult(value = ...future.value$value, 
[18:05:02.962]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.962]                   ...future.rng), globalenv = if (FALSE) 
[18:05:02.962]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:02.962]                     ...future.globalenv.names))
[18:05:02.962]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:02.962]         }, condition = base::local({
[18:05:02.962]             c <- base::c
[18:05:02.962]             inherits <- base::inherits
[18:05:02.962]             invokeRestart <- base::invokeRestart
[18:05:02.962]             length <- base::length
[18:05:02.962]             list <- base::list
[18:05:02.962]             seq.int <- base::seq.int
[18:05:02.962]             signalCondition <- base::signalCondition
[18:05:02.962]             sys.calls <- base::sys.calls
[18:05:02.962]             `[[` <- base::`[[`
[18:05:02.962]             `+` <- base::`+`
[18:05:02.962]             `<<-` <- base::`<<-`
[18:05:02.962]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:02.962]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:02.962]                   3L)]
[18:05:02.962]             }
[18:05:02.962]             function(cond) {
[18:05:02.962]                 is_error <- inherits(cond, "error")
[18:05:02.962]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:02.962]                   NULL)
[18:05:02.962]                 if (is_error) {
[18:05:02.962]                   sessionInformation <- function() {
[18:05:02.962]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:02.962]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:02.962]                       search = base::search(), system = base::Sys.info())
[18:05:02.962]                   }
[18:05:02.962]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.962]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:02.962]                     cond$call), session = sessionInformation(), 
[18:05:02.962]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:02.962]                   signalCondition(cond)
[18:05:02.962]                 }
[18:05:02.962]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:02.962]                 "immediateCondition"))) {
[18:05:02.962]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:02.962]                   ...future.conditions[[length(...future.conditions) + 
[18:05:02.962]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:02.962]                   if (TRUE && !signal) {
[18:05:02.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.962]                     {
[18:05:02.962]                       inherits <- base::inherits
[18:05:02.962]                       invokeRestart <- base::invokeRestart
[18:05:02.962]                       is.null <- base::is.null
[18:05:02.962]                       muffled <- FALSE
[18:05:02.962]                       if (inherits(cond, "message")) {
[18:05:02.962]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.962]                         if (muffled) 
[18:05:02.962]                           invokeRestart("muffleMessage")
[18:05:02.962]                       }
[18:05:02.962]                       else if (inherits(cond, "warning")) {
[18:05:02.962]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.962]                         if (muffled) 
[18:05:02.962]                           invokeRestart("muffleWarning")
[18:05:02.962]                       }
[18:05:02.962]                       else if (inherits(cond, "condition")) {
[18:05:02.962]                         if (!is.null(pattern)) {
[18:05:02.962]                           computeRestarts <- base::computeRestarts
[18:05:02.962]                           grepl <- base::grepl
[18:05:02.962]                           restarts <- computeRestarts(cond)
[18:05:02.962]                           for (restart in restarts) {
[18:05:02.962]                             name <- restart$name
[18:05:02.962]                             if (is.null(name)) 
[18:05:02.962]                               next
[18:05:02.962]                             if (!grepl(pattern, name)) 
[18:05:02.962]                               next
[18:05:02.962]                             invokeRestart(restart)
[18:05:02.962]                             muffled <- TRUE
[18:05:02.962]                             break
[18:05:02.962]                           }
[18:05:02.962]                         }
[18:05:02.962]                       }
[18:05:02.962]                       invisible(muffled)
[18:05:02.962]                     }
[18:05:02.962]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.962]                   }
[18:05:02.962]                 }
[18:05:02.962]                 else {
[18:05:02.962]                   if (TRUE) {
[18:05:02.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:02.962]                     {
[18:05:02.962]                       inherits <- base::inherits
[18:05:02.962]                       invokeRestart <- base::invokeRestart
[18:05:02.962]                       is.null <- base::is.null
[18:05:02.962]                       muffled <- FALSE
[18:05:02.962]                       if (inherits(cond, "message")) {
[18:05:02.962]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:02.962]                         if (muffled) 
[18:05:02.962]                           invokeRestart("muffleMessage")
[18:05:02.962]                       }
[18:05:02.962]                       else if (inherits(cond, "warning")) {
[18:05:02.962]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:02.962]                         if (muffled) 
[18:05:02.962]                           invokeRestart("muffleWarning")
[18:05:02.962]                       }
[18:05:02.962]                       else if (inherits(cond, "condition")) {
[18:05:02.962]                         if (!is.null(pattern)) {
[18:05:02.962]                           computeRestarts <- base::computeRestarts
[18:05:02.962]                           grepl <- base::grepl
[18:05:02.962]                           restarts <- computeRestarts(cond)
[18:05:02.962]                           for (restart in restarts) {
[18:05:02.962]                             name <- restart$name
[18:05:02.962]                             if (is.null(name)) 
[18:05:02.962]                               next
[18:05:02.962]                             if (!grepl(pattern, name)) 
[18:05:02.962]                               next
[18:05:02.962]                             invokeRestart(restart)
[18:05:02.962]                             muffled <- TRUE
[18:05:02.962]                             break
[18:05:02.962]                           }
[18:05:02.962]                         }
[18:05:02.962]                       }
[18:05:02.962]                       invisible(muffled)
[18:05:02.962]                     }
[18:05:02.962]                     muffleCondition(cond, pattern = "^muffle")
[18:05:02.962]                   }
[18:05:02.962]                 }
[18:05:02.962]             }
[18:05:02.962]         }))
[18:05:02.962]     }, error = function(ex) {
[18:05:02.962]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:02.962]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:02.962]                 ...future.rng), started = ...future.startTime, 
[18:05:02.962]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:02.962]             version = "1.8"), class = "FutureResult")
[18:05:02.962]     }, finally = {
[18:05:02.962]         if (!identical(...future.workdir, getwd())) 
[18:05:02.962]             setwd(...future.workdir)
[18:05:02.962]         {
[18:05:02.962]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:02.962]                 ...future.oldOptions$nwarnings <- NULL
[18:05:02.962]             }
[18:05:02.962]             base::options(...future.oldOptions)
[18:05:02.962]             if (.Platform$OS.type == "windows") {
[18:05:02.962]                 old_names <- names(...future.oldEnvVars)
[18:05:02.962]                 envs <- base::Sys.getenv()
[18:05:02.962]                 names <- names(envs)
[18:05:02.962]                 common <- intersect(names, old_names)
[18:05:02.962]                 added <- setdiff(names, old_names)
[18:05:02.962]                 removed <- setdiff(old_names, names)
[18:05:02.962]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:02.962]                   envs[common]]
[18:05:02.962]                 NAMES <- toupper(changed)
[18:05:02.962]                 args <- list()
[18:05:02.962]                 for (kk in seq_along(NAMES)) {
[18:05:02.962]                   name <- changed[[kk]]
[18:05:02.962]                   NAME <- NAMES[[kk]]
[18:05:02.962]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.962]                     next
[18:05:02.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.962]                 }
[18:05:02.962]                 NAMES <- toupper(added)
[18:05:02.962]                 for (kk in seq_along(NAMES)) {
[18:05:02.962]                   name <- added[[kk]]
[18:05:02.962]                   NAME <- NAMES[[kk]]
[18:05:02.962]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.962]                     next
[18:05:02.962]                   args[[name]] <- ""
[18:05:02.962]                 }
[18:05:02.962]                 NAMES <- toupper(removed)
[18:05:02.962]                 for (kk in seq_along(NAMES)) {
[18:05:02.962]                   name <- removed[[kk]]
[18:05:02.962]                   NAME <- NAMES[[kk]]
[18:05:02.962]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:02.962]                     next
[18:05:02.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:02.962]                 }
[18:05:02.962]                 if (length(args) > 0) 
[18:05:02.962]                   base::do.call(base::Sys.setenv, args = args)
[18:05:02.962]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:02.962]             }
[18:05:02.962]             else {
[18:05:02.962]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:02.962]             }
[18:05:02.962]             {
[18:05:02.962]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:02.962]                   0L) {
[18:05:02.962]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:02.962]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:02.962]                   base::options(opts)
[18:05:02.962]                 }
[18:05:02.962]                 {
[18:05:02.962]                   {
[18:05:02.962]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:02.962]                     NULL
[18:05:02.962]                   }
[18:05:02.962]                   options(future.plan = NULL)
[18:05:02.962]                   if (is.na(NA_character_)) 
[18:05:02.962]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:02.962]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:02.962]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:02.962]                     .init = FALSE)
[18:05:02.962]                 }
[18:05:02.962]             }
[18:05:02.962]         }
[18:05:02.962]     })
[18:05:02.962]     if (TRUE) {
[18:05:02.962]         base::sink(type = "output", split = FALSE)
[18:05:02.962]         if (TRUE) {
[18:05:02.962]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:02.962]         }
[18:05:02.962]         else {
[18:05:02.962]             ...future.result["stdout"] <- base::list(NULL)
[18:05:02.962]         }
[18:05:02.962]         base::close(...future.stdout)
[18:05:02.962]         ...future.stdout <- NULL
[18:05:02.962]     }
[18:05:02.962]     ...future.result$conditions <- ...future.conditions
[18:05:02.962]     ...future.result$finished <- base::Sys.time()
[18:05:02.962]     ...future.result
[18:05:02.962] }
[18:05:02.969] MultisessionFuture started
[18:05:02.969] - Launch lazy future ... done
[18:05:02.969] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:02.970] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:02.971] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:02.972] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:05:02.973] Searching for globals ... DONE
[18:05:02.973] Resolving globals: TRUE
[18:05:02.973] Resolving any globals that are futures ...
[18:05:02.973] - globals: [3] ‘+’, ‘value’, ‘a’
[18:05:02.973] Resolving any globals that are futures ... DONE
[18:05:02.974] Resolving futures part of globals (recursively) ...
[18:05:02.975] resolve() on list ...
[18:05:02.975]  recursive: 99
[18:05:02.975]  length: 1
[18:05:02.975]  elements: ‘a’
[18:05:03.019] receiveMessageFromWorker() for ClusterFuture ...
[18:05:03.019] - Validating connection of MultisessionFuture
[18:05:03.020] - received message: FutureResult
[18:05:03.020] - Received FutureResult
[18:05:03.020] - Erased future from FutureRegistry
[18:05:03.021] result() for ClusterFuture ...
[18:05:03.021] - result already collected: FutureResult
[18:05:03.021] result() for ClusterFuture ... done
[18:05:03.022] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:03.022] Future #1
[18:05:03.022] result() for ClusterFuture ...
[18:05:03.022] - result already collected: FutureResult
[18:05:03.023] result() for ClusterFuture ... done
[18:05:03.023] result() for ClusterFuture ...
[18:05:03.023] - result already collected: FutureResult
[18:05:03.024] result() for ClusterFuture ... done
[18:05:03.024] A MultisessionFuture was resolved
[18:05:03.024]  length: 0 (resolved future 1)
[18:05:03.025] resolve() on list ... DONE
[18:05:03.025] - globals: [1] ‘a’
[18:05:03.025] Resolving futures part of globals (recursively) ... DONE
[18:05:03.031] The total size of the 1 globals is 1.57 MiB (1649664 bytes)
[18:05:03.032] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[18:05:03.032] - globals: [1] ‘a’
[18:05:03.033] - packages: [1] ‘future’
[18:05:03.033] getGlobalsAndPackages() ... DONE
[18:05:03.034] run() for ‘Future’ ...
[18:05:03.034] - state: ‘created’
[18:05:03.034] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:03.059] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:03.060] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:03.063]   - Field: ‘node’
[18:05:03.063]   - Field: ‘label’
[18:05:03.064]   - Field: ‘local’
[18:05:03.064]   - Field: ‘owner’
[18:05:03.064]   - Field: ‘envir’
[18:05:03.064]   - Field: ‘workers’
[18:05:03.064]   - Field: ‘packages’
[18:05:03.065]   - Field: ‘gc’
[18:05:03.065]   - Field: ‘conditions’
[18:05:03.065]   - Field: ‘persistent’
[18:05:03.065]   - Field: ‘expr’
[18:05:03.065]   - Field: ‘uuid’
[18:05:03.066]   - Field: ‘seed’
[18:05:03.066]   - Field: ‘version’
[18:05:03.066]   - Field: ‘result’
[18:05:03.066]   - Field: ‘asynchronous’
[18:05:03.066]   - Field: ‘calls’
[18:05:03.067]   - Field: ‘globals’
[18:05:03.067]   - Field: ‘stdout’
[18:05:03.067]   - Field: ‘earlySignal’
[18:05:03.067]   - Field: ‘lazy’
[18:05:03.067]   - Field: ‘state’
[18:05:03.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:03.068] - Launch lazy future ...
[18:05:03.068] Packages needed by the future expression (n = 1): ‘future’
[18:05:03.068] Packages needed by future strategies (n = 0): <none>
[18:05:03.069] {
[18:05:03.069]     {
[18:05:03.069]         {
[18:05:03.069]             ...future.startTime <- base::Sys.time()
[18:05:03.069]             {
[18:05:03.069]                 {
[18:05:03.069]                   {
[18:05:03.069]                     {
[18:05:03.069]                       {
[18:05:03.069]                         base::local({
[18:05:03.069]                           has_future <- base::requireNamespace("future", 
[18:05:03.069]                             quietly = TRUE)
[18:05:03.069]                           if (has_future) {
[18:05:03.069]                             ns <- base::getNamespace("future")
[18:05:03.069]                             version <- ns[[".package"]][["version"]]
[18:05:03.069]                             if (is.null(version)) 
[18:05:03.069]                               version <- utils::packageVersion("future")
[18:05:03.069]                           }
[18:05:03.069]                           else {
[18:05:03.069]                             version <- NULL
[18:05:03.069]                           }
[18:05:03.069]                           if (!has_future || version < "1.8.0") {
[18:05:03.069]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:03.069]                               "", base::R.version$version.string), 
[18:05:03.069]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:03.069]                                 base::R.version$platform, 8 * 
[18:05:03.069]                                   base::.Machine$sizeof.pointer), 
[18:05:03.069]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:03.069]                                 "release", "version")], collapse = " "), 
[18:05:03.069]                               hostname = base::Sys.info()[["nodename"]])
[18:05:03.069]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:03.069]                               info)
[18:05:03.069]                             info <- base::paste(info, collapse = "; ")
[18:05:03.069]                             if (!has_future) {
[18:05:03.069]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:03.069]                                 info)
[18:05:03.069]                             }
[18:05:03.069]                             else {
[18:05:03.069]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:03.069]                                 info, version)
[18:05:03.069]                             }
[18:05:03.069]                             base::stop(msg)
[18:05:03.069]                           }
[18:05:03.069]                         })
[18:05:03.069]                       }
[18:05:03.069]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:03.069]                       base::options(mc.cores = 1L)
[18:05:03.069]                     }
[18:05:03.069]                     base::local({
[18:05:03.069]                       for (pkg in "future") {
[18:05:03.069]                         base::loadNamespace(pkg)
[18:05:03.069]                         base::library(pkg, character.only = TRUE)
[18:05:03.069]                       }
[18:05:03.069]                     })
[18:05:03.069]                   }
[18:05:03.069]                   ...future.strategy.old <- future::plan("list")
[18:05:03.069]                   options(future.plan = NULL)
[18:05:03.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:03.069]                 }
[18:05:03.069]                 ...future.workdir <- getwd()
[18:05:03.069]             }
[18:05:03.069]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:03.069]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:03.069]         }
[18:05:03.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:03.069]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:03.069]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:03.069]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:03.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:03.069]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:03.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:03.069]             base::names(...future.oldOptions))
[18:05:03.069]     }
[18:05:03.069]     if (FALSE) {
[18:05:03.069]     }
[18:05:03.069]     else {
[18:05:03.069]         if (TRUE) {
[18:05:03.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:03.069]                 open = "w")
[18:05:03.069]         }
[18:05:03.069]         else {
[18:05:03.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:03.069]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:03.069]         }
[18:05:03.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:03.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:03.069]             base::sink(type = "output", split = FALSE)
[18:05:03.069]             base::close(...future.stdout)
[18:05:03.069]         }, add = TRUE)
[18:05:03.069]     }
[18:05:03.069]     ...future.frame <- base::sys.nframe()
[18:05:03.069]     ...future.conditions <- base::list()
[18:05:03.069]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:03.069]     if (FALSE) {
[18:05:03.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:03.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:03.069]     }
[18:05:03.069]     ...future.result <- base::tryCatch({
[18:05:03.069]         base::withCallingHandlers({
[18:05:03.069]             ...future.value <- base::withVisible(base::local({
[18:05:03.069]                 ...future.makeSendCondition <- base::local({
[18:05:03.069]                   sendCondition <- NULL
[18:05:03.069]                   function(frame = 1L) {
[18:05:03.069]                     if (is.function(sendCondition)) 
[18:05:03.069]                       return(sendCondition)
[18:05:03.069]                     ns <- getNamespace("parallel")
[18:05:03.069]                     if (exists("sendData", mode = "function", 
[18:05:03.069]                       envir = ns)) {
[18:05:03.069]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:03.069]                         envir = ns)
[18:05:03.069]                       envir <- sys.frame(frame)
[18:05:03.069]                       master <- NULL
[18:05:03.069]                       while (!identical(envir, .GlobalEnv) && 
[18:05:03.069]                         !identical(envir, emptyenv())) {
[18:05:03.069]                         if (exists("master", mode = "list", envir = envir, 
[18:05:03.069]                           inherits = FALSE)) {
[18:05:03.069]                           master <- get("master", mode = "list", 
[18:05:03.069]                             envir = envir, inherits = FALSE)
[18:05:03.069]                           if (inherits(master, c("SOCKnode", 
[18:05:03.069]                             "SOCK0node"))) {
[18:05:03.069]                             sendCondition <<- function(cond) {
[18:05:03.069]                               data <- list(type = "VALUE", value = cond, 
[18:05:03.069]                                 success = TRUE)
[18:05:03.069]                               parallel_sendData(master, data)
[18:05:03.069]                             }
[18:05:03.069]                             return(sendCondition)
[18:05:03.069]                           }
[18:05:03.069]                         }
[18:05:03.069]                         frame <- frame + 1L
[18:05:03.069]                         envir <- sys.frame(frame)
[18:05:03.069]                       }
[18:05:03.069]                     }
[18:05:03.069]                     sendCondition <<- function(cond) NULL
[18:05:03.069]                   }
[18:05:03.069]                 })
[18:05:03.069]                 withCallingHandlers({
[18:05:03.069]                   value(a) + 1
[18:05:03.069]                 }, immediateCondition = function(cond) {
[18:05:03.069]                   sendCondition <- ...future.makeSendCondition()
[18:05:03.069]                   sendCondition(cond)
[18:05:03.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.069]                   {
[18:05:03.069]                     inherits <- base::inherits
[18:05:03.069]                     invokeRestart <- base::invokeRestart
[18:05:03.069]                     is.null <- base::is.null
[18:05:03.069]                     muffled <- FALSE
[18:05:03.069]                     if (inherits(cond, "message")) {
[18:05:03.069]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:03.069]                       if (muffled) 
[18:05:03.069]                         invokeRestart("muffleMessage")
[18:05:03.069]                     }
[18:05:03.069]                     else if (inherits(cond, "warning")) {
[18:05:03.069]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:03.069]                       if (muffled) 
[18:05:03.069]                         invokeRestart("muffleWarning")
[18:05:03.069]                     }
[18:05:03.069]                     else if (inherits(cond, "condition")) {
[18:05:03.069]                       if (!is.null(pattern)) {
[18:05:03.069]                         computeRestarts <- base::computeRestarts
[18:05:03.069]                         grepl <- base::grepl
[18:05:03.069]                         restarts <- computeRestarts(cond)
[18:05:03.069]                         for (restart in restarts) {
[18:05:03.069]                           name <- restart$name
[18:05:03.069]                           if (is.null(name)) 
[18:05:03.069]                             next
[18:05:03.069]                           if (!grepl(pattern, name)) 
[18:05:03.069]                             next
[18:05:03.069]                           invokeRestart(restart)
[18:05:03.069]                           muffled <- TRUE
[18:05:03.069]                           break
[18:05:03.069]                         }
[18:05:03.069]                       }
[18:05:03.069]                     }
[18:05:03.069]                     invisible(muffled)
[18:05:03.069]                   }
[18:05:03.069]                   muffleCondition(cond)
[18:05:03.069]                 })
[18:05:03.069]             }))
[18:05:03.069]             future::FutureResult(value = ...future.value$value, 
[18:05:03.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.069]                   ...future.rng), globalenv = if (FALSE) 
[18:05:03.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:03.069]                     ...future.globalenv.names))
[18:05:03.069]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:03.069]         }, condition = base::local({
[18:05:03.069]             c <- base::c
[18:05:03.069]             inherits <- base::inherits
[18:05:03.069]             invokeRestart <- base::invokeRestart
[18:05:03.069]             length <- base::length
[18:05:03.069]             list <- base::list
[18:05:03.069]             seq.int <- base::seq.int
[18:05:03.069]             signalCondition <- base::signalCondition
[18:05:03.069]             sys.calls <- base::sys.calls
[18:05:03.069]             `[[` <- base::`[[`
[18:05:03.069]             `+` <- base::`+`
[18:05:03.069]             `<<-` <- base::`<<-`
[18:05:03.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:03.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:03.069]                   3L)]
[18:05:03.069]             }
[18:05:03.069]             function(cond) {
[18:05:03.069]                 is_error <- inherits(cond, "error")
[18:05:03.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:03.069]                   NULL)
[18:05:03.069]                 if (is_error) {
[18:05:03.069]                   sessionInformation <- function() {
[18:05:03.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:03.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:03.069]                       search = base::search(), system = base::Sys.info())
[18:05:03.069]                   }
[18:05:03.069]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:03.069]                     cond$call), session = sessionInformation(), 
[18:05:03.069]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:03.069]                   signalCondition(cond)
[18:05:03.069]                 }
[18:05:03.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:03.069]                 "immediateCondition"))) {
[18:05:03.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:03.069]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:03.069]                   if (TRUE && !signal) {
[18:05:03.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.069]                     {
[18:05:03.069]                       inherits <- base::inherits
[18:05:03.069]                       invokeRestart <- base::invokeRestart
[18:05:03.069]                       is.null <- base::is.null
[18:05:03.069]                       muffled <- FALSE
[18:05:03.069]                       if (inherits(cond, "message")) {
[18:05:03.069]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.069]                         if (muffled) 
[18:05:03.069]                           invokeRestart("muffleMessage")
[18:05:03.069]                       }
[18:05:03.069]                       else if (inherits(cond, "warning")) {
[18:05:03.069]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.069]                         if (muffled) 
[18:05:03.069]                           invokeRestart("muffleWarning")
[18:05:03.069]                       }
[18:05:03.069]                       else if (inherits(cond, "condition")) {
[18:05:03.069]                         if (!is.null(pattern)) {
[18:05:03.069]                           computeRestarts <- base::computeRestarts
[18:05:03.069]                           grepl <- base::grepl
[18:05:03.069]                           restarts <- computeRestarts(cond)
[18:05:03.069]                           for (restart in restarts) {
[18:05:03.069]                             name <- restart$name
[18:05:03.069]                             if (is.null(name)) 
[18:05:03.069]                               next
[18:05:03.069]                             if (!grepl(pattern, name)) 
[18:05:03.069]                               next
[18:05:03.069]                             invokeRestart(restart)
[18:05:03.069]                             muffled <- TRUE
[18:05:03.069]                             break
[18:05:03.069]                           }
[18:05:03.069]                         }
[18:05:03.069]                       }
[18:05:03.069]                       invisible(muffled)
[18:05:03.069]                     }
[18:05:03.069]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.069]                   }
[18:05:03.069]                 }
[18:05:03.069]                 else {
[18:05:03.069]                   if (TRUE) {
[18:05:03.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.069]                     {
[18:05:03.069]                       inherits <- base::inherits
[18:05:03.069]                       invokeRestart <- base::invokeRestart
[18:05:03.069]                       is.null <- base::is.null
[18:05:03.069]                       muffled <- FALSE
[18:05:03.069]                       if (inherits(cond, "message")) {
[18:05:03.069]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.069]                         if (muffled) 
[18:05:03.069]                           invokeRestart("muffleMessage")
[18:05:03.069]                       }
[18:05:03.069]                       else if (inherits(cond, "warning")) {
[18:05:03.069]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.069]                         if (muffled) 
[18:05:03.069]                           invokeRestart("muffleWarning")
[18:05:03.069]                       }
[18:05:03.069]                       else if (inherits(cond, "condition")) {
[18:05:03.069]                         if (!is.null(pattern)) {
[18:05:03.069]                           computeRestarts <- base::computeRestarts
[18:05:03.069]                           grepl <- base::grepl
[18:05:03.069]                           restarts <- computeRestarts(cond)
[18:05:03.069]                           for (restart in restarts) {
[18:05:03.069]                             name <- restart$name
[18:05:03.069]                             if (is.null(name)) 
[18:05:03.069]                               next
[18:05:03.069]                             if (!grepl(pattern, name)) 
[18:05:03.069]                               next
[18:05:03.069]                             invokeRestart(restart)
[18:05:03.069]                             muffled <- TRUE
[18:05:03.069]                             break
[18:05:03.069]                           }
[18:05:03.069]                         }
[18:05:03.069]                       }
[18:05:03.069]                       invisible(muffled)
[18:05:03.069]                     }
[18:05:03.069]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.069]                   }
[18:05:03.069]                 }
[18:05:03.069]             }
[18:05:03.069]         }))
[18:05:03.069]     }, error = function(ex) {
[18:05:03.069]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:03.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.069]                 ...future.rng), started = ...future.startTime, 
[18:05:03.069]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:03.069]             version = "1.8"), class = "FutureResult")
[18:05:03.069]     }, finally = {
[18:05:03.069]         if (!identical(...future.workdir, getwd())) 
[18:05:03.069]             setwd(...future.workdir)
[18:05:03.069]         {
[18:05:03.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:03.069]                 ...future.oldOptions$nwarnings <- NULL
[18:05:03.069]             }
[18:05:03.069]             base::options(...future.oldOptions)
[18:05:03.069]             if (.Platform$OS.type == "windows") {
[18:05:03.069]                 old_names <- names(...future.oldEnvVars)
[18:05:03.069]                 envs <- base::Sys.getenv()
[18:05:03.069]                 names <- names(envs)
[18:05:03.069]                 common <- intersect(names, old_names)
[18:05:03.069]                 added <- setdiff(names, old_names)
[18:05:03.069]                 removed <- setdiff(old_names, names)
[18:05:03.069]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:03.069]                   envs[common]]
[18:05:03.069]                 NAMES <- toupper(changed)
[18:05:03.069]                 args <- list()
[18:05:03.069]                 for (kk in seq_along(NAMES)) {
[18:05:03.069]                   name <- changed[[kk]]
[18:05:03.069]                   NAME <- NAMES[[kk]]
[18:05:03.069]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.069]                     next
[18:05:03.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.069]                 }
[18:05:03.069]                 NAMES <- toupper(added)
[18:05:03.069]                 for (kk in seq_along(NAMES)) {
[18:05:03.069]                   name <- added[[kk]]
[18:05:03.069]                   NAME <- NAMES[[kk]]
[18:05:03.069]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.069]                     next
[18:05:03.069]                   args[[name]] <- ""
[18:05:03.069]                 }
[18:05:03.069]                 NAMES <- toupper(removed)
[18:05:03.069]                 for (kk in seq_along(NAMES)) {
[18:05:03.069]                   name <- removed[[kk]]
[18:05:03.069]                   NAME <- NAMES[[kk]]
[18:05:03.069]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.069]                     next
[18:05:03.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.069]                 }
[18:05:03.069]                 if (length(args) > 0) 
[18:05:03.069]                   base::do.call(base::Sys.setenv, args = args)
[18:05:03.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:03.069]             }
[18:05:03.069]             else {
[18:05:03.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:03.069]             }
[18:05:03.069]             {
[18:05:03.069]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:03.069]                   0L) {
[18:05:03.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:03.069]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:03.069]                   base::options(opts)
[18:05:03.069]                 }
[18:05:03.069]                 {
[18:05:03.069]                   {
[18:05:03.069]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:03.069]                     NULL
[18:05:03.069]                   }
[18:05:03.069]                   options(future.plan = NULL)
[18:05:03.069]                   if (is.na(NA_character_)) 
[18:05:03.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:03.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:03.069]                     .init = FALSE)
[18:05:03.069]                 }
[18:05:03.069]             }
[18:05:03.069]         }
[18:05:03.069]     })
[18:05:03.069]     if (TRUE) {
[18:05:03.069]         base::sink(type = "output", split = FALSE)
[18:05:03.069]         if (TRUE) {
[18:05:03.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:03.069]         }
[18:05:03.069]         else {
[18:05:03.069]             ...future.result["stdout"] <- base::list(NULL)
[18:05:03.069]         }
[18:05:03.069]         base::close(...future.stdout)
[18:05:03.069]         ...future.stdout <- NULL
[18:05:03.069]     }
[18:05:03.069]     ...future.result$conditions <- ...future.conditions
[18:05:03.069]     ...future.result$finished <- base::Sys.time()
[18:05:03.069]     ...future.result
[18:05:03.069] }
[18:05:03.074] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[18:05:03.079] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[18:05:03.136] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[18:05:03.137] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[18:05:03.138] MultisessionFuture started
[18:05:03.138] - Launch lazy future ... done
[18:05:03.138] run() for ‘MultisessionFuture’ ... done
[18:05:03.138] result() for ClusterFuture ...
[18:05:03.139] receiveMessageFromWorker() for ClusterFuture ...
[18:05:03.139] - Validating connection of MultisessionFuture
[18:05:03.183] - received message: FutureResult
[18:05:03.183] - Received FutureResult
[18:05:03.184] - Erased future from FutureRegistry
[18:05:03.184] result() for ClusterFuture ...
[18:05:03.184] - result already collected: FutureResult
[18:05:03.184] result() for ClusterFuture ... done
[18:05:03.184] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:03.185] result() for ClusterFuture ... done
[18:05:03.185] result() for ClusterFuture ...
[18:05:03.185] - result already collected: FutureResult
[18:05:03.185] result() for ClusterFuture ... done
value(b) = 2
[18:05:03.186] result() for ClusterFuture ...
[18:05:03.186] - result already collected: FutureResult
[18:05:03.186] result() for ClusterFuture ... done
[18:05:03.186] result() for ClusterFuture ...
[18:05:03.186] - result already collected: FutureResult
[18:05:03.187] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:03.187] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:03.188] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:03.189] 
[18:05:03.189] Searching for globals ... DONE
[18:05:03.189] - globals: [0] <none>
[18:05:03.189] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:03.190] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:03.191] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:03.192] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:05:03.193] Searching for globals ... DONE
[18:05:03.193] Resolving globals: TRUE
[18:05:03.193] Resolving any globals that are futures ...
[18:05:03.194] - globals: [3] ‘+’, ‘value’, ‘a’
[18:05:03.194] Resolving any globals that are futures ... DONE
[18:05:03.195] Resolving futures part of globals (recursively) ...
[18:05:03.195] resolve() on list ...
[18:05:03.195]  recursive: 99
[18:05:03.196]  length: 1
[18:05:03.196]  elements: ‘a’
[18:05:03.196] run() for ‘Future’ ...
[18:05:03.196] - state: ‘created’
[18:05:03.197] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:03.220] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:03.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:03.221]   - Field: ‘node’
[18:05:03.221]   - Field: ‘label’
[18:05:03.221]   - Field: ‘local’
[18:05:03.221]   - Field: ‘owner’
[18:05:03.221]   - Field: ‘envir’
[18:05:03.222]   - Field: ‘workers’
[18:05:03.222]   - Field: ‘packages’
[18:05:03.222]   - Field: ‘gc’
[18:05:03.222]   - Field: ‘conditions’
[18:05:03.222]   - Field: ‘persistent’
[18:05:03.223]   - Field: ‘expr’
[18:05:03.223]   - Field: ‘uuid’
[18:05:03.223]   - Field: ‘seed’
[18:05:03.223]   - Field: ‘version’
[18:05:03.223]   - Field: ‘result’
[18:05:03.224]   - Field: ‘asynchronous’
[18:05:03.224]   - Field: ‘calls’
[18:05:03.224]   - Field: ‘globals’
[18:05:03.224]   - Field: ‘stdout’
[18:05:03.224]   - Field: ‘earlySignal’
[18:05:03.225]   - Field: ‘lazy’
[18:05:03.225]   - Field: ‘state’
[18:05:03.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:03.225] - Launch lazy future ...
[18:05:03.226] Packages needed by the future expression (n = 0): <none>
[18:05:03.226] Packages needed by future strategies (n = 0): <none>
[18:05:03.227] {
[18:05:03.227]     {
[18:05:03.227]         {
[18:05:03.227]             ...future.startTime <- base::Sys.time()
[18:05:03.227]             {
[18:05:03.227]                 {
[18:05:03.227]                   {
[18:05:03.227]                     {
[18:05:03.227]                       base::local({
[18:05:03.227]                         has_future <- base::requireNamespace("future", 
[18:05:03.227]                           quietly = TRUE)
[18:05:03.227]                         if (has_future) {
[18:05:03.227]                           ns <- base::getNamespace("future")
[18:05:03.227]                           version <- ns[[".package"]][["version"]]
[18:05:03.227]                           if (is.null(version)) 
[18:05:03.227]                             version <- utils::packageVersion("future")
[18:05:03.227]                         }
[18:05:03.227]                         else {
[18:05:03.227]                           version <- NULL
[18:05:03.227]                         }
[18:05:03.227]                         if (!has_future || version < "1.8.0") {
[18:05:03.227]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:03.227]                             "", base::R.version$version.string), 
[18:05:03.227]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:03.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:03.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:03.227]                               "release", "version")], collapse = " "), 
[18:05:03.227]                             hostname = base::Sys.info()[["nodename"]])
[18:05:03.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:03.227]                             info)
[18:05:03.227]                           info <- base::paste(info, collapse = "; ")
[18:05:03.227]                           if (!has_future) {
[18:05:03.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:03.227]                               info)
[18:05:03.227]                           }
[18:05:03.227]                           else {
[18:05:03.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:03.227]                               info, version)
[18:05:03.227]                           }
[18:05:03.227]                           base::stop(msg)
[18:05:03.227]                         }
[18:05:03.227]                       })
[18:05:03.227]                     }
[18:05:03.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:03.227]                     base::options(mc.cores = 1L)
[18:05:03.227]                   }
[18:05:03.227]                   ...future.strategy.old <- future::plan("list")
[18:05:03.227]                   options(future.plan = NULL)
[18:05:03.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:03.227]                 }
[18:05:03.227]                 ...future.workdir <- getwd()
[18:05:03.227]             }
[18:05:03.227]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:03.227]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:03.227]         }
[18:05:03.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:03.227]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:03.227]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:03.227]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:03.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:03.227]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:03.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:03.227]             base::names(...future.oldOptions))
[18:05:03.227]     }
[18:05:03.227]     if (FALSE) {
[18:05:03.227]     }
[18:05:03.227]     else {
[18:05:03.227]         if (TRUE) {
[18:05:03.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:03.227]                 open = "w")
[18:05:03.227]         }
[18:05:03.227]         else {
[18:05:03.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:03.227]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:03.227]         }
[18:05:03.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:03.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:03.227]             base::sink(type = "output", split = FALSE)
[18:05:03.227]             base::close(...future.stdout)
[18:05:03.227]         }, add = TRUE)
[18:05:03.227]     }
[18:05:03.227]     ...future.frame <- base::sys.nframe()
[18:05:03.227]     ...future.conditions <- base::list()
[18:05:03.227]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:03.227]     if (FALSE) {
[18:05:03.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:03.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:03.227]     }
[18:05:03.227]     ...future.result <- base::tryCatch({
[18:05:03.227]         base::withCallingHandlers({
[18:05:03.227]             ...future.value <- base::withVisible(base::local({
[18:05:03.227]                 ...future.makeSendCondition <- base::local({
[18:05:03.227]                   sendCondition <- NULL
[18:05:03.227]                   function(frame = 1L) {
[18:05:03.227]                     if (is.function(sendCondition)) 
[18:05:03.227]                       return(sendCondition)
[18:05:03.227]                     ns <- getNamespace("parallel")
[18:05:03.227]                     if (exists("sendData", mode = "function", 
[18:05:03.227]                       envir = ns)) {
[18:05:03.227]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:03.227]                         envir = ns)
[18:05:03.227]                       envir <- sys.frame(frame)
[18:05:03.227]                       master <- NULL
[18:05:03.227]                       while (!identical(envir, .GlobalEnv) && 
[18:05:03.227]                         !identical(envir, emptyenv())) {
[18:05:03.227]                         if (exists("master", mode = "list", envir = envir, 
[18:05:03.227]                           inherits = FALSE)) {
[18:05:03.227]                           master <- get("master", mode = "list", 
[18:05:03.227]                             envir = envir, inherits = FALSE)
[18:05:03.227]                           if (inherits(master, c("SOCKnode", 
[18:05:03.227]                             "SOCK0node"))) {
[18:05:03.227]                             sendCondition <<- function(cond) {
[18:05:03.227]                               data <- list(type = "VALUE", value = cond, 
[18:05:03.227]                                 success = TRUE)
[18:05:03.227]                               parallel_sendData(master, data)
[18:05:03.227]                             }
[18:05:03.227]                             return(sendCondition)
[18:05:03.227]                           }
[18:05:03.227]                         }
[18:05:03.227]                         frame <- frame + 1L
[18:05:03.227]                         envir <- sys.frame(frame)
[18:05:03.227]                       }
[18:05:03.227]                     }
[18:05:03.227]                     sendCondition <<- function(cond) NULL
[18:05:03.227]                   }
[18:05:03.227]                 })
[18:05:03.227]                 withCallingHandlers({
[18:05:03.227]                   1
[18:05:03.227]                 }, immediateCondition = function(cond) {
[18:05:03.227]                   sendCondition <- ...future.makeSendCondition()
[18:05:03.227]                   sendCondition(cond)
[18:05:03.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.227]                   {
[18:05:03.227]                     inherits <- base::inherits
[18:05:03.227]                     invokeRestart <- base::invokeRestart
[18:05:03.227]                     is.null <- base::is.null
[18:05:03.227]                     muffled <- FALSE
[18:05:03.227]                     if (inherits(cond, "message")) {
[18:05:03.227]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:03.227]                       if (muffled) 
[18:05:03.227]                         invokeRestart("muffleMessage")
[18:05:03.227]                     }
[18:05:03.227]                     else if (inherits(cond, "warning")) {
[18:05:03.227]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:03.227]                       if (muffled) 
[18:05:03.227]                         invokeRestart("muffleWarning")
[18:05:03.227]                     }
[18:05:03.227]                     else if (inherits(cond, "condition")) {
[18:05:03.227]                       if (!is.null(pattern)) {
[18:05:03.227]                         computeRestarts <- base::computeRestarts
[18:05:03.227]                         grepl <- base::grepl
[18:05:03.227]                         restarts <- computeRestarts(cond)
[18:05:03.227]                         for (restart in restarts) {
[18:05:03.227]                           name <- restart$name
[18:05:03.227]                           if (is.null(name)) 
[18:05:03.227]                             next
[18:05:03.227]                           if (!grepl(pattern, name)) 
[18:05:03.227]                             next
[18:05:03.227]                           invokeRestart(restart)
[18:05:03.227]                           muffled <- TRUE
[18:05:03.227]                           break
[18:05:03.227]                         }
[18:05:03.227]                       }
[18:05:03.227]                     }
[18:05:03.227]                     invisible(muffled)
[18:05:03.227]                   }
[18:05:03.227]                   muffleCondition(cond)
[18:05:03.227]                 })
[18:05:03.227]             }))
[18:05:03.227]             future::FutureResult(value = ...future.value$value, 
[18:05:03.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.227]                   ...future.rng), globalenv = if (FALSE) 
[18:05:03.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:03.227]                     ...future.globalenv.names))
[18:05:03.227]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:03.227]         }, condition = base::local({
[18:05:03.227]             c <- base::c
[18:05:03.227]             inherits <- base::inherits
[18:05:03.227]             invokeRestart <- base::invokeRestart
[18:05:03.227]             length <- base::length
[18:05:03.227]             list <- base::list
[18:05:03.227]             seq.int <- base::seq.int
[18:05:03.227]             signalCondition <- base::signalCondition
[18:05:03.227]             sys.calls <- base::sys.calls
[18:05:03.227]             `[[` <- base::`[[`
[18:05:03.227]             `+` <- base::`+`
[18:05:03.227]             `<<-` <- base::`<<-`
[18:05:03.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:03.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:03.227]                   3L)]
[18:05:03.227]             }
[18:05:03.227]             function(cond) {
[18:05:03.227]                 is_error <- inherits(cond, "error")
[18:05:03.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:03.227]                   NULL)
[18:05:03.227]                 if (is_error) {
[18:05:03.227]                   sessionInformation <- function() {
[18:05:03.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:03.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:03.227]                       search = base::search(), system = base::Sys.info())
[18:05:03.227]                   }
[18:05:03.227]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:03.227]                     cond$call), session = sessionInformation(), 
[18:05:03.227]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:03.227]                   signalCondition(cond)
[18:05:03.227]                 }
[18:05:03.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:03.227]                 "immediateCondition"))) {
[18:05:03.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:03.227]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:03.227]                   if (TRUE && !signal) {
[18:05:03.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.227]                     {
[18:05:03.227]                       inherits <- base::inherits
[18:05:03.227]                       invokeRestart <- base::invokeRestart
[18:05:03.227]                       is.null <- base::is.null
[18:05:03.227]                       muffled <- FALSE
[18:05:03.227]                       if (inherits(cond, "message")) {
[18:05:03.227]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.227]                         if (muffled) 
[18:05:03.227]                           invokeRestart("muffleMessage")
[18:05:03.227]                       }
[18:05:03.227]                       else if (inherits(cond, "warning")) {
[18:05:03.227]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.227]                         if (muffled) 
[18:05:03.227]                           invokeRestart("muffleWarning")
[18:05:03.227]                       }
[18:05:03.227]                       else if (inherits(cond, "condition")) {
[18:05:03.227]                         if (!is.null(pattern)) {
[18:05:03.227]                           computeRestarts <- base::computeRestarts
[18:05:03.227]                           grepl <- base::grepl
[18:05:03.227]                           restarts <- computeRestarts(cond)
[18:05:03.227]                           for (restart in restarts) {
[18:05:03.227]                             name <- restart$name
[18:05:03.227]                             if (is.null(name)) 
[18:05:03.227]                               next
[18:05:03.227]                             if (!grepl(pattern, name)) 
[18:05:03.227]                               next
[18:05:03.227]                             invokeRestart(restart)
[18:05:03.227]                             muffled <- TRUE
[18:05:03.227]                             break
[18:05:03.227]                           }
[18:05:03.227]                         }
[18:05:03.227]                       }
[18:05:03.227]                       invisible(muffled)
[18:05:03.227]                     }
[18:05:03.227]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.227]                   }
[18:05:03.227]                 }
[18:05:03.227]                 else {
[18:05:03.227]                   if (TRUE) {
[18:05:03.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.227]                     {
[18:05:03.227]                       inherits <- base::inherits
[18:05:03.227]                       invokeRestart <- base::invokeRestart
[18:05:03.227]                       is.null <- base::is.null
[18:05:03.227]                       muffled <- FALSE
[18:05:03.227]                       if (inherits(cond, "message")) {
[18:05:03.227]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.227]                         if (muffled) 
[18:05:03.227]                           invokeRestart("muffleMessage")
[18:05:03.227]                       }
[18:05:03.227]                       else if (inherits(cond, "warning")) {
[18:05:03.227]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.227]                         if (muffled) 
[18:05:03.227]                           invokeRestart("muffleWarning")
[18:05:03.227]                       }
[18:05:03.227]                       else if (inherits(cond, "condition")) {
[18:05:03.227]                         if (!is.null(pattern)) {
[18:05:03.227]                           computeRestarts <- base::computeRestarts
[18:05:03.227]                           grepl <- base::grepl
[18:05:03.227]                           restarts <- computeRestarts(cond)
[18:05:03.227]                           for (restart in restarts) {
[18:05:03.227]                             name <- restart$name
[18:05:03.227]                             if (is.null(name)) 
[18:05:03.227]                               next
[18:05:03.227]                             if (!grepl(pattern, name)) 
[18:05:03.227]                               next
[18:05:03.227]                             invokeRestart(restart)
[18:05:03.227]                             muffled <- TRUE
[18:05:03.227]                             break
[18:05:03.227]                           }
[18:05:03.227]                         }
[18:05:03.227]                       }
[18:05:03.227]                       invisible(muffled)
[18:05:03.227]                     }
[18:05:03.227]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.227]                   }
[18:05:03.227]                 }
[18:05:03.227]             }
[18:05:03.227]         }))
[18:05:03.227]     }, error = function(ex) {
[18:05:03.227]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:03.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.227]                 ...future.rng), started = ...future.startTime, 
[18:05:03.227]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:03.227]             version = "1.8"), class = "FutureResult")
[18:05:03.227]     }, finally = {
[18:05:03.227]         if (!identical(...future.workdir, getwd())) 
[18:05:03.227]             setwd(...future.workdir)
[18:05:03.227]         {
[18:05:03.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:03.227]                 ...future.oldOptions$nwarnings <- NULL
[18:05:03.227]             }
[18:05:03.227]             base::options(...future.oldOptions)
[18:05:03.227]             if (.Platform$OS.type == "windows") {
[18:05:03.227]                 old_names <- names(...future.oldEnvVars)
[18:05:03.227]                 envs <- base::Sys.getenv()
[18:05:03.227]                 names <- names(envs)
[18:05:03.227]                 common <- intersect(names, old_names)
[18:05:03.227]                 added <- setdiff(names, old_names)
[18:05:03.227]                 removed <- setdiff(old_names, names)
[18:05:03.227]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:03.227]                   envs[common]]
[18:05:03.227]                 NAMES <- toupper(changed)
[18:05:03.227]                 args <- list()
[18:05:03.227]                 for (kk in seq_along(NAMES)) {
[18:05:03.227]                   name <- changed[[kk]]
[18:05:03.227]                   NAME <- NAMES[[kk]]
[18:05:03.227]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.227]                     next
[18:05:03.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.227]                 }
[18:05:03.227]                 NAMES <- toupper(added)
[18:05:03.227]                 for (kk in seq_along(NAMES)) {
[18:05:03.227]                   name <- added[[kk]]
[18:05:03.227]                   NAME <- NAMES[[kk]]
[18:05:03.227]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.227]                     next
[18:05:03.227]                   args[[name]] <- ""
[18:05:03.227]                 }
[18:05:03.227]                 NAMES <- toupper(removed)
[18:05:03.227]                 for (kk in seq_along(NAMES)) {
[18:05:03.227]                   name <- removed[[kk]]
[18:05:03.227]                   NAME <- NAMES[[kk]]
[18:05:03.227]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.227]                     next
[18:05:03.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.227]                 }
[18:05:03.227]                 if (length(args) > 0) 
[18:05:03.227]                   base::do.call(base::Sys.setenv, args = args)
[18:05:03.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:03.227]             }
[18:05:03.227]             else {
[18:05:03.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:03.227]             }
[18:05:03.227]             {
[18:05:03.227]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:03.227]                   0L) {
[18:05:03.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:03.227]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:03.227]                   base::options(opts)
[18:05:03.227]                 }
[18:05:03.227]                 {
[18:05:03.227]                   {
[18:05:03.227]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:03.227]                     NULL
[18:05:03.227]                   }
[18:05:03.227]                   options(future.plan = NULL)
[18:05:03.227]                   if (is.na(NA_character_)) 
[18:05:03.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:03.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:03.227]                     .init = FALSE)
[18:05:03.227]                 }
[18:05:03.227]             }
[18:05:03.227]         }
[18:05:03.227]     })
[18:05:03.227]     if (TRUE) {
[18:05:03.227]         base::sink(type = "output", split = FALSE)
[18:05:03.227]         if (TRUE) {
[18:05:03.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:03.227]         }
[18:05:03.227]         else {
[18:05:03.227]             ...future.result["stdout"] <- base::list(NULL)
[18:05:03.227]         }
[18:05:03.227]         base::close(...future.stdout)
[18:05:03.227]         ...future.stdout <- NULL
[18:05:03.227]     }
[18:05:03.227]     ...future.result$conditions <- ...future.conditions
[18:05:03.227]     ...future.result$finished <- base::Sys.time()
[18:05:03.227]     ...future.result
[18:05:03.227] }
[18:05:03.232] MultisessionFuture started
[18:05:03.233] - Launch lazy future ... done
[18:05:03.233] run() for ‘MultisessionFuture’ ... done
[18:05:03.277] receiveMessageFromWorker() for ClusterFuture ...
[18:05:03.277] - Validating connection of MultisessionFuture
[18:05:03.278] - received message: FutureResult
[18:05:03.278] - Received FutureResult
[18:05:03.278] - Erased future from FutureRegistry
[18:05:03.278] result() for ClusterFuture ...
[18:05:03.278] - result already collected: FutureResult
[18:05:03.279] result() for ClusterFuture ... done
[18:05:03.279] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:03.279] Future #1
[18:05:03.279] result() for ClusterFuture ...
[18:05:03.279] - result already collected: FutureResult
[18:05:03.280] result() for ClusterFuture ... done
[18:05:03.280] result() for ClusterFuture ...
[18:05:03.280] - result already collected: FutureResult
[18:05:03.280] result() for ClusterFuture ... done
[18:05:03.280] A MultisessionFuture was resolved
[18:05:03.281]  length: 0 (resolved future 1)
[18:05:03.281] resolve() on list ... DONE
[18:05:03.281] - globals: [1] ‘a’
[18:05:03.281] Resolving futures part of globals (recursively) ... DONE
[18:05:03.286] The total size of the 1 globals is 1.57 MiB (1649832 bytes)
[18:05:03.287] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[18:05:03.287] - globals: [1] ‘a’
[18:05:03.288] - packages: [1] ‘future’
[18:05:03.288] getGlobalsAndPackages() ... DONE
[18:05:03.289] run() for ‘Future’ ...
[18:05:03.289] - state: ‘created’
[18:05:03.289] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:03.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:03.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:03.314]   - Field: ‘node’
[18:05:03.314]   - Field: ‘label’
[18:05:03.314]   - Field: ‘local’
[18:05:03.314]   - Field: ‘owner’
[18:05:03.315]   - Field: ‘envir’
[18:05:03.315]   - Field: ‘workers’
[18:05:03.315]   - Field: ‘packages’
[18:05:03.315]   - Field: ‘gc’
[18:05:03.315]   - Field: ‘conditions’
[18:05:03.316]   - Field: ‘persistent’
[18:05:03.316]   - Field: ‘expr’
[18:05:03.316]   - Field: ‘uuid’
[18:05:03.316]   - Field: ‘seed’
[18:05:03.316]   - Field: ‘version’
[18:05:03.317]   - Field: ‘result’
[18:05:03.317]   - Field: ‘asynchronous’
[18:05:03.317]   - Field: ‘calls’
[18:05:03.317]   - Field: ‘globals’
[18:05:03.317]   - Field: ‘stdout’
[18:05:03.318]   - Field: ‘earlySignal’
[18:05:03.318]   - Field: ‘lazy’
[18:05:03.318]   - Field: ‘state’
[18:05:03.318] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:03.318] - Launch lazy future ...
[18:05:03.319] Packages needed by the future expression (n = 1): ‘future’
[18:05:03.319] Packages needed by future strategies (n = 0): <none>
[18:05:03.320] {
[18:05:03.320]     {
[18:05:03.320]         {
[18:05:03.320]             ...future.startTime <- base::Sys.time()
[18:05:03.320]             {
[18:05:03.320]                 {
[18:05:03.320]                   {
[18:05:03.320]                     {
[18:05:03.320]                       {
[18:05:03.320]                         base::local({
[18:05:03.320]                           has_future <- base::requireNamespace("future", 
[18:05:03.320]                             quietly = TRUE)
[18:05:03.320]                           if (has_future) {
[18:05:03.320]                             ns <- base::getNamespace("future")
[18:05:03.320]                             version <- ns[[".package"]][["version"]]
[18:05:03.320]                             if (is.null(version)) 
[18:05:03.320]                               version <- utils::packageVersion("future")
[18:05:03.320]                           }
[18:05:03.320]                           else {
[18:05:03.320]                             version <- NULL
[18:05:03.320]                           }
[18:05:03.320]                           if (!has_future || version < "1.8.0") {
[18:05:03.320]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:03.320]                               "", base::R.version$version.string), 
[18:05:03.320]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:03.320]                                 base::R.version$platform, 8 * 
[18:05:03.320]                                   base::.Machine$sizeof.pointer), 
[18:05:03.320]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:03.320]                                 "release", "version")], collapse = " "), 
[18:05:03.320]                               hostname = base::Sys.info()[["nodename"]])
[18:05:03.320]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:03.320]                               info)
[18:05:03.320]                             info <- base::paste(info, collapse = "; ")
[18:05:03.320]                             if (!has_future) {
[18:05:03.320]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:03.320]                                 info)
[18:05:03.320]                             }
[18:05:03.320]                             else {
[18:05:03.320]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:03.320]                                 info, version)
[18:05:03.320]                             }
[18:05:03.320]                             base::stop(msg)
[18:05:03.320]                           }
[18:05:03.320]                         })
[18:05:03.320]                       }
[18:05:03.320]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:03.320]                       base::options(mc.cores = 1L)
[18:05:03.320]                     }
[18:05:03.320]                     base::local({
[18:05:03.320]                       for (pkg in "future") {
[18:05:03.320]                         base::loadNamespace(pkg)
[18:05:03.320]                         base::library(pkg, character.only = TRUE)
[18:05:03.320]                       }
[18:05:03.320]                     })
[18:05:03.320]                   }
[18:05:03.320]                   ...future.strategy.old <- future::plan("list")
[18:05:03.320]                   options(future.plan = NULL)
[18:05:03.320]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.320]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:03.320]                 }
[18:05:03.320]                 ...future.workdir <- getwd()
[18:05:03.320]             }
[18:05:03.320]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:03.320]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:03.320]         }
[18:05:03.320]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:03.320]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:03.320]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:03.320]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:03.320]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:03.320]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:03.320]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:03.320]             base::names(...future.oldOptions))
[18:05:03.320]     }
[18:05:03.320]     if (FALSE) {
[18:05:03.320]     }
[18:05:03.320]     else {
[18:05:03.320]         if (TRUE) {
[18:05:03.320]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:03.320]                 open = "w")
[18:05:03.320]         }
[18:05:03.320]         else {
[18:05:03.320]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:03.320]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:03.320]         }
[18:05:03.320]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:03.320]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:03.320]             base::sink(type = "output", split = FALSE)
[18:05:03.320]             base::close(...future.stdout)
[18:05:03.320]         }, add = TRUE)
[18:05:03.320]     }
[18:05:03.320]     ...future.frame <- base::sys.nframe()
[18:05:03.320]     ...future.conditions <- base::list()
[18:05:03.320]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:03.320]     if (FALSE) {
[18:05:03.320]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:03.320]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:03.320]     }
[18:05:03.320]     ...future.result <- base::tryCatch({
[18:05:03.320]         base::withCallingHandlers({
[18:05:03.320]             ...future.value <- base::withVisible(base::local({
[18:05:03.320]                 ...future.makeSendCondition <- base::local({
[18:05:03.320]                   sendCondition <- NULL
[18:05:03.320]                   function(frame = 1L) {
[18:05:03.320]                     if (is.function(sendCondition)) 
[18:05:03.320]                       return(sendCondition)
[18:05:03.320]                     ns <- getNamespace("parallel")
[18:05:03.320]                     if (exists("sendData", mode = "function", 
[18:05:03.320]                       envir = ns)) {
[18:05:03.320]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:03.320]                         envir = ns)
[18:05:03.320]                       envir <- sys.frame(frame)
[18:05:03.320]                       master <- NULL
[18:05:03.320]                       while (!identical(envir, .GlobalEnv) && 
[18:05:03.320]                         !identical(envir, emptyenv())) {
[18:05:03.320]                         if (exists("master", mode = "list", envir = envir, 
[18:05:03.320]                           inherits = FALSE)) {
[18:05:03.320]                           master <- get("master", mode = "list", 
[18:05:03.320]                             envir = envir, inherits = FALSE)
[18:05:03.320]                           if (inherits(master, c("SOCKnode", 
[18:05:03.320]                             "SOCK0node"))) {
[18:05:03.320]                             sendCondition <<- function(cond) {
[18:05:03.320]                               data <- list(type = "VALUE", value = cond, 
[18:05:03.320]                                 success = TRUE)
[18:05:03.320]                               parallel_sendData(master, data)
[18:05:03.320]                             }
[18:05:03.320]                             return(sendCondition)
[18:05:03.320]                           }
[18:05:03.320]                         }
[18:05:03.320]                         frame <- frame + 1L
[18:05:03.320]                         envir <- sys.frame(frame)
[18:05:03.320]                       }
[18:05:03.320]                     }
[18:05:03.320]                     sendCondition <<- function(cond) NULL
[18:05:03.320]                   }
[18:05:03.320]                 })
[18:05:03.320]                 withCallingHandlers({
[18:05:03.320]                   value(a) + 1
[18:05:03.320]                 }, immediateCondition = function(cond) {
[18:05:03.320]                   sendCondition <- ...future.makeSendCondition()
[18:05:03.320]                   sendCondition(cond)
[18:05:03.320]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.320]                   {
[18:05:03.320]                     inherits <- base::inherits
[18:05:03.320]                     invokeRestart <- base::invokeRestart
[18:05:03.320]                     is.null <- base::is.null
[18:05:03.320]                     muffled <- FALSE
[18:05:03.320]                     if (inherits(cond, "message")) {
[18:05:03.320]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:03.320]                       if (muffled) 
[18:05:03.320]                         invokeRestart("muffleMessage")
[18:05:03.320]                     }
[18:05:03.320]                     else if (inherits(cond, "warning")) {
[18:05:03.320]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:03.320]                       if (muffled) 
[18:05:03.320]                         invokeRestart("muffleWarning")
[18:05:03.320]                     }
[18:05:03.320]                     else if (inherits(cond, "condition")) {
[18:05:03.320]                       if (!is.null(pattern)) {
[18:05:03.320]                         computeRestarts <- base::computeRestarts
[18:05:03.320]                         grepl <- base::grepl
[18:05:03.320]                         restarts <- computeRestarts(cond)
[18:05:03.320]                         for (restart in restarts) {
[18:05:03.320]                           name <- restart$name
[18:05:03.320]                           if (is.null(name)) 
[18:05:03.320]                             next
[18:05:03.320]                           if (!grepl(pattern, name)) 
[18:05:03.320]                             next
[18:05:03.320]                           invokeRestart(restart)
[18:05:03.320]                           muffled <- TRUE
[18:05:03.320]                           break
[18:05:03.320]                         }
[18:05:03.320]                       }
[18:05:03.320]                     }
[18:05:03.320]                     invisible(muffled)
[18:05:03.320]                   }
[18:05:03.320]                   muffleCondition(cond)
[18:05:03.320]                 })
[18:05:03.320]             }))
[18:05:03.320]             future::FutureResult(value = ...future.value$value, 
[18:05:03.320]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.320]                   ...future.rng), globalenv = if (FALSE) 
[18:05:03.320]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:03.320]                     ...future.globalenv.names))
[18:05:03.320]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:03.320]         }, condition = base::local({
[18:05:03.320]             c <- base::c
[18:05:03.320]             inherits <- base::inherits
[18:05:03.320]             invokeRestart <- base::invokeRestart
[18:05:03.320]             length <- base::length
[18:05:03.320]             list <- base::list
[18:05:03.320]             seq.int <- base::seq.int
[18:05:03.320]             signalCondition <- base::signalCondition
[18:05:03.320]             sys.calls <- base::sys.calls
[18:05:03.320]             `[[` <- base::`[[`
[18:05:03.320]             `+` <- base::`+`
[18:05:03.320]             `<<-` <- base::`<<-`
[18:05:03.320]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:03.320]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:03.320]                   3L)]
[18:05:03.320]             }
[18:05:03.320]             function(cond) {
[18:05:03.320]                 is_error <- inherits(cond, "error")
[18:05:03.320]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:03.320]                   NULL)
[18:05:03.320]                 if (is_error) {
[18:05:03.320]                   sessionInformation <- function() {
[18:05:03.320]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:03.320]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:03.320]                       search = base::search(), system = base::Sys.info())
[18:05:03.320]                   }
[18:05:03.320]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.320]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:03.320]                     cond$call), session = sessionInformation(), 
[18:05:03.320]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:03.320]                   signalCondition(cond)
[18:05:03.320]                 }
[18:05:03.320]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:03.320]                 "immediateCondition"))) {
[18:05:03.320]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:03.320]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.320]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:03.320]                   if (TRUE && !signal) {
[18:05:03.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.320]                     {
[18:05:03.320]                       inherits <- base::inherits
[18:05:03.320]                       invokeRestart <- base::invokeRestart
[18:05:03.320]                       is.null <- base::is.null
[18:05:03.320]                       muffled <- FALSE
[18:05:03.320]                       if (inherits(cond, "message")) {
[18:05:03.320]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.320]                         if (muffled) 
[18:05:03.320]                           invokeRestart("muffleMessage")
[18:05:03.320]                       }
[18:05:03.320]                       else if (inherits(cond, "warning")) {
[18:05:03.320]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.320]                         if (muffled) 
[18:05:03.320]                           invokeRestart("muffleWarning")
[18:05:03.320]                       }
[18:05:03.320]                       else if (inherits(cond, "condition")) {
[18:05:03.320]                         if (!is.null(pattern)) {
[18:05:03.320]                           computeRestarts <- base::computeRestarts
[18:05:03.320]                           grepl <- base::grepl
[18:05:03.320]                           restarts <- computeRestarts(cond)
[18:05:03.320]                           for (restart in restarts) {
[18:05:03.320]                             name <- restart$name
[18:05:03.320]                             if (is.null(name)) 
[18:05:03.320]                               next
[18:05:03.320]                             if (!grepl(pattern, name)) 
[18:05:03.320]                               next
[18:05:03.320]                             invokeRestart(restart)
[18:05:03.320]                             muffled <- TRUE
[18:05:03.320]                             break
[18:05:03.320]                           }
[18:05:03.320]                         }
[18:05:03.320]                       }
[18:05:03.320]                       invisible(muffled)
[18:05:03.320]                     }
[18:05:03.320]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.320]                   }
[18:05:03.320]                 }
[18:05:03.320]                 else {
[18:05:03.320]                   if (TRUE) {
[18:05:03.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.320]                     {
[18:05:03.320]                       inherits <- base::inherits
[18:05:03.320]                       invokeRestart <- base::invokeRestart
[18:05:03.320]                       is.null <- base::is.null
[18:05:03.320]                       muffled <- FALSE
[18:05:03.320]                       if (inherits(cond, "message")) {
[18:05:03.320]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.320]                         if (muffled) 
[18:05:03.320]                           invokeRestart("muffleMessage")
[18:05:03.320]                       }
[18:05:03.320]                       else if (inherits(cond, "warning")) {
[18:05:03.320]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.320]                         if (muffled) 
[18:05:03.320]                           invokeRestart("muffleWarning")
[18:05:03.320]                       }
[18:05:03.320]                       else if (inherits(cond, "condition")) {
[18:05:03.320]                         if (!is.null(pattern)) {
[18:05:03.320]                           computeRestarts <- base::computeRestarts
[18:05:03.320]                           grepl <- base::grepl
[18:05:03.320]                           restarts <- computeRestarts(cond)
[18:05:03.320]                           for (restart in restarts) {
[18:05:03.320]                             name <- restart$name
[18:05:03.320]                             if (is.null(name)) 
[18:05:03.320]                               next
[18:05:03.320]                             if (!grepl(pattern, name)) 
[18:05:03.320]                               next
[18:05:03.320]                             invokeRestart(restart)
[18:05:03.320]                             muffled <- TRUE
[18:05:03.320]                             break
[18:05:03.320]                           }
[18:05:03.320]                         }
[18:05:03.320]                       }
[18:05:03.320]                       invisible(muffled)
[18:05:03.320]                     }
[18:05:03.320]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.320]                   }
[18:05:03.320]                 }
[18:05:03.320]             }
[18:05:03.320]         }))
[18:05:03.320]     }, error = function(ex) {
[18:05:03.320]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:03.320]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.320]                 ...future.rng), started = ...future.startTime, 
[18:05:03.320]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:03.320]             version = "1.8"), class = "FutureResult")
[18:05:03.320]     }, finally = {
[18:05:03.320]         if (!identical(...future.workdir, getwd())) 
[18:05:03.320]             setwd(...future.workdir)
[18:05:03.320]         {
[18:05:03.320]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:03.320]                 ...future.oldOptions$nwarnings <- NULL
[18:05:03.320]             }
[18:05:03.320]             base::options(...future.oldOptions)
[18:05:03.320]             if (.Platform$OS.type == "windows") {
[18:05:03.320]                 old_names <- names(...future.oldEnvVars)
[18:05:03.320]                 envs <- base::Sys.getenv()
[18:05:03.320]                 names <- names(envs)
[18:05:03.320]                 common <- intersect(names, old_names)
[18:05:03.320]                 added <- setdiff(names, old_names)
[18:05:03.320]                 removed <- setdiff(old_names, names)
[18:05:03.320]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:03.320]                   envs[common]]
[18:05:03.320]                 NAMES <- toupper(changed)
[18:05:03.320]                 args <- list()
[18:05:03.320]                 for (kk in seq_along(NAMES)) {
[18:05:03.320]                   name <- changed[[kk]]
[18:05:03.320]                   NAME <- NAMES[[kk]]
[18:05:03.320]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.320]                     next
[18:05:03.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.320]                 }
[18:05:03.320]                 NAMES <- toupper(added)
[18:05:03.320]                 for (kk in seq_along(NAMES)) {
[18:05:03.320]                   name <- added[[kk]]
[18:05:03.320]                   NAME <- NAMES[[kk]]
[18:05:03.320]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.320]                     next
[18:05:03.320]                   args[[name]] <- ""
[18:05:03.320]                 }
[18:05:03.320]                 NAMES <- toupper(removed)
[18:05:03.320]                 for (kk in seq_along(NAMES)) {
[18:05:03.320]                   name <- removed[[kk]]
[18:05:03.320]                   NAME <- NAMES[[kk]]
[18:05:03.320]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.320]                     next
[18:05:03.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.320]                 }
[18:05:03.320]                 if (length(args) > 0) 
[18:05:03.320]                   base::do.call(base::Sys.setenv, args = args)
[18:05:03.320]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:03.320]             }
[18:05:03.320]             else {
[18:05:03.320]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:03.320]             }
[18:05:03.320]             {
[18:05:03.320]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:03.320]                   0L) {
[18:05:03.320]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:03.320]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:03.320]                   base::options(opts)
[18:05:03.320]                 }
[18:05:03.320]                 {
[18:05:03.320]                   {
[18:05:03.320]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:03.320]                     NULL
[18:05:03.320]                   }
[18:05:03.320]                   options(future.plan = NULL)
[18:05:03.320]                   if (is.na(NA_character_)) 
[18:05:03.320]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.320]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:03.320]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:03.320]                     .init = FALSE)
[18:05:03.320]                 }
[18:05:03.320]             }
[18:05:03.320]         }
[18:05:03.320]     })
[18:05:03.320]     if (TRUE) {
[18:05:03.320]         base::sink(type = "output", split = FALSE)
[18:05:03.320]         if (TRUE) {
[18:05:03.320]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:03.320]         }
[18:05:03.320]         else {
[18:05:03.320]             ...future.result["stdout"] <- base::list(NULL)
[18:05:03.320]         }
[18:05:03.320]         base::close(...future.stdout)
[18:05:03.320]         ...future.stdout <- NULL
[18:05:03.320]     }
[18:05:03.320]     ...future.result$conditions <- ...future.conditions
[18:05:03.320]     ...future.result$finished <- base::Sys.time()
[18:05:03.320]     ...future.result
[18:05:03.320] }
[18:05:03.325] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[18:05:03.330] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[18:05:03.389] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[18:05:03.389] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[18:05:03.390] MultisessionFuture started
[18:05:03.390] - Launch lazy future ... done
[18:05:03.390] run() for ‘MultisessionFuture’ ... done
[18:05:03.391] result() for ClusterFuture ...
[18:05:03.391] receiveMessageFromWorker() for ClusterFuture ...
[18:05:03.391] - Validating connection of MultisessionFuture
[18:05:03.435] - received message: FutureResult
[18:05:03.435] - Received FutureResult
[18:05:03.436] - Erased future from FutureRegistry
[18:05:03.436] result() for ClusterFuture ...
[18:05:03.436] - result already collected: FutureResult
[18:05:03.436] result() for ClusterFuture ... done
[18:05:03.436] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:03.437] result() for ClusterFuture ... done
[18:05:03.437] result() for ClusterFuture ...
[18:05:03.437] - result already collected: FutureResult
[18:05:03.437] result() for ClusterFuture ... done
value(b) = 2
[18:05:03.438] result() for ClusterFuture ...
[18:05:03.438] - result already collected: FutureResult
[18:05:03.438] result() for ClusterFuture ... done
[18:05:03.438] result() for ClusterFuture ...
[18:05:03.439] - result already collected: FutureResult
[18:05:03.439] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:03.439] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:03.440] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:03.441] 
[18:05:03.441] Searching for globals ... DONE
[18:05:03.441] - globals: [0] <none>
[18:05:03.441] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:03.442] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:03.443] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:03.444] - globals found: [3] ‘+’, ‘value’, ‘a’
[18:05:03.445] Searching for globals ... DONE
[18:05:03.445] Resolving globals: TRUE
[18:05:03.445] Resolving any globals that are futures ...
[18:05:03.445] - globals: [3] ‘+’, ‘value’, ‘a’
[18:05:03.446] Resolving any globals that are futures ... DONE
[18:05:03.446] Resolving futures part of globals (recursively) ...
[18:05:03.447] resolve() on list ...
[18:05:03.447]  recursive: 99
[18:05:03.447]  length: 1
[18:05:03.447]  elements: ‘a’
[18:05:03.448] run() for ‘Future’ ...
[18:05:03.448] - state: ‘created’
[18:05:03.448] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:03.474] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:03.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:03.475]   - Field: ‘node’
[18:05:03.475]   - Field: ‘label’
[18:05:03.476]   - Field: ‘local’
[18:05:03.476]   - Field: ‘owner’
[18:05:03.476]   - Field: ‘envir’
[18:05:03.476]   - Field: ‘workers’
[18:05:03.476]   - Field: ‘packages’
[18:05:03.477]   - Field: ‘gc’
[18:05:03.477]   - Field: ‘conditions’
[18:05:03.477]   - Field: ‘persistent’
[18:05:03.477]   - Field: ‘expr’
[18:05:03.478]   - Field: ‘uuid’
[18:05:03.478]   - Field: ‘seed’
[18:05:03.478]   - Field: ‘version’
[18:05:03.478]   - Field: ‘result’
[18:05:03.478]   - Field: ‘asynchronous’
[18:05:03.479]   - Field: ‘calls’
[18:05:03.479]   - Field: ‘globals’
[18:05:03.479]   - Field: ‘stdout’
[18:05:03.479]   - Field: ‘earlySignal’
[18:05:03.480]   - Field: ‘lazy’
[18:05:03.480]   - Field: ‘state’
[18:05:03.480] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:03.480] - Launch lazy future ...
[18:05:03.481] Packages needed by the future expression (n = 0): <none>
[18:05:03.481] Packages needed by future strategies (n = 0): <none>
[18:05:03.482] {
[18:05:03.482]     {
[18:05:03.482]         {
[18:05:03.482]             ...future.startTime <- base::Sys.time()
[18:05:03.482]             {
[18:05:03.482]                 {
[18:05:03.482]                   {
[18:05:03.482]                     {
[18:05:03.482]                       base::local({
[18:05:03.482]                         has_future <- base::requireNamespace("future", 
[18:05:03.482]                           quietly = TRUE)
[18:05:03.482]                         if (has_future) {
[18:05:03.482]                           ns <- base::getNamespace("future")
[18:05:03.482]                           version <- ns[[".package"]][["version"]]
[18:05:03.482]                           if (is.null(version)) 
[18:05:03.482]                             version <- utils::packageVersion("future")
[18:05:03.482]                         }
[18:05:03.482]                         else {
[18:05:03.482]                           version <- NULL
[18:05:03.482]                         }
[18:05:03.482]                         if (!has_future || version < "1.8.0") {
[18:05:03.482]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:03.482]                             "", base::R.version$version.string), 
[18:05:03.482]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:03.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:03.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:03.482]                               "release", "version")], collapse = " "), 
[18:05:03.482]                             hostname = base::Sys.info()[["nodename"]])
[18:05:03.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:03.482]                             info)
[18:05:03.482]                           info <- base::paste(info, collapse = "; ")
[18:05:03.482]                           if (!has_future) {
[18:05:03.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:03.482]                               info)
[18:05:03.482]                           }
[18:05:03.482]                           else {
[18:05:03.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:03.482]                               info, version)
[18:05:03.482]                           }
[18:05:03.482]                           base::stop(msg)
[18:05:03.482]                         }
[18:05:03.482]                       })
[18:05:03.482]                     }
[18:05:03.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:03.482]                     base::options(mc.cores = 1L)
[18:05:03.482]                   }
[18:05:03.482]                   ...future.strategy.old <- future::plan("list")
[18:05:03.482]                   options(future.plan = NULL)
[18:05:03.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:03.482]                 }
[18:05:03.482]                 ...future.workdir <- getwd()
[18:05:03.482]             }
[18:05:03.482]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:03.482]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:03.482]         }
[18:05:03.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:03.482]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:03.482]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:03.482]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:03.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:03.482]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:03.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:03.482]             base::names(...future.oldOptions))
[18:05:03.482]     }
[18:05:03.482]     if (FALSE) {
[18:05:03.482]     }
[18:05:03.482]     else {
[18:05:03.482]         if (TRUE) {
[18:05:03.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:03.482]                 open = "w")
[18:05:03.482]         }
[18:05:03.482]         else {
[18:05:03.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:03.482]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:03.482]         }
[18:05:03.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:03.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:03.482]             base::sink(type = "output", split = FALSE)
[18:05:03.482]             base::close(...future.stdout)
[18:05:03.482]         }, add = TRUE)
[18:05:03.482]     }
[18:05:03.482]     ...future.frame <- base::sys.nframe()
[18:05:03.482]     ...future.conditions <- base::list()
[18:05:03.482]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:03.482]     if (FALSE) {
[18:05:03.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:03.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:03.482]     }
[18:05:03.482]     ...future.result <- base::tryCatch({
[18:05:03.482]         base::withCallingHandlers({
[18:05:03.482]             ...future.value <- base::withVisible(base::local({
[18:05:03.482]                 ...future.makeSendCondition <- base::local({
[18:05:03.482]                   sendCondition <- NULL
[18:05:03.482]                   function(frame = 1L) {
[18:05:03.482]                     if (is.function(sendCondition)) 
[18:05:03.482]                       return(sendCondition)
[18:05:03.482]                     ns <- getNamespace("parallel")
[18:05:03.482]                     if (exists("sendData", mode = "function", 
[18:05:03.482]                       envir = ns)) {
[18:05:03.482]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:03.482]                         envir = ns)
[18:05:03.482]                       envir <- sys.frame(frame)
[18:05:03.482]                       master <- NULL
[18:05:03.482]                       while (!identical(envir, .GlobalEnv) && 
[18:05:03.482]                         !identical(envir, emptyenv())) {
[18:05:03.482]                         if (exists("master", mode = "list", envir = envir, 
[18:05:03.482]                           inherits = FALSE)) {
[18:05:03.482]                           master <- get("master", mode = "list", 
[18:05:03.482]                             envir = envir, inherits = FALSE)
[18:05:03.482]                           if (inherits(master, c("SOCKnode", 
[18:05:03.482]                             "SOCK0node"))) {
[18:05:03.482]                             sendCondition <<- function(cond) {
[18:05:03.482]                               data <- list(type = "VALUE", value = cond, 
[18:05:03.482]                                 success = TRUE)
[18:05:03.482]                               parallel_sendData(master, data)
[18:05:03.482]                             }
[18:05:03.482]                             return(sendCondition)
[18:05:03.482]                           }
[18:05:03.482]                         }
[18:05:03.482]                         frame <- frame + 1L
[18:05:03.482]                         envir <- sys.frame(frame)
[18:05:03.482]                       }
[18:05:03.482]                     }
[18:05:03.482]                     sendCondition <<- function(cond) NULL
[18:05:03.482]                   }
[18:05:03.482]                 })
[18:05:03.482]                 withCallingHandlers({
[18:05:03.482]                   1
[18:05:03.482]                 }, immediateCondition = function(cond) {
[18:05:03.482]                   sendCondition <- ...future.makeSendCondition()
[18:05:03.482]                   sendCondition(cond)
[18:05:03.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.482]                   {
[18:05:03.482]                     inherits <- base::inherits
[18:05:03.482]                     invokeRestart <- base::invokeRestart
[18:05:03.482]                     is.null <- base::is.null
[18:05:03.482]                     muffled <- FALSE
[18:05:03.482]                     if (inherits(cond, "message")) {
[18:05:03.482]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:03.482]                       if (muffled) 
[18:05:03.482]                         invokeRestart("muffleMessage")
[18:05:03.482]                     }
[18:05:03.482]                     else if (inherits(cond, "warning")) {
[18:05:03.482]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:03.482]                       if (muffled) 
[18:05:03.482]                         invokeRestart("muffleWarning")
[18:05:03.482]                     }
[18:05:03.482]                     else if (inherits(cond, "condition")) {
[18:05:03.482]                       if (!is.null(pattern)) {
[18:05:03.482]                         computeRestarts <- base::computeRestarts
[18:05:03.482]                         grepl <- base::grepl
[18:05:03.482]                         restarts <- computeRestarts(cond)
[18:05:03.482]                         for (restart in restarts) {
[18:05:03.482]                           name <- restart$name
[18:05:03.482]                           if (is.null(name)) 
[18:05:03.482]                             next
[18:05:03.482]                           if (!grepl(pattern, name)) 
[18:05:03.482]                             next
[18:05:03.482]                           invokeRestart(restart)
[18:05:03.482]                           muffled <- TRUE
[18:05:03.482]                           break
[18:05:03.482]                         }
[18:05:03.482]                       }
[18:05:03.482]                     }
[18:05:03.482]                     invisible(muffled)
[18:05:03.482]                   }
[18:05:03.482]                   muffleCondition(cond)
[18:05:03.482]                 })
[18:05:03.482]             }))
[18:05:03.482]             future::FutureResult(value = ...future.value$value, 
[18:05:03.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.482]                   ...future.rng), globalenv = if (FALSE) 
[18:05:03.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:03.482]                     ...future.globalenv.names))
[18:05:03.482]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:03.482]         }, condition = base::local({
[18:05:03.482]             c <- base::c
[18:05:03.482]             inherits <- base::inherits
[18:05:03.482]             invokeRestart <- base::invokeRestart
[18:05:03.482]             length <- base::length
[18:05:03.482]             list <- base::list
[18:05:03.482]             seq.int <- base::seq.int
[18:05:03.482]             signalCondition <- base::signalCondition
[18:05:03.482]             sys.calls <- base::sys.calls
[18:05:03.482]             `[[` <- base::`[[`
[18:05:03.482]             `+` <- base::`+`
[18:05:03.482]             `<<-` <- base::`<<-`
[18:05:03.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:03.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:03.482]                   3L)]
[18:05:03.482]             }
[18:05:03.482]             function(cond) {
[18:05:03.482]                 is_error <- inherits(cond, "error")
[18:05:03.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:03.482]                   NULL)
[18:05:03.482]                 if (is_error) {
[18:05:03.482]                   sessionInformation <- function() {
[18:05:03.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:03.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:03.482]                       search = base::search(), system = base::Sys.info())
[18:05:03.482]                   }
[18:05:03.482]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:03.482]                     cond$call), session = sessionInformation(), 
[18:05:03.482]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:03.482]                   signalCondition(cond)
[18:05:03.482]                 }
[18:05:03.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:03.482]                 "immediateCondition"))) {
[18:05:03.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:03.482]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:03.482]                   if (TRUE && !signal) {
[18:05:03.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.482]                     {
[18:05:03.482]                       inherits <- base::inherits
[18:05:03.482]                       invokeRestart <- base::invokeRestart
[18:05:03.482]                       is.null <- base::is.null
[18:05:03.482]                       muffled <- FALSE
[18:05:03.482]                       if (inherits(cond, "message")) {
[18:05:03.482]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.482]                         if (muffled) 
[18:05:03.482]                           invokeRestart("muffleMessage")
[18:05:03.482]                       }
[18:05:03.482]                       else if (inherits(cond, "warning")) {
[18:05:03.482]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.482]                         if (muffled) 
[18:05:03.482]                           invokeRestart("muffleWarning")
[18:05:03.482]                       }
[18:05:03.482]                       else if (inherits(cond, "condition")) {
[18:05:03.482]                         if (!is.null(pattern)) {
[18:05:03.482]                           computeRestarts <- base::computeRestarts
[18:05:03.482]                           grepl <- base::grepl
[18:05:03.482]                           restarts <- computeRestarts(cond)
[18:05:03.482]                           for (restart in restarts) {
[18:05:03.482]                             name <- restart$name
[18:05:03.482]                             if (is.null(name)) 
[18:05:03.482]                               next
[18:05:03.482]                             if (!grepl(pattern, name)) 
[18:05:03.482]                               next
[18:05:03.482]                             invokeRestart(restart)
[18:05:03.482]                             muffled <- TRUE
[18:05:03.482]                             break
[18:05:03.482]                           }
[18:05:03.482]                         }
[18:05:03.482]                       }
[18:05:03.482]                       invisible(muffled)
[18:05:03.482]                     }
[18:05:03.482]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.482]                   }
[18:05:03.482]                 }
[18:05:03.482]                 else {
[18:05:03.482]                   if (TRUE) {
[18:05:03.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.482]                     {
[18:05:03.482]                       inherits <- base::inherits
[18:05:03.482]                       invokeRestart <- base::invokeRestart
[18:05:03.482]                       is.null <- base::is.null
[18:05:03.482]                       muffled <- FALSE
[18:05:03.482]                       if (inherits(cond, "message")) {
[18:05:03.482]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.482]                         if (muffled) 
[18:05:03.482]                           invokeRestart("muffleMessage")
[18:05:03.482]                       }
[18:05:03.482]                       else if (inherits(cond, "warning")) {
[18:05:03.482]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.482]                         if (muffled) 
[18:05:03.482]                           invokeRestart("muffleWarning")
[18:05:03.482]                       }
[18:05:03.482]                       else if (inherits(cond, "condition")) {
[18:05:03.482]                         if (!is.null(pattern)) {
[18:05:03.482]                           computeRestarts <- base::computeRestarts
[18:05:03.482]                           grepl <- base::grepl
[18:05:03.482]                           restarts <- computeRestarts(cond)
[18:05:03.482]                           for (restart in restarts) {
[18:05:03.482]                             name <- restart$name
[18:05:03.482]                             if (is.null(name)) 
[18:05:03.482]                               next
[18:05:03.482]                             if (!grepl(pattern, name)) 
[18:05:03.482]                               next
[18:05:03.482]                             invokeRestart(restart)
[18:05:03.482]                             muffled <- TRUE
[18:05:03.482]                             break
[18:05:03.482]                           }
[18:05:03.482]                         }
[18:05:03.482]                       }
[18:05:03.482]                       invisible(muffled)
[18:05:03.482]                     }
[18:05:03.482]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.482]                   }
[18:05:03.482]                 }
[18:05:03.482]             }
[18:05:03.482]         }))
[18:05:03.482]     }, error = function(ex) {
[18:05:03.482]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:03.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.482]                 ...future.rng), started = ...future.startTime, 
[18:05:03.482]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:03.482]             version = "1.8"), class = "FutureResult")
[18:05:03.482]     }, finally = {
[18:05:03.482]         if (!identical(...future.workdir, getwd())) 
[18:05:03.482]             setwd(...future.workdir)
[18:05:03.482]         {
[18:05:03.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:03.482]                 ...future.oldOptions$nwarnings <- NULL
[18:05:03.482]             }
[18:05:03.482]             base::options(...future.oldOptions)
[18:05:03.482]             if (.Platform$OS.type == "windows") {
[18:05:03.482]                 old_names <- names(...future.oldEnvVars)
[18:05:03.482]                 envs <- base::Sys.getenv()
[18:05:03.482]                 names <- names(envs)
[18:05:03.482]                 common <- intersect(names, old_names)
[18:05:03.482]                 added <- setdiff(names, old_names)
[18:05:03.482]                 removed <- setdiff(old_names, names)
[18:05:03.482]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:03.482]                   envs[common]]
[18:05:03.482]                 NAMES <- toupper(changed)
[18:05:03.482]                 args <- list()
[18:05:03.482]                 for (kk in seq_along(NAMES)) {
[18:05:03.482]                   name <- changed[[kk]]
[18:05:03.482]                   NAME <- NAMES[[kk]]
[18:05:03.482]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.482]                     next
[18:05:03.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.482]                 }
[18:05:03.482]                 NAMES <- toupper(added)
[18:05:03.482]                 for (kk in seq_along(NAMES)) {
[18:05:03.482]                   name <- added[[kk]]
[18:05:03.482]                   NAME <- NAMES[[kk]]
[18:05:03.482]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.482]                     next
[18:05:03.482]                   args[[name]] <- ""
[18:05:03.482]                 }
[18:05:03.482]                 NAMES <- toupper(removed)
[18:05:03.482]                 for (kk in seq_along(NAMES)) {
[18:05:03.482]                   name <- removed[[kk]]
[18:05:03.482]                   NAME <- NAMES[[kk]]
[18:05:03.482]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.482]                     next
[18:05:03.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.482]                 }
[18:05:03.482]                 if (length(args) > 0) 
[18:05:03.482]                   base::do.call(base::Sys.setenv, args = args)
[18:05:03.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:03.482]             }
[18:05:03.482]             else {
[18:05:03.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:03.482]             }
[18:05:03.482]             {
[18:05:03.482]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:03.482]                   0L) {
[18:05:03.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:03.482]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:03.482]                   base::options(opts)
[18:05:03.482]                 }
[18:05:03.482]                 {
[18:05:03.482]                   {
[18:05:03.482]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:03.482]                     NULL
[18:05:03.482]                   }
[18:05:03.482]                   options(future.plan = NULL)
[18:05:03.482]                   if (is.na(NA_character_)) 
[18:05:03.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:03.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:03.482]                     .init = FALSE)
[18:05:03.482]                 }
[18:05:03.482]             }
[18:05:03.482]         }
[18:05:03.482]     })
[18:05:03.482]     if (TRUE) {
[18:05:03.482]         base::sink(type = "output", split = FALSE)
[18:05:03.482]         if (TRUE) {
[18:05:03.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:03.482]         }
[18:05:03.482]         else {
[18:05:03.482]             ...future.result["stdout"] <- base::list(NULL)
[18:05:03.482]         }
[18:05:03.482]         base::close(...future.stdout)
[18:05:03.482]         ...future.stdout <- NULL
[18:05:03.482]     }
[18:05:03.482]     ...future.result$conditions <- ...future.conditions
[18:05:03.482]     ...future.result$finished <- base::Sys.time()
[18:05:03.482]     ...future.result
[18:05:03.482] }
[18:05:03.488] MultisessionFuture started
[18:05:03.489] - Launch lazy future ... done
[18:05:03.489] run() for ‘MultisessionFuture’ ... done
[18:05:03.532] receiveMessageFromWorker() for ClusterFuture ...
[18:05:03.533] - Validating connection of MultisessionFuture
[18:05:03.533] - received message: FutureResult
[18:05:03.534] - Received FutureResult
[18:05:03.534] - Erased future from FutureRegistry
[18:05:03.534] result() for ClusterFuture ...
[18:05:03.535] - result already collected: FutureResult
[18:05:03.535] result() for ClusterFuture ... done
[18:05:03.535] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:03.535] Future #1
[18:05:03.536] result() for ClusterFuture ...
[18:05:03.536] - result already collected: FutureResult
[18:05:03.536] result() for ClusterFuture ... done
[18:05:03.536] result() for ClusterFuture ...
[18:05:03.537] - result already collected: FutureResult
[18:05:03.537] result() for ClusterFuture ... done
[18:05:03.537] A MultisessionFuture was resolved
[18:05:03.538]  length: 0 (resolved future 1)
[18:05:03.538] resolve() on list ... DONE
[18:05:03.538] - globals: [1] ‘a’
[18:05:03.538] Resolving futures part of globals (recursively) ... DONE
[18:05:03.544] The total size of the 1 globals is 1.57 MiB (1649832 bytes)
[18:05:03.545] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[18:05:03.545] - globals: [1] ‘a’
[18:05:03.546] - packages: [1] ‘future’
[18:05:03.546] getGlobalsAndPackages() ... DONE
[18:05:03.547] run() for ‘Future’ ...
[18:05:03.547] - state: ‘created’
[18:05:03.547] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:03.573] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:03.573] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:03.573]   - Field: ‘node’
[18:05:03.574]   - Field: ‘label’
[18:05:03.574]   - Field: ‘local’
[18:05:03.574]   - Field: ‘owner’
[18:05:03.574]   - Field: ‘envir’
[18:05:03.574]   - Field: ‘workers’
[18:05:03.575]   - Field: ‘packages’
[18:05:03.575]   - Field: ‘gc’
[18:05:03.575]   - Field: ‘conditions’
[18:05:03.575]   - Field: ‘persistent’
[18:05:03.576]   - Field: ‘expr’
[18:05:03.576]   - Field: ‘uuid’
[18:05:03.576]   - Field: ‘seed’
[18:05:03.576]   - Field: ‘version’
[18:05:03.576]   - Field: ‘result’
[18:05:03.577]   - Field: ‘asynchronous’
[18:05:03.577]   - Field: ‘calls’
[18:05:03.577]   - Field: ‘globals’
[18:05:03.577]   - Field: ‘stdout’
[18:05:03.577]   - Field: ‘earlySignal’
[18:05:03.578]   - Field: ‘lazy’
[18:05:03.578]   - Field: ‘state’
[18:05:03.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:03.578] - Launch lazy future ...
[18:05:03.579] Packages needed by the future expression (n = 1): ‘future’
[18:05:03.579] Packages needed by future strategies (n = 0): <none>
[18:05:03.580] {
[18:05:03.580]     {
[18:05:03.580]         {
[18:05:03.580]             ...future.startTime <- base::Sys.time()
[18:05:03.580]             {
[18:05:03.580]                 {
[18:05:03.580]                   {
[18:05:03.580]                     {
[18:05:03.580]                       {
[18:05:03.580]                         base::local({
[18:05:03.580]                           has_future <- base::requireNamespace("future", 
[18:05:03.580]                             quietly = TRUE)
[18:05:03.580]                           if (has_future) {
[18:05:03.580]                             ns <- base::getNamespace("future")
[18:05:03.580]                             version <- ns[[".package"]][["version"]]
[18:05:03.580]                             if (is.null(version)) 
[18:05:03.580]                               version <- utils::packageVersion("future")
[18:05:03.580]                           }
[18:05:03.580]                           else {
[18:05:03.580]                             version <- NULL
[18:05:03.580]                           }
[18:05:03.580]                           if (!has_future || version < "1.8.0") {
[18:05:03.580]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:03.580]                               "", base::R.version$version.string), 
[18:05:03.580]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:03.580]                                 base::R.version$platform, 8 * 
[18:05:03.580]                                   base::.Machine$sizeof.pointer), 
[18:05:03.580]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:03.580]                                 "release", "version")], collapse = " "), 
[18:05:03.580]                               hostname = base::Sys.info()[["nodename"]])
[18:05:03.580]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:03.580]                               info)
[18:05:03.580]                             info <- base::paste(info, collapse = "; ")
[18:05:03.580]                             if (!has_future) {
[18:05:03.580]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:03.580]                                 info)
[18:05:03.580]                             }
[18:05:03.580]                             else {
[18:05:03.580]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:03.580]                                 info, version)
[18:05:03.580]                             }
[18:05:03.580]                             base::stop(msg)
[18:05:03.580]                           }
[18:05:03.580]                         })
[18:05:03.580]                       }
[18:05:03.580]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:03.580]                       base::options(mc.cores = 1L)
[18:05:03.580]                     }
[18:05:03.580]                     base::local({
[18:05:03.580]                       for (pkg in "future") {
[18:05:03.580]                         base::loadNamespace(pkg)
[18:05:03.580]                         base::library(pkg, character.only = TRUE)
[18:05:03.580]                       }
[18:05:03.580]                     })
[18:05:03.580]                   }
[18:05:03.580]                   ...future.strategy.old <- future::plan("list")
[18:05:03.580]                   options(future.plan = NULL)
[18:05:03.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:03.580]                 }
[18:05:03.580]                 ...future.workdir <- getwd()
[18:05:03.580]             }
[18:05:03.580]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:03.580]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:03.580]         }
[18:05:03.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:03.580]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:03.580]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:03.580]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:03.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:03.580]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:03.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:03.580]             base::names(...future.oldOptions))
[18:05:03.580]     }
[18:05:03.580]     if (FALSE) {
[18:05:03.580]     }
[18:05:03.580]     else {
[18:05:03.580]         if (TRUE) {
[18:05:03.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:03.580]                 open = "w")
[18:05:03.580]         }
[18:05:03.580]         else {
[18:05:03.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:03.580]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:03.580]         }
[18:05:03.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:03.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:03.580]             base::sink(type = "output", split = FALSE)
[18:05:03.580]             base::close(...future.stdout)
[18:05:03.580]         }, add = TRUE)
[18:05:03.580]     }
[18:05:03.580]     ...future.frame <- base::sys.nframe()
[18:05:03.580]     ...future.conditions <- base::list()
[18:05:03.580]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:03.580]     if (FALSE) {
[18:05:03.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:03.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:03.580]     }
[18:05:03.580]     ...future.result <- base::tryCatch({
[18:05:03.580]         base::withCallingHandlers({
[18:05:03.580]             ...future.value <- base::withVisible(base::local({
[18:05:03.580]                 ...future.makeSendCondition <- base::local({
[18:05:03.580]                   sendCondition <- NULL
[18:05:03.580]                   function(frame = 1L) {
[18:05:03.580]                     if (is.function(sendCondition)) 
[18:05:03.580]                       return(sendCondition)
[18:05:03.580]                     ns <- getNamespace("parallel")
[18:05:03.580]                     if (exists("sendData", mode = "function", 
[18:05:03.580]                       envir = ns)) {
[18:05:03.580]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:03.580]                         envir = ns)
[18:05:03.580]                       envir <- sys.frame(frame)
[18:05:03.580]                       master <- NULL
[18:05:03.580]                       while (!identical(envir, .GlobalEnv) && 
[18:05:03.580]                         !identical(envir, emptyenv())) {
[18:05:03.580]                         if (exists("master", mode = "list", envir = envir, 
[18:05:03.580]                           inherits = FALSE)) {
[18:05:03.580]                           master <- get("master", mode = "list", 
[18:05:03.580]                             envir = envir, inherits = FALSE)
[18:05:03.580]                           if (inherits(master, c("SOCKnode", 
[18:05:03.580]                             "SOCK0node"))) {
[18:05:03.580]                             sendCondition <<- function(cond) {
[18:05:03.580]                               data <- list(type = "VALUE", value = cond, 
[18:05:03.580]                                 success = TRUE)
[18:05:03.580]                               parallel_sendData(master, data)
[18:05:03.580]                             }
[18:05:03.580]                             return(sendCondition)
[18:05:03.580]                           }
[18:05:03.580]                         }
[18:05:03.580]                         frame <- frame + 1L
[18:05:03.580]                         envir <- sys.frame(frame)
[18:05:03.580]                       }
[18:05:03.580]                     }
[18:05:03.580]                     sendCondition <<- function(cond) NULL
[18:05:03.580]                   }
[18:05:03.580]                 })
[18:05:03.580]                 withCallingHandlers({
[18:05:03.580]                   value(a) + 1
[18:05:03.580]                 }, immediateCondition = function(cond) {
[18:05:03.580]                   sendCondition <- ...future.makeSendCondition()
[18:05:03.580]                   sendCondition(cond)
[18:05:03.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.580]                   {
[18:05:03.580]                     inherits <- base::inherits
[18:05:03.580]                     invokeRestart <- base::invokeRestart
[18:05:03.580]                     is.null <- base::is.null
[18:05:03.580]                     muffled <- FALSE
[18:05:03.580]                     if (inherits(cond, "message")) {
[18:05:03.580]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:03.580]                       if (muffled) 
[18:05:03.580]                         invokeRestart("muffleMessage")
[18:05:03.580]                     }
[18:05:03.580]                     else if (inherits(cond, "warning")) {
[18:05:03.580]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:03.580]                       if (muffled) 
[18:05:03.580]                         invokeRestart("muffleWarning")
[18:05:03.580]                     }
[18:05:03.580]                     else if (inherits(cond, "condition")) {
[18:05:03.580]                       if (!is.null(pattern)) {
[18:05:03.580]                         computeRestarts <- base::computeRestarts
[18:05:03.580]                         grepl <- base::grepl
[18:05:03.580]                         restarts <- computeRestarts(cond)
[18:05:03.580]                         for (restart in restarts) {
[18:05:03.580]                           name <- restart$name
[18:05:03.580]                           if (is.null(name)) 
[18:05:03.580]                             next
[18:05:03.580]                           if (!grepl(pattern, name)) 
[18:05:03.580]                             next
[18:05:03.580]                           invokeRestart(restart)
[18:05:03.580]                           muffled <- TRUE
[18:05:03.580]                           break
[18:05:03.580]                         }
[18:05:03.580]                       }
[18:05:03.580]                     }
[18:05:03.580]                     invisible(muffled)
[18:05:03.580]                   }
[18:05:03.580]                   muffleCondition(cond)
[18:05:03.580]                 })
[18:05:03.580]             }))
[18:05:03.580]             future::FutureResult(value = ...future.value$value, 
[18:05:03.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.580]                   ...future.rng), globalenv = if (FALSE) 
[18:05:03.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:03.580]                     ...future.globalenv.names))
[18:05:03.580]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:03.580]         }, condition = base::local({
[18:05:03.580]             c <- base::c
[18:05:03.580]             inherits <- base::inherits
[18:05:03.580]             invokeRestart <- base::invokeRestart
[18:05:03.580]             length <- base::length
[18:05:03.580]             list <- base::list
[18:05:03.580]             seq.int <- base::seq.int
[18:05:03.580]             signalCondition <- base::signalCondition
[18:05:03.580]             sys.calls <- base::sys.calls
[18:05:03.580]             `[[` <- base::`[[`
[18:05:03.580]             `+` <- base::`+`
[18:05:03.580]             `<<-` <- base::`<<-`
[18:05:03.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:03.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:03.580]                   3L)]
[18:05:03.580]             }
[18:05:03.580]             function(cond) {
[18:05:03.580]                 is_error <- inherits(cond, "error")
[18:05:03.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:03.580]                   NULL)
[18:05:03.580]                 if (is_error) {
[18:05:03.580]                   sessionInformation <- function() {
[18:05:03.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:03.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:03.580]                       search = base::search(), system = base::Sys.info())
[18:05:03.580]                   }
[18:05:03.580]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:03.580]                     cond$call), session = sessionInformation(), 
[18:05:03.580]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:03.580]                   signalCondition(cond)
[18:05:03.580]                 }
[18:05:03.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:03.580]                 "immediateCondition"))) {
[18:05:03.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:03.580]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:03.580]                   if (TRUE && !signal) {
[18:05:03.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.580]                     {
[18:05:03.580]                       inherits <- base::inherits
[18:05:03.580]                       invokeRestart <- base::invokeRestart
[18:05:03.580]                       is.null <- base::is.null
[18:05:03.580]                       muffled <- FALSE
[18:05:03.580]                       if (inherits(cond, "message")) {
[18:05:03.580]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.580]                         if (muffled) 
[18:05:03.580]                           invokeRestart("muffleMessage")
[18:05:03.580]                       }
[18:05:03.580]                       else if (inherits(cond, "warning")) {
[18:05:03.580]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.580]                         if (muffled) 
[18:05:03.580]                           invokeRestart("muffleWarning")
[18:05:03.580]                       }
[18:05:03.580]                       else if (inherits(cond, "condition")) {
[18:05:03.580]                         if (!is.null(pattern)) {
[18:05:03.580]                           computeRestarts <- base::computeRestarts
[18:05:03.580]                           grepl <- base::grepl
[18:05:03.580]                           restarts <- computeRestarts(cond)
[18:05:03.580]                           for (restart in restarts) {
[18:05:03.580]                             name <- restart$name
[18:05:03.580]                             if (is.null(name)) 
[18:05:03.580]                               next
[18:05:03.580]                             if (!grepl(pattern, name)) 
[18:05:03.580]                               next
[18:05:03.580]                             invokeRestart(restart)
[18:05:03.580]                             muffled <- TRUE
[18:05:03.580]                             break
[18:05:03.580]                           }
[18:05:03.580]                         }
[18:05:03.580]                       }
[18:05:03.580]                       invisible(muffled)
[18:05:03.580]                     }
[18:05:03.580]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.580]                   }
[18:05:03.580]                 }
[18:05:03.580]                 else {
[18:05:03.580]                   if (TRUE) {
[18:05:03.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.580]                     {
[18:05:03.580]                       inherits <- base::inherits
[18:05:03.580]                       invokeRestart <- base::invokeRestart
[18:05:03.580]                       is.null <- base::is.null
[18:05:03.580]                       muffled <- FALSE
[18:05:03.580]                       if (inherits(cond, "message")) {
[18:05:03.580]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.580]                         if (muffled) 
[18:05:03.580]                           invokeRestart("muffleMessage")
[18:05:03.580]                       }
[18:05:03.580]                       else if (inherits(cond, "warning")) {
[18:05:03.580]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.580]                         if (muffled) 
[18:05:03.580]                           invokeRestart("muffleWarning")
[18:05:03.580]                       }
[18:05:03.580]                       else if (inherits(cond, "condition")) {
[18:05:03.580]                         if (!is.null(pattern)) {
[18:05:03.580]                           computeRestarts <- base::computeRestarts
[18:05:03.580]                           grepl <- base::grepl
[18:05:03.580]                           restarts <- computeRestarts(cond)
[18:05:03.580]                           for (restart in restarts) {
[18:05:03.580]                             name <- restart$name
[18:05:03.580]                             if (is.null(name)) 
[18:05:03.580]                               next
[18:05:03.580]                             if (!grepl(pattern, name)) 
[18:05:03.580]                               next
[18:05:03.580]                             invokeRestart(restart)
[18:05:03.580]                             muffled <- TRUE
[18:05:03.580]                             break
[18:05:03.580]                           }
[18:05:03.580]                         }
[18:05:03.580]                       }
[18:05:03.580]                       invisible(muffled)
[18:05:03.580]                     }
[18:05:03.580]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.580]                   }
[18:05:03.580]                 }
[18:05:03.580]             }
[18:05:03.580]         }))
[18:05:03.580]     }, error = function(ex) {
[18:05:03.580]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:03.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.580]                 ...future.rng), started = ...future.startTime, 
[18:05:03.580]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:03.580]             version = "1.8"), class = "FutureResult")
[18:05:03.580]     }, finally = {
[18:05:03.580]         if (!identical(...future.workdir, getwd())) 
[18:05:03.580]             setwd(...future.workdir)
[18:05:03.580]         {
[18:05:03.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:03.580]                 ...future.oldOptions$nwarnings <- NULL
[18:05:03.580]             }
[18:05:03.580]             base::options(...future.oldOptions)
[18:05:03.580]             if (.Platform$OS.type == "windows") {
[18:05:03.580]                 old_names <- names(...future.oldEnvVars)
[18:05:03.580]                 envs <- base::Sys.getenv()
[18:05:03.580]                 names <- names(envs)
[18:05:03.580]                 common <- intersect(names, old_names)
[18:05:03.580]                 added <- setdiff(names, old_names)
[18:05:03.580]                 removed <- setdiff(old_names, names)
[18:05:03.580]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:03.580]                   envs[common]]
[18:05:03.580]                 NAMES <- toupper(changed)
[18:05:03.580]                 args <- list()
[18:05:03.580]                 for (kk in seq_along(NAMES)) {
[18:05:03.580]                   name <- changed[[kk]]
[18:05:03.580]                   NAME <- NAMES[[kk]]
[18:05:03.580]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.580]                     next
[18:05:03.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.580]                 }
[18:05:03.580]                 NAMES <- toupper(added)
[18:05:03.580]                 for (kk in seq_along(NAMES)) {
[18:05:03.580]                   name <- added[[kk]]
[18:05:03.580]                   NAME <- NAMES[[kk]]
[18:05:03.580]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.580]                     next
[18:05:03.580]                   args[[name]] <- ""
[18:05:03.580]                 }
[18:05:03.580]                 NAMES <- toupper(removed)
[18:05:03.580]                 for (kk in seq_along(NAMES)) {
[18:05:03.580]                   name <- removed[[kk]]
[18:05:03.580]                   NAME <- NAMES[[kk]]
[18:05:03.580]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.580]                     next
[18:05:03.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.580]                 }
[18:05:03.580]                 if (length(args) > 0) 
[18:05:03.580]                   base::do.call(base::Sys.setenv, args = args)
[18:05:03.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:03.580]             }
[18:05:03.580]             else {
[18:05:03.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:03.580]             }
[18:05:03.580]             {
[18:05:03.580]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:03.580]                   0L) {
[18:05:03.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:03.580]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:03.580]                   base::options(opts)
[18:05:03.580]                 }
[18:05:03.580]                 {
[18:05:03.580]                   {
[18:05:03.580]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:03.580]                     NULL
[18:05:03.580]                   }
[18:05:03.580]                   options(future.plan = NULL)
[18:05:03.580]                   if (is.na(NA_character_)) 
[18:05:03.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:03.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:03.580]                     .init = FALSE)
[18:05:03.580]                 }
[18:05:03.580]             }
[18:05:03.580]         }
[18:05:03.580]     })
[18:05:03.580]     if (TRUE) {
[18:05:03.580]         base::sink(type = "output", split = FALSE)
[18:05:03.580]         if (TRUE) {
[18:05:03.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:03.580]         }
[18:05:03.580]         else {
[18:05:03.580]             ...future.result["stdout"] <- base::list(NULL)
[18:05:03.580]         }
[18:05:03.580]         base::close(...future.stdout)
[18:05:03.580]         ...future.stdout <- NULL
[18:05:03.580]     }
[18:05:03.580]     ...future.result$conditions <- ...future.conditions
[18:05:03.580]     ...future.result$finished <- base::Sys.time()
[18:05:03.580]     ...future.result
[18:05:03.580] }
[18:05:03.585] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[18:05:03.590] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[18:05:03.651] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[18:05:03.651] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[18:05:03.652] MultisessionFuture started
[18:05:03.652] - Launch lazy future ... done
[18:05:03.652] run() for ‘MultisessionFuture’ ... done
[18:05:03.653] result() for ClusterFuture ...
[18:05:03.653] receiveMessageFromWorker() for ClusterFuture ...
[18:05:03.653] - Validating connection of MultisessionFuture
[18:05:03.697] - received message: FutureResult
[18:05:03.697] - Received FutureResult
[18:05:03.698] - Erased future from FutureRegistry
[18:05:03.698] result() for ClusterFuture ...
[18:05:03.698] - result already collected: FutureResult
[18:05:03.698] result() for ClusterFuture ... done
[18:05:03.698] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:03.699] result() for ClusterFuture ... done
[18:05:03.699] result() for ClusterFuture ...
[18:05:03.699] - result already collected: FutureResult
[18:05:03.699] result() for ClusterFuture ... done
value(b) = 2
[18:05:03.700] result() for ClusterFuture ...
[18:05:03.700] - result already collected: FutureResult
[18:05:03.700] result() for ClusterFuture ... done
[18:05:03.700] result() for ClusterFuture ...
[18:05:03.701] - result already collected: FutureResult
[18:05:03.701] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:03.701] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:03.702] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:03.704] - globals found: [2] ‘{’, ‘pkg’
[18:05:03.704] Searching for globals ... DONE
[18:05:03.704] Resolving globals: TRUE
[18:05:03.704] Resolving any globals that are futures ...
[18:05:03.705] - globals: [2] ‘{’, ‘pkg’
[18:05:03.705] Resolving any globals that are futures ... DONE
[18:05:03.706] Resolving futures part of globals (recursively) ...
[18:05:03.706] resolve() on list ...
[18:05:03.706]  recursive: 99
[18:05:03.706]  length: 1
[18:05:03.707]  elements: ‘pkg’
[18:05:03.707]  length: 0 (resolved future 1)
[18:05:03.707] resolve() on list ... DONE
[18:05:03.707] - globals: [1] ‘pkg’
[18:05:03.708] Resolving futures part of globals (recursively) ... DONE
[18:05:03.708] The total size of the 1 globals is 112 bytes (112 bytes)
[18:05:03.709] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[18:05:03.709] - globals: [1] ‘pkg’
[18:05:03.709] 
[18:05:03.709] getGlobalsAndPackages() ... DONE
[18:05:03.710] Packages needed by the future expression (n = 0): <none>
[18:05:03.710] Packages needed by future strategies (n = 0): <none>
[18:05:03.711] {
[18:05:03.711]     {
[18:05:03.711]         {
[18:05:03.711]             ...future.startTime <- base::Sys.time()
[18:05:03.711]             {
[18:05:03.711]                 {
[18:05:03.711]                   {
[18:05:03.711]                     base::local({
[18:05:03.711]                       has_future <- base::requireNamespace("future", 
[18:05:03.711]                         quietly = TRUE)
[18:05:03.711]                       if (has_future) {
[18:05:03.711]                         ns <- base::getNamespace("future")
[18:05:03.711]                         version <- ns[[".package"]][["version"]]
[18:05:03.711]                         if (is.null(version)) 
[18:05:03.711]                           version <- utils::packageVersion("future")
[18:05:03.711]                       }
[18:05:03.711]                       else {
[18:05:03.711]                         version <- NULL
[18:05:03.711]                       }
[18:05:03.711]                       if (!has_future || version < "1.8.0") {
[18:05:03.711]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:03.711]                           "", base::R.version$version.string), 
[18:05:03.711]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:03.711]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:03.711]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:03.711]                             "release", "version")], collapse = " "), 
[18:05:03.711]                           hostname = base::Sys.info()[["nodename"]])
[18:05:03.711]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:03.711]                           info)
[18:05:03.711]                         info <- base::paste(info, collapse = "; ")
[18:05:03.711]                         if (!has_future) {
[18:05:03.711]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:03.711]                             info)
[18:05:03.711]                         }
[18:05:03.711]                         else {
[18:05:03.711]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:03.711]                             info, version)
[18:05:03.711]                         }
[18:05:03.711]                         base::stop(msg)
[18:05:03.711]                       }
[18:05:03.711]                     })
[18:05:03.711]                   }
[18:05:03.711]                   ...future.strategy.old <- future::plan("list")
[18:05:03.711]                   options(future.plan = NULL)
[18:05:03.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:03.711]                 }
[18:05:03.711]                 ...future.workdir <- getwd()
[18:05:03.711]             }
[18:05:03.711]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:03.711]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:03.711]         }
[18:05:03.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:03.711]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:03.711]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:03.711]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:03.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:03.711]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:03.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:03.711]             base::names(...future.oldOptions))
[18:05:03.711]     }
[18:05:03.711]     if (FALSE) {
[18:05:03.711]     }
[18:05:03.711]     else {
[18:05:03.711]         if (TRUE) {
[18:05:03.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:03.711]                 open = "w")
[18:05:03.711]         }
[18:05:03.711]         else {
[18:05:03.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:03.711]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:03.711]         }
[18:05:03.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:03.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:03.711]             base::sink(type = "output", split = FALSE)
[18:05:03.711]             base::close(...future.stdout)
[18:05:03.711]         }, add = TRUE)
[18:05:03.711]     }
[18:05:03.711]     ...future.frame <- base::sys.nframe()
[18:05:03.711]     ...future.conditions <- base::list()
[18:05:03.711]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:03.711]     if (FALSE) {
[18:05:03.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:03.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:03.711]     }
[18:05:03.711]     ...future.result <- base::tryCatch({
[18:05:03.711]         base::withCallingHandlers({
[18:05:03.711]             ...future.value <- base::withVisible(base::local({
[18:05:03.711]                 pkg
[18:05:03.711]             }))
[18:05:03.711]             future::FutureResult(value = ...future.value$value, 
[18:05:03.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.711]                   ...future.rng), globalenv = if (FALSE) 
[18:05:03.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:03.711]                     ...future.globalenv.names))
[18:05:03.711]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:03.711]         }, condition = base::local({
[18:05:03.711]             c <- base::c
[18:05:03.711]             inherits <- base::inherits
[18:05:03.711]             invokeRestart <- base::invokeRestart
[18:05:03.711]             length <- base::length
[18:05:03.711]             list <- base::list
[18:05:03.711]             seq.int <- base::seq.int
[18:05:03.711]             signalCondition <- base::signalCondition
[18:05:03.711]             sys.calls <- base::sys.calls
[18:05:03.711]             `[[` <- base::`[[`
[18:05:03.711]             `+` <- base::`+`
[18:05:03.711]             `<<-` <- base::`<<-`
[18:05:03.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:03.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:03.711]                   3L)]
[18:05:03.711]             }
[18:05:03.711]             function(cond) {
[18:05:03.711]                 is_error <- inherits(cond, "error")
[18:05:03.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:03.711]                   NULL)
[18:05:03.711]                 if (is_error) {
[18:05:03.711]                   sessionInformation <- function() {
[18:05:03.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:03.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:03.711]                       search = base::search(), system = base::Sys.info())
[18:05:03.711]                   }
[18:05:03.711]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:03.711]                     cond$call), session = sessionInformation(), 
[18:05:03.711]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:03.711]                   signalCondition(cond)
[18:05:03.711]                 }
[18:05:03.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:03.711]                 "immediateCondition"))) {
[18:05:03.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:03.711]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:03.711]                   if (TRUE && !signal) {
[18:05:03.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.711]                     {
[18:05:03.711]                       inherits <- base::inherits
[18:05:03.711]                       invokeRestart <- base::invokeRestart
[18:05:03.711]                       is.null <- base::is.null
[18:05:03.711]                       muffled <- FALSE
[18:05:03.711]                       if (inherits(cond, "message")) {
[18:05:03.711]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.711]                         if (muffled) 
[18:05:03.711]                           invokeRestart("muffleMessage")
[18:05:03.711]                       }
[18:05:03.711]                       else if (inherits(cond, "warning")) {
[18:05:03.711]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.711]                         if (muffled) 
[18:05:03.711]                           invokeRestart("muffleWarning")
[18:05:03.711]                       }
[18:05:03.711]                       else if (inherits(cond, "condition")) {
[18:05:03.711]                         if (!is.null(pattern)) {
[18:05:03.711]                           computeRestarts <- base::computeRestarts
[18:05:03.711]                           grepl <- base::grepl
[18:05:03.711]                           restarts <- computeRestarts(cond)
[18:05:03.711]                           for (restart in restarts) {
[18:05:03.711]                             name <- restart$name
[18:05:03.711]                             if (is.null(name)) 
[18:05:03.711]                               next
[18:05:03.711]                             if (!grepl(pattern, name)) 
[18:05:03.711]                               next
[18:05:03.711]                             invokeRestart(restart)
[18:05:03.711]                             muffled <- TRUE
[18:05:03.711]                             break
[18:05:03.711]                           }
[18:05:03.711]                         }
[18:05:03.711]                       }
[18:05:03.711]                       invisible(muffled)
[18:05:03.711]                     }
[18:05:03.711]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.711]                   }
[18:05:03.711]                 }
[18:05:03.711]                 else {
[18:05:03.711]                   if (TRUE) {
[18:05:03.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.711]                     {
[18:05:03.711]                       inherits <- base::inherits
[18:05:03.711]                       invokeRestart <- base::invokeRestart
[18:05:03.711]                       is.null <- base::is.null
[18:05:03.711]                       muffled <- FALSE
[18:05:03.711]                       if (inherits(cond, "message")) {
[18:05:03.711]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.711]                         if (muffled) 
[18:05:03.711]                           invokeRestart("muffleMessage")
[18:05:03.711]                       }
[18:05:03.711]                       else if (inherits(cond, "warning")) {
[18:05:03.711]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.711]                         if (muffled) 
[18:05:03.711]                           invokeRestart("muffleWarning")
[18:05:03.711]                       }
[18:05:03.711]                       else if (inherits(cond, "condition")) {
[18:05:03.711]                         if (!is.null(pattern)) {
[18:05:03.711]                           computeRestarts <- base::computeRestarts
[18:05:03.711]                           grepl <- base::grepl
[18:05:03.711]                           restarts <- computeRestarts(cond)
[18:05:03.711]                           for (restart in restarts) {
[18:05:03.711]                             name <- restart$name
[18:05:03.711]                             if (is.null(name)) 
[18:05:03.711]                               next
[18:05:03.711]                             if (!grepl(pattern, name)) 
[18:05:03.711]                               next
[18:05:03.711]                             invokeRestart(restart)
[18:05:03.711]                             muffled <- TRUE
[18:05:03.711]                             break
[18:05:03.711]                           }
[18:05:03.711]                         }
[18:05:03.711]                       }
[18:05:03.711]                       invisible(muffled)
[18:05:03.711]                     }
[18:05:03.711]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.711]                   }
[18:05:03.711]                 }
[18:05:03.711]             }
[18:05:03.711]         }))
[18:05:03.711]     }, error = function(ex) {
[18:05:03.711]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:03.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.711]                 ...future.rng), started = ...future.startTime, 
[18:05:03.711]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:03.711]             version = "1.8"), class = "FutureResult")
[18:05:03.711]     }, finally = {
[18:05:03.711]         if (!identical(...future.workdir, getwd())) 
[18:05:03.711]             setwd(...future.workdir)
[18:05:03.711]         {
[18:05:03.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:03.711]                 ...future.oldOptions$nwarnings <- NULL
[18:05:03.711]             }
[18:05:03.711]             base::options(...future.oldOptions)
[18:05:03.711]             if (.Platform$OS.type == "windows") {
[18:05:03.711]                 old_names <- names(...future.oldEnvVars)
[18:05:03.711]                 envs <- base::Sys.getenv()
[18:05:03.711]                 names <- names(envs)
[18:05:03.711]                 common <- intersect(names, old_names)
[18:05:03.711]                 added <- setdiff(names, old_names)
[18:05:03.711]                 removed <- setdiff(old_names, names)
[18:05:03.711]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:03.711]                   envs[common]]
[18:05:03.711]                 NAMES <- toupper(changed)
[18:05:03.711]                 args <- list()
[18:05:03.711]                 for (kk in seq_along(NAMES)) {
[18:05:03.711]                   name <- changed[[kk]]
[18:05:03.711]                   NAME <- NAMES[[kk]]
[18:05:03.711]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.711]                     next
[18:05:03.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.711]                 }
[18:05:03.711]                 NAMES <- toupper(added)
[18:05:03.711]                 for (kk in seq_along(NAMES)) {
[18:05:03.711]                   name <- added[[kk]]
[18:05:03.711]                   NAME <- NAMES[[kk]]
[18:05:03.711]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.711]                     next
[18:05:03.711]                   args[[name]] <- ""
[18:05:03.711]                 }
[18:05:03.711]                 NAMES <- toupper(removed)
[18:05:03.711]                 for (kk in seq_along(NAMES)) {
[18:05:03.711]                   name <- removed[[kk]]
[18:05:03.711]                   NAME <- NAMES[[kk]]
[18:05:03.711]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.711]                     next
[18:05:03.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.711]                 }
[18:05:03.711]                 if (length(args) > 0) 
[18:05:03.711]                   base::do.call(base::Sys.setenv, args = args)
[18:05:03.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:03.711]             }
[18:05:03.711]             else {
[18:05:03.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:03.711]             }
[18:05:03.711]             {
[18:05:03.711]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:03.711]                   0L) {
[18:05:03.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:03.711]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:03.711]                   base::options(opts)
[18:05:03.711]                 }
[18:05:03.711]                 {
[18:05:03.711]                   {
[18:05:03.711]                     NULL
[18:05:03.711]                     RNGkind("Mersenne-Twister")
[18:05:03.711]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:03.711]                       inherits = FALSE)
[18:05:03.711]                   }
[18:05:03.711]                   options(future.plan = NULL)
[18:05:03.711]                   if (is.na(NA_character_)) 
[18:05:03.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:03.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:03.711]                     .init = FALSE)
[18:05:03.711]                 }
[18:05:03.711]             }
[18:05:03.711]         }
[18:05:03.711]     })
[18:05:03.711]     if (TRUE) {
[18:05:03.711]         base::sink(type = "output", split = FALSE)
[18:05:03.711]         if (TRUE) {
[18:05:03.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:03.711]         }
[18:05:03.711]         else {
[18:05:03.711]             ...future.result["stdout"] <- base::list(NULL)
[18:05:03.711]         }
[18:05:03.711]         base::close(...future.stdout)
[18:05:03.711]         ...future.stdout <- NULL
[18:05:03.711]     }
[18:05:03.711]     ...future.result$conditions <- ...future.conditions
[18:05:03.711]     ...future.result$finished <- base::Sys.time()
[18:05:03.711]     ...future.result
[18:05:03.711] }
[18:05:03.715] assign_globals() ...
[18:05:03.715] List of 1
[18:05:03.715]  $ pkg: chr "foo"
[18:05:03.715]  - attr(*, "where")=List of 1
[18:05:03.715]   ..$ pkg:<environment: R_EmptyEnv> 
[18:05:03.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:03.715]  - attr(*, "resolved")= logi TRUE
[18:05:03.715]  - attr(*, "total_size")= num 112
[18:05:03.720] - copied ‘pkg’ to environment
[18:05:03.720] assign_globals() ... done
[18:05:03.721] plan(): Setting new future strategy stack:
[18:05:03.721] List of future strategies:
[18:05:03.721] 1. sequential:
[18:05:03.721]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:03.721]    - tweaked: FALSE
[18:05:03.721]    - call: NULL
[18:05:03.722] plan(): nbrOfWorkers() = 1
[18:05:03.724] plan(): Setting new future strategy stack:
[18:05:03.724] List of future strategies:
[18:05:03.724] 1. multisession:
[18:05:03.724]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:03.724]    - tweaked: FALSE
[18:05:03.724]    - call: plan(strategy)
[18:05:03.731] plan(): nbrOfWorkers() = 2
[18:05:03.731] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:03.732] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:03.733] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:03.737] - globals found: [3] ‘{’, ‘<-’, ‘+’
[18:05:03.737] Searching for globals ... DONE
[18:05:03.737] Resolving globals: TRUE
[18:05:03.737] Resolving any globals that are futures ...
[18:05:03.738] - globals: [3] ‘{’, ‘<-’, ‘+’
[18:05:03.738] Resolving any globals that are futures ... DONE
[18:05:03.738] 
[18:05:03.739] 
[18:05:03.739] getGlobalsAndPackages() ... DONE
[18:05:03.739] run() for ‘Future’ ...
[18:05:03.740] - state: ‘created’
[18:05:03.740] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:03.763] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:03.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:03.764]   - Field: ‘node’
[18:05:03.764]   - Field: ‘label’
[18:05:03.764]   - Field: ‘local’
[18:05:03.765]   - Field: ‘owner’
[18:05:03.765]   - Field: ‘envir’
[18:05:03.765]   - Field: ‘workers’
[18:05:03.765]   - Field: ‘packages’
[18:05:03.765]   - Field: ‘gc’
[18:05:03.766]   - Field: ‘conditions’
[18:05:03.766]   - Field: ‘persistent’
[18:05:03.766]   - Field: ‘expr’
[18:05:03.766]   - Field: ‘uuid’
[18:05:03.766]   - Field: ‘seed’
[18:05:03.766]   - Field: ‘version’
[18:05:03.767]   - Field: ‘result’
[18:05:03.767]   - Field: ‘asynchronous’
[18:05:03.767]   - Field: ‘calls’
[18:05:03.767]   - Field: ‘globals’
[18:05:03.767]   - Field: ‘stdout’
[18:05:03.768]   - Field: ‘earlySignal’
[18:05:03.768]   - Field: ‘lazy’
[18:05:03.768]   - Field: ‘state’
[18:05:03.768] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:03.769] - Launch lazy future ...
[18:05:03.769] Packages needed by the future expression (n = 0): <none>
[18:05:03.769] Packages needed by future strategies (n = 0): <none>
[18:05:03.770] {
[18:05:03.770]     {
[18:05:03.770]         {
[18:05:03.770]             ...future.startTime <- base::Sys.time()
[18:05:03.770]             {
[18:05:03.770]                 {
[18:05:03.770]                   {
[18:05:03.770]                     {
[18:05:03.770]                       base::local({
[18:05:03.770]                         has_future <- base::requireNamespace("future", 
[18:05:03.770]                           quietly = TRUE)
[18:05:03.770]                         if (has_future) {
[18:05:03.770]                           ns <- base::getNamespace("future")
[18:05:03.770]                           version <- ns[[".package"]][["version"]]
[18:05:03.770]                           if (is.null(version)) 
[18:05:03.770]                             version <- utils::packageVersion("future")
[18:05:03.770]                         }
[18:05:03.770]                         else {
[18:05:03.770]                           version <- NULL
[18:05:03.770]                         }
[18:05:03.770]                         if (!has_future || version < "1.8.0") {
[18:05:03.770]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:03.770]                             "", base::R.version$version.string), 
[18:05:03.770]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:03.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:03.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:03.770]                               "release", "version")], collapse = " "), 
[18:05:03.770]                             hostname = base::Sys.info()[["nodename"]])
[18:05:03.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:03.770]                             info)
[18:05:03.770]                           info <- base::paste(info, collapse = "; ")
[18:05:03.770]                           if (!has_future) {
[18:05:03.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:03.770]                               info)
[18:05:03.770]                           }
[18:05:03.770]                           else {
[18:05:03.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:03.770]                               info, version)
[18:05:03.770]                           }
[18:05:03.770]                           base::stop(msg)
[18:05:03.770]                         }
[18:05:03.770]                       })
[18:05:03.770]                     }
[18:05:03.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:03.770]                     base::options(mc.cores = 1L)
[18:05:03.770]                   }
[18:05:03.770]                   ...future.strategy.old <- future::plan("list")
[18:05:03.770]                   options(future.plan = NULL)
[18:05:03.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:03.770]                 }
[18:05:03.770]                 ...future.workdir <- getwd()
[18:05:03.770]             }
[18:05:03.770]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:03.770]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:03.770]         }
[18:05:03.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:03.770]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:03.770]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:03.770]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:03.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:03.770]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:03.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:03.770]             base::names(...future.oldOptions))
[18:05:03.770]     }
[18:05:03.770]     if (FALSE) {
[18:05:03.770]     }
[18:05:03.770]     else {
[18:05:03.770]         if (TRUE) {
[18:05:03.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:03.770]                 open = "w")
[18:05:03.770]         }
[18:05:03.770]         else {
[18:05:03.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:03.770]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:03.770]         }
[18:05:03.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:03.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:03.770]             base::sink(type = "output", split = FALSE)
[18:05:03.770]             base::close(...future.stdout)
[18:05:03.770]         }, add = TRUE)
[18:05:03.770]     }
[18:05:03.770]     ...future.frame <- base::sys.nframe()
[18:05:03.770]     ...future.conditions <- base::list()
[18:05:03.770]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:03.770]     if (FALSE) {
[18:05:03.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:03.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:03.770]     }
[18:05:03.770]     ...future.result <- base::tryCatch({
[18:05:03.770]         base::withCallingHandlers({
[18:05:03.770]             ...future.value <- base::withVisible(base::local({
[18:05:03.770]                 ...future.makeSendCondition <- base::local({
[18:05:03.770]                   sendCondition <- NULL
[18:05:03.770]                   function(frame = 1L) {
[18:05:03.770]                     if (is.function(sendCondition)) 
[18:05:03.770]                       return(sendCondition)
[18:05:03.770]                     ns <- getNamespace("parallel")
[18:05:03.770]                     if (exists("sendData", mode = "function", 
[18:05:03.770]                       envir = ns)) {
[18:05:03.770]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:03.770]                         envir = ns)
[18:05:03.770]                       envir <- sys.frame(frame)
[18:05:03.770]                       master <- NULL
[18:05:03.770]                       while (!identical(envir, .GlobalEnv) && 
[18:05:03.770]                         !identical(envir, emptyenv())) {
[18:05:03.770]                         if (exists("master", mode = "list", envir = envir, 
[18:05:03.770]                           inherits = FALSE)) {
[18:05:03.770]                           master <- get("master", mode = "list", 
[18:05:03.770]                             envir = envir, inherits = FALSE)
[18:05:03.770]                           if (inherits(master, c("SOCKnode", 
[18:05:03.770]                             "SOCK0node"))) {
[18:05:03.770]                             sendCondition <<- function(cond) {
[18:05:03.770]                               data <- list(type = "VALUE", value = cond, 
[18:05:03.770]                                 success = TRUE)
[18:05:03.770]                               parallel_sendData(master, data)
[18:05:03.770]                             }
[18:05:03.770]                             return(sendCondition)
[18:05:03.770]                           }
[18:05:03.770]                         }
[18:05:03.770]                         frame <- frame + 1L
[18:05:03.770]                         envir <- sys.frame(frame)
[18:05:03.770]                       }
[18:05:03.770]                     }
[18:05:03.770]                     sendCondition <<- function(cond) NULL
[18:05:03.770]                   }
[18:05:03.770]                 })
[18:05:03.770]                 withCallingHandlers({
[18:05:03.770]                   {
[18:05:03.770]                     x <- 0
[18:05:03.770]                     x <- x + 1
[18:05:03.770]                     x
[18:05:03.770]                   }
[18:05:03.770]                 }, immediateCondition = function(cond) {
[18:05:03.770]                   sendCondition <- ...future.makeSendCondition()
[18:05:03.770]                   sendCondition(cond)
[18:05:03.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.770]                   {
[18:05:03.770]                     inherits <- base::inherits
[18:05:03.770]                     invokeRestart <- base::invokeRestart
[18:05:03.770]                     is.null <- base::is.null
[18:05:03.770]                     muffled <- FALSE
[18:05:03.770]                     if (inherits(cond, "message")) {
[18:05:03.770]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:03.770]                       if (muffled) 
[18:05:03.770]                         invokeRestart("muffleMessage")
[18:05:03.770]                     }
[18:05:03.770]                     else if (inherits(cond, "warning")) {
[18:05:03.770]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:03.770]                       if (muffled) 
[18:05:03.770]                         invokeRestart("muffleWarning")
[18:05:03.770]                     }
[18:05:03.770]                     else if (inherits(cond, "condition")) {
[18:05:03.770]                       if (!is.null(pattern)) {
[18:05:03.770]                         computeRestarts <- base::computeRestarts
[18:05:03.770]                         grepl <- base::grepl
[18:05:03.770]                         restarts <- computeRestarts(cond)
[18:05:03.770]                         for (restart in restarts) {
[18:05:03.770]                           name <- restart$name
[18:05:03.770]                           if (is.null(name)) 
[18:05:03.770]                             next
[18:05:03.770]                           if (!grepl(pattern, name)) 
[18:05:03.770]                             next
[18:05:03.770]                           invokeRestart(restart)
[18:05:03.770]                           muffled <- TRUE
[18:05:03.770]                           break
[18:05:03.770]                         }
[18:05:03.770]                       }
[18:05:03.770]                     }
[18:05:03.770]                     invisible(muffled)
[18:05:03.770]                   }
[18:05:03.770]                   muffleCondition(cond)
[18:05:03.770]                 })
[18:05:03.770]             }))
[18:05:03.770]             future::FutureResult(value = ...future.value$value, 
[18:05:03.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.770]                   ...future.rng), globalenv = if (FALSE) 
[18:05:03.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:03.770]                     ...future.globalenv.names))
[18:05:03.770]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:03.770]         }, condition = base::local({
[18:05:03.770]             c <- base::c
[18:05:03.770]             inherits <- base::inherits
[18:05:03.770]             invokeRestart <- base::invokeRestart
[18:05:03.770]             length <- base::length
[18:05:03.770]             list <- base::list
[18:05:03.770]             seq.int <- base::seq.int
[18:05:03.770]             signalCondition <- base::signalCondition
[18:05:03.770]             sys.calls <- base::sys.calls
[18:05:03.770]             `[[` <- base::`[[`
[18:05:03.770]             `+` <- base::`+`
[18:05:03.770]             `<<-` <- base::`<<-`
[18:05:03.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:03.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:03.770]                   3L)]
[18:05:03.770]             }
[18:05:03.770]             function(cond) {
[18:05:03.770]                 is_error <- inherits(cond, "error")
[18:05:03.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:03.770]                   NULL)
[18:05:03.770]                 if (is_error) {
[18:05:03.770]                   sessionInformation <- function() {
[18:05:03.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:03.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:03.770]                       search = base::search(), system = base::Sys.info())
[18:05:03.770]                   }
[18:05:03.770]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:03.770]                     cond$call), session = sessionInformation(), 
[18:05:03.770]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:03.770]                   signalCondition(cond)
[18:05:03.770]                 }
[18:05:03.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:03.770]                 "immediateCondition"))) {
[18:05:03.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:03.770]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:03.770]                   if (TRUE && !signal) {
[18:05:03.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.770]                     {
[18:05:03.770]                       inherits <- base::inherits
[18:05:03.770]                       invokeRestart <- base::invokeRestart
[18:05:03.770]                       is.null <- base::is.null
[18:05:03.770]                       muffled <- FALSE
[18:05:03.770]                       if (inherits(cond, "message")) {
[18:05:03.770]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.770]                         if (muffled) 
[18:05:03.770]                           invokeRestart("muffleMessage")
[18:05:03.770]                       }
[18:05:03.770]                       else if (inherits(cond, "warning")) {
[18:05:03.770]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.770]                         if (muffled) 
[18:05:03.770]                           invokeRestart("muffleWarning")
[18:05:03.770]                       }
[18:05:03.770]                       else if (inherits(cond, "condition")) {
[18:05:03.770]                         if (!is.null(pattern)) {
[18:05:03.770]                           computeRestarts <- base::computeRestarts
[18:05:03.770]                           grepl <- base::grepl
[18:05:03.770]                           restarts <- computeRestarts(cond)
[18:05:03.770]                           for (restart in restarts) {
[18:05:03.770]                             name <- restart$name
[18:05:03.770]                             if (is.null(name)) 
[18:05:03.770]                               next
[18:05:03.770]                             if (!grepl(pattern, name)) 
[18:05:03.770]                               next
[18:05:03.770]                             invokeRestart(restart)
[18:05:03.770]                             muffled <- TRUE
[18:05:03.770]                             break
[18:05:03.770]                           }
[18:05:03.770]                         }
[18:05:03.770]                       }
[18:05:03.770]                       invisible(muffled)
[18:05:03.770]                     }
[18:05:03.770]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.770]                   }
[18:05:03.770]                 }
[18:05:03.770]                 else {
[18:05:03.770]                   if (TRUE) {
[18:05:03.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.770]                     {
[18:05:03.770]                       inherits <- base::inherits
[18:05:03.770]                       invokeRestart <- base::invokeRestart
[18:05:03.770]                       is.null <- base::is.null
[18:05:03.770]                       muffled <- FALSE
[18:05:03.770]                       if (inherits(cond, "message")) {
[18:05:03.770]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.770]                         if (muffled) 
[18:05:03.770]                           invokeRestart("muffleMessage")
[18:05:03.770]                       }
[18:05:03.770]                       else if (inherits(cond, "warning")) {
[18:05:03.770]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.770]                         if (muffled) 
[18:05:03.770]                           invokeRestart("muffleWarning")
[18:05:03.770]                       }
[18:05:03.770]                       else if (inherits(cond, "condition")) {
[18:05:03.770]                         if (!is.null(pattern)) {
[18:05:03.770]                           computeRestarts <- base::computeRestarts
[18:05:03.770]                           grepl <- base::grepl
[18:05:03.770]                           restarts <- computeRestarts(cond)
[18:05:03.770]                           for (restart in restarts) {
[18:05:03.770]                             name <- restart$name
[18:05:03.770]                             if (is.null(name)) 
[18:05:03.770]                               next
[18:05:03.770]                             if (!grepl(pattern, name)) 
[18:05:03.770]                               next
[18:05:03.770]                             invokeRestart(restart)
[18:05:03.770]                             muffled <- TRUE
[18:05:03.770]                             break
[18:05:03.770]                           }
[18:05:03.770]                         }
[18:05:03.770]                       }
[18:05:03.770]                       invisible(muffled)
[18:05:03.770]                     }
[18:05:03.770]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.770]                   }
[18:05:03.770]                 }
[18:05:03.770]             }
[18:05:03.770]         }))
[18:05:03.770]     }, error = function(ex) {
[18:05:03.770]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:03.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.770]                 ...future.rng), started = ...future.startTime, 
[18:05:03.770]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:03.770]             version = "1.8"), class = "FutureResult")
[18:05:03.770]     }, finally = {
[18:05:03.770]         if (!identical(...future.workdir, getwd())) 
[18:05:03.770]             setwd(...future.workdir)
[18:05:03.770]         {
[18:05:03.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:03.770]                 ...future.oldOptions$nwarnings <- NULL
[18:05:03.770]             }
[18:05:03.770]             base::options(...future.oldOptions)
[18:05:03.770]             if (.Platform$OS.type == "windows") {
[18:05:03.770]                 old_names <- names(...future.oldEnvVars)
[18:05:03.770]                 envs <- base::Sys.getenv()
[18:05:03.770]                 names <- names(envs)
[18:05:03.770]                 common <- intersect(names, old_names)
[18:05:03.770]                 added <- setdiff(names, old_names)
[18:05:03.770]                 removed <- setdiff(old_names, names)
[18:05:03.770]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:03.770]                   envs[common]]
[18:05:03.770]                 NAMES <- toupper(changed)
[18:05:03.770]                 args <- list()
[18:05:03.770]                 for (kk in seq_along(NAMES)) {
[18:05:03.770]                   name <- changed[[kk]]
[18:05:03.770]                   NAME <- NAMES[[kk]]
[18:05:03.770]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.770]                     next
[18:05:03.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.770]                 }
[18:05:03.770]                 NAMES <- toupper(added)
[18:05:03.770]                 for (kk in seq_along(NAMES)) {
[18:05:03.770]                   name <- added[[kk]]
[18:05:03.770]                   NAME <- NAMES[[kk]]
[18:05:03.770]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.770]                     next
[18:05:03.770]                   args[[name]] <- ""
[18:05:03.770]                 }
[18:05:03.770]                 NAMES <- toupper(removed)
[18:05:03.770]                 for (kk in seq_along(NAMES)) {
[18:05:03.770]                   name <- removed[[kk]]
[18:05:03.770]                   NAME <- NAMES[[kk]]
[18:05:03.770]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.770]                     next
[18:05:03.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.770]                 }
[18:05:03.770]                 if (length(args) > 0) 
[18:05:03.770]                   base::do.call(base::Sys.setenv, args = args)
[18:05:03.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:03.770]             }
[18:05:03.770]             else {
[18:05:03.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:03.770]             }
[18:05:03.770]             {
[18:05:03.770]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:03.770]                   0L) {
[18:05:03.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:03.770]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:03.770]                   base::options(opts)
[18:05:03.770]                 }
[18:05:03.770]                 {
[18:05:03.770]                   {
[18:05:03.770]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:03.770]                     NULL
[18:05:03.770]                   }
[18:05:03.770]                   options(future.plan = NULL)
[18:05:03.770]                   if (is.na(NA_character_)) 
[18:05:03.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:03.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:03.770]                     .init = FALSE)
[18:05:03.770]                 }
[18:05:03.770]             }
[18:05:03.770]         }
[18:05:03.770]     })
[18:05:03.770]     if (TRUE) {
[18:05:03.770]         base::sink(type = "output", split = FALSE)
[18:05:03.770]         if (TRUE) {
[18:05:03.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:03.770]         }
[18:05:03.770]         else {
[18:05:03.770]             ...future.result["stdout"] <- base::list(NULL)
[18:05:03.770]         }
[18:05:03.770]         base::close(...future.stdout)
[18:05:03.770]         ...future.stdout <- NULL
[18:05:03.770]     }
[18:05:03.770]     ...future.result$conditions <- ...future.conditions
[18:05:03.770]     ...future.result$finished <- base::Sys.time()
[18:05:03.770]     ...future.result
[18:05:03.770] }
[18:05:03.776] MultisessionFuture started
[18:05:03.776] - Launch lazy future ... done
[18:05:03.777] run() for ‘MultisessionFuture’ ... done
[18:05:03.777] result() for ClusterFuture ...
[18:05:03.777] receiveMessageFromWorker() for ClusterFuture ...
[18:05:03.777] - Validating connection of MultisessionFuture
[18:05:03.820] - received message: FutureResult
[18:05:03.820] - Received FutureResult
[18:05:03.821] - Erased future from FutureRegistry
[18:05:03.821] result() for ClusterFuture ...
[18:05:03.821] - result already collected: FutureResult
[18:05:03.821] result() for ClusterFuture ... done
[18:05:03.822] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:03.822] result() for ClusterFuture ... done
[18:05:03.822] result() for ClusterFuture ...
[18:05:03.822] - result already collected: FutureResult
[18:05:03.822] result() for ClusterFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:03.823] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:03.823] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:03.826] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[18:05:03.827] Searching for globals ... DONE
[18:05:03.827] Resolving globals: TRUE
[18:05:03.827] Resolving any globals that are futures ...
[18:05:03.827] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[18:05:03.828] Resolving any globals that are futures ... DONE
[18:05:03.828] Resolving futures part of globals (recursively) ...
[18:05:03.829] resolve() on list ...
[18:05:03.829]  recursive: 99
[18:05:03.829]  length: 1
[18:05:03.829]  elements: ‘x’
[18:05:03.829]  length: 0 (resolved future 1)
[18:05:03.830] resolve() on list ... DONE
[18:05:03.830] - globals: [1] ‘x’
[18:05:03.830] Resolving futures part of globals (recursively) ... DONE
[18:05:03.830] The total size of the 1 globals is 56 bytes (56 bytes)
[18:05:03.831] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[18:05:03.831] - globals: [1] ‘x’
[18:05:03.831] 
[18:05:03.832] getGlobalsAndPackages() ... DONE
[18:05:03.832] run() for ‘Future’ ...
[18:05:03.832] - state: ‘created’
[18:05:03.833] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:03.857] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:03.857] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:03.857]   - Field: ‘node’
[18:05:03.858]   - Field: ‘label’
[18:05:03.858]   - Field: ‘local’
[18:05:03.858]   - Field: ‘owner’
[18:05:03.858]   - Field: ‘envir’
[18:05:03.858]   - Field: ‘workers’
[18:05:03.859]   - Field: ‘packages’
[18:05:03.859]   - Field: ‘gc’
[18:05:03.859]   - Field: ‘conditions’
[18:05:03.859]   - Field: ‘persistent’
[18:05:03.859]   - Field: ‘expr’
[18:05:03.860]   - Field: ‘uuid’
[18:05:03.860]   - Field: ‘seed’
[18:05:03.860]   - Field: ‘version’
[18:05:03.860]   - Field: ‘result’
[18:05:03.860]   - Field: ‘asynchronous’
[18:05:03.861]   - Field: ‘calls’
[18:05:03.861]   - Field: ‘globals’
[18:05:03.861]   - Field: ‘stdout’
[18:05:03.861]   - Field: ‘earlySignal’
[18:05:03.861]   - Field: ‘lazy’
[18:05:03.862]   - Field: ‘state’
[18:05:03.862] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:03.862] - Launch lazy future ...
[18:05:03.862] Packages needed by the future expression (n = 0): <none>
[18:05:03.863] Packages needed by future strategies (n = 0): <none>
[18:05:03.864] {
[18:05:03.864]     {
[18:05:03.864]         {
[18:05:03.864]             ...future.startTime <- base::Sys.time()
[18:05:03.864]             {
[18:05:03.864]                 {
[18:05:03.864]                   {
[18:05:03.864]                     {
[18:05:03.864]                       base::local({
[18:05:03.864]                         has_future <- base::requireNamespace("future", 
[18:05:03.864]                           quietly = TRUE)
[18:05:03.864]                         if (has_future) {
[18:05:03.864]                           ns <- base::getNamespace("future")
[18:05:03.864]                           version <- ns[[".package"]][["version"]]
[18:05:03.864]                           if (is.null(version)) 
[18:05:03.864]                             version <- utils::packageVersion("future")
[18:05:03.864]                         }
[18:05:03.864]                         else {
[18:05:03.864]                           version <- NULL
[18:05:03.864]                         }
[18:05:03.864]                         if (!has_future || version < "1.8.0") {
[18:05:03.864]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:03.864]                             "", base::R.version$version.string), 
[18:05:03.864]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:03.864]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:03.864]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:03.864]                               "release", "version")], collapse = " "), 
[18:05:03.864]                             hostname = base::Sys.info()[["nodename"]])
[18:05:03.864]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:03.864]                             info)
[18:05:03.864]                           info <- base::paste(info, collapse = "; ")
[18:05:03.864]                           if (!has_future) {
[18:05:03.864]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:03.864]                               info)
[18:05:03.864]                           }
[18:05:03.864]                           else {
[18:05:03.864]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:03.864]                               info, version)
[18:05:03.864]                           }
[18:05:03.864]                           base::stop(msg)
[18:05:03.864]                         }
[18:05:03.864]                       })
[18:05:03.864]                     }
[18:05:03.864]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:03.864]                     base::options(mc.cores = 1L)
[18:05:03.864]                   }
[18:05:03.864]                   ...future.strategy.old <- future::plan("list")
[18:05:03.864]                   options(future.plan = NULL)
[18:05:03.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:03.864]                 }
[18:05:03.864]                 ...future.workdir <- getwd()
[18:05:03.864]             }
[18:05:03.864]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:03.864]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:03.864]         }
[18:05:03.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:03.864]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:03.864]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:03.864]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:03.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:03.864]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:03.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:03.864]             base::names(...future.oldOptions))
[18:05:03.864]     }
[18:05:03.864]     if (FALSE) {
[18:05:03.864]     }
[18:05:03.864]     else {
[18:05:03.864]         if (TRUE) {
[18:05:03.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:03.864]                 open = "w")
[18:05:03.864]         }
[18:05:03.864]         else {
[18:05:03.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:03.864]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:03.864]         }
[18:05:03.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:03.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:03.864]             base::sink(type = "output", split = FALSE)
[18:05:03.864]             base::close(...future.stdout)
[18:05:03.864]         }, add = TRUE)
[18:05:03.864]     }
[18:05:03.864]     ...future.frame <- base::sys.nframe()
[18:05:03.864]     ...future.conditions <- base::list()
[18:05:03.864]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:03.864]     if (FALSE) {
[18:05:03.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:03.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:03.864]     }
[18:05:03.864]     ...future.result <- base::tryCatch({
[18:05:03.864]         base::withCallingHandlers({
[18:05:03.864]             ...future.value <- base::withVisible(base::local({
[18:05:03.864]                 ...future.makeSendCondition <- base::local({
[18:05:03.864]                   sendCondition <- NULL
[18:05:03.864]                   function(frame = 1L) {
[18:05:03.864]                     if (is.function(sendCondition)) 
[18:05:03.864]                       return(sendCondition)
[18:05:03.864]                     ns <- getNamespace("parallel")
[18:05:03.864]                     if (exists("sendData", mode = "function", 
[18:05:03.864]                       envir = ns)) {
[18:05:03.864]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:03.864]                         envir = ns)
[18:05:03.864]                       envir <- sys.frame(frame)
[18:05:03.864]                       master <- NULL
[18:05:03.864]                       while (!identical(envir, .GlobalEnv) && 
[18:05:03.864]                         !identical(envir, emptyenv())) {
[18:05:03.864]                         if (exists("master", mode = "list", envir = envir, 
[18:05:03.864]                           inherits = FALSE)) {
[18:05:03.864]                           master <- get("master", mode = "list", 
[18:05:03.864]                             envir = envir, inherits = FALSE)
[18:05:03.864]                           if (inherits(master, c("SOCKnode", 
[18:05:03.864]                             "SOCK0node"))) {
[18:05:03.864]                             sendCondition <<- function(cond) {
[18:05:03.864]                               data <- list(type = "VALUE", value = cond, 
[18:05:03.864]                                 success = TRUE)
[18:05:03.864]                               parallel_sendData(master, data)
[18:05:03.864]                             }
[18:05:03.864]                             return(sendCondition)
[18:05:03.864]                           }
[18:05:03.864]                         }
[18:05:03.864]                         frame <- frame + 1L
[18:05:03.864]                         envir <- sys.frame(frame)
[18:05:03.864]                       }
[18:05:03.864]                     }
[18:05:03.864]                     sendCondition <<- function(cond) NULL
[18:05:03.864]                   }
[18:05:03.864]                 })
[18:05:03.864]                 withCallingHandlers({
[18:05:03.864]                   {
[18:05:03.864]                     x <- x + 1
[18:05:03.864]                     x
[18:05:03.864]                   }
[18:05:03.864]                 }, immediateCondition = function(cond) {
[18:05:03.864]                   sendCondition <- ...future.makeSendCondition()
[18:05:03.864]                   sendCondition(cond)
[18:05:03.864]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.864]                   {
[18:05:03.864]                     inherits <- base::inherits
[18:05:03.864]                     invokeRestart <- base::invokeRestart
[18:05:03.864]                     is.null <- base::is.null
[18:05:03.864]                     muffled <- FALSE
[18:05:03.864]                     if (inherits(cond, "message")) {
[18:05:03.864]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:03.864]                       if (muffled) 
[18:05:03.864]                         invokeRestart("muffleMessage")
[18:05:03.864]                     }
[18:05:03.864]                     else if (inherits(cond, "warning")) {
[18:05:03.864]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:03.864]                       if (muffled) 
[18:05:03.864]                         invokeRestart("muffleWarning")
[18:05:03.864]                     }
[18:05:03.864]                     else if (inherits(cond, "condition")) {
[18:05:03.864]                       if (!is.null(pattern)) {
[18:05:03.864]                         computeRestarts <- base::computeRestarts
[18:05:03.864]                         grepl <- base::grepl
[18:05:03.864]                         restarts <- computeRestarts(cond)
[18:05:03.864]                         for (restart in restarts) {
[18:05:03.864]                           name <- restart$name
[18:05:03.864]                           if (is.null(name)) 
[18:05:03.864]                             next
[18:05:03.864]                           if (!grepl(pattern, name)) 
[18:05:03.864]                             next
[18:05:03.864]                           invokeRestart(restart)
[18:05:03.864]                           muffled <- TRUE
[18:05:03.864]                           break
[18:05:03.864]                         }
[18:05:03.864]                       }
[18:05:03.864]                     }
[18:05:03.864]                     invisible(muffled)
[18:05:03.864]                   }
[18:05:03.864]                   muffleCondition(cond)
[18:05:03.864]                 })
[18:05:03.864]             }))
[18:05:03.864]             future::FutureResult(value = ...future.value$value, 
[18:05:03.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.864]                   ...future.rng), globalenv = if (FALSE) 
[18:05:03.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:03.864]                     ...future.globalenv.names))
[18:05:03.864]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:03.864]         }, condition = base::local({
[18:05:03.864]             c <- base::c
[18:05:03.864]             inherits <- base::inherits
[18:05:03.864]             invokeRestart <- base::invokeRestart
[18:05:03.864]             length <- base::length
[18:05:03.864]             list <- base::list
[18:05:03.864]             seq.int <- base::seq.int
[18:05:03.864]             signalCondition <- base::signalCondition
[18:05:03.864]             sys.calls <- base::sys.calls
[18:05:03.864]             `[[` <- base::`[[`
[18:05:03.864]             `+` <- base::`+`
[18:05:03.864]             `<<-` <- base::`<<-`
[18:05:03.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:03.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:03.864]                   3L)]
[18:05:03.864]             }
[18:05:03.864]             function(cond) {
[18:05:03.864]                 is_error <- inherits(cond, "error")
[18:05:03.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:03.864]                   NULL)
[18:05:03.864]                 if (is_error) {
[18:05:03.864]                   sessionInformation <- function() {
[18:05:03.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:03.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:03.864]                       search = base::search(), system = base::Sys.info())
[18:05:03.864]                   }
[18:05:03.864]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:03.864]                     cond$call), session = sessionInformation(), 
[18:05:03.864]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:03.864]                   signalCondition(cond)
[18:05:03.864]                 }
[18:05:03.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:03.864]                 "immediateCondition"))) {
[18:05:03.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:03.864]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:03.864]                   if (TRUE && !signal) {
[18:05:03.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.864]                     {
[18:05:03.864]                       inherits <- base::inherits
[18:05:03.864]                       invokeRestart <- base::invokeRestart
[18:05:03.864]                       is.null <- base::is.null
[18:05:03.864]                       muffled <- FALSE
[18:05:03.864]                       if (inherits(cond, "message")) {
[18:05:03.864]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.864]                         if (muffled) 
[18:05:03.864]                           invokeRestart("muffleMessage")
[18:05:03.864]                       }
[18:05:03.864]                       else if (inherits(cond, "warning")) {
[18:05:03.864]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.864]                         if (muffled) 
[18:05:03.864]                           invokeRestart("muffleWarning")
[18:05:03.864]                       }
[18:05:03.864]                       else if (inherits(cond, "condition")) {
[18:05:03.864]                         if (!is.null(pattern)) {
[18:05:03.864]                           computeRestarts <- base::computeRestarts
[18:05:03.864]                           grepl <- base::grepl
[18:05:03.864]                           restarts <- computeRestarts(cond)
[18:05:03.864]                           for (restart in restarts) {
[18:05:03.864]                             name <- restart$name
[18:05:03.864]                             if (is.null(name)) 
[18:05:03.864]                               next
[18:05:03.864]                             if (!grepl(pattern, name)) 
[18:05:03.864]                               next
[18:05:03.864]                             invokeRestart(restart)
[18:05:03.864]                             muffled <- TRUE
[18:05:03.864]                             break
[18:05:03.864]                           }
[18:05:03.864]                         }
[18:05:03.864]                       }
[18:05:03.864]                       invisible(muffled)
[18:05:03.864]                     }
[18:05:03.864]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.864]                   }
[18:05:03.864]                 }
[18:05:03.864]                 else {
[18:05:03.864]                   if (TRUE) {
[18:05:03.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.864]                     {
[18:05:03.864]                       inherits <- base::inherits
[18:05:03.864]                       invokeRestart <- base::invokeRestart
[18:05:03.864]                       is.null <- base::is.null
[18:05:03.864]                       muffled <- FALSE
[18:05:03.864]                       if (inherits(cond, "message")) {
[18:05:03.864]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.864]                         if (muffled) 
[18:05:03.864]                           invokeRestart("muffleMessage")
[18:05:03.864]                       }
[18:05:03.864]                       else if (inherits(cond, "warning")) {
[18:05:03.864]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.864]                         if (muffled) 
[18:05:03.864]                           invokeRestart("muffleWarning")
[18:05:03.864]                       }
[18:05:03.864]                       else if (inherits(cond, "condition")) {
[18:05:03.864]                         if (!is.null(pattern)) {
[18:05:03.864]                           computeRestarts <- base::computeRestarts
[18:05:03.864]                           grepl <- base::grepl
[18:05:03.864]                           restarts <- computeRestarts(cond)
[18:05:03.864]                           for (restart in restarts) {
[18:05:03.864]                             name <- restart$name
[18:05:03.864]                             if (is.null(name)) 
[18:05:03.864]                               next
[18:05:03.864]                             if (!grepl(pattern, name)) 
[18:05:03.864]                               next
[18:05:03.864]                             invokeRestart(restart)
[18:05:03.864]                             muffled <- TRUE
[18:05:03.864]                             break
[18:05:03.864]                           }
[18:05:03.864]                         }
[18:05:03.864]                       }
[18:05:03.864]                       invisible(muffled)
[18:05:03.864]                     }
[18:05:03.864]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.864]                   }
[18:05:03.864]                 }
[18:05:03.864]             }
[18:05:03.864]         }))
[18:05:03.864]     }, error = function(ex) {
[18:05:03.864]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:03.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.864]                 ...future.rng), started = ...future.startTime, 
[18:05:03.864]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:03.864]             version = "1.8"), class = "FutureResult")
[18:05:03.864]     }, finally = {
[18:05:03.864]         if (!identical(...future.workdir, getwd())) 
[18:05:03.864]             setwd(...future.workdir)
[18:05:03.864]         {
[18:05:03.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:03.864]                 ...future.oldOptions$nwarnings <- NULL
[18:05:03.864]             }
[18:05:03.864]             base::options(...future.oldOptions)
[18:05:03.864]             if (.Platform$OS.type == "windows") {
[18:05:03.864]                 old_names <- names(...future.oldEnvVars)
[18:05:03.864]                 envs <- base::Sys.getenv()
[18:05:03.864]                 names <- names(envs)
[18:05:03.864]                 common <- intersect(names, old_names)
[18:05:03.864]                 added <- setdiff(names, old_names)
[18:05:03.864]                 removed <- setdiff(old_names, names)
[18:05:03.864]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:03.864]                   envs[common]]
[18:05:03.864]                 NAMES <- toupper(changed)
[18:05:03.864]                 args <- list()
[18:05:03.864]                 for (kk in seq_along(NAMES)) {
[18:05:03.864]                   name <- changed[[kk]]
[18:05:03.864]                   NAME <- NAMES[[kk]]
[18:05:03.864]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.864]                     next
[18:05:03.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.864]                 }
[18:05:03.864]                 NAMES <- toupper(added)
[18:05:03.864]                 for (kk in seq_along(NAMES)) {
[18:05:03.864]                   name <- added[[kk]]
[18:05:03.864]                   NAME <- NAMES[[kk]]
[18:05:03.864]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.864]                     next
[18:05:03.864]                   args[[name]] <- ""
[18:05:03.864]                 }
[18:05:03.864]                 NAMES <- toupper(removed)
[18:05:03.864]                 for (kk in seq_along(NAMES)) {
[18:05:03.864]                   name <- removed[[kk]]
[18:05:03.864]                   NAME <- NAMES[[kk]]
[18:05:03.864]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.864]                     next
[18:05:03.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.864]                 }
[18:05:03.864]                 if (length(args) > 0) 
[18:05:03.864]                   base::do.call(base::Sys.setenv, args = args)
[18:05:03.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:03.864]             }
[18:05:03.864]             else {
[18:05:03.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:03.864]             }
[18:05:03.864]             {
[18:05:03.864]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:03.864]                   0L) {
[18:05:03.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:03.864]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:03.864]                   base::options(opts)
[18:05:03.864]                 }
[18:05:03.864]                 {
[18:05:03.864]                   {
[18:05:03.864]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:03.864]                     NULL
[18:05:03.864]                   }
[18:05:03.864]                   options(future.plan = NULL)
[18:05:03.864]                   if (is.na(NA_character_)) 
[18:05:03.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:03.864]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:03.864]                     .init = FALSE)
[18:05:03.864]                 }
[18:05:03.864]             }
[18:05:03.864]         }
[18:05:03.864]     })
[18:05:03.864]     if (TRUE) {
[18:05:03.864]         base::sink(type = "output", split = FALSE)
[18:05:03.864]         if (TRUE) {
[18:05:03.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:03.864]         }
[18:05:03.864]         else {
[18:05:03.864]             ...future.result["stdout"] <- base::list(NULL)
[18:05:03.864]         }
[18:05:03.864]         base::close(...future.stdout)
[18:05:03.864]         ...future.stdout <- NULL
[18:05:03.864]     }
[18:05:03.864]     ...future.result$conditions <- ...future.conditions
[18:05:03.864]     ...future.result$finished <- base::Sys.time()
[18:05:03.864]     ...future.result
[18:05:03.864] }
[18:05:03.868] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:05:03.869] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[18:05:03.870] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[18:05:03.870] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:05:03.871] MultisessionFuture started
[18:05:03.871] - Launch lazy future ... done
[18:05:03.871] run() for ‘MultisessionFuture’ ... done
[18:05:03.872] result() for ClusterFuture ...
[18:05:03.872] receiveMessageFromWorker() for ClusterFuture ...
[18:05:03.872] - Validating connection of MultisessionFuture
[18:05:03.915] - received message: FutureResult
[18:05:03.916] - Received FutureResult
[18:05:03.916] - Erased future from FutureRegistry
[18:05:03.916] result() for ClusterFuture ...
[18:05:03.916] - result already collected: FutureResult
[18:05:03.916] result() for ClusterFuture ... done
[18:05:03.917] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:03.917] result() for ClusterFuture ... done
[18:05:03.917] result() for ClusterFuture ...
[18:05:03.917] - result already collected: FutureResult
[18:05:03.917] result() for ClusterFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[18:05:03.918] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:05:03.919] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[18:05:03.922] - globals found: [3] ‘{’, ‘<-’, ‘x’
[18:05:03.922] Searching for globals ... DONE
[18:05:03.923] Resolving globals: TRUE
[18:05:03.923] Resolving any globals that are futures ...
[18:05:03.923] - globals: [3] ‘{’, ‘<-’, ‘x’
[18:05:03.923] Resolving any globals that are futures ... DONE
[18:05:03.924] Resolving futures part of globals (recursively) ...
[18:05:03.924] resolve() on list ...
[18:05:03.925]  recursive: 99
[18:05:03.925]  length: 1
[18:05:03.925]  elements: ‘x’
[18:05:03.925]  length: 0 (resolved future 1)
[18:05:03.926] resolve() on list ... DONE
[18:05:03.926] - globals: [1] ‘x’
[18:05:03.926] Resolving futures part of globals (recursively) ... DONE
[18:05:03.926] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[18:05:03.927] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[18:05:03.927] - globals: [1] ‘x’
[18:05:03.927] 
[18:05:03.928] getGlobalsAndPackages() ... DONE
[18:05:03.928] run() for ‘Future’ ...
[18:05:03.928] - state: ‘created’
[18:05:03.929] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:03.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:03.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:03.955]   - Field: ‘node’
[18:05:03.955]   - Field: ‘label’
[18:05:03.956]   - Field: ‘local’
[18:05:03.956]   - Field: ‘owner’
[18:05:03.956]   - Field: ‘envir’
[18:05:03.956]   - Field: ‘workers’
[18:05:03.957]   - Field: ‘packages’
[18:05:03.957]   - Field: ‘gc’
[18:05:03.957]   - Field: ‘conditions’
[18:05:03.957]   - Field: ‘persistent’
[18:05:03.957]   - Field: ‘expr’
[18:05:03.958]   - Field: ‘uuid’
[18:05:03.958]   - Field: ‘seed’
[18:05:03.958]   - Field: ‘version’
[18:05:03.958]   - Field: ‘result’
[18:05:03.958]   - Field: ‘asynchronous’
[18:05:03.959]   - Field: ‘calls’
[18:05:03.959]   - Field: ‘globals’
[18:05:03.959]   - Field: ‘stdout’
[18:05:03.959]   - Field: ‘earlySignal’
[18:05:03.959]   - Field: ‘lazy’
[18:05:03.960]   - Field: ‘state’
[18:05:03.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:03.960] - Launch lazy future ...
[18:05:03.961] Packages needed by the future expression (n = 0): <none>
[18:05:03.961] Packages needed by future strategies (n = 0): <none>
[18:05:03.962] {
[18:05:03.962]     {
[18:05:03.962]         {
[18:05:03.962]             ...future.startTime <- base::Sys.time()
[18:05:03.962]             {
[18:05:03.962]                 {
[18:05:03.962]                   {
[18:05:03.962]                     {
[18:05:03.962]                       base::local({
[18:05:03.962]                         has_future <- base::requireNamespace("future", 
[18:05:03.962]                           quietly = TRUE)
[18:05:03.962]                         if (has_future) {
[18:05:03.962]                           ns <- base::getNamespace("future")
[18:05:03.962]                           version <- ns[[".package"]][["version"]]
[18:05:03.962]                           if (is.null(version)) 
[18:05:03.962]                             version <- utils::packageVersion("future")
[18:05:03.962]                         }
[18:05:03.962]                         else {
[18:05:03.962]                           version <- NULL
[18:05:03.962]                         }
[18:05:03.962]                         if (!has_future || version < "1.8.0") {
[18:05:03.962]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:03.962]                             "", base::R.version$version.string), 
[18:05:03.962]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:03.962]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:03.962]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:03.962]                               "release", "version")], collapse = " "), 
[18:05:03.962]                             hostname = base::Sys.info()[["nodename"]])
[18:05:03.962]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:03.962]                             info)
[18:05:03.962]                           info <- base::paste(info, collapse = "; ")
[18:05:03.962]                           if (!has_future) {
[18:05:03.962]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:03.962]                               info)
[18:05:03.962]                           }
[18:05:03.962]                           else {
[18:05:03.962]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:03.962]                               info, version)
[18:05:03.962]                           }
[18:05:03.962]                           base::stop(msg)
[18:05:03.962]                         }
[18:05:03.962]                       })
[18:05:03.962]                     }
[18:05:03.962]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:03.962]                     base::options(mc.cores = 1L)
[18:05:03.962]                   }
[18:05:03.962]                   ...future.strategy.old <- future::plan("list")
[18:05:03.962]                   options(future.plan = NULL)
[18:05:03.962]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.962]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:03.962]                 }
[18:05:03.962]                 ...future.workdir <- getwd()
[18:05:03.962]             }
[18:05:03.962]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:03.962]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:03.962]         }
[18:05:03.962]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:05:03.962]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[18:05:03.962]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:05:03.962]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[18:05:03.962]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:03.962]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:03.962]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:03.962]             base::names(...future.oldOptions))
[18:05:03.962]     }
[18:05:03.962]     if (FALSE) {
[18:05:03.962]     }
[18:05:03.962]     else {
[18:05:03.962]         if (TRUE) {
[18:05:03.962]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:03.962]                 open = "w")
[18:05:03.962]         }
[18:05:03.962]         else {
[18:05:03.962]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:03.962]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:03.962]         }
[18:05:03.962]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:03.962]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:03.962]             base::sink(type = "output", split = FALSE)
[18:05:03.962]             base::close(...future.stdout)
[18:05:03.962]         }, add = TRUE)
[18:05:03.962]     }
[18:05:03.962]     ...future.frame <- base::sys.nframe()
[18:05:03.962]     ...future.conditions <- base::list()
[18:05:03.962]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:03.962]     if (FALSE) {
[18:05:03.962]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:03.962]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:03.962]     }
[18:05:03.962]     ...future.result <- base::tryCatch({
[18:05:03.962]         base::withCallingHandlers({
[18:05:03.962]             ...future.value <- base::withVisible(base::local({
[18:05:03.962]                 ...future.makeSendCondition <- base::local({
[18:05:03.962]                   sendCondition <- NULL
[18:05:03.962]                   function(frame = 1L) {
[18:05:03.962]                     if (is.function(sendCondition)) 
[18:05:03.962]                       return(sendCondition)
[18:05:03.962]                     ns <- getNamespace("parallel")
[18:05:03.962]                     if (exists("sendData", mode = "function", 
[18:05:03.962]                       envir = ns)) {
[18:05:03.962]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:03.962]                         envir = ns)
[18:05:03.962]                       envir <- sys.frame(frame)
[18:05:03.962]                       master <- NULL
[18:05:03.962]                       while (!identical(envir, .GlobalEnv) && 
[18:05:03.962]                         !identical(envir, emptyenv())) {
[18:05:03.962]                         if (exists("master", mode = "list", envir = envir, 
[18:05:03.962]                           inherits = FALSE)) {
[18:05:03.962]                           master <- get("master", mode = "list", 
[18:05:03.962]                             envir = envir, inherits = FALSE)
[18:05:03.962]                           if (inherits(master, c("SOCKnode", 
[18:05:03.962]                             "SOCK0node"))) {
[18:05:03.962]                             sendCondition <<- function(cond) {
[18:05:03.962]                               data <- list(type = "VALUE", value = cond, 
[18:05:03.962]                                 success = TRUE)
[18:05:03.962]                               parallel_sendData(master, data)
[18:05:03.962]                             }
[18:05:03.962]                             return(sendCondition)
[18:05:03.962]                           }
[18:05:03.962]                         }
[18:05:03.962]                         frame <- frame + 1L
[18:05:03.962]                         envir <- sys.frame(frame)
[18:05:03.962]                       }
[18:05:03.962]                     }
[18:05:03.962]                     sendCondition <<- function(cond) NULL
[18:05:03.962]                   }
[18:05:03.962]                 })
[18:05:03.962]                 withCallingHandlers({
[18:05:03.962]                   {
[18:05:03.962]                     x <- x()
[18:05:03.962]                     x
[18:05:03.962]                   }
[18:05:03.962]                 }, immediateCondition = function(cond) {
[18:05:03.962]                   sendCondition <- ...future.makeSendCondition()
[18:05:03.962]                   sendCondition(cond)
[18:05:03.962]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.962]                   {
[18:05:03.962]                     inherits <- base::inherits
[18:05:03.962]                     invokeRestart <- base::invokeRestart
[18:05:03.962]                     is.null <- base::is.null
[18:05:03.962]                     muffled <- FALSE
[18:05:03.962]                     if (inherits(cond, "message")) {
[18:05:03.962]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:03.962]                       if (muffled) 
[18:05:03.962]                         invokeRestart("muffleMessage")
[18:05:03.962]                     }
[18:05:03.962]                     else if (inherits(cond, "warning")) {
[18:05:03.962]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:03.962]                       if (muffled) 
[18:05:03.962]                         invokeRestart("muffleWarning")
[18:05:03.962]                     }
[18:05:03.962]                     else if (inherits(cond, "condition")) {
[18:05:03.962]                       if (!is.null(pattern)) {
[18:05:03.962]                         computeRestarts <- base::computeRestarts
[18:05:03.962]                         grepl <- base::grepl
[18:05:03.962]                         restarts <- computeRestarts(cond)
[18:05:03.962]                         for (restart in restarts) {
[18:05:03.962]                           name <- restart$name
[18:05:03.962]                           if (is.null(name)) 
[18:05:03.962]                             next
[18:05:03.962]                           if (!grepl(pattern, name)) 
[18:05:03.962]                             next
[18:05:03.962]                           invokeRestart(restart)
[18:05:03.962]                           muffled <- TRUE
[18:05:03.962]                           break
[18:05:03.962]                         }
[18:05:03.962]                       }
[18:05:03.962]                     }
[18:05:03.962]                     invisible(muffled)
[18:05:03.962]                   }
[18:05:03.962]                   muffleCondition(cond)
[18:05:03.962]                 })
[18:05:03.962]             }))
[18:05:03.962]             future::FutureResult(value = ...future.value$value, 
[18:05:03.962]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.962]                   ...future.rng), globalenv = if (FALSE) 
[18:05:03.962]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:03.962]                     ...future.globalenv.names))
[18:05:03.962]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:03.962]         }, condition = base::local({
[18:05:03.962]             c <- base::c
[18:05:03.962]             inherits <- base::inherits
[18:05:03.962]             invokeRestart <- base::invokeRestart
[18:05:03.962]             length <- base::length
[18:05:03.962]             list <- base::list
[18:05:03.962]             seq.int <- base::seq.int
[18:05:03.962]             signalCondition <- base::signalCondition
[18:05:03.962]             sys.calls <- base::sys.calls
[18:05:03.962]             `[[` <- base::`[[`
[18:05:03.962]             `+` <- base::`+`
[18:05:03.962]             `<<-` <- base::`<<-`
[18:05:03.962]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:03.962]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:03.962]                   3L)]
[18:05:03.962]             }
[18:05:03.962]             function(cond) {
[18:05:03.962]                 is_error <- inherits(cond, "error")
[18:05:03.962]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:03.962]                   NULL)
[18:05:03.962]                 if (is_error) {
[18:05:03.962]                   sessionInformation <- function() {
[18:05:03.962]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:03.962]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:03.962]                       search = base::search(), system = base::Sys.info())
[18:05:03.962]                   }
[18:05:03.962]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.962]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:03.962]                     cond$call), session = sessionInformation(), 
[18:05:03.962]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:03.962]                   signalCondition(cond)
[18:05:03.962]                 }
[18:05:03.962]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:03.962]                 "immediateCondition"))) {
[18:05:03.962]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:03.962]                   ...future.conditions[[length(...future.conditions) + 
[18:05:03.962]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:03.962]                   if (TRUE && !signal) {
[18:05:03.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.962]                     {
[18:05:03.962]                       inherits <- base::inherits
[18:05:03.962]                       invokeRestart <- base::invokeRestart
[18:05:03.962]                       is.null <- base::is.null
[18:05:03.962]                       muffled <- FALSE
[18:05:03.962]                       if (inherits(cond, "message")) {
[18:05:03.962]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.962]                         if (muffled) 
[18:05:03.962]                           invokeRestart("muffleMessage")
[18:05:03.962]                       }
[18:05:03.962]                       else if (inherits(cond, "warning")) {
[18:05:03.962]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.962]                         if (muffled) 
[18:05:03.962]                           invokeRestart("muffleWarning")
[18:05:03.962]                       }
[18:05:03.962]                       else if (inherits(cond, "condition")) {
[18:05:03.962]                         if (!is.null(pattern)) {
[18:05:03.962]                           computeRestarts <- base::computeRestarts
[18:05:03.962]                           grepl <- base::grepl
[18:05:03.962]                           restarts <- computeRestarts(cond)
[18:05:03.962]                           for (restart in restarts) {
[18:05:03.962]                             name <- restart$name
[18:05:03.962]                             if (is.null(name)) 
[18:05:03.962]                               next
[18:05:03.962]                             if (!grepl(pattern, name)) 
[18:05:03.962]                               next
[18:05:03.962]                             invokeRestart(restart)
[18:05:03.962]                             muffled <- TRUE
[18:05:03.962]                             break
[18:05:03.962]                           }
[18:05:03.962]                         }
[18:05:03.962]                       }
[18:05:03.962]                       invisible(muffled)
[18:05:03.962]                     }
[18:05:03.962]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.962]                   }
[18:05:03.962]                 }
[18:05:03.962]                 else {
[18:05:03.962]                   if (TRUE) {
[18:05:03.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:03.962]                     {
[18:05:03.962]                       inherits <- base::inherits
[18:05:03.962]                       invokeRestart <- base::invokeRestart
[18:05:03.962]                       is.null <- base::is.null
[18:05:03.962]                       muffled <- FALSE
[18:05:03.962]                       if (inherits(cond, "message")) {
[18:05:03.962]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:03.962]                         if (muffled) 
[18:05:03.962]                           invokeRestart("muffleMessage")
[18:05:03.962]                       }
[18:05:03.962]                       else if (inherits(cond, "warning")) {
[18:05:03.962]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:03.962]                         if (muffled) 
[18:05:03.962]                           invokeRestart("muffleWarning")
[18:05:03.962]                       }
[18:05:03.962]                       else if (inherits(cond, "condition")) {
[18:05:03.962]                         if (!is.null(pattern)) {
[18:05:03.962]                           computeRestarts <- base::computeRestarts
[18:05:03.962]                           grepl <- base::grepl
[18:05:03.962]                           restarts <- computeRestarts(cond)
[18:05:03.962]                           for (restart in restarts) {
[18:05:03.962]                             name <- restart$name
[18:05:03.962]                             if (is.null(name)) 
[18:05:03.962]                               next
[18:05:03.962]                             if (!grepl(pattern, name)) 
[18:05:03.962]                               next
[18:05:03.962]                             invokeRestart(restart)
[18:05:03.962]                             muffled <- TRUE
[18:05:03.962]                             break
[18:05:03.962]                           }
[18:05:03.962]                         }
[18:05:03.962]                       }
[18:05:03.962]                       invisible(muffled)
[18:05:03.962]                     }
[18:05:03.962]                     muffleCondition(cond, pattern = "^muffle")
[18:05:03.962]                   }
[18:05:03.962]                 }
[18:05:03.962]             }
[18:05:03.962]         }))
[18:05:03.962]     }, error = function(ex) {
[18:05:03.962]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:03.962]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:03.962]                 ...future.rng), started = ...future.startTime, 
[18:05:03.962]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:03.962]             version = "1.8"), class = "FutureResult")
[18:05:03.962]     }, finally = {
[18:05:03.962]         if (!identical(...future.workdir, getwd())) 
[18:05:03.962]             setwd(...future.workdir)
[18:05:03.962]         {
[18:05:03.962]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:03.962]                 ...future.oldOptions$nwarnings <- NULL
[18:05:03.962]             }
[18:05:03.962]             base::options(...future.oldOptions)
[18:05:03.962]             if (.Platform$OS.type == "windows") {
[18:05:03.962]                 old_names <- names(...future.oldEnvVars)
[18:05:03.962]                 envs <- base::Sys.getenv()
[18:05:03.962]                 names <- names(envs)
[18:05:03.962]                 common <- intersect(names, old_names)
[18:05:03.962]                 added <- setdiff(names, old_names)
[18:05:03.962]                 removed <- setdiff(old_names, names)
[18:05:03.962]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:03.962]                   envs[common]]
[18:05:03.962]                 NAMES <- toupper(changed)
[18:05:03.962]                 args <- list()
[18:05:03.962]                 for (kk in seq_along(NAMES)) {
[18:05:03.962]                   name <- changed[[kk]]
[18:05:03.962]                   NAME <- NAMES[[kk]]
[18:05:03.962]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.962]                     next
[18:05:03.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.962]                 }
[18:05:03.962]                 NAMES <- toupper(added)
[18:05:03.962]                 for (kk in seq_along(NAMES)) {
[18:05:03.962]                   name <- added[[kk]]
[18:05:03.962]                   NAME <- NAMES[[kk]]
[18:05:03.962]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.962]                     next
[18:05:03.962]                   args[[name]] <- ""
[18:05:03.962]                 }
[18:05:03.962]                 NAMES <- toupper(removed)
[18:05:03.962]                 for (kk in seq_along(NAMES)) {
[18:05:03.962]                   name <- removed[[kk]]
[18:05:03.962]                   NAME <- NAMES[[kk]]
[18:05:03.962]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:03.962]                     next
[18:05:03.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:03.962]                 }
[18:05:03.962]                 if (length(args) > 0) 
[18:05:03.962]                   base::do.call(base::Sys.setenv, args = args)
[18:05:03.962]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:03.962]             }
[18:05:03.962]             else {
[18:05:03.962]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:03.962]             }
[18:05:03.962]             {
[18:05:03.962]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:03.962]                   0L) {
[18:05:03.962]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:03.962]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:03.962]                   base::options(opts)
[18:05:03.962]                 }
[18:05:03.962]                 {
[18:05:03.962]                   {
[18:05:03.962]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:03.962]                     NULL
[18:05:03.962]                   }
[18:05:03.962]                   options(future.plan = NULL)
[18:05:03.962]                   if (is.na(NA_character_)) 
[18:05:03.962]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:03.962]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:03.962]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:03.962]                     .init = FALSE)
[18:05:03.962]                 }
[18:05:03.962]             }
[18:05:03.962]         }
[18:05:03.962]     })
[18:05:03.962]     if (TRUE) {
[18:05:03.962]         base::sink(type = "output", split = FALSE)
[18:05:03.962]         if (TRUE) {
[18:05:03.962]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:03.962]         }
[18:05:03.962]         else {
[18:05:03.962]             ...future.result["stdout"] <- base::list(NULL)
[18:05:03.962]         }
[18:05:03.962]         base::close(...future.stdout)
[18:05:03.962]         ...future.stdout <- NULL
[18:05:03.962]     }
[18:05:03.962]     ...future.result$conditions <- ...future.conditions
[18:05:03.962]     ...future.result$finished <- base::Sys.time()
[18:05:03.962]     ...future.result
[18:05:03.962] }
[18:05:03.967] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[18:05:03.967] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[18:05:03.968] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[18:05:03.969] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[18:05:03.970] MultisessionFuture started
[18:05:03.970] - Launch lazy future ... done
[18:05:03.970] run() for ‘MultisessionFuture’ ... done
[18:05:03.970] result() for ClusterFuture ...
[18:05:03.971] receiveMessageFromWorker() for ClusterFuture ...
[18:05:03.971] - Validating connection of MultisessionFuture
[18:05:04.014] - received message: FutureResult
[18:05:04.015] - Received FutureResult
[18:05:04.015] - Erased future from FutureRegistry
[18:05:04.015] result() for ClusterFuture ...
[18:05:04.015] - result already collected: FutureResult
[18:05:04.016] result() for ClusterFuture ... done
[18:05:04.016] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:04.016] result() for ClusterFuture ... done
[18:05:04.016] result() for ClusterFuture ...
[18:05:04.016] - result already collected: FutureResult
[18:05:04.017] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[18:05:04.018] plan(): Setting new future strategy stack:
[18:05:04.018] List of future strategies:
[18:05:04.018] 1. FutureStrategy:
[18:05:04.018]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:04.018]    - tweaked: FALSE
[18:05:04.018]    - call: future::plan(oplan)
[18:05:04.020] plan(): nbrOfWorkers() = 1
> 
