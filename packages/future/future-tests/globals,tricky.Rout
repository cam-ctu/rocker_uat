
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:47:06.182] plan(): Setting new future strategy stack:
[17:47:06.183] List of future strategies:
[17:47:06.183] 1. sequential:
[17:47:06.183]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.183]    - tweaked: FALSE
[17:47:06.183]    - call: future::plan("sequential")
[17:47:06.194] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[17:47:06.288] plan(): Setting new future strategy stack:
[17:47:06.288] List of future strategies:
[17:47:06.288] 1. sequential:
[17:47:06.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.288]    - tweaked: FALSE
[17:47:06.288]    - call: plan(strategy)
[17:47:06.300] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.302] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.302] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.308] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:47:06.308] Searching for globals ... DONE
[17:47:06.308] Resolving globals: TRUE
[17:47:06.309] Resolving any globals that are futures ...
[17:47:06.309] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:47:06.309] Resolving any globals that are futures ... DONE
[17:47:06.309] 
[17:47:06.309] 
[17:47:06.309] getGlobalsAndPackages() ... DONE
[17:47:06.310] run() for ‘Future’ ...
[17:47:06.310] - state: ‘created’
[17:47:06.310] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.311] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.311]   - Field: ‘label’
[17:47:06.311]   - Field: ‘local’
[17:47:06.311]   - Field: ‘owner’
[17:47:06.311]   - Field: ‘envir’
[17:47:06.311]   - Field: ‘packages’
[17:47:06.311]   - Field: ‘gc’
[17:47:06.312]   - Field: ‘conditions’
[17:47:06.312]   - Field: ‘expr’
[17:47:06.312]   - Field: ‘uuid’
[17:47:06.312]   - Field: ‘seed’
[17:47:06.312]   - Field: ‘version’
[17:47:06.312]   - Field: ‘result’
[17:47:06.312]   - Field: ‘asynchronous’
[17:47:06.312]   - Field: ‘calls’
[17:47:06.312]   - Field: ‘globals’
[17:47:06.312]   - Field: ‘stdout’
[17:47:06.312]   - Field: ‘earlySignal’
[17:47:06.312]   - Field: ‘lazy’
[17:47:06.313]   - Field: ‘state’
[17:47:06.313] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.313] - Launch lazy future ...
[17:47:06.313] Packages needed by the future expression (n = 0): <none>
[17:47:06.314] Packages needed by future strategies (n = 0): <none>
[17:47:06.314] {
[17:47:06.314]     {
[17:47:06.314]         {
[17:47:06.314]             ...future.startTime <- base::Sys.time()
[17:47:06.314]             {
[17:47:06.314]                 {
[17:47:06.314]                   {
[17:47:06.314]                     base::local({
[17:47:06.314]                       has_future <- base::requireNamespace("future", 
[17:47:06.314]                         quietly = TRUE)
[17:47:06.314]                       if (has_future) {
[17:47:06.314]                         ns <- base::getNamespace("future")
[17:47:06.314]                         version <- ns[[".package"]][["version"]]
[17:47:06.314]                         if (is.null(version)) 
[17:47:06.314]                           version <- utils::packageVersion("future")
[17:47:06.314]                       }
[17:47:06.314]                       else {
[17:47:06.314]                         version <- NULL
[17:47:06.314]                       }
[17:47:06.314]                       if (!has_future || version < "1.8.0") {
[17:47:06.314]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.314]                           "", base::R.version$version.string), 
[17:47:06.314]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.314]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.314]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.314]                             "release", "version")], collapse = " "), 
[17:47:06.314]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.314]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.314]                           info)
[17:47:06.314]                         info <- base::paste(info, collapse = "; ")
[17:47:06.314]                         if (!has_future) {
[17:47:06.314]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.314]                             info)
[17:47:06.314]                         }
[17:47:06.314]                         else {
[17:47:06.314]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.314]                             info, version)
[17:47:06.314]                         }
[17:47:06.314]                         base::stop(msg)
[17:47:06.314]                       }
[17:47:06.314]                     })
[17:47:06.314]                   }
[17:47:06.314]                   ...future.strategy.old <- future::plan("list")
[17:47:06.314]                   options(future.plan = NULL)
[17:47:06.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.314]                 }
[17:47:06.314]                 ...future.workdir <- getwd()
[17:47:06.314]             }
[17:47:06.314]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.314]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.314]         }
[17:47:06.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.314]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.314]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.314]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.314]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.314]             base::names(...future.oldOptions))
[17:47:06.314]     }
[17:47:06.314]     if (FALSE) {
[17:47:06.314]     }
[17:47:06.314]     else {
[17:47:06.314]         if (TRUE) {
[17:47:06.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.314]                 open = "w")
[17:47:06.314]         }
[17:47:06.314]         else {
[17:47:06.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.314]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.314]         }
[17:47:06.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.314]             base::sink(type = "output", split = FALSE)
[17:47:06.314]             base::close(...future.stdout)
[17:47:06.314]         }, add = TRUE)
[17:47:06.314]     }
[17:47:06.314]     ...future.frame <- base::sys.nframe()
[17:47:06.314]     ...future.conditions <- base::list()
[17:47:06.314]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.314]     if (FALSE) {
[17:47:06.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.314]     }
[17:47:06.314]     ...future.result <- base::tryCatch({
[17:47:06.314]         base::withCallingHandlers({
[17:47:06.314]             ...future.value <- base::withVisible(base::local({
[17:47:06.314]                 b <- a
[17:47:06.314]                 a <- 2
[17:47:06.314]                 a * b
[17:47:06.314]             }))
[17:47:06.314]             future::FutureResult(value = ...future.value$value, 
[17:47:06.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.314]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.314]                     ...future.globalenv.names))
[17:47:06.314]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.314]         }, condition = base::local({
[17:47:06.314]             c <- base::c
[17:47:06.314]             inherits <- base::inherits
[17:47:06.314]             invokeRestart <- base::invokeRestart
[17:47:06.314]             length <- base::length
[17:47:06.314]             list <- base::list
[17:47:06.314]             seq.int <- base::seq.int
[17:47:06.314]             signalCondition <- base::signalCondition
[17:47:06.314]             sys.calls <- base::sys.calls
[17:47:06.314]             `[[` <- base::`[[`
[17:47:06.314]             `+` <- base::`+`
[17:47:06.314]             `<<-` <- base::`<<-`
[17:47:06.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.314]                   3L)]
[17:47:06.314]             }
[17:47:06.314]             function(cond) {
[17:47:06.314]                 is_error <- inherits(cond, "error")
[17:47:06.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.314]                   NULL)
[17:47:06.314]                 if (is_error) {
[17:47:06.314]                   sessionInformation <- function() {
[17:47:06.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.314]                       search = base::search(), system = base::Sys.info())
[17:47:06.314]                   }
[17:47:06.314]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.314]                     cond$call), session = sessionInformation(), 
[17:47:06.314]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.314]                   signalCondition(cond)
[17:47:06.314]                 }
[17:47:06.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.314]                 "immediateCondition"))) {
[17:47:06.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.314]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.314]                   if (TRUE && !signal) {
[17:47:06.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.314]                     {
[17:47:06.314]                       inherits <- base::inherits
[17:47:06.314]                       invokeRestart <- base::invokeRestart
[17:47:06.314]                       is.null <- base::is.null
[17:47:06.314]                       muffled <- FALSE
[17:47:06.314]                       if (inherits(cond, "message")) {
[17:47:06.314]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.314]                         if (muffled) 
[17:47:06.314]                           invokeRestart("muffleMessage")
[17:47:06.314]                       }
[17:47:06.314]                       else if (inherits(cond, "warning")) {
[17:47:06.314]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.314]                         if (muffled) 
[17:47:06.314]                           invokeRestart("muffleWarning")
[17:47:06.314]                       }
[17:47:06.314]                       else if (inherits(cond, "condition")) {
[17:47:06.314]                         if (!is.null(pattern)) {
[17:47:06.314]                           computeRestarts <- base::computeRestarts
[17:47:06.314]                           grepl <- base::grepl
[17:47:06.314]                           restarts <- computeRestarts(cond)
[17:47:06.314]                           for (restart in restarts) {
[17:47:06.314]                             name <- restart$name
[17:47:06.314]                             if (is.null(name)) 
[17:47:06.314]                               next
[17:47:06.314]                             if (!grepl(pattern, name)) 
[17:47:06.314]                               next
[17:47:06.314]                             invokeRestart(restart)
[17:47:06.314]                             muffled <- TRUE
[17:47:06.314]                             break
[17:47:06.314]                           }
[17:47:06.314]                         }
[17:47:06.314]                       }
[17:47:06.314]                       invisible(muffled)
[17:47:06.314]                     }
[17:47:06.314]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.314]                   }
[17:47:06.314]                 }
[17:47:06.314]                 else {
[17:47:06.314]                   if (TRUE) {
[17:47:06.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.314]                     {
[17:47:06.314]                       inherits <- base::inherits
[17:47:06.314]                       invokeRestart <- base::invokeRestart
[17:47:06.314]                       is.null <- base::is.null
[17:47:06.314]                       muffled <- FALSE
[17:47:06.314]                       if (inherits(cond, "message")) {
[17:47:06.314]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.314]                         if (muffled) 
[17:47:06.314]                           invokeRestart("muffleMessage")
[17:47:06.314]                       }
[17:47:06.314]                       else if (inherits(cond, "warning")) {
[17:47:06.314]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.314]                         if (muffled) 
[17:47:06.314]                           invokeRestart("muffleWarning")
[17:47:06.314]                       }
[17:47:06.314]                       else if (inherits(cond, "condition")) {
[17:47:06.314]                         if (!is.null(pattern)) {
[17:47:06.314]                           computeRestarts <- base::computeRestarts
[17:47:06.314]                           grepl <- base::grepl
[17:47:06.314]                           restarts <- computeRestarts(cond)
[17:47:06.314]                           for (restart in restarts) {
[17:47:06.314]                             name <- restart$name
[17:47:06.314]                             if (is.null(name)) 
[17:47:06.314]                               next
[17:47:06.314]                             if (!grepl(pattern, name)) 
[17:47:06.314]                               next
[17:47:06.314]                             invokeRestart(restart)
[17:47:06.314]                             muffled <- TRUE
[17:47:06.314]                             break
[17:47:06.314]                           }
[17:47:06.314]                         }
[17:47:06.314]                       }
[17:47:06.314]                       invisible(muffled)
[17:47:06.314]                     }
[17:47:06.314]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.314]                   }
[17:47:06.314]                 }
[17:47:06.314]             }
[17:47:06.314]         }))
[17:47:06.314]     }, error = function(ex) {
[17:47:06.314]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.314]                 ...future.rng), started = ...future.startTime, 
[17:47:06.314]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.314]             version = "1.8"), class = "FutureResult")
[17:47:06.314]     }, finally = {
[17:47:06.314]         if (!identical(...future.workdir, getwd())) 
[17:47:06.314]             setwd(...future.workdir)
[17:47:06.314]         {
[17:47:06.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.314]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.314]             }
[17:47:06.314]             base::options(...future.oldOptions)
[17:47:06.314]             if (.Platform$OS.type == "windows") {
[17:47:06.314]                 old_names <- names(...future.oldEnvVars)
[17:47:06.314]                 envs <- base::Sys.getenv()
[17:47:06.314]                 names <- names(envs)
[17:47:06.314]                 common <- intersect(names, old_names)
[17:47:06.314]                 added <- setdiff(names, old_names)
[17:47:06.314]                 removed <- setdiff(old_names, names)
[17:47:06.314]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.314]                   envs[common]]
[17:47:06.314]                 NAMES <- toupper(changed)
[17:47:06.314]                 args <- list()
[17:47:06.314]                 for (kk in seq_along(NAMES)) {
[17:47:06.314]                   name <- changed[[kk]]
[17:47:06.314]                   NAME <- NAMES[[kk]]
[17:47:06.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.314]                     next
[17:47:06.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.314]                 }
[17:47:06.314]                 NAMES <- toupper(added)
[17:47:06.314]                 for (kk in seq_along(NAMES)) {
[17:47:06.314]                   name <- added[[kk]]
[17:47:06.314]                   NAME <- NAMES[[kk]]
[17:47:06.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.314]                     next
[17:47:06.314]                   args[[name]] <- ""
[17:47:06.314]                 }
[17:47:06.314]                 NAMES <- toupper(removed)
[17:47:06.314]                 for (kk in seq_along(NAMES)) {
[17:47:06.314]                   name <- removed[[kk]]
[17:47:06.314]                   NAME <- NAMES[[kk]]
[17:47:06.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.314]                     next
[17:47:06.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.314]                 }
[17:47:06.314]                 if (length(args) > 0) 
[17:47:06.314]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.314]             }
[17:47:06.314]             else {
[17:47:06.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.314]             }
[17:47:06.314]             {
[17:47:06.314]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.314]                   0L) {
[17:47:06.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.314]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.314]                   base::options(opts)
[17:47:06.314]                 }
[17:47:06.314]                 {
[17:47:06.314]                   {
[17:47:06.314]                     NULL
[17:47:06.314]                     RNGkind("Mersenne-Twister")
[17:47:06.314]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.314]                       inherits = FALSE)
[17:47:06.314]                   }
[17:47:06.314]                   options(future.plan = NULL)
[17:47:06.314]                   if (is.na(NA_character_)) 
[17:47:06.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.314]                     .init = FALSE)
[17:47:06.314]                 }
[17:47:06.314]             }
[17:47:06.314]         }
[17:47:06.314]     })
[17:47:06.314]     if (TRUE) {
[17:47:06.314]         base::sink(type = "output", split = FALSE)
[17:47:06.314]         if (TRUE) {
[17:47:06.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.314]         }
[17:47:06.314]         else {
[17:47:06.314]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.314]         }
[17:47:06.314]         base::close(...future.stdout)
[17:47:06.314]         ...future.stdout <- NULL
[17:47:06.314]     }
[17:47:06.314]     ...future.result$conditions <- ...future.conditions
[17:47:06.314]     ...future.result$finished <- base::Sys.time()
[17:47:06.314]     ...future.result
[17:47:06.314] }
[17:47:06.316] plan(): Setting new future strategy stack:
[17:47:06.316] List of future strategies:
[17:47:06.316] 1. sequential:
[17:47:06.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.316]    - tweaked: FALSE
[17:47:06.316]    - call: NULL
[17:47:06.317] plan(): nbrOfWorkers() = 1
[17:47:06.318] plan(): Setting new future strategy stack:
[17:47:06.318] List of future strategies:
[17:47:06.318] 1. sequential:
[17:47:06.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.318]    - tweaked: FALSE
[17:47:06.318]    - call: plan(strategy)
[17:47:06.318] plan(): nbrOfWorkers() = 1
[17:47:06.318] SequentialFuture started (and completed)
[17:47:06.319] - Launch lazy future ... done
[17:47:06.319] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.320] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.320] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.321] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:47:06.321] Searching for globals ... DONE
[17:47:06.321] Resolving globals: TRUE
[17:47:06.321] Resolving any globals that are futures ...
[17:47:06.322] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:47:06.322] Resolving any globals that are futures ... DONE
[17:47:06.322] 
[17:47:06.322] 
[17:47:06.322] getGlobalsAndPackages() ... DONE
[17:47:06.322] run() for ‘Future’ ...
[17:47:06.323] - state: ‘created’
[17:47:06.323] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.323] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.323] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.323]   - Field: ‘label’
[17:47:06.323]   - Field: ‘local’
[17:47:06.323]   - Field: ‘owner’
[17:47:06.323]   - Field: ‘envir’
[17:47:06.324]   - Field: ‘packages’
[17:47:06.324]   - Field: ‘gc’
[17:47:06.324]   - Field: ‘conditions’
[17:47:06.324]   - Field: ‘expr’
[17:47:06.324]   - Field: ‘uuid’
[17:47:06.324]   - Field: ‘seed’
[17:47:06.324]   - Field: ‘version’
[17:47:06.324]   - Field: ‘result’
[17:47:06.324]   - Field: ‘asynchronous’
[17:47:06.324]   - Field: ‘calls’
[17:47:06.324]   - Field: ‘globals’
[17:47:06.324]   - Field: ‘stdout’
[17:47:06.325]   - Field: ‘earlySignal’
[17:47:06.325]   - Field: ‘lazy’
[17:47:06.325]   - Field: ‘state’
[17:47:06.325] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.325] - Launch lazy future ...
[17:47:06.325] Packages needed by the future expression (n = 0): <none>
[17:47:06.325] Packages needed by future strategies (n = 0): <none>
[17:47:06.326] {
[17:47:06.326]     {
[17:47:06.326]         {
[17:47:06.326]             ...future.startTime <- base::Sys.time()
[17:47:06.326]             {
[17:47:06.326]                 {
[17:47:06.326]                   {
[17:47:06.326]                     base::local({
[17:47:06.326]                       has_future <- base::requireNamespace("future", 
[17:47:06.326]                         quietly = TRUE)
[17:47:06.326]                       if (has_future) {
[17:47:06.326]                         ns <- base::getNamespace("future")
[17:47:06.326]                         version <- ns[[".package"]][["version"]]
[17:47:06.326]                         if (is.null(version)) 
[17:47:06.326]                           version <- utils::packageVersion("future")
[17:47:06.326]                       }
[17:47:06.326]                       else {
[17:47:06.326]                         version <- NULL
[17:47:06.326]                       }
[17:47:06.326]                       if (!has_future || version < "1.8.0") {
[17:47:06.326]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.326]                           "", base::R.version$version.string), 
[17:47:06.326]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.326]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.326]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.326]                             "release", "version")], collapse = " "), 
[17:47:06.326]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.326]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.326]                           info)
[17:47:06.326]                         info <- base::paste(info, collapse = "; ")
[17:47:06.326]                         if (!has_future) {
[17:47:06.326]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.326]                             info)
[17:47:06.326]                         }
[17:47:06.326]                         else {
[17:47:06.326]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.326]                             info, version)
[17:47:06.326]                         }
[17:47:06.326]                         base::stop(msg)
[17:47:06.326]                       }
[17:47:06.326]                     })
[17:47:06.326]                   }
[17:47:06.326]                   ...future.strategy.old <- future::plan("list")
[17:47:06.326]                   options(future.plan = NULL)
[17:47:06.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.326]                 }
[17:47:06.326]                 ...future.workdir <- getwd()
[17:47:06.326]             }
[17:47:06.326]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.326]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.326]         }
[17:47:06.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.326]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.326]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.326]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.326]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.326]             base::names(...future.oldOptions))
[17:47:06.326]     }
[17:47:06.326]     if (FALSE) {
[17:47:06.326]     }
[17:47:06.326]     else {
[17:47:06.326]         if (TRUE) {
[17:47:06.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.326]                 open = "w")
[17:47:06.326]         }
[17:47:06.326]         else {
[17:47:06.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.326]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.326]         }
[17:47:06.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.326]             base::sink(type = "output", split = FALSE)
[17:47:06.326]             base::close(...future.stdout)
[17:47:06.326]         }, add = TRUE)
[17:47:06.326]     }
[17:47:06.326]     ...future.frame <- base::sys.nframe()
[17:47:06.326]     ...future.conditions <- base::list()
[17:47:06.326]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.326]     if (FALSE) {
[17:47:06.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.326]     }
[17:47:06.326]     ...future.result <- base::tryCatch({
[17:47:06.326]         base::withCallingHandlers({
[17:47:06.326]             ...future.value <- base::withVisible(base::local({
[17:47:06.326]                 b <- a
[17:47:06.326]                 a <- 2
[17:47:06.326]                 a * b
[17:47:06.326]             }))
[17:47:06.326]             future::FutureResult(value = ...future.value$value, 
[17:47:06.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.326]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.326]                     ...future.globalenv.names))
[17:47:06.326]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.326]         }, condition = base::local({
[17:47:06.326]             c <- base::c
[17:47:06.326]             inherits <- base::inherits
[17:47:06.326]             invokeRestart <- base::invokeRestart
[17:47:06.326]             length <- base::length
[17:47:06.326]             list <- base::list
[17:47:06.326]             seq.int <- base::seq.int
[17:47:06.326]             signalCondition <- base::signalCondition
[17:47:06.326]             sys.calls <- base::sys.calls
[17:47:06.326]             `[[` <- base::`[[`
[17:47:06.326]             `+` <- base::`+`
[17:47:06.326]             `<<-` <- base::`<<-`
[17:47:06.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.326]                   3L)]
[17:47:06.326]             }
[17:47:06.326]             function(cond) {
[17:47:06.326]                 is_error <- inherits(cond, "error")
[17:47:06.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.326]                   NULL)
[17:47:06.326]                 if (is_error) {
[17:47:06.326]                   sessionInformation <- function() {
[17:47:06.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.326]                       search = base::search(), system = base::Sys.info())
[17:47:06.326]                   }
[17:47:06.326]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.326]                     cond$call), session = sessionInformation(), 
[17:47:06.326]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.326]                   signalCondition(cond)
[17:47:06.326]                 }
[17:47:06.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.326]                 "immediateCondition"))) {
[17:47:06.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.326]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.326]                   if (TRUE && !signal) {
[17:47:06.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.326]                     {
[17:47:06.326]                       inherits <- base::inherits
[17:47:06.326]                       invokeRestart <- base::invokeRestart
[17:47:06.326]                       is.null <- base::is.null
[17:47:06.326]                       muffled <- FALSE
[17:47:06.326]                       if (inherits(cond, "message")) {
[17:47:06.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.326]                         if (muffled) 
[17:47:06.326]                           invokeRestart("muffleMessage")
[17:47:06.326]                       }
[17:47:06.326]                       else if (inherits(cond, "warning")) {
[17:47:06.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.326]                         if (muffled) 
[17:47:06.326]                           invokeRestart("muffleWarning")
[17:47:06.326]                       }
[17:47:06.326]                       else if (inherits(cond, "condition")) {
[17:47:06.326]                         if (!is.null(pattern)) {
[17:47:06.326]                           computeRestarts <- base::computeRestarts
[17:47:06.326]                           grepl <- base::grepl
[17:47:06.326]                           restarts <- computeRestarts(cond)
[17:47:06.326]                           for (restart in restarts) {
[17:47:06.326]                             name <- restart$name
[17:47:06.326]                             if (is.null(name)) 
[17:47:06.326]                               next
[17:47:06.326]                             if (!grepl(pattern, name)) 
[17:47:06.326]                               next
[17:47:06.326]                             invokeRestart(restart)
[17:47:06.326]                             muffled <- TRUE
[17:47:06.326]                             break
[17:47:06.326]                           }
[17:47:06.326]                         }
[17:47:06.326]                       }
[17:47:06.326]                       invisible(muffled)
[17:47:06.326]                     }
[17:47:06.326]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.326]                   }
[17:47:06.326]                 }
[17:47:06.326]                 else {
[17:47:06.326]                   if (TRUE) {
[17:47:06.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.326]                     {
[17:47:06.326]                       inherits <- base::inherits
[17:47:06.326]                       invokeRestart <- base::invokeRestart
[17:47:06.326]                       is.null <- base::is.null
[17:47:06.326]                       muffled <- FALSE
[17:47:06.326]                       if (inherits(cond, "message")) {
[17:47:06.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.326]                         if (muffled) 
[17:47:06.326]                           invokeRestart("muffleMessage")
[17:47:06.326]                       }
[17:47:06.326]                       else if (inherits(cond, "warning")) {
[17:47:06.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.326]                         if (muffled) 
[17:47:06.326]                           invokeRestart("muffleWarning")
[17:47:06.326]                       }
[17:47:06.326]                       else if (inherits(cond, "condition")) {
[17:47:06.326]                         if (!is.null(pattern)) {
[17:47:06.326]                           computeRestarts <- base::computeRestarts
[17:47:06.326]                           grepl <- base::grepl
[17:47:06.326]                           restarts <- computeRestarts(cond)
[17:47:06.326]                           for (restart in restarts) {
[17:47:06.326]                             name <- restart$name
[17:47:06.326]                             if (is.null(name)) 
[17:47:06.326]                               next
[17:47:06.326]                             if (!grepl(pattern, name)) 
[17:47:06.326]                               next
[17:47:06.326]                             invokeRestart(restart)
[17:47:06.326]                             muffled <- TRUE
[17:47:06.326]                             break
[17:47:06.326]                           }
[17:47:06.326]                         }
[17:47:06.326]                       }
[17:47:06.326]                       invisible(muffled)
[17:47:06.326]                     }
[17:47:06.326]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.326]                   }
[17:47:06.326]                 }
[17:47:06.326]             }
[17:47:06.326]         }))
[17:47:06.326]     }, error = function(ex) {
[17:47:06.326]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.326]                 ...future.rng), started = ...future.startTime, 
[17:47:06.326]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.326]             version = "1.8"), class = "FutureResult")
[17:47:06.326]     }, finally = {
[17:47:06.326]         if (!identical(...future.workdir, getwd())) 
[17:47:06.326]             setwd(...future.workdir)
[17:47:06.326]         {
[17:47:06.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.326]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.326]             }
[17:47:06.326]             base::options(...future.oldOptions)
[17:47:06.326]             if (.Platform$OS.type == "windows") {
[17:47:06.326]                 old_names <- names(...future.oldEnvVars)
[17:47:06.326]                 envs <- base::Sys.getenv()
[17:47:06.326]                 names <- names(envs)
[17:47:06.326]                 common <- intersect(names, old_names)
[17:47:06.326]                 added <- setdiff(names, old_names)
[17:47:06.326]                 removed <- setdiff(old_names, names)
[17:47:06.326]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.326]                   envs[common]]
[17:47:06.326]                 NAMES <- toupper(changed)
[17:47:06.326]                 args <- list()
[17:47:06.326]                 for (kk in seq_along(NAMES)) {
[17:47:06.326]                   name <- changed[[kk]]
[17:47:06.326]                   NAME <- NAMES[[kk]]
[17:47:06.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.326]                     next
[17:47:06.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.326]                 }
[17:47:06.326]                 NAMES <- toupper(added)
[17:47:06.326]                 for (kk in seq_along(NAMES)) {
[17:47:06.326]                   name <- added[[kk]]
[17:47:06.326]                   NAME <- NAMES[[kk]]
[17:47:06.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.326]                     next
[17:47:06.326]                   args[[name]] <- ""
[17:47:06.326]                 }
[17:47:06.326]                 NAMES <- toupper(removed)
[17:47:06.326]                 for (kk in seq_along(NAMES)) {
[17:47:06.326]                   name <- removed[[kk]]
[17:47:06.326]                   NAME <- NAMES[[kk]]
[17:47:06.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.326]                     next
[17:47:06.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.326]                 }
[17:47:06.326]                 if (length(args) > 0) 
[17:47:06.326]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.326]             }
[17:47:06.326]             else {
[17:47:06.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.326]             }
[17:47:06.326]             {
[17:47:06.326]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.326]                   0L) {
[17:47:06.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.326]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.326]                   base::options(opts)
[17:47:06.326]                 }
[17:47:06.326]                 {
[17:47:06.326]                   {
[17:47:06.326]                     NULL
[17:47:06.326]                     RNGkind("Mersenne-Twister")
[17:47:06.326]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.326]                       inherits = FALSE)
[17:47:06.326]                   }
[17:47:06.326]                   options(future.plan = NULL)
[17:47:06.326]                   if (is.na(NA_character_)) 
[17:47:06.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.326]                     .init = FALSE)
[17:47:06.326]                 }
[17:47:06.326]             }
[17:47:06.326]         }
[17:47:06.326]     })
[17:47:06.326]     if (TRUE) {
[17:47:06.326]         base::sink(type = "output", split = FALSE)
[17:47:06.326]         if (TRUE) {
[17:47:06.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.326]         }
[17:47:06.326]         else {
[17:47:06.326]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.326]         }
[17:47:06.326]         base::close(...future.stdout)
[17:47:06.326]         ...future.stdout <- NULL
[17:47:06.326]     }
[17:47:06.326]     ...future.result$conditions <- ...future.conditions
[17:47:06.326]     ...future.result$finished <- base::Sys.time()
[17:47:06.326]     ...future.result
[17:47:06.326] }
[17:47:06.327] plan(): Setting new future strategy stack:
[17:47:06.327] List of future strategies:
[17:47:06.327] 1. sequential:
[17:47:06.327]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.327]    - tweaked: FALSE
[17:47:06.327]    - call: NULL
[17:47:06.328] plan(): nbrOfWorkers() = 1
[17:47:06.329] plan(): Setting new future strategy stack:
[17:47:06.329] List of future strategies:
[17:47:06.329] 1. sequential:
[17:47:06.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.329]    - tweaked: FALSE
[17:47:06.329]    - call: plan(strategy)
[17:47:06.329] plan(): nbrOfWorkers() = 1
[17:47:06.329] SequentialFuture started (and completed)
[17:47:06.330] signalConditions() ...
[17:47:06.330]  - include = ‘immediateCondition’
[17:47:06.330]  - exclude = 
[17:47:06.330]  - resignal = FALSE
[17:47:06.330]  - Number of conditions: 1
[17:47:06.330] signalConditions() ... done
[17:47:06.330] - Launch lazy future ... done
[17:47:06.330] run() for ‘SequentialFuture’ ... done
[17:47:06.330] signalConditions() ...
[17:47:06.330]  - include = ‘immediateCondition’
[17:47:06.330]  - exclude = 
[17:47:06.330]  - resignal = FALSE
[17:47:06.331]  - Number of conditions: 1
[17:47:06.331] signalConditions() ... done
[17:47:06.331] Future state: ‘finished’
[17:47:06.331] signalConditions() ...
[17:47:06.331]  - include = ‘condition’
[17:47:06.333]  - exclude = ‘immediateCondition’
[17:47:06.333]  - resignal = TRUE
[17:47:06.333]  - Number of conditions: 1
[17:47:06.333]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:47:06.334] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-22 17:47:06"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.349] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.349] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.350] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.351] Searching for globals ... DONE
[17:47:06.351] Resolving globals: TRUE
[17:47:06.351] Resolving any globals that are futures ...
[17:47:06.351] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.351] Resolving any globals that are futures ... DONE
[17:47:06.351] Resolving futures part of globals (recursively) ...
[17:47:06.352] resolve() on list ...
[17:47:06.352]  recursive: 99
[17:47:06.352]  length: 1
[17:47:06.353]  elements: ‘ii’
[17:47:06.353]  length: 0 (resolved future 1)
[17:47:06.353] resolve() on list ... DONE
[17:47:06.353] - globals: [1] ‘ii’
[17:47:06.353] Resolving futures part of globals (recursively) ... DONE
[17:47:06.353] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.354] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.354] - globals: [1] ‘ii’
[17:47:06.354] 
[17:47:06.354] getGlobalsAndPackages() ... DONE
[17:47:06.354] run() for ‘Future’ ...
[17:47:06.354] - state: ‘created’
[17:47:06.355] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.355] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.355]   - Field: ‘label’
[17:47:06.355]   - Field: ‘local’
[17:47:06.355]   - Field: ‘owner’
[17:47:06.355]   - Field: ‘envir’
[17:47:06.355]   - Field: ‘packages’
[17:47:06.355]   - Field: ‘gc’
[17:47:06.356]   - Field: ‘conditions’
[17:47:06.356]   - Field: ‘expr’
[17:47:06.356]   - Field: ‘uuid’
[17:47:06.356]   - Field: ‘seed’
[17:47:06.356]   - Field: ‘version’
[17:47:06.356]   - Field: ‘result’
[17:47:06.356]   - Field: ‘asynchronous’
[17:47:06.356]   - Field: ‘calls’
[17:47:06.356]   - Field: ‘globals’
[17:47:06.356]   - Field: ‘stdout’
[17:47:06.356]   - Field: ‘earlySignal’
[17:47:06.357]   - Field: ‘lazy’
[17:47:06.357]   - Field: ‘state’
[17:47:06.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.357] - Launch lazy future ...
[17:47:06.357] Packages needed by the future expression (n = 0): <none>
[17:47:06.357] Packages needed by future strategies (n = 0): <none>
[17:47:06.357] {
[17:47:06.357]     {
[17:47:06.357]         {
[17:47:06.357]             ...future.startTime <- base::Sys.time()
[17:47:06.357]             {
[17:47:06.357]                 {
[17:47:06.357]                   {
[17:47:06.357]                     base::local({
[17:47:06.357]                       has_future <- base::requireNamespace("future", 
[17:47:06.357]                         quietly = TRUE)
[17:47:06.357]                       if (has_future) {
[17:47:06.357]                         ns <- base::getNamespace("future")
[17:47:06.357]                         version <- ns[[".package"]][["version"]]
[17:47:06.357]                         if (is.null(version)) 
[17:47:06.357]                           version <- utils::packageVersion("future")
[17:47:06.357]                       }
[17:47:06.357]                       else {
[17:47:06.357]                         version <- NULL
[17:47:06.357]                       }
[17:47:06.357]                       if (!has_future || version < "1.8.0") {
[17:47:06.357]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.357]                           "", base::R.version$version.string), 
[17:47:06.357]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.357]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.357]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.357]                             "release", "version")], collapse = " "), 
[17:47:06.357]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.357]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.357]                           info)
[17:47:06.357]                         info <- base::paste(info, collapse = "; ")
[17:47:06.357]                         if (!has_future) {
[17:47:06.357]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.357]                             info)
[17:47:06.357]                         }
[17:47:06.357]                         else {
[17:47:06.357]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.357]                             info, version)
[17:47:06.357]                         }
[17:47:06.357]                         base::stop(msg)
[17:47:06.357]                       }
[17:47:06.357]                     })
[17:47:06.357]                   }
[17:47:06.357]                   ...future.strategy.old <- future::plan("list")
[17:47:06.357]                   options(future.plan = NULL)
[17:47:06.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.357]                 }
[17:47:06.357]                 ...future.workdir <- getwd()
[17:47:06.357]             }
[17:47:06.357]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.357]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.357]         }
[17:47:06.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.357]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.357]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.357]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.357]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.357]             base::names(...future.oldOptions))
[17:47:06.357]     }
[17:47:06.357]     if (FALSE) {
[17:47:06.357]     }
[17:47:06.357]     else {
[17:47:06.357]         if (TRUE) {
[17:47:06.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.357]                 open = "w")
[17:47:06.357]         }
[17:47:06.357]         else {
[17:47:06.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.357]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.357]         }
[17:47:06.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.357]             base::sink(type = "output", split = FALSE)
[17:47:06.357]             base::close(...future.stdout)
[17:47:06.357]         }, add = TRUE)
[17:47:06.357]     }
[17:47:06.357]     ...future.frame <- base::sys.nframe()
[17:47:06.357]     ...future.conditions <- base::list()
[17:47:06.357]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.357]     if (FALSE) {
[17:47:06.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.357]     }
[17:47:06.357]     ...future.result <- base::tryCatch({
[17:47:06.357]         base::withCallingHandlers({
[17:47:06.357]             ...future.value <- base::withVisible(base::local({
[17:47:06.357]                 b <- a * ii
[17:47:06.357]                 a <- 0
[17:47:06.357]                 b
[17:47:06.357]             }))
[17:47:06.357]             future::FutureResult(value = ...future.value$value, 
[17:47:06.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.357]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.357]                     ...future.globalenv.names))
[17:47:06.357]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.357]         }, condition = base::local({
[17:47:06.357]             c <- base::c
[17:47:06.357]             inherits <- base::inherits
[17:47:06.357]             invokeRestart <- base::invokeRestart
[17:47:06.357]             length <- base::length
[17:47:06.357]             list <- base::list
[17:47:06.357]             seq.int <- base::seq.int
[17:47:06.357]             signalCondition <- base::signalCondition
[17:47:06.357]             sys.calls <- base::sys.calls
[17:47:06.357]             `[[` <- base::`[[`
[17:47:06.357]             `+` <- base::`+`
[17:47:06.357]             `<<-` <- base::`<<-`
[17:47:06.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.357]                   3L)]
[17:47:06.357]             }
[17:47:06.357]             function(cond) {
[17:47:06.357]                 is_error <- inherits(cond, "error")
[17:47:06.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.357]                   NULL)
[17:47:06.357]                 if (is_error) {
[17:47:06.357]                   sessionInformation <- function() {
[17:47:06.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.357]                       search = base::search(), system = base::Sys.info())
[17:47:06.357]                   }
[17:47:06.357]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.357]                     cond$call), session = sessionInformation(), 
[17:47:06.357]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.357]                   signalCondition(cond)
[17:47:06.357]                 }
[17:47:06.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.357]                 "immediateCondition"))) {
[17:47:06.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.357]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.357]                   if (TRUE && !signal) {
[17:47:06.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.357]                     {
[17:47:06.357]                       inherits <- base::inherits
[17:47:06.357]                       invokeRestart <- base::invokeRestart
[17:47:06.357]                       is.null <- base::is.null
[17:47:06.357]                       muffled <- FALSE
[17:47:06.357]                       if (inherits(cond, "message")) {
[17:47:06.357]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.357]                         if (muffled) 
[17:47:06.357]                           invokeRestart("muffleMessage")
[17:47:06.357]                       }
[17:47:06.357]                       else if (inherits(cond, "warning")) {
[17:47:06.357]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.357]                         if (muffled) 
[17:47:06.357]                           invokeRestart("muffleWarning")
[17:47:06.357]                       }
[17:47:06.357]                       else if (inherits(cond, "condition")) {
[17:47:06.357]                         if (!is.null(pattern)) {
[17:47:06.357]                           computeRestarts <- base::computeRestarts
[17:47:06.357]                           grepl <- base::grepl
[17:47:06.357]                           restarts <- computeRestarts(cond)
[17:47:06.357]                           for (restart in restarts) {
[17:47:06.357]                             name <- restart$name
[17:47:06.357]                             if (is.null(name)) 
[17:47:06.357]                               next
[17:47:06.357]                             if (!grepl(pattern, name)) 
[17:47:06.357]                               next
[17:47:06.357]                             invokeRestart(restart)
[17:47:06.357]                             muffled <- TRUE
[17:47:06.357]                             break
[17:47:06.357]                           }
[17:47:06.357]                         }
[17:47:06.357]                       }
[17:47:06.357]                       invisible(muffled)
[17:47:06.357]                     }
[17:47:06.357]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.357]                   }
[17:47:06.357]                 }
[17:47:06.357]                 else {
[17:47:06.357]                   if (TRUE) {
[17:47:06.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.357]                     {
[17:47:06.357]                       inherits <- base::inherits
[17:47:06.357]                       invokeRestart <- base::invokeRestart
[17:47:06.357]                       is.null <- base::is.null
[17:47:06.357]                       muffled <- FALSE
[17:47:06.357]                       if (inherits(cond, "message")) {
[17:47:06.357]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.357]                         if (muffled) 
[17:47:06.357]                           invokeRestart("muffleMessage")
[17:47:06.357]                       }
[17:47:06.357]                       else if (inherits(cond, "warning")) {
[17:47:06.357]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.357]                         if (muffled) 
[17:47:06.357]                           invokeRestart("muffleWarning")
[17:47:06.357]                       }
[17:47:06.357]                       else if (inherits(cond, "condition")) {
[17:47:06.357]                         if (!is.null(pattern)) {
[17:47:06.357]                           computeRestarts <- base::computeRestarts
[17:47:06.357]                           grepl <- base::grepl
[17:47:06.357]                           restarts <- computeRestarts(cond)
[17:47:06.357]                           for (restart in restarts) {
[17:47:06.357]                             name <- restart$name
[17:47:06.357]                             if (is.null(name)) 
[17:47:06.357]                               next
[17:47:06.357]                             if (!grepl(pattern, name)) 
[17:47:06.357]                               next
[17:47:06.357]                             invokeRestart(restart)
[17:47:06.357]                             muffled <- TRUE
[17:47:06.357]                             break
[17:47:06.357]                           }
[17:47:06.357]                         }
[17:47:06.357]                       }
[17:47:06.357]                       invisible(muffled)
[17:47:06.357]                     }
[17:47:06.357]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.357]                   }
[17:47:06.357]                 }
[17:47:06.357]             }
[17:47:06.357]         }))
[17:47:06.357]     }, error = function(ex) {
[17:47:06.357]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.357]                 ...future.rng), started = ...future.startTime, 
[17:47:06.357]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.357]             version = "1.8"), class = "FutureResult")
[17:47:06.357]     }, finally = {
[17:47:06.357]         if (!identical(...future.workdir, getwd())) 
[17:47:06.357]             setwd(...future.workdir)
[17:47:06.357]         {
[17:47:06.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.357]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.357]             }
[17:47:06.357]             base::options(...future.oldOptions)
[17:47:06.357]             if (.Platform$OS.type == "windows") {
[17:47:06.357]                 old_names <- names(...future.oldEnvVars)
[17:47:06.357]                 envs <- base::Sys.getenv()
[17:47:06.357]                 names <- names(envs)
[17:47:06.357]                 common <- intersect(names, old_names)
[17:47:06.357]                 added <- setdiff(names, old_names)
[17:47:06.357]                 removed <- setdiff(old_names, names)
[17:47:06.357]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.357]                   envs[common]]
[17:47:06.357]                 NAMES <- toupper(changed)
[17:47:06.357]                 args <- list()
[17:47:06.357]                 for (kk in seq_along(NAMES)) {
[17:47:06.357]                   name <- changed[[kk]]
[17:47:06.357]                   NAME <- NAMES[[kk]]
[17:47:06.357]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.357]                     next
[17:47:06.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.357]                 }
[17:47:06.357]                 NAMES <- toupper(added)
[17:47:06.357]                 for (kk in seq_along(NAMES)) {
[17:47:06.357]                   name <- added[[kk]]
[17:47:06.357]                   NAME <- NAMES[[kk]]
[17:47:06.357]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.357]                     next
[17:47:06.357]                   args[[name]] <- ""
[17:47:06.357]                 }
[17:47:06.357]                 NAMES <- toupper(removed)
[17:47:06.357]                 for (kk in seq_along(NAMES)) {
[17:47:06.357]                   name <- removed[[kk]]
[17:47:06.357]                   NAME <- NAMES[[kk]]
[17:47:06.357]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.357]                     next
[17:47:06.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.357]                 }
[17:47:06.357]                 if (length(args) > 0) 
[17:47:06.357]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.357]             }
[17:47:06.357]             else {
[17:47:06.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.357]             }
[17:47:06.357]             {
[17:47:06.357]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.357]                   0L) {
[17:47:06.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.357]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.357]                   base::options(opts)
[17:47:06.357]                 }
[17:47:06.357]                 {
[17:47:06.357]                   {
[17:47:06.357]                     NULL
[17:47:06.357]                     RNGkind("Mersenne-Twister")
[17:47:06.357]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.357]                       inherits = FALSE)
[17:47:06.357]                   }
[17:47:06.357]                   options(future.plan = NULL)
[17:47:06.357]                   if (is.na(NA_character_)) 
[17:47:06.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.357]                     .init = FALSE)
[17:47:06.357]                 }
[17:47:06.357]             }
[17:47:06.357]         }
[17:47:06.357]     })
[17:47:06.357]     if (TRUE) {
[17:47:06.357]         base::sink(type = "output", split = FALSE)
[17:47:06.357]         if (TRUE) {
[17:47:06.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.357]         }
[17:47:06.357]         else {
[17:47:06.357]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.357]         }
[17:47:06.357]         base::close(...future.stdout)
[17:47:06.357]         ...future.stdout <- NULL
[17:47:06.357]     }
[17:47:06.357]     ...future.result$conditions <- ...future.conditions
[17:47:06.357]     ...future.result$finished <- base::Sys.time()
[17:47:06.357]     ...future.result
[17:47:06.357] }
[17:47:06.359] assign_globals() ...
[17:47:06.359] List of 1
[17:47:06.359]  $ ii: int 1
[17:47:06.359]  - attr(*, "where")=List of 1
[17:47:06.359]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.359]  - attr(*, "resolved")= logi TRUE
[17:47:06.359]  - attr(*, "total_size")= num 56
[17:47:06.359]  - attr(*, "already-done")= logi TRUE
[17:47:06.362] - copied ‘ii’ to environment
[17:47:06.362] assign_globals() ... done
[17:47:06.362] plan(): Setting new future strategy stack:
[17:47:06.362] List of future strategies:
[17:47:06.362] 1. sequential:
[17:47:06.362]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.362]    - tweaked: FALSE
[17:47:06.362]    - call: NULL
[17:47:06.364] plan(): nbrOfWorkers() = 1
[17:47:06.365] plan(): Setting new future strategy stack:
[17:47:06.365] List of future strategies:
[17:47:06.365] 1. sequential:
[17:47:06.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.365]    - tweaked: FALSE
[17:47:06.365]    - call: plan(strategy)
[17:47:06.365] plan(): nbrOfWorkers() = 1
[17:47:06.365] SequentialFuture started (and completed)
[17:47:06.366] - Launch lazy future ... done
[17:47:06.366] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.366] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.366] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.367] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.368] Searching for globals ... DONE
[17:47:06.368] Resolving globals: TRUE
[17:47:06.368] Resolving any globals that are futures ...
[17:47:06.368] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.368] Resolving any globals that are futures ... DONE
[17:47:06.368] Resolving futures part of globals (recursively) ...
[17:47:06.369] resolve() on list ...
[17:47:06.369]  recursive: 99
[17:47:06.369]  length: 1
[17:47:06.369]  elements: ‘ii’
[17:47:06.369]  length: 0 (resolved future 1)
[17:47:06.369] resolve() on list ... DONE
[17:47:06.369] - globals: [1] ‘ii’
[17:47:06.369] Resolving futures part of globals (recursively) ... DONE
[17:47:06.369] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.370] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.370] - globals: [1] ‘ii’
[17:47:06.370] 
[17:47:06.370] getGlobalsAndPackages() ... DONE
[17:47:06.370] run() for ‘Future’ ...
[17:47:06.370] - state: ‘created’
[17:47:06.370] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.371] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.371]   - Field: ‘label’
[17:47:06.371]   - Field: ‘local’
[17:47:06.371]   - Field: ‘owner’
[17:47:06.371]   - Field: ‘envir’
[17:47:06.371]   - Field: ‘packages’
[17:47:06.371]   - Field: ‘gc’
[17:47:06.371]   - Field: ‘conditions’
[17:47:06.371]   - Field: ‘expr’
[17:47:06.372]   - Field: ‘uuid’
[17:47:06.372]   - Field: ‘seed’
[17:47:06.372]   - Field: ‘version’
[17:47:06.372]   - Field: ‘result’
[17:47:06.372]   - Field: ‘asynchronous’
[17:47:06.372]   - Field: ‘calls’
[17:47:06.372]   - Field: ‘globals’
[17:47:06.372]   - Field: ‘stdout’
[17:47:06.372]   - Field: ‘earlySignal’
[17:47:06.372]   - Field: ‘lazy’
[17:47:06.372]   - Field: ‘state’
[17:47:06.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.373] - Launch lazy future ...
[17:47:06.373] Packages needed by the future expression (n = 0): <none>
[17:47:06.373] Packages needed by future strategies (n = 0): <none>
[17:47:06.373] {
[17:47:06.373]     {
[17:47:06.373]         {
[17:47:06.373]             ...future.startTime <- base::Sys.time()
[17:47:06.373]             {
[17:47:06.373]                 {
[17:47:06.373]                   {
[17:47:06.373]                     base::local({
[17:47:06.373]                       has_future <- base::requireNamespace("future", 
[17:47:06.373]                         quietly = TRUE)
[17:47:06.373]                       if (has_future) {
[17:47:06.373]                         ns <- base::getNamespace("future")
[17:47:06.373]                         version <- ns[[".package"]][["version"]]
[17:47:06.373]                         if (is.null(version)) 
[17:47:06.373]                           version <- utils::packageVersion("future")
[17:47:06.373]                       }
[17:47:06.373]                       else {
[17:47:06.373]                         version <- NULL
[17:47:06.373]                       }
[17:47:06.373]                       if (!has_future || version < "1.8.0") {
[17:47:06.373]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.373]                           "", base::R.version$version.string), 
[17:47:06.373]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.373]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.373]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.373]                             "release", "version")], collapse = " "), 
[17:47:06.373]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.373]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.373]                           info)
[17:47:06.373]                         info <- base::paste(info, collapse = "; ")
[17:47:06.373]                         if (!has_future) {
[17:47:06.373]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.373]                             info)
[17:47:06.373]                         }
[17:47:06.373]                         else {
[17:47:06.373]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.373]                             info, version)
[17:47:06.373]                         }
[17:47:06.373]                         base::stop(msg)
[17:47:06.373]                       }
[17:47:06.373]                     })
[17:47:06.373]                   }
[17:47:06.373]                   ...future.strategy.old <- future::plan("list")
[17:47:06.373]                   options(future.plan = NULL)
[17:47:06.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.373]                 }
[17:47:06.373]                 ...future.workdir <- getwd()
[17:47:06.373]             }
[17:47:06.373]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.373]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.373]         }
[17:47:06.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.373]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.373]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.373]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.373]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.373]             base::names(...future.oldOptions))
[17:47:06.373]     }
[17:47:06.373]     if (FALSE) {
[17:47:06.373]     }
[17:47:06.373]     else {
[17:47:06.373]         if (TRUE) {
[17:47:06.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.373]                 open = "w")
[17:47:06.373]         }
[17:47:06.373]         else {
[17:47:06.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.373]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.373]         }
[17:47:06.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.373]             base::sink(type = "output", split = FALSE)
[17:47:06.373]             base::close(...future.stdout)
[17:47:06.373]         }, add = TRUE)
[17:47:06.373]     }
[17:47:06.373]     ...future.frame <- base::sys.nframe()
[17:47:06.373]     ...future.conditions <- base::list()
[17:47:06.373]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.373]     if (FALSE) {
[17:47:06.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.373]     }
[17:47:06.373]     ...future.result <- base::tryCatch({
[17:47:06.373]         base::withCallingHandlers({
[17:47:06.373]             ...future.value <- base::withVisible(base::local({
[17:47:06.373]                 b <- a * ii
[17:47:06.373]                 a <- 0
[17:47:06.373]                 b
[17:47:06.373]             }))
[17:47:06.373]             future::FutureResult(value = ...future.value$value, 
[17:47:06.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.373]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.373]                     ...future.globalenv.names))
[17:47:06.373]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.373]         }, condition = base::local({
[17:47:06.373]             c <- base::c
[17:47:06.373]             inherits <- base::inherits
[17:47:06.373]             invokeRestart <- base::invokeRestart
[17:47:06.373]             length <- base::length
[17:47:06.373]             list <- base::list
[17:47:06.373]             seq.int <- base::seq.int
[17:47:06.373]             signalCondition <- base::signalCondition
[17:47:06.373]             sys.calls <- base::sys.calls
[17:47:06.373]             `[[` <- base::`[[`
[17:47:06.373]             `+` <- base::`+`
[17:47:06.373]             `<<-` <- base::`<<-`
[17:47:06.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.373]                   3L)]
[17:47:06.373]             }
[17:47:06.373]             function(cond) {
[17:47:06.373]                 is_error <- inherits(cond, "error")
[17:47:06.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.373]                   NULL)
[17:47:06.373]                 if (is_error) {
[17:47:06.373]                   sessionInformation <- function() {
[17:47:06.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.373]                       search = base::search(), system = base::Sys.info())
[17:47:06.373]                   }
[17:47:06.373]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.373]                     cond$call), session = sessionInformation(), 
[17:47:06.373]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.373]                   signalCondition(cond)
[17:47:06.373]                 }
[17:47:06.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.373]                 "immediateCondition"))) {
[17:47:06.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.373]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.373]                   if (TRUE && !signal) {
[17:47:06.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.373]                     {
[17:47:06.373]                       inherits <- base::inherits
[17:47:06.373]                       invokeRestart <- base::invokeRestart
[17:47:06.373]                       is.null <- base::is.null
[17:47:06.373]                       muffled <- FALSE
[17:47:06.373]                       if (inherits(cond, "message")) {
[17:47:06.373]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.373]                         if (muffled) 
[17:47:06.373]                           invokeRestart("muffleMessage")
[17:47:06.373]                       }
[17:47:06.373]                       else if (inherits(cond, "warning")) {
[17:47:06.373]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.373]                         if (muffled) 
[17:47:06.373]                           invokeRestart("muffleWarning")
[17:47:06.373]                       }
[17:47:06.373]                       else if (inherits(cond, "condition")) {
[17:47:06.373]                         if (!is.null(pattern)) {
[17:47:06.373]                           computeRestarts <- base::computeRestarts
[17:47:06.373]                           grepl <- base::grepl
[17:47:06.373]                           restarts <- computeRestarts(cond)
[17:47:06.373]                           for (restart in restarts) {
[17:47:06.373]                             name <- restart$name
[17:47:06.373]                             if (is.null(name)) 
[17:47:06.373]                               next
[17:47:06.373]                             if (!grepl(pattern, name)) 
[17:47:06.373]                               next
[17:47:06.373]                             invokeRestart(restart)
[17:47:06.373]                             muffled <- TRUE
[17:47:06.373]                             break
[17:47:06.373]                           }
[17:47:06.373]                         }
[17:47:06.373]                       }
[17:47:06.373]                       invisible(muffled)
[17:47:06.373]                     }
[17:47:06.373]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.373]                   }
[17:47:06.373]                 }
[17:47:06.373]                 else {
[17:47:06.373]                   if (TRUE) {
[17:47:06.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.373]                     {
[17:47:06.373]                       inherits <- base::inherits
[17:47:06.373]                       invokeRestart <- base::invokeRestart
[17:47:06.373]                       is.null <- base::is.null
[17:47:06.373]                       muffled <- FALSE
[17:47:06.373]                       if (inherits(cond, "message")) {
[17:47:06.373]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.373]                         if (muffled) 
[17:47:06.373]                           invokeRestart("muffleMessage")
[17:47:06.373]                       }
[17:47:06.373]                       else if (inherits(cond, "warning")) {
[17:47:06.373]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.373]                         if (muffled) 
[17:47:06.373]                           invokeRestart("muffleWarning")
[17:47:06.373]                       }
[17:47:06.373]                       else if (inherits(cond, "condition")) {
[17:47:06.373]                         if (!is.null(pattern)) {
[17:47:06.373]                           computeRestarts <- base::computeRestarts
[17:47:06.373]                           grepl <- base::grepl
[17:47:06.373]                           restarts <- computeRestarts(cond)
[17:47:06.373]                           for (restart in restarts) {
[17:47:06.373]                             name <- restart$name
[17:47:06.373]                             if (is.null(name)) 
[17:47:06.373]                               next
[17:47:06.373]                             if (!grepl(pattern, name)) 
[17:47:06.373]                               next
[17:47:06.373]                             invokeRestart(restart)
[17:47:06.373]                             muffled <- TRUE
[17:47:06.373]                             break
[17:47:06.373]                           }
[17:47:06.373]                         }
[17:47:06.373]                       }
[17:47:06.373]                       invisible(muffled)
[17:47:06.373]                     }
[17:47:06.373]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.373]                   }
[17:47:06.373]                 }
[17:47:06.373]             }
[17:47:06.373]         }))
[17:47:06.373]     }, error = function(ex) {
[17:47:06.373]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.373]                 ...future.rng), started = ...future.startTime, 
[17:47:06.373]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.373]             version = "1.8"), class = "FutureResult")
[17:47:06.373]     }, finally = {
[17:47:06.373]         if (!identical(...future.workdir, getwd())) 
[17:47:06.373]             setwd(...future.workdir)
[17:47:06.373]         {
[17:47:06.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.373]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.373]             }
[17:47:06.373]             base::options(...future.oldOptions)
[17:47:06.373]             if (.Platform$OS.type == "windows") {
[17:47:06.373]                 old_names <- names(...future.oldEnvVars)
[17:47:06.373]                 envs <- base::Sys.getenv()
[17:47:06.373]                 names <- names(envs)
[17:47:06.373]                 common <- intersect(names, old_names)
[17:47:06.373]                 added <- setdiff(names, old_names)
[17:47:06.373]                 removed <- setdiff(old_names, names)
[17:47:06.373]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.373]                   envs[common]]
[17:47:06.373]                 NAMES <- toupper(changed)
[17:47:06.373]                 args <- list()
[17:47:06.373]                 for (kk in seq_along(NAMES)) {
[17:47:06.373]                   name <- changed[[kk]]
[17:47:06.373]                   NAME <- NAMES[[kk]]
[17:47:06.373]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.373]                     next
[17:47:06.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.373]                 }
[17:47:06.373]                 NAMES <- toupper(added)
[17:47:06.373]                 for (kk in seq_along(NAMES)) {
[17:47:06.373]                   name <- added[[kk]]
[17:47:06.373]                   NAME <- NAMES[[kk]]
[17:47:06.373]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.373]                     next
[17:47:06.373]                   args[[name]] <- ""
[17:47:06.373]                 }
[17:47:06.373]                 NAMES <- toupper(removed)
[17:47:06.373]                 for (kk in seq_along(NAMES)) {
[17:47:06.373]                   name <- removed[[kk]]
[17:47:06.373]                   NAME <- NAMES[[kk]]
[17:47:06.373]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.373]                     next
[17:47:06.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.373]                 }
[17:47:06.373]                 if (length(args) > 0) 
[17:47:06.373]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.373]             }
[17:47:06.373]             else {
[17:47:06.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.373]             }
[17:47:06.373]             {
[17:47:06.373]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.373]                   0L) {
[17:47:06.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.373]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.373]                   base::options(opts)
[17:47:06.373]                 }
[17:47:06.373]                 {
[17:47:06.373]                   {
[17:47:06.373]                     NULL
[17:47:06.373]                     RNGkind("Mersenne-Twister")
[17:47:06.373]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.373]                       inherits = FALSE)
[17:47:06.373]                   }
[17:47:06.373]                   options(future.plan = NULL)
[17:47:06.373]                   if (is.na(NA_character_)) 
[17:47:06.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.373]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.373]                     .init = FALSE)
[17:47:06.373]                 }
[17:47:06.373]             }
[17:47:06.373]         }
[17:47:06.373]     })
[17:47:06.373]     if (TRUE) {
[17:47:06.373]         base::sink(type = "output", split = FALSE)
[17:47:06.373]         if (TRUE) {
[17:47:06.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.373]         }
[17:47:06.373]         else {
[17:47:06.373]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.373]         }
[17:47:06.373]         base::close(...future.stdout)
[17:47:06.373]         ...future.stdout <- NULL
[17:47:06.373]     }
[17:47:06.373]     ...future.result$conditions <- ...future.conditions
[17:47:06.373]     ...future.result$finished <- base::Sys.time()
[17:47:06.373]     ...future.result
[17:47:06.373] }
[17:47:06.375] assign_globals() ...
[17:47:06.375] List of 1
[17:47:06.375]  $ ii: int 2
[17:47:06.375]  - attr(*, "where")=List of 1
[17:47:06.375]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.375]  - attr(*, "resolved")= logi TRUE
[17:47:06.375]  - attr(*, "total_size")= num 56
[17:47:06.375]  - attr(*, "already-done")= logi TRUE
[17:47:06.377] - copied ‘ii’ to environment
[17:47:06.377] assign_globals() ... done
[17:47:06.378] plan(): Setting new future strategy stack:
[17:47:06.378] List of future strategies:
[17:47:06.378] 1. sequential:
[17:47:06.378]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.378]    - tweaked: FALSE
[17:47:06.378]    - call: NULL
[17:47:06.378] plan(): nbrOfWorkers() = 1
[17:47:06.379] plan(): Setting new future strategy stack:
[17:47:06.379] List of future strategies:
[17:47:06.379] 1. sequential:
[17:47:06.379]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.379]    - tweaked: FALSE
[17:47:06.379]    - call: plan(strategy)
[17:47:06.379] plan(): nbrOfWorkers() = 1
[17:47:06.380] SequentialFuture started (and completed)
[17:47:06.380] - Launch lazy future ... done
[17:47:06.380] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.380] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.380] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.382] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.382] Searching for globals ... DONE
[17:47:06.382] Resolving globals: TRUE
[17:47:06.382] Resolving any globals that are futures ...
[17:47:06.382] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.382] Resolving any globals that are futures ... DONE
[17:47:06.382] Resolving futures part of globals (recursively) ...
[17:47:06.383] resolve() on list ...
[17:47:06.383]  recursive: 99
[17:47:06.383]  length: 1
[17:47:06.383]  elements: ‘ii’
[17:47:06.383]  length: 0 (resolved future 1)
[17:47:06.383] resolve() on list ... DONE
[17:47:06.383] - globals: [1] ‘ii’
[17:47:06.383] Resolving futures part of globals (recursively) ... DONE
[17:47:06.384] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.384] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.384] - globals: [1] ‘ii’
[17:47:06.384] 
[17:47:06.384] getGlobalsAndPackages() ... DONE
[17:47:06.384] run() for ‘Future’ ...
[17:47:06.385] - state: ‘created’
[17:47:06.385] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.385] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.385]   - Field: ‘label’
[17:47:06.385]   - Field: ‘local’
[17:47:06.385]   - Field: ‘owner’
[17:47:06.385]   - Field: ‘envir’
[17:47:06.385]   - Field: ‘packages’
[17:47:06.386]   - Field: ‘gc’
[17:47:06.386]   - Field: ‘conditions’
[17:47:06.386]   - Field: ‘expr’
[17:47:06.386]   - Field: ‘uuid’
[17:47:06.386]   - Field: ‘seed’
[17:47:06.386]   - Field: ‘version’
[17:47:06.386]   - Field: ‘result’
[17:47:06.386]   - Field: ‘asynchronous’
[17:47:06.386]   - Field: ‘calls’
[17:47:06.386]   - Field: ‘globals’
[17:47:06.386]   - Field: ‘stdout’
[17:47:06.387]   - Field: ‘earlySignal’
[17:47:06.387]   - Field: ‘lazy’
[17:47:06.387]   - Field: ‘state’
[17:47:06.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.387] - Launch lazy future ...
[17:47:06.387] Packages needed by the future expression (n = 0): <none>
[17:47:06.387] Packages needed by future strategies (n = 0): <none>
[17:47:06.388] {
[17:47:06.388]     {
[17:47:06.388]         {
[17:47:06.388]             ...future.startTime <- base::Sys.time()
[17:47:06.388]             {
[17:47:06.388]                 {
[17:47:06.388]                   {
[17:47:06.388]                     base::local({
[17:47:06.388]                       has_future <- base::requireNamespace("future", 
[17:47:06.388]                         quietly = TRUE)
[17:47:06.388]                       if (has_future) {
[17:47:06.388]                         ns <- base::getNamespace("future")
[17:47:06.388]                         version <- ns[[".package"]][["version"]]
[17:47:06.388]                         if (is.null(version)) 
[17:47:06.388]                           version <- utils::packageVersion("future")
[17:47:06.388]                       }
[17:47:06.388]                       else {
[17:47:06.388]                         version <- NULL
[17:47:06.388]                       }
[17:47:06.388]                       if (!has_future || version < "1.8.0") {
[17:47:06.388]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.388]                           "", base::R.version$version.string), 
[17:47:06.388]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.388]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.388]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.388]                             "release", "version")], collapse = " "), 
[17:47:06.388]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.388]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.388]                           info)
[17:47:06.388]                         info <- base::paste(info, collapse = "; ")
[17:47:06.388]                         if (!has_future) {
[17:47:06.388]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.388]                             info)
[17:47:06.388]                         }
[17:47:06.388]                         else {
[17:47:06.388]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.388]                             info, version)
[17:47:06.388]                         }
[17:47:06.388]                         base::stop(msg)
[17:47:06.388]                       }
[17:47:06.388]                     })
[17:47:06.388]                   }
[17:47:06.388]                   ...future.strategy.old <- future::plan("list")
[17:47:06.388]                   options(future.plan = NULL)
[17:47:06.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.388]                 }
[17:47:06.388]                 ...future.workdir <- getwd()
[17:47:06.388]             }
[17:47:06.388]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.388]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.388]         }
[17:47:06.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.388]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.388]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.388]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.388]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.388]             base::names(...future.oldOptions))
[17:47:06.388]     }
[17:47:06.388]     if (FALSE) {
[17:47:06.388]     }
[17:47:06.388]     else {
[17:47:06.388]         if (TRUE) {
[17:47:06.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.388]                 open = "w")
[17:47:06.388]         }
[17:47:06.388]         else {
[17:47:06.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.388]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.388]         }
[17:47:06.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.388]             base::sink(type = "output", split = FALSE)
[17:47:06.388]             base::close(...future.stdout)
[17:47:06.388]         }, add = TRUE)
[17:47:06.388]     }
[17:47:06.388]     ...future.frame <- base::sys.nframe()
[17:47:06.388]     ...future.conditions <- base::list()
[17:47:06.388]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.388]     if (FALSE) {
[17:47:06.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.388]     }
[17:47:06.388]     ...future.result <- base::tryCatch({
[17:47:06.388]         base::withCallingHandlers({
[17:47:06.388]             ...future.value <- base::withVisible(base::local({
[17:47:06.388]                 b <- a * ii
[17:47:06.388]                 a <- 0
[17:47:06.388]                 b
[17:47:06.388]             }))
[17:47:06.388]             future::FutureResult(value = ...future.value$value, 
[17:47:06.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.388]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.388]                     ...future.globalenv.names))
[17:47:06.388]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.388]         }, condition = base::local({
[17:47:06.388]             c <- base::c
[17:47:06.388]             inherits <- base::inherits
[17:47:06.388]             invokeRestart <- base::invokeRestart
[17:47:06.388]             length <- base::length
[17:47:06.388]             list <- base::list
[17:47:06.388]             seq.int <- base::seq.int
[17:47:06.388]             signalCondition <- base::signalCondition
[17:47:06.388]             sys.calls <- base::sys.calls
[17:47:06.388]             `[[` <- base::`[[`
[17:47:06.388]             `+` <- base::`+`
[17:47:06.388]             `<<-` <- base::`<<-`
[17:47:06.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.388]                   3L)]
[17:47:06.388]             }
[17:47:06.388]             function(cond) {
[17:47:06.388]                 is_error <- inherits(cond, "error")
[17:47:06.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.388]                   NULL)
[17:47:06.388]                 if (is_error) {
[17:47:06.388]                   sessionInformation <- function() {
[17:47:06.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.388]                       search = base::search(), system = base::Sys.info())
[17:47:06.388]                   }
[17:47:06.388]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.388]                     cond$call), session = sessionInformation(), 
[17:47:06.388]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.388]                   signalCondition(cond)
[17:47:06.388]                 }
[17:47:06.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.388]                 "immediateCondition"))) {
[17:47:06.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.388]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.388]                   if (TRUE && !signal) {
[17:47:06.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.388]                     {
[17:47:06.388]                       inherits <- base::inherits
[17:47:06.388]                       invokeRestart <- base::invokeRestart
[17:47:06.388]                       is.null <- base::is.null
[17:47:06.388]                       muffled <- FALSE
[17:47:06.388]                       if (inherits(cond, "message")) {
[17:47:06.388]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.388]                         if (muffled) 
[17:47:06.388]                           invokeRestart("muffleMessage")
[17:47:06.388]                       }
[17:47:06.388]                       else if (inherits(cond, "warning")) {
[17:47:06.388]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.388]                         if (muffled) 
[17:47:06.388]                           invokeRestart("muffleWarning")
[17:47:06.388]                       }
[17:47:06.388]                       else if (inherits(cond, "condition")) {
[17:47:06.388]                         if (!is.null(pattern)) {
[17:47:06.388]                           computeRestarts <- base::computeRestarts
[17:47:06.388]                           grepl <- base::grepl
[17:47:06.388]                           restarts <- computeRestarts(cond)
[17:47:06.388]                           for (restart in restarts) {
[17:47:06.388]                             name <- restart$name
[17:47:06.388]                             if (is.null(name)) 
[17:47:06.388]                               next
[17:47:06.388]                             if (!grepl(pattern, name)) 
[17:47:06.388]                               next
[17:47:06.388]                             invokeRestart(restart)
[17:47:06.388]                             muffled <- TRUE
[17:47:06.388]                             break
[17:47:06.388]                           }
[17:47:06.388]                         }
[17:47:06.388]                       }
[17:47:06.388]                       invisible(muffled)
[17:47:06.388]                     }
[17:47:06.388]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.388]                   }
[17:47:06.388]                 }
[17:47:06.388]                 else {
[17:47:06.388]                   if (TRUE) {
[17:47:06.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.388]                     {
[17:47:06.388]                       inherits <- base::inherits
[17:47:06.388]                       invokeRestart <- base::invokeRestart
[17:47:06.388]                       is.null <- base::is.null
[17:47:06.388]                       muffled <- FALSE
[17:47:06.388]                       if (inherits(cond, "message")) {
[17:47:06.388]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.388]                         if (muffled) 
[17:47:06.388]                           invokeRestart("muffleMessage")
[17:47:06.388]                       }
[17:47:06.388]                       else if (inherits(cond, "warning")) {
[17:47:06.388]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.388]                         if (muffled) 
[17:47:06.388]                           invokeRestart("muffleWarning")
[17:47:06.388]                       }
[17:47:06.388]                       else if (inherits(cond, "condition")) {
[17:47:06.388]                         if (!is.null(pattern)) {
[17:47:06.388]                           computeRestarts <- base::computeRestarts
[17:47:06.388]                           grepl <- base::grepl
[17:47:06.388]                           restarts <- computeRestarts(cond)
[17:47:06.388]                           for (restart in restarts) {
[17:47:06.388]                             name <- restart$name
[17:47:06.388]                             if (is.null(name)) 
[17:47:06.388]                               next
[17:47:06.388]                             if (!grepl(pattern, name)) 
[17:47:06.388]                               next
[17:47:06.388]                             invokeRestart(restart)
[17:47:06.388]                             muffled <- TRUE
[17:47:06.388]                             break
[17:47:06.388]                           }
[17:47:06.388]                         }
[17:47:06.388]                       }
[17:47:06.388]                       invisible(muffled)
[17:47:06.388]                     }
[17:47:06.388]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.388]                   }
[17:47:06.388]                 }
[17:47:06.388]             }
[17:47:06.388]         }))
[17:47:06.388]     }, error = function(ex) {
[17:47:06.388]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.388]                 ...future.rng), started = ...future.startTime, 
[17:47:06.388]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.388]             version = "1.8"), class = "FutureResult")
[17:47:06.388]     }, finally = {
[17:47:06.388]         if (!identical(...future.workdir, getwd())) 
[17:47:06.388]             setwd(...future.workdir)
[17:47:06.388]         {
[17:47:06.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.388]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.388]             }
[17:47:06.388]             base::options(...future.oldOptions)
[17:47:06.388]             if (.Platform$OS.type == "windows") {
[17:47:06.388]                 old_names <- names(...future.oldEnvVars)
[17:47:06.388]                 envs <- base::Sys.getenv()
[17:47:06.388]                 names <- names(envs)
[17:47:06.388]                 common <- intersect(names, old_names)
[17:47:06.388]                 added <- setdiff(names, old_names)
[17:47:06.388]                 removed <- setdiff(old_names, names)
[17:47:06.388]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.388]                   envs[common]]
[17:47:06.388]                 NAMES <- toupper(changed)
[17:47:06.388]                 args <- list()
[17:47:06.388]                 for (kk in seq_along(NAMES)) {
[17:47:06.388]                   name <- changed[[kk]]
[17:47:06.388]                   NAME <- NAMES[[kk]]
[17:47:06.388]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.388]                     next
[17:47:06.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.388]                 }
[17:47:06.388]                 NAMES <- toupper(added)
[17:47:06.388]                 for (kk in seq_along(NAMES)) {
[17:47:06.388]                   name <- added[[kk]]
[17:47:06.388]                   NAME <- NAMES[[kk]]
[17:47:06.388]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.388]                     next
[17:47:06.388]                   args[[name]] <- ""
[17:47:06.388]                 }
[17:47:06.388]                 NAMES <- toupper(removed)
[17:47:06.388]                 for (kk in seq_along(NAMES)) {
[17:47:06.388]                   name <- removed[[kk]]
[17:47:06.388]                   NAME <- NAMES[[kk]]
[17:47:06.388]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.388]                     next
[17:47:06.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.388]                 }
[17:47:06.388]                 if (length(args) > 0) 
[17:47:06.388]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.388]             }
[17:47:06.388]             else {
[17:47:06.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.388]             }
[17:47:06.388]             {
[17:47:06.388]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.388]                   0L) {
[17:47:06.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.388]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.388]                   base::options(opts)
[17:47:06.388]                 }
[17:47:06.388]                 {
[17:47:06.388]                   {
[17:47:06.388]                     NULL
[17:47:06.388]                     RNGkind("Mersenne-Twister")
[17:47:06.388]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.388]                       inherits = FALSE)
[17:47:06.388]                   }
[17:47:06.388]                   options(future.plan = NULL)
[17:47:06.388]                   if (is.na(NA_character_)) 
[17:47:06.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.388]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.388]                     .init = FALSE)
[17:47:06.388]                 }
[17:47:06.388]             }
[17:47:06.388]         }
[17:47:06.388]     })
[17:47:06.388]     if (TRUE) {
[17:47:06.388]         base::sink(type = "output", split = FALSE)
[17:47:06.388]         if (TRUE) {
[17:47:06.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.388]         }
[17:47:06.388]         else {
[17:47:06.388]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.388]         }
[17:47:06.388]         base::close(...future.stdout)
[17:47:06.388]         ...future.stdout <- NULL
[17:47:06.388]     }
[17:47:06.388]     ...future.result$conditions <- ...future.conditions
[17:47:06.388]     ...future.result$finished <- base::Sys.time()
[17:47:06.388]     ...future.result
[17:47:06.388] }
[17:47:06.389] assign_globals() ...
[17:47:06.389] List of 1
[17:47:06.389]  $ ii: int 3
[17:47:06.389]  - attr(*, "where")=List of 1
[17:47:06.389]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.389]  - attr(*, "resolved")= logi TRUE
[17:47:06.389]  - attr(*, "total_size")= num 56
[17:47:06.389]  - attr(*, "already-done")= logi TRUE
[17:47:06.393] - copied ‘ii’ to environment
[17:47:06.393] assign_globals() ... done
[17:47:06.394] plan(): Setting new future strategy stack:
[17:47:06.394] List of future strategies:
[17:47:06.394] 1. sequential:
[17:47:06.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.394]    - tweaked: FALSE
[17:47:06.394]    - call: NULL
[17:47:06.394] plan(): nbrOfWorkers() = 1
[17:47:06.395] plan(): Setting new future strategy stack:
[17:47:06.395] List of future strategies:
[17:47:06.395] 1. sequential:
[17:47:06.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.395]    - tweaked: FALSE
[17:47:06.395]    - call: plan(strategy)
[17:47:06.395] plan(): nbrOfWorkers() = 1
[17:47:06.396] SequentialFuture started (and completed)
[17:47:06.396] - Launch lazy future ... done
[17:47:06.396] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.397] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.397] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.398] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.398] Searching for globals ... DONE
[17:47:06.399] Resolving globals: TRUE
[17:47:06.399] Resolving any globals that are futures ...
[17:47:06.399] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.399] Resolving any globals that are futures ... DONE
[17:47:06.399] Resolving futures part of globals (recursively) ...
[17:47:06.399] resolve() on list ...
[17:47:06.399]  recursive: 99
[17:47:06.400]  length: 1
[17:47:06.400]  elements: ‘ii’
[17:47:06.400]  length: 0 (resolved future 1)
[17:47:06.400] resolve() on list ... DONE
[17:47:06.400] - globals: [1] ‘ii’
[17:47:06.400] Resolving futures part of globals (recursively) ... DONE
[17:47:06.400] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.400] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.401] - globals: [1] ‘ii’
[17:47:06.401] 
[17:47:06.401] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.401] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.402] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.403] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.403] Searching for globals ... DONE
[17:47:06.403] Resolving globals: TRUE
[17:47:06.403] Resolving any globals that are futures ...
[17:47:06.403] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.403] Resolving any globals that are futures ... DONE
[17:47:06.404] Resolving futures part of globals (recursively) ...
[17:47:06.404] resolve() on list ...
[17:47:06.404]  recursive: 99
[17:47:06.404]  length: 1
[17:47:06.404]  elements: ‘ii’
[17:47:06.404]  length: 0 (resolved future 1)
[17:47:06.404] resolve() on list ... DONE
[17:47:06.404] - globals: [1] ‘ii’
[17:47:06.404] Resolving futures part of globals (recursively) ... DONE
[17:47:06.405] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.405] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.405] - globals: [1] ‘ii’
[17:47:06.405] 
[17:47:06.405] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.406] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.406] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.407] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.407] Searching for globals ... DONE
[17:47:06.407] Resolving globals: TRUE
[17:47:06.407] Resolving any globals that are futures ...
[17:47:06.407] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.408] Resolving any globals that are futures ... DONE
[17:47:06.408] Resolving futures part of globals (recursively) ...
[17:47:06.408] resolve() on list ...
[17:47:06.408]  recursive: 99
[17:47:06.408]  length: 1
[17:47:06.408]  elements: ‘ii’
[17:47:06.408]  length: 0 (resolved future 1)
[17:47:06.409] resolve() on list ... DONE
[17:47:06.409] - globals: [1] ‘ii’
[17:47:06.409] Resolving futures part of globals (recursively) ... DONE
[17:47:06.409] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.409] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.409] - globals: [1] ‘ii’
[17:47:06.409] 
[17:47:06.409] getGlobalsAndPackages() ... DONE
[17:47:06.410] run() for ‘Future’ ...
[17:47:06.410] - state: ‘created’
[17:47:06.410] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.410] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.410]   - Field: ‘label’
[17:47:06.411]   - Field: ‘local’
[17:47:06.411]   - Field: ‘owner’
[17:47:06.411]   - Field: ‘envir’
[17:47:06.411]   - Field: ‘packages’
[17:47:06.411]   - Field: ‘gc’
[17:47:06.411]   - Field: ‘conditions’
[17:47:06.411]   - Field: ‘expr’
[17:47:06.411]   - Field: ‘uuid’
[17:47:06.411]   - Field: ‘seed’
[17:47:06.411]   - Field: ‘version’
[17:47:06.411]   - Field: ‘result’
[17:47:06.412]   - Field: ‘asynchronous’
[17:47:06.412]   - Field: ‘calls’
[17:47:06.412]   - Field: ‘globals’
[17:47:06.412]   - Field: ‘stdout’
[17:47:06.412]   - Field: ‘earlySignal’
[17:47:06.412]   - Field: ‘lazy’
[17:47:06.412]   - Field: ‘state’
[17:47:06.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.412] - Launch lazy future ...
[17:47:06.412] Packages needed by the future expression (n = 0): <none>
[17:47:06.413] Packages needed by future strategies (n = 0): <none>
[17:47:06.413] {
[17:47:06.413]     {
[17:47:06.413]         {
[17:47:06.413]             ...future.startTime <- base::Sys.time()
[17:47:06.413]             {
[17:47:06.413]                 {
[17:47:06.413]                   {
[17:47:06.413]                     base::local({
[17:47:06.413]                       has_future <- base::requireNamespace("future", 
[17:47:06.413]                         quietly = TRUE)
[17:47:06.413]                       if (has_future) {
[17:47:06.413]                         ns <- base::getNamespace("future")
[17:47:06.413]                         version <- ns[[".package"]][["version"]]
[17:47:06.413]                         if (is.null(version)) 
[17:47:06.413]                           version <- utils::packageVersion("future")
[17:47:06.413]                       }
[17:47:06.413]                       else {
[17:47:06.413]                         version <- NULL
[17:47:06.413]                       }
[17:47:06.413]                       if (!has_future || version < "1.8.0") {
[17:47:06.413]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.413]                           "", base::R.version$version.string), 
[17:47:06.413]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.413]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.413]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.413]                             "release", "version")], collapse = " "), 
[17:47:06.413]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.413]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.413]                           info)
[17:47:06.413]                         info <- base::paste(info, collapse = "; ")
[17:47:06.413]                         if (!has_future) {
[17:47:06.413]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.413]                             info)
[17:47:06.413]                         }
[17:47:06.413]                         else {
[17:47:06.413]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.413]                             info, version)
[17:47:06.413]                         }
[17:47:06.413]                         base::stop(msg)
[17:47:06.413]                       }
[17:47:06.413]                     })
[17:47:06.413]                   }
[17:47:06.413]                   ...future.strategy.old <- future::plan("list")
[17:47:06.413]                   options(future.plan = NULL)
[17:47:06.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.413]                 }
[17:47:06.413]                 ...future.workdir <- getwd()
[17:47:06.413]             }
[17:47:06.413]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.413]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.413]         }
[17:47:06.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.413]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.413]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.413]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.413]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.413]             base::names(...future.oldOptions))
[17:47:06.413]     }
[17:47:06.413]     if (FALSE) {
[17:47:06.413]     }
[17:47:06.413]     else {
[17:47:06.413]         if (TRUE) {
[17:47:06.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.413]                 open = "w")
[17:47:06.413]         }
[17:47:06.413]         else {
[17:47:06.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.413]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.413]         }
[17:47:06.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.413]             base::sink(type = "output", split = FALSE)
[17:47:06.413]             base::close(...future.stdout)
[17:47:06.413]         }, add = TRUE)
[17:47:06.413]     }
[17:47:06.413]     ...future.frame <- base::sys.nframe()
[17:47:06.413]     ...future.conditions <- base::list()
[17:47:06.413]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.413]     if (FALSE) {
[17:47:06.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.413]     }
[17:47:06.413]     ...future.result <- base::tryCatch({
[17:47:06.413]         base::withCallingHandlers({
[17:47:06.413]             ...future.value <- base::withVisible(base::local({
[17:47:06.413]                 b <- a * ii
[17:47:06.413]                 a <- 0
[17:47:06.413]                 b
[17:47:06.413]             }))
[17:47:06.413]             future::FutureResult(value = ...future.value$value, 
[17:47:06.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.413]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.413]                     ...future.globalenv.names))
[17:47:06.413]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.413]         }, condition = base::local({
[17:47:06.413]             c <- base::c
[17:47:06.413]             inherits <- base::inherits
[17:47:06.413]             invokeRestart <- base::invokeRestart
[17:47:06.413]             length <- base::length
[17:47:06.413]             list <- base::list
[17:47:06.413]             seq.int <- base::seq.int
[17:47:06.413]             signalCondition <- base::signalCondition
[17:47:06.413]             sys.calls <- base::sys.calls
[17:47:06.413]             `[[` <- base::`[[`
[17:47:06.413]             `+` <- base::`+`
[17:47:06.413]             `<<-` <- base::`<<-`
[17:47:06.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.413]                   3L)]
[17:47:06.413]             }
[17:47:06.413]             function(cond) {
[17:47:06.413]                 is_error <- inherits(cond, "error")
[17:47:06.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.413]                   NULL)
[17:47:06.413]                 if (is_error) {
[17:47:06.413]                   sessionInformation <- function() {
[17:47:06.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.413]                       search = base::search(), system = base::Sys.info())
[17:47:06.413]                   }
[17:47:06.413]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.413]                     cond$call), session = sessionInformation(), 
[17:47:06.413]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.413]                   signalCondition(cond)
[17:47:06.413]                 }
[17:47:06.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.413]                 "immediateCondition"))) {
[17:47:06.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.413]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.413]                   if (TRUE && !signal) {
[17:47:06.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.413]                     {
[17:47:06.413]                       inherits <- base::inherits
[17:47:06.413]                       invokeRestart <- base::invokeRestart
[17:47:06.413]                       is.null <- base::is.null
[17:47:06.413]                       muffled <- FALSE
[17:47:06.413]                       if (inherits(cond, "message")) {
[17:47:06.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.413]                         if (muffled) 
[17:47:06.413]                           invokeRestart("muffleMessage")
[17:47:06.413]                       }
[17:47:06.413]                       else if (inherits(cond, "warning")) {
[17:47:06.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.413]                         if (muffled) 
[17:47:06.413]                           invokeRestart("muffleWarning")
[17:47:06.413]                       }
[17:47:06.413]                       else if (inherits(cond, "condition")) {
[17:47:06.413]                         if (!is.null(pattern)) {
[17:47:06.413]                           computeRestarts <- base::computeRestarts
[17:47:06.413]                           grepl <- base::grepl
[17:47:06.413]                           restarts <- computeRestarts(cond)
[17:47:06.413]                           for (restart in restarts) {
[17:47:06.413]                             name <- restart$name
[17:47:06.413]                             if (is.null(name)) 
[17:47:06.413]                               next
[17:47:06.413]                             if (!grepl(pattern, name)) 
[17:47:06.413]                               next
[17:47:06.413]                             invokeRestart(restart)
[17:47:06.413]                             muffled <- TRUE
[17:47:06.413]                             break
[17:47:06.413]                           }
[17:47:06.413]                         }
[17:47:06.413]                       }
[17:47:06.413]                       invisible(muffled)
[17:47:06.413]                     }
[17:47:06.413]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.413]                   }
[17:47:06.413]                 }
[17:47:06.413]                 else {
[17:47:06.413]                   if (TRUE) {
[17:47:06.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.413]                     {
[17:47:06.413]                       inherits <- base::inherits
[17:47:06.413]                       invokeRestart <- base::invokeRestart
[17:47:06.413]                       is.null <- base::is.null
[17:47:06.413]                       muffled <- FALSE
[17:47:06.413]                       if (inherits(cond, "message")) {
[17:47:06.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.413]                         if (muffled) 
[17:47:06.413]                           invokeRestart("muffleMessage")
[17:47:06.413]                       }
[17:47:06.413]                       else if (inherits(cond, "warning")) {
[17:47:06.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.413]                         if (muffled) 
[17:47:06.413]                           invokeRestart("muffleWarning")
[17:47:06.413]                       }
[17:47:06.413]                       else if (inherits(cond, "condition")) {
[17:47:06.413]                         if (!is.null(pattern)) {
[17:47:06.413]                           computeRestarts <- base::computeRestarts
[17:47:06.413]                           grepl <- base::grepl
[17:47:06.413]                           restarts <- computeRestarts(cond)
[17:47:06.413]                           for (restart in restarts) {
[17:47:06.413]                             name <- restart$name
[17:47:06.413]                             if (is.null(name)) 
[17:47:06.413]                               next
[17:47:06.413]                             if (!grepl(pattern, name)) 
[17:47:06.413]                               next
[17:47:06.413]                             invokeRestart(restart)
[17:47:06.413]                             muffled <- TRUE
[17:47:06.413]                             break
[17:47:06.413]                           }
[17:47:06.413]                         }
[17:47:06.413]                       }
[17:47:06.413]                       invisible(muffled)
[17:47:06.413]                     }
[17:47:06.413]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.413]                   }
[17:47:06.413]                 }
[17:47:06.413]             }
[17:47:06.413]         }))
[17:47:06.413]     }, error = function(ex) {
[17:47:06.413]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.413]                 ...future.rng), started = ...future.startTime, 
[17:47:06.413]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.413]             version = "1.8"), class = "FutureResult")
[17:47:06.413]     }, finally = {
[17:47:06.413]         if (!identical(...future.workdir, getwd())) 
[17:47:06.413]             setwd(...future.workdir)
[17:47:06.413]         {
[17:47:06.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.413]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.413]             }
[17:47:06.413]             base::options(...future.oldOptions)
[17:47:06.413]             if (.Platform$OS.type == "windows") {
[17:47:06.413]                 old_names <- names(...future.oldEnvVars)
[17:47:06.413]                 envs <- base::Sys.getenv()
[17:47:06.413]                 names <- names(envs)
[17:47:06.413]                 common <- intersect(names, old_names)
[17:47:06.413]                 added <- setdiff(names, old_names)
[17:47:06.413]                 removed <- setdiff(old_names, names)
[17:47:06.413]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.413]                   envs[common]]
[17:47:06.413]                 NAMES <- toupper(changed)
[17:47:06.413]                 args <- list()
[17:47:06.413]                 for (kk in seq_along(NAMES)) {
[17:47:06.413]                   name <- changed[[kk]]
[17:47:06.413]                   NAME <- NAMES[[kk]]
[17:47:06.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.413]                     next
[17:47:06.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.413]                 }
[17:47:06.413]                 NAMES <- toupper(added)
[17:47:06.413]                 for (kk in seq_along(NAMES)) {
[17:47:06.413]                   name <- added[[kk]]
[17:47:06.413]                   NAME <- NAMES[[kk]]
[17:47:06.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.413]                     next
[17:47:06.413]                   args[[name]] <- ""
[17:47:06.413]                 }
[17:47:06.413]                 NAMES <- toupper(removed)
[17:47:06.413]                 for (kk in seq_along(NAMES)) {
[17:47:06.413]                   name <- removed[[kk]]
[17:47:06.413]                   NAME <- NAMES[[kk]]
[17:47:06.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.413]                     next
[17:47:06.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.413]                 }
[17:47:06.413]                 if (length(args) > 0) 
[17:47:06.413]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.413]             }
[17:47:06.413]             else {
[17:47:06.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.413]             }
[17:47:06.413]             {
[17:47:06.413]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.413]                   0L) {
[17:47:06.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.413]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.413]                   base::options(opts)
[17:47:06.413]                 }
[17:47:06.413]                 {
[17:47:06.413]                   {
[17:47:06.413]                     NULL
[17:47:06.413]                     RNGkind("Mersenne-Twister")
[17:47:06.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.413]                       inherits = FALSE)
[17:47:06.413]                   }
[17:47:06.413]                   options(future.plan = NULL)
[17:47:06.413]                   if (is.na(NA_character_)) 
[17:47:06.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.413]                     .init = FALSE)
[17:47:06.413]                 }
[17:47:06.413]             }
[17:47:06.413]         }
[17:47:06.413]     })
[17:47:06.413]     if (TRUE) {
[17:47:06.413]         base::sink(type = "output", split = FALSE)
[17:47:06.413]         if (TRUE) {
[17:47:06.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.413]         }
[17:47:06.413]         else {
[17:47:06.413]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.413]         }
[17:47:06.413]         base::close(...future.stdout)
[17:47:06.413]         ...future.stdout <- NULL
[17:47:06.413]     }
[17:47:06.413]     ...future.result$conditions <- ...future.conditions
[17:47:06.413]     ...future.result$finished <- base::Sys.time()
[17:47:06.413]     ...future.result
[17:47:06.413] }
[17:47:06.414] assign_globals() ...
[17:47:06.415] List of 1
[17:47:06.415]  $ ii: int 1
[17:47:06.415]  - attr(*, "where")=List of 1
[17:47:06.415]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.415]  - attr(*, "resolved")= logi TRUE
[17:47:06.415]  - attr(*, "total_size")= num 56
[17:47:06.415]  - attr(*, "already-done")= logi TRUE
[17:47:06.417] - copied ‘ii’ to environment
[17:47:06.417] assign_globals() ... done
[17:47:06.417] plan(): Setting new future strategy stack:
[17:47:06.417] List of future strategies:
[17:47:06.417] 1. sequential:
[17:47:06.417]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.417]    - tweaked: FALSE
[17:47:06.417]    - call: NULL
[17:47:06.418] plan(): nbrOfWorkers() = 1
[17:47:06.420] plan(): Setting new future strategy stack:
[17:47:06.420] List of future strategies:
[17:47:06.420] 1. sequential:
[17:47:06.420]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.420]    - tweaked: FALSE
[17:47:06.420]    - call: plan(strategy)
[17:47:06.421] plan(): nbrOfWorkers() = 1
[17:47:06.421] SequentialFuture started (and completed)
[17:47:06.421] signalConditions() ...
[17:47:06.421]  - include = ‘immediateCondition’
[17:47:06.421]  - exclude = 
[17:47:06.421]  - resignal = FALSE
[17:47:06.421]  - Number of conditions: 1
[17:47:06.421] signalConditions() ... done
[17:47:06.421] - Launch lazy future ... done
[17:47:06.422] run() for ‘SequentialFuture’ ... done
[17:47:06.422] signalConditions() ...
[17:47:06.422]  - include = ‘immediateCondition’
[17:47:06.422]  - exclude = 
[17:47:06.422]  - resignal = FALSE
[17:47:06.422]  - Number of conditions: 1
[17:47:06.422] signalConditions() ... done
[17:47:06.422] Future state: ‘finished’
[17:47:06.422] signalConditions() ...
[17:47:06.422]  - include = ‘condition’
[17:47:06.422]  - exclude = ‘immediateCondition’
[17:47:06.423]  - resignal = TRUE
[17:47:06.423]  - Number of conditions: 1
[17:47:06.423]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:47:06.423] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-22 17:47:06"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.435] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.436] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.436] 
[17:47:06.436] Searching for globals ... DONE
[17:47:06.436] - globals: [0] <none>
[17:47:06.436] getGlobalsAndPackages() ... DONE
[17:47:06.437] run() for ‘Future’ ...
[17:47:06.437] - state: ‘created’
[17:47:06.437] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.437] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.437]   - Field: ‘label’
[17:47:06.437]   - Field: ‘local’
[17:47:06.438]   - Field: ‘owner’
[17:47:06.438]   - Field: ‘envir’
[17:47:06.438]   - Field: ‘packages’
[17:47:06.438]   - Field: ‘gc’
[17:47:06.438]   - Field: ‘conditions’
[17:47:06.438]   - Field: ‘expr’
[17:47:06.438]   - Field: ‘uuid’
[17:47:06.438]   - Field: ‘seed’
[17:47:06.438]   - Field: ‘version’
[17:47:06.438]   - Field: ‘result’
[17:47:06.438]   - Field: ‘asynchronous’
[17:47:06.438]   - Field: ‘calls’
[17:47:06.439]   - Field: ‘globals’
[17:47:06.439]   - Field: ‘stdout’
[17:47:06.439]   - Field: ‘earlySignal’
[17:47:06.439]   - Field: ‘lazy’
[17:47:06.439]   - Field: ‘state’
[17:47:06.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.439] - Launch lazy future ...
[17:47:06.439] Packages needed by the future expression (n = 0): <none>
[17:47:06.439] Packages needed by future strategies (n = 0): <none>
[17:47:06.440] {
[17:47:06.440]     {
[17:47:06.440]         {
[17:47:06.440]             ...future.startTime <- base::Sys.time()
[17:47:06.440]             {
[17:47:06.440]                 {
[17:47:06.440]                   {
[17:47:06.440]                     base::local({
[17:47:06.440]                       has_future <- base::requireNamespace("future", 
[17:47:06.440]                         quietly = TRUE)
[17:47:06.440]                       if (has_future) {
[17:47:06.440]                         ns <- base::getNamespace("future")
[17:47:06.440]                         version <- ns[[".package"]][["version"]]
[17:47:06.440]                         if (is.null(version)) 
[17:47:06.440]                           version <- utils::packageVersion("future")
[17:47:06.440]                       }
[17:47:06.440]                       else {
[17:47:06.440]                         version <- NULL
[17:47:06.440]                       }
[17:47:06.440]                       if (!has_future || version < "1.8.0") {
[17:47:06.440]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.440]                           "", base::R.version$version.string), 
[17:47:06.440]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.440]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.440]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.440]                             "release", "version")], collapse = " "), 
[17:47:06.440]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.440]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.440]                           info)
[17:47:06.440]                         info <- base::paste(info, collapse = "; ")
[17:47:06.440]                         if (!has_future) {
[17:47:06.440]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.440]                             info)
[17:47:06.440]                         }
[17:47:06.440]                         else {
[17:47:06.440]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.440]                             info, version)
[17:47:06.440]                         }
[17:47:06.440]                         base::stop(msg)
[17:47:06.440]                       }
[17:47:06.440]                     })
[17:47:06.440]                   }
[17:47:06.440]                   ...future.strategy.old <- future::plan("list")
[17:47:06.440]                   options(future.plan = NULL)
[17:47:06.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.440]                 }
[17:47:06.440]                 ...future.workdir <- getwd()
[17:47:06.440]             }
[17:47:06.440]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.440]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.440]         }
[17:47:06.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.440]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.440]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.440]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.440]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.440]             base::names(...future.oldOptions))
[17:47:06.440]     }
[17:47:06.440]     if (FALSE) {
[17:47:06.440]     }
[17:47:06.440]     else {
[17:47:06.440]         if (TRUE) {
[17:47:06.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.440]                 open = "w")
[17:47:06.440]         }
[17:47:06.440]         else {
[17:47:06.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.440]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.440]         }
[17:47:06.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.440]             base::sink(type = "output", split = FALSE)
[17:47:06.440]             base::close(...future.stdout)
[17:47:06.440]         }, add = TRUE)
[17:47:06.440]     }
[17:47:06.440]     ...future.frame <- base::sys.nframe()
[17:47:06.440]     ...future.conditions <- base::list()
[17:47:06.440]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.440]     if (FALSE) {
[17:47:06.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.440]     }
[17:47:06.440]     ...future.result <- base::tryCatch({
[17:47:06.440]         base::withCallingHandlers({
[17:47:06.440]             ...future.value <- base::withVisible(base::local(1))
[17:47:06.440]             future::FutureResult(value = ...future.value$value, 
[17:47:06.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.440]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.440]                     ...future.globalenv.names))
[17:47:06.440]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.440]         }, condition = base::local({
[17:47:06.440]             c <- base::c
[17:47:06.440]             inherits <- base::inherits
[17:47:06.440]             invokeRestart <- base::invokeRestart
[17:47:06.440]             length <- base::length
[17:47:06.440]             list <- base::list
[17:47:06.440]             seq.int <- base::seq.int
[17:47:06.440]             signalCondition <- base::signalCondition
[17:47:06.440]             sys.calls <- base::sys.calls
[17:47:06.440]             `[[` <- base::`[[`
[17:47:06.440]             `+` <- base::`+`
[17:47:06.440]             `<<-` <- base::`<<-`
[17:47:06.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.440]                   3L)]
[17:47:06.440]             }
[17:47:06.440]             function(cond) {
[17:47:06.440]                 is_error <- inherits(cond, "error")
[17:47:06.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.440]                   NULL)
[17:47:06.440]                 if (is_error) {
[17:47:06.440]                   sessionInformation <- function() {
[17:47:06.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.440]                       search = base::search(), system = base::Sys.info())
[17:47:06.440]                   }
[17:47:06.440]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.440]                     cond$call), session = sessionInformation(), 
[17:47:06.440]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.440]                   signalCondition(cond)
[17:47:06.440]                 }
[17:47:06.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.440]                 "immediateCondition"))) {
[17:47:06.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.440]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.440]                   if (TRUE && !signal) {
[17:47:06.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.440]                     {
[17:47:06.440]                       inherits <- base::inherits
[17:47:06.440]                       invokeRestart <- base::invokeRestart
[17:47:06.440]                       is.null <- base::is.null
[17:47:06.440]                       muffled <- FALSE
[17:47:06.440]                       if (inherits(cond, "message")) {
[17:47:06.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.440]                         if (muffled) 
[17:47:06.440]                           invokeRestart("muffleMessage")
[17:47:06.440]                       }
[17:47:06.440]                       else if (inherits(cond, "warning")) {
[17:47:06.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.440]                         if (muffled) 
[17:47:06.440]                           invokeRestart("muffleWarning")
[17:47:06.440]                       }
[17:47:06.440]                       else if (inherits(cond, "condition")) {
[17:47:06.440]                         if (!is.null(pattern)) {
[17:47:06.440]                           computeRestarts <- base::computeRestarts
[17:47:06.440]                           grepl <- base::grepl
[17:47:06.440]                           restarts <- computeRestarts(cond)
[17:47:06.440]                           for (restart in restarts) {
[17:47:06.440]                             name <- restart$name
[17:47:06.440]                             if (is.null(name)) 
[17:47:06.440]                               next
[17:47:06.440]                             if (!grepl(pattern, name)) 
[17:47:06.440]                               next
[17:47:06.440]                             invokeRestart(restart)
[17:47:06.440]                             muffled <- TRUE
[17:47:06.440]                             break
[17:47:06.440]                           }
[17:47:06.440]                         }
[17:47:06.440]                       }
[17:47:06.440]                       invisible(muffled)
[17:47:06.440]                     }
[17:47:06.440]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.440]                   }
[17:47:06.440]                 }
[17:47:06.440]                 else {
[17:47:06.440]                   if (TRUE) {
[17:47:06.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.440]                     {
[17:47:06.440]                       inherits <- base::inherits
[17:47:06.440]                       invokeRestart <- base::invokeRestart
[17:47:06.440]                       is.null <- base::is.null
[17:47:06.440]                       muffled <- FALSE
[17:47:06.440]                       if (inherits(cond, "message")) {
[17:47:06.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.440]                         if (muffled) 
[17:47:06.440]                           invokeRestart("muffleMessage")
[17:47:06.440]                       }
[17:47:06.440]                       else if (inherits(cond, "warning")) {
[17:47:06.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.440]                         if (muffled) 
[17:47:06.440]                           invokeRestart("muffleWarning")
[17:47:06.440]                       }
[17:47:06.440]                       else if (inherits(cond, "condition")) {
[17:47:06.440]                         if (!is.null(pattern)) {
[17:47:06.440]                           computeRestarts <- base::computeRestarts
[17:47:06.440]                           grepl <- base::grepl
[17:47:06.440]                           restarts <- computeRestarts(cond)
[17:47:06.440]                           for (restart in restarts) {
[17:47:06.440]                             name <- restart$name
[17:47:06.440]                             if (is.null(name)) 
[17:47:06.440]                               next
[17:47:06.440]                             if (!grepl(pattern, name)) 
[17:47:06.440]                               next
[17:47:06.440]                             invokeRestart(restart)
[17:47:06.440]                             muffled <- TRUE
[17:47:06.440]                             break
[17:47:06.440]                           }
[17:47:06.440]                         }
[17:47:06.440]                       }
[17:47:06.440]                       invisible(muffled)
[17:47:06.440]                     }
[17:47:06.440]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.440]                   }
[17:47:06.440]                 }
[17:47:06.440]             }
[17:47:06.440]         }))
[17:47:06.440]     }, error = function(ex) {
[17:47:06.440]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.440]                 ...future.rng), started = ...future.startTime, 
[17:47:06.440]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.440]             version = "1.8"), class = "FutureResult")
[17:47:06.440]     }, finally = {
[17:47:06.440]         if (!identical(...future.workdir, getwd())) 
[17:47:06.440]             setwd(...future.workdir)
[17:47:06.440]         {
[17:47:06.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.440]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.440]             }
[17:47:06.440]             base::options(...future.oldOptions)
[17:47:06.440]             if (.Platform$OS.type == "windows") {
[17:47:06.440]                 old_names <- names(...future.oldEnvVars)
[17:47:06.440]                 envs <- base::Sys.getenv()
[17:47:06.440]                 names <- names(envs)
[17:47:06.440]                 common <- intersect(names, old_names)
[17:47:06.440]                 added <- setdiff(names, old_names)
[17:47:06.440]                 removed <- setdiff(old_names, names)
[17:47:06.440]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.440]                   envs[common]]
[17:47:06.440]                 NAMES <- toupper(changed)
[17:47:06.440]                 args <- list()
[17:47:06.440]                 for (kk in seq_along(NAMES)) {
[17:47:06.440]                   name <- changed[[kk]]
[17:47:06.440]                   NAME <- NAMES[[kk]]
[17:47:06.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.440]                     next
[17:47:06.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.440]                 }
[17:47:06.440]                 NAMES <- toupper(added)
[17:47:06.440]                 for (kk in seq_along(NAMES)) {
[17:47:06.440]                   name <- added[[kk]]
[17:47:06.440]                   NAME <- NAMES[[kk]]
[17:47:06.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.440]                     next
[17:47:06.440]                   args[[name]] <- ""
[17:47:06.440]                 }
[17:47:06.440]                 NAMES <- toupper(removed)
[17:47:06.440]                 for (kk in seq_along(NAMES)) {
[17:47:06.440]                   name <- removed[[kk]]
[17:47:06.440]                   NAME <- NAMES[[kk]]
[17:47:06.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.440]                     next
[17:47:06.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.440]                 }
[17:47:06.440]                 if (length(args) > 0) 
[17:47:06.440]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.440]             }
[17:47:06.440]             else {
[17:47:06.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.440]             }
[17:47:06.440]             {
[17:47:06.440]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.440]                   0L) {
[17:47:06.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.440]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.440]                   base::options(opts)
[17:47:06.440]                 }
[17:47:06.440]                 {
[17:47:06.440]                   {
[17:47:06.440]                     NULL
[17:47:06.440]                     RNGkind("Mersenne-Twister")
[17:47:06.440]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.440]                       inherits = FALSE)
[17:47:06.440]                   }
[17:47:06.440]                   options(future.plan = NULL)
[17:47:06.440]                   if (is.na(NA_character_)) 
[17:47:06.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.440]                     .init = FALSE)
[17:47:06.440]                 }
[17:47:06.440]             }
[17:47:06.440]         }
[17:47:06.440]     })
[17:47:06.440]     if (TRUE) {
[17:47:06.440]         base::sink(type = "output", split = FALSE)
[17:47:06.440]         if (TRUE) {
[17:47:06.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.440]         }
[17:47:06.440]         else {
[17:47:06.440]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.440]         }
[17:47:06.440]         base::close(...future.stdout)
[17:47:06.440]         ...future.stdout <- NULL
[17:47:06.440]     }
[17:47:06.440]     ...future.result$conditions <- ...future.conditions
[17:47:06.440]     ...future.result$finished <- base::Sys.time()
[17:47:06.440]     ...future.result
[17:47:06.440] }
[17:47:06.441] plan(): Setting new future strategy stack:
[17:47:06.442] List of future strategies:
[17:47:06.442] 1. sequential:
[17:47:06.442]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.442]    - tweaked: FALSE
[17:47:06.442]    - call: NULL
[17:47:06.442] plan(): nbrOfWorkers() = 1
[17:47:06.443] plan(): Setting new future strategy stack:
[17:47:06.443] List of future strategies:
[17:47:06.443] 1. sequential:
[17:47:06.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.443]    - tweaked: FALSE
[17:47:06.443]    - call: plan(strategy)
[17:47:06.443] plan(): nbrOfWorkers() = 1
[17:47:06.443] SequentialFuture started (and completed)
[17:47:06.443] - Launch lazy future ... done
[17:47:06.443] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.444] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.444] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.446] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:06.446] Searching for globals ... DONE
[17:47:06.446] Resolving globals: TRUE
[17:47:06.446] Resolving any globals that are futures ...
[17:47:06.446] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:06.447] Resolving any globals that are futures ... DONE
[17:47:06.447] Resolving futures part of globals (recursively) ...
[17:47:06.447] resolve() on list ...
[17:47:06.447]  recursive: 99
[17:47:06.447]  length: 1
[17:47:06.447]  elements: ‘a’
[17:47:06.448] resolved() for ‘SequentialFuture’ ...
[17:47:06.448] - state: ‘finished’
[17:47:06.448] - run: TRUE
[17:47:06.448] - result: ‘FutureResult’
[17:47:06.448] resolved() for ‘SequentialFuture’ ... done
[17:47:06.448] Future #1
[17:47:06.448] resolved() for ‘SequentialFuture’ ...
[17:47:06.448] - state: ‘finished’
[17:47:06.448] - run: TRUE
[17:47:06.449] - result: ‘FutureResult’
[17:47:06.449] resolved() for ‘SequentialFuture’ ... done
[17:47:06.449] A SequentialFuture was resolved
[17:47:06.449]  length: 0 (resolved future 1)
[17:47:06.449] resolve() on list ... DONE
[17:47:06.449] - globals: [1] ‘a’
[17:47:06.449] Resolving futures part of globals (recursively) ... DONE
[17:47:06.450] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[17:47:06.450] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[17:47:06.450] - globals: [1] ‘a’
[17:47:06.450] - packages: [1] ‘future’
[17:47:06.450] getGlobalsAndPackages() ... DONE
[17:47:06.451] run() for ‘Future’ ...
[17:47:06.451] - state: ‘created’
[17:47:06.451] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.451] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.451]   - Field: ‘label’
[17:47:06.451]   - Field: ‘local’
[17:47:06.452]   - Field: ‘owner’
[17:47:06.452]   - Field: ‘envir’
[17:47:06.452]   - Field: ‘packages’
[17:47:06.452]   - Field: ‘gc’
[17:47:06.452]   - Field: ‘conditions’
[17:47:06.452]   - Field: ‘expr’
[17:47:06.452]   - Field: ‘uuid’
[17:47:06.452]   - Field: ‘seed’
[17:47:06.452]   - Field: ‘version’
[17:47:06.452]   - Field: ‘result’
[17:47:06.452]   - Field: ‘asynchronous’
[17:47:06.453]   - Field: ‘calls’
[17:47:06.453]   - Field: ‘globals’
[17:47:06.453]   - Field: ‘stdout’
[17:47:06.453]   - Field: ‘earlySignal’
[17:47:06.453]   - Field: ‘lazy’
[17:47:06.453]   - Field: ‘state’
[17:47:06.453] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.453] - Launch lazy future ...
[17:47:06.453] Packages needed by the future expression (n = 1): ‘future’
[17:47:06.453] Packages needed by future strategies (n = 0): <none>
[17:47:06.454] {
[17:47:06.454]     {
[17:47:06.454]         {
[17:47:06.454]             ...future.startTime <- base::Sys.time()
[17:47:06.454]             {
[17:47:06.454]                 {
[17:47:06.454]                   {
[17:47:06.454]                     {
[17:47:06.454]                       base::local({
[17:47:06.454]                         has_future <- base::requireNamespace("future", 
[17:47:06.454]                           quietly = TRUE)
[17:47:06.454]                         if (has_future) {
[17:47:06.454]                           ns <- base::getNamespace("future")
[17:47:06.454]                           version <- ns[[".package"]][["version"]]
[17:47:06.454]                           if (is.null(version)) 
[17:47:06.454]                             version <- utils::packageVersion("future")
[17:47:06.454]                         }
[17:47:06.454]                         else {
[17:47:06.454]                           version <- NULL
[17:47:06.454]                         }
[17:47:06.454]                         if (!has_future || version < "1.8.0") {
[17:47:06.454]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.454]                             "", base::R.version$version.string), 
[17:47:06.454]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.454]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.454]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.454]                               "release", "version")], collapse = " "), 
[17:47:06.454]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.454]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.454]                             info)
[17:47:06.454]                           info <- base::paste(info, collapse = "; ")
[17:47:06.454]                           if (!has_future) {
[17:47:06.454]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.454]                               info)
[17:47:06.454]                           }
[17:47:06.454]                           else {
[17:47:06.454]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.454]                               info, version)
[17:47:06.454]                           }
[17:47:06.454]                           base::stop(msg)
[17:47:06.454]                         }
[17:47:06.454]                       })
[17:47:06.454]                     }
[17:47:06.454]                     base::local({
[17:47:06.454]                       for (pkg in "future") {
[17:47:06.454]                         base::loadNamespace(pkg)
[17:47:06.454]                         base::library(pkg, character.only = TRUE)
[17:47:06.454]                       }
[17:47:06.454]                     })
[17:47:06.454]                   }
[17:47:06.454]                   ...future.strategy.old <- future::plan("list")
[17:47:06.454]                   options(future.plan = NULL)
[17:47:06.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.454]                 }
[17:47:06.454]                 ...future.workdir <- getwd()
[17:47:06.454]             }
[17:47:06.454]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.454]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.454]         }
[17:47:06.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.454]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.454]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.454]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.454]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.454]             base::names(...future.oldOptions))
[17:47:06.454]     }
[17:47:06.454]     if (FALSE) {
[17:47:06.454]     }
[17:47:06.454]     else {
[17:47:06.454]         if (TRUE) {
[17:47:06.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.454]                 open = "w")
[17:47:06.454]         }
[17:47:06.454]         else {
[17:47:06.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.454]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.454]         }
[17:47:06.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.454]             base::sink(type = "output", split = FALSE)
[17:47:06.454]             base::close(...future.stdout)
[17:47:06.454]         }, add = TRUE)
[17:47:06.454]     }
[17:47:06.454]     ...future.frame <- base::sys.nframe()
[17:47:06.454]     ...future.conditions <- base::list()
[17:47:06.454]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.454]     if (FALSE) {
[17:47:06.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.454]     }
[17:47:06.454]     ...future.result <- base::tryCatch({
[17:47:06.454]         base::withCallingHandlers({
[17:47:06.454]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:47:06.454]                 1))
[17:47:06.454]             future::FutureResult(value = ...future.value$value, 
[17:47:06.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.454]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.454]                     ...future.globalenv.names))
[17:47:06.454]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.454]         }, condition = base::local({
[17:47:06.454]             c <- base::c
[17:47:06.454]             inherits <- base::inherits
[17:47:06.454]             invokeRestart <- base::invokeRestart
[17:47:06.454]             length <- base::length
[17:47:06.454]             list <- base::list
[17:47:06.454]             seq.int <- base::seq.int
[17:47:06.454]             signalCondition <- base::signalCondition
[17:47:06.454]             sys.calls <- base::sys.calls
[17:47:06.454]             `[[` <- base::`[[`
[17:47:06.454]             `+` <- base::`+`
[17:47:06.454]             `<<-` <- base::`<<-`
[17:47:06.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.454]                   3L)]
[17:47:06.454]             }
[17:47:06.454]             function(cond) {
[17:47:06.454]                 is_error <- inherits(cond, "error")
[17:47:06.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.454]                   NULL)
[17:47:06.454]                 if (is_error) {
[17:47:06.454]                   sessionInformation <- function() {
[17:47:06.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.454]                       search = base::search(), system = base::Sys.info())
[17:47:06.454]                   }
[17:47:06.454]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.454]                     cond$call), session = sessionInformation(), 
[17:47:06.454]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.454]                   signalCondition(cond)
[17:47:06.454]                 }
[17:47:06.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.454]                 "immediateCondition"))) {
[17:47:06.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.454]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.454]                   if (TRUE && !signal) {
[17:47:06.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.454]                     {
[17:47:06.454]                       inherits <- base::inherits
[17:47:06.454]                       invokeRestart <- base::invokeRestart
[17:47:06.454]                       is.null <- base::is.null
[17:47:06.454]                       muffled <- FALSE
[17:47:06.454]                       if (inherits(cond, "message")) {
[17:47:06.454]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.454]                         if (muffled) 
[17:47:06.454]                           invokeRestart("muffleMessage")
[17:47:06.454]                       }
[17:47:06.454]                       else if (inherits(cond, "warning")) {
[17:47:06.454]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.454]                         if (muffled) 
[17:47:06.454]                           invokeRestart("muffleWarning")
[17:47:06.454]                       }
[17:47:06.454]                       else if (inherits(cond, "condition")) {
[17:47:06.454]                         if (!is.null(pattern)) {
[17:47:06.454]                           computeRestarts <- base::computeRestarts
[17:47:06.454]                           grepl <- base::grepl
[17:47:06.454]                           restarts <- computeRestarts(cond)
[17:47:06.454]                           for (restart in restarts) {
[17:47:06.454]                             name <- restart$name
[17:47:06.454]                             if (is.null(name)) 
[17:47:06.454]                               next
[17:47:06.454]                             if (!grepl(pattern, name)) 
[17:47:06.454]                               next
[17:47:06.454]                             invokeRestart(restart)
[17:47:06.454]                             muffled <- TRUE
[17:47:06.454]                             break
[17:47:06.454]                           }
[17:47:06.454]                         }
[17:47:06.454]                       }
[17:47:06.454]                       invisible(muffled)
[17:47:06.454]                     }
[17:47:06.454]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.454]                   }
[17:47:06.454]                 }
[17:47:06.454]                 else {
[17:47:06.454]                   if (TRUE) {
[17:47:06.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.454]                     {
[17:47:06.454]                       inherits <- base::inherits
[17:47:06.454]                       invokeRestart <- base::invokeRestart
[17:47:06.454]                       is.null <- base::is.null
[17:47:06.454]                       muffled <- FALSE
[17:47:06.454]                       if (inherits(cond, "message")) {
[17:47:06.454]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.454]                         if (muffled) 
[17:47:06.454]                           invokeRestart("muffleMessage")
[17:47:06.454]                       }
[17:47:06.454]                       else if (inherits(cond, "warning")) {
[17:47:06.454]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.454]                         if (muffled) 
[17:47:06.454]                           invokeRestart("muffleWarning")
[17:47:06.454]                       }
[17:47:06.454]                       else if (inherits(cond, "condition")) {
[17:47:06.454]                         if (!is.null(pattern)) {
[17:47:06.454]                           computeRestarts <- base::computeRestarts
[17:47:06.454]                           grepl <- base::grepl
[17:47:06.454]                           restarts <- computeRestarts(cond)
[17:47:06.454]                           for (restart in restarts) {
[17:47:06.454]                             name <- restart$name
[17:47:06.454]                             if (is.null(name)) 
[17:47:06.454]                               next
[17:47:06.454]                             if (!grepl(pattern, name)) 
[17:47:06.454]                               next
[17:47:06.454]                             invokeRestart(restart)
[17:47:06.454]                             muffled <- TRUE
[17:47:06.454]                             break
[17:47:06.454]                           }
[17:47:06.454]                         }
[17:47:06.454]                       }
[17:47:06.454]                       invisible(muffled)
[17:47:06.454]                     }
[17:47:06.454]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.454]                   }
[17:47:06.454]                 }
[17:47:06.454]             }
[17:47:06.454]         }))
[17:47:06.454]     }, error = function(ex) {
[17:47:06.454]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.454]                 ...future.rng), started = ...future.startTime, 
[17:47:06.454]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.454]             version = "1.8"), class = "FutureResult")
[17:47:06.454]     }, finally = {
[17:47:06.454]         if (!identical(...future.workdir, getwd())) 
[17:47:06.454]             setwd(...future.workdir)
[17:47:06.454]         {
[17:47:06.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.454]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.454]             }
[17:47:06.454]             base::options(...future.oldOptions)
[17:47:06.454]             if (.Platform$OS.type == "windows") {
[17:47:06.454]                 old_names <- names(...future.oldEnvVars)
[17:47:06.454]                 envs <- base::Sys.getenv()
[17:47:06.454]                 names <- names(envs)
[17:47:06.454]                 common <- intersect(names, old_names)
[17:47:06.454]                 added <- setdiff(names, old_names)
[17:47:06.454]                 removed <- setdiff(old_names, names)
[17:47:06.454]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.454]                   envs[common]]
[17:47:06.454]                 NAMES <- toupper(changed)
[17:47:06.454]                 args <- list()
[17:47:06.454]                 for (kk in seq_along(NAMES)) {
[17:47:06.454]                   name <- changed[[kk]]
[17:47:06.454]                   NAME <- NAMES[[kk]]
[17:47:06.454]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.454]                     next
[17:47:06.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.454]                 }
[17:47:06.454]                 NAMES <- toupper(added)
[17:47:06.454]                 for (kk in seq_along(NAMES)) {
[17:47:06.454]                   name <- added[[kk]]
[17:47:06.454]                   NAME <- NAMES[[kk]]
[17:47:06.454]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.454]                     next
[17:47:06.454]                   args[[name]] <- ""
[17:47:06.454]                 }
[17:47:06.454]                 NAMES <- toupper(removed)
[17:47:06.454]                 for (kk in seq_along(NAMES)) {
[17:47:06.454]                   name <- removed[[kk]]
[17:47:06.454]                   NAME <- NAMES[[kk]]
[17:47:06.454]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.454]                     next
[17:47:06.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.454]                 }
[17:47:06.454]                 if (length(args) > 0) 
[17:47:06.454]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.454]             }
[17:47:06.454]             else {
[17:47:06.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.454]             }
[17:47:06.454]             {
[17:47:06.454]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.454]                   0L) {
[17:47:06.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.454]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.454]                   base::options(opts)
[17:47:06.454]                 }
[17:47:06.454]                 {
[17:47:06.454]                   {
[17:47:06.454]                     NULL
[17:47:06.454]                     RNGkind("Mersenne-Twister")
[17:47:06.454]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.454]                       inherits = FALSE)
[17:47:06.454]                   }
[17:47:06.454]                   options(future.plan = NULL)
[17:47:06.454]                   if (is.na(NA_character_)) 
[17:47:06.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.454]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.454]                     .init = FALSE)
[17:47:06.454]                 }
[17:47:06.454]             }
[17:47:06.454]         }
[17:47:06.454]     })
[17:47:06.454]     if (TRUE) {
[17:47:06.454]         base::sink(type = "output", split = FALSE)
[17:47:06.454]         if (TRUE) {
[17:47:06.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.454]         }
[17:47:06.454]         else {
[17:47:06.454]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.454]         }
[17:47:06.454]         base::close(...future.stdout)
[17:47:06.454]         ...future.stdout <- NULL
[17:47:06.454]     }
[17:47:06.454]     ...future.result$conditions <- ...future.conditions
[17:47:06.454]     ...future.result$finished <- base::Sys.time()
[17:47:06.454]     ...future.result
[17:47:06.454] }
[17:47:06.455] assign_globals() ...
[17:47:06.455] List of 1
[17:47:06.455]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558b3284b908> 
[17:47:06.455]  - attr(*, "where")=List of 1
[17:47:06.455]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.455]  - attr(*, "resolved")= logi TRUE
[17:47:06.455]  - attr(*, "total_size")= num 10424
[17:47:06.455]  - attr(*, "already-done")= logi TRUE
[17:47:06.458] - copied ‘a’ to environment
[17:47:06.458] assign_globals() ... done
[17:47:06.458] plan(): Setting new future strategy stack:
[17:47:06.458] List of future strategies:
[17:47:06.458] 1. sequential:
[17:47:06.458]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.458]    - tweaked: FALSE
[17:47:06.458]    - call: NULL
[17:47:06.459] plan(): nbrOfWorkers() = 1
[17:47:06.459] plan(): Setting new future strategy stack:
[17:47:06.460] List of future strategies:
[17:47:06.460] 1. sequential:
[17:47:06.460]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.460]    - tweaked: FALSE
[17:47:06.460]    - call: plan(strategy)
[17:47:06.460] plan(): nbrOfWorkers() = 1
[17:47:06.460] SequentialFuture started (and completed)
[17:47:06.460] - Launch lazy future ... done
[17:47:06.460] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.461] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.461] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.461] 
[17:47:06.461] Searching for globals ... DONE
[17:47:06.462] - globals: [0] <none>
[17:47:06.462] getGlobalsAndPackages() ... DONE
[17:47:06.462] run() for ‘Future’ ...
[17:47:06.462] - state: ‘created’
[17:47:06.462] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.462] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.463]   - Field: ‘label’
[17:47:06.463]   - Field: ‘local’
[17:47:06.463]   - Field: ‘owner’
[17:47:06.463]   - Field: ‘envir’
[17:47:06.463]   - Field: ‘packages’
[17:47:06.463]   - Field: ‘gc’
[17:47:06.463]   - Field: ‘conditions’
[17:47:06.463]   - Field: ‘expr’
[17:47:06.463]   - Field: ‘uuid’
[17:47:06.463]   - Field: ‘seed’
[17:47:06.463]   - Field: ‘version’
[17:47:06.464]   - Field: ‘result’
[17:47:06.464]   - Field: ‘asynchronous’
[17:47:06.464]   - Field: ‘calls’
[17:47:06.464]   - Field: ‘globals’
[17:47:06.464]   - Field: ‘stdout’
[17:47:06.464]   - Field: ‘earlySignal’
[17:47:06.464]   - Field: ‘lazy’
[17:47:06.464]   - Field: ‘state’
[17:47:06.464] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.464] - Launch lazy future ...
[17:47:06.464] Packages needed by the future expression (n = 0): <none>
[17:47:06.465] Packages needed by future strategies (n = 0): <none>
[17:47:06.465] {
[17:47:06.465]     {
[17:47:06.465]         {
[17:47:06.465]             ...future.startTime <- base::Sys.time()
[17:47:06.465]             {
[17:47:06.465]                 {
[17:47:06.465]                   {
[17:47:06.465]                     base::local({
[17:47:06.465]                       has_future <- base::requireNamespace("future", 
[17:47:06.465]                         quietly = TRUE)
[17:47:06.465]                       if (has_future) {
[17:47:06.465]                         ns <- base::getNamespace("future")
[17:47:06.465]                         version <- ns[[".package"]][["version"]]
[17:47:06.465]                         if (is.null(version)) 
[17:47:06.465]                           version <- utils::packageVersion("future")
[17:47:06.465]                       }
[17:47:06.465]                       else {
[17:47:06.465]                         version <- NULL
[17:47:06.465]                       }
[17:47:06.465]                       if (!has_future || version < "1.8.0") {
[17:47:06.465]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.465]                           "", base::R.version$version.string), 
[17:47:06.465]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.465]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.465]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.465]                             "release", "version")], collapse = " "), 
[17:47:06.465]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.465]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.465]                           info)
[17:47:06.465]                         info <- base::paste(info, collapse = "; ")
[17:47:06.465]                         if (!has_future) {
[17:47:06.465]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.465]                             info)
[17:47:06.465]                         }
[17:47:06.465]                         else {
[17:47:06.465]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.465]                             info, version)
[17:47:06.465]                         }
[17:47:06.465]                         base::stop(msg)
[17:47:06.465]                       }
[17:47:06.465]                     })
[17:47:06.465]                   }
[17:47:06.465]                   ...future.strategy.old <- future::plan("list")
[17:47:06.465]                   options(future.plan = NULL)
[17:47:06.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.465]                 }
[17:47:06.465]                 ...future.workdir <- getwd()
[17:47:06.465]             }
[17:47:06.465]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.465]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.465]         }
[17:47:06.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.465]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.465]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.465]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.465]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.465]             base::names(...future.oldOptions))
[17:47:06.465]     }
[17:47:06.465]     if (FALSE) {
[17:47:06.465]     }
[17:47:06.465]     else {
[17:47:06.465]         if (TRUE) {
[17:47:06.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.465]                 open = "w")
[17:47:06.465]         }
[17:47:06.465]         else {
[17:47:06.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.465]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.465]         }
[17:47:06.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.465]             base::sink(type = "output", split = FALSE)
[17:47:06.465]             base::close(...future.stdout)
[17:47:06.465]         }, add = TRUE)
[17:47:06.465]     }
[17:47:06.465]     ...future.frame <- base::sys.nframe()
[17:47:06.465]     ...future.conditions <- base::list()
[17:47:06.465]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.465]     if (FALSE) {
[17:47:06.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.465]     }
[17:47:06.465]     ...future.result <- base::tryCatch({
[17:47:06.465]         base::withCallingHandlers({
[17:47:06.465]             ...future.value <- base::withVisible(base::local(1))
[17:47:06.465]             future::FutureResult(value = ...future.value$value, 
[17:47:06.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.465]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.465]                     ...future.globalenv.names))
[17:47:06.465]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.465]         }, condition = base::local({
[17:47:06.465]             c <- base::c
[17:47:06.465]             inherits <- base::inherits
[17:47:06.465]             invokeRestart <- base::invokeRestart
[17:47:06.465]             length <- base::length
[17:47:06.465]             list <- base::list
[17:47:06.465]             seq.int <- base::seq.int
[17:47:06.465]             signalCondition <- base::signalCondition
[17:47:06.465]             sys.calls <- base::sys.calls
[17:47:06.465]             `[[` <- base::`[[`
[17:47:06.465]             `+` <- base::`+`
[17:47:06.465]             `<<-` <- base::`<<-`
[17:47:06.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.465]                   3L)]
[17:47:06.465]             }
[17:47:06.465]             function(cond) {
[17:47:06.465]                 is_error <- inherits(cond, "error")
[17:47:06.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.465]                   NULL)
[17:47:06.465]                 if (is_error) {
[17:47:06.465]                   sessionInformation <- function() {
[17:47:06.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.465]                       search = base::search(), system = base::Sys.info())
[17:47:06.465]                   }
[17:47:06.465]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.465]                     cond$call), session = sessionInformation(), 
[17:47:06.465]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.465]                   signalCondition(cond)
[17:47:06.465]                 }
[17:47:06.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.465]                 "immediateCondition"))) {
[17:47:06.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.465]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.465]                   if (TRUE && !signal) {
[17:47:06.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.465]                     {
[17:47:06.465]                       inherits <- base::inherits
[17:47:06.465]                       invokeRestart <- base::invokeRestart
[17:47:06.465]                       is.null <- base::is.null
[17:47:06.465]                       muffled <- FALSE
[17:47:06.465]                       if (inherits(cond, "message")) {
[17:47:06.465]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.465]                         if (muffled) 
[17:47:06.465]                           invokeRestart("muffleMessage")
[17:47:06.465]                       }
[17:47:06.465]                       else if (inherits(cond, "warning")) {
[17:47:06.465]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.465]                         if (muffled) 
[17:47:06.465]                           invokeRestart("muffleWarning")
[17:47:06.465]                       }
[17:47:06.465]                       else if (inherits(cond, "condition")) {
[17:47:06.465]                         if (!is.null(pattern)) {
[17:47:06.465]                           computeRestarts <- base::computeRestarts
[17:47:06.465]                           grepl <- base::grepl
[17:47:06.465]                           restarts <- computeRestarts(cond)
[17:47:06.465]                           for (restart in restarts) {
[17:47:06.465]                             name <- restart$name
[17:47:06.465]                             if (is.null(name)) 
[17:47:06.465]                               next
[17:47:06.465]                             if (!grepl(pattern, name)) 
[17:47:06.465]                               next
[17:47:06.465]                             invokeRestart(restart)
[17:47:06.465]                             muffled <- TRUE
[17:47:06.465]                             break
[17:47:06.465]                           }
[17:47:06.465]                         }
[17:47:06.465]                       }
[17:47:06.465]                       invisible(muffled)
[17:47:06.465]                     }
[17:47:06.465]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.465]                   }
[17:47:06.465]                 }
[17:47:06.465]                 else {
[17:47:06.465]                   if (TRUE) {
[17:47:06.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.465]                     {
[17:47:06.465]                       inherits <- base::inherits
[17:47:06.465]                       invokeRestart <- base::invokeRestart
[17:47:06.465]                       is.null <- base::is.null
[17:47:06.465]                       muffled <- FALSE
[17:47:06.465]                       if (inherits(cond, "message")) {
[17:47:06.465]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.465]                         if (muffled) 
[17:47:06.465]                           invokeRestart("muffleMessage")
[17:47:06.465]                       }
[17:47:06.465]                       else if (inherits(cond, "warning")) {
[17:47:06.465]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.465]                         if (muffled) 
[17:47:06.465]                           invokeRestart("muffleWarning")
[17:47:06.465]                       }
[17:47:06.465]                       else if (inherits(cond, "condition")) {
[17:47:06.465]                         if (!is.null(pattern)) {
[17:47:06.465]                           computeRestarts <- base::computeRestarts
[17:47:06.465]                           grepl <- base::grepl
[17:47:06.465]                           restarts <- computeRestarts(cond)
[17:47:06.465]                           for (restart in restarts) {
[17:47:06.465]                             name <- restart$name
[17:47:06.465]                             if (is.null(name)) 
[17:47:06.465]                               next
[17:47:06.465]                             if (!grepl(pattern, name)) 
[17:47:06.465]                               next
[17:47:06.465]                             invokeRestart(restart)
[17:47:06.465]                             muffled <- TRUE
[17:47:06.465]                             break
[17:47:06.465]                           }
[17:47:06.465]                         }
[17:47:06.465]                       }
[17:47:06.465]                       invisible(muffled)
[17:47:06.465]                     }
[17:47:06.465]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.465]                   }
[17:47:06.465]                 }
[17:47:06.465]             }
[17:47:06.465]         }))
[17:47:06.465]     }, error = function(ex) {
[17:47:06.465]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.465]                 ...future.rng), started = ...future.startTime, 
[17:47:06.465]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.465]             version = "1.8"), class = "FutureResult")
[17:47:06.465]     }, finally = {
[17:47:06.465]         if (!identical(...future.workdir, getwd())) 
[17:47:06.465]             setwd(...future.workdir)
[17:47:06.465]         {
[17:47:06.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.465]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.465]             }
[17:47:06.465]             base::options(...future.oldOptions)
[17:47:06.465]             if (.Platform$OS.type == "windows") {
[17:47:06.465]                 old_names <- names(...future.oldEnvVars)
[17:47:06.465]                 envs <- base::Sys.getenv()
[17:47:06.465]                 names <- names(envs)
[17:47:06.465]                 common <- intersect(names, old_names)
[17:47:06.465]                 added <- setdiff(names, old_names)
[17:47:06.465]                 removed <- setdiff(old_names, names)
[17:47:06.465]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.465]                   envs[common]]
[17:47:06.465]                 NAMES <- toupper(changed)
[17:47:06.465]                 args <- list()
[17:47:06.465]                 for (kk in seq_along(NAMES)) {
[17:47:06.465]                   name <- changed[[kk]]
[17:47:06.465]                   NAME <- NAMES[[kk]]
[17:47:06.465]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.465]                     next
[17:47:06.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.465]                 }
[17:47:06.465]                 NAMES <- toupper(added)
[17:47:06.465]                 for (kk in seq_along(NAMES)) {
[17:47:06.465]                   name <- added[[kk]]
[17:47:06.465]                   NAME <- NAMES[[kk]]
[17:47:06.465]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.465]                     next
[17:47:06.465]                   args[[name]] <- ""
[17:47:06.465]                 }
[17:47:06.465]                 NAMES <- toupper(removed)
[17:47:06.465]                 for (kk in seq_along(NAMES)) {
[17:47:06.465]                   name <- removed[[kk]]
[17:47:06.465]                   NAME <- NAMES[[kk]]
[17:47:06.465]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.465]                     next
[17:47:06.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.465]                 }
[17:47:06.465]                 if (length(args) > 0) 
[17:47:06.465]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.465]             }
[17:47:06.465]             else {
[17:47:06.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.465]             }
[17:47:06.465]             {
[17:47:06.465]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.465]                   0L) {
[17:47:06.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.465]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.465]                   base::options(opts)
[17:47:06.465]                 }
[17:47:06.465]                 {
[17:47:06.465]                   {
[17:47:06.465]                     NULL
[17:47:06.465]                     RNGkind("Mersenne-Twister")
[17:47:06.465]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.465]                       inherits = FALSE)
[17:47:06.465]                   }
[17:47:06.465]                   options(future.plan = NULL)
[17:47:06.465]                   if (is.na(NA_character_)) 
[17:47:06.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.465]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.465]                     .init = FALSE)
[17:47:06.465]                 }
[17:47:06.465]             }
[17:47:06.465]         }
[17:47:06.465]     })
[17:47:06.465]     if (TRUE) {
[17:47:06.465]         base::sink(type = "output", split = FALSE)
[17:47:06.465]         if (TRUE) {
[17:47:06.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.465]         }
[17:47:06.465]         else {
[17:47:06.465]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.465]         }
[17:47:06.465]         base::close(...future.stdout)
[17:47:06.465]         ...future.stdout <- NULL
[17:47:06.465]     }
[17:47:06.465]     ...future.result$conditions <- ...future.conditions
[17:47:06.465]     ...future.result$finished <- base::Sys.time()
[17:47:06.465]     ...future.result
[17:47:06.465] }
[17:47:06.467] plan(): Setting new future strategy stack:
[17:47:06.467] List of future strategies:
[17:47:06.467] 1. sequential:
[17:47:06.467]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.467]    - tweaked: FALSE
[17:47:06.467]    - call: NULL
[17:47:06.467] plan(): nbrOfWorkers() = 1
[17:47:06.468] plan(): Setting new future strategy stack:
[17:47:06.468] List of future strategies:
[17:47:06.468] 1. sequential:
[17:47:06.468]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.468]    - tweaked: FALSE
[17:47:06.468]    - call: plan(strategy)
[17:47:06.468] plan(): nbrOfWorkers() = 1
[17:47:06.468] SequentialFuture started (and completed)
[17:47:06.469] - Launch lazy future ... done
[17:47:06.469] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.469] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.469] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.470] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:06.470] Searching for globals ... DONE
[17:47:06.470] Resolving globals: TRUE
[17:47:06.470] Resolving any globals that are futures ...
[17:47:06.470] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:06.470] Resolving any globals that are futures ... DONE
[17:47:06.471] Resolving futures part of globals (recursively) ...
[17:47:06.471] resolve() on list ...
[17:47:06.471]  recursive: 99
[17:47:06.471]  length: 1
[17:47:06.471]  elements: ‘a’
[17:47:06.471] resolved() for ‘SequentialFuture’ ...
[17:47:06.471] - state: ‘finished’
[17:47:06.471] - run: TRUE
[17:47:06.472] - result: ‘FutureResult’
[17:47:06.472] resolved() for ‘SequentialFuture’ ... done
[17:47:06.472] Future #1
[17:47:06.472] resolved() for ‘SequentialFuture’ ...
[17:47:06.472] - state: ‘finished’
[17:47:06.472] - run: TRUE
[17:47:06.472] - result: ‘FutureResult’
[17:47:06.472] resolved() for ‘SequentialFuture’ ... done
[17:47:06.472] A SequentialFuture was resolved
[17:47:06.474]  length: 0 (resolved future 1)
[17:47:06.474] resolve() on list ... DONE
[17:47:06.474] - globals: [1] ‘a’
[17:47:06.474] Resolving futures part of globals (recursively) ... DONE
[17:47:06.475] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[17:47:06.475] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[17:47:06.475] - globals: [1] ‘a’
[17:47:06.475] - packages: [1] ‘future’
[17:47:06.476] getGlobalsAndPackages() ... DONE
[17:47:06.476] run() for ‘Future’ ...
[17:47:06.476] - state: ‘created’
[17:47:06.476] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.476] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.476]   - Field: ‘label’
[17:47:06.477]   - Field: ‘local’
[17:47:06.477]   - Field: ‘owner’
[17:47:06.477]   - Field: ‘envir’
[17:47:06.477]   - Field: ‘packages’
[17:47:06.477]   - Field: ‘gc’
[17:47:06.477]   - Field: ‘conditions’
[17:47:06.477]   - Field: ‘expr’
[17:47:06.477]   - Field: ‘uuid’
[17:47:06.477]   - Field: ‘seed’
[17:47:06.477]   - Field: ‘version’
[17:47:06.477]   - Field: ‘result’
[17:47:06.478]   - Field: ‘asynchronous’
[17:47:06.478]   - Field: ‘calls’
[17:47:06.478]   - Field: ‘globals’
[17:47:06.478]   - Field: ‘stdout’
[17:47:06.478]   - Field: ‘earlySignal’
[17:47:06.478]   - Field: ‘lazy’
[17:47:06.478]   - Field: ‘state’
[17:47:06.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.478] - Launch lazy future ...
[17:47:06.478] Packages needed by the future expression (n = 1): ‘future’
[17:47:06.479] Packages needed by future strategies (n = 0): <none>
[17:47:06.479] {
[17:47:06.479]     {
[17:47:06.479]         {
[17:47:06.479]             ...future.startTime <- base::Sys.time()
[17:47:06.479]             {
[17:47:06.479]                 {
[17:47:06.479]                   {
[17:47:06.479]                     {
[17:47:06.479]                       base::local({
[17:47:06.479]                         has_future <- base::requireNamespace("future", 
[17:47:06.479]                           quietly = TRUE)
[17:47:06.479]                         if (has_future) {
[17:47:06.479]                           ns <- base::getNamespace("future")
[17:47:06.479]                           version <- ns[[".package"]][["version"]]
[17:47:06.479]                           if (is.null(version)) 
[17:47:06.479]                             version <- utils::packageVersion("future")
[17:47:06.479]                         }
[17:47:06.479]                         else {
[17:47:06.479]                           version <- NULL
[17:47:06.479]                         }
[17:47:06.479]                         if (!has_future || version < "1.8.0") {
[17:47:06.479]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.479]                             "", base::R.version$version.string), 
[17:47:06.479]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.479]                               "release", "version")], collapse = " "), 
[17:47:06.479]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.479]                             info)
[17:47:06.479]                           info <- base::paste(info, collapse = "; ")
[17:47:06.479]                           if (!has_future) {
[17:47:06.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.479]                               info)
[17:47:06.479]                           }
[17:47:06.479]                           else {
[17:47:06.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.479]                               info, version)
[17:47:06.479]                           }
[17:47:06.479]                           base::stop(msg)
[17:47:06.479]                         }
[17:47:06.479]                       })
[17:47:06.479]                     }
[17:47:06.479]                     base::local({
[17:47:06.479]                       for (pkg in "future") {
[17:47:06.479]                         base::loadNamespace(pkg)
[17:47:06.479]                         base::library(pkg, character.only = TRUE)
[17:47:06.479]                       }
[17:47:06.479]                     })
[17:47:06.479]                   }
[17:47:06.479]                   ...future.strategy.old <- future::plan("list")
[17:47:06.479]                   options(future.plan = NULL)
[17:47:06.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.479]                 }
[17:47:06.479]                 ...future.workdir <- getwd()
[17:47:06.479]             }
[17:47:06.479]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.479]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.479]         }
[17:47:06.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.479]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.479]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.479]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.479]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.479]             base::names(...future.oldOptions))
[17:47:06.479]     }
[17:47:06.479]     if (FALSE) {
[17:47:06.479]     }
[17:47:06.479]     else {
[17:47:06.479]         if (TRUE) {
[17:47:06.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.479]                 open = "w")
[17:47:06.479]         }
[17:47:06.479]         else {
[17:47:06.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.479]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.479]         }
[17:47:06.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.479]             base::sink(type = "output", split = FALSE)
[17:47:06.479]             base::close(...future.stdout)
[17:47:06.479]         }, add = TRUE)
[17:47:06.479]     }
[17:47:06.479]     ...future.frame <- base::sys.nframe()
[17:47:06.479]     ...future.conditions <- base::list()
[17:47:06.479]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.479]     if (FALSE) {
[17:47:06.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.479]     }
[17:47:06.479]     ...future.result <- base::tryCatch({
[17:47:06.479]         base::withCallingHandlers({
[17:47:06.479]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:47:06.479]                 1))
[17:47:06.479]             future::FutureResult(value = ...future.value$value, 
[17:47:06.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.479]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.479]                     ...future.globalenv.names))
[17:47:06.479]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.479]         }, condition = base::local({
[17:47:06.479]             c <- base::c
[17:47:06.479]             inherits <- base::inherits
[17:47:06.479]             invokeRestart <- base::invokeRestart
[17:47:06.479]             length <- base::length
[17:47:06.479]             list <- base::list
[17:47:06.479]             seq.int <- base::seq.int
[17:47:06.479]             signalCondition <- base::signalCondition
[17:47:06.479]             sys.calls <- base::sys.calls
[17:47:06.479]             `[[` <- base::`[[`
[17:47:06.479]             `+` <- base::`+`
[17:47:06.479]             `<<-` <- base::`<<-`
[17:47:06.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.479]                   3L)]
[17:47:06.479]             }
[17:47:06.479]             function(cond) {
[17:47:06.479]                 is_error <- inherits(cond, "error")
[17:47:06.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.479]                   NULL)
[17:47:06.479]                 if (is_error) {
[17:47:06.479]                   sessionInformation <- function() {
[17:47:06.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.479]                       search = base::search(), system = base::Sys.info())
[17:47:06.479]                   }
[17:47:06.479]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.479]                     cond$call), session = sessionInformation(), 
[17:47:06.479]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.479]                   signalCondition(cond)
[17:47:06.479]                 }
[17:47:06.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.479]                 "immediateCondition"))) {
[17:47:06.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.479]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.479]                   if (TRUE && !signal) {
[17:47:06.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.479]                     {
[17:47:06.479]                       inherits <- base::inherits
[17:47:06.479]                       invokeRestart <- base::invokeRestart
[17:47:06.479]                       is.null <- base::is.null
[17:47:06.479]                       muffled <- FALSE
[17:47:06.479]                       if (inherits(cond, "message")) {
[17:47:06.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.479]                         if (muffled) 
[17:47:06.479]                           invokeRestart("muffleMessage")
[17:47:06.479]                       }
[17:47:06.479]                       else if (inherits(cond, "warning")) {
[17:47:06.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.479]                         if (muffled) 
[17:47:06.479]                           invokeRestart("muffleWarning")
[17:47:06.479]                       }
[17:47:06.479]                       else if (inherits(cond, "condition")) {
[17:47:06.479]                         if (!is.null(pattern)) {
[17:47:06.479]                           computeRestarts <- base::computeRestarts
[17:47:06.479]                           grepl <- base::grepl
[17:47:06.479]                           restarts <- computeRestarts(cond)
[17:47:06.479]                           for (restart in restarts) {
[17:47:06.479]                             name <- restart$name
[17:47:06.479]                             if (is.null(name)) 
[17:47:06.479]                               next
[17:47:06.479]                             if (!grepl(pattern, name)) 
[17:47:06.479]                               next
[17:47:06.479]                             invokeRestart(restart)
[17:47:06.479]                             muffled <- TRUE
[17:47:06.479]                             break
[17:47:06.479]                           }
[17:47:06.479]                         }
[17:47:06.479]                       }
[17:47:06.479]                       invisible(muffled)
[17:47:06.479]                     }
[17:47:06.479]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.479]                   }
[17:47:06.479]                 }
[17:47:06.479]                 else {
[17:47:06.479]                   if (TRUE) {
[17:47:06.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.479]                     {
[17:47:06.479]                       inherits <- base::inherits
[17:47:06.479]                       invokeRestart <- base::invokeRestart
[17:47:06.479]                       is.null <- base::is.null
[17:47:06.479]                       muffled <- FALSE
[17:47:06.479]                       if (inherits(cond, "message")) {
[17:47:06.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.479]                         if (muffled) 
[17:47:06.479]                           invokeRestart("muffleMessage")
[17:47:06.479]                       }
[17:47:06.479]                       else if (inherits(cond, "warning")) {
[17:47:06.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.479]                         if (muffled) 
[17:47:06.479]                           invokeRestart("muffleWarning")
[17:47:06.479]                       }
[17:47:06.479]                       else if (inherits(cond, "condition")) {
[17:47:06.479]                         if (!is.null(pattern)) {
[17:47:06.479]                           computeRestarts <- base::computeRestarts
[17:47:06.479]                           grepl <- base::grepl
[17:47:06.479]                           restarts <- computeRestarts(cond)
[17:47:06.479]                           for (restart in restarts) {
[17:47:06.479]                             name <- restart$name
[17:47:06.479]                             if (is.null(name)) 
[17:47:06.479]                               next
[17:47:06.479]                             if (!grepl(pattern, name)) 
[17:47:06.479]                               next
[17:47:06.479]                             invokeRestart(restart)
[17:47:06.479]                             muffled <- TRUE
[17:47:06.479]                             break
[17:47:06.479]                           }
[17:47:06.479]                         }
[17:47:06.479]                       }
[17:47:06.479]                       invisible(muffled)
[17:47:06.479]                     }
[17:47:06.479]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.479]                   }
[17:47:06.479]                 }
[17:47:06.479]             }
[17:47:06.479]         }))
[17:47:06.479]     }, error = function(ex) {
[17:47:06.479]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.479]                 ...future.rng), started = ...future.startTime, 
[17:47:06.479]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.479]             version = "1.8"), class = "FutureResult")
[17:47:06.479]     }, finally = {
[17:47:06.479]         if (!identical(...future.workdir, getwd())) 
[17:47:06.479]             setwd(...future.workdir)
[17:47:06.479]         {
[17:47:06.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.479]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.479]             }
[17:47:06.479]             base::options(...future.oldOptions)
[17:47:06.479]             if (.Platform$OS.type == "windows") {
[17:47:06.479]                 old_names <- names(...future.oldEnvVars)
[17:47:06.479]                 envs <- base::Sys.getenv()
[17:47:06.479]                 names <- names(envs)
[17:47:06.479]                 common <- intersect(names, old_names)
[17:47:06.479]                 added <- setdiff(names, old_names)
[17:47:06.479]                 removed <- setdiff(old_names, names)
[17:47:06.479]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.479]                   envs[common]]
[17:47:06.479]                 NAMES <- toupper(changed)
[17:47:06.479]                 args <- list()
[17:47:06.479]                 for (kk in seq_along(NAMES)) {
[17:47:06.479]                   name <- changed[[kk]]
[17:47:06.479]                   NAME <- NAMES[[kk]]
[17:47:06.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.479]                     next
[17:47:06.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.479]                 }
[17:47:06.479]                 NAMES <- toupper(added)
[17:47:06.479]                 for (kk in seq_along(NAMES)) {
[17:47:06.479]                   name <- added[[kk]]
[17:47:06.479]                   NAME <- NAMES[[kk]]
[17:47:06.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.479]                     next
[17:47:06.479]                   args[[name]] <- ""
[17:47:06.479]                 }
[17:47:06.479]                 NAMES <- toupper(removed)
[17:47:06.479]                 for (kk in seq_along(NAMES)) {
[17:47:06.479]                   name <- removed[[kk]]
[17:47:06.479]                   NAME <- NAMES[[kk]]
[17:47:06.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.479]                     next
[17:47:06.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.479]                 }
[17:47:06.479]                 if (length(args) > 0) 
[17:47:06.479]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.479]             }
[17:47:06.479]             else {
[17:47:06.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.479]             }
[17:47:06.479]             {
[17:47:06.479]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.479]                   0L) {
[17:47:06.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.479]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.479]                   base::options(opts)
[17:47:06.479]                 }
[17:47:06.479]                 {
[17:47:06.479]                   {
[17:47:06.479]                     NULL
[17:47:06.479]                     RNGkind("Mersenne-Twister")
[17:47:06.479]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.479]                       inherits = FALSE)
[17:47:06.479]                   }
[17:47:06.479]                   options(future.plan = NULL)
[17:47:06.479]                   if (is.na(NA_character_)) 
[17:47:06.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.479]                     .init = FALSE)
[17:47:06.479]                 }
[17:47:06.479]             }
[17:47:06.479]         }
[17:47:06.479]     })
[17:47:06.479]     if (TRUE) {
[17:47:06.479]         base::sink(type = "output", split = FALSE)
[17:47:06.479]         if (TRUE) {
[17:47:06.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.479]         }
[17:47:06.479]         else {
[17:47:06.479]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.479]         }
[17:47:06.479]         base::close(...future.stdout)
[17:47:06.479]         ...future.stdout <- NULL
[17:47:06.479]     }
[17:47:06.479]     ...future.result$conditions <- ...future.conditions
[17:47:06.479]     ...future.result$finished <- base::Sys.time()
[17:47:06.479]     ...future.result
[17:47:06.479] }
[17:47:06.481] assign_globals() ...
[17:47:06.481] List of 1
[17:47:06.481]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558b325d8880> 
[17:47:06.481]  - attr(*, "where")=List of 1
[17:47:06.481]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.481]  - attr(*, "resolved")= logi TRUE
[17:47:06.481]  - attr(*, "total_size")= num 10424
[17:47:06.481]  - attr(*, "already-done")= logi TRUE
[17:47:06.483] - copied ‘a’ to environment
[17:47:06.483] assign_globals() ... done
[17:47:06.483] plan(): Setting new future strategy stack:
[17:47:06.483] List of future strategies:
[17:47:06.483] 1. sequential:
[17:47:06.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.483]    - tweaked: FALSE
[17:47:06.483]    - call: NULL
[17:47:06.484] plan(): nbrOfWorkers() = 1
[17:47:06.485] plan(): Setting new future strategy stack:
[17:47:06.485] List of future strategies:
[17:47:06.485] 1. sequential:
[17:47:06.485]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.485]    - tweaked: FALSE
[17:47:06.485]    - call: plan(strategy)
[17:47:06.485] plan(): nbrOfWorkers() = 1
[17:47:06.485] SequentialFuture started (and completed)
[17:47:06.485] - Launch lazy future ... done
[17:47:06.486] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.486] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.486] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.487] 
[17:47:06.487] Searching for globals ... DONE
[17:47:06.487] - globals: [0] <none>
[17:47:06.487] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.487] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.487] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.488] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:06.488] Searching for globals ... DONE
[17:47:06.488] Resolving globals: TRUE
[17:47:06.488] Resolving any globals that are futures ...
[17:47:06.489] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:06.489] Resolving any globals that are futures ... DONE
[17:47:06.489] Resolving futures part of globals (recursively) ...
[17:47:06.489] resolve() on list ...
[17:47:06.489]  recursive: 99
[17:47:06.489]  length: 1
[17:47:06.489]  elements: ‘a’
[17:47:06.489] run() for ‘Future’ ...
[17:47:06.490] - state: ‘created’
[17:47:06.490] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.490] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.490]   - Field: ‘label’
[17:47:06.490]   - Field: ‘local’
[17:47:06.490]   - Field: ‘owner’
[17:47:06.490]   - Field: ‘envir’
[17:47:06.490]   - Field: ‘packages’
[17:47:06.491]   - Field: ‘gc’
[17:47:06.491]   - Field: ‘conditions’
[17:47:06.491]   - Field: ‘expr’
[17:47:06.491]   - Field: ‘uuid’
[17:47:06.491]   - Field: ‘seed’
[17:47:06.491]   - Field: ‘version’
[17:47:06.491]   - Field: ‘result’
[17:47:06.491]   - Field: ‘asynchronous’
[17:47:06.491]   - Field: ‘calls’
[17:47:06.491]   - Field: ‘globals’
[17:47:06.491]   - Field: ‘stdout’
[17:47:06.492]   - Field: ‘earlySignal’
[17:47:06.492]   - Field: ‘lazy’
[17:47:06.492]   - Field: ‘state’
[17:47:06.492] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.492] - Launch lazy future ...
[17:47:06.492] Packages needed by the future expression (n = 0): <none>
[17:47:06.492] Packages needed by future strategies (n = 0): <none>
[17:47:06.493] {
[17:47:06.493]     {
[17:47:06.493]         {
[17:47:06.493]             ...future.startTime <- base::Sys.time()
[17:47:06.493]             {
[17:47:06.493]                 {
[17:47:06.493]                   {
[17:47:06.493]                     base::local({
[17:47:06.493]                       has_future <- base::requireNamespace("future", 
[17:47:06.493]                         quietly = TRUE)
[17:47:06.493]                       if (has_future) {
[17:47:06.493]                         ns <- base::getNamespace("future")
[17:47:06.493]                         version <- ns[[".package"]][["version"]]
[17:47:06.493]                         if (is.null(version)) 
[17:47:06.493]                           version <- utils::packageVersion("future")
[17:47:06.493]                       }
[17:47:06.493]                       else {
[17:47:06.493]                         version <- NULL
[17:47:06.493]                       }
[17:47:06.493]                       if (!has_future || version < "1.8.0") {
[17:47:06.493]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.493]                           "", base::R.version$version.string), 
[17:47:06.493]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.493]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.493]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.493]                             "release", "version")], collapse = " "), 
[17:47:06.493]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.493]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.493]                           info)
[17:47:06.493]                         info <- base::paste(info, collapse = "; ")
[17:47:06.493]                         if (!has_future) {
[17:47:06.493]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.493]                             info)
[17:47:06.493]                         }
[17:47:06.493]                         else {
[17:47:06.493]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.493]                             info, version)
[17:47:06.493]                         }
[17:47:06.493]                         base::stop(msg)
[17:47:06.493]                       }
[17:47:06.493]                     })
[17:47:06.493]                   }
[17:47:06.493]                   ...future.strategy.old <- future::plan("list")
[17:47:06.493]                   options(future.plan = NULL)
[17:47:06.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.493]                 }
[17:47:06.493]                 ...future.workdir <- getwd()
[17:47:06.493]             }
[17:47:06.493]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.493]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.493]         }
[17:47:06.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.493]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.493]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.493]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.493]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.493]             base::names(...future.oldOptions))
[17:47:06.493]     }
[17:47:06.493]     if (FALSE) {
[17:47:06.493]     }
[17:47:06.493]     else {
[17:47:06.493]         if (TRUE) {
[17:47:06.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.493]                 open = "w")
[17:47:06.493]         }
[17:47:06.493]         else {
[17:47:06.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.493]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.493]         }
[17:47:06.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.493]             base::sink(type = "output", split = FALSE)
[17:47:06.493]             base::close(...future.stdout)
[17:47:06.493]         }, add = TRUE)
[17:47:06.493]     }
[17:47:06.493]     ...future.frame <- base::sys.nframe()
[17:47:06.493]     ...future.conditions <- base::list()
[17:47:06.493]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.493]     if (FALSE) {
[17:47:06.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.493]     }
[17:47:06.493]     ...future.result <- base::tryCatch({
[17:47:06.493]         base::withCallingHandlers({
[17:47:06.493]             ...future.value <- base::withVisible(base::local(1))
[17:47:06.493]             future::FutureResult(value = ...future.value$value, 
[17:47:06.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.493]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.493]                     ...future.globalenv.names))
[17:47:06.493]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.493]         }, condition = base::local({
[17:47:06.493]             c <- base::c
[17:47:06.493]             inherits <- base::inherits
[17:47:06.493]             invokeRestart <- base::invokeRestart
[17:47:06.493]             length <- base::length
[17:47:06.493]             list <- base::list
[17:47:06.493]             seq.int <- base::seq.int
[17:47:06.493]             signalCondition <- base::signalCondition
[17:47:06.493]             sys.calls <- base::sys.calls
[17:47:06.493]             `[[` <- base::`[[`
[17:47:06.493]             `+` <- base::`+`
[17:47:06.493]             `<<-` <- base::`<<-`
[17:47:06.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.493]                   3L)]
[17:47:06.493]             }
[17:47:06.493]             function(cond) {
[17:47:06.493]                 is_error <- inherits(cond, "error")
[17:47:06.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.493]                   NULL)
[17:47:06.493]                 if (is_error) {
[17:47:06.493]                   sessionInformation <- function() {
[17:47:06.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.493]                       search = base::search(), system = base::Sys.info())
[17:47:06.493]                   }
[17:47:06.493]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.493]                     cond$call), session = sessionInformation(), 
[17:47:06.493]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.493]                   signalCondition(cond)
[17:47:06.493]                 }
[17:47:06.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.493]                 "immediateCondition"))) {
[17:47:06.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.493]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.493]                   if (TRUE && !signal) {
[17:47:06.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.493]                     {
[17:47:06.493]                       inherits <- base::inherits
[17:47:06.493]                       invokeRestart <- base::invokeRestart
[17:47:06.493]                       is.null <- base::is.null
[17:47:06.493]                       muffled <- FALSE
[17:47:06.493]                       if (inherits(cond, "message")) {
[17:47:06.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.493]                         if (muffled) 
[17:47:06.493]                           invokeRestart("muffleMessage")
[17:47:06.493]                       }
[17:47:06.493]                       else if (inherits(cond, "warning")) {
[17:47:06.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.493]                         if (muffled) 
[17:47:06.493]                           invokeRestart("muffleWarning")
[17:47:06.493]                       }
[17:47:06.493]                       else if (inherits(cond, "condition")) {
[17:47:06.493]                         if (!is.null(pattern)) {
[17:47:06.493]                           computeRestarts <- base::computeRestarts
[17:47:06.493]                           grepl <- base::grepl
[17:47:06.493]                           restarts <- computeRestarts(cond)
[17:47:06.493]                           for (restart in restarts) {
[17:47:06.493]                             name <- restart$name
[17:47:06.493]                             if (is.null(name)) 
[17:47:06.493]                               next
[17:47:06.493]                             if (!grepl(pattern, name)) 
[17:47:06.493]                               next
[17:47:06.493]                             invokeRestart(restart)
[17:47:06.493]                             muffled <- TRUE
[17:47:06.493]                             break
[17:47:06.493]                           }
[17:47:06.493]                         }
[17:47:06.493]                       }
[17:47:06.493]                       invisible(muffled)
[17:47:06.493]                     }
[17:47:06.493]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.493]                   }
[17:47:06.493]                 }
[17:47:06.493]                 else {
[17:47:06.493]                   if (TRUE) {
[17:47:06.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.493]                     {
[17:47:06.493]                       inherits <- base::inherits
[17:47:06.493]                       invokeRestart <- base::invokeRestart
[17:47:06.493]                       is.null <- base::is.null
[17:47:06.493]                       muffled <- FALSE
[17:47:06.493]                       if (inherits(cond, "message")) {
[17:47:06.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.493]                         if (muffled) 
[17:47:06.493]                           invokeRestart("muffleMessage")
[17:47:06.493]                       }
[17:47:06.493]                       else if (inherits(cond, "warning")) {
[17:47:06.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.493]                         if (muffled) 
[17:47:06.493]                           invokeRestart("muffleWarning")
[17:47:06.493]                       }
[17:47:06.493]                       else if (inherits(cond, "condition")) {
[17:47:06.493]                         if (!is.null(pattern)) {
[17:47:06.493]                           computeRestarts <- base::computeRestarts
[17:47:06.493]                           grepl <- base::grepl
[17:47:06.493]                           restarts <- computeRestarts(cond)
[17:47:06.493]                           for (restart in restarts) {
[17:47:06.493]                             name <- restart$name
[17:47:06.493]                             if (is.null(name)) 
[17:47:06.493]                               next
[17:47:06.493]                             if (!grepl(pattern, name)) 
[17:47:06.493]                               next
[17:47:06.493]                             invokeRestart(restart)
[17:47:06.493]                             muffled <- TRUE
[17:47:06.493]                             break
[17:47:06.493]                           }
[17:47:06.493]                         }
[17:47:06.493]                       }
[17:47:06.493]                       invisible(muffled)
[17:47:06.493]                     }
[17:47:06.493]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.493]                   }
[17:47:06.493]                 }
[17:47:06.493]             }
[17:47:06.493]         }))
[17:47:06.493]     }, error = function(ex) {
[17:47:06.493]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.493]                 ...future.rng), started = ...future.startTime, 
[17:47:06.493]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.493]             version = "1.8"), class = "FutureResult")
[17:47:06.493]     }, finally = {
[17:47:06.493]         if (!identical(...future.workdir, getwd())) 
[17:47:06.493]             setwd(...future.workdir)
[17:47:06.493]         {
[17:47:06.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.493]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.493]             }
[17:47:06.493]             base::options(...future.oldOptions)
[17:47:06.493]             if (.Platform$OS.type == "windows") {
[17:47:06.493]                 old_names <- names(...future.oldEnvVars)
[17:47:06.493]                 envs <- base::Sys.getenv()
[17:47:06.493]                 names <- names(envs)
[17:47:06.493]                 common <- intersect(names, old_names)
[17:47:06.493]                 added <- setdiff(names, old_names)
[17:47:06.493]                 removed <- setdiff(old_names, names)
[17:47:06.493]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.493]                   envs[common]]
[17:47:06.493]                 NAMES <- toupper(changed)
[17:47:06.493]                 args <- list()
[17:47:06.493]                 for (kk in seq_along(NAMES)) {
[17:47:06.493]                   name <- changed[[kk]]
[17:47:06.493]                   NAME <- NAMES[[kk]]
[17:47:06.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.493]                     next
[17:47:06.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.493]                 }
[17:47:06.493]                 NAMES <- toupper(added)
[17:47:06.493]                 for (kk in seq_along(NAMES)) {
[17:47:06.493]                   name <- added[[kk]]
[17:47:06.493]                   NAME <- NAMES[[kk]]
[17:47:06.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.493]                     next
[17:47:06.493]                   args[[name]] <- ""
[17:47:06.493]                 }
[17:47:06.493]                 NAMES <- toupper(removed)
[17:47:06.493]                 for (kk in seq_along(NAMES)) {
[17:47:06.493]                   name <- removed[[kk]]
[17:47:06.493]                   NAME <- NAMES[[kk]]
[17:47:06.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.493]                     next
[17:47:06.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.493]                 }
[17:47:06.493]                 if (length(args) > 0) 
[17:47:06.493]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.493]             }
[17:47:06.493]             else {
[17:47:06.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.493]             }
[17:47:06.493]             {
[17:47:06.493]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.493]                   0L) {
[17:47:06.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.493]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.493]                   base::options(opts)
[17:47:06.493]                 }
[17:47:06.493]                 {
[17:47:06.493]                   {
[17:47:06.493]                     NULL
[17:47:06.493]                     RNGkind("Mersenne-Twister")
[17:47:06.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.493]                       inherits = FALSE)
[17:47:06.493]                   }
[17:47:06.493]                   options(future.plan = NULL)
[17:47:06.493]                   if (is.na(NA_character_)) 
[17:47:06.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.493]                     .init = FALSE)
[17:47:06.493]                 }
[17:47:06.493]             }
[17:47:06.493]         }
[17:47:06.493]     })
[17:47:06.493]     if (TRUE) {
[17:47:06.493]         base::sink(type = "output", split = FALSE)
[17:47:06.493]         if (TRUE) {
[17:47:06.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.493]         }
[17:47:06.493]         else {
[17:47:06.493]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.493]         }
[17:47:06.493]         base::close(...future.stdout)
[17:47:06.493]         ...future.stdout <- NULL
[17:47:06.493]     }
[17:47:06.493]     ...future.result$conditions <- ...future.conditions
[17:47:06.493]     ...future.result$finished <- base::Sys.time()
[17:47:06.493]     ...future.result
[17:47:06.493] }
[17:47:06.494] plan(): Setting new future strategy stack:
[17:47:06.494] List of future strategies:
[17:47:06.494] 1. sequential:
[17:47:06.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.494]    - tweaked: FALSE
[17:47:06.494]    - call: NULL
[17:47:06.495] plan(): nbrOfWorkers() = 1
[17:47:06.495] plan(): Setting new future strategy stack:
[17:47:06.495] List of future strategies:
[17:47:06.495] 1. sequential:
[17:47:06.495]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.495]    - tweaked: FALSE
[17:47:06.495]    - call: plan(strategy)
[17:47:06.496] plan(): nbrOfWorkers() = 1
[17:47:06.496] SequentialFuture started (and completed)
[17:47:06.496] - Launch lazy future ... done
[17:47:06.496] run() for ‘SequentialFuture’ ... done
[17:47:06.496] resolved() for ‘SequentialFuture’ ...
[17:47:06.496] - state: ‘finished’
[17:47:06.497] - run: TRUE
[17:47:06.497] - result: ‘FutureResult’
[17:47:06.497] resolved() for ‘SequentialFuture’ ... done
[17:47:06.497] Future #1
[17:47:06.497] resolved() for ‘SequentialFuture’ ...
[17:47:06.497] - state: ‘finished’
[17:47:06.497] - run: TRUE
[17:47:06.497] - result: ‘FutureResult’
[17:47:06.497] resolved() for ‘SequentialFuture’ ... done
[17:47:06.497] A SequentialFuture was resolved
[17:47:06.497]  length: 0 (resolved future 1)
[17:47:06.498] resolve() on list ... DONE
[17:47:06.498] - globals: [1] ‘a’
[17:47:06.498] Resolving futures part of globals (recursively) ... DONE
[17:47:06.498] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[17:47:06.499] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[17:47:06.499] - globals: [1] ‘a’
[17:47:06.499] - packages: [1] ‘future’
[17:47:06.499] getGlobalsAndPackages() ... DONE
[17:47:06.499] run() for ‘Future’ ...
[17:47:06.499] - state: ‘created’
[17:47:06.500] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.500] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.500]   - Field: ‘label’
[17:47:06.500]   - Field: ‘local’
[17:47:06.502]   - Field: ‘owner’
[17:47:06.502]   - Field: ‘envir’
[17:47:06.502]   - Field: ‘packages’
[17:47:06.502]   - Field: ‘gc’
[17:47:06.502]   - Field: ‘conditions’
[17:47:06.502]   - Field: ‘expr’
[17:47:06.502]   - Field: ‘uuid’
[17:47:06.502]   - Field: ‘seed’
[17:47:06.502]   - Field: ‘version’
[17:47:06.502]   - Field: ‘result’
[17:47:06.502]   - Field: ‘asynchronous’
[17:47:06.502]   - Field: ‘calls’
[17:47:06.503]   - Field: ‘globals’
[17:47:06.503]   - Field: ‘stdout’
[17:47:06.503]   - Field: ‘earlySignal’
[17:47:06.503]   - Field: ‘lazy’
[17:47:06.503]   - Field: ‘state’
[17:47:06.503] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.503] - Launch lazy future ...
[17:47:06.503] Packages needed by the future expression (n = 1): ‘future’
[17:47:06.503] Packages needed by future strategies (n = 0): <none>
[17:47:06.504] {
[17:47:06.504]     {
[17:47:06.504]         {
[17:47:06.504]             ...future.startTime <- base::Sys.time()
[17:47:06.504]             {
[17:47:06.504]                 {
[17:47:06.504]                   {
[17:47:06.504]                     {
[17:47:06.504]                       base::local({
[17:47:06.504]                         has_future <- base::requireNamespace("future", 
[17:47:06.504]                           quietly = TRUE)
[17:47:06.504]                         if (has_future) {
[17:47:06.504]                           ns <- base::getNamespace("future")
[17:47:06.504]                           version <- ns[[".package"]][["version"]]
[17:47:06.504]                           if (is.null(version)) 
[17:47:06.504]                             version <- utils::packageVersion("future")
[17:47:06.504]                         }
[17:47:06.504]                         else {
[17:47:06.504]                           version <- NULL
[17:47:06.504]                         }
[17:47:06.504]                         if (!has_future || version < "1.8.0") {
[17:47:06.504]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.504]                             "", base::R.version$version.string), 
[17:47:06.504]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.504]                               "release", "version")], collapse = " "), 
[17:47:06.504]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.504]                             info)
[17:47:06.504]                           info <- base::paste(info, collapse = "; ")
[17:47:06.504]                           if (!has_future) {
[17:47:06.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.504]                               info)
[17:47:06.504]                           }
[17:47:06.504]                           else {
[17:47:06.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.504]                               info, version)
[17:47:06.504]                           }
[17:47:06.504]                           base::stop(msg)
[17:47:06.504]                         }
[17:47:06.504]                       })
[17:47:06.504]                     }
[17:47:06.504]                     base::local({
[17:47:06.504]                       for (pkg in "future") {
[17:47:06.504]                         base::loadNamespace(pkg)
[17:47:06.504]                         base::library(pkg, character.only = TRUE)
[17:47:06.504]                       }
[17:47:06.504]                     })
[17:47:06.504]                   }
[17:47:06.504]                   ...future.strategy.old <- future::plan("list")
[17:47:06.504]                   options(future.plan = NULL)
[17:47:06.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.504]                 }
[17:47:06.504]                 ...future.workdir <- getwd()
[17:47:06.504]             }
[17:47:06.504]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.504]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.504]         }
[17:47:06.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.504]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.504]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.504]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.504]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.504]             base::names(...future.oldOptions))
[17:47:06.504]     }
[17:47:06.504]     if (FALSE) {
[17:47:06.504]     }
[17:47:06.504]     else {
[17:47:06.504]         if (TRUE) {
[17:47:06.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.504]                 open = "w")
[17:47:06.504]         }
[17:47:06.504]         else {
[17:47:06.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.504]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.504]         }
[17:47:06.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.504]             base::sink(type = "output", split = FALSE)
[17:47:06.504]             base::close(...future.stdout)
[17:47:06.504]         }, add = TRUE)
[17:47:06.504]     }
[17:47:06.504]     ...future.frame <- base::sys.nframe()
[17:47:06.504]     ...future.conditions <- base::list()
[17:47:06.504]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.504]     if (FALSE) {
[17:47:06.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.504]     }
[17:47:06.504]     ...future.result <- base::tryCatch({
[17:47:06.504]         base::withCallingHandlers({
[17:47:06.504]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:47:06.504]                 1))
[17:47:06.504]             future::FutureResult(value = ...future.value$value, 
[17:47:06.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.504]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.504]                     ...future.globalenv.names))
[17:47:06.504]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.504]         }, condition = base::local({
[17:47:06.504]             c <- base::c
[17:47:06.504]             inherits <- base::inherits
[17:47:06.504]             invokeRestart <- base::invokeRestart
[17:47:06.504]             length <- base::length
[17:47:06.504]             list <- base::list
[17:47:06.504]             seq.int <- base::seq.int
[17:47:06.504]             signalCondition <- base::signalCondition
[17:47:06.504]             sys.calls <- base::sys.calls
[17:47:06.504]             `[[` <- base::`[[`
[17:47:06.504]             `+` <- base::`+`
[17:47:06.504]             `<<-` <- base::`<<-`
[17:47:06.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.504]                   3L)]
[17:47:06.504]             }
[17:47:06.504]             function(cond) {
[17:47:06.504]                 is_error <- inherits(cond, "error")
[17:47:06.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.504]                   NULL)
[17:47:06.504]                 if (is_error) {
[17:47:06.504]                   sessionInformation <- function() {
[17:47:06.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.504]                       search = base::search(), system = base::Sys.info())
[17:47:06.504]                   }
[17:47:06.504]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.504]                     cond$call), session = sessionInformation(), 
[17:47:06.504]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.504]                   signalCondition(cond)
[17:47:06.504]                 }
[17:47:06.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.504]                 "immediateCondition"))) {
[17:47:06.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.504]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.504]                   if (TRUE && !signal) {
[17:47:06.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.504]                     {
[17:47:06.504]                       inherits <- base::inherits
[17:47:06.504]                       invokeRestart <- base::invokeRestart
[17:47:06.504]                       is.null <- base::is.null
[17:47:06.504]                       muffled <- FALSE
[17:47:06.504]                       if (inherits(cond, "message")) {
[17:47:06.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.504]                         if (muffled) 
[17:47:06.504]                           invokeRestart("muffleMessage")
[17:47:06.504]                       }
[17:47:06.504]                       else if (inherits(cond, "warning")) {
[17:47:06.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.504]                         if (muffled) 
[17:47:06.504]                           invokeRestart("muffleWarning")
[17:47:06.504]                       }
[17:47:06.504]                       else if (inherits(cond, "condition")) {
[17:47:06.504]                         if (!is.null(pattern)) {
[17:47:06.504]                           computeRestarts <- base::computeRestarts
[17:47:06.504]                           grepl <- base::grepl
[17:47:06.504]                           restarts <- computeRestarts(cond)
[17:47:06.504]                           for (restart in restarts) {
[17:47:06.504]                             name <- restart$name
[17:47:06.504]                             if (is.null(name)) 
[17:47:06.504]                               next
[17:47:06.504]                             if (!grepl(pattern, name)) 
[17:47:06.504]                               next
[17:47:06.504]                             invokeRestart(restart)
[17:47:06.504]                             muffled <- TRUE
[17:47:06.504]                             break
[17:47:06.504]                           }
[17:47:06.504]                         }
[17:47:06.504]                       }
[17:47:06.504]                       invisible(muffled)
[17:47:06.504]                     }
[17:47:06.504]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.504]                   }
[17:47:06.504]                 }
[17:47:06.504]                 else {
[17:47:06.504]                   if (TRUE) {
[17:47:06.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.504]                     {
[17:47:06.504]                       inherits <- base::inherits
[17:47:06.504]                       invokeRestart <- base::invokeRestart
[17:47:06.504]                       is.null <- base::is.null
[17:47:06.504]                       muffled <- FALSE
[17:47:06.504]                       if (inherits(cond, "message")) {
[17:47:06.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.504]                         if (muffled) 
[17:47:06.504]                           invokeRestart("muffleMessage")
[17:47:06.504]                       }
[17:47:06.504]                       else if (inherits(cond, "warning")) {
[17:47:06.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.504]                         if (muffled) 
[17:47:06.504]                           invokeRestart("muffleWarning")
[17:47:06.504]                       }
[17:47:06.504]                       else if (inherits(cond, "condition")) {
[17:47:06.504]                         if (!is.null(pattern)) {
[17:47:06.504]                           computeRestarts <- base::computeRestarts
[17:47:06.504]                           grepl <- base::grepl
[17:47:06.504]                           restarts <- computeRestarts(cond)
[17:47:06.504]                           for (restart in restarts) {
[17:47:06.504]                             name <- restart$name
[17:47:06.504]                             if (is.null(name)) 
[17:47:06.504]                               next
[17:47:06.504]                             if (!grepl(pattern, name)) 
[17:47:06.504]                               next
[17:47:06.504]                             invokeRestart(restart)
[17:47:06.504]                             muffled <- TRUE
[17:47:06.504]                             break
[17:47:06.504]                           }
[17:47:06.504]                         }
[17:47:06.504]                       }
[17:47:06.504]                       invisible(muffled)
[17:47:06.504]                     }
[17:47:06.504]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.504]                   }
[17:47:06.504]                 }
[17:47:06.504]             }
[17:47:06.504]         }))
[17:47:06.504]     }, error = function(ex) {
[17:47:06.504]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.504]                 ...future.rng), started = ...future.startTime, 
[17:47:06.504]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.504]             version = "1.8"), class = "FutureResult")
[17:47:06.504]     }, finally = {
[17:47:06.504]         if (!identical(...future.workdir, getwd())) 
[17:47:06.504]             setwd(...future.workdir)
[17:47:06.504]         {
[17:47:06.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.504]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.504]             }
[17:47:06.504]             base::options(...future.oldOptions)
[17:47:06.504]             if (.Platform$OS.type == "windows") {
[17:47:06.504]                 old_names <- names(...future.oldEnvVars)
[17:47:06.504]                 envs <- base::Sys.getenv()
[17:47:06.504]                 names <- names(envs)
[17:47:06.504]                 common <- intersect(names, old_names)
[17:47:06.504]                 added <- setdiff(names, old_names)
[17:47:06.504]                 removed <- setdiff(old_names, names)
[17:47:06.504]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.504]                   envs[common]]
[17:47:06.504]                 NAMES <- toupper(changed)
[17:47:06.504]                 args <- list()
[17:47:06.504]                 for (kk in seq_along(NAMES)) {
[17:47:06.504]                   name <- changed[[kk]]
[17:47:06.504]                   NAME <- NAMES[[kk]]
[17:47:06.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.504]                     next
[17:47:06.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.504]                 }
[17:47:06.504]                 NAMES <- toupper(added)
[17:47:06.504]                 for (kk in seq_along(NAMES)) {
[17:47:06.504]                   name <- added[[kk]]
[17:47:06.504]                   NAME <- NAMES[[kk]]
[17:47:06.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.504]                     next
[17:47:06.504]                   args[[name]] <- ""
[17:47:06.504]                 }
[17:47:06.504]                 NAMES <- toupper(removed)
[17:47:06.504]                 for (kk in seq_along(NAMES)) {
[17:47:06.504]                   name <- removed[[kk]]
[17:47:06.504]                   NAME <- NAMES[[kk]]
[17:47:06.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.504]                     next
[17:47:06.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.504]                 }
[17:47:06.504]                 if (length(args) > 0) 
[17:47:06.504]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.504]             }
[17:47:06.504]             else {
[17:47:06.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.504]             }
[17:47:06.504]             {
[17:47:06.504]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.504]                   0L) {
[17:47:06.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.504]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.504]                   base::options(opts)
[17:47:06.504]                 }
[17:47:06.504]                 {
[17:47:06.504]                   {
[17:47:06.504]                     NULL
[17:47:06.504]                     RNGkind("Mersenne-Twister")
[17:47:06.504]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.504]                       inherits = FALSE)
[17:47:06.504]                   }
[17:47:06.504]                   options(future.plan = NULL)
[17:47:06.504]                   if (is.na(NA_character_)) 
[17:47:06.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.504]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.504]                     .init = FALSE)
[17:47:06.504]                 }
[17:47:06.504]             }
[17:47:06.504]         }
[17:47:06.504]     })
[17:47:06.504]     if (TRUE) {
[17:47:06.504]         base::sink(type = "output", split = FALSE)
[17:47:06.504]         if (TRUE) {
[17:47:06.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.504]         }
[17:47:06.504]         else {
[17:47:06.504]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.504]         }
[17:47:06.504]         base::close(...future.stdout)
[17:47:06.504]         ...future.stdout <- NULL
[17:47:06.504]     }
[17:47:06.504]     ...future.result$conditions <- ...future.conditions
[17:47:06.504]     ...future.result$finished <- base::Sys.time()
[17:47:06.504]     ...future.result
[17:47:06.504] }
[17:47:06.505] assign_globals() ...
[17:47:06.505] List of 1
[17:47:06.505]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558b323a4bc0> 
[17:47:06.505]  - attr(*, "where")=List of 1
[17:47:06.505]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.505]  - attr(*, "resolved")= logi TRUE
[17:47:06.505]  - attr(*, "total_size")= num 10592
[17:47:06.505]  - attr(*, "already-done")= logi TRUE
[17:47:06.508] - copied ‘a’ to environment
[17:47:06.508] assign_globals() ... done
[17:47:06.508] plan(): Setting new future strategy stack:
[17:47:06.508] List of future strategies:
[17:47:06.508] 1. sequential:
[17:47:06.508]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.508]    - tweaked: FALSE
[17:47:06.508]    - call: NULL
[17:47:06.509] plan(): nbrOfWorkers() = 1
[17:47:06.509] plan(): Setting new future strategy stack:
[17:47:06.510] List of future strategies:
[17:47:06.510] 1. sequential:
[17:47:06.510]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.510]    - tweaked: FALSE
[17:47:06.510]    - call: plan(strategy)
[17:47:06.510] plan(): nbrOfWorkers() = 1
[17:47:06.510] SequentialFuture started (and completed)
[17:47:06.510] - Launch lazy future ... done
[17:47:06.510] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.511] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.511] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.511] 
[17:47:06.511] Searching for globals ... DONE
[17:47:06.512] - globals: [0] <none>
[17:47:06.512] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.512] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.512] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.513] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:06.513] Searching for globals ... DONE
[17:47:06.513] Resolving globals: TRUE
[17:47:06.513] Resolving any globals that are futures ...
[17:47:06.513] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:06.513] Resolving any globals that are futures ... DONE
[17:47:06.514] Resolving futures part of globals (recursively) ...
[17:47:06.514] resolve() on list ...
[17:47:06.514]  recursive: 99
[17:47:06.514]  length: 1
[17:47:06.514]  elements: ‘a’
[17:47:06.514] run() for ‘Future’ ...
[17:47:06.514] - state: ‘created’
[17:47:06.515] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.515] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.515]   - Field: ‘label’
[17:47:06.515]   - Field: ‘local’
[17:47:06.515]   - Field: ‘owner’
[17:47:06.515]   - Field: ‘envir’
[17:47:06.515]   - Field: ‘packages’
[17:47:06.515]   - Field: ‘gc’
[17:47:06.515]   - Field: ‘conditions’
[17:47:06.516]   - Field: ‘expr’
[17:47:06.516]   - Field: ‘uuid’
[17:47:06.516]   - Field: ‘seed’
[17:47:06.516]   - Field: ‘version’
[17:47:06.516]   - Field: ‘result’
[17:47:06.516]   - Field: ‘asynchronous’
[17:47:06.516]   - Field: ‘calls’
[17:47:06.516]   - Field: ‘globals’
[17:47:06.516]   - Field: ‘stdout’
[17:47:06.516]   - Field: ‘earlySignal’
[17:47:06.516]   - Field: ‘lazy’
[17:47:06.517]   - Field: ‘state’
[17:47:06.517] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.517] - Launch lazy future ...
[17:47:06.517] Packages needed by the future expression (n = 0): <none>
[17:47:06.517] Packages needed by future strategies (n = 0): <none>
[17:47:06.517] {
[17:47:06.517]     {
[17:47:06.517]         {
[17:47:06.517]             ...future.startTime <- base::Sys.time()
[17:47:06.517]             {
[17:47:06.517]                 {
[17:47:06.517]                   {
[17:47:06.517]                     base::local({
[17:47:06.517]                       has_future <- base::requireNamespace("future", 
[17:47:06.517]                         quietly = TRUE)
[17:47:06.517]                       if (has_future) {
[17:47:06.517]                         ns <- base::getNamespace("future")
[17:47:06.517]                         version <- ns[[".package"]][["version"]]
[17:47:06.517]                         if (is.null(version)) 
[17:47:06.517]                           version <- utils::packageVersion("future")
[17:47:06.517]                       }
[17:47:06.517]                       else {
[17:47:06.517]                         version <- NULL
[17:47:06.517]                       }
[17:47:06.517]                       if (!has_future || version < "1.8.0") {
[17:47:06.517]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.517]                           "", base::R.version$version.string), 
[17:47:06.517]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.517]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.517]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.517]                             "release", "version")], collapse = " "), 
[17:47:06.517]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.517]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.517]                           info)
[17:47:06.517]                         info <- base::paste(info, collapse = "; ")
[17:47:06.517]                         if (!has_future) {
[17:47:06.517]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.517]                             info)
[17:47:06.517]                         }
[17:47:06.517]                         else {
[17:47:06.517]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.517]                             info, version)
[17:47:06.517]                         }
[17:47:06.517]                         base::stop(msg)
[17:47:06.517]                       }
[17:47:06.517]                     })
[17:47:06.517]                   }
[17:47:06.517]                   ...future.strategy.old <- future::plan("list")
[17:47:06.517]                   options(future.plan = NULL)
[17:47:06.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.517]                 }
[17:47:06.517]                 ...future.workdir <- getwd()
[17:47:06.517]             }
[17:47:06.517]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.517]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.517]         }
[17:47:06.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.517]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.517]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.517]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.517]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.517]             base::names(...future.oldOptions))
[17:47:06.517]     }
[17:47:06.517]     if (FALSE) {
[17:47:06.517]     }
[17:47:06.517]     else {
[17:47:06.517]         if (TRUE) {
[17:47:06.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.517]                 open = "w")
[17:47:06.517]         }
[17:47:06.517]         else {
[17:47:06.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.517]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.517]         }
[17:47:06.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.517]             base::sink(type = "output", split = FALSE)
[17:47:06.517]             base::close(...future.stdout)
[17:47:06.517]         }, add = TRUE)
[17:47:06.517]     }
[17:47:06.517]     ...future.frame <- base::sys.nframe()
[17:47:06.517]     ...future.conditions <- base::list()
[17:47:06.517]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.517]     if (FALSE) {
[17:47:06.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.517]     }
[17:47:06.517]     ...future.result <- base::tryCatch({
[17:47:06.517]         base::withCallingHandlers({
[17:47:06.517]             ...future.value <- base::withVisible(base::local(1))
[17:47:06.517]             future::FutureResult(value = ...future.value$value, 
[17:47:06.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.517]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.517]                     ...future.globalenv.names))
[17:47:06.517]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.517]         }, condition = base::local({
[17:47:06.517]             c <- base::c
[17:47:06.517]             inherits <- base::inherits
[17:47:06.517]             invokeRestart <- base::invokeRestart
[17:47:06.517]             length <- base::length
[17:47:06.517]             list <- base::list
[17:47:06.517]             seq.int <- base::seq.int
[17:47:06.517]             signalCondition <- base::signalCondition
[17:47:06.517]             sys.calls <- base::sys.calls
[17:47:06.517]             `[[` <- base::`[[`
[17:47:06.517]             `+` <- base::`+`
[17:47:06.517]             `<<-` <- base::`<<-`
[17:47:06.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.517]                   3L)]
[17:47:06.517]             }
[17:47:06.517]             function(cond) {
[17:47:06.517]                 is_error <- inherits(cond, "error")
[17:47:06.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.517]                   NULL)
[17:47:06.517]                 if (is_error) {
[17:47:06.517]                   sessionInformation <- function() {
[17:47:06.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.517]                       search = base::search(), system = base::Sys.info())
[17:47:06.517]                   }
[17:47:06.517]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.517]                     cond$call), session = sessionInformation(), 
[17:47:06.517]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.517]                   signalCondition(cond)
[17:47:06.517]                 }
[17:47:06.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.517]                 "immediateCondition"))) {
[17:47:06.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.517]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.517]                   if (TRUE && !signal) {
[17:47:06.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.517]                     {
[17:47:06.517]                       inherits <- base::inherits
[17:47:06.517]                       invokeRestart <- base::invokeRestart
[17:47:06.517]                       is.null <- base::is.null
[17:47:06.517]                       muffled <- FALSE
[17:47:06.517]                       if (inherits(cond, "message")) {
[17:47:06.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.517]                         if (muffled) 
[17:47:06.517]                           invokeRestart("muffleMessage")
[17:47:06.517]                       }
[17:47:06.517]                       else if (inherits(cond, "warning")) {
[17:47:06.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.517]                         if (muffled) 
[17:47:06.517]                           invokeRestart("muffleWarning")
[17:47:06.517]                       }
[17:47:06.517]                       else if (inherits(cond, "condition")) {
[17:47:06.517]                         if (!is.null(pattern)) {
[17:47:06.517]                           computeRestarts <- base::computeRestarts
[17:47:06.517]                           grepl <- base::grepl
[17:47:06.517]                           restarts <- computeRestarts(cond)
[17:47:06.517]                           for (restart in restarts) {
[17:47:06.517]                             name <- restart$name
[17:47:06.517]                             if (is.null(name)) 
[17:47:06.517]                               next
[17:47:06.517]                             if (!grepl(pattern, name)) 
[17:47:06.517]                               next
[17:47:06.517]                             invokeRestart(restart)
[17:47:06.517]                             muffled <- TRUE
[17:47:06.517]                             break
[17:47:06.517]                           }
[17:47:06.517]                         }
[17:47:06.517]                       }
[17:47:06.517]                       invisible(muffled)
[17:47:06.517]                     }
[17:47:06.517]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.517]                   }
[17:47:06.517]                 }
[17:47:06.517]                 else {
[17:47:06.517]                   if (TRUE) {
[17:47:06.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.517]                     {
[17:47:06.517]                       inherits <- base::inherits
[17:47:06.517]                       invokeRestart <- base::invokeRestart
[17:47:06.517]                       is.null <- base::is.null
[17:47:06.517]                       muffled <- FALSE
[17:47:06.517]                       if (inherits(cond, "message")) {
[17:47:06.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.517]                         if (muffled) 
[17:47:06.517]                           invokeRestart("muffleMessage")
[17:47:06.517]                       }
[17:47:06.517]                       else if (inherits(cond, "warning")) {
[17:47:06.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.517]                         if (muffled) 
[17:47:06.517]                           invokeRestart("muffleWarning")
[17:47:06.517]                       }
[17:47:06.517]                       else if (inherits(cond, "condition")) {
[17:47:06.517]                         if (!is.null(pattern)) {
[17:47:06.517]                           computeRestarts <- base::computeRestarts
[17:47:06.517]                           grepl <- base::grepl
[17:47:06.517]                           restarts <- computeRestarts(cond)
[17:47:06.517]                           for (restart in restarts) {
[17:47:06.517]                             name <- restart$name
[17:47:06.517]                             if (is.null(name)) 
[17:47:06.517]                               next
[17:47:06.517]                             if (!grepl(pattern, name)) 
[17:47:06.517]                               next
[17:47:06.517]                             invokeRestart(restart)
[17:47:06.517]                             muffled <- TRUE
[17:47:06.517]                             break
[17:47:06.517]                           }
[17:47:06.517]                         }
[17:47:06.517]                       }
[17:47:06.517]                       invisible(muffled)
[17:47:06.517]                     }
[17:47:06.517]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.517]                   }
[17:47:06.517]                 }
[17:47:06.517]             }
[17:47:06.517]         }))
[17:47:06.517]     }, error = function(ex) {
[17:47:06.517]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.517]                 ...future.rng), started = ...future.startTime, 
[17:47:06.517]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.517]             version = "1.8"), class = "FutureResult")
[17:47:06.517]     }, finally = {
[17:47:06.517]         if (!identical(...future.workdir, getwd())) 
[17:47:06.517]             setwd(...future.workdir)
[17:47:06.517]         {
[17:47:06.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.517]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.517]             }
[17:47:06.517]             base::options(...future.oldOptions)
[17:47:06.517]             if (.Platform$OS.type == "windows") {
[17:47:06.517]                 old_names <- names(...future.oldEnvVars)
[17:47:06.517]                 envs <- base::Sys.getenv()
[17:47:06.517]                 names <- names(envs)
[17:47:06.517]                 common <- intersect(names, old_names)
[17:47:06.517]                 added <- setdiff(names, old_names)
[17:47:06.517]                 removed <- setdiff(old_names, names)
[17:47:06.517]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.517]                   envs[common]]
[17:47:06.517]                 NAMES <- toupper(changed)
[17:47:06.517]                 args <- list()
[17:47:06.517]                 for (kk in seq_along(NAMES)) {
[17:47:06.517]                   name <- changed[[kk]]
[17:47:06.517]                   NAME <- NAMES[[kk]]
[17:47:06.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.517]                     next
[17:47:06.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.517]                 }
[17:47:06.517]                 NAMES <- toupper(added)
[17:47:06.517]                 for (kk in seq_along(NAMES)) {
[17:47:06.517]                   name <- added[[kk]]
[17:47:06.517]                   NAME <- NAMES[[kk]]
[17:47:06.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.517]                     next
[17:47:06.517]                   args[[name]] <- ""
[17:47:06.517]                 }
[17:47:06.517]                 NAMES <- toupper(removed)
[17:47:06.517]                 for (kk in seq_along(NAMES)) {
[17:47:06.517]                   name <- removed[[kk]]
[17:47:06.517]                   NAME <- NAMES[[kk]]
[17:47:06.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.517]                     next
[17:47:06.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.517]                 }
[17:47:06.517]                 if (length(args) > 0) 
[17:47:06.517]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.517]             }
[17:47:06.517]             else {
[17:47:06.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.517]             }
[17:47:06.517]             {
[17:47:06.517]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.517]                   0L) {
[17:47:06.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.517]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.517]                   base::options(opts)
[17:47:06.517]                 }
[17:47:06.517]                 {
[17:47:06.517]                   {
[17:47:06.517]                     NULL
[17:47:06.517]                     RNGkind("Mersenne-Twister")
[17:47:06.517]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.517]                       inherits = FALSE)
[17:47:06.517]                   }
[17:47:06.517]                   options(future.plan = NULL)
[17:47:06.517]                   if (is.na(NA_character_)) 
[17:47:06.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.517]                     .init = FALSE)
[17:47:06.517]                 }
[17:47:06.517]             }
[17:47:06.517]         }
[17:47:06.517]     })
[17:47:06.517]     if (TRUE) {
[17:47:06.517]         base::sink(type = "output", split = FALSE)
[17:47:06.517]         if (TRUE) {
[17:47:06.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.517]         }
[17:47:06.517]         else {
[17:47:06.517]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.517]         }
[17:47:06.517]         base::close(...future.stdout)
[17:47:06.517]         ...future.stdout <- NULL
[17:47:06.517]     }
[17:47:06.517]     ...future.result$conditions <- ...future.conditions
[17:47:06.517]     ...future.result$finished <- base::Sys.time()
[17:47:06.517]     ...future.result
[17:47:06.517] }
[17:47:06.519] plan(): Setting new future strategy stack:
[17:47:06.519] List of future strategies:
[17:47:06.519] 1. sequential:
[17:47:06.519]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.519]    - tweaked: FALSE
[17:47:06.519]    - call: NULL
[17:47:06.520] plan(): nbrOfWorkers() = 1
[17:47:06.520] plan(): Setting new future strategy stack:
[17:47:06.520] List of future strategies:
[17:47:06.520] 1. sequential:
[17:47:06.520]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.520]    - tweaked: FALSE
[17:47:06.520]    - call: plan(strategy)
[17:47:06.521] plan(): nbrOfWorkers() = 1
[17:47:06.521] SequentialFuture started (and completed)
[17:47:06.521] - Launch lazy future ... done
[17:47:06.521] run() for ‘SequentialFuture’ ... done
[17:47:06.521] resolved() for ‘SequentialFuture’ ...
[17:47:06.521] - state: ‘finished’
[17:47:06.521] - run: TRUE
[17:47:06.521] - result: ‘FutureResult’
[17:47:06.521] resolved() for ‘SequentialFuture’ ... done
[17:47:06.522] Future #1
[17:47:06.522] resolved() for ‘SequentialFuture’ ...
[17:47:06.522] - state: ‘finished’
[17:47:06.522] - run: TRUE
[17:47:06.522] - result: ‘FutureResult’
[17:47:06.522] resolved() for ‘SequentialFuture’ ... done
[17:47:06.522] A SequentialFuture was resolved
[17:47:06.522]  length: 0 (resolved future 1)
[17:47:06.522] resolve() on list ... DONE
[17:47:06.522] - globals: [1] ‘a’
[17:47:06.523] Resolving futures part of globals (recursively) ... DONE
[17:47:06.523] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[17:47:06.524] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[17:47:06.524] - globals: [1] ‘a’
[17:47:06.524] - packages: [1] ‘future’
[17:47:06.524] getGlobalsAndPackages() ... DONE
[17:47:06.524] run() for ‘Future’ ...
[17:47:06.524] - state: ‘created’
[17:47:06.524] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.525] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.525]   - Field: ‘label’
[17:47:06.525]   - Field: ‘local’
[17:47:06.525]   - Field: ‘owner’
[17:47:06.525]   - Field: ‘envir’
[17:47:06.525]   - Field: ‘packages’
[17:47:06.525]   - Field: ‘gc’
[17:47:06.525]   - Field: ‘conditions’
[17:47:06.525]   - Field: ‘expr’
[17:47:06.526]   - Field: ‘uuid’
[17:47:06.526]   - Field: ‘seed’
[17:47:06.526]   - Field: ‘version’
[17:47:06.526]   - Field: ‘result’
[17:47:06.526]   - Field: ‘asynchronous’
[17:47:06.526]   - Field: ‘calls’
[17:47:06.526]   - Field: ‘globals’
[17:47:06.526]   - Field: ‘stdout’
[17:47:06.526]   - Field: ‘earlySignal’
[17:47:06.526]   - Field: ‘lazy’
[17:47:06.526]   - Field: ‘state’
[17:47:06.526] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.527] - Launch lazy future ...
[17:47:06.527] Packages needed by the future expression (n = 1): ‘future’
[17:47:06.527] Packages needed by future strategies (n = 0): <none>
[17:47:06.529] {
[17:47:06.529]     {
[17:47:06.529]         {
[17:47:06.529]             ...future.startTime <- base::Sys.time()
[17:47:06.529]             {
[17:47:06.529]                 {
[17:47:06.529]                   {
[17:47:06.529]                     {
[17:47:06.529]                       base::local({
[17:47:06.529]                         has_future <- base::requireNamespace("future", 
[17:47:06.529]                           quietly = TRUE)
[17:47:06.529]                         if (has_future) {
[17:47:06.529]                           ns <- base::getNamespace("future")
[17:47:06.529]                           version <- ns[[".package"]][["version"]]
[17:47:06.529]                           if (is.null(version)) 
[17:47:06.529]                             version <- utils::packageVersion("future")
[17:47:06.529]                         }
[17:47:06.529]                         else {
[17:47:06.529]                           version <- NULL
[17:47:06.529]                         }
[17:47:06.529]                         if (!has_future || version < "1.8.0") {
[17:47:06.529]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.529]                             "", base::R.version$version.string), 
[17:47:06.529]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.529]                               "release", "version")], collapse = " "), 
[17:47:06.529]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.529]                             info)
[17:47:06.529]                           info <- base::paste(info, collapse = "; ")
[17:47:06.529]                           if (!has_future) {
[17:47:06.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.529]                               info)
[17:47:06.529]                           }
[17:47:06.529]                           else {
[17:47:06.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.529]                               info, version)
[17:47:06.529]                           }
[17:47:06.529]                           base::stop(msg)
[17:47:06.529]                         }
[17:47:06.529]                       })
[17:47:06.529]                     }
[17:47:06.529]                     base::local({
[17:47:06.529]                       for (pkg in "future") {
[17:47:06.529]                         base::loadNamespace(pkg)
[17:47:06.529]                         base::library(pkg, character.only = TRUE)
[17:47:06.529]                       }
[17:47:06.529]                     })
[17:47:06.529]                   }
[17:47:06.529]                   ...future.strategy.old <- future::plan("list")
[17:47:06.529]                   options(future.plan = NULL)
[17:47:06.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.529]                 }
[17:47:06.529]                 ...future.workdir <- getwd()
[17:47:06.529]             }
[17:47:06.529]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.529]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.529]         }
[17:47:06.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.529]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.529]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.529]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.529]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.529]             base::names(...future.oldOptions))
[17:47:06.529]     }
[17:47:06.529]     if (FALSE) {
[17:47:06.529]     }
[17:47:06.529]     else {
[17:47:06.529]         if (TRUE) {
[17:47:06.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.529]                 open = "w")
[17:47:06.529]         }
[17:47:06.529]         else {
[17:47:06.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.529]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.529]         }
[17:47:06.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.529]             base::sink(type = "output", split = FALSE)
[17:47:06.529]             base::close(...future.stdout)
[17:47:06.529]         }, add = TRUE)
[17:47:06.529]     }
[17:47:06.529]     ...future.frame <- base::sys.nframe()
[17:47:06.529]     ...future.conditions <- base::list()
[17:47:06.529]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.529]     if (FALSE) {
[17:47:06.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.529]     }
[17:47:06.529]     ...future.result <- base::tryCatch({
[17:47:06.529]         base::withCallingHandlers({
[17:47:06.529]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:47:06.529]                 1))
[17:47:06.529]             future::FutureResult(value = ...future.value$value, 
[17:47:06.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.529]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.529]                     ...future.globalenv.names))
[17:47:06.529]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.529]         }, condition = base::local({
[17:47:06.529]             c <- base::c
[17:47:06.529]             inherits <- base::inherits
[17:47:06.529]             invokeRestart <- base::invokeRestart
[17:47:06.529]             length <- base::length
[17:47:06.529]             list <- base::list
[17:47:06.529]             seq.int <- base::seq.int
[17:47:06.529]             signalCondition <- base::signalCondition
[17:47:06.529]             sys.calls <- base::sys.calls
[17:47:06.529]             `[[` <- base::`[[`
[17:47:06.529]             `+` <- base::`+`
[17:47:06.529]             `<<-` <- base::`<<-`
[17:47:06.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.529]                   3L)]
[17:47:06.529]             }
[17:47:06.529]             function(cond) {
[17:47:06.529]                 is_error <- inherits(cond, "error")
[17:47:06.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.529]                   NULL)
[17:47:06.529]                 if (is_error) {
[17:47:06.529]                   sessionInformation <- function() {
[17:47:06.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.529]                       search = base::search(), system = base::Sys.info())
[17:47:06.529]                   }
[17:47:06.529]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.529]                     cond$call), session = sessionInformation(), 
[17:47:06.529]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.529]                   signalCondition(cond)
[17:47:06.529]                 }
[17:47:06.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.529]                 "immediateCondition"))) {
[17:47:06.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.529]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.529]                   if (TRUE && !signal) {
[17:47:06.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.529]                     {
[17:47:06.529]                       inherits <- base::inherits
[17:47:06.529]                       invokeRestart <- base::invokeRestart
[17:47:06.529]                       is.null <- base::is.null
[17:47:06.529]                       muffled <- FALSE
[17:47:06.529]                       if (inherits(cond, "message")) {
[17:47:06.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.529]                         if (muffled) 
[17:47:06.529]                           invokeRestart("muffleMessage")
[17:47:06.529]                       }
[17:47:06.529]                       else if (inherits(cond, "warning")) {
[17:47:06.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.529]                         if (muffled) 
[17:47:06.529]                           invokeRestart("muffleWarning")
[17:47:06.529]                       }
[17:47:06.529]                       else if (inherits(cond, "condition")) {
[17:47:06.529]                         if (!is.null(pattern)) {
[17:47:06.529]                           computeRestarts <- base::computeRestarts
[17:47:06.529]                           grepl <- base::grepl
[17:47:06.529]                           restarts <- computeRestarts(cond)
[17:47:06.529]                           for (restart in restarts) {
[17:47:06.529]                             name <- restart$name
[17:47:06.529]                             if (is.null(name)) 
[17:47:06.529]                               next
[17:47:06.529]                             if (!grepl(pattern, name)) 
[17:47:06.529]                               next
[17:47:06.529]                             invokeRestart(restart)
[17:47:06.529]                             muffled <- TRUE
[17:47:06.529]                             break
[17:47:06.529]                           }
[17:47:06.529]                         }
[17:47:06.529]                       }
[17:47:06.529]                       invisible(muffled)
[17:47:06.529]                     }
[17:47:06.529]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.529]                   }
[17:47:06.529]                 }
[17:47:06.529]                 else {
[17:47:06.529]                   if (TRUE) {
[17:47:06.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.529]                     {
[17:47:06.529]                       inherits <- base::inherits
[17:47:06.529]                       invokeRestart <- base::invokeRestart
[17:47:06.529]                       is.null <- base::is.null
[17:47:06.529]                       muffled <- FALSE
[17:47:06.529]                       if (inherits(cond, "message")) {
[17:47:06.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.529]                         if (muffled) 
[17:47:06.529]                           invokeRestart("muffleMessage")
[17:47:06.529]                       }
[17:47:06.529]                       else if (inherits(cond, "warning")) {
[17:47:06.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.529]                         if (muffled) 
[17:47:06.529]                           invokeRestart("muffleWarning")
[17:47:06.529]                       }
[17:47:06.529]                       else if (inherits(cond, "condition")) {
[17:47:06.529]                         if (!is.null(pattern)) {
[17:47:06.529]                           computeRestarts <- base::computeRestarts
[17:47:06.529]                           grepl <- base::grepl
[17:47:06.529]                           restarts <- computeRestarts(cond)
[17:47:06.529]                           for (restart in restarts) {
[17:47:06.529]                             name <- restart$name
[17:47:06.529]                             if (is.null(name)) 
[17:47:06.529]                               next
[17:47:06.529]                             if (!grepl(pattern, name)) 
[17:47:06.529]                               next
[17:47:06.529]                             invokeRestart(restart)
[17:47:06.529]                             muffled <- TRUE
[17:47:06.529]                             break
[17:47:06.529]                           }
[17:47:06.529]                         }
[17:47:06.529]                       }
[17:47:06.529]                       invisible(muffled)
[17:47:06.529]                     }
[17:47:06.529]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.529]                   }
[17:47:06.529]                 }
[17:47:06.529]             }
[17:47:06.529]         }))
[17:47:06.529]     }, error = function(ex) {
[17:47:06.529]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.529]                 ...future.rng), started = ...future.startTime, 
[17:47:06.529]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.529]             version = "1.8"), class = "FutureResult")
[17:47:06.529]     }, finally = {
[17:47:06.529]         if (!identical(...future.workdir, getwd())) 
[17:47:06.529]             setwd(...future.workdir)
[17:47:06.529]         {
[17:47:06.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.529]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.529]             }
[17:47:06.529]             base::options(...future.oldOptions)
[17:47:06.529]             if (.Platform$OS.type == "windows") {
[17:47:06.529]                 old_names <- names(...future.oldEnvVars)
[17:47:06.529]                 envs <- base::Sys.getenv()
[17:47:06.529]                 names <- names(envs)
[17:47:06.529]                 common <- intersect(names, old_names)
[17:47:06.529]                 added <- setdiff(names, old_names)
[17:47:06.529]                 removed <- setdiff(old_names, names)
[17:47:06.529]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.529]                   envs[common]]
[17:47:06.529]                 NAMES <- toupper(changed)
[17:47:06.529]                 args <- list()
[17:47:06.529]                 for (kk in seq_along(NAMES)) {
[17:47:06.529]                   name <- changed[[kk]]
[17:47:06.529]                   NAME <- NAMES[[kk]]
[17:47:06.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.529]                     next
[17:47:06.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.529]                 }
[17:47:06.529]                 NAMES <- toupper(added)
[17:47:06.529]                 for (kk in seq_along(NAMES)) {
[17:47:06.529]                   name <- added[[kk]]
[17:47:06.529]                   NAME <- NAMES[[kk]]
[17:47:06.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.529]                     next
[17:47:06.529]                   args[[name]] <- ""
[17:47:06.529]                 }
[17:47:06.529]                 NAMES <- toupper(removed)
[17:47:06.529]                 for (kk in seq_along(NAMES)) {
[17:47:06.529]                   name <- removed[[kk]]
[17:47:06.529]                   NAME <- NAMES[[kk]]
[17:47:06.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.529]                     next
[17:47:06.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.529]                 }
[17:47:06.529]                 if (length(args) > 0) 
[17:47:06.529]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.529]             }
[17:47:06.529]             else {
[17:47:06.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.529]             }
[17:47:06.529]             {
[17:47:06.529]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.529]                   0L) {
[17:47:06.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.529]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.529]                   base::options(opts)
[17:47:06.529]                 }
[17:47:06.529]                 {
[17:47:06.529]                   {
[17:47:06.529]                     NULL
[17:47:06.529]                     RNGkind("Mersenne-Twister")
[17:47:06.529]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.529]                       inherits = FALSE)
[17:47:06.529]                   }
[17:47:06.529]                   options(future.plan = NULL)
[17:47:06.529]                   if (is.na(NA_character_)) 
[17:47:06.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.529]                     .init = FALSE)
[17:47:06.529]                 }
[17:47:06.529]             }
[17:47:06.529]         }
[17:47:06.529]     })
[17:47:06.529]     if (TRUE) {
[17:47:06.529]         base::sink(type = "output", split = FALSE)
[17:47:06.529]         if (TRUE) {
[17:47:06.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.529]         }
[17:47:06.529]         else {
[17:47:06.529]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.529]         }
[17:47:06.529]         base::close(...future.stdout)
[17:47:06.529]         ...future.stdout <- NULL
[17:47:06.529]     }
[17:47:06.529]     ...future.result$conditions <- ...future.conditions
[17:47:06.529]     ...future.result$finished <- base::Sys.time()
[17:47:06.529]     ...future.result
[17:47:06.529] }
[17:47:06.530] assign_globals() ...
[17:47:06.530] List of 1
[17:47:06.530]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558b320c5210> 
[17:47:06.530]  - attr(*, "where")=List of 1
[17:47:06.530]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.530]  - attr(*, "resolved")= logi TRUE
[17:47:06.530]  - attr(*, "total_size")= num 10592
[17:47:06.530]  - attr(*, "already-done")= logi TRUE
[17:47:06.532] - copied ‘a’ to environment
[17:47:06.533] assign_globals() ... done
[17:47:06.533] plan(): Setting new future strategy stack:
[17:47:06.533] List of future strategies:
[17:47:06.533] 1. sequential:
[17:47:06.533]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.533]    - tweaked: FALSE
[17:47:06.533]    - call: NULL
[17:47:06.533] plan(): nbrOfWorkers() = 1
[17:47:06.534] plan(): Setting new future strategy stack:
[17:47:06.534] List of future strategies:
[17:47:06.534] 1. sequential:
[17:47:06.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.534]    - tweaked: FALSE
[17:47:06.534]    - call: plan(strategy)
[17:47:06.535] plan(): nbrOfWorkers() = 1
[17:47:06.535] SequentialFuture started (and completed)
[17:47:06.535] - Launch lazy future ... done
[17:47:06.535] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.535] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.536] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.536] - globals found: [2] ‘{’, ‘pkg’
[17:47:06.536] Searching for globals ... DONE
[17:47:06.537] Resolving globals: TRUE
[17:47:06.537] Resolving any globals that are futures ...
[17:47:06.537] - globals: [2] ‘{’, ‘pkg’
[17:47:06.537] Resolving any globals that are futures ... DONE
[17:47:06.537] Resolving futures part of globals (recursively) ...
[17:47:06.537] resolve() on list ...
[17:47:06.537]  recursive: 99
[17:47:06.537]  length: 1
[17:47:06.538]  elements: ‘pkg’
[17:47:06.538]  length: 0 (resolved future 1)
[17:47:06.538] resolve() on list ... DONE
[17:47:06.538] - globals: [1] ‘pkg’
[17:47:06.538] Resolving futures part of globals (recursively) ... DONE
[17:47:06.538] The total size of the 1 globals is 112 bytes (112 bytes)
[17:47:06.538] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:47:06.538] - globals: [1] ‘pkg’
[17:47:06.539] 
[17:47:06.539] getGlobalsAndPackages() ... DONE
[17:47:06.539] Packages needed by the future expression (n = 0): <none>
[17:47:06.539] Packages needed by future strategies (n = 0): <none>
[17:47:06.539] {
[17:47:06.539]     {
[17:47:06.539]         {
[17:47:06.539]             ...future.startTime <- base::Sys.time()
[17:47:06.539]             {
[17:47:06.539]                 {
[17:47:06.539]                   {
[17:47:06.539]                     base::local({
[17:47:06.539]                       has_future <- base::requireNamespace("future", 
[17:47:06.539]                         quietly = TRUE)
[17:47:06.539]                       if (has_future) {
[17:47:06.539]                         ns <- base::getNamespace("future")
[17:47:06.539]                         version <- ns[[".package"]][["version"]]
[17:47:06.539]                         if (is.null(version)) 
[17:47:06.539]                           version <- utils::packageVersion("future")
[17:47:06.539]                       }
[17:47:06.539]                       else {
[17:47:06.539]                         version <- NULL
[17:47:06.539]                       }
[17:47:06.539]                       if (!has_future || version < "1.8.0") {
[17:47:06.539]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.539]                           "", base::R.version$version.string), 
[17:47:06.539]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.539]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.539]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.539]                             "release", "version")], collapse = " "), 
[17:47:06.539]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.539]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.539]                           info)
[17:47:06.539]                         info <- base::paste(info, collapse = "; ")
[17:47:06.539]                         if (!has_future) {
[17:47:06.539]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.539]                             info)
[17:47:06.539]                         }
[17:47:06.539]                         else {
[17:47:06.539]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.539]                             info, version)
[17:47:06.539]                         }
[17:47:06.539]                         base::stop(msg)
[17:47:06.539]                       }
[17:47:06.539]                     })
[17:47:06.539]                   }
[17:47:06.539]                   ...future.strategy.old <- future::plan("list")
[17:47:06.539]                   options(future.plan = NULL)
[17:47:06.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.539]                 }
[17:47:06.539]                 ...future.workdir <- getwd()
[17:47:06.539]             }
[17:47:06.539]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.539]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.539]         }
[17:47:06.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.539]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.539]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.539]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.539]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.539]             base::names(...future.oldOptions))
[17:47:06.539]     }
[17:47:06.539]     if (FALSE) {
[17:47:06.539]     }
[17:47:06.539]     else {
[17:47:06.539]         if (TRUE) {
[17:47:06.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.539]                 open = "w")
[17:47:06.539]         }
[17:47:06.539]         else {
[17:47:06.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.539]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.539]         }
[17:47:06.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.539]             base::sink(type = "output", split = FALSE)
[17:47:06.539]             base::close(...future.stdout)
[17:47:06.539]         }, add = TRUE)
[17:47:06.539]     }
[17:47:06.539]     ...future.frame <- base::sys.nframe()
[17:47:06.539]     ...future.conditions <- base::list()
[17:47:06.539]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.539]     if (FALSE) {
[17:47:06.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.539]     }
[17:47:06.539]     ...future.result <- base::tryCatch({
[17:47:06.539]         base::withCallingHandlers({
[17:47:06.539]             ...future.value <- base::withVisible(base::local({
[17:47:06.539]                 pkg
[17:47:06.539]             }))
[17:47:06.539]             future::FutureResult(value = ...future.value$value, 
[17:47:06.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.539]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.539]                     ...future.globalenv.names))
[17:47:06.539]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.539]         }, condition = base::local({
[17:47:06.539]             c <- base::c
[17:47:06.539]             inherits <- base::inherits
[17:47:06.539]             invokeRestart <- base::invokeRestart
[17:47:06.539]             length <- base::length
[17:47:06.539]             list <- base::list
[17:47:06.539]             seq.int <- base::seq.int
[17:47:06.539]             signalCondition <- base::signalCondition
[17:47:06.539]             sys.calls <- base::sys.calls
[17:47:06.539]             `[[` <- base::`[[`
[17:47:06.539]             `+` <- base::`+`
[17:47:06.539]             `<<-` <- base::`<<-`
[17:47:06.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.539]                   3L)]
[17:47:06.539]             }
[17:47:06.539]             function(cond) {
[17:47:06.539]                 is_error <- inherits(cond, "error")
[17:47:06.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.539]                   NULL)
[17:47:06.539]                 if (is_error) {
[17:47:06.539]                   sessionInformation <- function() {
[17:47:06.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.539]                       search = base::search(), system = base::Sys.info())
[17:47:06.539]                   }
[17:47:06.539]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.539]                     cond$call), session = sessionInformation(), 
[17:47:06.539]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.539]                   signalCondition(cond)
[17:47:06.539]                 }
[17:47:06.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.539]                 "immediateCondition"))) {
[17:47:06.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.539]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.539]                   if (TRUE && !signal) {
[17:47:06.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.539]                     {
[17:47:06.539]                       inherits <- base::inherits
[17:47:06.539]                       invokeRestart <- base::invokeRestart
[17:47:06.539]                       is.null <- base::is.null
[17:47:06.539]                       muffled <- FALSE
[17:47:06.539]                       if (inherits(cond, "message")) {
[17:47:06.539]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.539]                         if (muffled) 
[17:47:06.539]                           invokeRestart("muffleMessage")
[17:47:06.539]                       }
[17:47:06.539]                       else if (inherits(cond, "warning")) {
[17:47:06.539]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.539]                         if (muffled) 
[17:47:06.539]                           invokeRestart("muffleWarning")
[17:47:06.539]                       }
[17:47:06.539]                       else if (inherits(cond, "condition")) {
[17:47:06.539]                         if (!is.null(pattern)) {
[17:47:06.539]                           computeRestarts <- base::computeRestarts
[17:47:06.539]                           grepl <- base::grepl
[17:47:06.539]                           restarts <- computeRestarts(cond)
[17:47:06.539]                           for (restart in restarts) {
[17:47:06.539]                             name <- restart$name
[17:47:06.539]                             if (is.null(name)) 
[17:47:06.539]                               next
[17:47:06.539]                             if (!grepl(pattern, name)) 
[17:47:06.539]                               next
[17:47:06.539]                             invokeRestart(restart)
[17:47:06.539]                             muffled <- TRUE
[17:47:06.539]                             break
[17:47:06.539]                           }
[17:47:06.539]                         }
[17:47:06.539]                       }
[17:47:06.539]                       invisible(muffled)
[17:47:06.539]                     }
[17:47:06.539]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.539]                   }
[17:47:06.539]                 }
[17:47:06.539]                 else {
[17:47:06.539]                   if (TRUE) {
[17:47:06.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.539]                     {
[17:47:06.539]                       inherits <- base::inherits
[17:47:06.539]                       invokeRestart <- base::invokeRestart
[17:47:06.539]                       is.null <- base::is.null
[17:47:06.539]                       muffled <- FALSE
[17:47:06.539]                       if (inherits(cond, "message")) {
[17:47:06.539]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.539]                         if (muffled) 
[17:47:06.539]                           invokeRestart("muffleMessage")
[17:47:06.539]                       }
[17:47:06.539]                       else if (inherits(cond, "warning")) {
[17:47:06.539]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.539]                         if (muffled) 
[17:47:06.539]                           invokeRestart("muffleWarning")
[17:47:06.539]                       }
[17:47:06.539]                       else if (inherits(cond, "condition")) {
[17:47:06.539]                         if (!is.null(pattern)) {
[17:47:06.539]                           computeRestarts <- base::computeRestarts
[17:47:06.539]                           grepl <- base::grepl
[17:47:06.539]                           restarts <- computeRestarts(cond)
[17:47:06.539]                           for (restart in restarts) {
[17:47:06.539]                             name <- restart$name
[17:47:06.539]                             if (is.null(name)) 
[17:47:06.539]                               next
[17:47:06.539]                             if (!grepl(pattern, name)) 
[17:47:06.539]                               next
[17:47:06.539]                             invokeRestart(restart)
[17:47:06.539]                             muffled <- TRUE
[17:47:06.539]                             break
[17:47:06.539]                           }
[17:47:06.539]                         }
[17:47:06.539]                       }
[17:47:06.539]                       invisible(muffled)
[17:47:06.539]                     }
[17:47:06.539]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.539]                   }
[17:47:06.539]                 }
[17:47:06.539]             }
[17:47:06.539]         }))
[17:47:06.539]     }, error = function(ex) {
[17:47:06.539]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.539]                 ...future.rng), started = ...future.startTime, 
[17:47:06.539]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.539]             version = "1.8"), class = "FutureResult")
[17:47:06.539]     }, finally = {
[17:47:06.539]         if (!identical(...future.workdir, getwd())) 
[17:47:06.539]             setwd(...future.workdir)
[17:47:06.539]         {
[17:47:06.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.539]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.539]             }
[17:47:06.539]             base::options(...future.oldOptions)
[17:47:06.539]             if (.Platform$OS.type == "windows") {
[17:47:06.539]                 old_names <- names(...future.oldEnvVars)
[17:47:06.539]                 envs <- base::Sys.getenv()
[17:47:06.539]                 names <- names(envs)
[17:47:06.539]                 common <- intersect(names, old_names)
[17:47:06.539]                 added <- setdiff(names, old_names)
[17:47:06.539]                 removed <- setdiff(old_names, names)
[17:47:06.539]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.539]                   envs[common]]
[17:47:06.539]                 NAMES <- toupper(changed)
[17:47:06.539]                 args <- list()
[17:47:06.539]                 for (kk in seq_along(NAMES)) {
[17:47:06.539]                   name <- changed[[kk]]
[17:47:06.539]                   NAME <- NAMES[[kk]]
[17:47:06.539]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.539]                     next
[17:47:06.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.539]                 }
[17:47:06.539]                 NAMES <- toupper(added)
[17:47:06.539]                 for (kk in seq_along(NAMES)) {
[17:47:06.539]                   name <- added[[kk]]
[17:47:06.539]                   NAME <- NAMES[[kk]]
[17:47:06.539]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.539]                     next
[17:47:06.539]                   args[[name]] <- ""
[17:47:06.539]                 }
[17:47:06.539]                 NAMES <- toupper(removed)
[17:47:06.539]                 for (kk in seq_along(NAMES)) {
[17:47:06.539]                   name <- removed[[kk]]
[17:47:06.539]                   NAME <- NAMES[[kk]]
[17:47:06.539]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.539]                     next
[17:47:06.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.539]                 }
[17:47:06.539]                 if (length(args) > 0) 
[17:47:06.539]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.539]             }
[17:47:06.539]             else {
[17:47:06.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.539]             }
[17:47:06.539]             {
[17:47:06.539]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.539]                   0L) {
[17:47:06.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.539]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.539]                   base::options(opts)
[17:47:06.539]                 }
[17:47:06.539]                 {
[17:47:06.539]                   {
[17:47:06.539]                     NULL
[17:47:06.539]                     RNGkind("Mersenne-Twister")
[17:47:06.539]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.539]                       inherits = FALSE)
[17:47:06.539]                   }
[17:47:06.539]                   options(future.plan = NULL)
[17:47:06.539]                   if (is.na(NA_character_)) 
[17:47:06.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.539]                     .init = FALSE)
[17:47:06.539]                 }
[17:47:06.539]             }
[17:47:06.539]         }
[17:47:06.539]     })
[17:47:06.539]     if (TRUE) {
[17:47:06.539]         base::sink(type = "output", split = FALSE)
[17:47:06.539]         if (TRUE) {
[17:47:06.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.539]         }
[17:47:06.539]         else {
[17:47:06.539]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.539]         }
[17:47:06.539]         base::close(...future.stdout)
[17:47:06.539]         ...future.stdout <- NULL
[17:47:06.539]     }
[17:47:06.539]     ...future.result$conditions <- ...future.conditions
[17:47:06.539]     ...future.result$finished <- base::Sys.time()
[17:47:06.539]     ...future.result
[17:47:06.539] }
[17:47:06.541] assign_globals() ...
[17:47:06.541] List of 1
[17:47:06.541]  $ pkg: chr "foo"
[17:47:06.541]  - attr(*, "where")=List of 1
[17:47:06.541]   ..$ pkg:<environment: R_EmptyEnv> 
[17:47:06.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.541]  - attr(*, "resolved")= logi TRUE
[17:47:06.541]  - attr(*, "total_size")= num 112
[17:47:06.543] - copied ‘pkg’ to environment
[17:47:06.543] assign_globals() ... done
[17:47:06.543] plan(): Setting new future strategy stack:
[17:47:06.543] List of future strategies:
[17:47:06.543] 1. sequential:
[17:47:06.543]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.543]    - tweaked: FALSE
[17:47:06.543]    - call: NULL
[17:47:06.544] plan(): nbrOfWorkers() = 1
[17:47:06.544] plan(): Setting new future strategy stack:
[17:47:06.545] List of future strategies:
[17:47:06.545] 1. sequential:
[17:47:06.545]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.545]    - tweaked: FALSE
[17:47:06.545]    - call: plan(strategy)
[17:47:06.545] plan(): nbrOfWorkers() = 1
[17:47:06.545] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.546] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.546] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.548] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:06.548] Searching for globals ... DONE
[17:47:06.548] Resolving globals: TRUE
[17:47:06.548] Resolving any globals that are futures ...
[17:47:06.549] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:06.549] Resolving any globals that are futures ... DONE
[17:47:06.549] Resolving futures part of globals (recursively) ...
[17:47:06.549] resolve() on list ...
[17:47:06.549]  recursive: 99
[17:47:06.549]  length: 1
[17:47:06.549]  elements: ‘a’
[17:47:06.550]  length: 0 (resolved future 1)
[17:47:06.550] resolve() on list ... DONE
[17:47:06.550] - globals: [1] ‘a’
[17:47:06.550] Resolving futures part of globals (recursively) ... DONE
[17:47:06.550] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.550] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:47:06.550] - globals: [1] ‘a’
[17:47:06.550] 
[17:47:06.551] getGlobalsAndPackages() ... DONE
[17:47:06.551] run() for ‘Future’ ...
[17:47:06.551] - state: ‘created’
[17:47:06.551] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.551] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.551] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.551]   - Field: ‘label’
[17:47:06.552]   - Field: ‘local’
[17:47:06.552]   - Field: ‘owner’
[17:47:06.552]   - Field: ‘envir’
[17:47:06.552]   - Field: ‘packages’
[17:47:06.552]   - Field: ‘gc’
[17:47:06.552]   - Field: ‘conditions’
[17:47:06.552]   - Field: ‘expr’
[17:47:06.552]   - Field: ‘uuid’
[17:47:06.552]   - Field: ‘seed’
[17:47:06.552]   - Field: ‘version’
[17:47:06.552]   - Field: ‘result’
[17:47:06.552]   - Field: ‘asynchronous’
[17:47:06.553]   - Field: ‘calls’
[17:47:06.553]   - Field: ‘globals’
[17:47:06.553]   - Field: ‘stdout’
[17:47:06.553]   - Field: ‘earlySignal’
[17:47:06.553]   - Field: ‘lazy’
[17:47:06.553]   - Field: ‘state’
[17:47:06.553] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.553] - Launch lazy future ...
[17:47:06.553] Packages needed by the future expression (n = 0): <none>
[17:47:06.553] Packages needed by future strategies (n = 0): <none>
[17:47:06.554] {
[17:47:06.554]     {
[17:47:06.554]         {
[17:47:06.554]             ...future.startTime <- base::Sys.time()
[17:47:06.554]             {
[17:47:06.554]                 {
[17:47:06.554]                   {
[17:47:06.554]                     base::local({
[17:47:06.554]                       has_future <- base::requireNamespace("future", 
[17:47:06.554]                         quietly = TRUE)
[17:47:06.554]                       if (has_future) {
[17:47:06.554]                         ns <- base::getNamespace("future")
[17:47:06.554]                         version <- ns[[".package"]][["version"]]
[17:47:06.554]                         if (is.null(version)) 
[17:47:06.554]                           version <- utils::packageVersion("future")
[17:47:06.554]                       }
[17:47:06.554]                       else {
[17:47:06.554]                         version <- NULL
[17:47:06.554]                       }
[17:47:06.554]                       if (!has_future || version < "1.8.0") {
[17:47:06.554]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.554]                           "", base::R.version$version.string), 
[17:47:06.554]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.554]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.554]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.554]                             "release", "version")], collapse = " "), 
[17:47:06.554]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.554]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.554]                           info)
[17:47:06.554]                         info <- base::paste(info, collapse = "; ")
[17:47:06.554]                         if (!has_future) {
[17:47:06.554]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.554]                             info)
[17:47:06.554]                         }
[17:47:06.554]                         else {
[17:47:06.554]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.554]                             info, version)
[17:47:06.554]                         }
[17:47:06.554]                         base::stop(msg)
[17:47:06.554]                       }
[17:47:06.554]                     })
[17:47:06.554]                   }
[17:47:06.554]                   ...future.strategy.old <- future::plan("list")
[17:47:06.554]                   options(future.plan = NULL)
[17:47:06.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.554]                 }
[17:47:06.554]                 ...future.workdir <- getwd()
[17:47:06.554]             }
[17:47:06.554]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.554]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.554]         }
[17:47:06.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.554]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.554]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.554]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.554]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.554]             base::names(...future.oldOptions))
[17:47:06.554]     }
[17:47:06.554]     if (FALSE) {
[17:47:06.554]     }
[17:47:06.554]     else {
[17:47:06.554]         if (TRUE) {
[17:47:06.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.554]                 open = "w")
[17:47:06.554]         }
[17:47:06.554]         else {
[17:47:06.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.554]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.554]         }
[17:47:06.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.554]             base::sink(type = "output", split = FALSE)
[17:47:06.554]             base::close(...future.stdout)
[17:47:06.554]         }, add = TRUE)
[17:47:06.554]     }
[17:47:06.554]     ...future.frame <- base::sys.nframe()
[17:47:06.554]     ...future.conditions <- base::list()
[17:47:06.554]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.554]     if (FALSE) {
[17:47:06.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.554]     }
[17:47:06.554]     ...future.result <- base::tryCatch({
[17:47:06.554]         base::withCallingHandlers({
[17:47:06.554]             ...future.value <- base::withVisible(base::local({
[17:47:06.554]                 b <- a
[17:47:06.554]                 a <- 2
[17:47:06.554]                 a * b
[17:47:06.554]             }))
[17:47:06.554]             future::FutureResult(value = ...future.value$value, 
[17:47:06.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.554]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.554]                     ...future.globalenv.names))
[17:47:06.554]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.554]         }, condition = base::local({
[17:47:06.554]             c <- base::c
[17:47:06.554]             inherits <- base::inherits
[17:47:06.554]             invokeRestart <- base::invokeRestart
[17:47:06.554]             length <- base::length
[17:47:06.554]             list <- base::list
[17:47:06.554]             seq.int <- base::seq.int
[17:47:06.554]             signalCondition <- base::signalCondition
[17:47:06.554]             sys.calls <- base::sys.calls
[17:47:06.554]             `[[` <- base::`[[`
[17:47:06.554]             `+` <- base::`+`
[17:47:06.554]             `<<-` <- base::`<<-`
[17:47:06.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.554]                   3L)]
[17:47:06.554]             }
[17:47:06.554]             function(cond) {
[17:47:06.554]                 is_error <- inherits(cond, "error")
[17:47:06.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.554]                   NULL)
[17:47:06.554]                 if (is_error) {
[17:47:06.554]                   sessionInformation <- function() {
[17:47:06.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.554]                       search = base::search(), system = base::Sys.info())
[17:47:06.554]                   }
[17:47:06.554]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.554]                     cond$call), session = sessionInformation(), 
[17:47:06.554]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.554]                   signalCondition(cond)
[17:47:06.554]                 }
[17:47:06.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.554]                 "immediateCondition"))) {
[17:47:06.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.554]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.554]                   if (TRUE && !signal) {
[17:47:06.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.554]                     {
[17:47:06.554]                       inherits <- base::inherits
[17:47:06.554]                       invokeRestart <- base::invokeRestart
[17:47:06.554]                       is.null <- base::is.null
[17:47:06.554]                       muffled <- FALSE
[17:47:06.554]                       if (inherits(cond, "message")) {
[17:47:06.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.554]                         if (muffled) 
[17:47:06.554]                           invokeRestart("muffleMessage")
[17:47:06.554]                       }
[17:47:06.554]                       else if (inherits(cond, "warning")) {
[17:47:06.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.554]                         if (muffled) 
[17:47:06.554]                           invokeRestart("muffleWarning")
[17:47:06.554]                       }
[17:47:06.554]                       else if (inherits(cond, "condition")) {
[17:47:06.554]                         if (!is.null(pattern)) {
[17:47:06.554]                           computeRestarts <- base::computeRestarts
[17:47:06.554]                           grepl <- base::grepl
[17:47:06.554]                           restarts <- computeRestarts(cond)
[17:47:06.554]                           for (restart in restarts) {
[17:47:06.554]                             name <- restart$name
[17:47:06.554]                             if (is.null(name)) 
[17:47:06.554]                               next
[17:47:06.554]                             if (!grepl(pattern, name)) 
[17:47:06.554]                               next
[17:47:06.554]                             invokeRestart(restart)
[17:47:06.554]                             muffled <- TRUE
[17:47:06.554]                             break
[17:47:06.554]                           }
[17:47:06.554]                         }
[17:47:06.554]                       }
[17:47:06.554]                       invisible(muffled)
[17:47:06.554]                     }
[17:47:06.554]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.554]                   }
[17:47:06.554]                 }
[17:47:06.554]                 else {
[17:47:06.554]                   if (TRUE) {
[17:47:06.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.554]                     {
[17:47:06.554]                       inherits <- base::inherits
[17:47:06.554]                       invokeRestart <- base::invokeRestart
[17:47:06.554]                       is.null <- base::is.null
[17:47:06.554]                       muffled <- FALSE
[17:47:06.554]                       if (inherits(cond, "message")) {
[17:47:06.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.554]                         if (muffled) 
[17:47:06.554]                           invokeRestart("muffleMessage")
[17:47:06.554]                       }
[17:47:06.554]                       else if (inherits(cond, "warning")) {
[17:47:06.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.554]                         if (muffled) 
[17:47:06.554]                           invokeRestart("muffleWarning")
[17:47:06.554]                       }
[17:47:06.554]                       else if (inherits(cond, "condition")) {
[17:47:06.554]                         if (!is.null(pattern)) {
[17:47:06.554]                           computeRestarts <- base::computeRestarts
[17:47:06.554]                           grepl <- base::grepl
[17:47:06.554]                           restarts <- computeRestarts(cond)
[17:47:06.554]                           for (restart in restarts) {
[17:47:06.554]                             name <- restart$name
[17:47:06.554]                             if (is.null(name)) 
[17:47:06.554]                               next
[17:47:06.554]                             if (!grepl(pattern, name)) 
[17:47:06.554]                               next
[17:47:06.554]                             invokeRestart(restart)
[17:47:06.554]                             muffled <- TRUE
[17:47:06.554]                             break
[17:47:06.554]                           }
[17:47:06.554]                         }
[17:47:06.554]                       }
[17:47:06.554]                       invisible(muffled)
[17:47:06.554]                     }
[17:47:06.554]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.554]                   }
[17:47:06.554]                 }
[17:47:06.554]             }
[17:47:06.554]         }))
[17:47:06.554]     }, error = function(ex) {
[17:47:06.554]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.554]                 ...future.rng), started = ...future.startTime, 
[17:47:06.554]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.554]             version = "1.8"), class = "FutureResult")
[17:47:06.554]     }, finally = {
[17:47:06.554]         if (!identical(...future.workdir, getwd())) 
[17:47:06.554]             setwd(...future.workdir)
[17:47:06.554]         {
[17:47:06.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.554]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.554]             }
[17:47:06.554]             base::options(...future.oldOptions)
[17:47:06.554]             if (.Platform$OS.type == "windows") {
[17:47:06.554]                 old_names <- names(...future.oldEnvVars)
[17:47:06.554]                 envs <- base::Sys.getenv()
[17:47:06.554]                 names <- names(envs)
[17:47:06.554]                 common <- intersect(names, old_names)
[17:47:06.554]                 added <- setdiff(names, old_names)
[17:47:06.554]                 removed <- setdiff(old_names, names)
[17:47:06.554]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.554]                   envs[common]]
[17:47:06.554]                 NAMES <- toupper(changed)
[17:47:06.554]                 args <- list()
[17:47:06.554]                 for (kk in seq_along(NAMES)) {
[17:47:06.554]                   name <- changed[[kk]]
[17:47:06.554]                   NAME <- NAMES[[kk]]
[17:47:06.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.554]                     next
[17:47:06.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.554]                 }
[17:47:06.554]                 NAMES <- toupper(added)
[17:47:06.554]                 for (kk in seq_along(NAMES)) {
[17:47:06.554]                   name <- added[[kk]]
[17:47:06.554]                   NAME <- NAMES[[kk]]
[17:47:06.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.554]                     next
[17:47:06.554]                   args[[name]] <- ""
[17:47:06.554]                 }
[17:47:06.554]                 NAMES <- toupper(removed)
[17:47:06.554]                 for (kk in seq_along(NAMES)) {
[17:47:06.554]                   name <- removed[[kk]]
[17:47:06.554]                   NAME <- NAMES[[kk]]
[17:47:06.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.554]                     next
[17:47:06.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.554]                 }
[17:47:06.554]                 if (length(args) > 0) 
[17:47:06.554]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.554]             }
[17:47:06.554]             else {
[17:47:06.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.554]             }
[17:47:06.554]             {
[17:47:06.554]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.554]                   0L) {
[17:47:06.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.554]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.554]                   base::options(opts)
[17:47:06.554]                 }
[17:47:06.554]                 {
[17:47:06.554]                   {
[17:47:06.554]                     NULL
[17:47:06.554]                     RNGkind("Mersenne-Twister")
[17:47:06.554]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.554]                       inherits = FALSE)
[17:47:06.554]                   }
[17:47:06.554]                   options(future.plan = NULL)
[17:47:06.554]                   if (is.na(NA_character_)) 
[17:47:06.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.554]                     .init = FALSE)
[17:47:06.554]                 }
[17:47:06.554]             }
[17:47:06.554]         }
[17:47:06.554]     })
[17:47:06.554]     if (TRUE) {
[17:47:06.554]         base::sink(type = "output", split = FALSE)
[17:47:06.554]         if (TRUE) {
[17:47:06.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.554]         }
[17:47:06.554]         else {
[17:47:06.554]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.554]         }
[17:47:06.554]         base::close(...future.stdout)
[17:47:06.554]         ...future.stdout <- NULL
[17:47:06.554]     }
[17:47:06.554]     ...future.result$conditions <- ...future.conditions
[17:47:06.554]     ...future.result$finished <- base::Sys.time()
[17:47:06.554]     ...future.result
[17:47:06.554] }
[17:47:06.555] assign_globals() ...
[17:47:06.555] List of 1
[17:47:06.555]  $ a: num 3
[17:47:06.555]  - attr(*, "where")=List of 1
[17:47:06.555]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.555]  - attr(*, "resolved")= logi TRUE
[17:47:06.555]  - attr(*, "total_size")= num 56
[17:47:06.555]  - attr(*, "already-done")= logi TRUE
[17:47:06.559] - copied ‘a’ to environment
[17:47:06.560] assign_globals() ... done
[17:47:06.560] plan(): Setting new future strategy stack:
[17:47:06.560] List of future strategies:
[17:47:06.560] 1. sequential:
[17:47:06.560]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.560]    - tweaked: FALSE
[17:47:06.560]    - call: NULL
[17:47:06.560] plan(): nbrOfWorkers() = 1
[17:47:06.561] plan(): Setting new future strategy stack:
[17:47:06.561] List of future strategies:
[17:47:06.561] 1. sequential:
[17:47:06.561]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.561]    - tweaked: FALSE
[17:47:06.561]    - call: plan(strategy)
[17:47:06.561] plan(): nbrOfWorkers() = 1
[17:47:06.562] SequentialFuture started (and completed)
[17:47:06.562] - Launch lazy future ... done
[17:47:06.562] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.562] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.563] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.564] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:06.564] Searching for globals ... DONE
[17:47:06.564] Resolving globals: TRUE
[17:47:06.564] Resolving any globals that are futures ...
[17:47:06.565] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:06.565] Resolving any globals that are futures ... DONE
[17:47:06.565] Resolving futures part of globals (recursively) ...
[17:47:06.565] resolve() on list ...
[17:47:06.565]  recursive: 99
[17:47:06.565]  length: 1
[17:47:06.565]  elements: ‘a’
[17:47:06.565]  length: 0 (resolved future 1)
[17:47:06.566] resolve() on list ... DONE
[17:47:06.566] - globals: [1] ‘a’
[17:47:06.566] Resolving futures part of globals (recursively) ... DONE
[17:47:06.566] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.566] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:47:06.566] - globals: [1] ‘a’
[17:47:06.566] 
[17:47:06.566] getGlobalsAndPackages() ... DONE
[17:47:06.567] run() for ‘Future’ ...
[17:47:06.567] - state: ‘created’
[17:47:06.567] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.567] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.567]   - Field: ‘label’
[17:47:06.568]   - Field: ‘local’
[17:47:06.568]   - Field: ‘owner’
[17:47:06.568]   - Field: ‘envir’
[17:47:06.568]   - Field: ‘packages’
[17:47:06.568]   - Field: ‘gc’
[17:47:06.568]   - Field: ‘conditions’
[17:47:06.568]   - Field: ‘expr’
[17:47:06.568]   - Field: ‘uuid’
[17:47:06.568]   - Field: ‘seed’
[17:47:06.568]   - Field: ‘version’
[17:47:06.568]   - Field: ‘result’
[17:47:06.569]   - Field: ‘asynchronous’
[17:47:06.569]   - Field: ‘calls’
[17:47:06.569]   - Field: ‘globals’
[17:47:06.569]   - Field: ‘stdout’
[17:47:06.569]   - Field: ‘earlySignal’
[17:47:06.569]   - Field: ‘lazy’
[17:47:06.569]   - Field: ‘state’
[17:47:06.569] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.569] - Launch lazy future ...
[17:47:06.569] Packages needed by the future expression (n = 0): <none>
[17:47:06.569] Packages needed by future strategies (n = 0): <none>
[17:47:06.570] {
[17:47:06.570]     {
[17:47:06.570]         {
[17:47:06.570]             ...future.startTime <- base::Sys.time()
[17:47:06.570]             {
[17:47:06.570]                 {
[17:47:06.570]                   {
[17:47:06.570]                     base::local({
[17:47:06.570]                       has_future <- base::requireNamespace("future", 
[17:47:06.570]                         quietly = TRUE)
[17:47:06.570]                       if (has_future) {
[17:47:06.570]                         ns <- base::getNamespace("future")
[17:47:06.570]                         version <- ns[[".package"]][["version"]]
[17:47:06.570]                         if (is.null(version)) 
[17:47:06.570]                           version <- utils::packageVersion("future")
[17:47:06.570]                       }
[17:47:06.570]                       else {
[17:47:06.570]                         version <- NULL
[17:47:06.570]                       }
[17:47:06.570]                       if (!has_future || version < "1.8.0") {
[17:47:06.570]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.570]                           "", base::R.version$version.string), 
[17:47:06.570]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.570]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.570]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.570]                             "release", "version")], collapse = " "), 
[17:47:06.570]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.570]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.570]                           info)
[17:47:06.570]                         info <- base::paste(info, collapse = "; ")
[17:47:06.570]                         if (!has_future) {
[17:47:06.570]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.570]                             info)
[17:47:06.570]                         }
[17:47:06.570]                         else {
[17:47:06.570]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.570]                             info, version)
[17:47:06.570]                         }
[17:47:06.570]                         base::stop(msg)
[17:47:06.570]                       }
[17:47:06.570]                     })
[17:47:06.570]                   }
[17:47:06.570]                   ...future.strategy.old <- future::plan("list")
[17:47:06.570]                   options(future.plan = NULL)
[17:47:06.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.570]                 }
[17:47:06.570]                 ...future.workdir <- getwd()
[17:47:06.570]             }
[17:47:06.570]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.570]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.570]         }
[17:47:06.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.570]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.570]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.570]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.570]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.570]             base::names(...future.oldOptions))
[17:47:06.570]     }
[17:47:06.570]     if (FALSE) {
[17:47:06.570]     }
[17:47:06.570]     else {
[17:47:06.570]         if (TRUE) {
[17:47:06.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.570]                 open = "w")
[17:47:06.570]         }
[17:47:06.570]         else {
[17:47:06.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.570]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.570]         }
[17:47:06.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.570]             base::sink(type = "output", split = FALSE)
[17:47:06.570]             base::close(...future.stdout)
[17:47:06.570]         }, add = TRUE)
[17:47:06.570]     }
[17:47:06.570]     ...future.frame <- base::sys.nframe()
[17:47:06.570]     ...future.conditions <- base::list()
[17:47:06.570]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.570]     if (FALSE) {
[17:47:06.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.570]     }
[17:47:06.570]     ...future.result <- base::tryCatch({
[17:47:06.570]         base::withCallingHandlers({
[17:47:06.570]             ...future.value <- base::withVisible(base::local({
[17:47:06.570]                 b <- a
[17:47:06.570]                 a <- 2
[17:47:06.570]                 a * b
[17:47:06.570]             }))
[17:47:06.570]             future::FutureResult(value = ...future.value$value, 
[17:47:06.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.570]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.570]                     ...future.globalenv.names))
[17:47:06.570]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.570]         }, condition = base::local({
[17:47:06.570]             c <- base::c
[17:47:06.570]             inherits <- base::inherits
[17:47:06.570]             invokeRestart <- base::invokeRestart
[17:47:06.570]             length <- base::length
[17:47:06.570]             list <- base::list
[17:47:06.570]             seq.int <- base::seq.int
[17:47:06.570]             signalCondition <- base::signalCondition
[17:47:06.570]             sys.calls <- base::sys.calls
[17:47:06.570]             `[[` <- base::`[[`
[17:47:06.570]             `+` <- base::`+`
[17:47:06.570]             `<<-` <- base::`<<-`
[17:47:06.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.570]                   3L)]
[17:47:06.570]             }
[17:47:06.570]             function(cond) {
[17:47:06.570]                 is_error <- inherits(cond, "error")
[17:47:06.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.570]                   NULL)
[17:47:06.570]                 if (is_error) {
[17:47:06.570]                   sessionInformation <- function() {
[17:47:06.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.570]                       search = base::search(), system = base::Sys.info())
[17:47:06.570]                   }
[17:47:06.570]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.570]                     cond$call), session = sessionInformation(), 
[17:47:06.570]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.570]                   signalCondition(cond)
[17:47:06.570]                 }
[17:47:06.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.570]                 "immediateCondition"))) {
[17:47:06.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.570]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.570]                   if (TRUE && !signal) {
[17:47:06.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.570]                     {
[17:47:06.570]                       inherits <- base::inherits
[17:47:06.570]                       invokeRestart <- base::invokeRestart
[17:47:06.570]                       is.null <- base::is.null
[17:47:06.570]                       muffled <- FALSE
[17:47:06.570]                       if (inherits(cond, "message")) {
[17:47:06.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.570]                         if (muffled) 
[17:47:06.570]                           invokeRestart("muffleMessage")
[17:47:06.570]                       }
[17:47:06.570]                       else if (inherits(cond, "warning")) {
[17:47:06.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.570]                         if (muffled) 
[17:47:06.570]                           invokeRestart("muffleWarning")
[17:47:06.570]                       }
[17:47:06.570]                       else if (inherits(cond, "condition")) {
[17:47:06.570]                         if (!is.null(pattern)) {
[17:47:06.570]                           computeRestarts <- base::computeRestarts
[17:47:06.570]                           grepl <- base::grepl
[17:47:06.570]                           restarts <- computeRestarts(cond)
[17:47:06.570]                           for (restart in restarts) {
[17:47:06.570]                             name <- restart$name
[17:47:06.570]                             if (is.null(name)) 
[17:47:06.570]                               next
[17:47:06.570]                             if (!grepl(pattern, name)) 
[17:47:06.570]                               next
[17:47:06.570]                             invokeRestart(restart)
[17:47:06.570]                             muffled <- TRUE
[17:47:06.570]                             break
[17:47:06.570]                           }
[17:47:06.570]                         }
[17:47:06.570]                       }
[17:47:06.570]                       invisible(muffled)
[17:47:06.570]                     }
[17:47:06.570]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.570]                   }
[17:47:06.570]                 }
[17:47:06.570]                 else {
[17:47:06.570]                   if (TRUE) {
[17:47:06.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.570]                     {
[17:47:06.570]                       inherits <- base::inherits
[17:47:06.570]                       invokeRestart <- base::invokeRestart
[17:47:06.570]                       is.null <- base::is.null
[17:47:06.570]                       muffled <- FALSE
[17:47:06.570]                       if (inherits(cond, "message")) {
[17:47:06.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.570]                         if (muffled) 
[17:47:06.570]                           invokeRestart("muffleMessage")
[17:47:06.570]                       }
[17:47:06.570]                       else if (inherits(cond, "warning")) {
[17:47:06.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.570]                         if (muffled) 
[17:47:06.570]                           invokeRestart("muffleWarning")
[17:47:06.570]                       }
[17:47:06.570]                       else if (inherits(cond, "condition")) {
[17:47:06.570]                         if (!is.null(pattern)) {
[17:47:06.570]                           computeRestarts <- base::computeRestarts
[17:47:06.570]                           grepl <- base::grepl
[17:47:06.570]                           restarts <- computeRestarts(cond)
[17:47:06.570]                           for (restart in restarts) {
[17:47:06.570]                             name <- restart$name
[17:47:06.570]                             if (is.null(name)) 
[17:47:06.570]                               next
[17:47:06.570]                             if (!grepl(pattern, name)) 
[17:47:06.570]                               next
[17:47:06.570]                             invokeRestart(restart)
[17:47:06.570]                             muffled <- TRUE
[17:47:06.570]                             break
[17:47:06.570]                           }
[17:47:06.570]                         }
[17:47:06.570]                       }
[17:47:06.570]                       invisible(muffled)
[17:47:06.570]                     }
[17:47:06.570]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.570]                   }
[17:47:06.570]                 }
[17:47:06.570]             }
[17:47:06.570]         }))
[17:47:06.570]     }, error = function(ex) {
[17:47:06.570]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.570]                 ...future.rng), started = ...future.startTime, 
[17:47:06.570]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.570]             version = "1.8"), class = "FutureResult")
[17:47:06.570]     }, finally = {
[17:47:06.570]         if (!identical(...future.workdir, getwd())) 
[17:47:06.570]             setwd(...future.workdir)
[17:47:06.570]         {
[17:47:06.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.570]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.570]             }
[17:47:06.570]             base::options(...future.oldOptions)
[17:47:06.570]             if (.Platform$OS.type == "windows") {
[17:47:06.570]                 old_names <- names(...future.oldEnvVars)
[17:47:06.570]                 envs <- base::Sys.getenv()
[17:47:06.570]                 names <- names(envs)
[17:47:06.570]                 common <- intersect(names, old_names)
[17:47:06.570]                 added <- setdiff(names, old_names)
[17:47:06.570]                 removed <- setdiff(old_names, names)
[17:47:06.570]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.570]                   envs[common]]
[17:47:06.570]                 NAMES <- toupper(changed)
[17:47:06.570]                 args <- list()
[17:47:06.570]                 for (kk in seq_along(NAMES)) {
[17:47:06.570]                   name <- changed[[kk]]
[17:47:06.570]                   NAME <- NAMES[[kk]]
[17:47:06.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.570]                     next
[17:47:06.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.570]                 }
[17:47:06.570]                 NAMES <- toupper(added)
[17:47:06.570]                 for (kk in seq_along(NAMES)) {
[17:47:06.570]                   name <- added[[kk]]
[17:47:06.570]                   NAME <- NAMES[[kk]]
[17:47:06.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.570]                     next
[17:47:06.570]                   args[[name]] <- ""
[17:47:06.570]                 }
[17:47:06.570]                 NAMES <- toupper(removed)
[17:47:06.570]                 for (kk in seq_along(NAMES)) {
[17:47:06.570]                   name <- removed[[kk]]
[17:47:06.570]                   NAME <- NAMES[[kk]]
[17:47:06.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.570]                     next
[17:47:06.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.570]                 }
[17:47:06.570]                 if (length(args) > 0) 
[17:47:06.570]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.570]             }
[17:47:06.570]             else {
[17:47:06.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.570]             }
[17:47:06.570]             {
[17:47:06.570]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.570]                   0L) {
[17:47:06.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.570]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.570]                   base::options(opts)
[17:47:06.570]                 }
[17:47:06.570]                 {
[17:47:06.570]                   {
[17:47:06.570]                     NULL
[17:47:06.570]                     RNGkind("Mersenne-Twister")
[17:47:06.570]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.570]                       inherits = FALSE)
[17:47:06.570]                   }
[17:47:06.570]                   options(future.plan = NULL)
[17:47:06.570]                   if (is.na(NA_character_)) 
[17:47:06.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.570]                     .init = FALSE)
[17:47:06.570]                 }
[17:47:06.570]             }
[17:47:06.570]         }
[17:47:06.570]     })
[17:47:06.570]     if (TRUE) {
[17:47:06.570]         base::sink(type = "output", split = FALSE)
[17:47:06.570]         if (TRUE) {
[17:47:06.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.570]         }
[17:47:06.570]         else {
[17:47:06.570]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.570]         }
[17:47:06.570]         base::close(...future.stdout)
[17:47:06.570]         ...future.stdout <- NULL
[17:47:06.570]     }
[17:47:06.570]     ...future.result$conditions <- ...future.conditions
[17:47:06.570]     ...future.result$finished <- base::Sys.time()
[17:47:06.570]     ...future.result
[17:47:06.570] }
[17:47:06.571] assign_globals() ...
[17:47:06.571] List of 1
[17:47:06.571]  $ a: num 3
[17:47:06.571]  - attr(*, "where")=List of 1
[17:47:06.571]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.571]  - attr(*, "resolved")= logi TRUE
[17:47:06.571]  - attr(*, "total_size")= num 56
[17:47:06.571]  - attr(*, "already-done")= logi TRUE
[17:47:06.574] - copied ‘a’ to environment
[17:47:06.574] assign_globals() ... done
[17:47:06.574] plan(): Setting new future strategy stack:
[17:47:06.574] List of future strategies:
[17:47:06.574] 1. sequential:
[17:47:06.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.574]    - tweaked: FALSE
[17:47:06.574]    - call: NULL
[17:47:06.575] plan(): nbrOfWorkers() = 1
[17:47:06.575] plan(): Setting new future strategy stack:
[17:47:06.575] List of future strategies:
[17:47:06.575] 1. sequential:
[17:47:06.575]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.575]    - tweaked: FALSE
[17:47:06.575]    - call: plan(strategy)
[17:47:06.576] plan(): nbrOfWorkers() = 1
[17:47:06.576] SequentialFuture started (and completed)
[17:47:06.576] - Launch lazy future ... done
[17:47:06.576] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.577] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.577] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.579] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.579] Searching for globals ... DONE
[17:47:06.579] Resolving globals: TRUE
[17:47:06.579] Resolving any globals that are futures ...
[17:47:06.579] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.579] Resolving any globals that are futures ... DONE
[17:47:06.579] Resolving futures part of globals (recursively) ...
[17:47:06.580] resolve() on list ...
[17:47:06.580]  recursive: 99
[17:47:06.580]  length: 2
[17:47:06.580]  elements: ‘a’, ‘ii’
[17:47:06.580]  length: 1 (resolved future 1)
[17:47:06.580]  length: 0 (resolved future 2)
[17:47:06.580] resolve() on list ... DONE
[17:47:06.580] - globals: [2] ‘a’, ‘ii’
[17:47:06.580] Resolving futures part of globals (recursively) ... DONE
[17:47:06.582] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:06.582] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.582] - globals: [2] ‘a’, ‘ii’
[17:47:06.583] 
[17:47:06.583] getGlobalsAndPackages() ... DONE
[17:47:06.583] run() for ‘Future’ ...
[17:47:06.583] - state: ‘created’
[17:47:06.583] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.583] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.584]   - Field: ‘label’
[17:47:06.584]   - Field: ‘local’
[17:47:06.584]   - Field: ‘owner’
[17:47:06.584]   - Field: ‘envir’
[17:47:06.584]   - Field: ‘packages’
[17:47:06.584]   - Field: ‘gc’
[17:47:06.584]   - Field: ‘conditions’
[17:47:06.584]   - Field: ‘expr’
[17:47:06.584]   - Field: ‘uuid’
[17:47:06.584]   - Field: ‘seed’
[17:47:06.584]   - Field: ‘version’
[17:47:06.584]   - Field: ‘result’
[17:47:06.585]   - Field: ‘asynchronous’
[17:47:06.585]   - Field: ‘calls’
[17:47:06.585]   - Field: ‘globals’
[17:47:06.585]   - Field: ‘stdout’
[17:47:06.585]   - Field: ‘earlySignal’
[17:47:06.585]   - Field: ‘lazy’
[17:47:06.585]   - Field: ‘state’
[17:47:06.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.585] - Launch lazy future ...
[17:47:06.585] Packages needed by the future expression (n = 0): <none>
[17:47:06.586] Packages needed by future strategies (n = 0): <none>
[17:47:06.586] {
[17:47:06.586]     {
[17:47:06.586]         {
[17:47:06.586]             ...future.startTime <- base::Sys.time()
[17:47:06.586]             {
[17:47:06.586]                 {
[17:47:06.586]                   {
[17:47:06.586]                     base::local({
[17:47:06.586]                       has_future <- base::requireNamespace("future", 
[17:47:06.586]                         quietly = TRUE)
[17:47:06.586]                       if (has_future) {
[17:47:06.586]                         ns <- base::getNamespace("future")
[17:47:06.586]                         version <- ns[[".package"]][["version"]]
[17:47:06.586]                         if (is.null(version)) 
[17:47:06.586]                           version <- utils::packageVersion("future")
[17:47:06.586]                       }
[17:47:06.586]                       else {
[17:47:06.586]                         version <- NULL
[17:47:06.586]                       }
[17:47:06.586]                       if (!has_future || version < "1.8.0") {
[17:47:06.586]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.586]                           "", base::R.version$version.string), 
[17:47:06.586]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.586]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.586]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.586]                             "release", "version")], collapse = " "), 
[17:47:06.586]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.586]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.586]                           info)
[17:47:06.586]                         info <- base::paste(info, collapse = "; ")
[17:47:06.586]                         if (!has_future) {
[17:47:06.586]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.586]                             info)
[17:47:06.586]                         }
[17:47:06.586]                         else {
[17:47:06.586]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.586]                             info, version)
[17:47:06.586]                         }
[17:47:06.586]                         base::stop(msg)
[17:47:06.586]                       }
[17:47:06.586]                     })
[17:47:06.586]                   }
[17:47:06.586]                   ...future.strategy.old <- future::plan("list")
[17:47:06.586]                   options(future.plan = NULL)
[17:47:06.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.586]                 }
[17:47:06.586]                 ...future.workdir <- getwd()
[17:47:06.586]             }
[17:47:06.586]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.586]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.586]         }
[17:47:06.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.586]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.586]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.586]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.586]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.586]             base::names(...future.oldOptions))
[17:47:06.586]     }
[17:47:06.586]     if (FALSE) {
[17:47:06.586]     }
[17:47:06.586]     else {
[17:47:06.586]         if (TRUE) {
[17:47:06.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.586]                 open = "w")
[17:47:06.586]         }
[17:47:06.586]         else {
[17:47:06.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.586]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.586]         }
[17:47:06.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.586]             base::sink(type = "output", split = FALSE)
[17:47:06.586]             base::close(...future.stdout)
[17:47:06.586]         }, add = TRUE)
[17:47:06.586]     }
[17:47:06.586]     ...future.frame <- base::sys.nframe()
[17:47:06.586]     ...future.conditions <- base::list()
[17:47:06.586]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.586]     if (FALSE) {
[17:47:06.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.586]     }
[17:47:06.586]     ...future.result <- base::tryCatch({
[17:47:06.586]         base::withCallingHandlers({
[17:47:06.586]             ...future.value <- base::withVisible(base::local({
[17:47:06.586]                 b <- a * ii
[17:47:06.586]                 a <- 0
[17:47:06.586]                 b
[17:47:06.586]             }))
[17:47:06.586]             future::FutureResult(value = ...future.value$value, 
[17:47:06.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.586]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.586]                     ...future.globalenv.names))
[17:47:06.586]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.586]         }, condition = base::local({
[17:47:06.586]             c <- base::c
[17:47:06.586]             inherits <- base::inherits
[17:47:06.586]             invokeRestart <- base::invokeRestart
[17:47:06.586]             length <- base::length
[17:47:06.586]             list <- base::list
[17:47:06.586]             seq.int <- base::seq.int
[17:47:06.586]             signalCondition <- base::signalCondition
[17:47:06.586]             sys.calls <- base::sys.calls
[17:47:06.586]             `[[` <- base::`[[`
[17:47:06.586]             `+` <- base::`+`
[17:47:06.586]             `<<-` <- base::`<<-`
[17:47:06.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.586]                   3L)]
[17:47:06.586]             }
[17:47:06.586]             function(cond) {
[17:47:06.586]                 is_error <- inherits(cond, "error")
[17:47:06.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.586]                   NULL)
[17:47:06.586]                 if (is_error) {
[17:47:06.586]                   sessionInformation <- function() {
[17:47:06.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.586]                       search = base::search(), system = base::Sys.info())
[17:47:06.586]                   }
[17:47:06.586]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.586]                     cond$call), session = sessionInformation(), 
[17:47:06.586]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.586]                   signalCondition(cond)
[17:47:06.586]                 }
[17:47:06.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.586]                 "immediateCondition"))) {
[17:47:06.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.586]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.586]                   if (TRUE && !signal) {
[17:47:06.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.586]                     {
[17:47:06.586]                       inherits <- base::inherits
[17:47:06.586]                       invokeRestart <- base::invokeRestart
[17:47:06.586]                       is.null <- base::is.null
[17:47:06.586]                       muffled <- FALSE
[17:47:06.586]                       if (inherits(cond, "message")) {
[17:47:06.586]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.586]                         if (muffled) 
[17:47:06.586]                           invokeRestart("muffleMessage")
[17:47:06.586]                       }
[17:47:06.586]                       else if (inherits(cond, "warning")) {
[17:47:06.586]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.586]                         if (muffled) 
[17:47:06.586]                           invokeRestart("muffleWarning")
[17:47:06.586]                       }
[17:47:06.586]                       else if (inherits(cond, "condition")) {
[17:47:06.586]                         if (!is.null(pattern)) {
[17:47:06.586]                           computeRestarts <- base::computeRestarts
[17:47:06.586]                           grepl <- base::grepl
[17:47:06.586]                           restarts <- computeRestarts(cond)
[17:47:06.586]                           for (restart in restarts) {
[17:47:06.586]                             name <- restart$name
[17:47:06.586]                             if (is.null(name)) 
[17:47:06.586]                               next
[17:47:06.586]                             if (!grepl(pattern, name)) 
[17:47:06.586]                               next
[17:47:06.586]                             invokeRestart(restart)
[17:47:06.586]                             muffled <- TRUE
[17:47:06.586]                             break
[17:47:06.586]                           }
[17:47:06.586]                         }
[17:47:06.586]                       }
[17:47:06.586]                       invisible(muffled)
[17:47:06.586]                     }
[17:47:06.586]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.586]                   }
[17:47:06.586]                 }
[17:47:06.586]                 else {
[17:47:06.586]                   if (TRUE) {
[17:47:06.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.586]                     {
[17:47:06.586]                       inherits <- base::inherits
[17:47:06.586]                       invokeRestart <- base::invokeRestart
[17:47:06.586]                       is.null <- base::is.null
[17:47:06.586]                       muffled <- FALSE
[17:47:06.586]                       if (inherits(cond, "message")) {
[17:47:06.586]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.586]                         if (muffled) 
[17:47:06.586]                           invokeRestart("muffleMessage")
[17:47:06.586]                       }
[17:47:06.586]                       else if (inherits(cond, "warning")) {
[17:47:06.586]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.586]                         if (muffled) 
[17:47:06.586]                           invokeRestart("muffleWarning")
[17:47:06.586]                       }
[17:47:06.586]                       else if (inherits(cond, "condition")) {
[17:47:06.586]                         if (!is.null(pattern)) {
[17:47:06.586]                           computeRestarts <- base::computeRestarts
[17:47:06.586]                           grepl <- base::grepl
[17:47:06.586]                           restarts <- computeRestarts(cond)
[17:47:06.586]                           for (restart in restarts) {
[17:47:06.586]                             name <- restart$name
[17:47:06.586]                             if (is.null(name)) 
[17:47:06.586]                               next
[17:47:06.586]                             if (!grepl(pattern, name)) 
[17:47:06.586]                               next
[17:47:06.586]                             invokeRestart(restart)
[17:47:06.586]                             muffled <- TRUE
[17:47:06.586]                             break
[17:47:06.586]                           }
[17:47:06.586]                         }
[17:47:06.586]                       }
[17:47:06.586]                       invisible(muffled)
[17:47:06.586]                     }
[17:47:06.586]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.586]                   }
[17:47:06.586]                 }
[17:47:06.586]             }
[17:47:06.586]         }))
[17:47:06.586]     }, error = function(ex) {
[17:47:06.586]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.586]                 ...future.rng), started = ...future.startTime, 
[17:47:06.586]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.586]             version = "1.8"), class = "FutureResult")
[17:47:06.586]     }, finally = {
[17:47:06.586]         if (!identical(...future.workdir, getwd())) 
[17:47:06.586]             setwd(...future.workdir)
[17:47:06.586]         {
[17:47:06.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.586]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.586]             }
[17:47:06.586]             base::options(...future.oldOptions)
[17:47:06.586]             if (.Platform$OS.type == "windows") {
[17:47:06.586]                 old_names <- names(...future.oldEnvVars)
[17:47:06.586]                 envs <- base::Sys.getenv()
[17:47:06.586]                 names <- names(envs)
[17:47:06.586]                 common <- intersect(names, old_names)
[17:47:06.586]                 added <- setdiff(names, old_names)
[17:47:06.586]                 removed <- setdiff(old_names, names)
[17:47:06.586]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.586]                   envs[common]]
[17:47:06.586]                 NAMES <- toupper(changed)
[17:47:06.586]                 args <- list()
[17:47:06.586]                 for (kk in seq_along(NAMES)) {
[17:47:06.586]                   name <- changed[[kk]]
[17:47:06.586]                   NAME <- NAMES[[kk]]
[17:47:06.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.586]                     next
[17:47:06.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.586]                 }
[17:47:06.586]                 NAMES <- toupper(added)
[17:47:06.586]                 for (kk in seq_along(NAMES)) {
[17:47:06.586]                   name <- added[[kk]]
[17:47:06.586]                   NAME <- NAMES[[kk]]
[17:47:06.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.586]                     next
[17:47:06.586]                   args[[name]] <- ""
[17:47:06.586]                 }
[17:47:06.586]                 NAMES <- toupper(removed)
[17:47:06.586]                 for (kk in seq_along(NAMES)) {
[17:47:06.586]                   name <- removed[[kk]]
[17:47:06.586]                   NAME <- NAMES[[kk]]
[17:47:06.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.586]                     next
[17:47:06.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.586]                 }
[17:47:06.586]                 if (length(args) > 0) 
[17:47:06.586]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.586]             }
[17:47:06.586]             else {
[17:47:06.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.586]             }
[17:47:06.586]             {
[17:47:06.586]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.586]                   0L) {
[17:47:06.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.586]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.586]                   base::options(opts)
[17:47:06.586]                 }
[17:47:06.586]                 {
[17:47:06.586]                   {
[17:47:06.586]                     NULL
[17:47:06.586]                     RNGkind("Mersenne-Twister")
[17:47:06.586]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.586]                       inherits = FALSE)
[17:47:06.586]                   }
[17:47:06.586]                   options(future.plan = NULL)
[17:47:06.586]                   if (is.na(NA_character_)) 
[17:47:06.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.586]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.586]                     .init = FALSE)
[17:47:06.586]                 }
[17:47:06.586]             }
[17:47:06.586]         }
[17:47:06.586]     })
[17:47:06.586]     if (TRUE) {
[17:47:06.586]         base::sink(type = "output", split = FALSE)
[17:47:06.586]         if (TRUE) {
[17:47:06.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.586]         }
[17:47:06.586]         else {
[17:47:06.586]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.586]         }
[17:47:06.586]         base::close(...future.stdout)
[17:47:06.586]         ...future.stdout <- NULL
[17:47:06.586]     }
[17:47:06.586]     ...future.result$conditions <- ...future.conditions
[17:47:06.586]     ...future.result$finished <- base::Sys.time()
[17:47:06.586]     ...future.result
[17:47:06.586] }
[17:47:06.587] assign_globals() ...
[17:47:06.588] List of 2
[17:47:06.588]  $ a : num 1
[17:47:06.588]  $ ii: int 1
[17:47:06.588]  - attr(*, "where")=List of 2
[17:47:06.588]   ..$ a :<environment: R_EmptyEnv> 
[17:47:06.588]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.588]  - attr(*, "resolved")= logi TRUE
[17:47:06.588]  - attr(*, "total_size")= num 112
[17:47:06.588]  - attr(*, "already-done")= logi TRUE
[17:47:06.590] - copied ‘a’ to environment
[17:47:06.590] - copied ‘ii’ to environment
[17:47:06.591] assign_globals() ... done
[17:47:06.591] plan(): Setting new future strategy stack:
[17:47:06.591] List of future strategies:
[17:47:06.591] 1. sequential:
[17:47:06.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.591]    - tweaked: FALSE
[17:47:06.591]    - call: NULL
[17:47:06.591] plan(): nbrOfWorkers() = 1
[17:47:06.592] plan(): Setting new future strategy stack:
[17:47:06.592] List of future strategies:
[17:47:06.592] 1. sequential:
[17:47:06.592]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.592]    - tweaked: FALSE
[17:47:06.592]    - call: plan(strategy)
[17:47:06.592] plan(): nbrOfWorkers() = 1
[17:47:06.593] SequentialFuture started (and completed)
[17:47:06.593] - Launch lazy future ... done
[17:47:06.593] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.593] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.593] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.595] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.595] Searching for globals ... DONE
[17:47:06.595] Resolving globals: TRUE
[17:47:06.595] Resolving any globals that are futures ...
[17:47:06.596] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.596] Resolving any globals that are futures ... DONE
[17:47:06.596] Resolving futures part of globals (recursively) ...
[17:47:06.596] resolve() on list ...
[17:47:06.596]  recursive: 99
[17:47:06.596]  length: 2
[17:47:06.596]  elements: ‘a’, ‘ii’
[17:47:06.597]  length: 1 (resolved future 1)
[17:47:06.597]  length: 0 (resolved future 2)
[17:47:06.597] resolve() on list ... DONE
[17:47:06.597] - globals: [2] ‘a’, ‘ii’
[17:47:06.597] Resolving futures part of globals (recursively) ... DONE
[17:47:06.597] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:06.597] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.598] - globals: [2] ‘a’, ‘ii’
[17:47:06.598] 
[17:47:06.598] getGlobalsAndPackages() ... DONE
[17:47:06.598] run() for ‘Future’ ...
[17:47:06.598] - state: ‘created’
[17:47:06.598] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.598] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.599] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.599]   - Field: ‘label’
[17:47:06.599]   - Field: ‘local’
[17:47:06.599]   - Field: ‘owner’
[17:47:06.599]   - Field: ‘envir’
[17:47:06.599]   - Field: ‘packages’
[17:47:06.599]   - Field: ‘gc’
[17:47:06.599]   - Field: ‘conditions’
[17:47:06.599]   - Field: ‘expr’
[17:47:06.599]   - Field: ‘uuid’
[17:47:06.599]   - Field: ‘seed’
[17:47:06.600]   - Field: ‘version’
[17:47:06.600]   - Field: ‘result’
[17:47:06.600]   - Field: ‘asynchronous’
[17:47:06.600]   - Field: ‘calls’
[17:47:06.600]   - Field: ‘globals’
[17:47:06.600]   - Field: ‘stdout’
[17:47:06.600]   - Field: ‘earlySignal’
[17:47:06.600]   - Field: ‘lazy’
[17:47:06.600]   - Field: ‘state’
[17:47:06.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.600] - Launch lazy future ...
[17:47:06.601] Packages needed by the future expression (n = 0): <none>
[17:47:06.601] Packages needed by future strategies (n = 0): <none>
[17:47:06.601] {
[17:47:06.601]     {
[17:47:06.601]         {
[17:47:06.601]             ...future.startTime <- base::Sys.time()
[17:47:06.601]             {
[17:47:06.601]                 {
[17:47:06.601]                   {
[17:47:06.601]                     base::local({
[17:47:06.601]                       has_future <- base::requireNamespace("future", 
[17:47:06.601]                         quietly = TRUE)
[17:47:06.601]                       if (has_future) {
[17:47:06.601]                         ns <- base::getNamespace("future")
[17:47:06.601]                         version <- ns[[".package"]][["version"]]
[17:47:06.601]                         if (is.null(version)) 
[17:47:06.601]                           version <- utils::packageVersion("future")
[17:47:06.601]                       }
[17:47:06.601]                       else {
[17:47:06.601]                         version <- NULL
[17:47:06.601]                       }
[17:47:06.601]                       if (!has_future || version < "1.8.0") {
[17:47:06.601]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.601]                           "", base::R.version$version.string), 
[17:47:06.601]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.601]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.601]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.601]                             "release", "version")], collapse = " "), 
[17:47:06.601]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.601]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.601]                           info)
[17:47:06.601]                         info <- base::paste(info, collapse = "; ")
[17:47:06.601]                         if (!has_future) {
[17:47:06.601]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.601]                             info)
[17:47:06.601]                         }
[17:47:06.601]                         else {
[17:47:06.601]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.601]                             info, version)
[17:47:06.601]                         }
[17:47:06.601]                         base::stop(msg)
[17:47:06.601]                       }
[17:47:06.601]                     })
[17:47:06.601]                   }
[17:47:06.601]                   ...future.strategy.old <- future::plan("list")
[17:47:06.601]                   options(future.plan = NULL)
[17:47:06.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.601]                 }
[17:47:06.601]                 ...future.workdir <- getwd()
[17:47:06.601]             }
[17:47:06.601]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.601]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.601]         }
[17:47:06.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.601]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.601]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.601]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.601]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.601]             base::names(...future.oldOptions))
[17:47:06.601]     }
[17:47:06.601]     if (FALSE) {
[17:47:06.601]     }
[17:47:06.601]     else {
[17:47:06.601]         if (TRUE) {
[17:47:06.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.601]                 open = "w")
[17:47:06.601]         }
[17:47:06.601]         else {
[17:47:06.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.601]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.601]         }
[17:47:06.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.601]             base::sink(type = "output", split = FALSE)
[17:47:06.601]             base::close(...future.stdout)
[17:47:06.601]         }, add = TRUE)
[17:47:06.601]     }
[17:47:06.601]     ...future.frame <- base::sys.nframe()
[17:47:06.601]     ...future.conditions <- base::list()
[17:47:06.601]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.601]     if (FALSE) {
[17:47:06.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.601]     }
[17:47:06.601]     ...future.result <- base::tryCatch({
[17:47:06.601]         base::withCallingHandlers({
[17:47:06.601]             ...future.value <- base::withVisible(base::local({
[17:47:06.601]                 b <- a * ii
[17:47:06.601]                 a <- 0
[17:47:06.601]                 b
[17:47:06.601]             }))
[17:47:06.601]             future::FutureResult(value = ...future.value$value, 
[17:47:06.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.601]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.601]                     ...future.globalenv.names))
[17:47:06.601]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.601]         }, condition = base::local({
[17:47:06.601]             c <- base::c
[17:47:06.601]             inherits <- base::inherits
[17:47:06.601]             invokeRestart <- base::invokeRestart
[17:47:06.601]             length <- base::length
[17:47:06.601]             list <- base::list
[17:47:06.601]             seq.int <- base::seq.int
[17:47:06.601]             signalCondition <- base::signalCondition
[17:47:06.601]             sys.calls <- base::sys.calls
[17:47:06.601]             `[[` <- base::`[[`
[17:47:06.601]             `+` <- base::`+`
[17:47:06.601]             `<<-` <- base::`<<-`
[17:47:06.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.601]                   3L)]
[17:47:06.601]             }
[17:47:06.601]             function(cond) {
[17:47:06.601]                 is_error <- inherits(cond, "error")
[17:47:06.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.601]                   NULL)
[17:47:06.601]                 if (is_error) {
[17:47:06.601]                   sessionInformation <- function() {
[17:47:06.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.601]                       search = base::search(), system = base::Sys.info())
[17:47:06.601]                   }
[17:47:06.601]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.601]                     cond$call), session = sessionInformation(), 
[17:47:06.601]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.601]                   signalCondition(cond)
[17:47:06.601]                 }
[17:47:06.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.601]                 "immediateCondition"))) {
[17:47:06.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.601]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.601]                   if (TRUE && !signal) {
[17:47:06.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.601]                     {
[17:47:06.601]                       inherits <- base::inherits
[17:47:06.601]                       invokeRestart <- base::invokeRestart
[17:47:06.601]                       is.null <- base::is.null
[17:47:06.601]                       muffled <- FALSE
[17:47:06.601]                       if (inherits(cond, "message")) {
[17:47:06.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.601]                         if (muffled) 
[17:47:06.601]                           invokeRestart("muffleMessage")
[17:47:06.601]                       }
[17:47:06.601]                       else if (inherits(cond, "warning")) {
[17:47:06.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.601]                         if (muffled) 
[17:47:06.601]                           invokeRestart("muffleWarning")
[17:47:06.601]                       }
[17:47:06.601]                       else if (inherits(cond, "condition")) {
[17:47:06.601]                         if (!is.null(pattern)) {
[17:47:06.601]                           computeRestarts <- base::computeRestarts
[17:47:06.601]                           grepl <- base::grepl
[17:47:06.601]                           restarts <- computeRestarts(cond)
[17:47:06.601]                           for (restart in restarts) {
[17:47:06.601]                             name <- restart$name
[17:47:06.601]                             if (is.null(name)) 
[17:47:06.601]                               next
[17:47:06.601]                             if (!grepl(pattern, name)) 
[17:47:06.601]                               next
[17:47:06.601]                             invokeRestart(restart)
[17:47:06.601]                             muffled <- TRUE
[17:47:06.601]                             break
[17:47:06.601]                           }
[17:47:06.601]                         }
[17:47:06.601]                       }
[17:47:06.601]                       invisible(muffled)
[17:47:06.601]                     }
[17:47:06.601]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.601]                   }
[17:47:06.601]                 }
[17:47:06.601]                 else {
[17:47:06.601]                   if (TRUE) {
[17:47:06.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.601]                     {
[17:47:06.601]                       inherits <- base::inherits
[17:47:06.601]                       invokeRestart <- base::invokeRestart
[17:47:06.601]                       is.null <- base::is.null
[17:47:06.601]                       muffled <- FALSE
[17:47:06.601]                       if (inherits(cond, "message")) {
[17:47:06.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.601]                         if (muffled) 
[17:47:06.601]                           invokeRestart("muffleMessage")
[17:47:06.601]                       }
[17:47:06.601]                       else if (inherits(cond, "warning")) {
[17:47:06.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.601]                         if (muffled) 
[17:47:06.601]                           invokeRestart("muffleWarning")
[17:47:06.601]                       }
[17:47:06.601]                       else if (inherits(cond, "condition")) {
[17:47:06.601]                         if (!is.null(pattern)) {
[17:47:06.601]                           computeRestarts <- base::computeRestarts
[17:47:06.601]                           grepl <- base::grepl
[17:47:06.601]                           restarts <- computeRestarts(cond)
[17:47:06.601]                           for (restart in restarts) {
[17:47:06.601]                             name <- restart$name
[17:47:06.601]                             if (is.null(name)) 
[17:47:06.601]                               next
[17:47:06.601]                             if (!grepl(pattern, name)) 
[17:47:06.601]                               next
[17:47:06.601]                             invokeRestart(restart)
[17:47:06.601]                             muffled <- TRUE
[17:47:06.601]                             break
[17:47:06.601]                           }
[17:47:06.601]                         }
[17:47:06.601]                       }
[17:47:06.601]                       invisible(muffled)
[17:47:06.601]                     }
[17:47:06.601]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.601]                   }
[17:47:06.601]                 }
[17:47:06.601]             }
[17:47:06.601]         }))
[17:47:06.601]     }, error = function(ex) {
[17:47:06.601]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.601]                 ...future.rng), started = ...future.startTime, 
[17:47:06.601]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.601]             version = "1.8"), class = "FutureResult")
[17:47:06.601]     }, finally = {
[17:47:06.601]         if (!identical(...future.workdir, getwd())) 
[17:47:06.601]             setwd(...future.workdir)
[17:47:06.601]         {
[17:47:06.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.601]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.601]             }
[17:47:06.601]             base::options(...future.oldOptions)
[17:47:06.601]             if (.Platform$OS.type == "windows") {
[17:47:06.601]                 old_names <- names(...future.oldEnvVars)
[17:47:06.601]                 envs <- base::Sys.getenv()
[17:47:06.601]                 names <- names(envs)
[17:47:06.601]                 common <- intersect(names, old_names)
[17:47:06.601]                 added <- setdiff(names, old_names)
[17:47:06.601]                 removed <- setdiff(old_names, names)
[17:47:06.601]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.601]                   envs[common]]
[17:47:06.601]                 NAMES <- toupper(changed)
[17:47:06.601]                 args <- list()
[17:47:06.601]                 for (kk in seq_along(NAMES)) {
[17:47:06.601]                   name <- changed[[kk]]
[17:47:06.601]                   NAME <- NAMES[[kk]]
[17:47:06.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.601]                     next
[17:47:06.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.601]                 }
[17:47:06.601]                 NAMES <- toupper(added)
[17:47:06.601]                 for (kk in seq_along(NAMES)) {
[17:47:06.601]                   name <- added[[kk]]
[17:47:06.601]                   NAME <- NAMES[[kk]]
[17:47:06.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.601]                     next
[17:47:06.601]                   args[[name]] <- ""
[17:47:06.601]                 }
[17:47:06.601]                 NAMES <- toupper(removed)
[17:47:06.601]                 for (kk in seq_along(NAMES)) {
[17:47:06.601]                   name <- removed[[kk]]
[17:47:06.601]                   NAME <- NAMES[[kk]]
[17:47:06.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.601]                     next
[17:47:06.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.601]                 }
[17:47:06.601]                 if (length(args) > 0) 
[17:47:06.601]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.601]             }
[17:47:06.601]             else {
[17:47:06.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.601]             }
[17:47:06.601]             {
[17:47:06.601]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.601]                   0L) {
[17:47:06.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.601]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.601]                   base::options(opts)
[17:47:06.601]                 }
[17:47:06.601]                 {
[17:47:06.601]                   {
[17:47:06.601]                     NULL
[17:47:06.601]                     RNGkind("Mersenne-Twister")
[17:47:06.601]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.601]                       inherits = FALSE)
[17:47:06.601]                   }
[17:47:06.601]                   options(future.plan = NULL)
[17:47:06.601]                   if (is.na(NA_character_)) 
[17:47:06.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.601]                     .init = FALSE)
[17:47:06.601]                 }
[17:47:06.601]             }
[17:47:06.601]         }
[17:47:06.601]     })
[17:47:06.601]     if (TRUE) {
[17:47:06.601]         base::sink(type = "output", split = FALSE)
[17:47:06.601]         if (TRUE) {
[17:47:06.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.601]         }
[17:47:06.601]         else {
[17:47:06.601]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.601]         }
[17:47:06.601]         base::close(...future.stdout)
[17:47:06.601]         ...future.stdout <- NULL
[17:47:06.601]     }
[17:47:06.601]     ...future.result$conditions <- ...future.conditions
[17:47:06.601]     ...future.result$finished <- base::Sys.time()
[17:47:06.601]     ...future.result
[17:47:06.601] }
[17:47:06.603] assign_globals() ...
[17:47:06.603] List of 2
[17:47:06.603]  $ a : num 1
[17:47:06.603]  $ ii: int 2
[17:47:06.603]  - attr(*, "where")=List of 2
[17:47:06.603]   ..$ a :<environment: R_EmptyEnv> 
[17:47:06.603]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.603]  - attr(*, "resolved")= logi TRUE
[17:47:06.603]  - attr(*, "total_size")= num 112
[17:47:06.603]  - attr(*, "already-done")= logi TRUE
[17:47:06.606] - copied ‘a’ to environment
[17:47:06.606] - copied ‘ii’ to environment
[17:47:06.606] assign_globals() ... done
[17:47:06.606] plan(): Setting new future strategy stack:
[17:47:06.606] List of future strategies:
[17:47:06.606] 1. sequential:
[17:47:06.606]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.606]    - tweaked: FALSE
[17:47:06.606]    - call: NULL
[17:47:06.608] plan(): nbrOfWorkers() = 1
[17:47:06.609] plan(): Setting new future strategy stack:
[17:47:06.609] List of future strategies:
[17:47:06.609] 1. sequential:
[17:47:06.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.609]    - tweaked: FALSE
[17:47:06.609]    - call: plan(strategy)
[17:47:06.609] plan(): nbrOfWorkers() = 1
[17:47:06.610] SequentialFuture started (and completed)
[17:47:06.610] - Launch lazy future ... done
[17:47:06.610] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.610] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.610] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.612] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.612] Searching for globals ... DONE
[17:47:06.612] Resolving globals: TRUE
[17:47:06.613] Resolving any globals that are futures ...
[17:47:06.613] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.613] Resolving any globals that are futures ... DONE
[17:47:06.613] Resolving futures part of globals (recursively) ...
[17:47:06.613] resolve() on list ...
[17:47:06.613]  recursive: 99
[17:47:06.613]  length: 2
[17:47:06.614]  elements: ‘a’, ‘ii’
[17:47:06.614]  length: 1 (resolved future 1)
[17:47:06.614]  length: 0 (resolved future 2)
[17:47:06.614] resolve() on list ... DONE
[17:47:06.614] - globals: [2] ‘a’, ‘ii’
[17:47:06.614] Resolving futures part of globals (recursively) ... DONE
[17:47:06.614] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:06.614] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.615] - globals: [2] ‘a’, ‘ii’
[17:47:06.615] 
[17:47:06.615] getGlobalsAndPackages() ... DONE
[17:47:06.615] run() for ‘Future’ ...
[17:47:06.615] - state: ‘created’
[17:47:06.615] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.615] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.616]   - Field: ‘label’
[17:47:06.616]   - Field: ‘local’
[17:47:06.616]   - Field: ‘owner’
[17:47:06.616]   - Field: ‘envir’
[17:47:06.616]   - Field: ‘packages’
[17:47:06.616]   - Field: ‘gc’
[17:47:06.616]   - Field: ‘conditions’
[17:47:06.616]   - Field: ‘expr’
[17:47:06.616]   - Field: ‘uuid’
[17:47:06.616]   - Field: ‘seed’
[17:47:06.617]   - Field: ‘version’
[17:47:06.617]   - Field: ‘result’
[17:47:06.617]   - Field: ‘asynchronous’
[17:47:06.617]   - Field: ‘calls’
[17:47:06.617]   - Field: ‘globals’
[17:47:06.617]   - Field: ‘stdout’
[17:47:06.617]   - Field: ‘earlySignal’
[17:47:06.617]   - Field: ‘lazy’
[17:47:06.617]   - Field: ‘state’
[17:47:06.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.617] - Launch lazy future ...
[17:47:06.618] Packages needed by the future expression (n = 0): <none>
[17:47:06.618] Packages needed by future strategies (n = 0): <none>
[17:47:06.618] {
[17:47:06.618]     {
[17:47:06.618]         {
[17:47:06.618]             ...future.startTime <- base::Sys.time()
[17:47:06.618]             {
[17:47:06.618]                 {
[17:47:06.618]                   {
[17:47:06.618]                     base::local({
[17:47:06.618]                       has_future <- base::requireNamespace("future", 
[17:47:06.618]                         quietly = TRUE)
[17:47:06.618]                       if (has_future) {
[17:47:06.618]                         ns <- base::getNamespace("future")
[17:47:06.618]                         version <- ns[[".package"]][["version"]]
[17:47:06.618]                         if (is.null(version)) 
[17:47:06.618]                           version <- utils::packageVersion("future")
[17:47:06.618]                       }
[17:47:06.618]                       else {
[17:47:06.618]                         version <- NULL
[17:47:06.618]                       }
[17:47:06.618]                       if (!has_future || version < "1.8.0") {
[17:47:06.618]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.618]                           "", base::R.version$version.string), 
[17:47:06.618]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.618]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.618]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.618]                             "release", "version")], collapse = " "), 
[17:47:06.618]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.618]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.618]                           info)
[17:47:06.618]                         info <- base::paste(info, collapse = "; ")
[17:47:06.618]                         if (!has_future) {
[17:47:06.618]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.618]                             info)
[17:47:06.618]                         }
[17:47:06.618]                         else {
[17:47:06.618]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.618]                             info, version)
[17:47:06.618]                         }
[17:47:06.618]                         base::stop(msg)
[17:47:06.618]                       }
[17:47:06.618]                     })
[17:47:06.618]                   }
[17:47:06.618]                   ...future.strategy.old <- future::plan("list")
[17:47:06.618]                   options(future.plan = NULL)
[17:47:06.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.618]                 }
[17:47:06.618]                 ...future.workdir <- getwd()
[17:47:06.618]             }
[17:47:06.618]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.618]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.618]         }
[17:47:06.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.618]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.618]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.618]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.618]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.618]             base::names(...future.oldOptions))
[17:47:06.618]     }
[17:47:06.618]     if (FALSE) {
[17:47:06.618]     }
[17:47:06.618]     else {
[17:47:06.618]         if (TRUE) {
[17:47:06.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.618]                 open = "w")
[17:47:06.618]         }
[17:47:06.618]         else {
[17:47:06.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.618]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.618]         }
[17:47:06.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.618]             base::sink(type = "output", split = FALSE)
[17:47:06.618]             base::close(...future.stdout)
[17:47:06.618]         }, add = TRUE)
[17:47:06.618]     }
[17:47:06.618]     ...future.frame <- base::sys.nframe()
[17:47:06.618]     ...future.conditions <- base::list()
[17:47:06.618]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.618]     if (FALSE) {
[17:47:06.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.618]     }
[17:47:06.618]     ...future.result <- base::tryCatch({
[17:47:06.618]         base::withCallingHandlers({
[17:47:06.618]             ...future.value <- base::withVisible(base::local({
[17:47:06.618]                 b <- a * ii
[17:47:06.618]                 a <- 0
[17:47:06.618]                 b
[17:47:06.618]             }))
[17:47:06.618]             future::FutureResult(value = ...future.value$value, 
[17:47:06.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.618]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.618]                     ...future.globalenv.names))
[17:47:06.618]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.618]         }, condition = base::local({
[17:47:06.618]             c <- base::c
[17:47:06.618]             inherits <- base::inherits
[17:47:06.618]             invokeRestart <- base::invokeRestart
[17:47:06.618]             length <- base::length
[17:47:06.618]             list <- base::list
[17:47:06.618]             seq.int <- base::seq.int
[17:47:06.618]             signalCondition <- base::signalCondition
[17:47:06.618]             sys.calls <- base::sys.calls
[17:47:06.618]             `[[` <- base::`[[`
[17:47:06.618]             `+` <- base::`+`
[17:47:06.618]             `<<-` <- base::`<<-`
[17:47:06.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.618]                   3L)]
[17:47:06.618]             }
[17:47:06.618]             function(cond) {
[17:47:06.618]                 is_error <- inherits(cond, "error")
[17:47:06.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.618]                   NULL)
[17:47:06.618]                 if (is_error) {
[17:47:06.618]                   sessionInformation <- function() {
[17:47:06.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.618]                       search = base::search(), system = base::Sys.info())
[17:47:06.618]                   }
[17:47:06.618]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.618]                     cond$call), session = sessionInformation(), 
[17:47:06.618]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.618]                   signalCondition(cond)
[17:47:06.618]                 }
[17:47:06.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.618]                 "immediateCondition"))) {
[17:47:06.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.618]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.618]                   if (TRUE && !signal) {
[17:47:06.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.618]                     {
[17:47:06.618]                       inherits <- base::inherits
[17:47:06.618]                       invokeRestart <- base::invokeRestart
[17:47:06.618]                       is.null <- base::is.null
[17:47:06.618]                       muffled <- FALSE
[17:47:06.618]                       if (inherits(cond, "message")) {
[17:47:06.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.618]                         if (muffled) 
[17:47:06.618]                           invokeRestart("muffleMessage")
[17:47:06.618]                       }
[17:47:06.618]                       else if (inherits(cond, "warning")) {
[17:47:06.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.618]                         if (muffled) 
[17:47:06.618]                           invokeRestart("muffleWarning")
[17:47:06.618]                       }
[17:47:06.618]                       else if (inherits(cond, "condition")) {
[17:47:06.618]                         if (!is.null(pattern)) {
[17:47:06.618]                           computeRestarts <- base::computeRestarts
[17:47:06.618]                           grepl <- base::grepl
[17:47:06.618]                           restarts <- computeRestarts(cond)
[17:47:06.618]                           for (restart in restarts) {
[17:47:06.618]                             name <- restart$name
[17:47:06.618]                             if (is.null(name)) 
[17:47:06.618]                               next
[17:47:06.618]                             if (!grepl(pattern, name)) 
[17:47:06.618]                               next
[17:47:06.618]                             invokeRestart(restart)
[17:47:06.618]                             muffled <- TRUE
[17:47:06.618]                             break
[17:47:06.618]                           }
[17:47:06.618]                         }
[17:47:06.618]                       }
[17:47:06.618]                       invisible(muffled)
[17:47:06.618]                     }
[17:47:06.618]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.618]                   }
[17:47:06.618]                 }
[17:47:06.618]                 else {
[17:47:06.618]                   if (TRUE) {
[17:47:06.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.618]                     {
[17:47:06.618]                       inherits <- base::inherits
[17:47:06.618]                       invokeRestart <- base::invokeRestart
[17:47:06.618]                       is.null <- base::is.null
[17:47:06.618]                       muffled <- FALSE
[17:47:06.618]                       if (inherits(cond, "message")) {
[17:47:06.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.618]                         if (muffled) 
[17:47:06.618]                           invokeRestart("muffleMessage")
[17:47:06.618]                       }
[17:47:06.618]                       else if (inherits(cond, "warning")) {
[17:47:06.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.618]                         if (muffled) 
[17:47:06.618]                           invokeRestart("muffleWarning")
[17:47:06.618]                       }
[17:47:06.618]                       else if (inherits(cond, "condition")) {
[17:47:06.618]                         if (!is.null(pattern)) {
[17:47:06.618]                           computeRestarts <- base::computeRestarts
[17:47:06.618]                           grepl <- base::grepl
[17:47:06.618]                           restarts <- computeRestarts(cond)
[17:47:06.618]                           for (restart in restarts) {
[17:47:06.618]                             name <- restart$name
[17:47:06.618]                             if (is.null(name)) 
[17:47:06.618]                               next
[17:47:06.618]                             if (!grepl(pattern, name)) 
[17:47:06.618]                               next
[17:47:06.618]                             invokeRestart(restart)
[17:47:06.618]                             muffled <- TRUE
[17:47:06.618]                             break
[17:47:06.618]                           }
[17:47:06.618]                         }
[17:47:06.618]                       }
[17:47:06.618]                       invisible(muffled)
[17:47:06.618]                     }
[17:47:06.618]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.618]                   }
[17:47:06.618]                 }
[17:47:06.618]             }
[17:47:06.618]         }))
[17:47:06.618]     }, error = function(ex) {
[17:47:06.618]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.618]                 ...future.rng), started = ...future.startTime, 
[17:47:06.618]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.618]             version = "1.8"), class = "FutureResult")
[17:47:06.618]     }, finally = {
[17:47:06.618]         if (!identical(...future.workdir, getwd())) 
[17:47:06.618]             setwd(...future.workdir)
[17:47:06.618]         {
[17:47:06.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.618]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.618]             }
[17:47:06.618]             base::options(...future.oldOptions)
[17:47:06.618]             if (.Platform$OS.type == "windows") {
[17:47:06.618]                 old_names <- names(...future.oldEnvVars)
[17:47:06.618]                 envs <- base::Sys.getenv()
[17:47:06.618]                 names <- names(envs)
[17:47:06.618]                 common <- intersect(names, old_names)
[17:47:06.618]                 added <- setdiff(names, old_names)
[17:47:06.618]                 removed <- setdiff(old_names, names)
[17:47:06.618]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.618]                   envs[common]]
[17:47:06.618]                 NAMES <- toupper(changed)
[17:47:06.618]                 args <- list()
[17:47:06.618]                 for (kk in seq_along(NAMES)) {
[17:47:06.618]                   name <- changed[[kk]]
[17:47:06.618]                   NAME <- NAMES[[kk]]
[17:47:06.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.618]                     next
[17:47:06.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.618]                 }
[17:47:06.618]                 NAMES <- toupper(added)
[17:47:06.618]                 for (kk in seq_along(NAMES)) {
[17:47:06.618]                   name <- added[[kk]]
[17:47:06.618]                   NAME <- NAMES[[kk]]
[17:47:06.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.618]                     next
[17:47:06.618]                   args[[name]] <- ""
[17:47:06.618]                 }
[17:47:06.618]                 NAMES <- toupper(removed)
[17:47:06.618]                 for (kk in seq_along(NAMES)) {
[17:47:06.618]                   name <- removed[[kk]]
[17:47:06.618]                   NAME <- NAMES[[kk]]
[17:47:06.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.618]                     next
[17:47:06.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.618]                 }
[17:47:06.618]                 if (length(args) > 0) 
[17:47:06.618]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.618]             }
[17:47:06.618]             else {
[17:47:06.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.618]             }
[17:47:06.618]             {
[17:47:06.618]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.618]                   0L) {
[17:47:06.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.618]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.618]                   base::options(opts)
[17:47:06.618]                 }
[17:47:06.618]                 {
[17:47:06.618]                   {
[17:47:06.618]                     NULL
[17:47:06.618]                     RNGkind("Mersenne-Twister")
[17:47:06.618]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.618]                       inherits = FALSE)
[17:47:06.618]                   }
[17:47:06.618]                   options(future.plan = NULL)
[17:47:06.618]                   if (is.na(NA_character_)) 
[17:47:06.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.618]                     .init = FALSE)
[17:47:06.618]                 }
[17:47:06.618]             }
[17:47:06.618]         }
[17:47:06.618]     })
[17:47:06.618]     if (TRUE) {
[17:47:06.618]         base::sink(type = "output", split = FALSE)
[17:47:06.618]         if (TRUE) {
[17:47:06.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.618]         }
[17:47:06.618]         else {
[17:47:06.618]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.618]         }
[17:47:06.618]         base::close(...future.stdout)
[17:47:06.618]         ...future.stdout <- NULL
[17:47:06.618]     }
[17:47:06.618]     ...future.result$conditions <- ...future.conditions
[17:47:06.618]     ...future.result$finished <- base::Sys.time()
[17:47:06.618]     ...future.result
[17:47:06.618] }
[17:47:06.620] assign_globals() ...
[17:47:06.620] List of 2
[17:47:06.620]  $ a : num 1
[17:47:06.620]  $ ii: int 3
[17:47:06.620]  - attr(*, "where")=List of 2
[17:47:06.620]   ..$ a :<environment: R_EmptyEnv> 
[17:47:06.620]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.620]  - attr(*, "resolved")= logi TRUE
[17:47:06.620]  - attr(*, "total_size")= num 112
[17:47:06.620]  - attr(*, "already-done")= logi TRUE
[17:47:06.622] - copied ‘a’ to environment
[17:47:06.623] - copied ‘ii’ to environment
[17:47:06.623] assign_globals() ... done
[17:47:06.623] plan(): Setting new future strategy stack:
[17:47:06.623] List of future strategies:
[17:47:06.623] 1. sequential:
[17:47:06.623]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.623]    - tweaked: FALSE
[17:47:06.623]    - call: NULL
[17:47:06.623] plan(): nbrOfWorkers() = 1
[17:47:06.624] plan(): Setting new future strategy stack:
[17:47:06.624] List of future strategies:
[17:47:06.624] 1. sequential:
[17:47:06.624]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.624]    - tweaked: FALSE
[17:47:06.624]    - call: plan(strategy)
[17:47:06.625] plan(): nbrOfWorkers() = 1
[17:47:06.625] SequentialFuture started (and completed)
[17:47:06.625] - Launch lazy future ... done
[17:47:06.625] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.626] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.626] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.628] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.628] Searching for globals ... DONE
[17:47:06.628] Resolving globals: TRUE
[17:47:06.628] Resolving any globals that are futures ...
[17:47:06.628] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.628] Resolving any globals that are futures ... DONE
[17:47:06.628] Resolving futures part of globals (recursively) ...
[17:47:06.629] resolve() on list ...
[17:47:06.629]  recursive: 99
[17:47:06.629]  length: 2
[17:47:06.629]  elements: ‘a’, ‘ii’
[17:47:06.629]  length: 1 (resolved future 1)
[17:47:06.629]  length: 0 (resolved future 2)
[17:47:06.629] resolve() on list ... DONE
[17:47:06.629] - globals: [2] ‘a’, ‘ii’
[17:47:06.629] Resolving futures part of globals (recursively) ... DONE
[17:47:06.629] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:06.630] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.630] - globals: [2] ‘a’, ‘ii’
[17:47:06.630] 
[17:47:06.630] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.631] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.631] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.634] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.634] Searching for globals ... DONE
[17:47:06.634] Resolving globals: TRUE
[17:47:06.634] Resolving any globals that are futures ...
[17:47:06.634] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.635] Resolving any globals that are futures ... DONE
[17:47:06.635] Resolving futures part of globals (recursively) ...
[17:47:06.635] resolve() on list ...
[17:47:06.635]  recursive: 99
[17:47:06.635]  length: 2
[17:47:06.635]  elements: ‘a’, ‘ii’
[17:47:06.635]  length: 1 (resolved future 1)
[17:47:06.636]  length: 0 (resolved future 2)
[17:47:06.636] resolve() on list ... DONE
[17:47:06.636] - globals: [2] ‘a’, ‘ii’
[17:47:06.636] Resolving futures part of globals (recursively) ... DONE
[17:47:06.636] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:06.636] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.636] - globals: [2] ‘a’, ‘ii’
[17:47:06.637] 
[17:47:06.637] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.637] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.637] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.639] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.639] Searching for globals ... DONE
[17:47:06.639] Resolving globals: TRUE
[17:47:06.639] Resolving any globals that are futures ...
[17:47:06.640] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:06.640] Resolving any globals that are futures ... DONE
[17:47:06.640] Resolving futures part of globals (recursively) ...
[17:47:06.640] resolve() on list ...
[17:47:06.640]  recursive: 99
[17:47:06.640]  length: 2
[17:47:06.640]  elements: ‘a’, ‘ii’
[17:47:06.641]  length: 1 (resolved future 1)
[17:47:06.641]  length: 0 (resolved future 2)
[17:47:06.641] resolve() on list ... DONE
[17:47:06.641] - globals: [2] ‘a’, ‘ii’
[17:47:06.641] Resolving futures part of globals (recursively) ... DONE
[17:47:06.641] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:06.641] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.642] - globals: [2] ‘a’, ‘ii’
[17:47:06.642] 
[17:47:06.642] getGlobalsAndPackages() ... DONE
[17:47:06.642] run() for ‘Future’ ...
[17:47:06.642] - state: ‘created’
[17:47:06.642] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.642] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.643]   - Field: ‘label’
[17:47:06.643]   - Field: ‘local’
[17:47:06.643]   - Field: ‘owner’
[17:47:06.643]   - Field: ‘envir’
[17:47:06.643]   - Field: ‘packages’
[17:47:06.643]   - Field: ‘gc’
[17:47:06.643]   - Field: ‘conditions’
[17:47:06.643]   - Field: ‘expr’
[17:47:06.643]   - Field: ‘uuid’
[17:47:06.643]   - Field: ‘seed’
[17:47:06.644]   - Field: ‘version’
[17:47:06.644]   - Field: ‘result’
[17:47:06.644]   - Field: ‘asynchronous’
[17:47:06.644]   - Field: ‘calls’
[17:47:06.644]   - Field: ‘globals’
[17:47:06.644]   - Field: ‘stdout’
[17:47:06.644]   - Field: ‘earlySignal’
[17:47:06.644]   - Field: ‘lazy’
[17:47:06.644]   - Field: ‘state’
[17:47:06.644] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.644] - Launch lazy future ...
[17:47:06.645] Packages needed by the future expression (n = 0): <none>
[17:47:06.645] Packages needed by future strategies (n = 0): <none>
[17:47:06.645] {
[17:47:06.645]     {
[17:47:06.645]         {
[17:47:06.645]             ...future.startTime <- base::Sys.time()
[17:47:06.645]             {
[17:47:06.645]                 {
[17:47:06.645]                   {
[17:47:06.645]                     base::local({
[17:47:06.645]                       has_future <- base::requireNamespace("future", 
[17:47:06.645]                         quietly = TRUE)
[17:47:06.645]                       if (has_future) {
[17:47:06.645]                         ns <- base::getNamespace("future")
[17:47:06.645]                         version <- ns[[".package"]][["version"]]
[17:47:06.645]                         if (is.null(version)) 
[17:47:06.645]                           version <- utils::packageVersion("future")
[17:47:06.645]                       }
[17:47:06.645]                       else {
[17:47:06.645]                         version <- NULL
[17:47:06.645]                       }
[17:47:06.645]                       if (!has_future || version < "1.8.0") {
[17:47:06.645]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.645]                           "", base::R.version$version.string), 
[17:47:06.645]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.645]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.645]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.645]                             "release", "version")], collapse = " "), 
[17:47:06.645]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.645]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.645]                           info)
[17:47:06.645]                         info <- base::paste(info, collapse = "; ")
[17:47:06.645]                         if (!has_future) {
[17:47:06.645]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.645]                             info)
[17:47:06.645]                         }
[17:47:06.645]                         else {
[17:47:06.645]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.645]                             info, version)
[17:47:06.645]                         }
[17:47:06.645]                         base::stop(msg)
[17:47:06.645]                       }
[17:47:06.645]                     })
[17:47:06.645]                   }
[17:47:06.645]                   ...future.strategy.old <- future::plan("list")
[17:47:06.645]                   options(future.plan = NULL)
[17:47:06.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.645]                 }
[17:47:06.645]                 ...future.workdir <- getwd()
[17:47:06.645]             }
[17:47:06.645]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.645]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.645]         }
[17:47:06.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.645]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.645]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.645]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.645]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.645]             base::names(...future.oldOptions))
[17:47:06.645]     }
[17:47:06.645]     if (FALSE) {
[17:47:06.645]     }
[17:47:06.645]     else {
[17:47:06.645]         if (TRUE) {
[17:47:06.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.645]                 open = "w")
[17:47:06.645]         }
[17:47:06.645]         else {
[17:47:06.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.645]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.645]         }
[17:47:06.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.645]             base::sink(type = "output", split = FALSE)
[17:47:06.645]             base::close(...future.stdout)
[17:47:06.645]         }, add = TRUE)
[17:47:06.645]     }
[17:47:06.645]     ...future.frame <- base::sys.nframe()
[17:47:06.645]     ...future.conditions <- base::list()
[17:47:06.645]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.645]     if (FALSE) {
[17:47:06.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.645]     }
[17:47:06.645]     ...future.result <- base::tryCatch({
[17:47:06.645]         base::withCallingHandlers({
[17:47:06.645]             ...future.value <- base::withVisible(base::local({
[17:47:06.645]                 b <- a * ii
[17:47:06.645]                 a <- 0
[17:47:06.645]                 b
[17:47:06.645]             }))
[17:47:06.645]             future::FutureResult(value = ...future.value$value, 
[17:47:06.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.645]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.645]                     ...future.globalenv.names))
[17:47:06.645]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.645]         }, condition = base::local({
[17:47:06.645]             c <- base::c
[17:47:06.645]             inherits <- base::inherits
[17:47:06.645]             invokeRestart <- base::invokeRestart
[17:47:06.645]             length <- base::length
[17:47:06.645]             list <- base::list
[17:47:06.645]             seq.int <- base::seq.int
[17:47:06.645]             signalCondition <- base::signalCondition
[17:47:06.645]             sys.calls <- base::sys.calls
[17:47:06.645]             `[[` <- base::`[[`
[17:47:06.645]             `+` <- base::`+`
[17:47:06.645]             `<<-` <- base::`<<-`
[17:47:06.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.645]                   3L)]
[17:47:06.645]             }
[17:47:06.645]             function(cond) {
[17:47:06.645]                 is_error <- inherits(cond, "error")
[17:47:06.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.645]                   NULL)
[17:47:06.645]                 if (is_error) {
[17:47:06.645]                   sessionInformation <- function() {
[17:47:06.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.645]                       search = base::search(), system = base::Sys.info())
[17:47:06.645]                   }
[17:47:06.645]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.645]                     cond$call), session = sessionInformation(), 
[17:47:06.645]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.645]                   signalCondition(cond)
[17:47:06.645]                 }
[17:47:06.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.645]                 "immediateCondition"))) {
[17:47:06.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.645]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.645]                   if (TRUE && !signal) {
[17:47:06.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.645]                     {
[17:47:06.645]                       inherits <- base::inherits
[17:47:06.645]                       invokeRestart <- base::invokeRestart
[17:47:06.645]                       is.null <- base::is.null
[17:47:06.645]                       muffled <- FALSE
[17:47:06.645]                       if (inherits(cond, "message")) {
[17:47:06.645]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.645]                         if (muffled) 
[17:47:06.645]                           invokeRestart("muffleMessage")
[17:47:06.645]                       }
[17:47:06.645]                       else if (inherits(cond, "warning")) {
[17:47:06.645]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.645]                         if (muffled) 
[17:47:06.645]                           invokeRestart("muffleWarning")
[17:47:06.645]                       }
[17:47:06.645]                       else if (inherits(cond, "condition")) {
[17:47:06.645]                         if (!is.null(pattern)) {
[17:47:06.645]                           computeRestarts <- base::computeRestarts
[17:47:06.645]                           grepl <- base::grepl
[17:47:06.645]                           restarts <- computeRestarts(cond)
[17:47:06.645]                           for (restart in restarts) {
[17:47:06.645]                             name <- restart$name
[17:47:06.645]                             if (is.null(name)) 
[17:47:06.645]                               next
[17:47:06.645]                             if (!grepl(pattern, name)) 
[17:47:06.645]                               next
[17:47:06.645]                             invokeRestart(restart)
[17:47:06.645]                             muffled <- TRUE
[17:47:06.645]                             break
[17:47:06.645]                           }
[17:47:06.645]                         }
[17:47:06.645]                       }
[17:47:06.645]                       invisible(muffled)
[17:47:06.645]                     }
[17:47:06.645]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.645]                   }
[17:47:06.645]                 }
[17:47:06.645]                 else {
[17:47:06.645]                   if (TRUE) {
[17:47:06.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.645]                     {
[17:47:06.645]                       inherits <- base::inherits
[17:47:06.645]                       invokeRestart <- base::invokeRestart
[17:47:06.645]                       is.null <- base::is.null
[17:47:06.645]                       muffled <- FALSE
[17:47:06.645]                       if (inherits(cond, "message")) {
[17:47:06.645]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.645]                         if (muffled) 
[17:47:06.645]                           invokeRestart("muffleMessage")
[17:47:06.645]                       }
[17:47:06.645]                       else if (inherits(cond, "warning")) {
[17:47:06.645]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.645]                         if (muffled) 
[17:47:06.645]                           invokeRestart("muffleWarning")
[17:47:06.645]                       }
[17:47:06.645]                       else if (inherits(cond, "condition")) {
[17:47:06.645]                         if (!is.null(pattern)) {
[17:47:06.645]                           computeRestarts <- base::computeRestarts
[17:47:06.645]                           grepl <- base::grepl
[17:47:06.645]                           restarts <- computeRestarts(cond)
[17:47:06.645]                           for (restart in restarts) {
[17:47:06.645]                             name <- restart$name
[17:47:06.645]                             if (is.null(name)) 
[17:47:06.645]                               next
[17:47:06.645]                             if (!grepl(pattern, name)) 
[17:47:06.645]                               next
[17:47:06.645]                             invokeRestart(restart)
[17:47:06.645]                             muffled <- TRUE
[17:47:06.645]                             break
[17:47:06.645]                           }
[17:47:06.645]                         }
[17:47:06.645]                       }
[17:47:06.645]                       invisible(muffled)
[17:47:06.645]                     }
[17:47:06.645]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.645]                   }
[17:47:06.645]                 }
[17:47:06.645]             }
[17:47:06.645]         }))
[17:47:06.645]     }, error = function(ex) {
[17:47:06.645]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.645]                 ...future.rng), started = ...future.startTime, 
[17:47:06.645]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.645]             version = "1.8"), class = "FutureResult")
[17:47:06.645]     }, finally = {
[17:47:06.645]         if (!identical(...future.workdir, getwd())) 
[17:47:06.645]             setwd(...future.workdir)
[17:47:06.645]         {
[17:47:06.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.645]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.645]             }
[17:47:06.645]             base::options(...future.oldOptions)
[17:47:06.645]             if (.Platform$OS.type == "windows") {
[17:47:06.645]                 old_names <- names(...future.oldEnvVars)
[17:47:06.645]                 envs <- base::Sys.getenv()
[17:47:06.645]                 names <- names(envs)
[17:47:06.645]                 common <- intersect(names, old_names)
[17:47:06.645]                 added <- setdiff(names, old_names)
[17:47:06.645]                 removed <- setdiff(old_names, names)
[17:47:06.645]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.645]                   envs[common]]
[17:47:06.645]                 NAMES <- toupper(changed)
[17:47:06.645]                 args <- list()
[17:47:06.645]                 for (kk in seq_along(NAMES)) {
[17:47:06.645]                   name <- changed[[kk]]
[17:47:06.645]                   NAME <- NAMES[[kk]]
[17:47:06.645]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.645]                     next
[17:47:06.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.645]                 }
[17:47:06.645]                 NAMES <- toupper(added)
[17:47:06.645]                 for (kk in seq_along(NAMES)) {
[17:47:06.645]                   name <- added[[kk]]
[17:47:06.645]                   NAME <- NAMES[[kk]]
[17:47:06.645]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.645]                     next
[17:47:06.645]                   args[[name]] <- ""
[17:47:06.645]                 }
[17:47:06.645]                 NAMES <- toupper(removed)
[17:47:06.645]                 for (kk in seq_along(NAMES)) {
[17:47:06.645]                   name <- removed[[kk]]
[17:47:06.645]                   NAME <- NAMES[[kk]]
[17:47:06.645]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.645]                     next
[17:47:06.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.645]                 }
[17:47:06.645]                 if (length(args) > 0) 
[17:47:06.645]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.645]             }
[17:47:06.645]             else {
[17:47:06.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.645]             }
[17:47:06.645]             {
[17:47:06.645]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.645]                   0L) {
[17:47:06.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.645]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.645]                   base::options(opts)
[17:47:06.645]                 }
[17:47:06.645]                 {
[17:47:06.645]                   {
[17:47:06.645]                     NULL
[17:47:06.645]                     RNGkind("Mersenne-Twister")
[17:47:06.645]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.645]                       inherits = FALSE)
[17:47:06.645]                   }
[17:47:06.645]                   options(future.plan = NULL)
[17:47:06.645]                   if (is.na(NA_character_)) 
[17:47:06.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.645]                     .init = FALSE)
[17:47:06.645]                 }
[17:47:06.645]             }
[17:47:06.645]         }
[17:47:06.645]     })
[17:47:06.645]     if (TRUE) {
[17:47:06.645]         base::sink(type = "output", split = FALSE)
[17:47:06.645]         if (TRUE) {
[17:47:06.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.645]         }
[17:47:06.645]         else {
[17:47:06.645]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.645]         }
[17:47:06.645]         base::close(...future.stdout)
[17:47:06.645]         ...future.stdout <- NULL
[17:47:06.645]     }
[17:47:06.645]     ...future.result$conditions <- ...future.conditions
[17:47:06.645]     ...future.result$finished <- base::Sys.time()
[17:47:06.645]     ...future.result
[17:47:06.645] }
[17:47:06.647] assign_globals() ...
[17:47:06.647] List of 2
[17:47:06.647]  $ a : num 1
[17:47:06.647]  $ ii: int 1
[17:47:06.647]  - attr(*, "where")=List of 2
[17:47:06.647]   ..$ a :<environment: R_EmptyEnv> 
[17:47:06.647]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.647]  - attr(*, "resolved")= logi TRUE
[17:47:06.647]  - attr(*, "total_size")= num 112
[17:47:06.647]  - attr(*, "already-done")= logi TRUE
[17:47:06.650] - copied ‘a’ to environment
[17:47:06.650] - copied ‘ii’ to environment
[17:47:06.650] assign_globals() ... done
[17:47:06.650] plan(): Setting new future strategy stack:
[17:47:06.650] List of future strategies:
[17:47:06.650] 1. sequential:
[17:47:06.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.650]    - tweaked: FALSE
[17:47:06.650]    - call: NULL
[17:47:06.650] plan(): nbrOfWorkers() = 1
[17:47:06.651] plan(): Setting new future strategy stack:
[17:47:06.651] List of future strategies:
[17:47:06.651] 1. sequential:
[17:47:06.651]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.651]    - tweaked: FALSE
[17:47:06.651]    - call: plan(strategy)
[17:47:06.652] plan(): nbrOfWorkers() = 1
[17:47:06.652] SequentialFuture started (and completed)
[17:47:06.652] - Launch lazy future ... done
[17:47:06.652] run() for ‘SequentialFuture’ ... done
[17:47:06.652] run() for ‘Future’ ...
[17:47:06.652] - state: ‘created’
[17:47:06.652] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.653] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.653]   - Field: ‘label’
[17:47:06.653]   - Field: ‘local’
[17:47:06.653]   - Field: ‘owner’
[17:47:06.653]   - Field: ‘envir’
[17:47:06.653]   - Field: ‘packages’
[17:47:06.653]   - Field: ‘gc’
[17:47:06.653]   - Field: ‘conditions’
[17:47:06.653]   - Field: ‘expr’
[17:47:06.654]   - Field: ‘uuid’
[17:47:06.654]   - Field: ‘seed’
[17:47:06.654]   - Field: ‘version’
[17:47:06.654]   - Field: ‘result’
[17:47:06.654]   - Field: ‘asynchronous’
[17:47:06.654]   - Field: ‘calls’
[17:47:06.654]   - Field: ‘globals’
[17:47:06.654]   - Field: ‘stdout’
[17:47:06.654]   - Field: ‘earlySignal’
[17:47:06.654]   - Field: ‘lazy’
[17:47:06.654]   - Field: ‘state’
[17:47:06.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.655] - Launch lazy future ...
[17:47:06.655] Packages needed by the future expression (n = 0): <none>
[17:47:06.655] Packages needed by future strategies (n = 0): <none>
[17:47:06.657] {
[17:47:06.657]     {
[17:47:06.657]         {
[17:47:06.657]             ...future.startTime <- base::Sys.time()
[17:47:06.657]             {
[17:47:06.657]                 {
[17:47:06.657]                   {
[17:47:06.657]                     base::local({
[17:47:06.657]                       has_future <- base::requireNamespace("future", 
[17:47:06.657]                         quietly = TRUE)
[17:47:06.657]                       if (has_future) {
[17:47:06.657]                         ns <- base::getNamespace("future")
[17:47:06.657]                         version <- ns[[".package"]][["version"]]
[17:47:06.657]                         if (is.null(version)) 
[17:47:06.657]                           version <- utils::packageVersion("future")
[17:47:06.657]                       }
[17:47:06.657]                       else {
[17:47:06.657]                         version <- NULL
[17:47:06.657]                       }
[17:47:06.657]                       if (!has_future || version < "1.8.0") {
[17:47:06.657]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.657]                           "", base::R.version$version.string), 
[17:47:06.657]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.657]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.657]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.657]                             "release", "version")], collapse = " "), 
[17:47:06.657]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.657]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.657]                           info)
[17:47:06.657]                         info <- base::paste(info, collapse = "; ")
[17:47:06.657]                         if (!has_future) {
[17:47:06.657]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.657]                             info)
[17:47:06.657]                         }
[17:47:06.657]                         else {
[17:47:06.657]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.657]                             info, version)
[17:47:06.657]                         }
[17:47:06.657]                         base::stop(msg)
[17:47:06.657]                       }
[17:47:06.657]                     })
[17:47:06.657]                   }
[17:47:06.657]                   ...future.strategy.old <- future::plan("list")
[17:47:06.657]                   options(future.plan = NULL)
[17:47:06.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.657]                 }
[17:47:06.657]                 ...future.workdir <- getwd()
[17:47:06.657]             }
[17:47:06.657]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.657]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.657]         }
[17:47:06.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.657]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.657]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.657]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.657]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.657]             base::names(...future.oldOptions))
[17:47:06.657]     }
[17:47:06.657]     if (FALSE) {
[17:47:06.657]     }
[17:47:06.657]     else {
[17:47:06.657]         if (TRUE) {
[17:47:06.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.657]                 open = "w")
[17:47:06.657]         }
[17:47:06.657]         else {
[17:47:06.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.657]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.657]         }
[17:47:06.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.657]             base::sink(type = "output", split = FALSE)
[17:47:06.657]             base::close(...future.stdout)
[17:47:06.657]         }, add = TRUE)
[17:47:06.657]     }
[17:47:06.657]     ...future.frame <- base::sys.nframe()
[17:47:06.657]     ...future.conditions <- base::list()
[17:47:06.657]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.657]     if (FALSE) {
[17:47:06.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.657]     }
[17:47:06.657]     ...future.result <- base::tryCatch({
[17:47:06.657]         base::withCallingHandlers({
[17:47:06.657]             ...future.value <- base::withVisible(base::local({
[17:47:06.657]                 b <- a * ii
[17:47:06.657]                 a <- 0
[17:47:06.657]                 b
[17:47:06.657]             }))
[17:47:06.657]             future::FutureResult(value = ...future.value$value, 
[17:47:06.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.657]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.657]                     ...future.globalenv.names))
[17:47:06.657]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.657]         }, condition = base::local({
[17:47:06.657]             c <- base::c
[17:47:06.657]             inherits <- base::inherits
[17:47:06.657]             invokeRestart <- base::invokeRestart
[17:47:06.657]             length <- base::length
[17:47:06.657]             list <- base::list
[17:47:06.657]             seq.int <- base::seq.int
[17:47:06.657]             signalCondition <- base::signalCondition
[17:47:06.657]             sys.calls <- base::sys.calls
[17:47:06.657]             `[[` <- base::`[[`
[17:47:06.657]             `+` <- base::`+`
[17:47:06.657]             `<<-` <- base::`<<-`
[17:47:06.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.657]                   3L)]
[17:47:06.657]             }
[17:47:06.657]             function(cond) {
[17:47:06.657]                 is_error <- inherits(cond, "error")
[17:47:06.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.657]                   NULL)
[17:47:06.657]                 if (is_error) {
[17:47:06.657]                   sessionInformation <- function() {
[17:47:06.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.657]                       search = base::search(), system = base::Sys.info())
[17:47:06.657]                   }
[17:47:06.657]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.657]                     cond$call), session = sessionInformation(), 
[17:47:06.657]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.657]                   signalCondition(cond)
[17:47:06.657]                 }
[17:47:06.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.657]                 "immediateCondition"))) {
[17:47:06.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.657]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.657]                   if (TRUE && !signal) {
[17:47:06.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.657]                     {
[17:47:06.657]                       inherits <- base::inherits
[17:47:06.657]                       invokeRestart <- base::invokeRestart
[17:47:06.657]                       is.null <- base::is.null
[17:47:06.657]                       muffled <- FALSE
[17:47:06.657]                       if (inherits(cond, "message")) {
[17:47:06.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.657]                         if (muffled) 
[17:47:06.657]                           invokeRestart("muffleMessage")
[17:47:06.657]                       }
[17:47:06.657]                       else if (inherits(cond, "warning")) {
[17:47:06.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.657]                         if (muffled) 
[17:47:06.657]                           invokeRestart("muffleWarning")
[17:47:06.657]                       }
[17:47:06.657]                       else if (inherits(cond, "condition")) {
[17:47:06.657]                         if (!is.null(pattern)) {
[17:47:06.657]                           computeRestarts <- base::computeRestarts
[17:47:06.657]                           grepl <- base::grepl
[17:47:06.657]                           restarts <- computeRestarts(cond)
[17:47:06.657]                           for (restart in restarts) {
[17:47:06.657]                             name <- restart$name
[17:47:06.657]                             if (is.null(name)) 
[17:47:06.657]                               next
[17:47:06.657]                             if (!grepl(pattern, name)) 
[17:47:06.657]                               next
[17:47:06.657]                             invokeRestart(restart)
[17:47:06.657]                             muffled <- TRUE
[17:47:06.657]                             break
[17:47:06.657]                           }
[17:47:06.657]                         }
[17:47:06.657]                       }
[17:47:06.657]                       invisible(muffled)
[17:47:06.657]                     }
[17:47:06.657]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.657]                   }
[17:47:06.657]                 }
[17:47:06.657]                 else {
[17:47:06.657]                   if (TRUE) {
[17:47:06.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.657]                     {
[17:47:06.657]                       inherits <- base::inherits
[17:47:06.657]                       invokeRestart <- base::invokeRestart
[17:47:06.657]                       is.null <- base::is.null
[17:47:06.657]                       muffled <- FALSE
[17:47:06.657]                       if (inherits(cond, "message")) {
[17:47:06.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.657]                         if (muffled) 
[17:47:06.657]                           invokeRestart("muffleMessage")
[17:47:06.657]                       }
[17:47:06.657]                       else if (inherits(cond, "warning")) {
[17:47:06.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.657]                         if (muffled) 
[17:47:06.657]                           invokeRestart("muffleWarning")
[17:47:06.657]                       }
[17:47:06.657]                       else if (inherits(cond, "condition")) {
[17:47:06.657]                         if (!is.null(pattern)) {
[17:47:06.657]                           computeRestarts <- base::computeRestarts
[17:47:06.657]                           grepl <- base::grepl
[17:47:06.657]                           restarts <- computeRestarts(cond)
[17:47:06.657]                           for (restart in restarts) {
[17:47:06.657]                             name <- restart$name
[17:47:06.657]                             if (is.null(name)) 
[17:47:06.657]                               next
[17:47:06.657]                             if (!grepl(pattern, name)) 
[17:47:06.657]                               next
[17:47:06.657]                             invokeRestart(restart)
[17:47:06.657]                             muffled <- TRUE
[17:47:06.657]                             break
[17:47:06.657]                           }
[17:47:06.657]                         }
[17:47:06.657]                       }
[17:47:06.657]                       invisible(muffled)
[17:47:06.657]                     }
[17:47:06.657]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.657]                   }
[17:47:06.657]                 }
[17:47:06.657]             }
[17:47:06.657]         }))
[17:47:06.657]     }, error = function(ex) {
[17:47:06.657]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.657]                 ...future.rng), started = ...future.startTime, 
[17:47:06.657]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.657]             version = "1.8"), class = "FutureResult")
[17:47:06.657]     }, finally = {
[17:47:06.657]         if (!identical(...future.workdir, getwd())) 
[17:47:06.657]             setwd(...future.workdir)
[17:47:06.657]         {
[17:47:06.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.657]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.657]             }
[17:47:06.657]             base::options(...future.oldOptions)
[17:47:06.657]             if (.Platform$OS.type == "windows") {
[17:47:06.657]                 old_names <- names(...future.oldEnvVars)
[17:47:06.657]                 envs <- base::Sys.getenv()
[17:47:06.657]                 names <- names(envs)
[17:47:06.657]                 common <- intersect(names, old_names)
[17:47:06.657]                 added <- setdiff(names, old_names)
[17:47:06.657]                 removed <- setdiff(old_names, names)
[17:47:06.657]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.657]                   envs[common]]
[17:47:06.657]                 NAMES <- toupper(changed)
[17:47:06.657]                 args <- list()
[17:47:06.657]                 for (kk in seq_along(NAMES)) {
[17:47:06.657]                   name <- changed[[kk]]
[17:47:06.657]                   NAME <- NAMES[[kk]]
[17:47:06.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.657]                     next
[17:47:06.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.657]                 }
[17:47:06.657]                 NAMES <- toupper(added)
[17:47:06.657]                 for (kk in seq_along(NAMES)) {
[17:47:06.657]                   name <- added[[kk]]
[17:47:06.657]                   NAME <- NAMES[[kk]]
[17:47:06.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.657]                     next
[17:47:06.657]                   args[[name]] <- ""
[17:47:06.657]                 }
[17:47:06.657]                 NAMES <- toupper(removed)
[17:47:06.657]                 for (kk in seq_along(NAMES)) {
[17:47:06.657]                   name <- removed[[kk]]
[17:47:06.657]                   NAME <- NAMES[[kk]]
[17:47:06.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.657]                     next
[17:47:06.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.657]                 }
[17:47:06.657]                 if (length(args) > 0) 
[17:47:06.657]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.657]             }
[17:47:06.657]             else {
[17:47:06.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.657]             }
[17:47:06.657]             {
[17:47:06.657]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.657]                   0L) {
[17:47:06.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.657]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.657]                   base::options(opts)
[17:47:06.657]                 }
[17:47:06.657]                 {
[17:47:06.657]                   {
[17:47:06.657]                     NULL
[17:47:06.657]                     RNGkind("Mersenne-Twister")
[17:47:06.657]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.657]                       inherits = FALSE)
[17:47:06.657]                   }
[17:47:06.657]                   options(future.plan = NULL)
[17:47:06.657]                   if (is.na(NA_character_)) 
[17:47:06.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.657]                     .init = FALSE)
[17:47:06.657]                 }
[17:47:06.657]             }
[17:47:06.657]         }
[17:47:06.657]     })
[17:47:06.657]     if (TRUE) {
[17:47:06.657]         base::sink(type = "output", split = FALSE)
[17:47:06.657]         if (TRUE) {
[17:47:06.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.657]         }
[17:47:06.657]         else {
[17:47:06.657]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.657]         }
[17:47:06.657]         base::close(...future.stdout)
[17:47:06.657]         ...future.stdout <- NULL
[17:47:06.657]     }
[17:47:06.657]     ...future.result$conditions <- ...future.conditions
[17:47:06.657]     ...future.result$finished <- base::Sys.time()
[17:47:06.657]     ...future.result
[17:47:06.657] }
[17:47:06.658] assign_globals() ...
[17:47:06.658] List of 2
[17:47:06.658]  $ a : num 1
[17:47:06.658]  $ ii: int 2
[17:47:06.658]  - attr(*, "where")=List of 2
[17:47:06.658]   ..$ a :<environment: R_EmptyEnv> 
[17:47:06.658]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.658]  - attr(*, "resolved")= logi TRUE
[17:47:06.658]  - attr(*, "total_size")= num 112
[17:47:06.658]  - attr(*, "already-done")= logi TRUE
[17:47:06.661] - copied ‘a’ to environment
[17:47:06.661] - copied ‘ii’ to environment
[17:47:06.661] assign_globals() ... done
[17:47:06.662] plan(): Setting new future strategy stack:
[17:47:06.662] List of future strategies:
[17:47:06.662] 1. sequential:
[17:47:06.662]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.662]    - tweaked: FALSE
[17:47:06.662]    - call: NULL
[17:47:06.662] plan(): nbrOfWorkers() = 1
[17:47:06.663] plan(): Setting new future strategy stack:
[17:47:06.663] List of future strategies:
[17:47:06.663] 1. sequential:
[17:47:06.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.663]    - tweaked: FALSE
[17:47:06.663]    - call: plan(strategy)
[17:47:06.663] plan(): nbrOfWorkers() = 1
[17:47:06.664] SequentialFuture started (and completed)
[17:47:06.664] - Launch lazy future ... done
[17:47:06.664] run() for ‘SequentialFuture’ ... done
[17:47:06.664] run() for ‘Future’ ...
[17:47:06.664] - state: ‘created’
[17:47:06.664] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.664] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.665]   - Field: ‘label’
[17:47:06.665]   - Field: ‘local’
[17:47:06.665]   - Field: ‘owner’
[17:47:06.665]   - Field: ‘envir’
[17:47:06.665]   - Field: ‘packages’
[17:47:06.665]   - Field: ‘gc’
[17:47:06.665]   - Field: ‘conditions’
[17:47:06.665]   - Field: ‘expr’
[17:47:06.665]   - Field: ‘uuid’
[17:47:06.665]   - Field: ‘seed’
[17:47:06.665]   - Field: ‘version’
[17:47:06.666]   - Field: ‘result’
[17:47:06.666]   - Field: ‘asynchronous’
[17:47:06.666]   - Field: ‘calls’
[17:47:06.666]   - Field: ‘globals’
[17:47:06.666]   - Field: ‘stdout’
[17:47:06.666]   - Field: ‘earlySignal’
[17:47:06.666]   - Field: ‘lazy’
[17:47:06.666]   - Field: ‘state’
[17:47:06.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.666] - Launch lazy future ...
[17:47:06.666] Packages needed by the future expression (n = 0): <none>
[17:47:06.667] Packages needed by future strategies (n = 0): <none>
[17:47:06.667] {
[17:47:06.667]     {
[17:47:06.667]         {
[17:47:06.667]             ...future.startTime <- base::Sys.time()
[17:47:06.667]             {
[17:47:06.667]                 {
[17:47:06.667]                   {
[17:47:06.667]                     base::local({
[17:47:06.667]                       has_future <- base::requireNamespace("future", 
[17:47:06.667]                         quietly = TRUE)
[17:47:06.667]                       if (has_future) {
[17:47:06.667]                         ns <- base::getNamespace("future")
[17:47:06.667]                         version <- ns[[".package"]][["version"]]
[17:47:06.667]                         if (is.null(version)) 
[17:47:06.667]                           version <- utils::packageVersion("future")
[17:47:06.667]                       }
[17:47:06.667]                       else {
[17:47:06.667]                         version <- NULL
[17:47:06.667]                       }
[17:47:06.667]                       if (!has_future || version < "1.8.0") {
[17:47:06.667]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.667]                           "", base::R.version$version.string), 
[17:47:06.667]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.667]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.667]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.667]                             "release", "version")], collapse = " "), 
[17:47:06.667]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.667]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.667]                           info)
[17:47:06.667]                         info <- base::paste(info, collapse = "; ")
[17:47:06.667]                         if (!has_future) {
[17:47:06.667]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.667]                             info)
[17:47:06.667]                         }
[17:47:06.667]                         else {
[17:47:06.667]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.667]                             info, version)
[17:47:06.667]                         }
[17:47:06.667]                         base::stop(msg)
[17:47:06.667]                       }
[17:47:06.667]                     })
[17:47:06.667]                   }
[17:47:06.667]                   ...future.strategy.old <- future::plan("list")
[17:47:06.667]                   options(future.plan = NULL)
[17:47:06.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.667]                 }
[17:47:06.667]                 ...future.workdir <- getwd()
[17:47:06.667]             }
[17:47:06.667]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.667]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.667]         }
[17:47:06.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.667]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.667]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.667]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.667]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.667]             base::names(...future.oldOptions))
[17:47:06.667]     }
[17:47:06.667]     if (FALSE) {
[17:47:06.667]     }
[17:47:06.667]     else {
[17:47:06.667]         if (TRUE) {
[17:47:06.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.667]                 open = "w")
[17:47:06.667]         }
[17:47:06.667]         else {
[17:47:06.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.667]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.667]         }
[17:47:06.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.667]             base::sink(type = "output", split = FALSE)
[17:47:06.667]             base::close(...future.stdout)
[17:47:06.667]         }, add = TRUE)
[17:47:06.667]     }
[17:47:06.667]     ...future.frame <- base::sys.nframe()
[17:47:06.667]     ...future.conditions <- base::list()
[17:47:06.667]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.667]     if (FALSE) {
[17:47:06.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.667]     }
[17:47:06.667]     ...future.result <- base::tryCatch({
[17:47:06.667]         base::withCallingHandlers({
[17:47:06.667]             ...future.value <- base::withVisible(base::local({
[17:47:06.667]                 b <- a * ii
[17:47:06.667]                 a <- 0
[17:47:06.667]                 b
[17:47:06.667]             }))
[17:47:06.667]             future::FutureResult(value = ...future.value$value, 
[17:47:06.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.667]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.667]                     ...future.globalenv.names))
[17:47:06.667]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.667]         }, condition = base::local({
[17:47:06.667]             c <- base::c
[17:47:06.667]             inherits <- base::inherits
[17:47:06.667]             invokeRestart <- base::invokeRestart
[17:47:06.667]             length <- base::length
[17:47:06.667]             list <- base::list
[17:47:06.667]             seq.int <- base::seq.int
[17:47:06.667]             signalCondition <- base::signalCondition
[17:47:06.667]             sys.calls <- base::sys.calls
[17:47:06.667]             `[[` <- base::`[[`
[17:47:06.667]             `+` <- base::`+`
[17:47:06.667]             `<<-` <- base::`<<-`
[17:47:06.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.667]                   3L)]
[17:47:06.667]             }
[17:47:06.667]             function(cond) {
[17:47:06.667]                 is_error <- inherits(cond, "error")
[17:47:06.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.667]                   NULL)
[17:47:06.667]                 if (is_error) {
[17:47:06.667]                   sessionInformation <- function() {
[17:47:06.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.667]                       search = base::search(), system = base::Sys.info())
[17:47:06.667]                   }
[17:47:06.667]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.667]                     cond$call), session = sessionInformation(), 
[17:47:06.667]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.667]                   signalCondition(cond)
[17:47:06.667]                 }
[17:47:06.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.667]                 "immediateCondition"))) {
[17:47:06.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.667]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.667]                   if (TRUE && !signal) {
[17:47:06.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.667]                     {
[17:47:06.667]                       inherits <- base::inherits
[17:47:06.667]                       invokeRestart <- base::invokeRestart
[17:47:06.667]                       is.null <- base::is.null
[17:47:06.667]                       muffled <- FALSE
[17:47:06.667]                       if (inherits(cond, "message")) {
[17:47:06.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.667]                         if (muffled) 
[17:47:06.667]                           invokeRestart("muffleMessage")
[17:47:06.667]                       }
[17:47:06.667]                       else if (inherits(cond, "warning")) {
[17:47:06.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.667]                         if (muffled) 
[17:47:06.667]                           invokeRestart("muffleWarning")
[17:47:06.667]                       }
[17:47:06.667]                       else if (inherits(cond, "condition")) {
[17:47:06.667]                         if (!is.null(pattern)) {
[17:47:06.667]                           computeRestarts <- base::computeRestarts
[17:47:06.667]                           grepl <- base::grepl
[17:47:06.667]                           restarts <- computeRestarts(cond)
[17:47:06.667]                           for (restart in restarts) {
[17:47:06.667]                             name <- restart$name
[17:47:06.667]                             if (is.null(name)) 
[17:47:06.667]                               next
[17:47:06.667]                             if (!grepl(pattern, name)) 
[17:47:06.667]                               next
[17:47:06.667]                             invokeRestart(restart)
[17:47:06.667]                             muffled <- TRUE
[17:47:06.667]                             break
[17:47:06.667]                           }
[17:47:06.667]                         }
[17:47:06.667]                       }
[17:47:06.667]                       invisible(muffled)
[17:47:06.667]                     }
[17:47:06.667]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.667]                   }
[17:47:06.667]                 }
[17:47:06.667]                 else {
[17:47:06.667]                   if (TRUE) {
[17:47:06.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.667]                     {
[17:47:06.667]                       inherits <- base::inherits
[17:47:06.667]                       invokeRestart <- base::invokeRestart
[17:47:06.667]                       is.null <- base::is.null
[17:47:06.667]                       muffled <- FALSE
[17:47:06.667]                       if (inherits(cond, "message")) {
[17:47:06.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.667]                         if (muffled) 
[17:47:06.667]                           invokeRestart("muffleMessage")
[17:47:06.667]                       }
[17:47:06.667]                       else if (inherits(cond, "warning")) {
[17:47:06.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.667]                         if (muffled) 
[17:47:06.667]                           invokeRestart("muffleWarning")
[17:47:06.667]                       }
[17:47:06.667]                       else if (inherits(cond, "condition")) {
[17:47:06.667]                         if (!is.null(pattern)) {
[17:47:06.667]                           computeRestarts <- base::computeRestarts
[17:47:06.667]                           grepl <- base::grepl
[17:47:06.667]                           restarts <- computeRestarts(cond)
[17:47:06.667]                           for (restart in restarts) {
[17:47:06.667]                             name <- restart$name
[17:47:06.667]                             if (is.null(name)) 
[17:47:06.667]                               next
[17:47:06.667]                             if (!grepl(pattern, name)) 
[17:47:06.667]                               next
[17:47:06.667]                             invokeRestart(restart)
[17:47:06.667]                             muffled <- TRUE
[17:47:06.667]                             break
[17:47:06.667]                           }
[17:47:06.667]                         }
[17:47:06.667]                       }
[17:47:06.667]                       invisible(muffled)
[17:47:06.667]                     }
[17:47:06.667]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.667]                   }
[17:47:06.667]                 }
[17:47:06.667]             }
[17:47:06.667]         }))
[17:47:06.667]     }, error = function(ex) {
[17:47:06.667]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.667]                 ...future.rng), started = ...future.startTime, 
[17:47:06.667]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.667]             version = "1.8"), class = "FutureResult")
[17:47:06.667]     }, finally = {
[17:47:06.667]         if (!identical(...future.workdir, getwd())) 
[17:47:06.667]             setwd(...future.workdir)
[17:47:06.667]         {
[17:47:06.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.667]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.667]             }
[17:47:06.667]             base::options(...future.oldOptions)
[17:47:06.667]             if (.Platform$OS.type == "windows") {
[17:47:06.667]                 old_names <- names(...future.oldEnvVars)
[17:47:06.667]                 envs <- base::Sys.getenv()
[17:47:06.667]                 names <- names(envs)
[17:47:06.667]                 common <- intersect(names, old_names)
[17:47:06.667]                 added <- setdiff(names, old_names)
[17:47:06.667]                 removed <- setdiff(old_names, names)
[17:47:06.667]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.667]                   envs[common]]
[17:47:06.667]                 NAMES <- toupper(changed)
[17:47:06.667]                 args <- list()
[17:47:06.667]                 for (kk in seq_along(NAMES)) {
[17:47:06.667]                   name <- changed[[kk]]
[17:47:06.667]                   NAME <- NAMES[[kk]]
[17:47:06.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.667]                     next
[17:47:06.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.667]                 }
[17:47:06.667]                 NAMES <- toupper(added)
[17:47:06.667]                 for (kk in seq_along(NAMES)) {
[17:47:06.667]                   name <- added[[kk]]
[17:47:06.667]                   NAME <- NAMES[[kk]]
[17:47:06.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.667]                     next
[17:47:06.667]                   args[[name]] <- ""
[17:47:06.667]                 }
[17:47:06.667]                 NAMES <- toupper(removed)
[17:47:06.667]                 for (kk in seq_along(NAMES)) {
[17:47:06.667]                   name <- removed[[kk]]
[17:47:06.667]                   NAME <- NAMES[[kk]]
[17:47:06.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.667]                     next
[17:47:06.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.667]                 }
[17:47:06.667]                 if (length(args) > 0) 
[17:47:06.667]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.667]             }
[17:47:06.667]             else {
[17:47:06.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.667]             }
[17:47:06.667]             {
[17:47:06.667]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.667]                   0L) {
[17:47:06.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.667]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.667]                   base::options(opts)
[17:47:06.667]                 }
[17:47:06.667]                 {
[17:47:06.667]                   {
[17:47:06.667]                     NULL
[17:47:06.667]                     RNGkind("Mersenne-Twister")
[17:47:06.667]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.667]                       inherits = FALSE)
[17:47:06.667]                   }
[17:47:06.667]                   options(future.plan = NULL)
[17:47:06.667]                   if (is.na(NA_character_)) 
[17:47:06.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.667]                     .init = FALSE)
[17:47:06.667]                 }
[17:47:06.667]             }
[17:47:06.667]         }
[17:47:06.667]     })
[17:47:06.667]     if (TRUE) {
[17:47:06.667]         base::sink(type = "output", split = FALSE)
[17:47:06.667]         if (TRUE) {
[17:47:06.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.667]         }
[17:47:06.667]         else {
[17:47:06.667]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.667]         }
[17:47:06.667]         base::close(...future.stdout)
[17:47:06.667]         ...future.stdout <- NULL
[17:47:06.667]     }
[17:47:06.667]     ...future.result$conditions <- ...future.conditions
[17:47:06.667]     ...future.result$finished <- base::Sys.time()
[17:47:06.667]     ...future.result
[17:47:06.667] }
[17:47:06.669] assign_globals() ...
[17:47:06.669] List of 2
[17:47:06.669]  $ a : num 1
[17:47:06.669]  $ ii: int 3
[17:47:06.669]  - attr(*, "where")=List of 2
[17:47:06.669]   ..$ a :<environment: R_EmptyEnv> 
[17:47:06.669]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.669]  - attr(*, "resolved")= logi TRUE
[17:47:06.669]  - attr(*, "total_size")= num 112
[17:47:06.669]  - attr(*, "already-done")= logi TRUE
[17:47:06.671] - copied ‘a’ to environment
[17:47:06.672] - copied ‘ii’ to environment
[17:47:06.672] assign_globals() ... done
[17:47:06.672] plan(): Setting new future strategy stack:
[17:47:06.672] List of future strategies:
[17:47:06.672] 1. sequential:
[17:47:06.672]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.672]    - tweaked: FALSE
[17:47:06.672]    - call: NULL
[17:47:06.672] plan(): nbrOfWorkers() = 1
[17:47:06.673] plan(): Setting new future strategy stack:
[17:47:06.673] List of future strategies:
[17:47:06.673] 1. sequential:
[17:47:06.673]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.673]    - tweaked: FALSE
[17:47:06.673]    - call: plan(strategy)
[17:47:06.674] plan(): nbrOfWorkers() = 1
[17:47:06.674] SequentialFuture started (and completed)
[17:47:06.674] - Launch lazy future ... done
[17:47:06.674] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.674] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.674] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.675] 
[17:47:06.675] Searching for globals ... DONE
[17:47:06.675] - globals: [0] <none>
[17:47:06.675] getGlobalsAndPackages() ... DONE
[17:47:06.675] run() for ‘Future’ ...
[17:47:06.675] - state: ‘created’
[17:47:06.676] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.676] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.676]   - Field: ‘label’
[17:47:06.676]   - Field: ‘local’
[17:47:06.676]   - Field: ‘owner’
[17:47:06.676]   - Field: ‘envir’
[17:47:06.676]   - Field: ‘packages’
[17:47:06.676]   - Field: ‘gc’
[17:47:06.676]   - Field: ‘conditions’
[17:47:06.677]   - Field: ‘expr’
[17:47:06.677]   - Field: ‘uuid’
[17:47:06.677]   - Field: ‘seed’
[17:47:06.677]   - Field: ‘version’
[17:47:06.677]   - Field: ‘result’
[17:47:06.677]   - Field: ‘asynchronous’
[17:47:06.677]   - Field: ‘calls’
[17:47:06.677]   - Field: ‘globals’
[17:47:06.677]   - Field: ‘stdout’
[17:47:06.677]   - Field: ‘earlySignal’
[17:47:06.677]   - Field: ‘lazy’
[17:47:06.678]   - Field: ‘state’
[17:47:06.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.678] - Launch lazy future ...
[17:47:06.678] Packages needed by the future expression (n = 0): <none>
[17:47:06.678] Packages needed by future strategies (n = 0): <none>
[17:47:06.678] {
[17:47:06.678]     {
[17:47:06.678]         {
[17:47:06.678]             ...future.startTime <- base::Sys.time()
[17:47:06.678]             {
[17:47:06.678]                 {
[17:47:06.678]                   {
[17:47:06.678]                     base::local({
[17:47:06.678]                       has_future <- base::requireNamespace("future", 
[17:47:06.678]                         quietly = TRUE)
[17:47:06.678]                       if (has_future) {
[17:47:06.678]                         ns <- base::getNamespace("future")
[17:47:06.678]                         version <- ns[[".package"]][["version"]]
[17:47:06.678]                         if (is.null(version)) 
[17:47:06.678]                           version <- utils::packageVersion("future")
[17:47:06.678]                       }
[17:47:06.678]                       else {
[17:47:06.678]                         version <- NULL
[17:47:06.678]                       }
[17:47:06.678]                       if (!has_future || version < "1.8.0") {
[17:47:06.678]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.678]                           "", base::R.version$version.string), 
[17:47:06.678]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.678]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.678]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.678]                             "release", "version")], collapse = " "), 
[17:47:06.678]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.678]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.678]                           info)
[17:47:06.678]                         info <- base::paste(info, collapse = "; ")
[17:47:06.678]                         if (!has_future) {
[17:47:06.678]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.678]                             info)
[17:47:06.678]                         }
[17:47:06.678]                         else {
[17:47:06.678]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.678]                             info, version)
[17:47:06.678]                         }
[17:47:06.678]                         base::stop(msg)
[17:47:06.678]                       }
[17:47:06.678]                     })
[17:47:06.678]                   }
[17:47:06.678]                   ...future.strategy.old <- future::plan("list")
[17:47:06.678]                   options(future.plan = NULL)
[17:47:06.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.678]                 }
[17:47:06.678]                 ...future.workdir <- getwd()
[17:47:06.678]             }
[17:47:06.678]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.678]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.678]         }
[17:47:06.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.678]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.678]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.678]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.678]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.678]             base::names(...future.oldOptions))
[17:47:06.678]     }
[17:47:06.678]     if (FALSE) {
[17:47:06.678]     }
[17:47:06.678]     else {
[17:47:06.678]         if (TRUE) {
[17:47:06.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.678]                 open = "w")
[17:47:06.678]         }
[17:47:06.678]         else {
[17:47:06.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.678]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.678]         }
[17:47:06.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.678]             base::sink(type = "output", split = FALSE)
[17:47:06.678]             base::close(...future.stdout)
[17:47:06.678]         }, add = TRUE)
[17:47:06.678]     }
[17:47:06.678]     ...future.frame <- base::sys.nframe()
[17:47:06.678]     ...future.conditions <- base::list()
[17:47:06.678]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.678]     if (FALSE) {
[17:47:06.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.678]     }
[17:47:06.678]     ...future.result <- base::tryCatch({
[17:47:06.678]         base::withCallingHandlers({
[17:47:06.678]             ...future.value <- base::withVisible(base::local(1))
[17:47:06.678]             future::FutureResult(value = ...future.value$value, 
[17:47:06.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.678]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.678]                     ...future.globalenv.names))
[17:47:06.678]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.678]         }, condition = base::local({
[17:47:06.678]             c <- base::c
[17:47:06.678]             inherits <- base::inherits
[17:47:06.678]             invokeRestart <- base::invokeRestart
[17:47:06.678]             length <- base::length
[17:47:06.678]             list <- base::list
[17:47:06.678]             seq.int <- base::seq.int
[17:47:06.678]             signalCondition <- base::signalCondition
[17:47:06.678]             sys.calls <- base::sys.calls
[17:47:06.678]             `[[` <- base::`[[`
[17:47:06.678]             `+` <- base::`+`
[17:47:06.678]             `<<-` <- base::`<<-`
[17:47:06.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.678]                   3L)]
[17:47:06.678]             }
[17:47:06.678]             function(cond) {
[17:47:06.678]                 is_error <- inherits(cond, "error")
[17:47:06.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.678]                   NULL)
[17:47:06.678]                 if (is_error) {
[17:47:06.678]                   sessionInformation <- function() {
[17:47:06.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.678]                       search = base::search(), system = base::Sys.info())
[17:47:06.678]                   }
[17:47:06.678]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.678]                     cond$call), session = sessionInformation(), 
[17:47:06.678]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.678]                   signalCondition(cond)
[17:47:06.678]                 }
[17:47:06.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.678]                 "immediateCondition"))) {
[17:47:06.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.678]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.678]                   if (TRUE && !signal) {
[17:47:06.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.678]                     {
[17:47:06.678]                       inherits <- base::inherits
[17:47:06.678]                       invokeRestart <- base::invokeRestart
[17:47:06.678]                       is.null <- base::is.null
[17:47:06.678]                       muffled <- FALSE
[17:47:06.678]                       if (inherits(cond, "message")) {
[17:47:06.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.678]                         if (muffled) 
[17:47:06.678]                           invokeRestart("muffleMessage")
[17:47:06.678]                       }
[17:47:06.678]                       else if (inherits(cond, "warning")) {
[17:47:06.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.678]                         if (muffled) 
[17:47:06.678]                           invokeRestart("muffleWarning")
[17:47:06.678]                       }
[17:47:06.678]                       else if (inherits(cond, "condition")) {
[17:47:06.678]                         if (!is.null(pattern)) {
[17:47:06.678]                           computeRestarts <- base::computeRestarts
[17:47:06.678]                           grepl <- base::grepl
[17:47:06.678]                           restarts <- computeRestarts(cond)
[17:47:06.678]                           for (restart in restarts) {
[17:47:06.678]                             name <- restart$name
[17:47:06.678]                             if (is.null(name)) 
[17:47:06.678]                               next
[17:47:06.678]                             if (!grepl(pattern, name)) 
[17:47:06.678]                               next
[17:47:06.678]                             invokeRestart(restart)
[17:47:06.678]                             muffled <- TRUE
[17:47:06.678]                             break
[17:47:06.678]                           }
[17:47:06.678]                         }
[17:47:06.678]                       }
[17:47:06.678]                       invisible(muffled)
[17:47:06.678]                     }
[17:47:06.678]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.678]                   }
[17:47:06.678]                 }
[17:47:06.678]                 else {
[17:47:06.678]                   if (TRUE) {
[17:47:06.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.678]                     {
[17:47:06.678]                       inherits <- base::inherits
[17:47:06.678]                       invokeRestart <- base::invokeRestart
[17:47:06.678]                       is.null <- base::is.null
[17:47:06.678]                       muffled <- FALSE
[17:47:06.678]                       if (inherits(cond, "message")) {
[17:47:06.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.678]                         if (muffled) 
[17:47:06.678]                           invokeRestart("muffleMessage")
[17:47:06.678]                       }
[17:47:06.678]                       else if (inherits(cond, "warning")) {
[17:47:06.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.678]                         if (muffled) 
[17:47:06.678]                           invokeRestart("muffleWarning")
[17:47:06.678]                       }
[17:47:06.678]                       else if (inherits(cond, "condition")) {
[17:47:06.678]                         if (!is.null(pattern)) {
[17:47:06.678]                           computeRestarts <- base::computeRestarts
[17:47:06.678]                           grepl <- base::grepl
[17:47:06.678]                           restarts <- computeRestarts(cond)
[17:47:06.678]                           for (restart in restarts) {
[17:47:06.678]                             name <- restart$name
[17:47:06.678]                             if (is.null(name)) 
[17:47:06.678]                               next
[17:47:06.678]                             if (!grepl(pattern, name)) 
[17:47:06.678]                               next
[17:47:06.678]                             invokeRestart(restart)
[17:47:06.678]                             muffled <- TRUE
[17:47:06.678]                             break
[17:47:06.678]                           }
[17:47:06.678]                         }
[17:47:06.678]                       }
[17:47:06.678]                       invisible(muffled)
[17:47:06.678]                     }
[17:47:06.678]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.678]                   }
[17:47:06.678]                 }
[17:47:06.678]             }
[17:47:06.678]         }))
[17:47:06.678]     }, error = function(ex) {
[17:47:06.678]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.678]                 ...future.rng), started = ...future.startTime, 
[17:47:06.678]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.678]             version = "1.8"), class = "FutureResult")
[17:47:06.678]     }, finally = {
[17:47:06.678]         if (!identical(...future.workdir, getwd())) 
[17:47:06.678]             setwd(...future.workdir)
[17:47:06.678]         {
[17:47:06.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.678]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.678]             }
[17:47:06.678]             base::options(...future.oldOptions)
[17:47:06.678]             if (.Platform$OS.type == "windows") {
[17:47:06.678]                 old_names <- names(...future.oldEnvVars)
[17:47:06.678]                 envs <- base::Sys.getenv()
[17:47:06.678]                 names <- names(envs)
[17:47:06.678]                 common <- intersect(names, old_names)
[17:47:06.678]                 added <- setdiff(names, old_names)
[17:47:06.678]                 removed <- setdiff(old_names, names)
[17:47:06.678]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.678]                   envs[common]]
[17:47:06.678]                 NAMES <- toupper(changed)
[17:47:06.678]                 args <- list()
[17:47:06.678]                 for (kk in seq_along(NAMES)) {
[17:47:06.678]                   name <- changed[[kk]]
[17:47:06.678]                   NAME <- NAMES[[kk]]
[17:47:06.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.678]                     next
[17:47:06.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.678]                 }
[17:47:06.678]                 NAMES <- toupper(added)
[17:47:06.678]                 for (kk in seq_along(NAMES)) {
[17:47:06.678]                   name <- added[[kk]]
[17:47:06.678]                   NAME <- NAMES[[kk]]
[17:47:06.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.678]                     next
[17:47:06.678]                   args[[name]] <- ""
[17:47:06.678]                 }
[17:47:06.678]                 NAMES <- toupper(removed)
[17:47:06.678]                 for (kk in seq_along(NAMES)) {
[17:47:06.678]                   name <- removed[[kk]]
[17:47:06.678]                   NAME <- NAMES[[kk]]
[17:47:06.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.678]                     next
[17:47:06.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.678]                 }
[17:47:06.678]                 if (length(args) > 0) 
[17:47:06.678]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.678]             }
[17:47:06.678]             else {
[17:47:06.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.678]             }
[17:47:06.678]             {
[17:47:06.678]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.678]                   0L) {
[17:47:06.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.678]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.678]                   base::options(opts)
[17:47:06.678]                 }
[17:47:06.678]                 {
[17:47:06.678]                   {
[17:47:06.678]                     NULL
[17:47:06.678]                     RNGkind("Mersenne-Twister")
[17:47:06.678]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.678]                       inherits = FALSE)
[17:47:06.678]                   }
[17:47:06.678]                   options(future.plan = NULL)
[17:47:06.678]                   if (is.na(NA_character_)) 
[17:47:06.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.678]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.678]                     .init = FALSE)
[17:47:06.678]                 }
[17:47:06.678]             }
[17:47:06.678]         }
[17:47:06.678]     })
[17:47:06.678]     if (TRUE) {
[17:47:06.678]         base::sink(type = "output", split = FALSE)
[17:47:06.678]         if (TRUE) {
[17:47:06.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.678]         }
[17:47:06.678]         else {
[17:47:06.678]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.678]         }
[17:47:06.678]         base::close(...future.stdout)
[17:47:06.678]         ...future.stdout <- NULL
[17:47:06.678]     }
[17:47:06.678]     ...future.result$conditions <- ...future.conditions
[17:47:06.678]     ...future.result$finished <- base::Sys.time()
[17:47:06.678]     ...future.result
[17:47:06.678] }
[17:47:06.680] plan(): Setting new future strategy stack:
[17:47:06.680] List of future strategies:
[17:47:06.680] 1. sequential:
[17:47:06.680]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.680]    - tweaked: FALSE
[17:47:06.680]    - call: NULL
[17:47:06.681] plan(): nbrOfWorkers() = 1
[17:47:06.681] plan(): Setting new future strategy stack:
[17:47:06.681] List of future strategies:
[17:47:06.681] 1. sequential:
[17:47:06.681]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.681]    - tweaked: FALSE
[17:47:06.681]    - call: plan(strategy)
[17:47:06.682] plan(): nbrOfWorkers() = 1
[17:47:06.682] SequentialFuture started (and completed)
[17:47:06.682] - Launch lazy future ... done
[17:47:06.682] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.682] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.682] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.685] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:06.685] Searching for globals ... DONE
[17:47:06.685] Resolving globals: TRUE
[17:47:06.685] Resolving any globals that are futures ...
[17:47:06.685] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:06.685] Resolving any globals that are futures ... DONE
[17:47:06.686] Resolving futures part of globals (recursively) ...
[17:47:06.686] resolve() on list ...
[17:47:06.686]  recursive: 99
[17:47:06.686]  length: 1
[17:47:06.686]  elements: ‘a’
[17:47:06.686] resolved() for ‘SequentialFuture’ ...
[17:47:06.686] - state: ‘finished’
[17:47:06.686] - run: TRUE
[17:47:06.686] - result: ‘FutureResult’
[17:47:06.687] resolved() for ‘SequentialFuture’ ... done
[17:47:06.687] Future #1
[17:47:06.687] resolved() for ‘SequentialFuture’ ...
[17:47:06.687] - state: ‘finished’
[17:47:06.687] - run: TRUE
[17:47:06.687] - result: ‘FutureResult’
[17:47:06.687] resolved() for ‘SequentialFuture’ ... done
[17:47:06.687] A SequentialFuture was resolved
[17:47:06.687]  length: 0 (resolved future 1)
[17:47:06.687] resolve() on list ... DONE
[17:47:06.688] - globals: [1] ‘a’
[17:47:06.688] Resolving futures part of globals (recursively) ... DONE
[17:47:06.689] The total size of the 1 globals is 1.55 MiB (1622272 bytes)
[17:47:06.690] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:47:06.690] - globals: [1] ‘a’
[17:47:06.690] - packages: [1] ‘future’
[17:47:06.690] getGlobalsAndPackages() ... DONE
[17:47:06.690] run() for ‘Future’ ...
[17:47:06.690] - state: ‘created’
[17:47:06.691] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.691] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.691]   - Field: ‘label’
[17:47:06.691]   - Field: ‘local’
[17:47:06.691]   - Field: ‘owner’
[17:47:06.691]   - Field: ‘envir’
[17:47:06.691]   - Field: ‘packages’
[17:47:06.691]   - Field: ‘gc’
[17:47:06.692]   - Field: ‘conditions’
[17:47:06.692]   - Field: ‘expr’
[17:47:06.692]   - Field: ‘uuid’
[17:47:06.692]   - Field: ‘seed’
[17:47:06.692]   - Field: ‘version’
[17:47:06.692]   - Field: ‘result’
[17:47:06.692]   - Field: ‘asynchronous’
[17:47:06.692]   - Field: ‘calls’
[17:47:06.692]   - Field: ‘globals’
[17:47:06.692]   - Field: ‘stdout’
[17:47:06.692]   - Field: ‘earlySignal’
[17:47:06.692]   - Field: ‘lazy’
[17:47:06.693]   - Field: ‘state’
[17:47:06.693] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.693] - Launch lazy future ...
[17:47:06.693] Packages needed by the future expression (n = 1): ‘future’
[17:47:06.693] Packages needed by future strategies (n = 0): <none>
[17:47:06.693] {
[17:47:06.693]     {
[17:47:06.693]         {
[17:47:06.693]             ...future.startTime <- base::Sys.time()
[17:47:06.693]             {
[17:47:06.693]                 {
[17:47:06.693]                   {
[17:47:06.693]                     {
[17:47:06.693]                       base::local({
[17:47:06.693]                         has_future <- base::requireNamespace("future", 
[17:47:06.693]                           quietly = TRUE)
[17:47:06.693]                         if (has_future) {
[17:47:06.693]                           ns <- base::getNamespace("future")
[17:47:06.693]                           version <- ns[[".package"]][["version"]]
[17:47:06.693]                           if (is.null(version)) 
[17:47:06.693]                             version <- utils::packageVersion("future")
[17:47:06.693]                         }
[17:47:06.693]                         else {
[17:47:06.693]                           version <- NULL
[17:47:06.693]                         }
[17:47:06.693]                         if (!has_future || version < "1.8.0") {
[17:47:06.693]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.693]                             "", base::R.version$version.string), 
[17:47:06.693]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.693]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.693]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.693]                               "release", "version")], collapse = " "), 
[17:47:06.693]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.693]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.693]                             info)
[17:47:06.693]                           info <- base::paste(info, collapse = "; ")
[17:47:06.693]                           if (!has_future) {
[17:47:06.693]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.693]                               info)
[17:47:06.693]                           }
[17:47:06.693]                           else {
[17:47:06.693]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.693]                               info, version)
[17:47:06.693]                           }
[17:47:06.693]                           base::stop(msg)
[17:47:06.693]                         }
[17:47:06.693]                       })
[17:47:06.693]                     }
[17:47:06.693]                     base::local({
[17:47:06.693]                       for (pkg in "future") {
[17:47:06.693]                         base::loadNamespace(pkg)
[17:47:06.693]                         base::library(pkg, character.only = TRUE)
[17:47:06.693]                       }
[17:47:06.693]                     })
[17:47:06.693]                   }
[17:47:06.693]                   ...future.strategy.old <- future::plan("list")
[17:47:06.693]                   options(future.plan = NULL)
[17:47:06.693]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.693]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.693]                 }
[17:47:06.693]                 ...future.workdir <- getwd()
[17:47:06.693]             }
[17:47:06.693]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.693]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.693]         }
[17:47:06.693]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.693]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.693]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.693]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.693]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.693]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.693]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.693]             base::names(...future.oldOptions))
[17:47:06.693]     }
[17:47:06.693]     if (FALSE) {
[17:47:06.693]     }
[17:47:06.693]     else {
[17:47:06.693]         if (TRUE) {
[17:47:06.693]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.693]                 open = "w")
[17:47:06.693]         }
[17:47:06.693]         else {
[17:47:06.693]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.693]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.693]         }
[17:47:06.693]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.693]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.693]             base::sink(type = "output", split = FALSE)
[17:47:06.693]             base::close(...future.stdout)
[17:47:06.693]         }, add = TRUE)
[17:47:06.693]     }
[17:47:06.693]     ...future.frame <- base::sys.nframe()
[17:47:06.693]     ...future.conditions <- base::list()
[17:47:06.693]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.693]     if (FALSE) {
[17:47:06.693]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.693]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.693]     }
[17:47:06.693]     ...future.result <- base::tryCatch({
[17:47:06.693]         base::withCallingHandlers({
[17:47:06.693]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:47:06.693]                 1))
[17:47:06.693]             future::FutureResult(value = ...future.value$value, 
[17:47:06.693]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.693]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.693]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.693]                     ...future.globalenv.names))
[17:47:06.693]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.693]         }, condition = base::local({
[17:47:06.693]             c <- base::c
[17:47:06.693]             inherits <- base::inherits
[17:47:06.693]             invokeRestart <- base::invokeRestart
[17:47:06.693]             length <- base::length
[17:47:06.693]             list <- base::list
[17:47:06.693]             seq.int <- base::seq.int
[17:47:06.693]             signalCondition <- base::signalCondition
[17:47:06.693]             sys.calls <- base::sys.calls
[17:47:06.693]             `[[` <- base::`[[`
[17:47:06.693]             `+` <- base::`+`
[17:47:06.693]             `<<-` <- base::`<<-`
[17:47:06.693]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.693]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.693]                   3L)]
[17:47:06.693]             }
[17:47:06.693]             function(cond) {
[17:47:06.693]                 is_error <- inherits(cond, "error")
[17:47:06.693]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.693]                   NULL)
[17:47:06.693]                 if (is_error) {
[17:47:06.693]                   sessionInformation <- function() {
[17:47:06.693]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.693]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.693]                       search = base::search(), system = base::Sys.info())
[17:47:06.693]                   }
[17:47:06.693]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.693]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.693]                     cond$call), session = sessionInformation(), 
[17:47:06.693]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.693]                   signalCondition(cond)
[17:47:06.693]                 }
[17:47:06.693]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.693]                 "immediateCondition"))) {
[17:47:06.693]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.693]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.693]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.693]                   if (TRUE && !signal) {
[17:47:06.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.693]                     {
[17:47:06.693]                       inherits <- base::inherits
[17:47:06.693]                       invokeRestart <- base::invokeRestart
[17:47:06.693]                       is.null <- base::is.null
[17:47:06.693]                       muffled <- FALSE
[17:47:06.693]                       if (inherits(cond, "message")) {
[17:47:06.693]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.693]                         if (muffled) 
[17:47:06.693]                           invokeRestart("muffleMessage")
[17:47:06.693]                       }
[17:47:06.693]                       else if (inherits(cond, "warning")) {
[17:47:06.693]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.693]                         if (muffled) 
[17:47:06.693]                           invokeRestart("muffleWarning")
[17:47:06.693]                       }
[17:47:06.693]                       else if (inherits(cond, "condition")) {
[17:47:06.693]                         if (!is.null(pattern)) {
[17:47:06.693]                           computeRestarts <- base::computeRestarts
[17:47:06.693]                           grepl <- base::grepl
[17:47:06.693]                           restarts <- computeRestarts(cond)
[17:47:06.693]                           for (restart in restarts) {
[17:47:06.693]                             name <- restart$name
[17:47:06.693]                             if (is.null(name)) 
[17:47:06.693]                               next
[17:47:06.693]                             if (!grepl(pattern, name)) 
[17:47:06.693]                               next
[17:47:06.693]                             invokeRestart(restart)
[17:47:06.693]                             muffled <- TRUE
[17:47:06.693]                             break
[17:47:06.693]                           }
[17:47:06.693]                         }
[17:47:06.693]                       }
[17:47:06.693]                       invisible(muffled)
[17:47:06.693]                     }
[17:47:06.693]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.693]                   }
[17:47:06.693]                 }
[17:47:06.693]                 else {
[17:47:06.693]                   if (TRUE) {
[17:47:06.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.693]                     {
[17:47:06.693]                       inherits <- base::inherits
[17:47:06.693]                       invokeRestart <- base::invokeRestart
[17:47:06.693]                       is.null <- base::is.null
[17:47:06.693]                       muffled <- FALSE
[17:47:06.693]                       if (inherits(cond, "message")) {
[17:47:06.693]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.693]                         if (muffled) 
[17:47:06.693]                           invokeRestart("muffleMessage")
[17:47:06.693]                       }
[17:47:06.693]                       else if (inherits(cond, "warning")) {
[17:47:06.693]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.693]                         if (muffled) 
[17:47:06.693]                           invokeRestart("muffleWarning")
[17:47:06.693]                       }
[17:47:06.693]                       else if (inherits(cond, "condition")) {
[17:47:06.693]                         if (!is.null(pattern)) {
[17:47:06.693]                           computeRestarts <- base::computeRestarts
[17:47:06.693]                           grepl <- base::grepl
[17:47:06.693]                           restarts <- computeRestarts(cond)
[17:47:06.693]                           for (restart in restarts) {
[17:47:06.693]                             name <- restart$name
[17:47:06.693]                             if (is.null(name)) 
[17:47:06.693]                               next
[17:47:06.693]                             if (!grepl(pattern, name)) 
[17:47:06.693]                               next
[17:47:06.693]                             invokeRestart(restart)
[17:47:06.693]                             muffled <- TRUE
[17:47:06.693]                             break
[17:47:06.693]                           }
[17:47:06.693]                         }
[17:47:06.693]                       }
[17:47:06.693]                       invisible(muffled)
[17:47:06.693]                     }
[17:47:06.693]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.693]                   }
[17:47:06.693]                 }
[17:47:06.693]             }
[17:47:06.693]         }))
[17:47:06.693]     }, error = function(ex) {
[17:47:06.693]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.693]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.693]                 ...future.rng), started = ...future.startTime, 
[17:47:06.693]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.693]             version = "1.8"), class = "FutureResult")
[17:47:06.693]     }, finally = {
[17:47:06.693]         if (!identical(...future.workdir, getwd())) 
[17:47:06.693]             setwd(...future.workdir)
[17:47:06.693]         {
[17:47:06.693]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.693]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.693]             }
[17:47:06.693]             base::options(...future.oldOptions)
[17:47:06.693]             if (.Platform$OS.type == "windows") {
[17:47:06.693]                 old_names <- names(...future.oldEnvVars)
[17:47:06.693]                 envs <- base::Sys.getenv()
[17:47:06.693]                 names <- names(envs)
[17:47:06.693]                 common <- intersect(names, old_names)
[17:47:06.693]                 added <- setdiff(names, old_names)
[17:47:06.693]                 removed <- setdiff(old_names, names)
[17:47:06.693]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.693]                   envs[common]]
[17:47:06.693]                 NAMES <- toupper(changed)
[17:47:06.693]                 args <- list()
[17:47:06.693]                 for (kk in seq_along(NAMES)) {
[17:47:06.693]                   name <- changed[[kk]]
[17:47:06.693]                   NAME <- NAMES[[kk]]
[17:47:06.693]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.693]                     next
[17:47:06.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.693]                 }
[17:47:06.693]                 NAMES <- toupper(added)
[17:47:06.693]                 for (kk in seq_along(NAMES)) {
[17:47:06.693]                   name <- added[[kk]]
[17:47:06.693]                   NAME <- NAMES[[kk]]
[17:47:06.693]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.693]                     next
[17:47:06.693]                   args[[name]] <- ""
[17:47:06.693]                 }
[17:47:06.693]                 NAMES <- toupper(removed)
[17:47:06.693]                 for (kk in seq_along(NAMES)) {
[17:47:06.693]                   name <- removed[[kk]]
[17:47:06.693]                   NAME <- NAMES[[kk]]
[17:47:06.693]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.693]                     next
[17:47:06.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.693]                 }
[17:47:06.693]                 if (length(args) > 0) 
[17:47:06.693]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.693]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.693]             }
[17:47:06.693]             else {
[17:47:06.693]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.693]             }
[17:47:06.693]             {
[17:47:06.693]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.693]                   0L) {
[17:47:06.693]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.693]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.693]                   base::options(opts)
[17:47:06.693]                 }
[17:47:06.693]                 {
[17:47:06.693]                   {
[17:47:06.693]                     NULL
[17:47:06.693]                     RNGkind("Mersenne-Twister")
[17:47:06.693]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.693]                       inherits = FALSE)
[17:47:06.693]                   }
[17:47:06.693]                   options(future.plan = NULL)
[17:47:06.693]                   if (is.na(NA_character_)) 
[17:47:06.693]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.693]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.693]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.693]                     .init = FALSE)
[17:47:06.693]                 }
[17:47:06.693]             }
[17:47:06.693]         }
[17:47:06.693]     })
[17:47:06.693]     if (TRUE) {
[17:47:06.693]         base::sink(type = "output", split = FALSE)
[17:47:06.693]         if (TRUE) {
[17:47:06.693]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.693]         }
[17:47:06.693]         else {
[17:47:06.693]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.693]         }
[17:47:06.693]         base::close(...future.stdout)
[17:47:06.693]         ...future.stdout <- NULL
[17:47:06.693]     }
[17:47:06.693]     ...future.result$conditions <- ...future.conditions
[17:47:06.693]     ...future.result$finished <- base::Sys.time()
[17:47:06.693]     ...future.result
[17:47:06.693] }
[17:47:06.695] assign_globals() ...
[17:47:06.695] List of 1
[17:47:06.695]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558b32759940> 
[17:47:06.695]  - attr(*, "where")=List of 1
[17:47:06.695]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.695]  - attr(*, "resolved")= logi TRUE
[17:47:06.695]  - attr(*, "total_size")= num 1622272
[17:47:06.695]  - attr(*, "already-done")= logi TRUE
[17:47:06.697] - copied ‘a’ to environment
[17:47:06.697] assign_globals() ... done
[17:47:06.698] plan(): Setting new future strategy stack:
[17:47:06.698] List of future strategies:
[17:47:06.698] 1. sequential:
[17:47:06.698]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.698]    - tweaked: FALSE
[17:47:06.698]    - call: NULL
[17:47:06.698] plan(): nbrOfWorkers() = 1
[17:47:06.699] plan(): Setting new future strategy stack:
[17:47:06.699] List of future strategies:
[17:47:06.699] 1. sequential:
[17:47:06.699]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.699]    - tweaked: FALSE
[17:47:06.699]    - call: plan(strategy)
[17:47:06.700] plan(): nbrOfWorkers() = 1
[17:47:06.700] SequentialFuture started (and completed)
[17:47:06.700] - Launch lazy future ... done
[17:47:06.700] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.700] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.700] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.701] 
[17:47:06.701] Searching for globals ... DONE
[17:47:06.701] - globals: [0] <none>
[17:47:06.701] getGlobalsAndPackages() ... DONE
[17:47:06.701] run() for ‘Future’ ...
[17:47:06.701] - state: ‘created’
[17:47:06.702] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.702] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.702] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.702]   - Field: ‘label’
[17:47:06.702]   - Field: ‘local’
[17:47:06.702]   - Field: ‘owner’
[17:47:06.702]   - Field: ‘envir’
[17:47:06.702]   - Field: ‘packages’
[17:47:06.702]   - Field: ‘gc’
[17:47:06.702]   - Field: ‘conditions’
[17:47:06.703]   - Field: ‘expr’
[17:47:06.703]   - Field: ‘uuid’
[17:47:06.703]   - Field: ‘seed’
[17:47:06.703]   - Field: ‘version’
[17:47:06.703]   - Field: ‘result’
[17:47:06.703]   - Field: ‘asynchronous’
[17:47:06.703]   - Field: ‘calls’
[17:47:06.703]   - Field: ‘globals’
[17:47:06.703]   - Field: ‘stdout’
[17:47:06.703]   - Field: ‘earlySignal’
[17:47:06.703]   - Field: ‘lazy’
[17:47:06.704]   - Field: ‘state’
[17:47:06.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.704] - Launch lazy future ...
[17:47:06.704] Packages needed by the future expression (n = 0): <none>
[17:47:06.704] Packages needed by future strategies (n = 0): <none>
[17:47:06.704] {
[17:47:06.704]     {
[17:47:06.704]         {
[17:47:06.704]             ...future.startTime <- base::Sys.time()
[17:47:06.704]             {
[17:47:06.704]                 {
[17:47:06.704]                   {
[17:47:06.704]                     base::local({
[17:47:06.704]                       has_future <- base::requireNamespace("future", 
[17:47:06.704]                         quietly = TRUE)
[17:47:06.704]                       if (has_future) {
[17:47:06.704]                         ns <- base::getNamespace("future")
[17:47:06.704]                         version <- ns[[".package"]][["version"]]
[17:47:06.704]                         if (is.null(version)) 
[17:47:06.704]                           version <- utils::packageVersion("future")
[17:47:06.704]                       }
[17:47:06.704]                       else {
[17:47:06.704]                         version <- NULL
[17:47:06.704]                       }
[17:47:06.704]                       if (!has_future || version < "1.8.0") {
[17:47:06.704]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.704]                           "", base::R.version$version.string), 
[17:47:06.704]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.704]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.704]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.704]                             "release", "version")], collapse = " "), 
[17:47:06.704]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.704]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.704]                           info)
[17:47:06.704]                         info <- base::paste(info, collapse = "; ")
[17:47:06.704]                         if (!has_future) {
[17:47:06.704]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.704]                             info)
[17:47:06.704]                         }
[17:47:06.704]                         else {
[17:47:06.704]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.704]                             info, version)
[17:47:06.704]                         }
[17:47:06.704]                         base::stop(msg)
[17:47:06.704]                       }
[17:47:06.704]                     })
[17:47:06.704]                   }
[17:47:06.704]                   ...future.strategy.old <- future::plan("list")
[17:47:06.704]                   options(future.plan = NULL)
[17:47:06.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.704]                 }
[17:47:06.704]                 ...future.workdir <- getwd()
[17:47:06.704]             }
[17:47:06.704]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.704]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.704]         }
[17:47:06.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.704]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.704]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.704]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.704]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.704]             base::names(...future.oldOptions))
[17:47:06.704]     }
[17:47:06.704]     if (FALSE) {
[17:47:06.704]     }
[17:47:06.704]     else {
[17:47:06.704]         if (TRUE) {
[17:47:06.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.704]                 open = "w")
[17:47:06.704]         }
[17:47:06.704]         else {
[17:47:06.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.704]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.704]         }
[17:47:06.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.704]             base::sink(type = "output", split = FALSE)
[17:47:06.704]             base::close(...future.stdout)
[17:47:06.704]         }, add = TRUE)
[17:47:06.704]     }
[17:47:06.704]     ...future.frame <- base::sys.nframe()
[17:47:06.704]     ...future.conditions <- base::list()
[17:47:06.704]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.704]     if (FALSE) {
[17:47:06.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.704]     }
[17:47:06.704]     ...future.result <- base::tryCatch({
[17:47:06.704]         base::withCallingHandlers({
[17:47:06.704]             ...future.value <- base::withVisible(base::local(1))
[17:47:06.704]             future::FutureResult(value = ...future.value$value, 
[17:47:06.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.704]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.704]                     ...future.globalenv.names))
[17:47:06.704]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.704]         }, condition = base::local({
[17:47:06.704]             c <- base::c
[17:47:06.704]             inherits <- base::inherits
[17:47:06.704]             invokeRestart <- base::invokeRestart
[17:47:06.704]             length <- base::length
[17:47:06.704]             list <- base::list
[17:47:06.704]             seq.int <- base::seq.int
[17:47:06.704]             signalCondition <- base::signalCondition
[17:47:06.704]             sys.calls <- base::sys.calls
[17:47:06.704]             `[[` <- base::`[[`
[17:47:06.704]             `+` <- base::`+`
[17:47:06.704]             `<<-` <- base::`<<-`
[17:47:06.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.704]                   3L)]
[17:47:06.704]             }
[17:47:06.704]             function(cond) {
[17:47:06.704]                 is_error <- inherits(cond, "error")
[17:47:06.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.704]                   NULL)
[17:47:06.704]                 if (is_error) {
[17:47:06.704]                   sessionInformation <- function() {
[17:47:06.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.704]                       search = base::search(), system = base::Sys.info())
[17:47:06.704]                   }
[17:47:06.704]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.704]                     cond$call), session = sessionInformation(), 
[17:47:06.704]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.704]                   signalCondition(cond)
[17:47:06.704]                 }
[17:47:06.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.704]                 "immediateCondition"))) {
[17:47:06.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.704]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.704]                   if (TRUE && !signal) {
[17:47:06.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.704]                     {
[17:47:06.704]                       inherits <- base::inherits
[17:47:06.704]                       invokeRestart <- base::invokeRestart
[17:47:06.704]                       is.null <- base::is.null
[17:47:06.704]                       muffled <- FALSE
[17:47:06.704]                       if (inherits(cond, "message")) {
[17:47:06.704]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.704]                         if (muffled) 
[17:47:06.704]                           invokeRestart("muffleMessage")
[17:47:06.704]                       }
[17:47:06.704]                       else if (inherits(cond, "warning")) {
[17:47:06.704]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.704]                         if (muffled) 
[17:47:06.704]                           invokeRestart("muffleWarning")
[17:47:06.704]                       }
[17:47:06.704]                       else if (inherits(cond, "condition")) {
[17:47:06.704]                         if (!is.null(pattern)) {
[17:47:06.704]                           computeRestarts <- base::computeRestarts
[17:47:06.704]                           grepl <- base::grepl
[17:47:06.704]                           restarts <- computeRestarts(cond)
[17:47:06.704]                           for (restart in restarts) {
[17:47:06.704]                             name <- restart$name
[17:47:06.704]                             if (is.null(name)) 
[17:47:06.704]                               next
[17:47:06.704]                             if (!grepl(pattern, name)) 
[17:47:06.704]                               next
[17:47:06.704]                             invokeRestart(restart)
[17:47:06.704]                             muffled <- TRUE
[17:47:06.704]                             break
[17:47:06.704]                           }
[17:47:06.704]                         }
[17:47:06.704]                       }
[17:47:06.704]                       invisible(muffled)
[17:47:06.704]                     }
[17:47:06.704]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.704]                   }
[17:47:06.704]                 }
[17:47:06.704]                 else {
[17:47:06.704]                   if (TRUE) {
[17:47:06.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.704]                     {
[17:47:06.704]                       inherits <- base::inherits
[17:47:06.704]                       invokeRestart <- base::invokeRestart
[17:47:06.704]                       is.null <- base::is.null
[17:47:06.704]                       muffled <- FALSE
[17:47:06.704]                       if (inherits(cond, "message")) {
[17:47:06.704]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.704]                         if (muffled) 
[17:47:06.704]                           invokeRestart("muffleMessage")
[17:47:06.704]                       }
[17:47:06.704]                       else if (inherits(cond, "warning")) {
[17:47:06.704]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.704]                         if (muffled) 
[17:47:06.704]                           invokeRestart("muffleWarning")
[17:47:06.704]                       }
[17:47:06.704]                       else if (inherits(cond, "condition")) {
[17:47:06.704]                         if (!is.null(pattern)) {
[17:47:06.704]                           computeRestarts <- base::computeRestarts
[17:47:06.704]                           grepl <- base::grepl
[17:47:06.704]                           restarts <- computeRestarts(cond)
[17:47:06.704]                           for (restart in restarts) {
[17:47:06.704]                             name <- restart$name
[17:47:06.704]                             if (is.null(name)) 
[17:47:06.704]                               next
[17:47:06.704]                             if (!grepl(pattern, name)) 
[17:47:06.704]                               next
[17:47:06.704]                             invokeRestart(restart)
[17:47:06.704]                             muffled <- TRUE
[17:47:06.704]                             break
[17:47:06.704]                           }
[17:47:06.704]                         }
[17:47:06.704]                       }
[17:47:06.704]                       invisible(muffled)
[17:47:06.704]                     }
[17:47:06.704]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.704]                   }
[17:47:06.704]                 }
[17:47:06.704]             }
[17:47:06.704]         }))
[17:47:06.704]     }, error = function(ex) {
[17:47:06.704]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.704]                 ...future.rng), started = ...future.startTime, 
[17:47:06.704]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.704]             version = "1.8"), class = "FutureResult")
[17:47:06.704]     }, finally = {
[17:47:06.704]         if (!identical(...future.workdir, getwd())) 
[17:47:06.704]             setwd(...future.workdir)
[17:47:06.704]         {
[17:47:06.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.704]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.704]             }
[17:47:06.704]             base::options(...future.oldOptions)
[17:47:06.704]             if (.Platform$OS.type == "windows") {
[17:47:06.704]                 old_names <- names(...future.oldEnvVars)
[17:47:06.704]                 envs <- base::Sys.getenv()
[17:47:06.704]                 names <- names(envs)
[17:47:06.704]                 common <- intersect(names, old_names)
[17:47:06.704]                 added <- setdiff(names, old_names)
[17:47:06.704]                 removed <- setdiff(old_names, names)
[17:47:06.704]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.704]                   envs[common]]
[17:47:06.704]                 NAMES <- toupper(changed)
[17:47:06.704]                 args <- list()
[17:47:06.704]                 for (kk in seq_along(NAMES)) {
[17:47:06.704]                   name <- changed[[kk]]
[17:47:06.704]                   NAME <- NAMES[[kk]]
[17:47:06.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.704]                     next
[17:47:06.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.704]                 }
[17:47:06.704]                 NAMES <- toupper(added)
[17:47:06.704]                 for (kk in seq_along(NAMES)) {
[17:47:06.704]                   name <- added[[kk]]
[17:47:06.704]                   NAME <- NAMES[[kk]]
[17:47:06.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.704]                     next
[17:47:06.704]                   args[[name]] <- ""
[17:47:06.704]                 }
[17:47:06.704]                 NAMES <- toupper(removed)
[17:47:06.704]                 for (kk in seq_along(NAMES)) {
[17:47:06.704]                   name <- removed[[kk]]
[17:47:06.704]                   NAME <- NAMES[[kk]]
[17:47:06.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.704]                     next
[17:47:06.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.704]                 }
[17:47:06.704]                 if (length(args) > 0) 
[17:47:06.704]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.704]             }
[17:47:06.704]             else {
[17:47:06.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.704]             }
[17:47:06.704]             {
[17:47:06.704]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.704]                   0L) {
[17:47:06.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.704]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.704]                   base::options(opts)
[17:47:06.704]                 }
[17:47:06.704]                 {
[17:47:06.704]                   {
[17:47:06.704]                     NULL
[17:47:06.704]                     RNGkind("Mersenne-Twister")
[17:47:06.704]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.704]                       inherits = FALSE)
[17:47:06.704]                   }
[17:47:06.704]                   options(future.plan = NULL)
[17:47:06.704]                   if (is.na(NA_character_)) 
[17:47:06.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.704]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.704]                     .init = FALSE)
[17:47:06.704]                 }
[17:47:06.704]             }
[17:47:06.704]         }
[17:47:06.704]     })
[17:47:06.704]     if (TRUE) {
[17:47:06.704]         base::sink(type = "output", split = FALSE)
[17:47:06.704]         if (TRUE) {
[17:47:06.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.704]         }
[17:47:06.704]         else {
[17:47:06.704]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.704]         }
[17:47:06.704]         base::close(...future.stdout)
[17:47:06.704]         ...future.stdout <- NULL
[17:47:06.704]     }
[17:47:06.704]     ...future.result$conditions <- ...future.conditions
[17:47:06.704]     ...future.result$finished <- base::Sys.time()
[17:47:06.704]     ...future.result
[17:47:06.704] }
[17:47:06.706] plan(): Setting new future strategy stack:
[17:47:06.706] List of future strategies:
[17:47:06.706] 1. sequential:
[17:47:06.706]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.706]    - tweaked: FALSE
[17:47:06.706]    - call: NULL
[17:47:06.707] plan(): nbrOfWorkers() = 1
[17:47:06.707] plan(): Setting new future strategy stack:
[17:47:06.707] List of future strategies:
[17:47:06.707] 1. sequential:
[17:47:06.707]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.707]    - tweaked: FALSE
[17:47:06.707]    - call: plan(strategy)
[17:47:06.708] plan(): nbrOfWorkers() = 1
[17:47:06.708] SequentialFuture started (and completed)
[17:47:06.708] - Launch lazy future ... done
[17:47:06.708] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.708] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.708] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.711] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:06.711] Searching for globals ... DONE
[17:47:06.711] Resolving globals: TRUE
[17:47:06.711] Resolving any globals that are futures ...
[17:47:06.711] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:06.711] Resolving any globals that are futures ... DONE
[17:47:06.711] Resolving futures part of globals (recursively) ...
[17:47:06.712] resolve() on list ...
[17:47:06.712]  recursive: 99
[17:47:06.712]  length: 1
[17:47:06.712]  elements: ‘a’
[17:47:06.712] resolved() for ‘SequentialFuture’ ...
[17:47:06.712] - state: ‘finished’
[17:47:06.712] - run: TRUE
[17:47:06.712] - result: ‘FutureResult’
[17:47:06.712] resolved() for ‘SequentialFuture’ ... done
[17:47:06.712] Future #1
[17:47:06.713] resolved() for ‘SequentialFuture’ ...
[17:47:06.713] - state: ‘finished’
[17:47:06.713] - run: TRUE
[17:47:06.713] - result: ‘FutureResult’
[17:47:06.713] resolved() for ‘SequentialFuture’ ... done
[17:47:06.713] A SequentialFuture was resolved
[17:47:06.713]  length: 0 (resolved future 1)
[17:47:06.713] resolve() on list ... DONE
[17:47:06.713] - globals: [1] ‘a’
[17:47:06.713] Resolving futures part of globals (recursively) ... DONE
[17:47:06.715] The total size of the 1 globals is 1.55 MiB (1622272 bytes)
[17:47:06.715] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:47:06.716] - globals: [1] ‘a’
[17:47:06.716] - packages: [1] ‘future’
[17:47:06.716] getGlobalsAndPackages() ... DONE
[17:47:06.716] run() for ‘Future’ ...
[17:47:06.716] - state: ‘created’
[17:47:06.716] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.716] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.717]   - Field: ‘label’
[17:47:06.717]   - Field: ‘local’
[17:47:06.717]   - Field: ‘owner’
[17:47:06.717]   - Field: ‘envir’
[17:47:06.717]   - Field: ‘packages’
[17:47:06.717]   - Field: ‘gc’
[17:47:06.717]   - Field: ‘conditions’
[17:47:06.717]   - Field: ‘expr’
[17:47:06.717]   - Field: ‘uuid’
[17:47:06.717]   - Field: ‘seed’
[17:47:06.718]   - Field: ‘version’
[17:47:06.718]   - Field: ‘result’
[17:47:06.718]   - Field: ‘asynchronous’
[17:47:06.718]   - Field: ‘calls’
[17:47:06.718]   - Field: ‘globals’
[17:47:06.718]   - Field: ‘stdout’
[17:47:06.718]   - Field: ‘earlySignal’
[17:47:06.718]   - Field: ‘lazy’
[17:47:06.718]   - Field: ‘state’
[17:47:06.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.718] - Launch lazy future ...
[17:47:06.719] Packages needed by the future expression (n = 1): ‘future’
[17:47:06.719] Packages needed by future strategies (n = 0): <none>
[17:47:06.719] {
[17:47:06.719]     {
[17:47:06.719]         {
[17:47:06.719]             ...future.startTime <- base::Sys.time()
[17:47:06.719]             {
[17:47:06.719]                 {
[17:47:06.719]                   {
[17:47:06.719]                     {
[17:47:06.719]                       base::local({
[17:47:06.719]                         has_future <- base::requireNamespace("future", 
[17:47:06.719]                           quietly = TRUE)
[17:47:06.719]                         if (has_future) {
[17:47:06.719]                           ns <- base::getNamespace("future")
[17:47:06.719]                           version <- ns[[".package"]][["version"]]
[17:47:06.719]                           if (is.null(version)) 
[17:47:06.719]                             version <- utils::packageVersion("future")
[17:47:06.719]                         }
[17:47:06.719]                         else {
[17:47:06.719]                           version <- NULL
[17:47:06.719]                         }
[17:47:06.719]                         if (!has_future || version < "1.8.0") {
[17:47:06.719]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.719]                             "", base::R.version$version.string), 
[17:47:06.719]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.719]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.719]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.719]                               "release", "version")], collapse = " "), 
[17:47:06.719]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.719]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.719]                             info)
[17:47:06.719]                           info <- base::paste(info, collapse = "; ")
[17:47:06.719]                           if (!has_future) {
[17:47:06.719]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.719]                               info)
[17:47:06.719]                           }
[17:47:06.719]                           else {
[17:47:06.719]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.719]                               info, version)
[17:47:06.719]                           }
[17:47:06.719]                           base::stop(msg)
[17:47:06.719]                         }
[17:47:06.719]                       })
[17:47:06.719]                     }
[17:47:06.719]                     base::local({
[17:47:06.719]                       for (pkg in "future") {
[17:47:06.719]                         base::loadNamespace(pkg)
[17:47:06.719]                         base::library(pkg, character.only = TRUE)
[17:47:06.719]                       }
[17:47:06.719]                     })
[17:47:06.719]                   }
[17:47:06.719]                   ...future.strategy.old <- future::plan("list")
[17:47:06.719]                   options(future.plan = NULL)
[17:47:06.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.719]                 }
[17:47:06.719]                 ...future.workdir <- getwd()
[17:47:06.719]             }
[17:47:06.719]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.719]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.719]         }
[17:47:06.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.719]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.719]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.719]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.719]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.719]             base::names(...future.oldOptions))
[17:47:06.719]     }
[17:47:06.719]     if (FALSE) {
[17:47:06.719]     }
[17:47:06.719]     else {
[17:47:06.719]         if (TRUE) {
[17:47:06.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.719]                 open = "w")
[17:47:06.719]         }
[17:47:06.719]         else {
[17:47:06.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.719]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.719]         }
[17:47:06.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.719]             base::sink(type = "output", split = FALSE)
[17:47:06.719]             base::close(...future.stdout)
[17:47:06.719]         }, add = TRUE)
[17:47:06.719]     }
[17:47:06.719]     ...future.frame <- base::sys.nframe()
[17:47:06.719]     ...future.conditions <- base::list()
[17:47:06.719]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.719]     if (FALSE) {
[17:47:06.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.719]     }
[17:47:06.719]     ...future.result <- base::tryCatch({
[17:47:06.719]         base::withCallingHandlers({
[17:47:06.719]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:47:06.719]                 1))
[17:47:06.719]             future::FutureResult(value = ...future.value$value, 
[17:47:06.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.719]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.719]                     ...future.globalenv.names))
[17:47:06.719]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.719]         }, condition = base::local({
[17:47:06.719]             c <- base::c
[17:47:06.719]             inherits <- base::inherits
[17:47:06.719]             invokeRestart <- base::invokeRestart
[17:47:06.719]             length <- base::length
[17:47:06.719]             list <- base::list
[17:47:06.719]             seq.int <- base::seq.int
[17:47:06.719]             signalCondition <- base::signalCondition
[17:47:06.719]             sys.calls <- base::sys.calls
[17:47:06.719]             `[[` <- base::`[[`
[17:47:06.719]             `+` <- base::`+`
[17:47:06.719]             `<<-` <- base::`<<-`
[17:47:06.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.719]                   3L)]
[17:47:06.719]             }
[17:47:06.719]             function(cond) {
[17:47:06.719]                 is_error <- inherits(cond, "error")
[17:47:06.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.719]                   NULL)
[17:47:06.719]                 if (is_error) {
[17:47:06.719]                   sessionInformation <- function() {
[17:47:06.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.719]                       search = base::search(), system = base::Sys.info())
[17:47:06.719]                   }
[17:47:06.719]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.719]                     cond$call), session = sessionInformation(), 
[17:47:06.719]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.719]                   signalCondition(cond)
[17:47:06.719]                 }
[17:47:06.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.719]                 "immediateCondition"))) {
[17:47:06.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.719]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.719]                   if (TRUE && !signal) {
[17:47:06.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.719]                     {
[17:47:06.719]                       inherits <- base::inherits
[17:47:06.719]                       invokeRestart <- base::invokeRestart
[17:47:06.719]                       is.null <- base::is.null
[17:47:06.719]                       muffled <- FALSE
[17:47:06.719]                       if (inherits(cond, "message")) {
[17:47:06.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.719]                         if (muffled) 
[17:47:06.719]                           invokeRestart("muffleMessage")
[17:47:06.719]                       }
[17:47:06.719]                       else if (inherits(cond, "warning")) {
[17:47:06.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.719]                         if (muffled) 
[17:47:06.719]                           invokeRestart("muffleWarning")
[17:47:06.719]                       }
[17:47:06.719]                       else if (inherits(cond, "condition")) {
[17:47:06.719]                         if (!is.null(pattern)) {
[17:47:06.719]                           computeRestarts <- base::computeRestarts
[17:47:06.719]                           grepl <- base::grepl
[17:47:06.719]                           restarts <- computeRestarts(cond)
[17:47:06.719]                           for (restart in restarts) {
[17:47:06.719]                             name <- restart$name
[17:47:06.719]                             if (is.null(name)) 
[17:47:06.719]                               next
[17:47:06.719]                             if (!grepl(pattern, name)) 
[17:47:06.719]                               next
[17:47:06.719]                             invokeRestart(restart)
[17:47:06.719]                             muffled <- TRUE
[17:47:06.719]                             break
[17:47:06.719]                           }
[17:47:06.719]                         }
[17:47:06.719]                       }
[17:47:06.719]                       invisible(muffled)
[17:47:06.719]                     }
[17:47:06.719]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.719]                   }
[17:47:06.719]                 }
[17:47:06.719]                 else {
[17:47:06.719]                   if (TRUE) {
[17:47:06.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.719]                     {
[17:47:06.719]                       inherits <- base::inherits
[17:47:06.719]                       invokeRestart <- base::invokeRestart
[17:47:06.719]                       is.null <- base::is.null
[17:47:06.719]                       muffled <- FALSE
[17:47:06.719]                       if (inherits(cond, "message")) {
[17:47:06.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.719]                         if (muffled) 
[17:47:06.719]                           invokeRestart("muffleMessage")
[17:47:06.719]                       }
[17:47:06.719]                       else if (inherits(cond, "warning")) {
[17:47:06.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.719]                         if (muffled) 
[17:47:06.719]                           invokeRestart("muffleWarning")
[17:47:06.719]                       }
[17:47:06.719]                       else if (inherits(cond, "condition")) {
[17:47:06.719]                         if (!is.null(pattern)) {
[17:47:06.719]                           computeRestarts <- base::computeRestarts
[17:47:06.719]                           grepl <- base::grepl
[17:47:06.719]                           restarts <- computeRestarts(cond)
[17:47:06.719]                           for (restart in restarts) {
[17:47:06.719]                             name <- restart$name
[17:47:06.719]                             if (is.null(name)) 
[17:47:06.719]                               next
[17:47:06.719]                             if (!grepl(pattern, name)) 
[17:47:06.719]                               next
[17:47:06.719]                             invokeRestart(restart)
[17:47:06.719]                             muffled <- TRUE
[17:47:06.719]                             break
[17:47:06.719]                           }
[17:47:06.719]                         }
[17:47:06.719]                       }
[17:47:06.719]                       invisible(muffled)
[17:47:06.719]                     }
[17:47:06.719]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.719]                   }
[17:47:06.719]                 }
[17:47:06.719]             }
[17:47:06.719]         }))
[17:47:06.719]     }, error = function(ex) {
[17:47:06.719]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.719]                 ...future.rng), started = ...future.startTime, 
[17:47:06.719]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.719]             version = "1.8"), class = "FutureResult")
[17:47:06.719]     }, finally = {
[17:47:06.719]         if (!identical(...future.workdir, getwd())) 
[17:47:06.719]             setwd(...future.workdir)
[17:47:06.719]         {
[17:47:06.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.719]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.719]             }
[17:47:06.719]             base::options(...future.oldOptions)
[17:47:06.719]             if (.Platform$OS.type == "windows") {
[17:47:06.719]                 old_names <- names(...future.oldEnvVars)
[17:47:06.719]                 envs <- base::Sys.getenv()
[17:47:06.719]                 names <- names(envs)
[17:47:06.719]                 common <- intersect(names, old_names)
[17:47:06.719]                 added <- setdiff(names, old_names)
[17:47:06.719]                 removed <- setdiff(old_names, names)
[17:47:06.719]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.719]                   envs[common]]
[17:47:06.719]                 NAMES <- toupper(changed)
[17:47:06.719]                 args <- list()
[17:47:06.719]                 for (kk in seq_along(NAMES)) {
[17:47:06.719]                   name <- changed[[kk]]
[17:47:06.719]                   NAME <- NAMES[[kk]]
[17:47:06.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.719]                     next
[17:47:06.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.719]                 }
[17:47:06.719]                 NAMES <- toupper(added)
[17:47:06.719]                 for (kk in seq_along(NAMES)) {
[17:47:06.719]                   name <- added[[kk]]
[17:47:06.719]                   NAME <- NAMES[[kk]]
[17:47:06.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.719]                     next
[17:47:06.719]                   args[[name]] <- ""
[17:47:06.719]                 }
[17:47:06.719]                 NAMES <- toupper(removed)
[17:47:06.719]                 for (kk in seq_along(NAMES)) {
[17:47:06.719]                   name <- removed[[kk]]
[17:47:06.719]                   NAME <- NAMES[[kk]]
[17:47:06.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.719]                     next
[17:47:06.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.719]                 }
[17:47:06.719]                 if (length(args) > 0) 
[17:47:06.719]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.719]             }
[17:47:06.719]             else {
[17:47:06.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.719]             }
[17:47:06.719]             {
[17:47:06.719]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.719]                   0L) {
[17:47:06.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.719]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.719]                   base::options(opts)
[17:47:06.719]                 }
[17:47:06.719]                 {
[17:47:06.719]                   {
[17:47:06.719]                     NULL
[17:47:06.719]                     RNGkind("Mersenne-Twister")
[17:47:06.719]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.719]                       inherits = FALSE)
[17:47:06.719]                   }
[17:47:06.719]                   options(future.plan = NULL)
[17:47:06.719]                   if (is.na(NA_character_)) 
[17:47:06.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.719]                     .init = FALSE)
[17:47:06.719]                 }
[17:47:06.719]             }
[17:47:06.719]         }
[17:47:06.719]     })
[17:47:06.719]     if (TRUE) {
[17:47:06.719]         base::sink(type = "output", split = FALSE)
[17:47:06.719]         if (TRUE) {
[17:47:06.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.719]         }
[17:47:06.719]         else {
[17:47:06.719]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.719]         }
[17:47:06.719]         base::close(...future.stdout)
[17:47:06.719]         ...future.stdout <- NULL
[17:47:06.719]     }
[17:47:06.719]     ...future.result$conditions <- ...future.conditions
[17:47:06.719]     ...future.result$finished <- base::Sys.time()
[17:47:06.719]     ...future.result
[17:47:06.719] }
[17:47:06.721] assign_globals() ...
[17:47:06.721] List of 1
[17:47:06.721]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558b32731850> 
[17:47:06.721]  - attr(*, "where")=List of 1
[17:47:06.721]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.721]  - attr(*, "resolved")= logi TRUE
[17:47:06.721]  - attr(*, "total_size")= num 1622272
[17:47:06.721]  - attr(*, "already-done")= logi TRUE
[17:47:06.723] - copied ‘a’ to environment
[17:47:06.723] assign_globals() ... done
[17:47:06.724] plan(): Setting new future strategy stack:
[17:47:06.724] List of future strategies:
[17:47:06.724] 1. sequential:
[17:47:06.724]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.724]    - tweaked: FALSE
[17:47:06.724]    - call: NULL
[17:47:06.724] plan(): nbrOfWorkers() = 1
[17:47:06.725] plan(): Setting new future strategy stack:
[17:47:06.725] List of future strategies:
[17:47:06.725] 1. sequential:
[17:47:06.725]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.725]    - tweaked: FALSE
[17:47:06.725]    - call: plan(strategy)
[17:47:06.725] plan(): nbrOfWorkers() = 1
[17:47:06.726] SequentialFuture started (and completed)
[17:47:06.726] - Launch lazy future ... done
[17:47:06.726] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.726] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.726] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.727] 
[17:47:06.727] Searching for globals ... DONE
[17:47:06.727] - globals: [0] <none>
[17:47:06.727] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.727] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.727] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.728] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:06.728] Searching for globals ... DONE
[17:47:06.728] Resolving globals: TRUE
[17:47:06.728] Resolving any globals that are futures ...
[17:47:06.729] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:06.729] Resolving any globals that are futures ... DONE
[17:47:06.729] Resolving futures part of globals (recursively) ...
[17:47:06.729] resolve() on list ...
[17:47:06.729]  recursive: 99
[17:47:06.729]  length: 1
[17:47:06.729]  elements: ‘a’
[17:47:06.730] run() for ‘Future’ ...
[17:47:06.730] - state: ‘created’
[17:47:06.730] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.730] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.730]   - Field: ‘label’
[17:47:06.730]   - Field: ‘local’
[17:47:06.730]   - Field: ‘owner’
[17:47:06.730]   - Field: ‘envir’
[17:47:06.731]   - Field: ‘packages’
[17:47:06.731]   - Field: ‘gc’
[17:47:06.731]   - Field: ‘conditions’
[17:47:06.731]   - Field: ‘expr’
[17:47:06.731]   - Field: ‘uuid’
[17:47:06.731]   - Field: ‘seed’
[17:47:06.731]   - Field: ‘version’
[17:47:06.731]   - Field: ‘result’
[17:47:06.731]   - Field: ‘asynchronous’
[17:47:06.731]   - Field: ‘calls’
[17:47:06.731]   - Field: ‘globals’
[17:47:06.732]   - Field: ‘stdout’
[17:47:06.732]   - Field: ‘earlySignal’
[17:47:06.732]   - Field: ‘lazy’
[17:47:06.732]   - Field: ‘state’
[17:47:06.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.732] - Launch lazy future ...
[17:47:06.732] Packages needed by the future expression (n = 0): <none>
[17:47:06.732] Packages needed by future strategies (n = 0): <none>
[17:47:06.733] {
[17:47:06.733]     {
[17:47:06.733]         {
[17:47:06.733]             ...future.startTime <- base::Sys.time()
[17:47:06.733]             {
[17:47:06.733]                 {
[17:47:06.733]                   {
[17:47:06.733]                     base::local({
[17:47:06.733]                       has_future <- base::requireNamespace("future", 
[17:47:06.733]                         quietly = TRUE)
[17:47:06.733]                       if (has_future) {
[17:47:06.733]                         ns <- base::getNamespace("future")
[17:47:06.733]                         version <- ns[[".package"]][["version"]]
[17:47:06.733]                         if (is.null(version)) 
[17:47:06.733]                           version <- utils::packageVersion("future")
[17:47:06.733]                       }
[17:47:06.733]                       else {
[17:47:06.733]                         version <- NULL
[17:47:06.733]                       }
[17:47:06.733]                       if (!has_future || version < "1.8.0") {
[17:47:06.733]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.733]                           "", base::R.version$version.string), 
[17:47:06.733]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.733]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.733]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.733]                             "release", "version")], collapse = " "), 
[17:47:06.733]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.733]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.733]                           info)
[17:47:06.733]                         info <- base::paste(info, collapse = "; ")
[17:47:06.733]                         if (!has_future) {
[17:47:06.733]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.733]                             info)
[17:47:06.733]                         }
[17:47:06.733]                         else {
[17:47:06.733]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.733]                             info, version)
[17:47:06.733]                         }
[17:47:06.733]                         base::stop(msg)
[17:47:06.733]                       }
[17:47:06.733]                     })
[17:47:06.733]                   }
[17:47:06.733]                   ...future.strategy.old <- future::plan("list")
[17:47:06.733]                   options(future.plan = NULL)
[17:47:06.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.733]                 }
[17:47:06.733]                 ...future.workdir <- getwd()
[17:47:06.733]             }
[17:47:06.733]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.733]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.733]         }
[17:47:06.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.733]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.733]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.733]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.733]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.733]             base::names(...future.oldOptions))
[17:47:06.733]     }
[17:47:06.733]     if (FALSE) {
[17:47:06.733]     }
[17:47:06.733]     else {
[17:47:06.733]         if (TRUE) {
[17:47:06.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.733]                 open = "w")
[17:47:06.733]         }
[17:47:06.733]         else {
[17:47:06.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.733]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.733]         }
[17:47:06.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.733]             base::sink(type = "output", split = FALSE)
[17:47:06.733]             base::close(...future.stdout)
[17:47:06.733]         }, add = TRUE)
[17:47:06.733]     }
[17:47:06.733]     ...future.frame <- base::sys.nframe()
[17:47:06.733]     ...future.conditions <- base::list()
[17:47:06.733]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.733]     if (FALSE) {
[17:47:06.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.733]     }
[17:47:06.733]     ...future.result <- base::tryCatch({
[17:47:06.733]         base::withCallingHandlers({
[17:47:06.733]             ...future.value <- base::withVisible(base::local(1))
[17:47:06.733]             future::FutureResult(value = ...future.value$value, 
[17:47:06.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.733]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.733]                     ...future.globalenv.names))
[17:47:06.733]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.733]         }, condition = base::local({
[17:47:06.733]             c <- base::c
[17:47:06.733]             inherits <- base::inherits
[17:47:06.733]             invokeRestart <- base::invokeRestart
[17:47:06.733]             length <- base::length
[17:47:06.733]             list <- base::list
[17:47:06.733]             seq.int <- base::seq.int
[17:47:06.733]             signalCondition <- base::signalCondition
[17:47:06.733]             sys.calls <- base::sys.calls
[17:47:06.733]             `[[` <- base::`[[`
[17:47:06.733]             `+` <- base::`+`
[17:47:06.733]             `<<-` <- base::`<<-`
[17:47:06.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.733]                   3L)]
[17:47:06.733]             }
[17:47:06.733]             function(cond) {
[17:47:06.733]                 is_error <- inherits(cond, "error")
[17:47:06.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.733]                   NULL)
[17:47:06.733]                 if (is_error) {
[17:47:06.733]                   sessionInformation <- function() {
[17:47:06.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.733]                       search = base::search(), system = base::Sys.info())
[17:47:06.733]                   }
[17:47:06.733]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.733]                     cond$call), session = sessionInformation(), 
[17:47:06.733]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.733]                   signalCondition(cond)
[17:47:06.733]                 }
[17:47:06.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.733]                 "immediateCondition"))) {
[17:47:06.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.733]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.733]                   if (TRUE && !signal) {
[17:47:06.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.733]                     {
[17:47:06.733]                       inherits <- base::inherits
[17:47:06.733]                       invokeRestart <- base::invokeRestart
[17:47:06.733]                       is.null <- base::is.null
[17:47:06.733]                       muffled <- FALSE
[17:47:06.733]                       if (inherits(cond, "message")) {
[17:47:06.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.733]                         if (muffled) 
[17:47:06.733]                           invokeRestart("muffleMessage")
[17:47:06.733]                       }
[17:47:06.733]                       else if (inherits(cond, "warning")) {
[17:47:06.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.733]                         if (muffled) 
[17:47:06.733]                           invokeRestart("muffleWarning")
[17:47:06.733]                       }
[17:47:06.733]                       else if (inherits(cond, "condition")) {
[17:47:06.733]                         if (!is.null(pattern)) {
[17:47:06.733]                           computeRestarts <- base::computeRestarts
[17:47:06.733]                           grepl <- base::grepl
[17:47:06.733]                           restarts <- computeRestarts(cond)
[17:47:06.733]                           for (restart in restarts) {
[17:47:06.733]                             name <- restart$name
[17:47:06.733]                             if (is.null(name)) 
[17:47:06.733]                               next
[17:47:06.733]                             if (!grepl(pattern, name)) 
[17:47:06.733]                               next
[17:47:06.733]                             invokeRestart(restart)
[17:47:06.733]                             muffled <- TRUE
[17:47:06.733]                             break
[17:47:06.733]                           }
[17:47:06.733]                         }
[17:47:06.733]                       }
[17:47:06.733]                       invisible(muffled)
[17:47:06.733]                     }
[17:47:06.733]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.733]                   }
[17:47:06.733]                 }
[17:47:06.733]                 else {
[17:47:06.733]                   if (TRUE) {
[17:47:06.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.733]                     {
[17:47:06.733]                       inherits <- base::inherits
[17:47:06.733]                       invokeRestart <- base::invokeRestart
[17:47:06.733]                       is.null <- base::is.null
[17:47:06.733]                       muffled <- FALSE
[17:47:06.733]                       if (inherits(cond, "message")) {
[17:47:06.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.733]                         if (muffled) 
[17:47:06.733]                           invokeRestart("muffleMessage")
[17:47:06.733]                       }
[17:47:06.733]                       else if (inherits(cond, "warning")) {
[17:47:06.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.733]                         if (muffled) 
[17:47:06.733]                           invokeRestart("muffleWarning")
[17:47:06.733]                       }
[17:47:06.733]                       else if (inherits(cond, "condition")) {
[17:47:06.733]                         if (!is.null(pattern)) {
[17:47:06.733]                           computeRestarts <- base::computeRestarts
[17:47:06.733]                           grepl <- base::grepl
[17:47:06.733]                           restarts <- computeRestarts(cond)
[17:47:06.733]                           for (restart in restarts) {
[17:47:06.733]                             name <- restart$name
[17:47:06.733]                             if (is.null(name)) 
[17:47:06.733]                               next
[17:47:06.733]                             if (!grepl(pattern, name)) 
[17:47:06.733]                               next
[17:47:06.733]                             invokeRestart(restart)
[17:47:06.733]                             muffled <- TRUE
[17:47:06.733]                             break
[17:47:06.733]                           }
[17:47:06.733]                         }
[17:47:06.733]                       }
[17:47:06.733]                       invisible(muffled)
[17:47:06.733]                     }
[17:47:06.733]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.733]                   }
[17:47:06.733]                 }
[17:47:06.733]             }
[17:47:06.733]         }))
[17:47:06.733]     }, error = function(ex) {
[17:47:06.733]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.733]                 ...future.rng), started = ...future.startTime, 
[17:47:06.733]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.733]             version = "1.8"), class = "FutureResult")
[17:47:06.733]     }, finally = {
[17:47:06.733]         if (!identical(...future.workdir, getwd())) 
[17:47:06.733]             setwd(...future.workdir)
[17:47:06.733]         {
[17:47:06.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.733]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.733]             }
[17:47:06.733]             base::options(...future.oldOptions)
[17:47:06.733]             if (.Platform$OS.type == "windows") {
[17:47:06.733]                 old_names <- names(...future.oldEnvVars)
[17:47:06.733]                 envs <- base::Sys.getenv()
[17:47:06.733]                 names <- names(envs)
[17:47:06.733]                 common <- intersect(names, old_names)
[17:47:06.733]                 added <- setdiff(names, old_names)
[17:47:06.733]                 removed <- setdiff(old_names, names)
[17:47:06.733]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.733]                   envs[common]]
[17:47:06.733]                 NAMES <- toupper(changed)
[17:47:06.733]                 args <- list()
[17:47:06.733]                 for (kk in seq_along(NAMES)) {
[17:47:06.733]                   name <- changed[[kk]]
[17:47:06.733]                   NAME <- NAMES[[kk]]
[17:47:06.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.733]                     next
[17:47:06.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.733]                 }
[17:47:06.733]                 NAMES <- toupper(added)
[17:47:06.733]                 for (kk in seq_along(NAMES)) {
[17:47:06.733]                   name <- added[[kk]]
[17:47:06.733]                   NAME <- NAMES[[kk]]
[17:47:06.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.733]                     next
[17:47:06.733]                   args[[name]] <- ""
[17:47:06.733]                 }
[17:47:06.733]                 NAMES <- toupper(removed)
[17:47:06.733]                 for (kk in seq_along(NAMES)) {
[17:47:06.733]                   name <- removed[[kk]]
[17:47:06.733]                   NAME <- NAMES[[kk]]
[17:47:06.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.733]                     next
[17:47:06.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.733]                 }
[17:47:06.733]                 if (length(args) > 0) 
[17:47:06.733]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.733]             }
[17:47:06.733]             else {
[17:47:06.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.733]             }
[17:47:06.733]             {
[17:47:06.733]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.733]                   0L) {
[17:47:06.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.733]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.733]                   base::options(opts)
[17:47:06.733]                 }
[17:47:06.733]                 {
[17:47:06.733]                   {
[17:47:06.733]                     NULL
[17:47:06.733]                     RNGkind("Mersenne-Twister")
[17:47:06.733]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.733]                       inherits = FALSE)
[17:47:06.733]                   }
[17:47:06.733]                   options(future.plan = NULL)
[17:47:06.733]                   if (is.na(NA_character_)) 
[17:47:06.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.733]                     .init = FALSE)
[17:47:06.733]                 }
[17:47:06.733]             }
[17:47:06.733]         }
[17:47:06.733]     })
[17:47:06.733]     if (TRUE) {
[17:47:06.733]         base::sink(type = "output", split = FALSE)
[17:47:06.733]         if (TRUE) {
[17:47:06.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.733]         }
[17:47:06.733]         else {
[17:47:06.733]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.733]         }
[17:47:06.733]         base::close(...future.stdout)
[17:47:06.733]         ...future.stdout <- NULL
[17:47:06.733]     }
[17:47:06.733]     ...future.result$conditions <- ...future.conditions
[17:47:06.733]     ...future.result$finished <- base::Sys.time()
[17:47:06.733]     ...future.result
[17:47:06.733] }
[17:47:06.760] plan(): Setting new future strategy stack:
[17:47:06.760] List of future strategies:
[17:47:06.760] 1. sequential:
[17:47:06.760]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.760]    - tweaked: FALSE
[17:47:06.760]    - call: NULL
[17:47:06.761] plan(): nbrOfWorkers() = 1
[17:47:06.762] plan(): Setting new future strategy stack:
[17:47:06.762] List of future strategies:
[17:47:06.762] 1. sequential:
[17:47:06.762]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.762]    - tweaked: FALSE
[17:47:06.762]    - call: plan(strategy)
[17:47:06.762] plan(): nbrOfWorkers() = 1
[17:47:06.763] SequentialFuture started (and completed)
[17:47:06.763] - Launch lazy future ... done
[17:47:06.763] run() for ‘SequentialFuture’ ... done
[17:47:06.763] resolved() for ‘SequentialFuture’ ...
[17:47:06.763] - state: ‘finished’
[17:47:06.763] - run: TRUE
[17:47:06.763] - result: ‘FutureResult’
[17:47:06.763] resolved() for ‘SequentialFuture’ ... done
[17:47:06.763] Future #1
[17:47:06.764] resolved() for ‘SequentialFuture’ ...
[17:47:06.764] - state: ‘finished’
[17:47:06.764] - run: TRUE
[17:47:06.764] - result: ‘FutureResult’
[17:47:06.764] resolved() for ‘SequentialFuture’ ... done
[17:47:06.764] A SequentialFuture was resolved
[17:47:06.764]  length: 0 (resolved future 1)
[17:47:06.764] resolve() on list ... DONE
[17:47:06.764] - globals: [1] ‘a’
[17:47:06.764] Resolving futures part of globals (recursively) ... DONE
[17:47:06.766] The total size of the 1 globals is 1.55 MiB (1622440 bytes)
[17:47:06.766] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:47:06.767] - globals: [1] ‘a’
[17:47:06.767] - packages: [1] ‘future’
[17:47:06.767] getGlobalsAndPackages() ... DONE
[17:47:06.767] run() for ‘Future’ ...
[17:47:06.767] - state: ‘created’
[17:47:06.767] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.768] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.768]   - Field: ‘label’
[17:47:06.768]   - Field: ‘local’
[17:47:06.768]   - Field: ‘owner’
[17:47:06.768]   - Field: ‘envir’
[17:47:06.768]   - Field: ‘packages’
[17:47:06.768]   - Field: ‘gc’
[17:47:06.768]   - Field: ‘conditions’
[17:47:06.768]   - Field: ‘expr’
[17:47:06.768]   - Field: ‘uuid’
[17:47:06.769]   - Field: ‘seed’
[17:47:06.769]   - Field: ‘version’
[17:47:06.769]   - Field: ‘result’
[17:47:06.769]   - Field: ‘asynchronous’
[17:47:06.769]   - Field: ‘calls’
[17:47:06.769]   - Field: ‘globals’
[17:47:06.769]   - Field: ‘stdout’
[17:47:06.769]   - Field: ‘earlySignal’
[17:47:06.769]   - Field: ‘lazy’
[17:47:06.769]   - Field: ‘state’
[17:47:06.769] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.770] - Launch lazy future ...
[17:47:06.770] Packages needed by the future expression (n = 1): ‘future’
[17:47:06.770] Packages needed by future strategies (n = 0): <none>
[17:47:06.770] {
[17:47:06.770]     {
[17:47:06.770]         {
[17:47:06.770]             ...future.startTime <- base::Sys.time()
[17:47:06.770]             {
[17:47:06.770]                 {
[17:47:06.770]                   {
[17:47:06.770]                     {
[17:47:06.770]                       base::local({
[17:47:06.770]                         has_future <- base::requireNamespace("future", 
[17:47:06.770]                           quietly = TRUE)
[17:47:06.770]                         if (has_future) {
[17:47:06.770]                           ns <- base::getNamespace("future")
[17:47:06.770]                           version <- ns[[".package"]][["version"]]
[17:47:06.770]                           if (is.null(version)) 
[17:47:06.770]                             version <- utils::packageVersion("future")
[17:47:06.770]                         }
[17:47:06.770]                         else {
[17:47:06.770]                           version <- NULL
[17:47:06.770]                         }
[17:47:06.770]                         if (!has_future || version < "1.8.0") {
[17:47:06.770]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.770]                             "", base::R.version$version.string), 
[17:47:06.770]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.770]                               "release", "version")], collapse = " "), 
[17:47:06.770]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.770]                             info)
[17:47:06.770]                           info <- base::paste(info, collapse = "; ")
[17:47:06.770]                           if (!has_future) {
[17:47:06.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.770]                               info)
[17:47:06.770]                           }
[17:47:06.770]                           else {
[17:47:06.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.770]                               info, version)
[17:47:06.770]                           }
[17:47:06.770]                           base::stop(msg)
[17:47:06.770]                         }
[17:47:06.770]                       })
[17:47:06.770]                     }
[17:47:06.770]                     base::local({
[17:47:06.770]                       for (pkg in "future") {
[17:47:06.770]                         base::loadNamespace(pkg)
[17:47:06.770]                         base::library(pkg, character.only = TRUE)
[17:47:06.770]                       }
[17:47:06.770]                     })
[17:47:06.770]                   }
[17:47:06.770]                   ...future.strategy.old <- future::plan("list")
[17:47:06.770]                   options(future.plan = NULL)
[17:47:06.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.770]                 }
[17:47:06.770]                 ...future.workdir <- getwd()
[17:47:06.770]             }
[17:47:06.770]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.770]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.770]         }
[17:47:06.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.770]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.770]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.770]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.770]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.770]             base::names(...future.oldOptions))
[17:47:06.770]     }
[17:47:06.770]     if (FALSE) {
[17:47:06.770]     }
[17:47:06.770]     else {
[17:47:06.770]         if (TRUE) {
[17:47:06.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.770]                 open = "w")
[17:47:06.770]         }
[17:47:06.770]         else {
[17:47:06.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.770]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.770]         }
[17:47:06.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.770]             base::sink(type = "output", split = FALSE)
[17:47:06.770]             base::close(...future.stdout)
[17:47:06.770]         }, add = TRUE)
[17:47:06.770]     }
[17:47:06.770]     ...future.frame <- base::sys.nframe()
[17:47:06.770]     ...future.conditions <- base::list()
[17:47:06.770]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.770]     if (FALSE) {
[17:47:06.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.770]     }
[17:47:06.770]     ...future.result <- base::tryCatch({
[17:47:06.770]         base::withCallingHandlers({
[17:47:06.770]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:47:06.770]                 1))
[17:47:06.770]             future::FutureResult(value = ...future.value$value, 
[17:47:06.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.770]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.770]                     ...future.globalenv.names))
[17:47:06.770]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.770]         }, condition = base::local({
[17:47:06.770]             c <- base::c
[17:47:06.770]             inherits <- base::inherits
[17:47:06.770]             invokeRestart <- base::invokeRestart
[17:47:06.770]             length <- base::length
[17:47:06.770]             list <- base::list
[17:47:06.770]             seq.int <- base::seq.int
[17:47:06.770]             signalCondition <- base::signalCondition
[17:47:06.770]             sys.calls <- base::sys.calls
[17:47:06.770]             `[[` <- base::`[[`
[17:47:06.770]             `+` <- base::`+`
[17:47:06.770]             `<<-` <- base::`<<-`
[17:47:06.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.770]                   3L)]
[17:47:06.770]             }
[17:47:06.770]             function(cond) {
[17:47:06.770]                 is_error <- inherits(cond, "error")
[17:47:06.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.770]                   NULL)
[17:47:06.770]                 if (is_error) {
[17:47:06.770]                   sessionInformation <- function() {
[17:47:06.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.770]                       search = base::search(), system = base::Sys.info())
[17:47:06.770]                   }
[17:47:06.770]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.770]                     cond$call), session = sessionInformation(), 
[17:47:06.770]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.770]                   signalCondition(cond)
[17:47:06.770]                 }
[17:47:06.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.770]                 "immediateCondition"))) {
[17:47:06.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.770]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.770]                   if (TRUE && !signal) {
[17:47:06.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.770]                     {
[17:47:06.770]                       inherits <- base::inherits
[17:47:06.770]                       invokeRestart <- base::invokeRestart
[17:47:06.770]                       is.null <- base::is.null
[17:47:06.770]                       muffled <- FALSE
[17:47:06.770]                       if (inherits(cond, "message")) {
[17:47:06.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.770]                         if (muffled) 
[17:47:06.770]                           invokeRestart("muffleMessage")
[17:47:06.770]                       }
[17:47:06.770]                       else if (inherits(cond, "warning")) {
[17:47:06.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.770]                         if (muffled) 
[17:47:06.770]                           invokeRestart("muffleWarning")
[17:47:06.770]                       }
[17:47:06.770]                       else if (inherits(cond, "condition")) {
[17:47:06.770]                         if (!is.null(pattern)) {
[17:47:06.770]                           computeRestarts <- base::computeRestarts
[17:47:06.770]                           grepl <- base::grepl
[17:47:06.770]                           restarts <- computeRestarts(cond)
[17:47:06.770]                           for (restart in restarts) {
[17:47:06.770]                             name <- restart$name
[17:47:06.770]                             if (is.null(name)) 
[17:47:06.770]                               next
[17:47:06.770]                             if (!grepl(pattern, name)) 
[17:47:06.770]                               next
[17:47:06.770]                             invokeRestart(restart)
[17:47:06.770]                             muffled <- TRUE
[17:47:06.770]                             break
[17:47:06.770]                           }
[17:47:06.770]                         }
[17:47:06.770]                       }
[17:47:06.770]                       invisible(muffled)
[17:47:06.770]                     }
[17:47:06.770]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.770]                   }
[17:47:06.770]                 }
[17:47:06.770]                 else {
[17:47:06.770]                   if (TRUE) {
[17:47:06.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.770]                     {
[17:47:06.770]                       inherits <- base::inherits
[17:47:06.770]                       invokeRestart <- base::invokeRestart
[17:47:06.770]                       is.null <- base::is.null
[17:47:06.770]                       muffled <- FALSE
[17:47:06.770]                       if (inherits(cond, "message")) {
[17:47:06.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.770]                         if (muffled) 
[17:47:06.770]                           invokeRestart("muffleMessage")
[17:47:06.770]                       }
[17:47:06.770]                       else if (inherits(cond, "warning")) {
[17:47:06.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.770]                         if (muffled) 
[17:47:06.770]                           invokeRestart("muffleWarning")
[17:47:06.770]                       }
[17:47:06.770]                       else if (inherits(cond, "condition")) {
[17:47:06.770]                         if (!is.null(pattern)) {
[17:47:06.770]                           computeRestarts <- base::computeRestarts
[17:47:06.770]                           grepl <- base::grepl
[17:47:06.770]                           restarts <- computeRestarts(cond)
[17:47:06.770]                           for (restart in restarts) {
[17:47:06.770]                             name <- restart$name
[17:47:06.770]                             if (is.null(name)) 
[17:47:06.770]                               next
[17:47:06.770]                             if (!grepl(pattern, name)) 
[17:47:06.770]                               next
[17:47:06.770]                             invokeRestart(restart)
[17:47:06.770]                             muffled <- TRUE
[17:47:06.770]                             break
[17:47:06.770]                           }
[17:47:06.770]                         }
[17:47:06.770]                       }
[17:47:06.770]                       invisible(muffled)
[17:47:06.770]                     }
[17:47:06.770]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.770]                   }
[17:47:06.770]                 }
[17:47:06.770]             }
[17:47:06.770]         }))
[17:47:06.770]     }, error = function(ex) {
[17:47:06.770]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.770]                 ...future.rng), started = ...future.startTime, 
[17:47:06.770]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.770]             version = "1.8"), class = "FutureResult")
[17:47:06.770]     }, finally = {
[17:47:06.770]         if (!identical(...future.workdir, getwd())) 
[17:47:06.770]             setwd(...future.workdir)
[17:47:06.770]         {
[17:47:06.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.770]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.770]             }
[17:47:06.770]             base::options(...future.oldOptions)
[17:47:06.770]             if (.Platform$OS.type == "windows") {
[17:47:06.770]                 old_names <- names(...future.oldEnvVars)
[17:47:06.770]                 envs <- base::Sys.getenv()
[17:47:06.770]                 names <- names(envs)
[17:47:06.770]                 common <- intersect(names, old_names)
[17:47:06.770]                 added <- setdiff(names, old_names)
[17:47:06.770]                 removed <- setdiff(old_names, names)
[17:47:06.770]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.770]                   envs[common]]
[17:47:06.770]                 NAMES <- toupper(changed)
[17:47:06.770]                 args <- list()
[17:47:06.770]                 for (kk in seq_along(NAMES)) {
[17:47:06.770]                   name <- changed[[kk]]
[17:47:06.770]                   NAME <- NAMES[[kk]]
[17:47:06.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.770]                     next
[17:47:06.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.770]                 }
[17:47:06.770]                 NAMES <- toupper(added)
[17:47:06.770]                 for (kk in seq_along(NAMES)) {
[17:47:06.770]                   name <- added[[kk]]
[17:47:06.770]                   NAME <- NAMES[[kk]]
[17:47:06.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.770]                     next
[17:47:06.770]                   args[[name]] <- ""
[17:47:06.770]                 }
[17:47:06.770]                 NAMES <- toupper(removed)
[17:47:06.770]                 for (kk in seq_along(NAMES)) {
[17:47:06.770]                   name <- removed[[kk]]
[17:47:06.770]                   NAME <- NAMES[[kk]]
[17:47:06.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.770]                     next
[17:47:06.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.770]                 }
[17:47:06.770]                 if (length(args) > 0) 
[17:47:06.770]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.770]             }
[17:47:06.770]             else {
[17:47:06.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.770]             }
[17:47:06.770]             {
[17:47:06.770]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.770]                   0L) {
[17:47:06.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.770]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.770]                   base::options(opts)
[17:47:06.770]                 }
[17:47:06.770]                 {
[17:47:06.770]                   {
[17:47:06.770]                     NULL
[17:47:06.770]                     RNGkind("Mersenne-Twister")
[17:47:06.770]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.770]                       inherits = FALSE)
[17:47:06.770]                   }
[17:47:06.770]                   options(future.plan = NULL)
[17:47:06.770]                   if (is.na(NA_character_)) 
[17:47:06.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.770]                     .init = FALSE)
[17:47:06.770]                 }
[17:47:06.770]             }
[17:47:06.770]         }
[17:47:06.770]     })
[17:47:06.770]     if (TRUE) {
[17:47:06.770]         base::sink(type = "output", split = FALSE)
[17:47:06.770]         if (TRUE) {
[17:47:06.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.770]         }
[17:47:06.770]         else {
[17:47:06.770]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.770]         }
[17:47:06.770]         base::close(...future.stdout)
[17:47:06.770]         ...future.stdout <- NULL
[17:47:06.770]     }
[17:47:06.770]     ...future.result$conditions <- ...future.conditions
[17:47:06.770]     ...future.result$finished <- base::Sys.time()
[17:47:06.770]     ...future.result
[17:47:06.770] }
[17:47:06.772] assign_globals() ...
[17:47:06.772] List of 1
[17:47:06.772]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558b32744a18> 
[17:47:06.772]  - attr(*, "where")=List of 1
[17:47:06.772]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.772]  - attr(*, "resolved")= logi TRUE
[17:47:06.772]  - attr(*, "total_size")= num 1622440
[17:47:06.772]  - attr(*, "already-done")= logi TRUE
[17:47:06.774] - copied ‘a’ to environment
[17:47:06.774] assign_globals() ... done
[17:47:06.775] plan(): Setting new future strategy stack:
[17:47:06.775] List of future strategies:
[17:47:06.775] 1. sequential:
[17:47:06.775]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.775]    - tweaked: FALSE
[17:47:06.775]    - call: NULL
[17:47:06.775] plan(): nbrOfWorkers() = 1
[17:47:06.776] plan(): Setting new future strategy stack:
[17:47:06.776] List of future strategies:
[17:47:06.776] 1. sequential:
[17:47:06.776]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.776]    - tweaked: FALSE
[17:47:06.776]    - call: plan(strategy)
[17:47:06.777] plan(): nbrOfWorkers() = 1
[17:47:06.777] SequentialFuture started (and completed)
[17:47:06.777] - Launch lazy future ... done
[17:47:06.777] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.777] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.778] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.778] 
[17:47:06.778] Searching for globals ... DONE
[17:47:06.778] - globals: [0] <none>
[17:47:06.778] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.779] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.779] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.779] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:06.780] Searching for globals ... DONE
[17:47:06.780] Resolving globals: TRUE
[17:47:06.780] Resolving any globals that are futures ...
[17:47:06.780] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:06.780] Resolving any globals that are futures ... DONE
[17:47:06.780] Resolving futures part of globals (recursively) ...
[17:47:06.780] resolve() on list ...
[17:47:06.781]  recursive: 99
[17:47:06.781]  length: 1
[17:47:06.781]  elements: ‘a’
[17:47:06.781] run() for ‘Future’ ...
[17:47:06.781] - state: ‘created’
[17:47:06.781] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.781] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.781] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.782]   - Field: ‘label’
[17:47:06.782]   - Field: ‘local’
[17:47:06.782]   - Field: ‘owner’
[17:47:06.782]   - Field: ‘envir’
[17:47:06.782]   - Field: ‘packages’
[17:47:06.782]   - Field: ‘gc’
[17:47:06.782]   - Field: ‘conditions’
[17:47:06.782]   - Field: ‘expr’
[17:47:06.782]   - Field: ‘uuid’
[17:47:06.782]   - Field: ‘seed’
[17:47:06.782]   - Field: ‘version’
[17:47:06.782]   - Field: ‘result’
[17:47:06.783]   - Field: ‘asynchronous’
[17:47:06.783]   - Field: ‘calls’
[17:47:06.783]   - Field: ‘globals’
[17:47:06.783]   - Field: ‘stdout’
[17:47:06.783]   - Field: ‘earlySignal’
[17:47:06.783]   - Field: ‘lazy’
[17:47:06.783]   - Field: ‘state’
[17:47:06.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.783] - Launch lazy future ...
[17:47:06.783] Packages needed by the future expression (n = 0): <none>
[17:47:06.784] Packages needed by future strategies (n = 0): <none>
[17:47:06.784] {
[17:47:06.784]     {
[17:47:06.784]         {
[17:47:06.784]             ...future.startTime <- base::Sys.time()
[17:47:06.784]             {
[17:47:06.784]                 {
[17:47:06.784]                   {
[17:47:06.784]                     base::local({
[17:47:06.784]                       has_future <- base::requireNamespace("future", 
[17:47:06.784]                         quietly = TRUE)
[17:47:06.784]                       if (has_future) {
[17:47:06.784]                         ns <- base::getNamespace("future")
[17:47:06.784]                         version <- ns[[".package"]][["version"]]
[17:47:06.784]                         if (is.null(version)) 
[17:47:06.784]                           version <- utils::packageVersion("future")
[17:47:06.784]                       }
[17:47:06.784]                       else {
[17:47:06.784]                         version <- NULL
[17:47:06.784]                       }
[17:47:06.784]                       if (!has_future || version < "1.8.0") {
[17:47:06.784]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.784]                           "", base::R.version$version.string), 
[17:47:06.784]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.784]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.784]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.784]                             "release", "version")], collapse = " "), 
[17:47:06.784]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.784]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.784]                           info)
[17:47:06.784]                         info <- base::paste(info, collapse = "; ")
[17:47:06.784]                         if (!has_future) {
[17:47:06.784]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.784]                             info)
[17:47:06.784]                         }
[17:47:06.784]                         else {
[17:47:06.784]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.784]                             info, version)
[17:47:06.784]                         }
[17:47:06.784]                         base::stop(msg)
[17:47:06.784]                       }
[17:47:06.784]                     })
[17:47:06.784]                   }
[17:47:06.784]                   ...future.strategy.old <- future::plan("list")
[17:47:06.784]                   options(future.plan = NULL)
[17:47:06.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.784]                 }
[17:47:06.784]                 ...future.workdir <- getwd()
[17:47:06.784]             }
[17:47:06.784]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.784]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.784]         }
[17:47:06.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.784]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.784]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.784]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.784]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.784]             base::names(...future.oldOptions))
[17:47:06.784]     }
[17:47:06.784]     if (FALSE) {
[17:47:06.784]     }
[17:47:06.784]     else {
[17:47:06.784]         if (TRUE) {
[17:47:06.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.784]                 open = "w")
[17:47:06.784]         }
[17:47:06.784]         else {
[17:47:06.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.784]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.784]         }
[17:47:06.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.784]             base::sink(type = "output", split = FALSE)
[17:47:06.784]             base::close(...future.stdout)
[17:47:06.784]         }, add = TRUE)
[17:47:06.784]     }
[17:47:06.784]     ...future.frame <- base::sys.nframe()
[17:47:06.784]     ...future.conditions <- base::list()
[17:47:06.784]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.784]     if (FALSE) {
[17:47:06.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.784]     }
[17:47:06.784]     ...future.result <- base::tryCatch({
[17:47:06.784]         base::withCallingHandlers({
[17:47:06.784]             ...future.value <- base::withVisible(base::local(1))
[17:47:06.784]             future::FutureResult(value = ...future.value$value, 
[17:47:06.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.784]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.784]                     ...future.globalenv.names))
[17:47:06.784]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.784]         }, condition = base::local({
[17:47:06.784]             c <- base::c
[17:47:06.784]             inherits <- base::inherits
[17:47:06.784]             invokeRestart <- base::invokeRestart
[17:47:06.784]             length <- base::length
[17:47:06.784]             list <- base::list
[17:47:06.784]             seq.int <- base::seq.int
[17:47:06.784]             signalCondition <- base::signalCondition
[17:47:06.784]             sys.calls <- base::sys.calls
[17:47:06.784]             `[[` <- base::`[[`
[17:47:06.784]             `+` <- base::`+`
[17:47:06.784]             `<<-` <- base::`<<-`
[17:47:06.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.784]                   3L)]
[17:47:06.784]             }
[17:47:06.784]             function(cond) {
[17:47:06.784]                 is_error <- inherits(cond, "error")
[17:47:06.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.784]                   NULL)
[17:47:06.784]                 if (is_error) {
[17:47:06.784]                   sessionInformation <- function() {
[17:47:06.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.784]                       search = base::search(), system = base::Sys.info())
[17:47:06.784]                   }
[17:47:06.784]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.784]                     cond$call), session = sessionInformation(), 
[17:47:06.784]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.784]                   signalCondition(cond)
[17:47:06.784]                 }
[17:47:06.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.784]                 "immediateCondition"))) {
[17:47:06.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.784]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.784]                   if (TRUE && !signal) {
[17:47:06.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.784]                     {
[17:47:06.784]                       inherits <- base::inherits
[17:47:06.784]                       invokeRestart <- base::invokeRestart
[17:47:06.784]                       is.null <- base::is.null
[17:47:06.784]                       muffled <- FALSE
[17:47:06.784]                       if (inherits(cond, "message")) {
[17:47:06.784]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.784]                         if (muffled) 
[17:47:06.784]                           invokeRestart("muffleMessage")
[17:47:06.784]                       }
[17:47:06.784]                       else if (inherits(cond, "warning")) {
[17:47:06.784]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.784]                         if (muffled) 
[17:47:06.784]                           invokeRestart("muffleWarning")
[17:47:06.784]                       }
[17:47:06.784]                       else if (inherits(cond, "condition")) {
[17:47:06.784]                         if (!is.null(pattern)) {
[17:47:06.784]                           computeRestarts <- base::computeRestarts
[17:47:06.784]                           grepl <- base::grepl
[17:47:06.784]                           restarts <- computeRestarts(cond)
[17:47:06.784]                           for (restart in restarts) {
[17:47:06.784]                             name <- restart$name
[17:47:06.784]                             if (is.null(name)) 
[17:47:06.784]                               next
[17:47:06.784]                             if (!grepl(pattern, name)) 
[17:47:06.784]                               next
[17:47:06.784]                             invokeRestart(restart)
[17:47:06.784]                             muffled <- TRUE
[17:47:06.784]                             break
[17:47:06.784]                           }
[17:47:06.784]                         }
[17:47:06.784]                       }
[17:47:06.784]                       invisible(muffled)
[17:47:06.784]                     }
[17:47:06.784]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.784]                   }
[17:47:06.784]                 }
[17:47:06.784]                 else {
[17:47:06.784]                   if (TRUE) {
[17:47:06.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.784]                     {
[17:47:06.784]                       inherits <- base::inherits
[17:47:06.784]                       invokeRestart <- base::invokeRestart
[17:47:06.784]                       is.null <- base::is.null
[17:47:06.784]                       muffled <- FALSE
[17:47:06.784]                       if (inherits(cond, "message")) {
[17:47:06.784]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.784]                         if (muffled) 
[17:47:06.784]                           invokeRestart("muffleMessage")
[17:47:06.784]                       }
[17:47:06.784]                       else if (inherits(cond, "warning")) {
[17:47:06.784]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.784]                         if (muffled) 
[17:47:06.784]                           invokeRestart("muffleWarning")
[17:47:06.784]                       }
[17:47:06.784]                       else if (inherits(cond, "condition")) {
[17:47:06.784]                         if (!is.null(pattern)) {
[17:47:06.784]                           computeRestarts <- base::computeRestarts
[17:47:06.784]                           grepl <- base::grepl
[17:47:06.784]                           restarts <- computeRestarts(cond)
[17:47:06.784]                           for (restart in restarts) {
[17:47:06.784]                             name <- restart$name
[17:47:06.784]                             if (is.null(name)) 
[17:47:06.784]                               next
[17:47:06.784]                             if (!grepl(pattern, name)) 
[17:47:06.784]                               next
[17:47:06.784]                             invokeRestart(restart)
[17:47:06.784]                             muffled <- TRUE
[17:47:06.784]                             break
[17:47:06.784]                           }
[17:47:06.784]                         }
[17:47:06.784]                       }
[17:47:06.784]                       invisible(muffled)
[17:47:06.784]                     }
[17:47:06.784]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.784]                   }
[17:47:06.784]                 }
[17:47:06.784]             }
[17:47:06.784]         }))
[17:47:06.784]     }, error = function(ex) {
[17:47:06.784]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.784]                 ...future.rng), started = ...future.startTime, 
[17:47:06.784]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.784]             version = "1.8"), class = "FutureResult")
[17:47:06.784]     }, finally = {
[17:47:06.784]         if (!identical(...future.workdir, getwd())) 
[17:47:06.784]             setwd(...future.workdir)
[17:47:06.784]         {
[17:47:06.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.784]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.784]             }
[17:47:06.784]             base::options(...future.oldOptions)
[17:47:06.784]             if (.Platform$OS.type == "windows") {
[17:47:06.784]                 old_names <- names(...future.oldEnvVars)
[17:47:06.784]                 envs <- base::Sys.getenv()
[17:47:06.784]                 names <- names(envs)
[17:47:06.784]                 common <- intersect(names, old_names)
[17:47:06.784]                 added <- setdiff(names, old_names)
[17:47:06.784]                 removed <- setdiff(old_names, names)
[17:47:06.784]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.784]                   envs[common]]
[17:47:06.784]                 NAMES <- toupper(changed)
[17:47:06.784]                 args <- list()
[17:47:06.784]                 for (kk in seq_along(NAMES)) {
[17:47:06.784]                   name <- changed[[kk]]
[17:47:06.784]                   NAME <- NAMES[[kk]]
[17:47:06.784]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.784]                     next
[17:47:06.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.784]                 }
[17:47:06.784]                 NAMES <- toupper(added)
[17:47:06.784]                 for (kk in seq_along(NAMES)) {
[17:47:06.784]                   name <- added[[kk]]
[17:47:06.784]                   NAME <- NAMES[[kk]]
[17:47:06.784]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.784]                     next
[17:47:06.784]                   args[[name]] <- ""
[17:47:06.784]                 }
[17:47:06.784]                 NAMES <- toupper(removed)
[17:47:06.784]                 for (kk in seq_along(NAMES)) {
[17:47:06.784]                   name <- removed[[kk]]
[17:47:06.784]                   NAME <- NAMES[[kk]]
[17:47:06.784]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.784]                     next
[17:47:06.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.784]                 }
[17:47:06.784]                 if (length(args) > 0) 
[17:47:06.784]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.784]             }
[17:47:06.784]             else {
[17:47:06.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.784]             }
[17:47:06.784]             {
[17:47:06.784]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.784]                   0L) {
[17:47:06.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.784]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.784]                   base::options(opts)
[17:47:06.784]                 }
[17:47:06.784]                 {
[17:47:06.784]                   {
[17:47:06.784]                     NULL
[17:47:06.784]                     RNGkind("Mersenne-Twister")
[17:47:06.784]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.784]                       inherits = FALSE)
[17:47:06.784]                   }
[17:47:06.784]                   options(future.plan = NULL)
[17:47:06.784]                   if (is.na(NA_character_)) 
[17:47:06.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.784]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.784]                     .init = FALSE)
[17:47:06.784]                 }
[17:47:06.784]             }
[17:47:06.784]         }
[17:47:06.784]     })
[17:47:06.784]     if (TRUE) {
[17:47:06.784]         base::sink(type = "output", split = FALSE)
[17:47:06.784]         if (TRUE) {
[17:47:06.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.784]         }
[17:47:06.784]         else {
[17:47:06.784]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.784]         }
[17:47:06.784]         base::close(...future.stdout)
[17:47:06.784]         ...future.stdout <- NULL
[17:47:06.784]     }
[17:47:06.784]     ...future.result$conditions <- ...future.conditions
[17:47:06.784]     ...future.result$finished <- base::Sys.time()
[17:47:06.784]     ...future.result
[17:47:06.784] }
[17:47:06.786] plan(): Setting new future strategy stack:
[17:47:06.786] List of future strategies:
[17:47:06.786] 1. sequential:
[17:47:06.786]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.786]    - tweaked: FALSE
[17:47:06.786]    - call: NULL
[17:47:06.786] plan(): nbrOfWorkers() = 1
[17:47:06.787] plan(): Setting new future strategy stack:
[17:47:06.787] List of future strategies:
[17:47:06.787] 1. sequential:
[17:47:06.787]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.787]    - tweaked: FALSE
[17:47:06.787]    - call: plan(strategy)
[17:47:06.787] plan(): nbrOfWorkers() = 1
[17:47:06.788] SequentialFuture started (and completed)
[17:47:06.788] - Launch lazy future ... done
[17:47:06.788] run() for ‘SequentialFuture’ ... done
[17:47:06.788] resolved() for ‘SequentialFuture’ ...
[17:47:06.788] - state: ‘finished’
[17:47:06.788] - run: TRUE
[17:47:06.788] - result: ‘FutureResult’
[17:47:06.788] resolved() for ‘SequentialFuture’ ... done
[17:47:06.788] Future #1
[17:47:06.789] resolved() for ‘SequentialFuture’ ...
[17:47:06.789] - state: ‘finished’
[17:47:06.790] - run: TRUE
[17:47:06.790] - result: ‘FutureResult’
[17:47:06.790] resolved() for ‘SequentialFuture’ ... done
[17:47:06.790] A SequentialFuture was resolved
[17:47:06.790]  length: 0 (resolved future 1)
[17:47:06.790] resolve() on list ... DONE
[17:47:06.791] - globals: [1] ‘a’
[17:47:06.791] Resolving futures part of globals (recursively) ... DONE
[17:47:06.792] The total size of the 1 globals is 1.55 MiB (1622440 bytes)
[17:47:06.793] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:47:06.793] - globals: [1] ‘a’
[17:47:06.793] - packages: [1] ‘future’
[17:47:06.793] getGlobalsAndPackages() ... DONE
[17:47:06.793] run() for ‘Future’ ...
[17:47:06.794] - state: ‘created’
[17:47:06.794] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.794] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.794] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.794]   - Field: ‘label’
[17:47:06.794]   - Field: ‘local’
[17:47:06.794]   - Field: ‘owner’
[17:47:06.794]   - Field: ‘envir’
[17:47:06.794]   - Field: ‘packages’
[17:47:06.795]   - Field: ‘gc’
[17:47:06.795]   - Field: ‘conditions’
[17:47:06.795]   - Field: ‘expr’
[17:47:06.795]   - Field: ‘uuid’
[17:47:06.795]   - Field: ‘seed’
[17:47:06.795]   - Field: ‘version’
[17:47:06.795]   - Field: ‘result’
[17:47:06.795]   - Field: ‘asynchronous’
[17:47:06.795]   - Field: ‘calls’
[17:47:06.795]   - Field: ‘globals’
[17:47:06.795]   - Field: ‘stdout’
[17:47:06.796]   - Field: ‘earlySignal’
[17:47:06.796]   - Field: ‘lazy’
[17:47:06.796]   - Field: ‘state’
[17:47:06.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.796] - Launch lazy future ...
[17:47:06.796] Packages needed by the future expression (n = 1): ‘future’
[17:47:06.796] Packages needed by future strategies (n = 0): <none>
[17:47:06.797] {
[17:47:06.797]     {
[17:47:06.797]         {
[17:47:06.797]             ...future.startTime <- base::Sys.time()
[17:47:06.797]             {
[17:47:06.797]                 {
[17:47:06.797]                   {
[17:47:06.797]                     {
[17:47:06.797]                       base::local({
[17:47:06.797]                         has_future <- base::requireNamespace("future", 
[17:47:06.797]                           quietly = TRUE)
[17:47:06.797]                         if (has_future) {
[17:47:06.797]                           ns <- base::getNamespace("future")
[17:47:06.797]                           version <- ns[[".package"]][["version"]]
[17:47:06.797]                           if (is.null(version)) 
[17:47:06.797]                             version <- utils::packageVersion("future")
[17:47:06.797]                         }
[17:47:06.797]                         else {
[17:47:06.797]                           version <- NULL
[17:47:06.797]                         }
[17:47:06.797]                         if (!has_future || version < "1.8.0") {
[17:47:06.797]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.797]                             "", base::R.version$version.string), 
[17:47:06.797]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.797]                               "release", "version")], collapse = " "), 
[17:47:06.797]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.797]                             info)
[17:47:06.797]                           info <- base::paste(info, collapse = "; ")
[17:47:06.797]                           if (!has_future) {
[17:47:06.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.797]                               info)
[17:47:06.797]                           }
[17:47:06.797]                           else {
[17:47:06.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.797]                               info, version)
[17:47:06.797]                           }
[17:47:06.797]                           base::stop(msg)
[17:47:06.797]                         }
[17:47:06.797]                       })
[17:47:06.797]                     }
[17:47:06.797]                     base::local({
[17:47:06.797]                       for (pkg in "future") {
[17:47:06.797]                         base::loadNamespace(pkg)
[17:47:06.797]                         base::library(pkg, character.only = TRUE)
[17:47:06.797]                       }
[17:47:06.797]                     })
[17:47:06.797]                   }
[17:47:06.797]                   ...future.strategy.old <- future::plan("list")
[17:47:06.797]                   options(future.plan = NULL)
[17:47:06.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.797]                 }
[17:47:06.797]                 ...future.workdir <- getwd()
[17:47:06.797]             }
[17:47:06.797]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.797]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.797]         }
[17:47:06.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.797]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.797]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.797]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.797]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.797]             base::names(...future.oldOptions))
[17:47:06.797]     }
[17:47:06.797]     if (FALSE) {
[17:47:06.797]     }
[17:47:06.797]     else {
[17:47:06.797]         if (TRUE) {
[17:47:06.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.797]                 open = "w")
[17:47:06.797]         }
[17:47:06.797]         else {
[17:47:06.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.797]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.797]         }
[17:47:06.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.797]             base::sink(type = "output", split = FALSE)
[17:47:06.797]             base::close(...future.stdout)
[17:47:06.797]         }, add = TRUE)
[17:47:06.797]     }
[17:47:06.797]     ...future.frame <- base::sys.nframe()
[17:47:06.797]     ...future.conditions <- base::list()
[17:47:06.797]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.797]     if (FALSE) {
[17:47:06.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.797]     }
[17:47:06.797]     ...future.result <- base::tryCatch({
[17:47:06.797]         base::withCallingHandlers({
[17:47:06.797]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:47:06.797]                 1))
[17:47:06.797]             future::FutureResult(value = ...future.value$value, 
[17:47:06.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.797]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.797]                     ...future.globalenv.names))
[17:47:06.797]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.797]         }, condition = base::local({
[17:47:06.797]             c <- base::c
[17:47:06.797]             inherits <- base::inherits
[17:47:06.797]             invokeRestart <- base::invokeRestart
[17:47:06.797]             length <- base::length
[17:47:06.797]             list <- base::list
[17:47:06.797]             seq.int <- base::seq.int
[17:47:06.797]             signalCondition <- base::signalCondition
[17:47:06.797]             sys.calls <- base::sys.calls
[17:47:06.797]             `[[` <- base::`[[`
[17:47:06.797]             `+` <- base::`+`
[17:47:06.797]             `<<-` <- base::`<<-`
[17:47:06.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.797]                   3L)]
[17:47:06.797]             }
[17:47:06.797]             function(cond) {
[17:47:06.797]                 is_error <- inherits(cond, "error")
[17:47:06.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.797]                   NULL)
[17:47:06.797]                 if (is_error) {
[17:47:06.797]                   sessionInformation <- function() {
[17:47:06.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.797]                       search = base::search(), system = base::Sys.info())
[17:47:06.797]                   }
[17:47:06.797]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.797]                     cond$call), session = sessionInformation(), 
[17:47:06.797]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.797]                   signalCondition(cond)
[17:47:06.797]                 }
[17:47:06.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.797]                 "immediateCondition"))) {
[17:47:06.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.797]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.797]                   if (TRUE && !signal) {
[17:47:06.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.797]                     {
[17:47:06.797]                       inherits <- base::inherits
[17:47:06.797]                       invokeRestart <- base::invokeRestart
[17:47:06.797]                       is.null <- base::is.null
[17:47:06.797]                       muffled <- FALSE
[17:47:06.797]                       if (inherits(cond, "message")) {
[17:47:06.797]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.797]                         if (muffled) 
[17:47:06.797]                           invokeRestart("muffleMessage")
[17:47:06.797]                       }
[17:47:06.797]                       else if (inherits(cond, "warning")) {
[17:47:06.797]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.797]                         if (muffled) 
[17:47:06.797]                           invokeRestart("muffleWarning")
[17:47:06.797]                       }
[17:47:06.797]                       else if (inherits(cond, "condition")) {
[17:47:06.797]                         if (!is.null(pattern)) {
[17:47:06.797]                           computeRestarts <- base::computeRestarts
[17:47:06.797]                           grepl <- base::grepl
[17:47:06.797]                           restarts <- computeRestarts(cond)
[17:47:06.797]                           for (restart in restarts) {
[17:47:06.797]                             name <- restart$name
[17:47:06.797]                             if (is.null(name)) 
[17:47:06.797]                               next
[17:47:06.797]                             if (!grepl(pattern, name)) 
[17:47:06.797]                               next
[17:47:06.797]                             invokeRestart(restart)
[17:47:06.797]                             muffled <- TRUE
[17:47:06.797]                             break
[17:47:06.797]                           }
[17:47:06.797]                         }
[17:47:06.797]                       }
[17:47:06.797]                       invisible(muffled)
[17:47:06.797]                     }
[17:47:06.797]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.797]                   }
[17:47:06.797]                 }
[17:47:06.797]                 else {
[17:47:06.797]                   if (TRUE) {
[17:47:06.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.797]                     {
[17:47:06.797]                       inherits <- base::inherits
[17:47:06.797]                       invokeRestart <- base::invokeRestart
[17:47:06.797]                       is.null <- base::is.null
[17:47:06.797]                       muffled <- FALSE
[17:47:06.797]                       if (inherits(cond, "message")) {
[17:47:06.797]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.797]                         if (muffled) 
[17:47:06.797]                           invokeRestart("muffleMessage")
[17:47:06.797]                       }
[17:47:06.797]                       else if (inherits(cond, "warning")) {
[17:47:06.797]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.797]                         if (muffled) 
[17:47:06.797]                           invokeRestart("muffleWarning")
[17:47:06.797]                       }
[17:47:06.797]                       else if (inherits(cond, "condition")) {
[17:47:06.797]                         if (!is.null(pattern)) {
[17:47:06.797]                           computeRestarts <- base::computeRestarts
[17:47:06.797]                           grepl <- base::grepl
[17:47:06.797]                           restarts <- computeRestarts(cond)
[17:47:06.797]                           for (restart in restarts) {
[17:47:06.797]                             name <- restart$name
[17:47:06.797]                             if (is.null(name)) 
[17:47:06.797]                               next
[17:47:06.797]                             if (!grepl(pattern, name)) 
[17:47:06.797]                               next
[17:47:06.797]                             invokeRestart(restart)
[17:47:06.797]                             muffled <- TRUE
[17:47:06.797]                             break
[17:47:06.797]                           }
[17:47:06.797]                         }
[17:47:06.797]                       }
[17:47:06.797]                       invisible(muffled)
[17:47:06.797]                     }
[17:47:06.797]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.797]                   }
[17:47:06.797]                 }
[17:47:06.797]             }
[17:47:06.797]         }))
[17:47:06.797]     }, error = function(ex) {
[17:47:06.797]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.797]                 ...future.rng), started = ...future.startTime, 
[17:47:06.797]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.797]             version = "1.8"), class = "FutureResult")
[17:47:06.797]     }, finally = {
[17:47:06.797]         if (!identical(...future.workdir, getwd())) 
[17:47:06.797]             setwd(...future.workdir)
[17:47:06.797]         {
[17:47:06.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.797]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.797]             }
[17:47:06.797]             base::options(...future.oldOptions)
[17:47:06.797]             if (.Platform$OS.type == "windows") {
[17:47:06.797]                 old_names <- names(...future.oldEnvVars)
[17:47:06.797]                 envs <- base::Sys.getenv()
[17:47:06.797]                 names <- names(envs)
[17:47:06.797]                 common <- intersect(names, old_names)
[17:47:06.797]                 added <- setdiff(names, old_names)
[17:47:06.797]                 removed <- setdiff(old_names, names)
[17:47:06.797]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.797]                   envs[common]]
[17:47:06.797]                 NAMES <- toupper(changed)
[17:47:06.797]                 args <- list()
[17:47:06.797]                 for (kk in seq_along(NAMES)) {
[17:47:06.797]                   name <- changed[[kk]]
[17:47:06.797]                   NAME <- NAMES[[kk]]
[17:47:06.797]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.797]                     next
[17:47:06.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.797]                 }
[17:47:06.797]                 NAMES <- toupper(added)
[17:47:06.797]                 for (kk in seq_along(NAMES)) {
[17:47:06.797]                   name <- added[[kk]]
[17:47:06.797]                   NAME <- NAMES[[kk]]
[17:47:06.797]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.797]                     next
[17:47:06.797]                   args[[name]] <- ""
[17:47:06.797]                 }
[17:47:06.797]                 NAMES <- toupper(removed)
[17:47:06.797]                 for (kk in seq_along(NAMES)) {
[17:47:06.797]                   name <- removed[[kk]]
[17:47:06.797]                   NAME <- NAMES[[kk]]
[17:47:06.797]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.797]                     next
[17:47:06.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.797]                 }
[17:47:06.797]                 if (length(args) > 0) 
[17:47:06.797]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.797]             }
[17:47:06.797]             else {
[17:47:06.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.797]             }
[17:47:06.797]             {
[17:47:06.797]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.797]                   0L) {
[17:47:06.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.797]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.797]                   base::options(opts)
[17:47:06.797]                 }
[17:47:06.797]                 {
[17:47:06.797]                   {
[17:47:06.797]                     NULL
[17:47:06.797]                     RNGkind("Mersenne-Twister")
[17:47:06.797]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.797]                       inherits = FALSE)
[17:47:06.797]                   }
[17:47:06.797]                   options(future.plan = NULL)
[17:47:06.797]                   if (is.na(NA_character_)) 
[17:47:06.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.797]                     .init = FALSE)
[17:47:06.797]                 }
[17:47:06.797]             }
[17:47:06.797]         }
[17:47:06.797]     })
[17:47:06.797]     if (TRUE) {
[17:47:06.797]         base::sink(type = "output", split = FALSE)
[17:47:06.797]         if (TRUE) {
[17:47:06.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.797]         }
[17:47:06.797]         else {
[17:47:06.797]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.797]         }
[17:47:06.797]         base::close(...future.stdout)
[17:47:06.797]         ...future.stdout <- NULL
[17:47:06.797]     }
[17:47:06.797]     ...future.result$conditions <- ...future.conditions
[17:47:06.797]     ...future.result$finished <- base::Sys.time()
[17:47:06.797]     ...future.result
[17:47:06.797] }
[17:47:06.798] assign_globals() ...
[17:47:06.798] List of 1
[17:47:06.798]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x558b325d1108> 
[17:47:06.798]  - attr(*, "where")=List of 1
[17:47:06.798]   ..$ a:<environment: R_EmptyEnv> 
[17:47:06.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.798]  - attr(*, "resolved")= logi TRUE
[17:47:06.798]  - attr(*, "total_size")= num 1622440
[17:47:06.798]  - attr(*, "already-done")= logi TRUE
[17:47:06.801] - copied ‘a’ to environment
[17:47:06.801] assign_globals() ... done
[17:47:06.801] plan(): Setting new future strategy stack:
[17:47:06.801] List of future strategies:
[17:47:06.801] 1. sequential:
[17:47:06.801]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.801]    - tweaked: FALSE
[17:47:06.801]    - call: NULL
[17:47:06.802] plan(): nbrOfWorkers() = 1
[17:47:06.802] plan(): Setting new future strategy stack:
[17:47:06.802] List of future strategies:
[17:47:06.802] 1. sequential:
[17:47:06.802]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.802]    - tweaked: FALSE
[17:47:06.802]    - call: plan(strategy)
[17:47:06.803] plan(): nbrOfWorkers() = 1
[17:47:06.803] SequentialFuture started (and completed)
[17:47:06.803] - Launch lazy future ... done
[17:47:06.803] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.804] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.804] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.805] - globals found: [2] ‘{’, ‘pkg’
[17:47:06.805] Searching for globals ... DONE
[17:47:06.805] Resolving globals: TRUE
[17:47:06.805] Resolving any globals that are futures ...
[17:47:06.805] - globals: [2] ‘{’, ‘pkg’
[17:47:06.805] Resolving any globals that are futures ... DONE
[17:47:06.805] Resolving futures part of globals (recursively) ...
[17:47:06.806] resolve() on list ...
[17:47:06.806]  recursive: 99
[17:47:06.806]  length: 1
[17:47:06.806]  elements: ‘pkg’
[17:47:06.806]  length: 0 (resolved future 1)
[17:47:06.806] resolve() on list ... DONE
[17:47:06.806] - globals: [1] ‘pkg’
[17:47:06.806] Resolving futures part of globals (recursively) ... DONE
[17:47:06.806] The total size of the 1 globals is 112 bytes (112 bytes)
[17:47:06.807] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:47:06.807] - globals: [1] ‘pkg’
[17:47:06.807] 
[17:47:06.807] getGlobalsAndPackages() ... DONE
[17:47:06.807] Packages needed by the future expression (n = 0): <none>
[17:47:06.807] Packages needed by future strategies (n = 0): <none>
[17:47:06.808] {
[17:47:06.808]     {
[17:47:06.808]         {
[17:47:06.808]             ...future.startTime <- base::Sys.time()
[17:47:06.808]             {
[17:47:06.808]                 {
[17:47:06.808]                   {
[17:47:06.808]                     base::local({
[17:47:06.808]                       has_future <- base::requireNamespace("future", 
[17:47:06.808]                         quietly = TRUE)
[17:47:06.808]                       if (has_future) {
[17:47:06.808]                         ns <- base::getNamespace("future")
[17:47:06.808]                         version <- ns[[".package"]][["version"]]
[17:47:06.808]                         if (is.null(version)) 
[17:47:06.808]                           version <- utils::packageVersion("future")
[17:47:06.808]                       }
[17:47:06.808]                       else {
[17:47:06.808]                         version <- NULL
[17:47:06.808]                       }
[17:47:06.808]                       if (!has_future || version < "1.8.0") {
[17:47:06.808]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.808]                           "", base::R.version$version.string), 
[17:47:06.808]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.808]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.808]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.808]                             "release", "version")], collapse = " "), 
[17:47:06.808]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.808]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.808]                           info)
[17:47:06.808]                         info <- base::paste(info, collapse = "; ")
[17:47:06.808]                         if (!has_future) {
[17:47:06.808]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.808]                             info)
[17:47:06.808]                         }
[17:47:06.808]                         else {
[17:47:06.808]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.808]                             info, version)
[17:47:06.808]                         }
[17:47:06.808]                         base::stop(msg)
[17:47:06.808]                       }
[17:47:06.808]                     })
[17:47:06.808]                   }
[17:47:06.808]                   ...future.strategy.old <- future::plan("list")
[17:47:06.808]                   options(future.plan = NULL)
[17:47:06.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.808]                 }
[17:47:06.808]                 ...future.workdir <- getwd()
[17:47:06.808]             }
[17:47:06.808]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.808]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.808]         }
[17:47:06.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.808]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.808]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.808]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.808]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.808]             base::names(...future.oldOptions))
[17:47:06.808]     }
[17:47:06.808]     if (FALSE) {
[17:47:06.808]     }
[17:47:06.808]     else {
[17:47:06.808]         if (TRUE) {
[17:47:06.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.808]                 open = "w")
[17:47:06.808]         }
[17:47:06.808]         else {
[17:47:06.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.808]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.808]         }
[17:47:06.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.808]             base::sink(type = "output", split = FALSE)
[17:47:06.808]             base::close(...future.stdout)
[17:47:06.808]         }, add = TRUE)
[17:47:06.808]     }
[17:47:06.808]     ...future.frame <- base::sys.nframe()
[17:47:06.808]     ...future.conditions <- base::list()
[17:47:06.808]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.808]     if (FALSE) {
[17:47:06.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.808]     }
[17:47:06.808]     ...future.result <- base::tryCatch({
[17:47:06.808]         base::withCallingHandlers({
[17:47:06.808]             ...future.value <- base::withVisible(base::local({
[17:47:06.808]                 pkg
[17:47:06.808]             }))
[17:47:06.808]             future::FutureResult(value = ...future.value$value, 
[17:47:06.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.808]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.808]                     ...future.globalenv.names))
[17:47:06.808]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.808]         }, condition = base::local({
[17:47:06.808]             c <- base::c
[17:47:06.808]             inherits <- base::inherits
[17:47:06.808]             invokeRestart <- base::invokeRestart
[17:47:06.808]             length <- base::length
[17:47:06.808]             list <- base::list
[17:47:06.808]             seq.int <- base::seq.int
[17:47:06.808]             signalCondition <- base::signalCondition
[17:47:06.808]             sys.calls <- base::sys.calls
[17:47:06.808]             `[[` <- base::`[[`
[17:47:06.808]             `+` <- base::`+`
[17:47:06.808]             `<<-` <- base::`<<-`
[17:47:06.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.808]                   3L)]
[17:47:06.808]             }
[17:47:06.808]             function(cond) {
[17:47:06.808]                 is_error <- inherits(cond, "error")
[17:47:06.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.808]                   NULL)
[17:47:06.808]                 if (is_error) {
[17:47:06.808]                   sessionInformation <- function() {
[17:47:06.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.808]                       search = base::search(), system = base::Sys.info())
[17:47:06.808]                   }
[17:47:06.808]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.808]                     cond$call), session = sessionInformation(), 
[17:47:06.808]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.808]                   signalCondition(cond)
[17:47:06.808]                 }
[17:47:06.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.808]                 "immediateCondition"))) {
[17:47:06.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.808]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.808]                   if (TRUE && !signal) {
[17:47:06.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.808]                     {
[17:47:06.808]                       inherits <- base::inherits
[17:47:06.808]                       invokeRestart <- base::invokeRestart
[17:47:06.808]                       is.null <- base::is.null
[17:47:06.808]                       muffled <- FALSE
[17:47:06.808]                       if (inherits(cond, "message")) {
[17:47:06.808]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.808]                         if (muffled) 
[17:47:06.808]                           invokeRestart("muffleMessage")
[17:47:06.808]                       }
[17:47:06.808]                       else if (inherits(cond, "warning")) {
[17:47:06.808]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.808]                         if (muffled) 
[17:47:06.808]                           invokeRestart("muffleWarning")
[17:47:06.808]                       }
[17:47:06.808]                       else if (inherits(cond, "condition")) {
[17:47:06.808]                         if (!is.null(pattern)) {
[17:47:06.808]                           computeRestarts <- base::computeRestarts
[17:47:06.808]                           grepl <- base::grepl
[17:47:06.808]                           restarts <- computeRestarts(cond)
[17:47:06.808]                           for (restart in restarts) {
[17:47:06.808]                             name <- restart$name
[17:47:06.808]                             if (is.null(name)) 
[17:47:06.808]                               next
[17:47:06.808]                             if (!grepl(pattern, name)) 
[17:47:06.808]                               next
[17:47:06.808]                             invokeRestart(restart)
[17:47:06.808]                             muffled <- TRUE
[17:47:06.808]                             break
[17:47:06.808]                           }
[17:47:06.808]                         }
[17:47:06.808]                       }
[17:47:06.808]                       invisible(muffled)
[17:47:06.808]                     }
[17:47:06.808]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.808]                   }
[17:47:06.808]                 }
[17:47:06.808]                 else {
[17:47:06.808]                   if (TRUE) {
[17:47:06.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.808]                     {
[17:47:06.808]                       inherits <- base::inherits
[17:47:06.808]                       invokeRestart <- base::invokeRestart
[17:47:06.808]                       is.null <- base::is.null
[17:47:06.808]                       muffled <- FALSE
[17:47:06.808]                       if (inherits(cond, "message")) {
[17:47:06.808]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.808]                         if (muffled) 
[17:47:06.808]                           invokeRestart("muffleMessage")
[17:47:06.808]                       }
[17:47:06.808]                       else if (inherits(cond, "warning")) {
[17:47:06.808]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.808]                         if (muffled) 
[17:47:06.808]                           invokeRestart("muffleWarning")
[17:47:06.808]                       }
[17:47:06.808]                       else if (inherits(cond, "condition")) {
[17:47:06.808]                         if (!is.null(pattern)) {
[17:47:06.808]                           computeRestarts <- base::computeRestarts
[17:47:06.808]                           grepl <- base::grepl
[17:47:06.808]                           restarts <- computeRestarts(cond)
[17:47:06.808]                           for (restart in restarts) {
[17:47:06.808]                             name <- restart$name
[17:47:06.808]                             if (is.null(name)) 
[17:47:06.808]                               next
[17:47:06.808]                             if (!grepl(pattern, name)) 
[17:47:06.808]                               next
[17:47:06.808]                             invokeRestart(restart)
[17:47:06.808]                             muffled <- TRUE
[17:47:06.808]                             break
[17:47:06.808]                           }
[17:47:06.808]                         }
[17:47:06.808]                       }
[17:47:06.808]                       invisible(muffled)
[17:47:06.808]                     }
[17:47:06.808]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.808]                   }
[17:47:06.808]                 }
[17:47:06.808]             }
[17:47:06.808]         }))
[17:47:06.808]     }, error = function(ex) {
[17:47:06.808]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.808]                 ...future.rng), started = ...future.startTime, 
[17:47:06.808]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.808]             version = "1.8"), class = "FutureResult")
[17:47:06.808]     }, finally = {
[17:47:06.808]         if (!identical(...future.workdir, getwd())) 
[17:47:06.808]             setwd(...future.workdir)
[17:47:06.808]         {
[17:47:06.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.808]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.808]             }
[17:47:06.808]             base::options(...future.oldOptions)
[17:47:06.808]             if (.Platform$OS.type == "windows") {
[17:47:06.808]                 old_names <- names(...future.oldEnvVars)
[17:47:06.808]                 envs <- base::Sys.getenv()
[17:47:06.808]                 names <- names(envs)
[17:47:06.808]                 common <- intersect(names, old_names)
[17:47:06.808]                 added <- setdiff(names, old_names)
[17:47:06.808]                 removed <- setdiff(old_names, names)
[17:47:06.808]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.808]                   envs[common]]
[17:47:06.808]                 NAMES <- toupper(changed)
[17:47:06.808]                 args <- list()
[17:47:06.808]                 for (kk in seq_along(NAMES)) {
[17:47:06.808]                   name <- changed[[kk]]
[17:47:06.808]                   NAME <- NAMES[[kk]]
[17:47:06.808]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.808]                     next
[17:47:06.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.808]                 }
[17:47:06.808]                 NAMES <- toupper(added)
[17:47:06.808]                 for (kk in seq_along(NAMES)) {
[17:47:06.808]                   name <- added[[kk]]
[17:47:06.808]                   NAME <- NAMES[[kk]]
[17:47:06.808]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.808]                     next
[17:47:06.808]                   args[[name]] <- ""
[17:47:06.808]                 }
[17:47:06.808]                 NAMES <- toupper(removed)
[17:47:06.808]                 for (kk in seq_along(NAMES)) {
[17:47:06.808]                   name <- removed[[kk]]
[17:47:06.808]                   NAME <- NAMES[[kk]]
[17:47:06.808]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.808]                     next
[17:47:06.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.808]                 }
[17:47:06.808]                 if (length(args) > 0) 
[17:47:06.808]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.808]             }
[17:47:06.808]             else {
[17:47:06.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.808]             }
[17:47:06.808]             {
[17:47:06.808]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.808]                   0L) {
[17:47:06.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.808]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.808]                   base::options(opts)
[17:47:06.808]                 }
[17:47:06.808]                 {
[17:47:06.808]                   {
[17:47:06.808]                     NULL
[17:47:06.808]                     RNGkind("Mersenne-Twister")
[17:47:06.808]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.808]                       inherits = FALSE)
[17:47:06.808]                   }
[17:47:06.808]                   options(future.plan = NULL)
[17:47:06.808]                   if (is.na(NA_character_)) 
[17:47:06.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.808]                     .init = FALSE)
[17:47:06.808]                 }
[17:47:06.808]             }
[17:47:06.808]         }
[17:47:06.808]     })
[17:47:06.808]     if (TRUE) {
[17:47:06.808]         base::sink(type = "output", split = FALSE)
[17:47:06.808]         if (TRUE) {
[17:47:06.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.808]         }
[17:47:06.808]         else {
[17:47:06.808]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.808]         }
[17:47:06.808]         base::close(...future.stdout)
[17:47:06.808]         ...future.stdout <- NULL
[17:47:06.808]     }
[17:47:06.808]     ...future.result$conditions <- ...future.conditions
[17:47:06.808]     ...future.result$finished <- base::Sys.time()
[17:47:06.808]     ...future.result
[17:47:06.808] }
[17:47:06.809] assign_globals() ...
[17:47:06.809] List of 1
[17:47:06.809]  $ pkg: chr "foo"
[17:47:06.809]  - attr(*, "where")=List of 1
[17:47:06.809]   ..$ pkg:<environment: R_EmptyEnv> 
[17:47:06.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.809]  - attr(*, "resolved")= logi TRUE
[17:47:06.809]  - attr(*, "total_size")= num 112
[17:47:06.811] - copied ‘pkg’ to environment
[17:47:06.811] assign_globals() ... done
[17:47:06.812] plan(): Setting new future strategy stack:
[17:47:06.812] List of future strategies:
[17:47:06.812] 1. sequential:
[17:47:06.812]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.812]    - tweaked: FALSE
[17:47:06.812]    - call: NULL
[17:47:06.812] plan(): nbrOfWorkers() = 1
[17:47:06.813] plan(): Setting new future strategy stack:
[17:47:06.813] List of future strategies:
[17:47:06.813] 1. sequential:
[17:47:06.813]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.813]    - tweaked: FALSE
[17:47:06.813]    - call: plan(strategy)
[17:47:06.813] plan(): nbrOfWorkers() = 1
[17:47:06.814] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.814] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.814] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.816] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:47:06.816] Searching for globals ... DONE
[17:47:06.816] Resolving globals: TRUE
[17:47:06.816] Resolving any globals that are futures ...
[17:47:06.816] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:47:06.816] Resolving any globals that are futures ... DONE
[17:47:06.817] 
[17:47:06.817] 
[17:47:06.817] getGlobalsAndPackages() ... DONE
[17:47:06.817] run() for ‘Future’ ...
[17:47:06.817] - state: ‘created’
[17:47:06.817] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.819] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.819]   - Field: ‘label’
[17:47:06.819]   - Field: ‘local’
[17:47:06.819]   - Field: ‘owner’
[17:47:06.819]   - Field: ‘envir’
[17:47:06.819]   - Field: ‘packages’
[17:47:06.819]   - Field: ‘gc’
[17:47:06.820]   - Field: ‘conditions’
[17:47:06.820]   - Field: ‘expr’
[17:47:06.820]   - Field: ‘uuid’
[17:47:06.820]   - Field: ‘seed’
[17:47:06.820]   - Field: ‘version’
[17:47:06.820]   - Field: ‘result’
[17:47:06.820]   - Field: ‘asynchronous’
[17:47:06.820]   - Field: ‘calls’
[17:47:06.820]   - Field: ‘globals’
[17:47:06.820]   - Field: ‘stdout’
[17:47:06.820]   - Field: ‘earlySignal’
[17:47:06.821]   - Field: ‘lazy’
[17:47:06.821]   - Field: ‘state’
[17:47:06.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.821] - Launch lazy future ...
[17:47:06.821] Packages needed by the future expression (n = 0): <none>
[17:47:06.821] Packages needed by future strategies (n = 0): <none>
[17:47:06.821] {
[17:47:06.821]     {
[17:47:06.821]         {
[17:47:06.821]             ...future.startTime <- base::Sys.time()
[17:47:06.821]             {
[17:47:06.821]                 {
[17:47:06.821]                   {
[17:47:06.821]                     base::local({
[17:47:06.821]                       has_future <- base::requireNamespace("future", 
[17:47:06.821]                         quietly = TRUE)
[17:47:06.821]                       if (has_future) {
[17:47:06.821]                         ns <- base::getNamespace("future")
[17:47:06.821]                         version <- ns[[".package"]][["version"]]
[17:47:06.821]                         if (is.null(version)) 
[17:47:06.821]                           version <- utils::packageVersion("future")
[17:47:06.821]                       }
[17:47:06.821]                       else {
[17:47:06.821]                         version <- NULL
[17:47:06.821]                       }
[17:47:06.821]                       if (!has_future || version < "1.8.0") {
[17:47:06.821]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.821]                           "", base::R.version$version.string), 
[17:47:06.821]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.821]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.821]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.821]                             "release", "version")], collapse = " "), 
[17:47:06.821]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.821]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.821]                           info)
[17:47:06.821]                         info <- base::paste(info, collapse = "; ")
[17:47:06.821]                         if (!has_future) {
[17:47:06.821]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.821]                             info)
[17:47:06.821]                         }
[17:47:06.821]                         else {
[17:47:06.821]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.821]                             info, version)
[17:47:06.821]                         }
[17:47:06.821]                         base::stop(msg)
[17:47:06.821]                       }
[17:47:06.821]                     })
[17:47:06.821]                   }
[17:47:06.821]                   ...future.strategy.old <- future::plan("list")
[17:47:06.821]                   options(future.plan = NULL)
[17:47:06.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.821]                 }
[17:47:06.821]                 ...future.workdir <- getwd()
[17:47:06.821]             }
[17:47:06.821]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.821]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.821]         }
[17:47:06.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.821]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.821]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.821]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.821]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.821]             base::names(...future.oldOptions))
[17:47:06.821]     }
[17:47:06.821]     if (FALSE) {
[17:47:06.821]     }
[17:47:06.821]     else {
[17:47:06.821]         if (TRUE) {
[17:47:06.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.821]                 open = "w")
[17:47:06.821]         }
[17:47:06.821]         else {
[17:47:06.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.821]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.821]         }
[17:47:06.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.821]             base::sink(type = "output", split = FALSE)
[17:47:06.821]             base::close(...future.stdout)
[17:47:06.821]         }, add = TRUE)
[17:47:06.821]     }
[17:47:06.821]     ...future.frame <- base::sys.nframe()
[17:47:06.821]     ...future.conditions <- base::list()
[17:47:06.821]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.821]     if (FALSE) {
[17:47:06.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.821]     }
[17:47:06.821]     ...future.result <- base::tryCatch({
[17:47:06.821]         base::withCallingHandlers({
[17:47:06.821]             ...future.value <- base::withVisible(base::local({
[17:47:06.821]                 x <- 0
[17:47:06.821]                 x <- x + 1
[17:47:06.821]                 x
[17:47:06.821]             }))
[17:47:06.821]             future::FutureResult(value = ...future.value$value, 
[17:47:06.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.821]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.821]                     ...future.globalenv.names))
[17:47:06.821]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.821]         }, condition = base::local({
[17:47:06.821]             c <- base::c
[17:47:06.821]             inherits <- base::inherits
[17:47:06.821]             invokeRestart <- base::invokeRestart
[17:47:06.821]             length <- base::length
[17:47:06.821]             list <- base::list
[17:47:06.821]             seq.int <- base::seq.int
[17:47:06.821]             signalCondition <- base::signalCondition
[17:47:06.821]             sys.calls <- base::sys.calls
[17:47:06.821]             `[[` <- base::`[[`
[17:47:06.821]             `+` <- base::`+`
[17:47:06.821]             `<<-` <- base::`<<-`
[17:47:06.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.821]                   3L)]
[17:47:06.821]             }
[17:47:06.821]             function(cond) {
[17:47:06.821]                 is_error <- inherits(cond, "error")
[17:47:06.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.821]                   NULL)
[17:47:06.821]                 if (is_error) {
[17:47:06.821]                   sessionInformation <- function() {
[17:47:06.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.821]                       search = base::search(), system = base::Sys.info())
[17:47:06.821]                   }
[17:47:06.821]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.821]                     cond$call), session = sessionInformation(), 
[17:47:06.821]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.821]                   signalCondition(cond)
[17:47:06.821]                 }
[17:47:06.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.821]                 "immediateCondition"))) {
[17:47:06.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.821]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.821]                   if (TRUE && !signal) {
[17:47:06.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.821]                     {
[17:47:06.821]                       inherits <- base::inherits
[17:47:06.821]                       invokeRestart <- base::invokeRestart
[17:47:06.821]                       is.null <- base::is.null
[17:47:06.821]                       muffled <- FALSE
[17:47:06.821]                       if (inherits(cond, "message")) {
[17:47:06.821]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.821]                         if (muffled) 
[17:47:06.821]                           invokeRestart("muffleMessage")
[17:47:06.821]                       }
[17:47:06.821]                       else if (inherits(cond, "warning")) {
[17:47:06.821]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.821]                         if (muffled) 
[17:47:06.821]                           invokeRestart("muffleWarning")
[17:47:06.821]                       }
[17:47:06.821]                       else if (inherits(cond, "condition")) {
[17:47:06.821]                         if (!is.null(pattern)) {
[17:47:06.821]                           computeRestarts <- base::computeRestarts
[17:47:06.821]                           grepl <- base::grepl
[17:47:06.821]                           restarts <- computeRestarts(cond)
[17:47:06.821]                           for (restart in restarts) {
[17:47:06.821]                             name <- restart$name
[17:47:06.821]                             if (is.null(name)) 
[17:47:06.821]                               next
[17:47:06.821]                             if (!grepl(pattern, name)) 
[17:47:06.821]                               next
[17:47:06.821]                             invokeRestart(restart)
[17:47:06.821]                             muffled <- TRUE
[17:47:06.821]                             break
[17:47:06.821]                           }
[17:47:06.821]                         }
[17:47:06.821]                       }
[17:47:06.821]                       invisible(muffled)
[17:47:06.821]                     }
[17:47:06.821]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.821]                   }
[17:47:06.821]                 }
[17:47:06.821]                 else {
[17:47:06.821]                   if (TRUE) {
[17:47:06.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.821]                     {
[17:47:06.821]                       inherits <- base::inherits
[17:47:06.821]                       invokeRestart <- base::invokeRestart
[17:47:06.821]                       is.null <- base::is.null
[17:47:06.821]                       muffled <- FALSE
[17:47:06.821]                       if (inherits(cond, "message")) {
[17:47:06.821]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.821]                         if (muffled) 
[17:47:06.821]                           invokeRestart("muffleMessage")
[17:47:06.821]                       }
[17:47:06.821]                       else if (inherits(cond, "warning")) {
[17:47:06.821]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.821]                         if (muffled) 
[17:47:06.821]                           invokeRestart("muffleWarning")
[17:47:06.821]                       }
[17:47:06.821]                       else if (inherits(cond, "condition")) {
[17:47:06.821]                         if (!is.null(pattern)) {
[17:47:06.821]                           computeRestarts <- base::computeRestarts
[17:47:06.821]                           grepl <- base::grepl
[17:47:06.821]                           restarts <- computeRestarts(cond)
[17:47:06.821]                           for (restart in restarts) {
[17:47:06.821]                             name <- restart$name
[17:47:06.821]                             if (is.null(name)) 
[17:47:06.821]                               next
[17:47:06.821]                             if (!grepl(pattern, name)) 
[17:47:06.821]                               next
[17:47:06.821]                             invokeRestart(restart)
[17:47:06.821]                             muffled <- TRUE
[17:47:06.821]                             break
[17:47:06.821]                           }
[17:47:06.821]                         }
[17:47:06.821]                       }
[17:47:06.821]                       invisible(muffled)
[17:47:06.821]                     }
[17:47:06.821]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.821]                   }
[17:47:06.821]                 }
[17:47:06.821]             }
[17:47:06.821]         }))
[17:47:06.821]     }, error = function(ex) {
[17:47:06.821]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.821]                 ...future.rng), started = ...future.startTime, 
[17:47:06.821]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.821]             version = "1.8"), class = "FutureResult")
[17:47:06.821]     }, finally = {
[17:47:06.821]         if (!identical(...future.workdir, getwd())) 
[17:47:06.821]             setwd(...future.workdir)
[17:47:06.821]         {
[17:47:06.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.821]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.821]             }
[17:47:06.821]             base::options(...future.oldOptions)
[17:47:06.821]             if (.Platform$OS.type == "windows") {
[17:47:06.821]                 old_names <- names(...future.oldEnvVars)
[17:47:06.821]                 envs <- base::Sys.getenv()
[17:47:06.821]                 names <- names(envs)
[17:47:06.821]                 common <- intersect(names, old_names)
[17:47:06.821]                 added <- setdiff(names, old_names)
[17:47:06.821]                 removed <- setdiff(old_names, names)
[17:47:06.821]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.821]                   envs[common]]
[17:47:06.821]                 NAMES <- toupper(changed)
[17:47:06.821]                 args <- list()
[17:47:06.821]                 for (kk in seq_along(NAMES)) {
[17:47:06.821]                   name <- changed[[kk]]
[17:47:06.821]                   NAME <- NAMES[[kk]]
[17:47:06.821]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.821]                     next
[17:47:06.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.821]                 }
[17:47:06.821]                 NAMES <- toupper(added)
[17:47:06.821]                 for (kk in seq_along(NAMES)) {
[17:47:06.821]                   name <- added[[kk]]
[17:47:06.821]                   NAME <- NAMES[[kk]]
[17:47:06.821]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.821]                     next
[17:47:06.821]                   args[[name]] <- ""
[17:47:06.821]                 }
[17:47:06.821]                 NAMES <- toupper(removed)
[17:47:06.821]                 for (kk in seq_along(NAMES)) {
[17:47:06.821]                   name <- removed[[kk]]
[17:47:06.821]                   NAME <- NAMES[[kk]]
[17:47:06.821]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.821]                     next
[17:47:06.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.821]                 }
[17:47:06.821]                 if (length(args) > 0) 
[17:47:06.821]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.821]             }
[17:47:06.821]             else {
[17:47:06.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.821]             }
[17:47:06.821]             {
[17:47:06.821]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.821]                   0L) {
[17:47:06.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.821]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.821]                   base::options(opts)
[17:47:06.821]                 }
[17:47:06.821]                 {
[17:47:06.821]                   {
[17:47:06.821]                     NULL
[17:47:06.821]                     RNGkind("Mersenne-Twister")
[17:47:06.821]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.821]                       inherits = FALSE)
[17:47:06.821]                   }
[17:47:06.821]                   options(future.plan = NULL)
[17:47:06.821]                   if (is.na(NA_character_)) 
[17:47:06.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.821]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.821]                     .init = FALSE)
[17:47:06.821]                 }
[17:47:06.821]             }
[17:47:06.821]         }
[17:47:06.821]     })
[17:47:06.821]     if (TRUE) {
[17:47:06.821]         base::sink(type = "output", split = FALSE)
[17:47:06.821]         if (TRUE) {
[17:47:06.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.821]         }
[17:47:06.821]         else {
[17:47:06.821]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.821]         }
[17:47:06.821]         base::close(...future.stdout)
[17:47:06.821]         ...future.stdout <- NULL
[17:47:06.821]     }
[17:47:06.821]     ...future.result$conditions <- ...future.conditions
[17:47:06.821]     ...future.result$finished <- base::Sys.time()
[17:47:06.821]     ...future.result
[17:47:06.821] }
[17:47:06.823] plan(): Setting new future strategy stack:
[17:47:06.823] List of future strategies:
[17:47:06.823] 1. sequential:
[17:47:06.823]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.823]    - tweaked: FALSE
[17:47:06.823]    - call: NULL
[17:47:06.824] plan(): nbrOfWorkers() = 1
[17:47:06.824] plan(): Setting new future strategy stack:
[17:47:06.825] List of future strategies:
[17:47:06.825] 1. sequential:
[17:47:06.825]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.825]    - tweaked: FALSE
[17:47:06.825]    - call: plan(strategy)
[17:47:06.825] plan(): nbrOfWorkers() = 1
[17:47:06.825] SequentialFuture started (and completed)
[17:47:06.825] - Launch lazy future ... done
[17:47:06.825] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.826] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.826] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.827] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:47:06.827] Searching for globals ... DONE
[17:47:06.827] Resolving globals: TRUE
[17:47:06.828] Resolving any globals that are futures ...
[17:47:06.828] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:47:06.828] Resolving any globals that are futures ... DONE
[17:47:06.828] Resolving futures part of globals (recursively) ...
[17:47:06.828] resolve() on list ...
[17:47:06.828]  recursive: 99
[17:47:06.828]  length: 1
[17:47:06.828]  elements: ‘x’
[17:47:06.829]  length: 0 (resolved future 1)
[17:47:06.829] resolve() on list ... DONE
[17:47:06.829] - globals: [1] ‘x’
[17:47:06.829] Resolving futures part of globals (recursively) ... DONE
[17:47:06.829] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.829] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:47:06.829] - globals: [1] ‘x’
[17:47:06.830] 
[17:47:06.830] getGlobalsAndPackages() ... DONE
[17:47:06.830] run() for ‘Future’ ...
[17:47:06.830] - state: ‘created’
[17:47:06.830] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.830] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.830]   - Field: ‘label’
[17:47:06.831]   - Field: ‘local’
[17:47:06.831]   - Field: ‘owner’
[17:47:06.831]   - Field: ‘envir’
[17:47:06.831]   - Field: ‘packages’
[17:47:06.831]   - Field: ‘gc’
[17:47:06.831]   - Field: ‘conditions’
[17:47:06.831]   - Field: ‘expr’
[17:47:06.831]   - Field: ‘uuid’
[17:47:06.831]   - Field: ‘seed’
[17:47:06.831]   - Field: ‘version’
[17:47:06.831]   - Field: ‘result’
[17:47:06.832]   - Field: ‘asynchronous’
[17:47:06.832]   - Field: ‘calls’
[17:47:06.832]   - Field: ‘globals’
[17:47:06.832]   - Field: ‘stdout’
[17:47:06.832]   - Field: ‘earlySignal’
[17:47:06.832]   - Field: ‘lazy’
[17:47:06.832]   - Field: ‘state’
[17:47:06.832] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.832] - Launch lazy future ...
[17:47:06.832] Packages needed by the future expression (n = 0): <none>
[17:47:06.833] Packages needed by future strategies (n = 0): <none>
[17:47:06.833] {
[17:47:06.833]     {
[17:47:06.833]         {
[17:47:06.833]             ...future.startTime <- base::Sys.time()
[17:47:06.833]             {
[17:47:06.833]                 {
[17:47:06.833]                   {
[17:47:06.833]                     base::local({
[17:47:06.833]                       has_future <- base::requireNamespace("future", 
[17:47:06.833]                         quietly = TRUE)
[17:47:06.833]                       if (has_future) {
[17:47:06.833]                         ns <- base::getNamespace("future")
[17:47:06.833]                         version <- ns[[".package"]][["version"]]
[17:47:06.833]                         if (is.null(version)) 
[17:47:06.833]                           version <- utils::packageVersion("future")
[17:47:06.833]                       }
[17:47:06.833]                       else {
[17:47:06.833]                         version <- NULL
[17:47:06.833]                       }
[17:47:06.833]                       if (!has_future || version < "1.8.0") {
[17:47:06.833]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.833]                           "", base::R.version$version.string), 
[17:47:06.833]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.833]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.833]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.833]                             "release", "version")], collapse = " "), 
[17:47:06.833]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.833]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.833]                           info)
[17:47:06.833]                         info <- base::paste(info, collapse = "; ")
[17:47:06.833]                         if (!has_future) {
[17:47:06.833]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.833]                             info)
[17:47:06.833]                         }
[17:47:06.833]                         else {
[17:47:06.833]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.833]                             info, version)
[17:47:06.833]                         }
[17:47:06.833]                         base::stop(msg)
[17:47:06.833]                       }
[17:47:06.833]                     })
[17:47:06.833]                   }
[17:47:06.833]                   ...future.strategy.old <- future::plan("list")
[17:47:06.833]                   options(future.plan = NULL)
[17:47:06.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.833]                 }
[17:47:06.833]                 ...future.workdir <- getwd()
[17:47:06.833]             }
[17:47:06.833]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.833]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.833]         }
[17:47:06.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.833]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.833]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.833]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.833]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.833]             base::names(...future.oldOptions))
[17:47:06.833]     }
[17:47:06.833]     if (FALSE) {
[17:47:06.833]     }
[17:47:06.833]     else {
[17:47:06.833]         if (TRUE) {
[17:47:06.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.833]                 open = "w")
[17:47:06.833]         }
[17:47:06.833]         else {
[17:47:06.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.833]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.833]         }
[17:47:06.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.833]             base::sink(type = "output", split = FALSE)
[17:47:06.833]             base::close(...future.stdout)
[17:47:06.833]         }, add = TRUE)
[17:47:06.833]     }
[17:47:06.833]     ...future.frame <- base::sys.nframe()
[17:47:06.833]     ...future.conditions <- base::list()
[17:47:06.833]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.833]     if (FALSE) {
[17:47:06.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.833]     }
[17:47:06.833]     ...future.result <- base::tryCatch({
[17:47:06.833]         base::withCallingHandlers({
[17:47:06.833]             ...future.value <- base::withVisible(base::local({
[17:47:06.833]                 x <- x + 1
[17:47:06.833]                 x
[17:47:06.833]             }))
[17:47:06.833]             future::FutureResult(value = ...future.value$value, 
[17:47:06.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.833]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.833]                     ...future.globalenv.names))
[17:47:06.833]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.833]         }, condition = base::local({
[17:47:06.833]             c <- base::c
[17:47:06.833]             inherits <- base::inherits
[17:47:06.833]             invokeRestart <- base::invokeRestart
[17:47:06.833]             length <- base::length
[17:47:06.833]             list <- base::list
[17:47:06.833]             seq.int <- base::seq.int
[17:47:06.833]             signalCondition <- base::signalCondition
[17:47:06.833]             sys.calls <- base::sys.calls
[17:47:06.833]             `[[` <- base::`[[`
[17:47:06.833]             `+` <- base::`+`
[17:47:06.833]             `<<-` <- base::`<<-`
[17:47:06.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.833]                   3L)]
[17:47:06.833]             }
[17:47:06.833]             function(cond) {
[17:47:06.833]                 is_error <- inherits(cond, "error")
[17:47:06.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.833]                   NULL)
[17:47:06.833]                 if (is_error) {
[17:47:06.833]                   sessionInformation <- function() {
[17:47:06.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.833]                       search = base::search(), system = base::Sys.info())
[17:47:06.833]                   }
[17:47:06.833]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.833]                     cond$call), session = sessionInformation(), 
[17:47:06.833]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.833]                   signalCondition(cond)
[17:47:06.833]                 }
[17:47:06.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.833]                 "immediateCondition"))) {
[17:47:06.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.833]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.833]                   if (TRUE && !signal) {
[17:47:06.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.833]                     {
[17:47:06.833]                       inherits <- base::inherits
[17:47:06.833]                       invokeRestart <- base::invokeRestart
[17:47:06.833]                       is.null <- base::is.null
[17:47:06.833]                       muffled <- FALSE
[17:47:06.833]                       if (inherits(cond, "message")) {
[17:47:06.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.833]                         if (muffled) 
[17:47:06.833]                           invokeRestart("muffleMessage")
[17:47:06.833]                       }
[17:47:06.833]                       else if (inherits(cond, "warning")) {
[17:47:06.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.833]                         if (muffled) 
[17:47:06.833]                           invokeRestart("muffleWarning")
[17:47:06.833]                       }
[17:47:06.833]                       else if (inherits(cond, "condition")) {
[17:47:06.833]                         if (!is.null(pattern)) {
[17:47:06.833]                           computeRestarts <- base::computeRestarts
[17:47:06.833]                           grepl <- base::grepl
[17:47:06.833]                           restarts <- computeRestarts(cond)
[17:47:06.833]                           for (restart in restarts) {
[17:47:06.833]                             name <- restart$name
[17:47:06.833]                             if (is.null(name)) 
[17:47:06.833]                               next
[17:47:06.833]                             if (!grepl(pattern, name)) 
[17:47:06.833]                               next
[17:47:06.833]                             invokeRestart(restart)
[17:47:06.833]                             muffled <- TRUE
[17:47:06.833]                             break
[17:47:06.833]                           }
[17:47:06.833]                         }
[17:47:06.833]                       }
[17:47:06.833]                       invisible(muffled)
[17:47:06.833]                     }
[17:47:06.833]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.833]                   }
[17:47:06.833]                 }
[17:47:06.833]                 else {
[17:47:06.833]                   if (TRUE) {
[17:47:06.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.833]                     {
[17:47:06.833]                       inherits <- base::inherits
[17:47:06.833]                       invokeRestart <- base::invokeRestart
[17:47:06.833]                       is.null <- base::is.null
[17:47:06.833]                       muffled <- FALSE
[17:47:06.833]                       if (inherits(cond, "message")) {
[17:47:06.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.833]                         if (muffled) 
[17:47:06.833]                           invokeRestart("muffleMessage")
[17:47:06.833]                       }
[17:47:06.833]                       else if (inherits(cond, "warning")) {
[17:47:06.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.833]                         if (muffled) 
[17:47:06.833]                           invokeRestart("muffleWarning")
[17:47:06.833]                       }
[17:47:06.833]                       else if (inherits(cond, "condition")) {
[17:47:06.833]                         if (!is.null(pattern)) {
[17:47:06.833]                           computeRestarts <- base::computeRestarts
[17:47:06.833]                           grepl <- base::grepl
[17:47:06.833]                           restarts <- computeRestarts(cond)
[17:47:06.833]                           for (restart in restarts) {
[17:47:06.833]                             name <- restart$name
[17:47:06.833]                             if (is.null(name)) 
[17:47:06.833]                               next
[17:47:06.833]                             if (!grepl(pattern, name)) 
[17:47:06.833]                               next
[17:47:06.833]                             invokeRestart(restart)
[17:47:06.833]                             muffled <- TRUE
[17:47:06.833]                             break
[17:47:06.833]                           }
[17:47:06.833]                         }
[17:47:06.833]                       }
[17:47:06.833]                       invisible(muffled)
[17:47:06.833]                     }
[17:47:06.833]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.833]                   }
[17:47:06.833]                 }
[17:47:06.833]             }
[17:47:06.833]         }))
[17:47:06.833]     }, error = function(ex) {
[17:47:06.833]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.833]                 ...future.rng), started = ...future.startTime, 
[17:47:06.833]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.833]             version = "1.8"), class = "FutureResult")
[17:47:06.833]     }, finally = {
[17:47:06.833]         if (!identical(...future.workdir, getwd())) 
[17:47:06.833]             setwd(...future.workdir)
[17:47:06.833]         {
[17:47:06.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.833]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.833]             }
[17:47:06.833]             base::options(...future.oldOptions)
[17:47:06.833]             if (.Platform$OS.type == "windows") {
[17:47:06.833]                 old_names <- names(...future.oldEnvVars)
[17:47:06.833]                 envs <- base::Sys.getenv()
[17:47:06.833]                 names <- names(envs)
[17:47:06.833]                 common <- intersect(names, old_names)
[17:47:06.833]                 added <- setdiff(names, old_names)
[17:47:06.833]                 removed <- setdiff(old_names, names)
[17:47:06.833]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.833]                   envs[common]]
[17:47:06.833]                 NAMES <- toupper(changed)
[17:47:06.833]                 args <- list()
[17:47:06.833]                 for (kk in seq_along(NAMES)) {
[17:47:06.833]                   name <- changed[[kk]]
[17:47:06.833]                   NAME <- NAMES[[kk]]
[17:47:06.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.833]                     next
[17:47:06.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.833]                 }
[17:47:06.833]                 NAMES <- toupper(added)
[17:47:06.833]                 for (kk in seq_along(NAMES)) {
[17:47:06.833]                   name <- added[[kk]]
[17:47:06.833]                   NAME <- NAMES[[kk]]
[17:47:06.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.833]                     next
[17:47:06.833]                   args[[name]] <- ""
[17:47:06.833]                 }
[17:47:06.833]                 NAMES <- toupper(removed)
[17:47:06.833]                 for (kk in seq_along(NAMES)) {
[17:47:06.833]                   name <- removed[[kk]]
[17:47:06.833]                   NAME <- NAMES[[kk]]
[17:47:06.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.833]                     next
[17:47:06.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.833]                 }
[17:47:06.833]                 if (length(args) > 0) 
[17:47:06.833]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.833]             }
[17:47:06.833]             else {
[17:47:06.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.833]             }
[17:47:06.833]             {
[17:47:06.833]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.833]                   0L) {
[17:47:06.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.833]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.833]                   base::options(opts)
[17:47:06.833]                 }
[17:47:06.833]                 {
[17:47:06.833]                   {
[17:47:06.833]                     NULL
[17:47:06.833]                     RNGkind("Mersenne-Twister")
[17:47:06.833]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.833]                       inherits = FALSE)
[17:47:06.833]                   }
[17:47:06.833]                   options(future.plan = NULL)
[17:47:06.833]                   if (is.na(NA_character_)) 
[17:47:06.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.833]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.833]                     .init = FALSE)
[17:47:06.833]                 }
[17:47:06.833]             }
[17:47:06.833]         }
[17:47:06.833]     })
[17:47:06.833]     if (TRUE) {
[17:47:06.833]         base::sink(type = "output", split = FALSE)
[17:47:06.833]         if (TRUE) {
[17:47:06.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.833]         }
[17:47:06.833]         else {
[17:47:06.833]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.833]         }
[17:47:06.833]         base::close(...future.stdout)
[17:47:06.833]         ...future.stdout <- NULL
[17:47:06.833]     }
[17:47:06.833]     ...future.result$conditions <- ...future.conditions
[17:47:06.833]     ...future.result$finished <- base::Sys.time()
[17:47:06.833]     ...future.result
[17:47:06.833] }
[17:47:06.834] assign_globals() ...
[17:47:06.835] List of 1
[17:47:06.835]  $ x: num 1
[17:47:06.835]  - attr(*, "where")=List of 1
[17:47:06.835]   ..$ x:<environment: R_EmptyEnv> 
[17:47:06.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.835]  - attr(*, "resolved")= logi TRUE
[17:47:06.835]  - attr(*, "total_size")= num 56
[17:47:06.835]  - attr(*, "already-done")= logi TRUE
[17:47:06.837] - copied ‘x’ to environment
[17:47:06.837] assign_globals() ... done
[17:47:06.837] plan(): Setting new future strategy stack:
[17:47:06.837] List of future strategies:
[17:47:06.837] 1. sequential:
[17:47:06.837]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.837]    - tweaked: FALSE
[17:47:06.837]    - call: NULL
[17:47:06.838] plan(): nbrOfWorkers() = 1
[17:47:06.838] plan(): Setting new future strategy stack:
[17:47:06.839] List of future strategies:
[17:47:06.839] 1. sequential:
[17:47:06.839]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.839]    - tweaked: FALSE
[17:47:06.839]    - call: plan(strategy)
[17:47:06.839] plan(): nbrOfWorkers() = 1
[17:47:06.839] SequentialFuture started (and completed)
[17:47:06.839] - Launch lazy future ... done
[17:47:06.839] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.840] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.840] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:06.842] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:47:06.842] Searching for globals ... DONE
[17:47:06.842] Resolving globals: TRUE
[17:47:06.842] Resolving any globals that are futures ...
[17:47:06.842] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:47:06.842] Resolving any globals that are futures ... DONE
[17:47:06.842] Resolving futures part of globals (recursively) ...
[17:47:06.843] resolve() on list ...
[17:47:06.843]  recursive: 99
[17:47:06.843]  length: 1
[17:47:06.843]  elements: ‘x’
[17:47:06.843]  length: 0 (resolved future 1)
[17:47:06.843] resolve() on list ... DONE
[17:47:06.843] - globals: [1] ‘x’
[17:47:06.843] Resolving futures part of globals (recursively) ... DONE
[17:47:06.843] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:47:06.844] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:47:06.844] - globals: [1] ‘x’
[17:47:06.844] 
[17:47:06.844] getGlobalsAndPackages() ... DONE
[17:47:06.844] run() for ‘Future’ ...
[17:47:06.844] - state: ‘created’
[17:47:06.845] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:06.845] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:06.845] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:06.845]   - Field: ‘label’
[17:47:06.845]   - Field: ‘local’
[17:47:06.845]   - Field: ‘owner’
[17:47:06.845]   - Field: ‘envir’
[17:47:06.845]   - Field: ‘packages’
[17:47:06.845]   - Field: ‘gc’
[17:47:06.846]   - Field: ‘conditions’
[17:47:06.846]   - Field: ‘expr’
[17:47:06.846]   - Field: ‘uuid’
[17:47:06.846]   - Field: ‘seed’
[17:47:06.846]   - Field: ‘version’
[17:47:06.846]   - Field: ‘result’
[17:47:06.846]   - Field: ‘asynchronous’
[17:47:06.848]   - Field: ‘calls’
[17:47:06.848]   - Field: ‘globals’
[17:47:06.848]   - Field: ‘stdout’
[17:47:06.848]   - Field: ‘earlySignal’
[17:47:06.848]   - Field: ‘lazy’
[17:47:06.848]   - Field: ‘state’
[17:47:06.848] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:06.848] - Launch lazy future ...
[17:47:06.849] Packages needed by the future expression (n = 0): <none>
[17:47:06.849] Packages needed by future strategies (n = 0): <none>
[17:47:06.849] {
[17:47:06.849]     {
[17:47:06.849]         {
[17:47:06.849]             ...future.startTime <- base::Sys.time()
[17:47:06.849]             {
[17:47:06.849]                 {
[17:47:06.849]                   {
[17:47:06.849]                     base::local({
[17:47:06.849]                       has_future <- base::requireNamespace("future", 
[17:47:06.849]                         quietly = TRUE)
[17:47:06.849]                       if (has_future) {
[17:47:06.849]                         ns <- base::getNamespace("future")
[17:47:06.849]                         version <- ns[[".package"]][["version"]]
[17:47:06.849]                         if (is.null(version)) 
[17:47:06.849]                           version <- utils::packageVersion("future")
[17:47:06.849]                       }
[17:47:06.849]                       else {
[17:47:06.849]                         version <- NULL
[17:47:06.849]                       }
[17:47:06.849]                       if (!has_future || version < "1.8.0") {
[17:47:06.849]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.849]                           "", base::R.version$version.string), 
[17:47:06.849]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:06.849]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.849]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.849]                             "release", "version")], collapse = " "), 
[17:47:06.849]                           hostname = base::Sys.info()[["nodename"]])
[17:47:06.849]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.849]                           info)
[17:47:06.849]                         info <- base::paste(info, collapse = "; ")
[17:47:06.849]                         if (!has_future) {
[17:47:06.849]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.849]                             info)
[17:47:06.849]                         }
[17:47:06.849]                         else {
[17:47:06.849]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.849]                             info, version)
[17:47:06.849]                         }
[17:47:06.849]                         base::stop(msg)
[17:47:06.849]                       }
[17:47:06.849]                     })
[17:47:06.849]                   }
[17:47:06.849]                   ...future.strategy.old <- future::plan("list")
[17:47:06.849]                   options(future.plan = NULL)
[17:47:06.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.849]                 }
[17:47:06.849]                 ...future.workdir <- getwd()
[17:47:06.849]             }
[17:47:06.849]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.849]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.849]         }
[17:47:06.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.849]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:06.849]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.849]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.849]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.849]             base::names(...future.oldOptions))
[17:47:06.849]     }
[17:47:06.849]     if (FALSE) {
[17:47:06.849]     }
[17:47:06.849]     else {
[17:47:06.849]         if (TRUE) {
[17:47:06.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.849]                 open = "w")
[17:47:06.849]         }
[17:47:06.849]         else {
[17:47:06.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.849]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.849]         }
[17:47:06.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.849]             base::sink(type = "output", split = FALSE)
[17:47:06.849]             base::close(...future.stdout)
[17:47:06.849]         }, add = TRUE)
[17:47:06.849]     }
[17:47:06.849]     ...future.frame <- base::sys.nframe()
[17:47:06.849]     ...future.conditions <- base::list()
[17:47:06.849]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.849]     if (FALSE) {
[17:47:06.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.849]     }
[17:47:06.849]     ...future.result <- base::tryCatch({
[17:47:06.849]         base::withCallingHandlers({
[17:47:06.849]             ...future.value <- base::withVisible(base::local({
[17:47:06.849]                 x <- x()
[17:47:06.849]                 x
[17:47:06.849]             }))
[17:47:06.849]             future::FutureResult(value = ...future.value$value, 
[17:47:06.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.849]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.849]                     ...future.globalenv.names))
[17:47:06.849]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.849]         }, condition = base::local({
[17:47:06.849]             c <- base::c
[17:47:06.849]             inherits <- base::inherits
[17:47:06.849]             invokeRestart <- base::invokeRestart
[17:47:06.849]             length <- base::length
[17:47:06.849]             list <- base::list
[17:47:06.849]             seq.int <- base::seq.int
[17:47:06.849]             signalCondition <- base::signalCondition
[17:47:06.849]             sys.calls <- base::sys.calls
[17:47:06.849]             `[[` <- base::`[[`
[17:47:06.849]             `+` <- base::`+`
[17:47:06.849]             `<<-` <- base::`<<-`
[17:47:06.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.849]                   3L)]
[17:47:06.849]             }
[17:47:06.849]             function(cond) {
[17:47:06.849]                 is_error <- inherits(cond, "error")
[17:47:06.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.849]                   NULL)
[17:47:06.849]                 if (is_error) {
[17:47:06.849]                   sessionInformation <- function() {
[17:47:06.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.849]                       search = base::search(), system = base::Sys.info())
[17:47:06.849]                   }
[17:47:06.849]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.849]                     cond$call), session = sessionInformation(), 
[17:47:06.849]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.849]                   signalCondition(cond)
[17:47:06.849]                 }
[17:47:06.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.849]                 "immediateCondition"))) {
[17:47:06.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.849]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.849]                   if (TRUE && !signal) {
[17:47:06.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.849]                     {
[17:47:06.849]                       inherits <- base::inherits
[17:47:06.849]                       invokeRestart <- base::invokeRestart
[17:47:06.849]                       is.null <- base::is.null
[17:47:06.849]                       muffled <- FALSE
[17:47:06.849]                       if (inherits(cond, "message")) {
[17:47:06.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.849]                         if (muffled) 
[17:47:06.849]                           invokeRestart("muffleMessage")
[17:47:06.849]                       }
[17:47:06.849]                       else if (inherits(cond, "warning")) {
[17:47:06.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.849]                         if (muffled) 
[17:47:06.849]                           invokeRestart("muffleWarning")
[17:47:06.849]                       }
[17:47:06.849]                       else if (inherits(cond, "condition")) {
[17:47:06.849]                         if (!is.null(pattern)) {
[17:47:06.849]                           computeRestarts <- base::computeRestarts
[17:47:06.849]                           grepl <- base::grepl
[17:47:06.849]                           restarts <- computeRestarts(cond)
[17:47:06.849]                           for (restart in restarts) {
[17:47:06.849]                             name <- restart$name
[17:47:06.849]                             if (is.null(name)) 
[17:47:06.849]                               next
[17:47:06.849]                             if (!grepl(pattern, name)) 
[17:47:06.849]                               next
[17:47:06.849]                             invokeRestart(restart)
[17:47:06.849]                             muffled <- TRUE
[17:47:06.849]                             break
[17:47:06.849]                           }
[17:47:06.849]                         }
[17:47:06.849]                       }
[17:47:06.849]                       invisible(muffled)
[17:47:06.849]                     }
[17:47:06.849]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.849]                   }
[17:47:06.849]                 }
[17:47:06.849]                 else {
[17:47:06.849]                   if (TRUE) {
[17:47:06.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.849]                     {
[17:47:06.849]                       inherits <- base::inherits
[17:47:06.849]                       invokeRestart <- base::invokeRestart
[17:47:06.849]                       is.null <- base::is.null
[17:47:06.849]                       muffled <- FALSE
[17:47:06.849]                       if (inherits(cond, "message")) {
[17:47:06.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.849]                         if (muffled) 
[17:47:06.849]                           invokeRestart("muffleMessage")
[17:47:06.849]                       }
[17:47:06.849]                       else if (inherits(cond, "warning")) {
[17:47:06.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.849]                         if (muffled) 
[17:47:06.849]                           invokeRestart("muffleWarning")
[17:47:06.849]                       }
[17:47:06.849]                       else if (inherits(cond, "condition")) {
[17:47:06.849]                         if (!is.null(pattern)) {
[17:47:06.849]                           computeRestarts <- base::computeRestarts
[17:47:06.849]                           grepl <- base::grepl
[17:47:06.849]                           restarts <- computeRestarts(cond)
[17:47:06.849]                           for (restart in restarts) {
[17:47:06.849]                             name <- restart$name
[17:47:06.849]                             if (is.null(name)) 
[17:47:06.849]                               next
[17:47:06.849]                             if (!grepl(pattern, name)) 
[17:47:06.849]                               next
[17:47:06.849]                             invokeRestart(restart)
[17:47:06.849]                             muffled <- TRUE
[17:47:06.849]                             break
[17:47:06.849]                           }
[17:47:06.849]                         }
[17:47:06.849]                       }
[17:47:06.849]                       invisible(muffled)
[17:47:06.849]                     }
[17:47:06.849]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.849]                   }
[17:47:06.849]                 }
[17:47:06.849]             }
[17:47:06.849]         }))
[17:47:06.849]     }, error = function(ex) {
[17:47:06.849]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.849]                 ...future.rng), started = ...future.startTime, 
[17:47:06.849]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.849]             version = "1.8"), class = "FutureResult")
[17:47:06.849]     }, finally = {
[17:47:06.849]         if (!identical(...future.workdir, getwd())) 
[17:47:06.849]             setwd(...future.workdir)
[17:47:06.849]         {
[17:47:06.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.849]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.849]             }
[17:47:06.849]             base::options(...future.oldOptions)
[17:47:06.849]             if (.Platform$OS.type == "windows") {
[17:47:06.849]                 old_names <- names(...future.oldEnvVars)
[17:47:06.849]                 envs <- base::Sys.getenv()
[17:47:06.849]                 names <- names(envs)
[17:47:06.849]                 common <- intersect(names, old_names)
[17:47:06.849]                 added <- setdiff(names, old_names)
[17:47:06.849]                 removed <- setdiff(old_names, names)
[17:47:06.849]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.849]                   envs[common]]
[17:47:06.849]                 NAMES <- toupper(changed)
[17:47:06.849]                 args <- list()
[17:47:06.849]                 for (kk in seq_along(NAMES)) {
[17:47:06.849]                   name <- changed[[kk]]
[17:47:06.849]                   NAME <- NAMES[[kk]]
[17:47:06.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.849]                     next
[17:47:06.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.849]                 }
[17:47:06.849]                 NAMES <- toupper(added)
[17:47:06.849]                 for (kk in seq_along(NAMES)) {
[17:47:06.849]                   name <- added[[kk]]
[17:47:06.849]                   NAME <- NAMES[[kk]]
[17:47:06.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.849]                     next
[17:47:06.849]                   args[[name]] <- ""
[17:47:06.849]                 }
[17:47:06.849]                 NAMES <- toupper(removed)
[17:47:06.849]                 for (kk in seq_along(NAMES)) {
[17:47:06.849]                   name <- removed[[kk]]
[17:47:06.849]                   NAME <- NAMES[[kk]]
[17:47:06.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.849]                     next
[17:47:06.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.849]                 }
[17:47:06.849]                 if (length(args) > 0) 
[17:47:06.849]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.849]             }
[17:47:06.849]             else {
[17:47:06.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.849]             }
[17:47:06.849]             {
[17:47:06.849]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.849]                   0L) {
[17:47:06.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.849]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.849]                   base::options(opts)
[17:47:06.849]                 }
[17:47:06.849]                 {
[17:47:06.849]                   {
[17:47:06.849]                     NULL
[17:47:06.849]                     RNGkind("Mersenne-Twister")
[17:47:06.849]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:06.849]                       inherits = FALSE)
[17:47:06.849]                   }
[17:47:06.849]                   options(future.plan = NULL)
[17:47:06.849]                   if (is.na(NA_character_)) 
[17:47:06.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.849]                     .init = FALSE)
[17:47:06.849]                 }
[17:47:06.849]             }
[17:47:06.849]         }
[17:47:06.849]     })
[17:47:06.849]     if (TRUE) {
[17:47:06.849]         base::sink(type = "output", split = FALSE)
[17:47:06.849]         if (TRUE) {
[17:47:06.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.849]         }
[17:47:06.849]         else {
[17:47:06.849]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.849]         }
[17:47:06.849]         base::close(...future.stdout)
[17:47:06.849]         ...future.stdout <- NULL
[17:47:06.849]     }
[17:47:06.849]     ...future.result$conditions <- ...future.conditions
[17:47:06.849]     ...future.result$finished <- base::Sys.time()
[17:47:06.849]     ...future.result
[17:47:06.849] }
[17:47:06.851] assign_globals() ...
[17:47:06.851] List of 1
[17:47:06.851]  $ x:function ()  
[17:47:06.851]  - attr(*, "where")=List of 1
[17:47:06.851]   ..$ x:<environment: R_EmptyEnv> 
[17:47:06.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.851]  - attr(*, "resolved")= logi TRUE
[17:47:06.851]  - attr(*, "total_size")= num 1032
[17:47:06.851]  - attr(*, "already-done")= logi TRUE
[17:47:06.853] - reassign environment for ‘x’
[17:47:06.853] - copied ‘x’ to environment
[17:47:06.854] assign_globals() ... done
[17:47:06.854] plan(): Setting new future strategy stack:
[17:47:06.854] List of future strategies:
[17:47:06.854] 1. sequential:
[17:47:06.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.854]    - tweaked: FALSE
[17:47:06.854]    - call: NULL
[17:47:06.854] plan(): nbrOfWorkers() = 1
[17:47:06.855] plan(): Setting new future strategy stack:
[17:47:06.855] List of future strategies:
[17:47:06.855] 1. sequential:
[17:47:06.855]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.855]    - tweaked: FALSE
[17:47:06.855]    - call: plan(strategy)
[17:47:06.856] plan(): nbrOfWorkers() = 1
[17:47:06.856] SequentialFuture started (and completed)
[17:47:06.856] - Launch lazy future ... done
[17:47:06.856] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[17:47:06.865] plan(): Setting new future strategy stack:
[17:47:06.865] List of future strategies:
[17:47:06.865] 1. multicore:
[17:47:06.865]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:06.865]    - tweaked: FALSE
[17:47:06.865]    - call: plan(strategy)
[17:47:06.869] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.869] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.869] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.870] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:47:06.871] Searching for globals ... DONE
[17:47:06.871] Resolving globals: TRUE
[17:47:06.871] Resolving any globals that are futures ...
[17:47:06.871] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:47:06.871] Resolving any globals that are futures ... DONE
[17:47:06.871] 
[17:47:06.871] 
[17:47:06.871] getGlobalsAndPackages() ... DONE
[17:47:06.872] run() for ‘Future’ ...
[17:47:06.872] - state: ‘created’
[17:47:06.872] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:06.876] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:06.876] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:06.876]   - Field: ‘label’
[17:47:06.876]   - Field: ‘local’
[17:47:06.876]   - Field: ‘owner’
[17:47:06.876]   - Field: ‘envir’
[17:47:06.876]   - Field: ‘workers’
[17:47:06.876]   - Field: ‘packages’
[17:47:06.876]   - Field: ‘gc’
[17:47:06.876]   - Field: ‘job’
[17:47:06.877]   - Field: ‘conditions’
[17:47:06.877]   - Field: ‘expr’
[17:47:06.877]   - Field: ‘uuid’
[17:47:06.877]   - Field: ‘seed’
[17:47:06.877]   - Field: ‘version’
[17:47:06.877]   - Field: ‘result’
[17:47:06.877]   - Field: ‘asynchronous’
[17:47:06.877]   - Field: ‘calls’
[17:47:06.877]   - Field: ‘globals’
[17:47:06.877]   - Field: ‘stdout’
[17:47:06.877]   - Field: ‘earlySignal’
[17:47:06.878]   - Field: ‘lazy’
[17:47:06.878]   - Field: ‘state’
[17:47:06.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:06.878] - Launch lazy future ...
[17:47:06.879] Packages needed by the future expression (n = 0): <none>
[17:47:06.879] Packages needed by future strategies (n = 0): <none>
[17:47:06.879] {
[17:47:06.879]     {
[17:47:06.879]         {
[17:47:06.879]             ...future.startTime <- base::Sys.time()
[17:47:06.879]             {
[17:47:06.879]                 {
[17:47:06.879]                   {
[17:47:06.879]                     {
[17:47:06.879]                       base::local({
[17:47:06.879]                         has_future <- base::requireNamespace("future", 
[17:47:06.879]                           quietly = TRUE)
[17:47:06.879]                         if (has_future) {
[17:47:06.879]                           ns <- base::getNamespace("future")
[17:47:06.879]                           version <- ns[[".package"]][["version"]]
[17:47:06.879]                           if (is.null(version)) 
[17:47:06.879]                             version <- utils::packageVersion("future")
[17:47:06.879]                         }
[17:47:06.879]                         else {
[17:47:06.879]                           version <- NULL
[17:47:06.879]                         }
[17:47:06.879]                         if (!has_future || version < "1.8.0") {
[17:47:06.879]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.879]                             "", base::R.version$version.string), 
[17:47:06.879]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.879]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.879]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.879]                               "release", "version")], collapse = " "), 
[17:47:06.879]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.879]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.879]                             info)
[17:47:06.879]                           info <- base::paste(info, collapse = "; ")
[17:47:06.879]                           if (!has_future) {
[17:47:06.879]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.879]                               info)
[17:47:06.879]                           }
[17:47:06.879]                           else {
[17:47:06.879]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.879]                               info, version)
[17:47:06.879]                           }
[17:47:06.879]                           base::stop(msg)
[17:47:06.879]                         }
[17:47:06.879]                       })
[17:47:06.879]                     }
[17:47:06.879]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:06.879]                     base::options(mc.cores = 1L)
[17:47:06.879]                   }
[17:47:06.879]                   ...future.strategy.old <- future::plan("list")
[17:47:06.879]                   options(future.plan = NULL)
[17:47:06.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.879]                 }
[17:47:06.879]                 ...future.workdir <- getwd()
[17:47:06.879]             }
[17:47:06.879]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.879]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.879]         }
[17:47:06.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.879]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.879]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.879]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.879]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.879]             base::names(...future.oldOptions))
[17:47:06.879]     }
[17:47:06.879]     if (FALSE) {
[17:47:06.879]     }
[17:47:06.879]     else {
[17:47:06.879]         if (TRUE) {
[17:47:06.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.879]                 open = "w")
[17:47:06.879]         }
[17:47:06.879]         else {
[17:47:06.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.879]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.879]         }
[17:47:06.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.879]             base::sink(type = "output", split = FALSE)
[17:47:06.879]             base::close(...future.stdout)
[17:47:06.879]         }, add = TRUE)
[17:47:06.879]     }
[17:47:06.879]     ...future.frame <- base::sys.nframe()
[17:47:06.879]     ...future.conditions <- base::list()
[17:47:06.879]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.879]     if (FALSE) {
[17:47:06.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.879]     }
[17:47:06.879]     ...future.result <- base::tryCatch({
[17:47:06.879]         base::withCallingHandlers({
[17:47:06.879]             ...future.value <- base::withVisible(base::local({
[17:47:06.879]                 withCallingHandlers({
[17:47:06.879]                   {
[17:47:06.879]                     b <- a
[17:47:06.879]                     a <- 2
[17:47:06.879]                     a * b
[17:47:06.879]                   }
[17:47:06.879]                 }, immediateCondition = function(cond) {
[17:47:06.879]                   save_rds <- function (object, pathname, ...) 
[17:47:06.879]                   {
[17:47:06.879]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:06.879]                     if (file_test("-f", pathname_tmp)) {
[17:47:06.879]                       fi_tmp <- file.info(pathname_tmp)
[17:47:06.879]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:06.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:06.879]                         fi_tmp[["mtime"]])
[17:47:06.879]                     }
[17:47:06.879]                     tryCatch({
[17:47:06.879]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:06.879]                     }, error = function(ex) {
[17:47:06.879]                       msg <- conditionMessage(ex)
[17:47:06.879]                       fi_tmp <- file.info(pathname_tmp)
[17:47:06.879]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:06.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:06.879]                         fi_tmp[["mtime"]], msg)
[17:47:06.879]                       ex$message <- msg
[17:47:06.879]                       stop(ex)
[17:47:06.879]                     })
[17:47:06.879]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:06.879]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:06.879]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:06.879]                       fi_tmp <- file.info(pathname_tmp)
[17:47:06.879]                       fi <- file.info(pathname)
[17:47:06.879]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:06.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:06.879]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:06.879]                         fi[["size"]], fi[["mtime"]])
[17:47:06.879]                       stop(msg)
[17:47:06.879]                     }
[17:47:06.879]                     invisible(pathname)
[17:47:06.879]                   }
[17:47:06.879]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:06.879]                     rootPath = tempdir()) 
[17:47:06.879]                   {
[17:47:06.879]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:06.879]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:06.879]                       tmpdir = path, fileext = ".rds")
[17:47:06.879]                     save_rds(obj, file)
[17:47:06.879]                   }
[17:47:06.879]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:06.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.879]                   {
[17:47:06.879]                     inherits <- base::inherits
[17:47:06.879]                     invokeRestart <- base::invokeRestart
[17:47:06.879]                     is.null <- base::is.null
[17:47:06.879]                     muffled <- FALSE
[17:47:06.879]                     if (inherits(cond, "message")) {
[17:47:06.879]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:06.879]                       if (muffled) 
[17:47:06.879]                         invokeRestart("muffleMessage")
[17:47:06.879]                     }
[17:47:06.879]                     else if (inherits(cond, "warning")) {
[17:47:06.879]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:06.879]                       if (muffled) 
[17:47:06.879]                         invokeRestart("muffleWarning")
[17:47:06.879]                     }
[17:47:06.879]                     else if (inherits(cond, "condition")) {
[17:47:06.879]                       if (!is.null(pattern)) {
[17:47:06.879]                         computeRestarts <- base::computeRestarts
[17:47:06.879]                         grepl <- base::grepl
[17:47:06.879]                         restarts <- computeRestarts(cond)
[17:47:06.879]                         for (restart in restarts) {
[17:47:06.879]                           name <- restart$name
[17:47:06.879]                           if (is.null(name)) 
[17:47:06.879]                             next
[17:47:06.879]                           if (!grepl(pattern, name)) 
[17:47:06.879]                             next
[17:47:06.879]                           invokeRestart(restart)
[17:47:06.879]                           muffled <- TRUE
[17:47:06.879]                           break
[17:47:06.879]                         }
[17:47:06.879]                       }
[17:47:06.879]                     }
[17:47:06.879]                     invisible(muffled)
[17:47:06.879]                   }
[17:47:06.879]                   muffleCondition(cond)
[17:47:06.879]                 })
[17:47:06.879]             }))
[17:47:06.879]             future::FutureResult(value = ...future.value$value, 
[17:47:06.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.879]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.879]                     ...future.globalenv.names))
[17:47:06.879]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.879]         }, condition = base::local({
[17:47:06.879]             c <- base::c
[17:47:06.879]             inherits <- base::inherits
[17:47:06.879]             invokeRestart <- base::invokeRestart
[17:47:06.879]             length <- base::length
[17:47:06.879]             list <- base::list
[17:47:06.879]             seq.int <- base::seq.int
[17:47:06.879]             signalCondition <- base::signalCondition
[17:47:06.879]             sys.calls <- base::sys.calls
[17:47:06.879]             `[[` <- base::`[[`
[17:47:06.879]             `+` <- base::`+`
[17:47:06.879]             `<<-` <- base::`<<-`
[17:47:06.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.879]                   3L)]
[17:47:06.879]             }
[17:47:06.879]             function(cond) {
[17:47:06.879]                 is_error <- inherits(cond, "error")
[17:47:06.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.879]                   NULL)
[17:47:06.879]                 if (is_error) {
[17:47:06.879]                   sessionInformation <- function() {
[17:47:06.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.879]                       search = base::search(), system = base::Sys.info())
[17:47:06.879]                   }
[17:47:06.879]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.879]                     cond$call), session = sessionInformation(), 
[17:47:06.879]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.879]                   signalCondition(cond)
[17:47:06.879]                 }
[17:47:06.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.879]                 "immediateCondition"))) {
[17:47:06.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.879]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.879]                   if (TRUE && !signal) {
[17:47:06.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.879]                     {
[17:47:06.879]                       inherits <- base::inherits
[17:47:06.879]                       invokeRestart <- base::invokeRestart
[17:47:06.879]                       is.null <- base::is.null
[17:47:06.879]                       muffled <- FALSE
[17:47:06.879]                       if (inherits(cond, "message")) {
[17:47:06.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.879]                         if (muffled) 
[17:47:06.879]                           invokeRestart("muffleMessage")
[17:47:06.879]                       }
[17:47:06.879]                       else if (inherits(cond, "warning")) {
[17:47:06.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.879]                         if (muffled) 
[17:47:06.879]                           invokeRestart("muffleWarning")
[17:47:06.879]                       }
[17:47:06.879]                       else if (inherits(cond, "condition")) {
[17:47:06.879]                         if (!is.null(pattern)) {
[17:47:06.879]                           computeRestarts <- base::computeRestarts
[17:47:06.879]                           grepl <- base::grepl
[17:47:06.879]                           restarts <- computeRestarts(cond)
[17:47:06.879]                           for (restart in restarts) {
[17:47:06.879]                             name <- restart$name
[17:47:06.879]                             if (is.null(name)) 
[17:47:06.879]                               next
[17:47:06.879]                             if (!grepl(pattern, name)) 
[17:47:06.879]                               next
[17:47:06.879]                             invokeRestart(restart)
[17:47:06.879]                             muffled <- TRUE
[17:47:06.879]                             break
[17:47:06.879]                           }
[17:47:06.879]                         }
[17:47:06.879]                       }
[17:47:06.879]                       invisible(muffled)
[17:47:06.879]                     }
[17:47:06.879]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.879]                   }
[17:47:06.879]                 }
[17:47:06.879]                 else {
[17:47:06.879]                   if (TRUE) {
[17:47:06.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.879]                     {
[17:47:06.879]                       inherits <- base::inherits
[17:47:06.879]                       invokeRestart <- base::invokeRestart
[17:47:06.879]                       is.null <- base::is.null
[17:47:06.879]                       muffled <- FALSE
[17:47:06.879]                       if (inherits(cond, "message")) {
[17:47:06.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.879]                         if (muffled) 
[17:47:06.879]                           invokeRestart("muffleMessage")
[17:47:06.879]                       }
[17:47:06.879]                       else if (inherits(cond, "warning")) {
[17:47:06.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.879]                         if (muffled) 
[17:47:06.879]                           invokeRestart("muffleWarning")
[17:47:06.879]                       }
[17:47:06.879]                       else if (inherits(cond, "condition")) {
[17:47:06.879]                         if (!is.null(pattern)) {
[17:47:06.879]                           computeRestarts <- base::computeRestarts
[17:47:06.879]                           grepl <- base::grepl
[17:47:06.879]                           restarts <- computeRestarts(cond)
[17:47:06.879]                           for (restart in restarts) {
[17:47:06.879]                             name <- restart$name
[17:47:06.879]                             if (is.null(name)) 
[17:47:06.879]                               next
[17:47:06.879]                             if (!grepl(pattern, name)) 
[17:47:06.879]                               next
[17:47:06.879]                             invokeRestart(restart)
[17:47:06.879]                             muffled <- TRUE
[17:47:06.879]                             break
[17:47:06.879]                           }
[17:47:06.879]                         }
[17:47:06.879]                       }
[17:47:06.879]                       invisible(muffled)
[17:47:06.879]                     }
[17:47:06.879]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.879]                   }
[17:47:06.879]                 }
[17:47:06.879]             }
[17:47:06.879]         }))
[17:47:06.879]     }, error = function(ex) {
[17:47:06.879]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.879]                 ...future.rng), started = ...future.startTime, 
[17:47:06.879]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.879]             version = "1.8"), class = "FutureResult")
[17:47:06.879]     }, finally = {
[17:47:06.879]         if (!identical(...future.workdir, getwd())) 
[17:47:06.879]             setwd(...future.workdir)
[17:47:06.879]         {
[17:47:06.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.879]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.879]             }
[17:47:06.879]             base::options(...future.oldOptions)
[17:47:06.879]             if (.Platform$OS.type == "windows") {
[17:47:06.879]                 old_names <- names(...future.oldEnvVars)
[17:47:06.879]                 envs <- base::Sys.getenv()
[17:47:06.879]                 names <- names(envs)
[17:47:06.879]                 common <- intersect(names, old_names)
[17:47:06.879]                 added <- setdiff(names, old_names)
[17:47:06.879]                 removed <- setdiff(old_names, names)
[17:47:06.879]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.879]                   envs[common]]
[17:47:06.879]                 NAMES <- toupper(changed)
[17:47:06.879]                 args <- list()
[17:47:06.879]                 for (kk in seq_along(NAMES)) {
[17:47:06.879]                   name <- changed[[kk]]
[17:47:06.879]                   NAME <- NAMES[[kk]]
[17:47:06.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.879]                     next
[17:47:06.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.879]                 }
[17:47:06.879]                 NAMES <- toupper(added)
[17:47:06.879]                 for (kk in seq_along(NAMES)) {
[17:47:06.879]                   name <- added[[kk]]
[17:47:06.879]                   NAME <- NAMES[[kk]]
[17:47:06.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.879]                     next
[17:47:06.879]                   args[[name]] <- ""
[17:47:06.879]                 }
[17:47:06.879]                 NAMES <- toupper(removed)
[17:47:06.879]                 for (kk in seq_along(NAMES)) {
[17:47:06.879]                   name <- removed[[kk]]
[17:47:06.879]                   NAME <- NAMES[[kk]]
[17:47:06.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.879]                     next
[17:47:06.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.879]                 }
[17:47:06.879]                 if (length(args) > 0) 
[17:47:06.879]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.879]             }
[17:47:06.879]             else {
[17:47:06.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.879]             }
[17:47:06.879]             {
[17:47:06.879]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.879]                   0L) {
[17:47:06.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.879]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.879]                   base::options(opts)
[17:47:06.879]                 }
[17:47:06.879]                 {
[17:47:06.879]                   {
[17:47:06.879]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:06.879]                     NULL
[17:47:06.879]                   }
[17:47:06.879]                   options(future.plan = NULL)
[17:47:06.879]                   if (is.na(NA_character_)) 
[17:47:06.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.879]                     .init = FALSE)
[17:47:06.879]                 }
[17:47:06.879]             }
[17:47:06.879]         }
[17:47:06.879]     })
[17:47:06.879]     if (TRUE) {
[17:47:06.879]         base::sink(type = "output", split = FALSE)
[17:47:06.879]         if (TRUE) {
[17:47:06.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.879]         }
[17:47:06.879]         else {
[17:47:06.879]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.879]         }
[17:47:06.879]         base::close(...future.stdout)
[17:47:06.879]         ...future.stdout <- NULL
[17:47:06.879]     }
[17:47:06.879]     ...future.result$conditions <- ...future.conditions
[17:47:06.879]     ...future.result$finished <- base::Sys.time()
[17:47:06.879]     ...future.result
[17:47:06.879] }
[17:47:06.882] requestCore(): workers = 2
[17:47:06.885] MulticoreFuture started
[17:47:06.885] - Launch lazy future ... done
[17:47:06.885] plan(): Setting new future strategy stack:
[17:47:06.885] run() for ‘MulticoreFuture’ ... done
[17:47:06.887] result() for MulticoreFuture ...
[17:47:06.885] List of future strategies:
[17:47:06.885] 1. sequential:
[17:47:06.885]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.885]    - tweaked: FALSE
[17:47:06.885]    - call: NULL
[17:47:06.892] plan(): nbrOfWorkers() = 1
[17:47:06.895] plan(): Setting new future strategy stack:
[17:47:06.895] List of future strategies:
[17:47:06.895] 1. multicore:
[17:47:06.895]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:06.895]    - tweaked: FALSE
[17:47:06.895]    - call: plan(strategy)
[17:47:06.901] plan(): nbrOfWorkers() = 2
[17:47:06.907] result() for MulticoreFuture ...
[17:47:06.907] result() for MulticoreFuture ... done
[17:47:06.907] result() for MulticoreFuture ... done
[17:47:06.907] result() for MulticoreFuture ...
[17:47:06.908] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.908] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.908] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.910] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:47:06.910] Searching for globals ... DONE
[17:47:06.910] Resolving globals: TRUE
[17:47:06.910] Resolving any globals that are futures ...
[17:47:06.911] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:47:06.911] Resolving any globals that are futures ... DONE
[17:47:06.911] 
[17:47:06.911] 
[17:47:06.911] getGlobalsAndPackages() ... DONE
[17:47:06.912] run() for ‘Future’ ...
[17:47:06.912] - state: ‘created’
[17:47:06.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:06.916] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:06.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:06.916]   - Field: ‘label’
[17:47:06.916]   - Field: ‘local’
[17:47:06.916]   - Field: ‘owner’
[17:47:06.917]   - Field: ‘envir’
[17:47:06.917]   - Field: ‘workers’
[17:47:06.917]   - Field: ‘packages’
[17:47:06.917]   - Field: ‘gc’
[17:47:06.917]   - Field: ‘job’
[17:47:06.917]   - Field: ‘conditions’
[17:47:06.917]   - Field: ‘expr’
[17:47:06.917]   - Field: ‘uuid’
[17:47:06.917]   - Field: ‘seed’
[17:47:06.918]   - Field: ‘version’
[17:47:06.918]   - Field: ‘result’
[17:47:06.918]   - Field: ‘asynchronous’
[17:47:06.918]   - Field: ‘calls’
[17:47:06.918]   - Field: ‘globals’
[17:47:06.918]   - Field: ‘stdout’
[17:47:06.918]   - Field: ‘earlySignal’
[17:47:06.918]   - Field: ‘lazy’
[17:47:06.918]   - Field: ‘state’
[17:47:06.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:06.919] - Launch lazy future ...
[17:47:06.919] Packages needed by the future expression (n = 0): <none>
[17:47:06.919] Packages needed by future strategies (n = 0): <none>
[17:47:06.920] {
[17:47:06.920]     {
[17:47:06.920]         {
[17:47:06.920]             ...future.startTime <- base::Sys.time()
[17:47:06.920]             {
[17:47:06.920]                 {
[17:47:06.920]                   {
[17:47:06.920]                     {
[17:47:06.920]                       base::local({
[17:47:06.920]                         has_future <- base::requireNamespace("future", 
[17:47:06.920]                           quietly = TRUE)
[17:47:06.920]                         if (has_future) {
[17:47:06.920]                           ns <- base::getNamespace("future")
[17:47:06.920]                           version <- ns[[".package"]][["version"]]
[17:47:06.920]                           if (is.null(version)) 
[17:47:06.920]                             version <- utils::packageVersion("future")
[17:47:06.920]                         }
[17:47:06.920]                         else {
[17:47:06.920]                           version <- NULL
[17:47:06.920]                         }
[17:47:06.920]                         if (!has_future || version < "1.8.0") {
[17:47:06.920]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.920]                             "", base::R.version$version.string), 
[17:47:06.920]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.920]                               "release", "version")], collapse = " "), 
[17:47:06.920]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.920]                             info)
[17:47:06.920]                           info <- base::paste(info, collapse = "; ")
[17:47:06.920]                           if (!has_future) {
[17:47:06.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.920]                               info)
[17:47:06.920]                           }
[17:47:06.920]                           else {
[17:47:06.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.920]                               info, version)
[17:47:06.920]                           }
[17:47:06.920]                           base::stop(msg)
[17:47:06.920]                         }
[17:47:06.920]                       })
[17:47:06.920]                     }
[17:47:06.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:06.920]                     base::options(mc.cores = 1L)
[17:47:06.920]                   }
[17:47:06.920]                   ...future.strategy.old <- future::plan("list")
[17:47:06.920]                   options(future.plan = NULL)
[17:47:06.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.920]                 }
[17:47:06.920]                 ...future.workdir <- getwd()
[17:47:06.920]             }
[17:47:06.920]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.920]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.920]         }
[17:47:06.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.920]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.920]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.920]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.920]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.920]             base::names(...future.oldOptions))
[17:47:06.920]     }
[17:47:06.920]     if (FALSE) {
[17:47:06.920]     }
[17:47:06.920]     else {
[17:47:06.920]         if (TRUE) {
[17:47:06.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.920]                 open = "w")
[17:47:06.920]         }
[17:47:06.920]         else {
[17:47:06.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.920]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.920]         }
[17:47:06.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.920]             base::sink(type = "output", split = FALSE)
[17:47:06.920]             base::close(...future.stdout)
[17:47:06.920]         }, add = TRUE)
[17:47:06.920]     }
[17:47:06.920]     ...future.frame <- base::sys.nframe()
[17:47:06.920]     ...future.conditions <- base::list()
[17:47:06.920]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.920]     if (FALSE) {
[17:47:06.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.920]     }
[17:47:06.920]     ...future.result <- base::tryCatch({
[17:47:06.920]         base::withCallingHandlers({
[17:47:06.920]             ...future.value <- base::withVisible(base::local({
[17:47:06.920]                 withCallingHandlers({
[17:47:06.920]                   {
[17:47:06.920]                     b <- a
[17:47:06.920]                     a <- 2
[17:47:06.920]                     a * b
[17:47:06.920]                   }
[17:47:06.920]                 }, immediateCondition = function(cond) {
[17:47:06.920]                   save_rds <- function (object, pathname, ...) 
[17:47:06.920]                   {
[17:47:06.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:06.920]                     if (file_test("-f", pathname_tmp)) {
[17:47:06.920]                       fi_tmp <- file.info(pathname_tmp)
[17:47:06.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:06.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:06.920]                         fi_tmp[["mtime"]])
[17:47:06.920]                     }
[17:47:06.920]                     tryCatch({
[17:47:06.920]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:06.920]                     }, error = function(ex) {
[17:47:06.920]                       msg <- conditionMessage(ex)
[17:47:06.920]                       fi_tmp <- file.info(pathname_tmp)
[17:47:06.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:06.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:06.920]                         fi_tmp[["mtime"]], msg)
[17:47:06.920]                       ex$message <- msg
[17:47:06.920]                       stop(ex)
[17:47:06.920]                     })
[17:47:06.920]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:06.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:06.920]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:06.920]                       fi_tmp <- file.info(pathname_tmp)
[17:47:06.920]                       fi <- file.info(pathname)
[17:47:06.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:06.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:06.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:06.920]                         fi[["size"]], fi[["mtime"]])
[17:47:06.920]                       stop(msg)
[17:47:06.920]                     }
[17:47:06.920]                     invisible(pathname)
[17:47:06.920]                   }
[17:47:06.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:06.920]                     rootPath = tempdir()) 
[17:47:06.920]                   {
[17:47:06.920]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:06.920]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:06.920]                       tmpdir = path, fileext = ".rds")
[17:47:06.920]                     save_rds(obj, file)
[17:47:06.920]                   }
[17:47:06.920]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:06.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.920]                   {
[17:47:06.920]                     inherits <- base::inherits
[17:47:06.920]                     invokeRestart <- base::invokeRestart
[17:47:06.920]                     is.null <- base::is.null
[17:47:06.920]                     muffled <- FALSE
[17:47:06.920]                     if (inherits(cond, "message")) {
[17:47:06.920]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:06.920]                       if (muffled) 
[17:47:06.920]                         invokeRestart("muffleMessage")
[17:47:06.920]                     }
[17:47:06.920]                     else if (inherits(cond, "warning")) {
[17:47:06.920]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:06.920]                       if (muffled) 
[17:47:06.920]                         invokeRestart("muffleWarning")
[17:47:06.920]                     }
[17:47:06.920]                     else if (inherits(cond, "condition")) {
[17:47:06.920]                       if (!is.null(pattern)) {
[17:47:06.920]                         computeRestarts <- base::computeRestarts
[17:47:06.920]                         grepl <- base::grepl
[17:47:06.920]                         restarts <- computeRestarts(cond)
[17:47:06.920]                         for (restart in restarts) {
[17:47:06.920]                           name <- restart$name
[17:47:06.920]                           if (is.null(name)) 
[17:47:06.920]                             next
[17:47:06.920]                           if (!grepl(pattern, name)) 
[17:47:06.920]                             next
[17:47:06.920]                           invokeRestart(restart)
[17:47:06.920]                           muffled <- TRUE
[17:47:06.920]                           break
[17:47:06.920]                         }
[17:47:06.920]                       }
[17:47:06.920]                     }
[17:47:06.920]                     invisible(muffled)
[17:47:06.920]                   }
[17:47:06.920]                   muffleCondition(cond)
[17:47:06.920]                 })
[17:47:06.920]             }))
[17:47:06.920]             future::FutureResult(value = ...future.value$value, 
[17:47:06.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.920]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.920]                     ...future.globalenv.names))
[17:47:06.920]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.920]         }, condition = base::local({
[17:47:06.920]             c <- base::c
[17:47:06.920]             inherits <- base::inherits
[17:47:06.920]             invokeRestart <- base::invokeRestart
[17:47:06.920]             length <- base::length
[17:47:06.920]             list <- base::list
[17:47:06.920]             seq.int <- base::seq.int
[17:47:06.920]             signalCondition <- base::signalCondition
[17:47:06.920]             sys.calls <- base::sys.calls
[17:47:06.920]             `[[` <- base::`[[`
[17:47:06.920]             `+` <- base::`+`
[17:47:06.920]             `<<-` <- base::`<<-`
[17:47:06.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.920]                   3L)]
[17:47:06.920]             }
[17:47:06.920]             function(cond) {
[17:47:06.920]                 is_error <- inherits(cond, "error")
[17:47:06.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.920]                   NULL)
[17:47:06.920]                 if (is_error) {
[17:47:06.920]                   sessionInformation <- function() {
[17:47:06.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.920]                       search = base::search(), system = base::Sys.info())
[17:47:06.920]                   }
[17:47:06.920]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.920]                     cond$call), session = sessionInformation(), 
[17:47:06.920]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.920]                   signalCondition(cond)
[17:47:06.920]                 }
[17:47:06.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.920]                 "immediateCondition"))) {
[17:47:06.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.920]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.920]                   if (TRUE && !signal) {
[17:47:06.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.920]                     {
[17:47:06.920]                       inherits <- base::inherits
[17:47:06.920]                       invokeRestart <- base::invokeRestart
[17:47:06.920]                       is.null <- base::is.null
[17:47:06.920]                       muffled <- FALSE
[17:47:06.920]                       if (inherits(cond, "message")) {
[17:47:06.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.920]                         if (muffled) 
[17:47:06.920]                           invokeRestart("muffleMessage")
[17:47:06.920]                       }
[17:47:06.920]                       else if (inherits(cond, "warning")) {
[17:47:06.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.920]                         if (muffled) 
[17:47:06.920]                           invokeRestart("muffleWarning")
[17:47:06.920]                       }
[17:47:06.920]                       else if (inherits(cond, "condition")) {
[17:47:06.920]                         if (!is.null(pattern)) {
[17:47:06.920]                           computeRestarts <- base::computeRestarts
[17:47:06.920]                           grepl <- base::grepl
[17:47:06.920]                           restarts <- computeRestarts(cond)
[17:47:06.920]                           for (restart in restarts) {
[17:47:06.920]                             name <- restart$name
[17:47:06.920]                             if (is.null(name)) 
[17:47:06.920]                               next
[17:47:06.920]                             if (!grepl(pattern, name)) 
[17:47:06.920]                               next
[17:47:06.920]                             invokeRestart(restart)
[17:47:06.920]                             muffled <- TRUE
[17:47:06.920]                             break
[17:47:06.920]                           }
[17:47:06.920]                         }
[17:47:06.920]                       }
[17:47:06.920]                       invisible(muffled)
[17:47:06.920]                     }
[17:47:06.920]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.920]                   }
[17:47:06.920]                 }
[17:47:06.920]                 else {
[17:47:06.920]                   if (TRUE) {
[17:47:06.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.920]                     {
[17:47:06.920]                       inherits <- base::inherits
[17:47:06.920]                       invokeRestart <- base::invokeRestart
[17:47:06.920]                       is.null <- base::is.null
[17:47:06.920]                       muffled <- FALSE
[17:47:06.920]                       if (inherits(cond, "message")) {
[17:47:06.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.920]                         if (muffled) 
[17:47:06.920]                           invokeRestart("muffleMessage")
[17:47:06.920]                       }
[17:47:06.920]                       else if (inherits(cond, "warning")) {
[17:47:06.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.920]                         if (muffled) 
[17:47:06.920]                           invokeRestart("muffleWarning")
[17:47:06.920]                       }
[17:47:06.920]                       else if (inherits(cond, "condition")) {
[17:47:06.920]                         if (!is.null(pattern)) {
[17:47:06.920]                           computeRestarts <- base::computeRestarts
[17:47:06.920]                           grepl <- base::grepl
[17:47:06.920]                           restarts <- computeRestarts(cond)
[17:47:06.920]                           for (restart in restarts) {
[17:47:06.920]                             name <- restart$name
[17:47:06.920]                             if (is.null(name)) 
[17:47:06.920]                               next
[17:47:06.920]                             if (!grepl(pattern, name)) 
[17:47:06.920]                               next
[17:47:06.920]                             invokeRestart(restart)
[17:47:06.920]                             muffled <- TRUE
[17:47:06.920]                             break
[17:47:06.920]                           }
[17:47:06.920]                         }
[17:47:06.920]                       }
[17:47:06.920]                       invisible(muffled)
[17:47:06.920]                     }
[17:47:06.920]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.920]                   }
[17:47:06.920]                 }
[17:47:06.920]             }
[17:47:06.920]         }))
[17:47:06.920]     }, error = function(ex) {
[17:47:06.920]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.920]                 ...future.rng), started = ...future.startTime, 
[17:47:06.920]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.920]             version = "1.8"), class = "FutureResult")
[17:47:06.920]     }, finally = {
[17:47:06.920]         if (!identical(...future.workdir, getwd())) 
[17:47:06.920]             setwd(...future.workdir)
[17:47:06.920]         {
[17:47:06.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.920]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.920]             }
[17:47:06.920]             base::options(...future.oldOptions)
[17:47:06.920]             if (.Platform$OS.type == "windows") {
[17:47:06.920]                 old_names <- names(...future.oldEnvVars)
[17:47:06.920]                 envs <- base::Sys.getenv()
[17:47:06.920]                 names <- names(envs)
[17:47:06.920]                 common <- intersect(names, old_names)
[17:47:06.920]                 added <- setdiff(names, old_names)
[17:47:06.920]                 removed <- setdiff(old_names, names)
[17:47:06.920]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.920]                   envs[common]]
[17:47:06.920]                 NAMES <- toupper(changed)
[17:47:06.920]                 args <- list()
[17:47:06.920]                 for (kk in seq_along(NAMES)) {
[17:47:06.920]                   name <- changed[[kk]]
[17:47:06.920]                   NAME <- NAMES[[kk]]
[17:47:06.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.920]                     next
[17:47:06.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.920]                 }
[17:47:06.920]                 NAMES <- toupper(added)
[17:47:06.920]                 for (kk in seq_along(NAMES)) {
[17:47:06.920]                   name <- added[[kk]]
[17:47:06.920]                   NAME <- NAMES[[kk]]
[17:47:06.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.920]                     next
[17:47:06.920]                   args[[name]] <- ""
[17:47:06.920]                 }
[17:47:06.920]                 NAMES <- toupper(removed)
[17:47:06.920]                 for (kk in seq_along(NAMES)) {
[17:47:06.920]                   name <- removed[[kk]]
[17:47:06.920]                   NAME <- NAMES[[kk]]
[17:47:06.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.920]                     next
[17:47:06.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.920]                 }
[17:47:06.920]                 if (length(args) > 0) 
[17:47:06.920]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.920]             }
[17:47:06.920]             else {
[17:47:06.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.920]             }
[17:47:06.920]             {
[17:47:06.920]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.920]                   0L) {
[17:47:06.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.920]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.920]                   base::options(opts)
[17:47:06.920]                 }
[17:47:06.920]                 {
[17:47:06.920]                   {
[17:47:06.920]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:06.920]                     NULL
[17:47:06.920]                   }
[17:47:06.920]                   options(future.plan = NULL)
[17:47:06.920]                   if (is.na(NA_character_)) 
[17:47:06.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.920]                     .init = FALSE)
[17:47:06.920]                 }
[17:47:06.920]             }
[17:47:06.920]         }
[17:47:06.920]     })
[17:47:06.920]     if (TRUE) {
[17:47:06.920]         base::sink(type = "output", split = FALSE)
[17:47:06.920]         if (TRUE) {
[17:47:06.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.920]         }
[17:47:06.920]         else {
[17:47:06.920]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.920]         }
[17:47:06.920]         base::close(...future.stdout)
[17:47:06.920]         ...future.stdout <- NULL
[17:47:06.920]     }
[17:47:06.920]     ...future.result$conditions <- ...future.conditions
[17:47:06.920]     ...future.result$finished <- base::Sys.time()
[17:47:06.920]     ...future.result
[17:47:06.920] }
[17:47:06.922] requestCore(): workers = 2
[17:47:06.924] MulticoreFuture started
[17:47:06.924] - Launch lazy future ... done
[17:47:06.924] run() for ‘MulticoreFuture’ ... done
[17:47:06.924] result() for MulticoreFuture ...
[17:47:06.925] plan(): Setting new future strategy stack:
[17:47:06.925] List of future strategies:
[17:47:06.925] 1. sequential:
[17:47:06.925]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.925]    - tweaked: FALSE
[17:47:06.925]    - call: NULL
[17:47:06.926] plan(): nbrOfWorkers() = 1
[17:47:06.928] plan(): Setting new future strategy stack:
[17:47:06.928] List of future strategies:
[17:47:06.928] 1. multicore:
[17:47:06.928]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:06.928]    - tweaked: FALSE
[17:47:06.928]    - call: plan(strategy)
[17:47:06.933] plan(): nbrOfWorkers() = 2
[17:47:06.939] result() for MulticoreFuture ...
[17:47:06.939] result() for MulticoreFuture ... done
[17:47:06.939] signalConditions() ...
[17:47:06.939]  - include = ‘immediateCondition’
[17:47:06.940]  - exclude = 
[17:47:06.940]  - resignal = FALSE
[17:47:06.940]  - Number of conditions: 1
[17:47:06.940] signalConditions() ... done
[17:47:06.940] result() for MulticoreFuture ... done
[17:47:06.940] result() for MulticoreFuture ...
[17:47:06.940] result() for MulticoreFuture ... done
[17:47:06.940] signalConditions() ...
[17:47:06.941]  - include = ‘immediateCondition’
[17:47:06.941]  - exclude = 
[17:47:06.941]  - resignal = FALSE
[17:47:06.941]  - Number of conditions: 1
[17:47:06.941] signalConditions() ... done
[17:47:06.941] Future state: ‘finished’
[17:47:06.941] result() for MulticoreFuture ...
[17:47:06.941] result() for MulticoreFuture ... done
[17:47:06.942] signalConditions() ...
[17:47:06.942]  - include = ‘condition’
[17:47:06.942]  - exclude = ‘immediateCondition’
[17:47:06.942]  - resignal = TRUE
[17:47:06.942]  - Number of conditions: 1
[17:47:06.942]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:47:06.942] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-22 17:47:06"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.971] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.971] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.972] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.973] Searching for globals ... DONE
[17:47:06.973] Resolving globals: TRUE
[17:47:06.973] Resolving any globals that are futures ...
[17:47:06.973] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.973] Resolving any globals that are futures ... DONE
[17:47:06.973] Resolving futures part of globals (recursively) ...
[17:47:06.974] resolve() on list ...
[17:47:06.974]  recursive: 99
[17:47:06.974]  length: 1
[17:47:06.974]  elements: ‘ii’
[17:47:06.974]  length: 0 (resolved future 1)
[17:47:06.974] resolve() on list ... DONE
[17:47:06.974] - globals: [1] ‘ii’
[17:47:06.974] Resolving futures part of globals (recursively) ... DONE
[17:47:06.974] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:06.975] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:06.975] - globals: [1] ‘ii’
[17:47:06.975] 
[17:47:06.975] getGlobalsAndPackages() ... DONE
[17:47:06.975] run() for ‘Future’ ...
[17:47:06.976] - state: ‘created’
[17:47:06.976] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:06.979] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:06.980] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:06.980]   - Field: ‘label’
[17:47:06.980]   - Field: ‘local’
[17:47:06.980]   - Field: ‘owner’
[17:47:06.980]   - Field: ‘envir’
[17:47:06.980]   - Field: ‘workers’
[17:47:06.982]   - Field: ‘packages’
[17:47:06.982]   - Field: ‘gc’
[17:47:06.982]   - Field: ‘job’
[17:47:06.982]   - Field: ‘conditions’
[17:47:06.982]   - Field: ‘expr’
[17:47:06.982]   - Field: ‘uuid’
[17:47:06.982]   - Field: ‘seed’
[17:47:06.982]   - Field: ‘version’
[17:47:06.982]   - Field: ‘result’
[17:47:06.982]   - Field: ‘asynchronous’
[17:47:06.983]   - Field: ‘calls’
[17:47:06.983]   - Field: ‘globals’
[17:47:06.983]   - Field: ‘stdout’
[17:47:06.983]   - Field: ‘earlySignal’
[17:47:06.983]   - Field: ‘lazy’
[17:47:06.983]   - Field: ‘state’
[17:47:06.983] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:06.983] - Launch lazy future ...
[17:47:06.984] Packages needed by the future expression (n = 0): <none>
[17:47:06.984] Packages needed by future strategies (n = 0): <none>
[17:47:06.984] {
[17:47:06.984]     {
[17:47:06.984]         {
[17:47:06.984]             ...future.startTime <- base::Sys.time()
[17:47:06.984]             {
[17:47:06.984]                 {
[17:47:06.984]                   {
[17:47:06.984]                     {
[17:47:06.984]                       base::local({
[17:47:06.984]                         has_future <- base::requireNamespace("future", 
[17:47:06.984]                           quietly = TRUE)
[17:47:06.984]                         if (has_future) {
[17:47:06.984]                           ns <- base::getNamespace("future")
[17:47:06.984]                           version <- ns[[".package"]][["version"]]
[17:47:06.984]                           if (is.null(version)) 
[17:47:06.984]                             version <- utils::packageVersion("future")
[17:47:06.984]                         }
[17:47:06.984]                         else {
[17:47:06.984]                           version <- NULL
[17:47:06.984]                         }
[17:47:06.984]                         if (!has_future || version < "1.8.0") {
[17:47:06.984]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:06.984]                             "", base::R.version$version.string), 
[17:47:06.984]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:06.984]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:06.984]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:06.984]                               "release", "version")], collapse = " "), 
[17:47:06.984]                             hostname = base::Sys.info()[["nodename"]])
[17:47:06.984]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:06.984]                             info)
[17:47:06.984]                           info <- base::paste(info, collapse = "; ")
[17:47:06.984]                           if (!has_future) {
[17:47:06.984]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:06.984]                               info)
[17:47:06.984]                           }
[17:47:06.984]                           else {
[17:47:06.984]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:06.984]                               info, version)
[17:47:06.984]                           }
[17:47:06.984]                           base::stop(msg)
[17:47:06.984]                         }
[17:47:06.984]                       })
[17:47:06.984]                     }
[17:47:06.984]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:06.984]                     base::options(mc.cores = 1L)
[17:47:06.984]                   }
[17:47:06.984]                   ...future.strategy.old <- future::plan("list")
[17:47:06.984]                   options(future.plan = NULL)
[17:47:06.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:06.984]                 }
[17:47:06.984]                 ...future.workdir <- getwd()
[17:47:06.984]             }
[17:47:06.984]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:06.984]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:06.984]         }
[17:47:06.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:06.984]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:06.984]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:06.984]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:06.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:06.984]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:06.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:06.984]             base::names(...future.oldOptions))
[17:47:06.984]     }
[17:47:06.984]     if (FALSE) {
[17:47:06.984]     }
[17:47:06.984]     else {
[17:47:06.984]         if (TRUE) {
[17:47:06.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:06.984]                 open = "w")
[17:47:06.984]         }
[17:47:06.984]         else {
[17:47:06.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:06.984]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:06.984]         }
[17:47:06.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:06.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:06.984]             base::sink(type = "output", split = FALSE)
[17:47:06.984]             base::close(...future.stdout)
[17:47:06.984]         }, add = TRUE)
[17:47:06.984]     }
[17:47:06.984]     ...future.frame <- base::sys.nframe()
[17:47:06.984]     ...future.conditions <- base::list()
[17:47:06.984]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:06.984]     if (FALSE) {
[17:47:06.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:06.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:06.984]     }
[17:47:06.984]     ...future.result <- base::tryCatch({
[17:47:06.984]         base::withCallingHandlers({
[17:47:06.984]             ...future.value <- base::withVisible(base::local({
[17:47:06.984]                 withCallingHandlers({
[17:47:06.984]                   {
[17:47:06.984]                     b <- a * ii
[17:47:06.984]                     a <- 0
[17:47:06.984]                     b
[17:47:06.984]                   }
[17:47:06.984]                 }, immediateCondition = function(cond) {
[17:47:06.984]                   save_rds <- function (object, pathname, ...) 
[17:47:06.984]                   {
[17:47:06.984]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:06.984]                     if (file_test("-f", pathname_tmp)) {
[17:47:06.984]                       fi_tmp <- file.info(pathname_tmp)
[17:47:06.984]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:06.984]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:06.984]                         fi_tmp[["mtime"]])
[17:47:06.984]                     }
[17:47:06.984]                     tryCatch({
[17:47:06.984]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:06.984]                     }, error = function(ex) {
[17:47:06.984]                       msg <- conditionMessage(ex)
[17:47:06.984]                       fi_tmp <- file.info(pathname_tmp)
[17:47:06.984]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:06.984]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:06.984]                         fi_tmp[["mtime"]], msg)
[17:47:06.984]                       ex$message <- msg
[17:47:06.984]                       stop(ex)
[17:47:06.984]                     })
[17:47:06.984]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:06.984]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:06.984]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:06.984]                       fi_tmp <- file.info(pathname_tmp)
[17:47:06.984]                       fi <- file.info(pathname)
[17:47:06.984]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:06.984]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:06.984]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:06.984]                         fi[["size"]], fi[["mtime"]])
[17:47:06.984]                       stop(msg)
[17:47:06.984]                     }
[17:47:06.984]                     invisible(pathname)
[17:47:06.984]                   }
[17:47:06.984]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:06.984]                     rootPath = tempdir()) 
[17:47:06.984]                   {
[17:47:06.984]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:06.984]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:06.984]                       tmpdir = path, fileext = ".rds")
[17:47:06.984]                     save_rds(obj, file)
[17:47:06.984]                   }
[17:47:06.984]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:06.984]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.984]                   {
[17:47:06.984]                     inherits <- base::inherits
[17:47:06.984]                     invokeRestart <- base::invokeRestart
[17:47:06.984]                     is.null <- base::is.null
[17:47:06.984]                     muffled <- FALSE
[17:47:06.984]                     if (inherits(cond, "message")) {
[17:47:06.984]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:06.984]                       if (muffled) 
[17:47:06.984]                         invokeRestart("muffleMessage")
[17:47:06.984]                     }
[17:47:06.984]                     else if (inherits(cond, "warning")) {
[17:47:06.984]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:06.984]                       if (muffled) 
[17:47:06.984]                         invokeRestart("muffleWarning")
[17:47:06.984]                     }
[17:47:06.984]                     else if (inherits(cond, "condition")) {
[17:47:06.984]                       if (!is.null(pattern)) {
[17:47:06.984]                         computeRestarts <- base::computeRestarts
[17:47:06.984]                         grepl <- base::grepl
[17:47:06.984]                         restarts <- computeRestarts(cond)
[17:47:06.984]                         for (restart in restarts) {
[17:47:06.984]                           name <- restart$name
[17:47:06.984]                           if (is.null(name)) 
[17:47:06.984]                             next
[17:47:06.984]                           if (!grepl(pattern, name)) 
[17:47:06.984]                             next
[17:47:06.984]                           invokeRestart(restart)
[17:47:06.984]                           muffled <- TRUE
[17:47:06.984]                           break
[17:47:06.984]                         }
[17:47:06.984]                       }
[17:47:06.984]                     }
[17:47:06.984]                     invisible(muffled)
[17:47:06.984]                   }
[17:47:06.984]                   muffleCondition(cond)
[17:47:06.984]                 })
[17:47:06.984]             }))
[17:47:06.984]             future::FutureResult(value = ...future.value$value, 
[17:47:06.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.984]                   ...future.rng), globalenv = if (FALSE) 
[17:47:06.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:06.984]                     ...future.globalenv.names))
[17:47:06.984]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:06.984]         }, condition = base::local({
[17:47:06.984]             c <- base::c
[17:47:06.984]             inherits <- base::inherits
[17:47:06.984]             invokeRestart <- base::invokeRestart
[17:47:06.984]             length <- base::length
[17:47:06.984]             list <- base::list
[17:47:06.984]             seq.int <- base::seq.int
[17:47:06.984]             signalCondition <- base::signalCondition
[17:47:06.984]             sys.calls <- base::sys.calls
[17:47:06.984]             `[[` <- base::`[[`
[17:47:06.984]             `+` <- base::`+`
[17:47:06.984]             `<<-` <- base::`<<-`
[17:47:06.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:06.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:06.984]                   3L)]
[17:47:06.984]             }
[17:47:06.984]             function(cond) {
[17:47:06.984]                 is_error <- inherits(cond, "error")
[17:47:06.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:06.984]                   NULL)
[17:47:06.984]                 if (is_error) {
[17:47:06.984]                   sessionInformation <- function() {
[17:47:06.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:06.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:06.984]                       search = base::search(), system = base::Sys.info())
[17:47:06.984]                   }
[17:47:06.984]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:06.984]                     cond$call), session = sessionInformation(), 
[17:47:06.984]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:06.984]                   signalCondition(cond)
[17:47:06.984]                 }
[17:47:06.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:06.984]                 "immediateCondition"))) {
[17:47:06.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:06.984]                   ...future.conditions[[length(...future.conditions) + 
[17:47:06.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:06.984]                   if (TRUE && !signal) {
[17:47:06.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.984]                     {
[17:47:06.984]                       inherits <- base::inherits
[17:47:06.984]                       invokeRestart <- base::invokeRestart
[17:47:06.984]                       is.null <- base::is.null
[17:47:06.984]                       muffled <- FALSE
[17:47:06.984]                       if (inherits(cond, "message")) {
[17:47:06.984]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.984]                         if (muffled) 
[17:47:06.984]                           invokeRestart("muffleMessage")
[17:47:06.984]                       }
[17:47:06.984]                       else if (inherits(cond, "warning")) {
[17:47:06.984]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.984]                         if (muffled) 
[17:47:06.984]                           invokeRestart("muffleWarning")
[17:47:06.984]                       }
[17:47:06.984]                       else if (inherits(cond, "condition")) {
[17:47:06.984]                         if (!is.null(pattern)) {
[17:47:06.984]                           computeRestarts <- base::computeRestarts
[17:47:06.984]                           grepl <- base::grepl
[17:47:06.984]                           restarts <- computeRestarts(cond)
[17:47:06.984]                           for (restart in restarts) {
[17:47:06.984]                             name <- restart$name
[17:47:06.984]                             if (is.null(name)) 
[17:47:06.984]                               next
[17:47:06.984]                             if (!grepl(pattern, name)) 
[17:47:06.984]                               next
[17:47:06.984]                             invokeRestart(restart)
[17:47:06.984]                             muffled <- TRUE
[17:47:06.984]                             break
[17:47:06.984]                           }
[17:47:06.984]                         }
[17:47:06.984]                       }
[17:47:06.984]                       invisible(muffled)
[17:47:06.984]                     }
[17:47:06.984]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.984]                   }
[17:47:06.984]                 }
[17:47:06.984]                 else {
[17:47:06.984]                   if (TRUE) {
[17:47:06.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:06.984]                     {
[17:47:06.984]                       inherits <- base::inherits
[17:47:06.984]                       invokeRestart <- base::invokeRestart
[17:47:06.984]                       is.null <- base::is.null
[17:47:06.984]                       muffled <- FALSE
[17:47:06.984]                       if (inherits(cond, "message")) {
[17:47:06.984]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:06.984]                         if (muffled) 
[17:47:06.984]                           invokeRestart("muffleMessage")
[17:47:06.984]                       }
[17:47:06.984]                       else if (inherits(cond, "warning")) {
[17:47:06.984]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:06.984]                         if (muffled) 
[17:47:06.984]                           invokeRestart("muffleWarning")
[17:47:06.984]                       }
[17:47:06.984]                       else if (inherits(cond, "condition")) {
[17:47:06.984]                         if (!is.null(pattern)) {
[17:47:06.984]                           computeRestarts <- base::computeRestarts
[17:47:06.984]                           grepl <- base::grepl
[17:47:06.984]                           restarts <- computeRestarts(cond)
[17:47:06.984]                           for (restart in restarts) {
[17:47:06.984]                             name <- restart$name
[17:47:06.984]                             if (is.null(name)) 
[17:47:06.984]                               next
[17:47:06.984]                             if (!grepl(pattern, name)) 
[17:47:06.984]                               next
[17:47:06.984]                             invokeRestart(restart)
[17:47:06.984]                             muffled <- TRUE
[17:47:06.984]                             break
[17:47:06.984]                           }
[17:47:06.984]                         }
[17:47:06.984]                       }
[17:47:06.984]                       invisible(muffled)
[17:47:06.984]                     }
[17:47:06.984]                     muffleCondition(cond, pattern = "^muffle")
[17:47:06.984]                   }
[17:47:06.984]                 }
[17:47:06.984]             }
[17:47:06.984]         }))
[17:47:06.984]     }, error = function(ex) {
[17:47:06.984]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:06.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:06.984]                 ...future.rng), started = ...future.startTime, 
[17:47:06.984]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:06.984]             version = "1.8"), class = "FutureResult")
[17:47:06.984]     }, finally = {
[17:47:06.984]         if (!identical(...future.workdir, getwd())) 
[17:47:06.984]             setwd(...future.workdir)
[17:47:06.984]         {
[17:47:06.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:06.984]                 ...future.oldOptions$nwarnings <- NULL
[17:47:06.984]             }
[17:47:06.984]             base::options(...future.oldOptions)
[17:47:06.984]             if (.Platform$OS.type == "windows") {
[17:47:06.984]                 old_names <- names(...future.oldEnvVars)
[17:47:06.984]                 envs <- base::Sys.getenv()
[17:47:06.984]                 names <- names(envs)
[17:47:06.984]                 common <- intersect(names, old_names)
[17:47:06.984]                 added <- setdiff(names, old_names)
[17:47:06.984]                 removed <- setdiff(old_names, names)
[17:47:06.984]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:06.984]                   envs[common]]
[17:47:06.984]                 NAMES <- toupper(changed)
[17:47:06.984]                 args <- list()
[17:47:06.984]                 for (kk in seq_along(NAMES)) {
[17:47:06.984]                   name <- changed[[kk]]
[17:47:06.984]                   NAME <- NAMES[[kk]]
[17:47:06.984]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.984]                     next
[17:47:06.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.984]                 }
[17:47:06.984]                 NAMES <- toupper(added)
[17:47:06.984]                 for (kk in seq_along(NAMES)) {
[17:47:06.984]                   name <- added[[kk]]
[17:47:06.984]                   NAME <- NAMES[[kk]]
[17:47:06.984]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.984]                     next
[17:47:06.984]                   args[[name]] <- ""
[17:47:06.984]                 }
[17:47:06.984]                 NAMES <- toupper(removed)
[17:47:06.984]                 for (kk in seq_along(NAMES)) {
[17:47:06.984]                   name <- removed[[kk]]
[17:47:06.984]                   NAME <- NAMES[[kk]]
[17:47:06.984]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:06.984]                     next
[17:47:06.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:06.984]                 }
[17:47:06.984]                 if (length(args) > 0) 
[17:47:06.984]                   base::do.call(base::Sys.setenv, args = args)
[17:47:06.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:06.984]             }
[17:47:06.984]             else {
[17:47:06.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:06.984]             }
[17:47:06.984]             {
[17:47:06.984]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:06.984]                   0L) {
[17:47:06.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:06.984]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:06.984]                   base::options(opts)
[17:47:06.984]                 }
[17:47:06.984]                 {
[17:47:06.984]                   {
[17:47:06.984]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:06.984]                     NULL
[17:47:06.984]                   }
[17:47:06.984]                   options(future.plan = NULL)
[17:47:06.984]                   if (is.na(NA_character_)) 
[17:47:06.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:06.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:06.984]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:06.984]                     .init = FALSE)
[17:47:06.984]                 }
[17:47:06.984]             }
[17:47:06.984]         }
[17:47:06.984]     })
[17:47:06.984]     if (TRUE) {
[17:47:06.984]         base::sink(type = "output", split = FALSE)
[17:47:06.984]         if (TRUE) {
[17:47:06.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:06.984]         }
[17:47:06.984]         else {
[17:47:06.984]             ...future.result["stdout"] <- base::list(NULL)
[17:47:06.984]         }
[17:47:06.984]         base::close(...future.stdout)
[17:47:06.984]         ...future.stdout <- NULL
[17:47:06.984]     }
[17:47:06.984]     ...future.result$conditions <- ...future.conditions
[17:47:06.984]     ...future.result$finished <- base::Sys.time()
[17:47:06.984]     ...future.result
[17:47:06.984] }
[17:47:06.986] assign_globals() ...
[17:47:06.986] List of 1
[17:47:06.986]  $ ii: int 1
[17:47:06.986]  - attr(*, "where")=List of 1
[17:47:06.986]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:06.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:06.986]  - attr(*, "resolved")= logi TRUE
[17:47:06.986]  - attr(*, "total_size")= num 56
[17:47:06.986]  - attr(*, "already-done")= logi TRUE
[17:47:06.989] - copied ‘ii’ to environment
[17:47:06.989] assign_globals() ... done
[17:47:06.989] requestCore(): workers = 2
[17:47:06.991] MulticoreFuture started
[17:47:06.991] - Launch lazy future ... done
[17:47:06.992] run() for ‘MulticoreFuture’ ... done
[17:47:06.992] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:06.993] getGlobalsAndPackages() ...
[17:47:06.992] List of future strategies:
[17:47:06.992] 1. sequential:
[17:47:06.992]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:06.992]    - tweaked: FALSE
[17:47:06.992]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:06.994] plan(): nbrOfWorkers() = 1
[17:47:06.994] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:06.996] plan(): Setting new future strategy stack:
[17:47:06.996] List of future strategies:
[17:47:06.996] 1. multicore:
[17:47:06.996]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:06.996]    - tweaked: FALSE
[17:47:06.996]    - call: plan(strategy)
[17:47:06.996] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.997] Searching for globals ... DONE
[17:47:06.997] Resolving globals: TRUE
[17:47:06.997] Resolving any globals that are futures ...
[17:47:06.997] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:06.997] Resolving any globals that are futures ... DONE
[17:47:06.998] Resolving futures part of globals (recursively) ...
[17:47:06.998] resolve() on list ...
[17:47:06.999]  recursive: 99
[17:47:06.999]  length: 1
[17:47:06.999]  elements: ‘ii’
[17:47:06.999]  length: 0 (resolved future 1)
[17:47:06.999] resolve() on list ... DONE
[17:47:06.999] - globals: [1] ‘ii’
[17:47:07.000] Resolving futures part of globals (recursively) ... DONE
[17:47:07.000] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:07.000] plan(): nbrOfWorkers() = 2
[17:47:07.000] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.001] - globals: [1] ‘ii’
[17:47:07.001] 
[17:47:07.001] getGlobalsAndPackages() ... DONE
[17:47:07.001] run() for ‘Future’ ...
[17:47:07.001] - state: ‘created’
[17:47:07.002] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.006] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.006]   - Field: ‘label’
[17:47:07.006]   - Field: ‘local’
[17:47:07.007]   - Field: ‘owner’
[17:47:07.007]   - Field: ‘envir’
[17:47:07.007]   - Field: ‘workers’
[17:47:07.007]   - Field: ‘packages’
[17:47:07.007]   - Field: ‘gc’
[17:47:07.007]   - Field: ‘job’
[17:47:07.008]   - Field: ‘conditions’
[17:47:07.008]   - Field: ‘expr’
[17:47:07.008]   - Field: ‘uuid’
[17:47:07.008]   - Field: ‘seed’
[17:47:07.008]   - Field: ‘version’
[17:47:07.008]   - Field: ‘result’
[17:47:07.008]   - Field: ‘asynchronous’
[17:47:07.008]   - Field: ‘calls’
[17:47:07.009]   - Field: ‘globals’
[17:47:07.009]   - Field: ‘stdout’
[17:47:07.009]   - Field: ‘earlySignal’
[17:47:07.009]   - Field: ‘lazy’
[17:47:07.009]   - Field: ‘state’
[17:47:07.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.009] - Launch lazy future ...
[17:47:07.010] Packages needed by the future expression (n = 0): <none>
[17:47:07.010] Packages needed by future strategies (n = 0): <none>
[17:47:07.011] {
[17:47:07.011]     {
[17:47:07.011]         {
[17:47:07.011]             ...future.startTime <- base::Sys.time()
[17:47:07.011]             {
[17:47:07.011]                 {
[17:47:07.011]                   {
[17:47:07.011]                     {
[17:47:07.011]                       base::local({
[17:47:07.011]                         has_future <- base::requireNamespace("future", 
[17:47:07.011]                           quietly = TRUE)
[17:47:07.011]                         if (has_future) {
[17:47:07.011]                           ns <- base::getNamespace("future")
[17:47:07.011]                           version <- ns[[".package"]][["version"]]
[17:47:07.011]                           if (is.null(version)) 
[17:47:07.011]                             version <- utils::packageVersion("future")
[17:47:07.011]                         }
[17:47:07.011]                         else {
[17:47:07.011]                           version <- NULL
[17:47:07.011]                         }
[17:47:07.011]                         if (!has_future || version < "1.8.0") {
[17:47:07.011]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.011]                             "", base::R.version$version.string), 
[17:47:07.011]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.011]                               "release", "version")], collapse = " "), 
[17:47:07.011]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.011]                             info)
[17:47:07.011]                           info <- base::paste(info, collapse = "; ")
[17:47:07.011]                           if (!has_future) {
[17:47:07.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.011]                               info)
[17:47:07.011]                           }
[17:47:07.011]                           else {
[17:47:07.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.011]                               info, version)
[17:47:07.011]                           }
[17:47:07.011]                           base::stop(msg)
[17:47:07.011]                         }
[17:47:07.011]                       })
[17:47:07.011]                     }
[17:47:07.011]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.011]                     base::options(mc.cores = 1L)
[17:47:07.011]                   }
[17:47:07.011]                   ...future.strategy.old <- future::plan("list")
[17:47:07.011]                   options(future.plan = NULL)
[17:47:07.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.011]                 }
[17:47:07.011]                 ...future.workdir <- getwd()
[17:47:07.011]             }
[17:47:07.011]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.011]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.011]         }
[17:47:07.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.011]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.011]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.011]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.011]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.011]             base::names(...future.oldOptions))
[17:47:07.011]     }
[17:47:07.011]     if (FALSE) {
[17:47:07.011]     }
[17:47:07.011]     else {
[17:47:07.011]         if (TRUE) {
[17:47:07.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.011]                 open = "w")
[17:47:07.011]         }
[17:47:07.011]         else {
[17:47:07.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.011]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.011]         }
[17:47:07.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.011]             base::sink(type = "output", split = FALSE)
[17:47:07.011]             base::close(...future.stdout)
[17:47:07.011]         }, add = TRUE)
[17:47:07.011]     }
[17:47:07.011]     ...future.frame <- base::sys.nframe()
[17:47:07.011]     ...future.conditions <- base::list()
[17:47:07.011]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.011]     if (FALSE) {
[17:47:07.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.011]     }
[17:47:07.011]     ...future.result <- base::tryCatch({
[17:47:07.011]         base::withCallingHandlers({
[17:47:07.011]             ...future.value <- base::withVisible(base::local({
[17:47:07.011]                 withCallingHandlers({
[17:47:07.011]                   {
[17:47:07.011]                     b <- a * ii
[17:47:07.011]                     a <- 0
[17:47:07.011]                     b
[17:47:07.011]                   }
[17:47:07.011]                 }, immediateCondition = function(cond) {
[17:47:07.011]                   save_rds <- function (object, pathname, ...) 
[17:47:07.011]                   {
[17:47:07.011]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.011]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.011]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.011]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.011]                         fi_tmp[["mtime"]])
[17:47:07.011]                     }
[17:47:07.011]                     tryCatch({
[17:47:07.011]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.011]                     }, error = function(ex) {
[17:47:07.011]                       msg <- conditionMessage(ex)
[17:47:07.011]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.011]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.011]                         fi_tmp[["mtime"]], msg)
[17:47:07.011]                       ex$message <- msg
[17:47:07.011]                       stop(ex)
[17:47:07.011]                     })
[17:47:07.011]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.011]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.011]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.011]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.011]                       fi <- file.info(pathname)
[17:47:07.011]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.011]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.011]                         fi[["size"]], fi[["mtime"]])
[17:47:07.011]                       stop(msg)
[17:47:07.011]                     }
[17:47:07.011]                     invisible(pathname)
[17:47:07.011]                   }
[17:47:07.011]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.011]                     rootPath = tempdir()) 
[17:47:07.011]                   {
[17:47:07.011]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.011]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.011]                       tmpdir = path, fileext = ".rds")
[17:47:07.011]                     save_rds(obj, file)
[17:47:07.011]                   }
[17:47:07.011]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.011]                   {
[17:47:07.011]                     inherits <- base::inherits
[17:47:07.011]                     invokeRestart <- base::invokeRestart
[17:47:07.011]                     is.null <- base::is.null
[17:47:07.011]                     muffled <- FALSE
[17:47:07.011]                     if (inherits(cond, "message")) {
[17:47:07.011]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.011]                       if (muffled) 
[17:47:07.011]                         invokeRestart("muffleMessage")
[17:47:07.011]                     }
[17:47:07.011]                     else if (inherits(cond, "warning")) {
[17:47:07.011]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.011]                       if (muffled) 
[17:47:07.011]                         invokeRestart("muffleWarning")
[17:47:07.011]                     }
[17:47:07.011]                     else if (inherits(cond, "condition")) {
[17:47:07.011]                       if (!is.null(pattern)) {
[17:47:07.011]                         computeRestarts <- base::computeRestarts
[17:47:07.011]                         grepl <- base::grepl
[17:47:07.011]                         restarts <- computeRestarts(cond)
[17:47:07.011]                         for (restart in restarts) {
[17:47:07.011]                           name <- restart$name
[17:47:07.011]                           if (is.null(name)) 
[17:47:07.011]                             next
[17:47:07.011]                           if (!grepl(pattern, name)) 
[17:47:07.011]                             next
[17:47:07.011]                           invokeRestart(restart)
[17:47:07.011]                           muffled <- TRUE
[17:47:07.011]                           break
[17:47:07.011]                         }
[17:47:07.011]                       }
[17:47:07.011]                     }
[17:47:07.011]                     invisible(muffled)
[17:47:07.011]                   }
[17:47:07.011]                   muffleCondition(cond)
[17:47:07.011]                 })
[17:47:07.011]             }))
[17:47:07.011]             future::FutureResult(value = ...future.value$value, 
[17:47:07.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.011]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.011]                     ...future.globalenv.names))
[17:47:07.011]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.011]         }, condition = base::local({
[17:47:07.011]             c <- base::c
[17:47:07.011]             inherits <- base::inherits
[17:47:07.011]             invokeRestart <- base::invokeRestart
[17:47:07.011]             length <- base::length
[17:47:07.011]             list <- base::list
[17:47:07.011]             seq.int <- base::seq.int
[17:47:07.011]             signalCondition <- base::signalCondition
[17:47:07.011]             sys.calls <- base::sys.calls
[17:47:07.011]             `[[` <- base::`[[`
[17:47:07.011]             `+` <- base::`+`
[17:47:07.011]             `<<-` <- base::`<<-`
[17:47:07.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.011]                   3L)]
[17:47:07.011]             }
[17:47:07.011]             function(cond) {
[17:47:07.011]                 is_error <- inherits(cond, "error")
[17:47:07.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.011]                   NULL)
[17:47:07.011]                 if (is_error) {
[17:47:07.011]                   sessionInformation <- function() {
[17:47:07.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.011]                       search = base::search(), system = base::Sys.info())
[17:47:07.011]                   }
[17:47:07.011]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.011]                     cond$call), session = sessionInformation(), 
[17:47:07.011]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.011]                   signalCondition(cond)
[17:47:07.011]                 }
[17:47:07.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.011]                 "immediateCondition"))) {
[17:47:07.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.011]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.011]                   if (TRUE && !signal) {
[17:47:07.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.011]                     {
[17:47:07.011]                       inherits <- base::inherits
[17:47:07.011]                       invokeRestart <- base::invokeRestart
[17:47:07.011]                       is.null <- base::is.null
[17:47:07.011]                       muffled <- FALSE
[17:47:07.011]                       if (inherits(cond, "message")) {
[17:47:07.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.011]                         if (muffled) 
[17:47:07.011]                           invokeRestart("muffleMessage")
[17:47:07.011]                       }
[17:47:07.011]                       else if (inherits(cond, "warning")) {
[17:47:07.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.011]                         if (muffled) 
[17:47:07.011]                           invokeRestart("muffleWarning")
[17:47:07.011]                       }
[17:47:07.011]                       else if (inherits(cond, "condition")) {
[17:47:07.011]                         if (!is.null(pattern)) {
[17:47:07.011]                           computeRestarts <- base::computeRestarts
[17:47:07.011]                           grepl <- base::grepl
[17:47:07.011]                           restarts <- computeRestarts(cond)
[17:47:07.011]                           for (restart in restarts) {
[17:47:07.011]                             name <- restart$name
[17:47:07.011]                             if (is.null(name)) 
[17:47:07.011]                               next
[17:47:07.011]                             if (!grepl(pattern, name)) 
[17:47:07.011]                               next
[17:47:07.011]                             invokeRestart(restart)
[17:47:07.011]                             muffled <- TRUE
[17:47:07.011]                             break
[17:47:07.011]                           }
[17:47:07.011]                         }
[17:47:07.011]                       }
[17:47:07.011]                       invisible(muffled)
[17:47:07.011]                     }
[17:47:07.011]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.011]                   }
[17:47:07.011]                 }
[17:47:07.011]                 else {
[17:47:07.011]                   if (TRUE) {
[17:47:07.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.011]                     {
[17:47:07.011]                       inherits <- base::inherits
[17:47:07.011]                       invokeRestart <- base::invokeRestart
[17:47:07.011]                       is.null <- base::is.null
[17:47:07.011]                       muffled <- FALSE
[17:47:07.011]                       if (inherits(cond, "message")) {
[17:47:07.011]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.011]                         if (muffled) 
[17:47:07.011]                           invokeRestart("muffleMessage")
[17:47:07.011]                       }
[17:47:07.011]                       else if (inherits(cond, "warning")) {
[17:47:07.011]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.011]                         if (muffled) 
[17:47:07.011]                           invokeRestart("muffleWarning")
[17:47:07.011]                       }
[17:47:07.011]                       else if (inherits(cond, "condition")) {
[17:47:07.011]                         if (!is.null(pattern)) {
[17:47:07.011]                           computeRestarts <- base::computeRestarts
[17:47:07.011]                           grepl <- base::grepl
[17:47:07.011]                           restarts <- computeRestarts(cond)
[17:47:07.011]                           for (restart in restarts) {
[17:47:07.011]                             name <- restart$name
[17:47:07.011]                             if (is.null(name)) 
[17:47:07.011]                               next
[17:47:07.011]                             if (!grepl(pattern, name)) 
[17:47:07.011]                               next
[17:47:07.011]                             invokeRestart(restart)
[17:47:07.011]                             muffled <- TRUE
[17:47:07.011]                             break
[17:47:07.011]                           }
[17:47:07.011]                         }
[17:47:07.011]                       }
[17:47:07.011]                       invisible(muffled)
[17:47:07.011]                     }
[17:47:07.011]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.011]                   }
[17:47:07.011]                 }
[17:47:07.011]             }
[17:47:07.011]         }))
[17:47:07.011]     }, error = function(ex) {
[17:47:07.011]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.011]                 ...future.rng), started = ...future.startTime, 
[17:47:07.011]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.011]             version = "1.8"), class = "FutureResult")
[17:47:07.011]     }, finally = {
[17:47:07.011]         if (!identical(...future.workdir, getwd())) 
[17:47:07.011]             setwd(...future.workdir)
[17:47:07.011]         {
[17:47:07.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.011]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.011]             }
[17:47:07.011]             base::options(...future.oldOptions)
[17:47:07.011]             if (.Platform$OS.type == "windows") {
[17:47:07.011]                 old_names <- names(...future.oldEnvVars)
[17:47:07.011]                 envs <- base::Sys.getenv()
[17:47:07.011]                 names <- names(envs)
[17:47:07.011]                 common <- intersect(names, old_names)
[17:47:07.011]                 added <- setdiff(names, old_names)
[17:47:07.011]                 removed <- setdiff(old_names, names)
[17:47:07.011]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.011]                   envs[common]]
[17:47:07.011]                 NAMES <- toupper(changed)
[17:47:07.011]                 args <- list()
[17:47:07.011]                 for (kk in seq_along(NAMES)) {
[17:47:07.011]                   name <- changed[[kk]]
[17:47:07.011]                   NAME <- NAMES[[kk]]
[17:47:07.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.011]                     next
[17:47:07.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.011]                 }
[17:47:07.011]                 NAMES <- toupper(added)
[17:47:07.011]                 for (kk in seq_along(NAMES)) {
[17:47:07.011]                   name <- added[[kk]]
[17:47:07.011]                   NAME <- NAMES[[kk]]
[17:47:07.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.011]                     next
[17:47:07.011]                   args[[name]] <- ""
[17:47:07.011]                 }
[17:47:07.011]                 NAMES <- toupper(removed)
[17:47:07.011]                 for (kk in seq_along(NAMES)) {
[17:47:07.011]                   name <- removed[[kk]]
[17:47:07.011]                   NAME <- NAMES[[kk]]
[17:47:07.011]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.011]                     next
[17:47:07.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.011]                 }
[17:47:07.011]                 if (length(args) > 0) 
[17:47:07.011]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.011]             }
[17:47:07.011]             else {
[17:47:07.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.011]             }
[17:47:07.011]             {
[17:47:07.011]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.011]                   0L) {
[17:47:07.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.011]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.011]                   base::options(opts)
[17:47:07.011]                 }
[17:47:07.011]                 {
[17:47:07.011]                   {
[17:47:07.011]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.011]                     NULL
[17:47:07.011]                   }
[17:47:07.011]                   options(future.plan = NULL)
[17:47:07.011]                   if (is.na(NA_character_)) 
[17:47:07.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.011]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.011]                     .init = FALSE)
[17:47:07.011]                 }
[17:47:07.011]             }
[17:47:07.011]         }
[17:47:07.011]     })
[17:47:07.011]     if (TRUE) {
[17:47:07.011]         base::sink(type = "output", split = FALSE)
[17:47:07.011]         if (TRUE) {
[17:47:07.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.011]         }
[17:47:07.011]         else {
[17:47:07.011]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.011]         }
[17:47:07.011]         base::close(...future.stdout)
[17:47:07.011]         ...future.stdout <- NULL
[17:47:07.011]     }
[17:47:07.011]     ...future.result$conditions <- ...future.conditions
[17:47:07.011]     ...future.result$finished <- base::Sys.time()
[17:47:07.011]     ...future.result
[17:47:07.011] }
[17:47:07.014] assign_globals() ...
[17:47:07.014] List of 1
[17:47:07.014]  $ ii: int 2
[17:47:07.014]  - attr(*, "where")=List of 1
[17:47:07.014]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:07.014]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.014]  - attr(*, "resolved")= logi TRUE
[17:47:07.014]  - attr(*, "total_size")= num 56
[17:47:07.014]  - attr(*, "already-done")= logi TRUE
[17:47:07.018] - copied ‘ii’ to environment
[17:47:07.018] assign_globals() ... done
[17:47:07.018] requestCore(): workers = 2
[17:47:07.020] MulticoreFuture started
[17:47:07.021] - Launch lazy future ... done
[17:47:07.021] run() for ‘MulticoreFuture’ ... done
[17:47:07.021] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.022] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.021] List of future strategies:
[17:47:07.021] 1. sequential:
[17:47:07.021]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.021]    - tweaked: FALSE
[17:47:07.021]    - call: NULL
[17:47:07.022] Searching for globals...
[17:47:07.022] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.025] plan(): Setting new future strategy stack:
[17:47:07.025] List of future strategies:
[17:47:07.025] 1. multicore:
[17:47:07.025]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.025]    - tweaked: FALSE
[17:47:07.025]    - call: plan(strategy)
[17:47:07.025] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:07.025] Searching for globals ... DONE
[17:47:07.025] Resolving globals: TRUE
[17:47:07.026] Resolving any globals that are futures ...
[17:47:07.026] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:07.030] plan(): nbrOfWorkers() = 2
[17:47:07.026] Resolving any globals that are futures ... DONE
[17:47:07.031] Resolving futures part of globals (recursively) ...
[17:47:07.032] resolve() on list ...
[17:47:07.032]  recursive: 99
[17:47:07.032]  length: 1
[17:47:07.033]  elements: ‘ii’
[17:47:07.033]  length: 0 (resolved future 1)
[17:47:07.033] resolve() on list ... DONE
[17:47:07.034] - globals: [1] ‘ii’
[17:47:07.034] Resolving futures part of globals (recursively) ... DONE
[17:47:07.034] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:07.035] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.035] - globals: [1] ‘ii’
[17:47:07.036] 
[17:47:07.036] getGlobalsAndPackages() ... DONE
[17:47:07.036] run() for ‘Future’ ...
[17:47:07.036] - state: ‘created’
[17:47:07.037] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.041] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.041]   - Field: ‘label’
[17:47:07.042]   - Field: ‘local’
[17:47:07.042]   - Field: ‘owner’
[17:47:07.042]   - Field: ‘envir’
[17:47:07.042]   - Field: ‘workers’
[17:47:07.042]   - Field: ‘packages’
[17:47:07.042]   - Field: ‘gc’
[17:47:07.042]   - Field: ‘job’
[17:47:07.043]   - Field: ‘conditions’
[17:47:07.043]   - Field: ‘expr’
[17:47:07.043]   - Field: ‘uuid’
[17:47:07.043]   - Field: ‘seed’
[17:47:07.043]   - Field: ‘version’
[17:47:07.043]   - Field: ‘result’
[17:47:07.044]   - Field: ‘asynchronous’
[17:47:07.044]   - Field: ‘calls’
[17:47:07.044]   - Field: ‘globals’
[17:47:07.044]   - Field: ‘stdout’
[17:47:07.044]   - Field: ‘earlySignal’
[17:47:07.044]   - Field: ‘lazy’
[17:47:07.044]   - Field: ‘state’
[17:47:07.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.045] - Launch lazy future ...
[17:47:07.045] Packages needed by the future expression (n = 0): <none>
[17:47:07.045] Packages needed by future strategies (n = 0): <none>
[17:47:07.046] {
[17:47:07.046]     {
[17:47:07.046]         {
[17:47:07.046]             ...future.startTime <- base::Sys.time()
[17:47:07.046]             {
[17:47:07.046]                 {
[17:47:07.046]                   {
[17:47:07.046]                     {
[17:47:07.046]                       base::local({
[17:47:07.046]                         has_future <- base::requireNamespace("future", 
[17:47:07.046]                           quietly = TRUE)
[17:47:07.046]                         if (has_future) {
[17:47:07.046]                           ns <- base::getNamespace("future")
[17:47:07.046]                           version <- ns[[".package"]][["version"]]
[17:47:07.046]                           if (is.null(version)) 
[17:47:07.046]                             version <- utils::packageVersion("future")
[17:47:07.046]                         }
[17:47:07.046]                         else {
[17:47:07.046]                           version <- NULL
[17:47:07.046]                         }
[17:47:07.046]                         if (!has_future || version < "1.8.0") {
[17:47:07.046]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.046]                             "", base::R.version$version.string), 
[17:47:07.046]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.046]                               "release", "version")], collapse = " "), 
[17:47:07.046]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.046]                             info)
[17:47:07.046]                           info <- base::paste(info, collapse = "; ")
[17:47:07.046]                           if (!has_future) {
[17:47:07.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.046]                               info)
[17:47:07.046]                           }
[17:47:07.046]                           else {
[17:47:07.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.046]                               info, version)
[17:47:07.046]                           }
[17:47:07.046]                           base::stop(msg)
[17:47:07.046]                         }
[17:47:07.046]                       })
[17:47:07.046]                     }
[17:47:07.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.046]                     base::options(mc.cores = 1L)
[17:47:07.046]                   }
[17:47:07.046]                   ...future.strategy.old <- future::plan("list")
[17:47:07.046]                   options(future.plan = NULL)
[17:47:07.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.046]                 }
[17:47:07.046]                 ...future.workdir <- getwd()
[17:47:07.046]             }
[17:47:07.046]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.046]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.046]         }
[17:47:07.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.046]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.046]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.046]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.046]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.046]             base::names(...future.oldOptions))
[17:47:07.046]     }
[17:47:07.046]     if (FALSE) {
[17:47:07.046]     }
[17:47:07.046]     else {
[17:47:07.046]         if (TRUE) {
[17:47:07.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.046]                 open = "w")
[17:47:07.046]         }
[17:47:07.046]         else {
[17:47:07.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.046]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.046]         }
[17:47:07.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.046]             base::sink(type = "output", split = FALSE)
[17:47:07.046]             base::close(...future.stdout)
[17:47:07.046]         }, add = TRUE)
[17:47:07.046]     }
[17:47:07.046]     ...future.frame <- base::sys.nframe()
[17:47:07.046]     ...future.conditions <- base::list()
[17:47:07.046]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.046]     if (FALSE) {
[17:47:07.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.046]     }
[17:47:07.046]     ...future.result <- base::tryCatch({
[17:47:07.046]         base::withCallingHandlers({
[17:47:07.046]             ...future.value <- base::withVisible(base::local({
[17:47:07.046]                 withCallingHandlers({
[17:47:07.046]                   {
[17:47:07.046]                     b <- a * ii
[17:47:07.046]                     a <- 0
[17:47:07.046]                     b
[17:47:07.046]                   }
[17:47:07.046]                 }, immediateCondition = function(cond) {
[17:47:07.046]                   save_rds <- function (object, pathname, ...) 
[17:47:07.046]                   {
[17:47:07.046]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.046]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.046]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.046]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.046]                         fi_tmp[["mtime"]])
[17:47:07.046]                     }
[17:47:07.046]                     tryCatch({
[17:47:07.046]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.046]                     }, error = function(ex) {
[17:47:07.046]                       msg <- conditionMessage(ex)
[17:47:07.046]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.046]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.046]                         fi_tmp[["mtime"]], msg)
[17:47:07.046]                       ex$message <- msg
[17:47:07.046]                       stop(ex)
[17:47:07.046]                     })
[17:47:07.046]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.046]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.046]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.046]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.046]                       fi <- file.info(pathname)
[17:47:07.046]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.046]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.046]                         fi[["size"]], fi[["mtime"]])
[17:47:07.046]                       stop(msg)
[17:47:07.046]                     }
[17:47:07.046]                     invisible(pathname)
[17:47:07.046]                   }
[17:47:07.046]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.046]                     rootPath = tempdir()) 
[17:47:07.046]                   {
[17:47:07.046]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.046]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.046]                       tmpdir = path, fileext = ".rds")
[17:47:07.046]                     save_rds(obj, file)
[17:47:07.046]                   }
[17:47:07.046]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.046]                   {
[17:47:07.046]                     inherits <- base::inherits
[17:47:07.046]                     invokeRestart <- base::invokeRestart
[17:47:07.046]                     is.null <- base::is.null
[17:47:07.046]                     muffled <- FALSE
[17:47:07.046]                     if (inherits(cond, "message")) {
[17:47:07.046]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.046]                       if (muffled) 
[17:47:07.046]                         invokeRestart("muffleMessage")
[17:47:07.046]                     }
[17:47:07.046]                     else if (inherits(cond, "warning")) {
[17:47:07.046]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.046]                       if (muffled) 
[17:47:07.046]                         invokeRestart("muffleWarning")
[17:47:07.046]                     }
[17:47:07.046]                     else if (inherits(cond, "condition")) {
[17:47:07.046]                       if (!is.null(pattern)) {
[17:47:07.046]                         computeRestarts <- base::computeRestarts
[17:47:07.046]                         grepl <- base::grepl
[17:47:07.046]                         restarts <- computeRestarts(cond)
[17:47:07.046]                         for (restart in restarts) {
[17:47:07.046]                           name <- restart$name
[17:47:07.046]                           if (is.null(name)) 
[17:47:07.046]                             next
[17:47:07.046]                           if (!grepl(pattern, name)) 
[17:47:07.046]                             next
[17:47:07.046]                           invokeRestart(restart)
[17:47:07.046]                           muffled <- TRUE
[17:47:07.046]                           break
[17:47:07.046]                         }
[17:47:07.046]                       }
[17:47:07.046]                     }
[17:47:07.046]                     invisible(muffled)
[17:47:07.046]                   }
[17:47:07.046]                   muffleCondition(cond)
[17:47:07.046]                 })
[17:47:07.046]             }))
[17:47:07.046]             future::FutureResult(value = ...future.value$value, 
[17:47:07.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.046]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.046]                     ...future.globalenv.names))
[17:47:07.046]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.046]         }, condition = base::local({
[17:47:07.046]             c <- base::c
[17:47:07.046]             inherits <- base::inherits
[17:47:07.046]             invokeRestart <- base::invokeRestart
[17:47:07.046]             length <- base::length
[17:47:07.046]             list <- base::list
[17:47:07.046]             seq.int <- base::seq.int
[17:47:07.046]             signalCondition <- base::signalCondition
[17:47:07.046]             sys.calls <- base::sys.calls
[17:47:07.046]             `[[` <- base::`[[`
[17:47:07.046]             `+` <- base::`+`
[17:47:07.046]             `<<-` <- base::`<<-`
[17:47:07.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.046]                   3L)]
[17:47:07.046]             }
[17:47:07.046]             function(cond) {
[17:47:07.046]                 is_error <- inherits(cond, "error")
[17:47:07.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.046]                   NULL)
[17:47:07.046]                 if (is_error) {
[17:47:07.046]                   sessionInformation <- function() {
[17:47:07.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.046]                       search = base::search(), system = base::Sys.info())
[17:47:07.046]                   }
[17:47:07.046]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.046]                     cond$call), session = sessionInformation(), 
[17:47:07.046]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.046]                   signalCondition(cond)
[17:47:07.046]                 }
[17:47:07.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.046]                 "immediateCondition"))) {
[17:47:07.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.046]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.046]                   if (TRUE && !signal) {
[17:47:07.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.046]                     {
[17:47:07.046]                       inherits <- base::inherits
[17:47:07.046]                       invokeRestart <- base::invokeRestart
[17:47:07.046]                       is.null <- base::is.null
[17:47:07.046]                       muffled <- FALSE
[17:47:07.046]                       if (inherits(cond, "message")) {
[17:47:07.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.046]                         if (muffled) 
[17:47:07.046]                           invokeRestart("muffleMessage")
[17:47:07.046]                       }
[17:47:07.046]                       else if (inherits(cond, "warning")) {
[17:47:07.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.046]                         if (muffled) 
[17:47:07.046]                           invokeRestart("muffleWarning")
[17:47:07.046]                       }
[17:47:07.046]                       else if (inherits(cond, "condition")) {
[17:47:07.046]                         if (!is.null(pattern)) {
[17:47:07.046]                           computeRestarts <- base::computeRestarts
[17:47:07.046]                           grepl <- base::grepl
[17:47:07.046]                           restarts <- computeRestarts(cond)
[17:47:07.046]                           for (restart in restarts) {
[17:47:07.046]                             name <- restart$name
[17:47:07.046]                             if (is.null(name)) 
[17:47:07.046]                               next
[17:47:07.046]                             if (!grepl(pattern, name)) 
[17:47:07.046]                               next
[17:47:07.046]                             invokeRestart(restart)
[17:47:07.046]                             muffled <- TRUE
[17:47:07.046]                             break
[17:47:07.046]                           }
[17:47:07.046]                         }
[17:47:07.046]                       }
[17:47:07.046]                       invisible(muffled)
[17:47:07.046]                     }
[17:47:07.046]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.046]                   }
[17:47:07.046]                 }
[17:47:07.046]                 else {
[17:47:07.046]                   if (TRUE) {
[17:47:07.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.046]                     {
[17:47:07.046]                       inherits <- base::inherits
[17:47:07.046]                       invokeRestart <- base::invokeRestart
[17:47:07.046]                       is.null <- base::is.null
[17:47:07.046]                       muffled <- FALSE
[17:47:07.046]                       if (inherits(cond, "message")) {
[17:47:07.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.046]                         if (muffled) 
[17:47:07.046]                           invokeRestart("muffleMessage")
[17:47:07.046]                       }
[17:47:07.046]                       else if (inherits(cond, "warning")) {
[17:47:07.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.046]                         if (muffled) 
[17:47:07.046]                           invokeRestart("muffleWarning")
[17:47:07.046]                       }
[17:47:07.046]                       else if (inherits(cond, "condition")) {
[17:47:07.046]                         if (!is.null(pattern)) {
[17:47:07.046]                           computeRestarts <- base::computeRestarts
[17:47:07.046]                           grepl <- base::grepl
[17:47:07.046]                           restarts <- computeRestarts(cond)
[17:47:07.046]                           for (restart in restarts) {
[17:47:07.046]                             name <- restart$name
[17:47:07.046]                             if (is.null(name)) 
[17:47:07.046]                               next
[17:47:07.046]                             if (!grepl(pattern, name)) 
[17:47:07.046]                               next
[17:47:07.046]                             invokeRestart(restart)
[17:47:07.046]                             muffled <- TRUE
[17:47:07.046]                             break
[17:47:07.046]                           }
[17:47:07.046]                         }
[17:47:07.046]                       }
[17:47:07.046]                       invisible(muffled)
[17:47:07.046]                     }
[17:47:07.046]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.046]                   }
[17:47:07.046]                 }
[17:47:07.046]             }
[17:47:07.046]         }))
[17:47:07.046]     }, error = function(ex) {
[17:47:07.046]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.046]                 ...future.rng), started = ...future.startTime, 
[17:47:07.046]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.046]             version = "1.8"), class = "FutureResult")
[17:47:07.046]     }, finally = {
[17:47:07.046]         if (!identical(...future.workdir, getwd())) 
[17:47:07.046]             setwd(...future.workdir)
[17:47:07.046]         {
[17:47:07.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.046]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.046]             }
[17:47:07.046]             base::options(...future.oldOptions)
[17:47:07.046]             if (.Platform$OS.type == "windows") {
[17:47:07.046]                 old_names <- names(...future.oldEnvVars)
[17:47:07.046]                 envs <- base::Sys.getenv()
[17:47:07.046]                 names <- names(envs)
[17:47:07.046]                 common <- intersect(names, old_names)
[17:47:07.046]                 added <- setdiff(names, old_names)
[17:47:07.046]                 removed <- setdiff(old_names, names)
[17:47:07.046]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.046]                   envs[common]]
[17:47:07.046]                 NAMES <- toupper(changed)
[17:47:07.046]                 args <- list()
[17:47:07.046]                 for (kk in seq_along(NAMES)) {
[17:47:07.046]                   name <- changed[[kk]]
[17:47:07.046]                   NAME <- NAMES[[kk]]
[17:47:07.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.046]                     next
[17:47:07.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.046]                 }
[17:47:07.046]                 NAMES <- toupper(added)
[17:47:07.046]                 for (kk in seq_along(NAMES)) {
[17:47:07.046]                   name <- added[[kk]]
[17:47:07.046]                   NAME <- NAMES[[kk]]
[17:47:07.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.046]                     next
[17:47:07.046]                   args[[name]] <- ""
[17:47:07.046]                 }
[17:47:07.046]                 NAMES <- toupper(removed)
[17:47:07.046]                 for (kk in seq_along(NAMES)) {
[17:47:07.046]                   name <- removed[[kk]]
[17:47:07.046]                   NAME <- NAMES[[kk]]
[17:47:07.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.046]                     next
[17:47:07.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.046]                 }
[17:47:07.046]                 if (length(args) > 0) 
[17:47:07.046]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.046]             }
[17:47:07.046]             else {
[17:47:07.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.046]             }
[17:47:07.046]             {
[17:47:07.046]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.046]                   0L) {
[17:47:07.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.046]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.046]                   base::options(opts)
[17:47:07.046]                 }
[17:47:07.046]                 {
[17:47:07.046]                   {
[17:47:07.046]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.046]                     NULL
[17:47:07.046]                   }
[17:47:07.046]                   options(future.plan = NULL)
[17:47:07.046]                   if (is.na(NA_character_)) 
[17:47:07.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.046]                     .init = FALSE)
[17:47:07.046]                 }
[17:47:07.046]             }
[17:47:07.046]         }
[17:47:07.046]     })
[17:47:07.046]     if (TRUE) {
[17:47:07.046]         base::sink(type = "output", split = FALSE)
[17:47:07.046]         if (TRUE) {
[17:47:07.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.046]         }
[17:47:07.046]         else {
[17:47:07.046]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.046]         }
[17:47:07.046]         base::close(...future.stdout)
[17:47:07.046]         ...future.stdout <- NULL
[17:47:07.046]     }
[17:47:07.046]     ...future.result$conditions <- ...future.conditions
[17:47:07.046]     ...future.result$finished <- base::Sys.time()
[17:47:07.046]     ...future.result
[17:47:07.046] }
[17:47:07.048] assign_globals() ...
[17:47:07.048] List of 1
[17:47:07.048]  $ ii: int 3
[17:47:07.048]  - attr(*, "where")=List of 1
[17:47:07.048]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:07.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.048]  - attr(*, "resolved")= logi TRUE
[17:47:07.048]  - attr(*, "total_size")= num 56
[17:47:07.048]  - attr(*, "already-done")= logi TRUE
[17:47:07.052] - copied ‘ii’ to environment
[17:47:07.052] assign_globals() ... done
[17:47:07.052] requestCore(): workers = 2
[17:47:07.052] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:07.064] result() for MulticoreFuture ...
[17:47:07.064] result() for MulticoreFuture ...
[17:47:07.064] result() for MulticoreFuture ... done
[17:47:07.065] result() for MulticoreFuture ... done
[17:47:07.065] result() for MulticoreFuture ...
[17:47:07.065] result() for MulticoreFuture ... done
[17:47:07.068] MulticoreFuture started
[17:47:07.068] - Launch lazy future ... done
[17:47:07.068] run() for ‘MulticoreFuture’ ... done
[17:47:07.069] plan(): Setting new future strategy stack:
[17:47:07.069] result() for MulticoreFuture ...
[17:47:07.070] result() for MulticoreFuture ... done
[17:47:07.070] result() for MulticoreFuture ...
[17:47:07.070] result() for MulticoreFuture ... done
[17:47:07.069] List of future strategies:
[17:47:07.069] 1. sequential:
[17:47:07.069]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.069]    - tweaked: FALSE
[17:47:07.069]    - call: NULL
[17:47:07.071] result() for MulticoreFuture ...
[17:47:07.071] plan(): nbrOfWorkers() = 1
[17:47:07.072] result() for MulticoreFuture ...
[17:47:07.072] result() for MulticoreFuture ... done
[17:47:07.073] result() for MulticoreFuture ... done
[17:47:07.073] result() for MulticoreFuture ...
[17:47:07.073] result() for MulticoreFuture ... done
[17:47:07.073] result() for MulticoreFuture ...
[17:47:07.074] plan(): Setting new future strategy stack:
[17:47:07.074] List of future strategies:
[17:47:07.074] 1. multicore:
[17:47:07.074]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.074]    - tweaked: FALSE
[17:47:07.074]    - call: plan(strategy)
[17:47:07.079] plan(): nbrOfWorkers() = 2
[17:47:07.080] result() for MulticoreFuture ...
[17:47:07.080] result() for MulticoreFuture ... done
[17:47:07.080] result() for MulticoreFuture ... done
[17:47:07.080] result() for MulticoreFuture ...
[17:47:07.080] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.081] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.082] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.084] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:07.084] Searching for globals ... DONE
[17:47:07.084] Resolving globals: TRUE
[17:47:07.084] Resolving any globals that are futures ...
[17:47:07.084] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:07.084] Resolving any globals that are futures ... DONE
[17:47:07.085] Resolving futures part of globals (recursively) ...
[17:47:07.085] resolve() on list ...
[17:47:07.085]  recursive: 99
[17:47:07.085]  length: 1
[17:47:07.085]  elements: ‘ii’
[17:47:07.086]  length: 0 (resolved future 1)
[17:47:07.086] resolve() on list ... DONE
[17:47:07.086] - globals: [1] ‘ii’
[17:47:07.086] Resolving futures part of globals (recursively) ... DONE
[17:47:07.086] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:07.087] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.087] - globals: [1] ‘ii’
[17:47:07.087] 
[17:47:07.087] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.088] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.088] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.089] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:07.090] Searching for globals ... DONE
[17:47:07.090] Resolving globals: TRUE
[17:47:07.090] Resolving any globals that are futures ...
[17:47:07.090] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:07.090] Resolving any globals that are futures ... DONE
[17:47:07.093] Resolving futures part of globals (recursively) ...
[17:47:07.093] resolve() on list ...
[17:47:07.094]  recursive: 99
[17:47:07.094]  length: 1
[17:47:07.094]  elements: ‘ii’
[17:47:07.094]  length: 0 (resolved future 1)
[17:47:07.094] resolve() on list ... DONE
[17:47:07.094] - globals: [1] ‘ii’
[17:47:07.095] Resolving futures part of globals (recursively) ... DONE
[17:47:07.095] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:07.095] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.095] - globals: [1] ‘ii’
[17:47:07.096] 
[17:47:07.096] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.096] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.097] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.098] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:07.098] Searching for globals ... DONE
[17:47:07.099] Resolving globals: TRUE
[17:47:07.099] Resolving any globals that are futures ...
[17:47:07.099] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:07.099] Resolving any globals that are futures ... DONE
[17:47:07.099] Resolving futures part of globals (recursively) ...
[17:47:07.099] resolve() on list ...
[17:47:07.100]  recursive: 99
[17:47:07.100]  length: 1
[17:47:07.100]  elements: ‘ii’
[17:47:07.100]  length: 0 (resolved future 1)
[17:47:07.100] resolve() on list ... DONE
[17:47:07.100] - globals: [1] ‘ii’
[17:47:07.100] Resolving futures part of globals (recursively) ... DONE
[17:47:07.100] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:07.101] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.101] - globals: [1] ‘ii’
[17:47:07.101] 
[17:47:07.101] getGlobalsAndPackages() ... DONE
[17:47:07.101] run() for ‘Future’ ...
[17:47:07.102] - state: ‘created’
[17:47:07.102] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.106] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.106] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.106]   - Field: ‘label’
[17:47:07.106]   - Field: ‘local’
[17:47:07.106]   - Field: ‘owner’
[17:47:07.106]   - Field: ‘envir’
[17:47:07.106]   - Field: ‘workers’
[17:47:07.106]   - Field: ‘packages’
[17:47:07.107]   - Field: ‘gc’
[17:47:07.107]   - Field: ‘job’
[17:47:07.107]   - Field: ‘conditions’
[17:47:07.107]   - Field: ‘expr’
[17:47:07.107]   - Field: ‘uuid’
[17:47:07.107]   - Field: ‘seed’
[17:47:07.107]   - Field: ‘version’
[17:47:07.107]   - Field: ‘result’
[17:47:07.107]   - Field: ‘asynchronous’
[17:47:07.108]   - Field: ‘calls’
[17:47:07.108]   - Field: ‘globals’
[17:47:07.108]   - Field: ‘stdout’
[17:47:07.108]   - Field: ‘earlySignal’
[17:47:07.108]   - Field: ‘lazy’
[17:47:07.108]   - Field: ‘state’
[17:47:07.108] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.108] - Launch lazy future ...
[17:47:07.109] Packages needed by the future expression (n = 0): <none>
[17:47:07.109] Packages needed by future strategies (n = 0): <none>
[17:47:07.109] {
[17:47:07.109]     {
[17:47:07.109]         {
[17:47:07.109]             ...future.startTime <- base::Sys.time()
[17:47:07.109]             {
[17:47:07.109]                 {
[17:47:07.109]                   {
[17:47:07.109]                     {
[17:47:07.109]                       base::local({
[17:47:07.109]                         has_future <- base::requireNamespace("future", 
[17:47:07.109]                           quietly = TRUE)
[17:47:07.109]                         if (has_future) {
[17:47:07.109]                           ns <- base::getNamespace("future")
[17:47:07.109]                           version <- ns[[".package"]][["version"]]
[17:47:07.109]                           if (is.null(version)) 
[17:47:07.109]                             version <- utils::packageVersion("future")
[17:47:07.109]                         }
[17:47:07.109]                         else {
[17:47:07.109]                           version <- NULL
[17:47:07.109]                         }
[17:47:07.109]                         if (!has_future || version < "1.8.0") {
[17:47:07.109]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.109]                             "", base::R.version$version.string), 
[17:47:07.109]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.109]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.109]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.109]                               "release", "version")], collapse = " "), 
[17:47:07.109]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.109]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.109]                             info)
[17:47:07.109]                           info <- base::paste(info, collapse = "; ")
[17:47:07.109]                           if (!has_future) {
[17:47:07.109]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.109]                               info)
[17:47:07.109]                           }
[17:47:07.109]                           else {
[17:47:07.109]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.109]                               info, version)
[17:47:07.109]                           }
[17:47:07.109]                           base::stop(msg)
[17:47:07.109]                         }
[17:47:07.109]                       })
[17:47:07.109]                     }
[17:47:07.109]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.109]                     base::options(mc.cores = 1L)
[17:47:07.109]                   }
[17:47:07.109]                   ...future.strategy.old <- future::plan("list")
[17:47:07.109]                   options(future.plan = NULL)
[17:47:07.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.109]                 }
[17:47:07.109]                 ...future.workdir <- getwd()
[17:47:07.109]             }
[17:47:07.109]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.109]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.109]         }
[17:47:07.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.109]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.109]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.109]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.109]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.109]             base::names(...future.oldOptions))
[17:47:07.109]     }
[17:47:07.109]     if (FALSE) {
[17:47:07.109]     }
[17:47:07.109]     else {
[17:47:07.109]         if (TRUE) {
[17:47:07.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.109]                 open = "w")
[17:47:07.109]         }
[17:47:07.109]         else {
[17:47:07.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.109]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.109]         }
[17:47:07.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.109]             base::sink(type = "output", split = FALSE)
[17:47:07.109]             base::close(...future.stdout)
[17:47:07.109]         }, add = TRUE)
[17:47:07.109]     }
[17:47:07.109]     ...future.frame <- base::sys.nframe()
[17:47:07.109]     ...future.conditions <- base::list()
[17:47:07.109]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.109]     if (FALSE) {
[17:47:07.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.109]     }
[17:47:07.109]     ...future.result <- base::tryCatch({
[17:47:07.109]         base::withCallingHandlers({
[17:47:07.109]             ...future.value <- base::withVisible(base::local({
[17:47:07.109]                 withCallingHandlers({
[17:47:07.109]                   {
[17:47:07.109]                     b <- a * ii
[17:47:07.109]                     a <- 0
[17:47:07.109]                     b
[17:47:07.109]                   }
[17:47:07.109]                 }, immediateCondition = function(cond) {
[17:47:07.109]                   save_rds <- function (object, pathname, ...) 
[17:47:07.109]                   {
[17:47:07.109]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.109]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.109]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.109]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.109]                         fi_tmp[["mtime"]])
[17:47:07.109]                     }
[17:47:07.109]                     tryCatch({
[17:47:07.109]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.109]                     }, error = function(ex) {
[17:47:07.109]                       msg <- conditionMessage(ex)
[17:47:07.109]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.109]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.109]                         fi_tmp[["mtime"]], msg)
[17:47:07.109]                       ex$message <- msg
[17:47:07.109]                       stop(ex)
[17:47:07.109]                     })
[17:47:07.109]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.109]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.109]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.109]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.109]                       fi <- file.info(pathname)
[17:47:07.109]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.109]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.109]                         fi[["size"]], fi[["mtime"]])
[17:47:07.109]                       stop(msg)
[17:47:07.109]                     }
[17:47:07.109]                     invisible(pathname)
[17:47:07.109]                   }
[17:47:07.109]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.109]                     rootPath = tempdir()) 
[17:47:07.109]                   {
[17:47:07.109]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.109]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.109]                       tmpdir = path, fileext = ".rds")
[17:47:07.109]                     save_rds(obj, file)
[17:47:07.109]                   }
[17:47:07.109]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.109]                   {
[17:47:07.109]                     inherits <- base::inherits
[17:47:07.109]                     invokeRestart <- base::invokeRestart
[17:47:07.109]                     is.null <- base::is.null
[17:47:07.109]                     muffled <- FALSE
[17:47:07.109]                     if (inherits(cond, "message")) {
[17:47:07.109]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.109]                       if (muffled) 
[17:47:07.109]                         invokeRestart("muffleMessage")
[17:47:07.109]                     }
[17:47:07.109]                     else if (inherits(cond, "warning")) {
[17:47:07.109]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.109]                       if (muffled) 
[17:47:07.109]                         invokeRestart("muffleWarning")
[17:47:07.109]                     }
[17:47:07.109]                     else if (inherits(cond, "condition")) {
[17:47:07.109]                       if (!is.null(pattern)) {
[17:47:07.109]                         computeRestarts <- base::computeRestarts
[17:47:07.109]                         grepl <- base::grepl
[17:47:07.109]                         restarts <- computeRestarts(cond)
[17:47:07.109]                         for (restart in restarts) {
[17:47:07.109]                           name <- restart$name
[17:47:07.109]                           if (is.null(name)) 
[17:47:07.109]                             next
[17:47:07.109]                           if (!grepl(pattern, name)) 
[17:47:07.109]                             next
[17:47:07.109]                           invokeRestart(restart)
[17:47:07.109]                           muffled <- TRUE
[17:47:07.109]                           break
[17:47:07.109]                         }
[17:47:07.109]                       }
[17:47:07.109]                     }
[17:47:07.109]                     invisible(muffled)
[17:47:07.109]                   }
[17:47:07.109]                   muffleCondition(cond)
[17:47:07.109]                 })
[17:47:07.109]             }))
[17:47:07.109]             future::FutureResult(value = ...future.value$value, 
[17:47:07.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.109]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.109]                     ...future.globalenv.names))
[17:47:07.109]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.109]         }, condition = base::local({
[17:47:07.109]             c <- base::c
[17:47:07.109]             inherits <- base::inherits
[17:47:07.109]             invokeRestart <- base::invokeRestart
[17:47:07.109]             length <- base::length
[17:47:07.109]             list <- base::list
[17:47:07.109]             seq.int <- base::seq.int
[17:47:07.109]             signalCondition <- base::signalCondition
[17:47:07.109]             sys.calls <- base::sys.calls
[17:47:07.109]             `[[` <- base::`[[`
[17:47:07.109]             `+` <- base::`+`
[17:47:07.109]             `<<-` <- base::`<<-`
[17:47:07.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.109]                   3L)]
[17:47:07.109]             }
[17:47:07.109]             function(cond) {
[17:47:07.109]                 is_error <- inherits(cond, "error")
[17:47:07.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.109]                   NULL)
[17:47:07.109]                 if (is_error) {
[17:47:07.109]                   sessionInformation <- function() {
[17:47:07.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.109]                       search = base::search(), system = base::Sys.info())
[17:47:07.109]                   }
[17:47:07.109]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.109]                     cond$call), session = sessionInformation(), 
[17:47:07.109]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.109]                   signalCondition(cond)
[17:47:07.109]                 }
[17:47:07.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.109]                 "immediateCondition"))) {
[17:47:07.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.109]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.109]                   if (TRUE && !signal) {
[17:47:07.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.109]                     {
[17:47:07.109]                       inherits <- base::inherits
[17:47:07.109]                       invokeRestart <- base::invokeRestart
[17:47:07.109]                       is.null <- base::is.null
[17:47:07.109]                       muffled <- FALSE
[17:47:07.109]                       if (inherits(cond, "message")) {
[17:47:07.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.109]                         if (muffled) 
[17:47:07.109]                           invokeRestart("muffleMessage")
[17:47:07.109]                       }
[17:47:07.109]                       else if (inherits(cond, "warning")) {
[17:47:07.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.109]                         if (muffled) 
[17:47:07.109]                           invokeRestart("muffleWarning")
[17:47:07.109]                       }
[17:47:07.109]                       else if (inherits(cond, "condition")) {
[17:47:07.109]                         if (!is.null(pattern)) {
[17:47:07.109]                           computeRestarts <- base::computeRestarts
[17:47:07.109]                           grepl <- base::grepl
[17:47:07.109]                           restarts <- computeRestarts(cond)
[17:47:07.109]                           for (restart in restarts) {
[17:47:07.109]                             name <- restart$name
[17:47:07.109]                             if (is.null(name)) 
[17:47:07.109]                               next
[17:47:07.109]                             if (!grepl(pattern, name)) 
[17:47:07.109]                               next
[17:47:07.109]                             invokeRestart(restart)
[17:47:07.109]                             muffled <- TRUE
[17:47:07.109]                             break
[17:47:07.109]                           }
[17:47:07.109]                         }
[17:47:07.109]                       }
[17:47:07.109]                       invisible(muffled)
[17:47:07.109]                     }
[17:47:07.109]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.109]                   }
[17:47:07.109]                 }
[17:47:07.109]                 else {
[17:47:07.109]                   if (TRUE) {
[17:47:07.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.109]                     {
[17:47:07.109]                       inherits <- base::inherits
[17:47:07.109]                       invokeRestart <- base::invokeRestart
[17:47:07.109]                       is.null <- base::is.null
[17:47:07.109]                       muffled <- FALSE
[17:47:07.109]                       if (inherits(cond, "message")) {
[17:47:07.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.109]                         if (muffled) 
[17:47:07.109]                           invokeRestart("muffleMessage")
[17:47:07.109]                       }
[17:47:07.109]                       else if (inherits(cond, "warning")) {
[17:47:07.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.109]                         if (muffled) 
[17:47:07.109]                           invokeRestart("muffleWarning")
[17:47:07.109]                       }
[17:47:07.109]                       else if (inherits(cond, "condition")) {
[17:47:07.109]                         if (!is.null(pattern)) {
[17:47:07.109]                           computeRestarts <- base::computeRestarts
[17:47:07.109]                           grepl <- base::grepl
[17:47:07.109]                           restarts <- computeRestarts(cond)
[17:47:07.109]                           for (restart in restarts) {
[17:47:07.109]                             name <- restart$name
[17:47:07.109]                             if (is.null(name)) 
[17:47:07.109]                               next
[17:47:07.109]                             if (!grepl(pattern, name)) 
[17:47:07.109]                               next
[17:47:07.109]                             invokeRestart(restart)
[17:47:07.109]                             muffled <- TRUE
[17:47:07.109]                             break
[17:47:07.109]                           }
[17:47:07.109]                         }
[17:47:07.109]                       }
[17:47:07.109]                       invisible(muffled)
[17:47:07.109]                     }
[17:47:07.109]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.109]                   }
[17:47:07.109]                 }
[17:47:07.109]             }
[17:47:07.109]         }))
[17:47:07.109]     }, error = function(ex) {
[17:47:07.109]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.109]                 ...future.rng), started = ...future.startTime, 
[17:47:07.109]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.109]             version = "1.8"), class = "FutureResult")
[17:47:07.109]     }, finally = {
[17:47:07.109]         if (!identical(...future.workdir, getwd())) 
[17:47:07.109]             setwd(...future.workdir)
[17:47:07.109]         {
[17:47:07.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.109]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.109]             }
[17:47:07.109]             base::options(...future.oldOptions)
[17:47:07.109]             if (.Platform$OS.type == "windows") {
[17:47:07.109]                 old_names <- names(...future.oldEnvVars)
[17:47:07.109]                 envs <- base::Sys.getenv()
[17:47:07.109]                 names <- names(envs)
[17:47:07.109]                 common <- intersect(names, old_names)
[17:47:07.109]                 added <- setdiff(names, old_names)
[17:47:07.109]                 removed <- setdiff(old_names, names)
[17:47:07.109]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.109]                   envs[common]]
[17:47:07.109]                 NAMES <- toupper(changed)
[17:47:07.109]                 args <- list()
[17:47:07.109]                 for (kk in seq_along(NAMES)) {
[17:47:07.109]                   name <- changed[[kk]]
[17:47:07.109]                   NAME <- NAMES[[kk]]
[17:47:07.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.109]                     next
[17:47:07.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.109]                 }
[17:47:07.109]                 NAMES <- toupper(added)
[17:47:07.109]                 for (kk in seq_along(NAMES)) {
[17:47:07.109]                   name <- added[[kk]]
[17:47:07.109]                   NAME <- NAMES[[kk]]
[17:47:07.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.109]                     next
[17:47:07.109]                   args[[name]] <- ""
[17:47:07.109]                 }
[17:47:07.109]                 NAMES <- toupper(removed)
[17:47:07.109]                 for (kk in seq_along(NAMES)) {
[17:47:07.109]                   name <- removed[[kk]]
[17:47:07.109]                   NAME <- NAMES[[kk]]
[17:47:07.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.109]                     next
[17:47:07.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.109]                 }
[17:47:07.109]                 if (length(args) > 0) 
[17:47:07.109]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.109]             }
[17:47:07.109]             else {
[17:47:07.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.109]             }
[17:47:07.109]             {
[17:47:07.109]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.109]                   0L) {
[17:47:07.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.109]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.109]                   base::options(opts)
[17:47:07.109]                 }
[17:47:07.109]                 {
[17:47:07.109]                   {
[17:47:07.109]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.109]                     NULL
[17:47:07.109]                   }
[17:47:07.109]                   options(future.plan = NULL)
[17:47:07.109]                   if (is.na(NA_character_)) 
[17:47:07.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.109]                     .init = FALSE)
[17:47:07.109]                 }
[17:47:07.109]             }
[17:47:07.109]         }
[17:47:07.109]     })
[17:47:07.109]     if (TRUE) {
[17:47:07.109]         base::sink(type = "output", split = FALSE)
[17:47:07.109]         if (TRUE) {
[17:47:07.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.109]         }
[17:47:07.109]         else {
[17:47:07.109]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.109]         }
[17:47:07.109]         base::close(...future.stdout)
[17:47:07.109]         ...future.stdout <- NULL
[17:47:07.109]     }
[17:47:07.109]     ...future.result$conditions <- ...future.conditions
[17:47:07.109]     ...future.result$finished <- base::Sys.time()
[17:47:07.109]     ...future.result
[17:47:07.109] }
[17:47:07.112] assign_globals() ...
[17:47:07.112] List of 1
[17:47:07.112]  $ ii: int 1
[17:47:07.112]  - attr(*, "where")=List of 1
[17:47:07.112]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:07.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.112]  - attr(*, "resolved")= logi TRUE
[17:47:07.112]  - attr(*, "total_size")= num 56
[17:47:07.112]  - attr(*, "already-done")= logi TRUE
[17:47:07.114] - copied ‘ii’ to environment
[17:47:07.114] assign_globals() ... done
[17:47:07.114] requestCore(): workers = 2
[17:47:07.116] MulticoreFuture started
[17:47:07.117] - Launch lazy future ... done
[17:47:07.117] run() for ‘MulticoreFuture’ ... done
[17:47:07.117] result() for MulticoreFuture ...
[17:47:07.117] plan(): Setting new future strategy stack:
[17:47:07.118] List of future strategies:
[17:47:07.118] 1. sequential:
[17:47:07.118]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.118]    - tweaked: FALSE
[17:47:07.118]    - call: NULL
[17:47:07.119] plan(): nbrOfWorkers() = 1
[17:47:07.121] plan(): Setting new future strategy stack:
[17:47:07.121] List of future strategies:
[17:47:07.121] 1. multicore:
[17:47:07.121]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.121]    - tweaked: FALSE
[17:47:07.121]    - call: plan(strategy)
[17:47:07.126] plan(): nbrOfWorkers() = 2
[17:47:07.132] result() for MulticoreFuture ...
[17:47:07.132] result() for MulticoreFuture ... done
[17:47:07.132] signalConditions() ...
[17:47:07.132]  - include = ‘immediateCondition’
[17:47:07.132]  - exclude = 
[17:47:07.132]  - resignal = FALSE
[17:47:07.132]  - Number of conditions: 1
[17:47:07.132] signalConditions() ... done
[17:47:07.133] result() for MulticoreFuture ... done
[17:47:07.133] result() for MulticoreFuture ...
[17:47:07.133] result() for MulticoreFuture ... done
[17:47:07.133] signalConditions() ...
[17:47:07.133]  - include = ‘immediateCondition’
[17:47:07.133]  - exclude = 
[17:47:07.133]  - resignal = FALSE
[17:47:07.133]  - Number of conditions: 1
[17:47:07.133] signalConditions() ... done
[17:47:07.134] Future state: ‘finished’
[17:47:07.134] result() for MulticoreFuture ...
[17:47:07.134] result() for MulticoreFuture ... done
[17:47:07.134] signalConditions() ...
[17:47:07.134]  - include = ‘condition’
[17:47:07.134]  - exclude = ‘immediateCondition’
[17:47:07.134]  - resignal = TRUE
[17:47:07.134]  - Number of conditions: 1
[17:47:07.135]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:47:07.135] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-22 17:47:07"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.165] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.166] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.166] 
[17:47:07.166] Searching for globals ... DONE
[17:47:07.166] - globals: [0] <none>
[17:47:07.167] getGlobalsAndPackages() ... DONE
[17:47:07.167] run() for ‘Future’ ...
[17:47:07.167] - state: ‘created’
[17:47:07.167] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.171] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.171]   - Field: ‘label’
[17:47:07.171]   - Field: ‘local’
[17:47:07.171]   - Field: ‘owner’
[17:47:07.171]   - Field: ‘envir’
[17:47:07.171]   - Field: ‘workers’
[17:47:07.172]   - Field: ‘packages’
[17:47:07.172]   - Field: ‘gc’
[17:47:07.172]   - Field: ‘job’
[17:47:07.172]   - Field: ‘conditions’
[17:47:07.172]   - Field: ‘expr’
[17:47:07.172]   - Field: ‘uuid’
[17:47:07.172]   - Field: ‘seed’
[17:47:07.172]   - Field: ‘version’
[17:47:07.172]   - Field: ‘result’
[17:47:07.172]   - Field: ‘asynchronous’
[17:47:07.172]   - Field: ‘calls’
[17:47:07.173]   - Field: ‘globals’
[17:47:07.173]   - Field: ‘stdout’
[17:47:07.173]   - Field: ‘earlySignal’
[17:47:07.173]   - Field: ‘lazy’
[17:47:07.173]   - Field: ‘state’
[17:47:07.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.173] - Launch lazy future ...
[17:47:07.173] Packages needed by the future expression (n = 0): <none>
[17:47:07.173] Packages needed by future strategies (n = 0): <none>
[17:47:07.174] {
[17:47:07.174]     {
[17:47:07.174]         {
[17:47:07.174]             ...future.startTime <- base::Sys.time()
[17:47:07.174]             {
[17:47:07.174]                 {
[17:47:07.174]                   {
[17:47:07.174]                     {
[17:47:07.174]                       base::local({
[17:47:07.174]                         has_future <- base::requireNamespace("future", 
[17:47:07.174]                           quietly = TRUE)
[17:47:07.174]                         if (has_future) {
[17:47:07.174]                           ns <- base::getNamespace("future")
[17:47:07.174]                           version <- ns[[".package"]][["version"]]
[17:47:07.174]                           if (is.null(version)) 
[17:47:07.174]                             version <- utils::packageVersion("future")
[17:47:07.174]                         }
[17:47:07.174]                         else {
[17:47:07.174]                           version <- NULL
[17:47:07.174]                         }
[17:47:07.174]                         if (!has_future || version < "1.8.0") {
[17:47:07.174]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.174]                             "", base::R.version$version.string), 
[17:47:07.174]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.174]                               "release", "version")], collapse = " "), 
[17:47:07.174]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.174]                             info)
[17:47:07.174]                           info <- base::paste(info, collapse = "; ")
[17:47:07.174]                           if (!has_future) {
[17:47:07.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.174]                               info)
[17:47:07.174]                           }
[17:47:07.174]                           else {
[17:47:07.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.174]                               info, version)
[17:47:07.174]                           }
[17:47:07.174]                           base::stop(msg)
[17:47:07.174]                         }
[17:47:07.174]                       })
[17:47:07.174]                     }
[17:47:07.174]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.174]                     base::options(mc.cores = 1L)
[17:47:07.174]                   }
[17:47:07.174]                   ...future.strategy.old <- future::plan("list")
[17:47:07.174]                   options(future.plan = NULL)
[17:47:07.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.174]                 }
[17:47:07.174]                 ...future.workdir <- getwd()
[17:47:07.174]             }
[17:47:07.174]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.174]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.174]         }
[17:47:07.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.174]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.174]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.174]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.174]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.174]             base::names(...future.oldOptions))
[17:47:07.174]     }
[17:47:07.174]     if (FALSE) {
[17:47:07.174]     }
[17:47:07.174]     else {
[17:47:07.174]         if (TRUE) {
[17:47:07.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.174]                 open = "w")
[17:47:07.174]         }
[17:47:07.174]         else {
[17:47:07.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.174]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.174]         }
[17:47:07.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.174]             base::sink(type = "output", split = FALSE)
[17:47:07.174]             base::close(...future.stdout)
[17:47:07.174]         }, add = TRUE)
[17:47:07.174]     }
[17:47:07.174]     ...future.frame <- base::sys.nframe()
[17:47:07.174]     ...future.conditions <- base::list()
[17:47:07.174]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.174]     if (FALSE) {
[17:47:07.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.174]     }
[17:47:07.174]     ...future.result <- base::tryCatch({
[17:47:07.174]         base::withCallingHandlers({
[17:47:07.174]             ...future.value <- base::withVisible(base::local({
[17:47:07.174]                 withCallingHandlers({
[17:47:07.174]                   1
[17:47:07.174]                 }, immediateCondition = function(cond) {
[17:47:07.174]                   save_rds <- function (object, pathname, ...) 
[17:47:07.174]                   {
[17:47:07.174]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.174]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.174]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.174]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.174]                         fi_tmp[["mtime"]])
[17:47:07.174]                     }
[17:47:07.174]                     tryCatch({
[17:47:07.174]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.174]                     }, error = function(ex) {
[17:47:07.174]                       msg <- conditionMessage(ex)
[17:47:07.174]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.174]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.174]                         fi_tmp[["mtime"]], msg)
[17:47:07.174]                       ex$message <- msg
[17:47:07.174]                       stop(ex)
[17:47:07.174]                     })
[17:47:07.174]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.174]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.174]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.174]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.174]                       fi <- file.info(pathname)
[17:47:07.174]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.174]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.174]                         fi[["size"]], fi[["mtime"]])
[17:47:07.174]                       stop(msg)
[17:47:07.174]                     }
[17:47:07.174]                     invisible(pathname)
[17:47:07.174]                   }
[17:47:07.174]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.174]                     rootPath = tempdir()) 
[17:47:07.174]                   {
[17:47:07.174]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.174]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.174]                       tmpdir = path, fileext = ".rds")
[17:47:07.174]                     save_rds(obj, file)
[17:47:07.174]                   }
[17:47:07.174]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.174]                   {
[17:47:07.174]                     inherits <- base::inherits
[17:47:07.174]                     invokeRestart <- base::invokeRestart
[17:47:07.174]                     is.null <- base::is.null
[17:47:07.174]                     muffled <- FALSE
[17:47:07.174]                     if (inherits(cond, "message")) {
[17:47:07.174]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.174]                       if (muffled) 
[17:47:07.174]                         invokeRestart("muffleMessage")
[17:47:07.174]                     }
[17:47:07.174]                     else if (inherits(cond, "warning")) {
[17:47:07.174]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.174]                       if (muffled) 
[17:47:07.174]                         invokeRestart("muffleWarning")
[17:47:07.174]                     }
[17:47:07.174]                     else if (inherits(cond, "condition")) {
[17:47:07.174]                       if (!is.null(pattern)) {
[17:47:07.174]                         computeRestarts <- base::computeRestarts
[17:47:07.174]                         grepl <- base::grepl
[17:47:07.174]                         restarts <- computeRestarts(cond)
[17:47:07.174]                         for (restart in restarts) {
[17:47:07.174]                           name <- restart$name
[17:47:07.174]                           if (is.null(name)) 
[17:47:07.174]                             next
[17:47:07.174]                           if (!grepl(pattern, name)) 
[17:47:07.174]                             next
[17:47:07.174]                           invokeRestart(restart)
[17:47:07.174]                           muffled <- TRUE
[17:47:07.174]                           break
[17:47:07.174]                         }
[17:47:07.174]                       }
[17:47:07.174]                     }
[17:47:07.174]                     invisible(muffled)
[17:47:07.174]                   }
[17:47:07.174]                   muffleCondition(cond)
[17:47:07.174]                 })
[17:47:07.174]             }))
[17:47:07.174]             future::FutureResult(value = ...future.value$value, 
[17:47:07.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.174]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.174]                     ...future.globalenv.names))
[17:47:07.174]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.174]         }, condition = base::local({
[17:47:07.174]             c <- base::c
[17:47:07.174]             inherits <- base::inherits
[17:47:07.174]             invokeRestart <- base::invokeRestart
[17:47:07.174]             length <- base::length
[17:47:07.174]             list <- base::list
[17:47:07.174]             seq.int <- base::seq.int
[17:47:07.174]             signalCondition <- base::signalCondition
[17:47:07.174]             sys.calls <- base::sys.calls
[17:47:07.174]             `[[` <- base::`[[`
[17:47:07.174]             `+` <- base::`+`
[17:47:07.174]             `<<-` <- base::`<<-`
[17:47:07.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.174]                   3L)]
[17:47:07.174]             }
[17:47:07.174]             function(cond) {
[17:47:07.174]                 is_error <- inherits(cond, "error")
[17:47:07.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.174]                   NULL)
[17:47:07.174]                 if (is_error) {
[17:47:07.174]                   sessionInformation <- function() {
[17:47:07.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.174]                       search = base::search(), system = base::Sys.info())
[17:47:07.174]                   }
[17:47:07.174]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.174]                     cond$call), session = sessionInformation(), 
[17:47:07.174]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.174]                   signalCondition(cond)
[17:47:07.174]                 }
[17:47:07.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.174]                 "immediateCondition"))) {
[17:47:07.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.174]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.174]                   if (TRUE && !signal) {
[17:47:07.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.174]                     {
[17:47:07.174]                       inherits <- base::inherits
[17:47:07.174]                       invokeRestart <- base::invokeRestart
[17:47:07.174]                       is.null <- base::is.null
[17:47:07.174]                       muffled <- FALSE
[17:47:07.174]                       if (inherits(cond, "message")) {
[17:47:07.174]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.174]                         if (muffled) 
[17:47:07.174]                           invokeRestart("muffleMessage")
[17:47:07.174]                       }
[17:47:07.174]                       else if (inherits(cond, "warning")) {
[17:47:07.174]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.174]                         if (muffled) 
[17:47:07.174]                           invokeRestart("muffleWarning")
[17:47:07.174]                       }
[17:47:07.174]                       else if (inherits(cond, "condition")) {
[17:47:07.174]                         if (!is.null(pattern)) {
[17:47:07.174]                           computeRestarts <- base::computeRestarts
[17:47:07.174]                           grepl <- base::grepl
[17:47:07.174]                           restarts <- computeRestarts(cond)
[17:47:07.174]                           for (restart in restarts) {
[17:47:07.174]                             name <- restart$name
[17:47:07.174]                             if (is.null(name)) 
[17:47:07.174]                               next
[17:47:07.174]                             if (!grepl(pattern, name)) 
[17:47:07.174]                               next
[17:47:07.174]                             invokeRestart(restart)
[17:47:07.174]                             muffled <- TRUE
[17:47:07.174]                             break
[17:47:07.174]                           }
[17:47:07.174]                         }
[17:47:07.174]                       }
[17:47:07.174]                       invisible(muffled)
[17:47:07.174]                     }
[17:47:07.174]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.174]                   }
[17:47:07.174]                 }
[17:47:07.174]                 else {
[17:47:07.174]                   if (TRUE) {
[17:47:07.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.174]                     {
[17:47:07.174]                       inherits <- base::inherits
[17:47:07.174]                       invokeRestart <- base::invokeRestart
[17:47:07.174]                       is.null <- base::is.null
[17:47:07.174]                       muffled <- FALSE
[17:47:07.174]                       if (inherits(cond, "message")) {
[17:47:07.174]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.174]                         if (muffled) 
[17:47:07.174]                           invokeRestart("muffleMessage")
[17:47:07.174]                       }
[17:47:07.174]                       else if (inherits(cond, "warning")) {
[17:47:07.174]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.174]                         if (muffled) 
[17:47:07.174]                           invokeRestart("muffleWarning")
[17:47:07.174]                       }
[17:47:07.174]                       else if (inherits(cond, "condition")) {
[17:47:07.174]                         if (!is.null(pattern)) {
[17:47:07.174]                           computeRestarts <- base::computeRestarts
[17:47:07.174]                           grepl <- base::grepl
[17:47:07.174]                           restarts <- computeRestarts(cond)
[17:47:07.174]                           for (restart in restarts) {
[17:47:07.174]                             name <- restart$name
[17:47:07.174]                             if (is.null(name)) 
[17:47:07.174]                               next
[17:47:07.174]                             if (!grepl(pattern, name)) 
[17:47:07.174]                               next
[17:47:07.174]                             invokeRestart(restart)
[17:47:07.174]                             muffled <- TRUE
[17:47:07.174]                             break
[17:47:07.174]                           }
[17:47:07.174]                         }
[17:47:07.174]                       }
[17:47:07.174]                       invisible(muffled)
[17:47:07.174]                     }
[17:47:07.174]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.174]                   }
[17:47:07.174]                 }
[17:47:07.174]             }
[17:47:07.174]         }))
[17:47:07.174]     }, error = function(ex) {
[17:47:07.174]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.174]                 ...future.rng), started = ...future.startTime, 
[17:47:07.174]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.174]             version = "1.8"), class = "FutureResult")
[17:47:07.174]     }, finally = {
[17:47:07.174]         if (!identical(...future.workdir, getwd())) 
[17:47:07.174]             setwd(...future.workdir)
[17:47:07.174]         {
[17:47:07.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.174]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.174]             }
[17:47:07.174]             base::options(...future.oldOptions)
[17:47:07.174]             if (.Platform$OS.type == "windows") {
[17:47:07.174]                 old_names <- names(...future.oldEnvVars)
[17:47:07.174]                 envs <- base::Sys.getenv()
[17:47:07.174]                 names <- names(envs)
[17:47:07.174]                 common <- intersect(names, old_names)
[17:47:07.174]                 added <- setdiff(names, old_names)
[17:47:07.174]                 removed <- setdiff(old_names, names)
[17:47:07.174]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.174]                   envs[common]]
[17:47:07.174]                 NAMES <- toupper(changed)
[17:47:07.174]                 args <- list()
[17:47:07.174]                 for (kk in seq_along(NAMES)) {
[17:47:07.174]                   name <- changed[[kk]]
[17:47:07.174]                   NAME <- NAMES[[kk]]
[17:47:07.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.174]                     next
[17:47:07.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.174]                 }
[17:47:07.174]                 NAMES <- toupper(added)
[17:47:07.174]                 for (kk in seq_along(NAMES)) {
[17:47:07.174]                   name <- added[[kk]]
[17:47:07.174]                   NAME <- NAMES[[kk]]
[17:47:07.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.174]                     next
[17:47:07.174]                   args[[name]] <- ""
[17:47:07.174]                 }
[17:47:07.174]                 NAMES <- toupper(removed)
[17:47:07.174]                 for (kk in seq_along(NAMES)) {
[17:47:07.174]                   name <- removed[[kk]]
[17:47:07.174]                   NAME <- NAMES[[kk]]
[17:47:07.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.174]                     next
[17:47:07.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.174]                 }
[17:47:07.174]                 if (length(args) > 0) 
[17:47:07.174]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.174]             }
[17:47:07.174]             else {
[17:47:07.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.174]             }
[17:47:07.174]             {
[17:47:07.174]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.174]                   0L) {
[17:47:07.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.174]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.174]                   base::options(opts)
[17:47:07.174]                 }
[17:47:07.174]                 {
[17:47:07.174]                   {
[17:47:07.174]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.174]                     NULL
[17:47:07.174]                   }
[17:47:07.174]                   options(future.plan = NULL)
[17:47:07.174]                   if (is.na(NA_character_)) 
[17:47:07.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.174]                     .init = FALSE)
[17:47:07.174]                 }
[17:47:07.174]             }
[17:47:07.174]         }
[17:47:07.174]     })
[17:47:07.174]     if (TRUE) {
[17:47:07.174]         base::sink(type = "output", split = FALSE)
[17:47:07.174]         if (TRUE) {
[17:47:07.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.174]         }
[17:47:07.174]         else {
[17:47:07.174]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.174]         }
[17:47:07.174]         base::close(...future.stdout)
[17:47:07.174]         ...future.stdout <- NULL
[17:47:07.174]     }
[17:47:07.174]     ...future.result$conditions <- ...future.conditions
[17:47:07.174]     ...future.result$finished <- base::Sys.time()
[17:47:07.174]     ...future.result
[17:47:07.174] }
[17:47:07.176] requestCore(): workers = 2
[17:47:07.178] MulticoreFuture started
[17:47:07.178] - Launch lazy future ... done
[17:47:07.179] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.179] plan(): Setting new future strategy stack:
[17:47:07.179] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.180] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.179] List of future strategies:
[17:47:07.179] 1. sequential:
[17:47:07.179]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.179]    - tweaked: FALSE
[17:47:07.179]    - call: NULL
[17:47:07.180] plan(): nbrOfWorkers() = 1
[17:47:07.182] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:07.182] Searching for globals ... DONE
[17:47:07.182] Resolving globals: TRUE
[17:47:07.182] Resolving any globals that are futures ...
[17:47:07.182] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:07.182] plan(): Setting new future strategy stack:
[17:47:07.182] Resolving any globals that are futures ... DONE
[17:47:07.182] List of future strategies:
[17:47:07.182] 1. multicore:
[17:47:07.182]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.182]    - tweaked: FALSE
[17:47:07.182]    - call: plan(strategy)
[17:47:07.183] Resolving futures part of globals (recursively) ...
[17:47:07.184] resolve() on list ...
[17:47:07.184]  recursive: 99
[17:47:07.184]  length: 1
[17:47:07.184]  elements: ‘a’
[17:47:07.187] plan(): nbrOfWorkers() = 2
[17:47:07.188] Future #1
[17:47:07.188] result() for MulticoreFuture ...
[17:47:07.189] result() for MulticoreFuture ...
[17:47:07.189] result() for MulticoreFuture ... done
[17:47:07.189] result() for MulticoreFuture ... done
[17:47:07.189] result() for MulticoreFuture ...
[17:47:07.190] result() for MulticoreFuture ... done
[17:47:07.190] A MulticoreFuture was resolved
[17:47:07.190]  length: 0 (resolved future 1)
[17:47:07.190] resolve() on list ... DONE
[17:47:07.190] - globals: [1] ‘a’
[17:47:07.190] Resolving futures part of globals (recursively) ... DONE
[17:47:07.192] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[17:47:07.192] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[17:47:07.192] - globals: [1] ‘a’
[17:47:07.192] - packages: [1] ‘future’
[17:47:07.192] getGlobalsAndPackages() ... DONE
[17:47:07.193] run() for ‘Future’ ...
[17:47:07.193] - state: ‘created’
[17:47:07.193] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.197] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.197] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.197]   - Field: ‘label’
[17:47:07.197]   - Field: ‘local’
[17:47:07.198]   - Field: ‘owner’
[17:47:07.198]   - Field: ‘envir’
[17:47:07.198]   - Field: ‘workers’
[17:47:07.198]   - Field: ‘packages’
[17:47:07.198]   - Field: ‘gc’
[17:47:07.198]   - Field: ‘job’
[17:47:07.198]   - Field: ‘conditions’
[17:47:07.198]   - Field: ‘expr’
[17:47:07.198]   - Field: ‘uuid’
[17:47:07.199]   - Field: ‘seed’
[17:47:07.199]   - Field: ‘version’
[17:47:07.199]   - Field: ‘result’
[17:47:07.199]   - Field: ‘asynchronous’
[17:47:07.199]   - Field: ‘calls’
[17:47:07.201]   - Field: ‘globals’
[17:47:07.201]   - Field: ‘stdout’
[17:47:07.201]   - Field: ‘earlySignal’
[17:47:07.202]   - Field: ‘lazy’
[17:47:07.202]   - Field: ‘state’
[17:47:07.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.202] - Launch lazy future ...
[17:47:07.203] Packages needed by the future expression (n = 1): ‘future’
[17:47:07.203] Packages needed by future strategies (n = 0): <none>
[17:47:07.204] {
[17:47:07.204]     {
[17:47:07.204]         {
[17:47:07.204]             ...future.startTime <- base::Sys.time()
[17:47:07.204]             {
[17:47:07.204]                 {
[17:47:07.204]                   {
[17:47:07.204]                     {
[17:47:07.204]                       {
[17:47:07.204]                         base::local({
[17:47:07.204]                           has_future <- base::requireNamespace("future", 
[17:47:07.204]                             quietly = TRUE)
[17:47:07.204]                           if (has_future) {
[17:47:07.204]                             ns <- base::getNamespace("future")
[17:47:07.204]                             version <- ns[[".package"]][["version"]]
[17:47:07.204]                             if (is.null(version)) 
[17:47:07.204]                               version <- utils::packageVersion("future")
[17:47:07.204]                           }
[17:47:07.204]                           else {
[17:47:07.204]                             version <- NULL
[17:47:07.204]                           }
[17:47:07.204]                           if (!has_future || version < "1.8.0") {
[17:47:07.204]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.204]                               "", base::R.version$version.string), 
[17:47:07.204]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:07.204]                                 base::R.version$platform, 8 * 
[17:47:07.204]                                   base::.Machine$sizeof.pointer), 
[17:47:07.204]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.204]                                 "release", "version")], collapse = " "), 
[17:47:07.204]                               hostname = base::Sys.info()[["nodename"]])
[17:47:07.204]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.204]                               info)
[17:47:07.204]                             info <- base::paste(info, collapse = "; ")
[17:47:07.204]                             if (!has_future) {
[17:47:07.204]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.204]                                 info)
[17:47:07.204]                             }
[17:47:07.204]                             else {
[17:47:07.204]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.204]                                 info, version)
[17:47:07.204]                             }
[17:47:07.204]                             base::stop(msg)
[17:47:07.204]                           }
[17:47:07.204]                         })
[17:47:07.204]                       }
[17:47:07.204]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.204]                       base::options(mc.cores = 1L)
[17:47:07.204]                     }
[17:47:07.204]                     base::local({
[17:47:07.204]                       for (pkg in "future") {
[17:47:07.204]                         base::loadNamespace(pkg)
[17:47:07.204]                         base::library(pkg, character.only = TRUE)
[17:47:07.204]                       }
[17:47:07.204]                     })
[17:47:07.204]                   }
[17:47:07.204]                   ...future.strategy.old <- future::plan("list")
[17:47:07.204]                   options(future.plan = NULL)
[17:47:07.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.204]                 }
[17:47:07.204]                 ...future.workdir <- getwd()
[17:47:07.204]             }
[17:47:07.204]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.204]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.204]         }
[17:47:07.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.204]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.204]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.204]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.204]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.204]             base::names(...future.oldOptions))
[17:47:07.204]     }
[17:47:07.204]     if (FALSE) {
[17:47:07.204]     }
[17:47:07.204]     else {
[17:47:07.204]         if (TRUE) {
[17:47:07.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.204]                 open = "w")
[17:47:07.204]         }
[17:47:07.204]         else {
[17:47:07.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.204]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.204]         }
[17:47:07.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.204]             base::sink(type = "output", split = FALSE)
[17:47:07.204]             base::close(...future.stdout)
[17:47:07.204]         }, add = TRUE)
[17:47:07.204]     }
[17:47:07.204]     ...future.frame <- base::sys.nframe()
[17:47:07.204]     ...future.conditions <- base::list()
[17:47:07.204]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.204]     if (FALSE) {
[17:47:07.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.204]     }
[17:47:07.204]     ...future.result <- base::tryCatch({
[17:47:07.204]         base::withCallingHandlers({
[17:47:07.204]             ...future.value <- base::withVisible(base::local({
[17:47:07.204]                 withCallingHandlers({
[17:47:07.204]                   value(a) + 1
[17:47:07.204]                 }, immediateCondition = function(cond) {
[17:47:07.204]                   save_rds <- function (object, pathname, ...) 
[17:47:07.204]                   {
[17:47:07.204]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.204]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.204]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.204]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.204]                         fi_tmp[["mtime"]])
[17:47:07.204]                     }
[17:47:07.204]                     tryCatch({
[17:47:07.204]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.204]                     }, error = function(ex) {
[17:47:07.204]                       msg <- conditionMessage(ex)
[17:47:07.204]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.204]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.204]                         fi_tmp[["mtime"]], msg)
[17:47:07.204]                       ex$message <- msg
[17:47:07.204]                       stop(ex)
[17:47:07.204]                     })
[17:47:07.204]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.204]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.204]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.204]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.204]                       fi <- file.info(pathname)
[17:47:07.204]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.204]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.204]                         fi[["size"]], fi[["mtime"]])
[17:47:07.204]                       stop(msg)
[17:47:07.204]                     }
[17:47:07.204]                     invisible(pathname)
[17:47:07.204]                   }
[17:47:07.204]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.204]                     rootPath = tempdir()) 
[17:47:07.204]                   {
[17:47:07.204]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.204]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.204]                       tmpdir = path, fileext = ".rds")
[17:47:07.204]                     save_rds(obj, file)
[17:47:07.204]                   }
[17:47:07.204]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.204]                   {
[17:47:07.204]                     inherits <- base::inherits
[17:47:07.204]                     invokeRestart <- base::invokeRestart
[17:47:07.204]                     is.null <- base::is.null
[17:47:07.204]                     muffled <- FALSE
[17:47:07.204]                     if (inherits(cond, "message")) {
[17:47:07.204]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.204]                       if (muffled) 
[17:47:07.204]                         invokeRestart("muffleMessage")
[17:47:07.204]                     }
[17:47:07.204]                     else if (inherits(cond, "warning")) {
[17:47:07.204]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.204]                       if (muffled) 
[17:47:07.204]                         invokeRestart("muffleWarning")
[17:47:07.204]                     }
[17:47:07.204]                     else if (inherits(cond, "condition")) {
[17:47:07.204]                       if (!is.null(pattern)) {
[17:47:07.204]                         computeRestarts <- base::computeRestarts
[17:47:07.204]                         grepl <- base::grepl
[17:47:07.204]                         restarts <- computeRestarts(cond)
[17:47:07.204]                         for (restart in restarts) {
[17:47:07.204]                           name <- restart$name
[17:47:07.204]                           if (is.null(name)) 
[17:47:07.204]                             next
[17:47:07.204]                           if (!grepl(pattern, name)) 
[17:47:07.204]                             next
[17:47:07.204]                           invokeRestart(restart)
[17:47:07.204]                           muffled <- TRUE
[17:47:07.204]                           break
[17:47:07.204]                         }
[17:47:07.204]                       }
[17:47:07.204]                     }
[17:47:07.204]                     invisible(muffled)
[17:47:07.204]                   }
[17:47:07.204]                   muffleCondition(cond)
[17:47:07.204]                 })
[17:47:07.204]             }))
[17:47:07.204]             future::FutureResult(value = ...future.value$value, 
[17:47:07.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.204]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.204]                     ...future.globalenv.names))
[17:47:07.204]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.204]         }, condition = base::local({
[17:47:07.204]             c <- base::c
[17:47:07.204]             inherits <- base::inherits
[17:47:07.204]             invokeRestart <- base::invokeRestart
[17:47:07.204]             length <- base::length
[17:47:07.204]             list <- base::list
[17:47:07.204]             seq.int <- base::seq.int
[17:47:07.204]             signalCondition <- base::signalCondition
[17:47:07.204]             sys.calls <- base::sys.calls
[17:47:07.204]             `[[` <- base::`[[`
[17:47:07.204]             `+` <- base::`+`
[17:47:07.204]             `<<-` <- base::`<<-`
[17:47:07.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.204]                   3L)]
[17:47:07.204]             }
[17:47:07.204]             function(cond) {
[17:47:07.204]                 is_error <- inherits(cond, "error")
[17:47:07.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.204]                   NULL)
[17:47:07.204]                 if (is_error) {
[17:47:07.204]                   sessionInformation <- function() {
[17:47:07.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.204]                       search = base::search(), system = base::Sys.info())
[17:47:07.204]                   }
[17:47:07.204]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.204]                     cond$call), session = sessionInformation(), 
[17:47:07.204]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.204]                   signalCondition(cond)
[17:47:07.204]                 }
[17:47:07.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.204]                 "immediateCondition"))) {
[17:47:07.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.204]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.204]                   if (TRUE && !signal) {
[17:47:07.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.204]                     {
[17:47:07.204]                       inherits <- base::inherits
[17:47:07.204]                       invokeRestart <- base::invokeRestart
[17:47:07.204]                       is.null <- base::is.null
[17:47:07.204]                       muffled <- FALSE
[17:47:07.204]                       if (inherits(cond, "message")) {
[17:47:07.204]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.204]                         if (muffled) 
[17:47:07.204]                           invokeRestart("muffleMessage")
[17:47:07.204]                       }
[17:47:07.204]                       else if (inherits(cond, "warning")) {
[17:47:07.204]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.204]                         if (muffled) 
[17:47:07.204]                           invokeRestart("muffleWarning")
[17:47:07.204]                       }
[17:47:07.204]                       else if (inherits(cond, "condition")) {
[17:47:07.204]                         if (!is.null(pattern)) {
[17:47:07.204]                           computeRestarts <- base::computeRestarts
[17:47:07.204]                           grepl <- base::grepl
[17:47:07.204]                           restarts <- computeRestarts(cond)
[17:47:07.204]                           for (restart in restarts) {
[17:47:07.204]                             name <- restart$name
[17:47:07.204]                             if (is.null(name)) 
[17:47:07.204]                               next
[17:47:07.204]                             if (!grepl(pattern, name)) 
[17:47:07.204]                               next
[17:47:07.204]                             invokeRestart(restart)
[17:47:07.204]                             muffled <- TRUE
[17:47:07.204]                             break
[17:47:07.204]                           }
[17:47:07.204]                         }
[17:47:07.204]                       }
[17:47:07.204]                       invisible(muffled)
[17:47:07.204]                     }
[17:47:07.204]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.204]                   }
[17:47:07.204]                 }
[17:47:07.204]                 else {
[17:47:07.204]                   if (TRUE) {
[17:47:07.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.204]                     {
[17:47:07.204]                       inherits <- base::inherits
[17:47:07.204]                       invokeRestart <- base::invokeRestart
[17:47:07.204]                       is.null <- base::is.null
[17:47:07.204]                       muffled <- FALSE
[17:47:07.204]                       if (inherits(cond, "message")) {
[17:47:07.204]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.204]                         if (muffled) 
[17:47:07.204]                           invokeRestart("muffleMessage")
[17:47:07.204]                       }
[17:47:07.204]                       else if (inherits(cond, "warning")) {
[17:47:07.204]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.204]                         if (muffled) 
[17:47:07.204]                           invokeRestart("muffleWarning")
[17:47:07.204]                       }
[17:47:07.204]                       else if (inherits(cond, "condition")) {
[17:47:07.204]                         if (!is.null(pattern)) {
[17:47:07.204]                           computeRestarts <- base::computeRestarts
[17:47:07.204]                           grepl <- base::grepl
[17:47:07.204]                           restarts <- computeRestarts(cond)
[17:47:07.204]                           for (restart in restarts) {
[17:47:07.204]                             name <- restart$name
[17:47:07.204]                             if (is.null(name)) 
[17:47:07.204]                               next
[17:47:07.204]                             if (!grepl(pattern, name)) 
[17:47:07.204]                               next
[17:47:07.204]                             invokeRestart(restart)
[17:47:07.204]                             muffled <- TRUE
[17:47:07.204]                             break
[17:47:07.204]                           }
[17:47:07.204]                         }
[17:47:07.204]                       }
[17:47:07.204]                       invisible(muffled)
[17:47:07.204]                     }
[17:47:07.204]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.204]                   }
[17:47:07.204]                 }
[17:47:07.204]             }
[17:47:07.204]         }))
[17:47:07.204]     }, error = function(ex) {
[17:47:07.204]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.204]                 ...future.rng), started = ...future.startTime, 
[17:47:07.204]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.204]             version = "1.8"), class = "FutureResult")
[17:47:07.204]     }, finally = {
[17:47:07.204]         if (!identical(...future.workdir, getwd())) 
[17:47:07.204]             setwd(...future.workdir)
[17:47:07.204]         {
[17:47:07.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.204]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.204]             }
[17:47:07.204]             base::options(...future.oldOptions)
[17:47:07.204]             if (.Platform$OS.type == "windows") {
[17:47:07.204]                 old_names <- names(...future.oldEnvVars)
[17:47:07.204]                 envs <- base::Sys.getenv()
[17:47:07.204]                 names <- names(envs)
[17:47:07.204]                 common <- intersect(names, old_names)
[17:47:07.204]                 added <- setdiff(names, old_names)
[17:47:07.204]                 removed <- setdiff(old_names, names)
[17:47:07.204]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.204]                   envs[common]]
[17:47:07.204]                 NAMES <- toupper(changed)
[17:47:07.204]                 args <- list()
[17:47:07.204]                 for (kk in seq_along(NAMES)) {
[17:47:07.204]                   name <- changed[[kk]]
[17:47:07.204]                   NAME <- NAMES[[kk]]
[17:47:07.204]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.204]                     next
[17:47:07.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.204]                 }
[17:47:07.204]                 NAMES <- toupper(added)
[17:47:07.204]                 for (kk in seq_along(NAMES)) {
[17:47:07.204]                   name <- added[[kk]]
[17:47:07.204]                   NAME <- NAMES[[kk]]
[17:47:07.204]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.204]                     next
[17:47:07.204]                   args[[name]] <- ""
[17:47:07.204]                 }
[17:47:07.204]                 NAMES <- toupper(removed)
[17:47:07.204]                 for (kk in seq_along(NAMES)) {
[17:47:07.204]                   name <- removed[[kk]]
[17:47:07.204]                   NAME <- NAMES[[kk]]
[17:47:07.204]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.204]                     next
[17:47:07.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.204]                 }
[17:47:07.204]                 if (length(args) > 0) 
[17:47:07.204]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.204]             }
[17:47:07.204]             else {
[17:47:07.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.204]             }
[17:47:07.204]             {
[17:47:07.204]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.204]                   0L) {
[17:47:07.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.204]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.204]                   base::options(opts)
[17:47:07.204]                 }
[17:47:07.204]                 {
[17:47:07.204]                   {
[17:47:07.204]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.204]                     NULL
[17:47:07.204]                   }
[17:47:07.204]                   options(future.plan = NULL)
[17:47:07.204]                   if (is.na(NA_character_)) 
[17:47:07.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.204]                     .init = FALSE)
[17:47:07.204]                 }
[17:47:07.204]             }
[17:47:07.204]         }
[17:47:07.204]     })
[17:47:07.204]     if (TRUE) {
[17:47:07.204]         base::sink(type = "output", split = FALSE)
[17:47:07.204]         if (TRUE) {
[17:47:07.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.204]         }
[17:47:07.204]         else {
[17:47:07.204]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.204]         }
[17:47:07.204]         base::close(...future.stdout)
[17:47:07.204]         ...future.stdout <- NULL
[17:47:07.204]     }
[17:47:07.204]     ...future.result$conditions <- ...future.conditions
[17:47:07.204]     ...future.result$finished <- base::Sys.time()
[17:47:07.204]     ...future.result
[17:47:07.204] }
[17:47:07.206] assign_globals() ...
[17:47:07.206] List of 1
[17:47:07.206]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558b30824448> 
[17:47:07.206]  - attr(*, "where")=List of 1
[17:47:07.206]   ..$ a:<environment: R_EmptyEnv> 
[17:47:07.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.206]  - attr(*, "resolved")= logi TRUE
[17:47:07.206]  - attr(*, "total_size")= num 10816
[17:47:07.206]  - attr(*, "already-done")= logi TRUE
[17:47:07.209] - copied ‘a’ to environment
[17:47:07.209] assign_globals() ... done
[17:47:07.210] requestCore(): workers = 2
[17:47:07.212] MulticoreFuture started
[17:47:07.212] - Launch lazy future ... done
[17:47:07.212] run() for ‘MulticoreFuture’ ... done
[17:47:07.213] result() for MulticoreFuture ...
[17:47:07.213] plan(): Setting new future strategy stack:
[17:47:07.213] List of future strategies:
[17:47:07.213] 1. sequential:
[17:47:07.213]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.213]    - tweaked: FALSE
[17:47:07.213]    - call: NULL
[17:47:07.214] plan(): nbrOfWorkers() = 1
[17:47:07.218] plan(): Setting new future strategy stack:
[17:47:07.218] List of future strategies:
[17:47:07.218] 1. multicore:
[17:47:07.218]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.218]    - tweaked: FALSE
[17:47:07.218]    - call: plan(strategy)
[17:47:07.223] plan(): nbrOfWorkers() = 2
[17:47:07.224] result() for MulticoreFuture ...
[17:47:07.225] result() for MulticoreFuture ... done
[17:47:07.225] signalConditions() ...
[17:47:07.225]  - include = ‘immediateCondition’
[17:47:07.225]  - exclude = 
[17:47:07.225]  - resignal = FALSE
[17:47:07.225]  - Number of conditions: 4
[17:47:07.225] signalConditions() ... done
[17:47:07.226] result() for MulticoreFuture ... done
[17:47:07.226] result() for MulticoreFuture ...
[17:47:07.226] result() for MulticoreFuture ... done
[17:47:07.226] signalConditions() ...
[17:47:07.226]  - include = ‘immediateCondition’
[17:47:07.226]  - exclude = 
[17:47:07.226]  - resignal = FALSE
[17:47:07.226]  - Number of conditions: 4
[17:47:07.227] signalConditions() ... done
[17:47:07.227] Future state: ‘finished’
[17:47:07.227] result() for MulticoreFuture ...
[17:47:07.227] result() for MulticoreFuture ... done
[17:47:07.227] signalConditions() ...
[17:47:07.227]  - include = ‘condition’
[17:47:07.227]  - exclude = ‘immediateCondition’
[17:47:07.228]  - resignal = TRUE
[17:47:07.228]  - Number of conditions: 4
[17:47:07.228]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.216] result() for MulticoreFuture ...
[17:47:07.228]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.216] result() for MulticoreFuture ... done
[17:47:07.228]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.216] result() for MulticoreFuture ...
[17:47:07.228]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.216] result() for MulticoreFuture ... done
[17:47:07.228] signalConditions() ... done
value(b) = 2
[17:47:07.229] result() for MulticoreFuture ...
[17:47:07.229] result() for MulticoreFuture ... done
[17:47:07.229] result() for MulticoreFuture ...
[17:47:07.229] result() for MulticoreFuture ... done
[17:47:07.229] signalConditions() ...
[17:47:07.229]  - include = ‘immediateCondition’
[17:47:07.229]  - exclude = 
[17:47:07.229]  - resignal = FALSE
[17:47:07.229]  - Number of conditions: 4
[17:47:07.230] signalConditions() ... done
[17:47:07.230] Future state: ‘finished’
[17:47:07.230] result() for MulticoreFuture ...
[17:47:07.230] result() for MulticoreFuture ... done
[17:47:07.230] signalConditions() ...
[17:47:07.230]  - include = ‘condition’
[17:47:07.230]  - exclude = ‘immediateCondition’
[17:47:07.230]  - resignal = TRUE
[17:47:07.230]  - Number of conditions: 4
[17:47:07.231]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.216] result() for MulticoreFuture ...
[17:47:07.231]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.216] result() for MulticoreFuture ... done
[17:47:07.231]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.216] result() for MulticoreFuture ...
[17:47:07.231]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.216] result() for MulticoreFuture ... done
[17:47:07.231] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.232] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.232] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.233] 
[17:47:07.233] Searching for globals ... DONE
[17:47:07.233] - globals: [0] <none>
[17:47:07.233] getGlobalsAndPackages() ... DONE
[17:47:07.233] run() for ‘Future’ ...
[17:47:07.233] - state: ‘created’
[17:47:07.234] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.238] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.238] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.238]   - Field: ‘label’
[17:47:07.238]   - Field: ‘local’
[17:47:07.238]   - Field: ‘owner’
[17:47:07.238]   - Field: ‘envir’
[17:47:07.239]   - Field: ‘workers’
[17:47:07.239]   - Field: ‘packages’
[17:47:07.239]   - Field: ‘gc’
[17:47:07.239]   - Field: ‘job’
[17:47:07.239]   - Field: ‘conditions’
[17:47:07.239]   - Field: ‘expr’
[17:47:07.239]   - Field: ‘uuid’
[17:47:07.239]   - Field: ‘seed’
[17:47:07.240]   - Field: ‘version’
[17:47:07.240]   - Field: ‘result’
[17:47:07.240]   - Field: ‘asynchronous’
[17:47:07.240]   - Field: ‘calls’
[17:47:07.240]   - Field: ‘globals’
[17:47:07.240]   - Field: ‘stdout’
[17:47:07.240]   - Field: ‘earlySignal’
[17:47:07.240]   - Field: ‘lazy’
[17:47:07.240]   - Field: ‘state’
[17:47:07.241] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.241] - Launch lazy future ...
[17:47:07.241] Packages needed by the future expression (n = 0): <none>
[17:47:07.241] Packages needed by future strategies (n = 0): <none>
[17:47:07.242] {
[17:47:07.242]     {
[17:47:07.242]         {
[17:47:07.242]             ...future.startTime <- base::Sys.time()
[17:47:07.242]             {
[17:47:07.242]                 {
[17:47:07.242]                   {
[17:47:07.242]                     {
[17:47:07.242]                       base::local({
[17:47:07.242]                         has_future <- base::requireNamespace("future", 
[17:47:07.242]                           quietly = TRUE)
[17:47:07.242]                         if (has_future) {
[17:47:07.242]                           ns <- base::getNamespace("future")
[17:47:07.242]                           version <- ns[[".package"]][["version"]]
[17:47:07.242]                           if (is.null(version)) 
[17:47:07.242]                             version <- utils::packageVersion("future")
[17:47:07.242]                         }
[17:47:07.242]                         else {
[17:47:07.242]                           version <- NULL
[17:47:07.242]                         }
[17:47:07.242]                         if (!has_future || version < "1.8.0") {
[17:47:07.242]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.242]                             "", base::R.version$version.string), 
[17:47:07.242]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.242]                               "release", "version")], collapse = " "), 
[17:47:07.242]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.242]                             info)
[17:47:07.242]                           info <- base::paste(info, collapse = "; ")
[17:47:07.242]                           if (!has_future) {
[17:47:07.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.242]                               info)
[17:47:07.242]                           }
[17:47:07.242]                           else {
[17:47:07.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.242]                               info, version)
[17:47:07.242]                           }
[17:47:07.242]                           base::stop(msg)
[17:47:07.242]                         }
[17:47:07.242]                       })
[17:47:07.242]                     }
[17:47:07.242]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.242]                     base::options(mc.cores = 1L)
[17:47:07.242]                   }
[17:47:07.242]                   ...future.strategy.old <- future::plan("list")
[17:47:07.242]                   options(future.plan = NULL)
[17:47:07.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.242]                 }
[17:47:07.242]                 ...future.workdir <- getwd()
[17:47:07.242]             }
[17:47:07.242]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.242]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.242]         }
[17:47:07.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.242]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.242]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.242]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.242]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.242]             base::names(...future.oldOptions))
[17:47:07.242]     }
[17:47:07.242]     if (FALSE) {
[17:47:07.242]     }
[17:47:07.242]     else {
[17:47:07.242]         if (TRUE) {
[17:47:07.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.242]                 open = "w")
[17:47:07.242]         }
[17:47:07.242]         else {
[17:47:07.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.242]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.242]         }
[17:47:07.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.242]             base::sink(type = "output", split = FALSE)
[17:47:07.242]             base::close(...future.stdout)
[17:47:07.242]         }, add = TRUE)
[17:47:07.242]     }
[17:47:07.242]     ...future.frame <- base::sys.nframe()
[17:47:07.242]     ...future.conditions <- base::list()
[17:47:07.242]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.242]     if (FALSE) {
[17:47:07.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.242]     }
[17:47:07.242]     ...future.result <- base::tryCatch({
[17:47:07.242]         base::withCallingHandlers({
[17:47:07.242]             ...future.value <- base::withVisible(base::local({
[17:47:07.242]                 withCallingHandlers({
[17:47:07.242]                   1
[17:47:07.242]                 }, immediateCondition = function(cond) {
[17:47:07.242]                   save_rds <- function (object, pathname, ...) 
[17:47:07.242]                   {
[17:47:07.242]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.242]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.242]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.242]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.242]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.242]                         fi_tmp[["mtime"]])
[17:47:07.242]                     }
[17:47:07.242]                     tryCatch({
[17:47:07.242]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.242]                     }, error = function(ex) {
[17:47:07.242]                       msg <- conditionMessage(ex)
[17:47:07.242]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.242]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.242]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.242]                         fi_tmp[["mtime"]], msg)
[17:47:07.242]                       ex$message <- msg
[17:47:07.242]                       stop(ex)
[17:47:07.242]                     })
[17:47:07.242]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.242]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.242]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.242]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.242]                       fi <- file.info(pathname)
[17:47:07.242]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.242]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.242]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.242]                         fi[["size"]], fi[["mtime"]])
[17:47:07.242]                       stop(msg)
[17:47:07.242]                     }
[17:47:07.242]                     invisible(pathname)
[17:47:07.242]                   }
[17:47:07.242]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.242]                     rootPath = tempdir()) 
[17:47:07.242]                   {
[17:47:07.242]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.242]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.242]                       tmpdir = path, fileext = ".rds")
[17:47:07.242]                     save_rds(obj, file)
[17:47:07.242]                   }
[17:47:07.242]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.242]                   {
[17:47:07.242]                     inherits <- base::inherits
[17:47:07.242]                     invokeRestart <- base::invokeRestart
[17:47:07.242]                     is.null <- base::is.null
[17:47:07.242]                     muffled <- FALSE
[17:47:07.242]                     if (inherits(cond, "message")) {
[17:47:07.242]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.242]                       if (muffled) 
[17:47:07.242]                         invokeRestart("muffleMessage")
[17:47:07.242]                     }
[17:47:07.242]                     else if (inherits(cond, "warning")) {
[17:47:07.242]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.242]                       if (muffled) 
[17:47:07.242]                         invokeRestart("muffleWarning")
[17:47:07.242]                     }
[17:47:07.242]                     else if (inherits(cond, "condition")) {
[17:47:07.242]                       if (!is.null(pattern)) {
[17:47:07.242]                         computeRestarts <- base::computeRestarts
[17:47:07.242]                         grepl <- base::grepl
[17:47:07.242]                         restarts <- computeRestarts(cond)
[17:47:07.242]                         for (restart in restarts) {
[17:47:07.242]                           name <- restart$name
[17:47:07.242]                           if (is.null(name)) 
[17:47:07.242]                             next
[17:47:07.242]                           if (!grepl(pattern, name)) 
[17:47:07.242]                             next
[17:47:07.242]                           invokeRestart(restart)
[17:47:07.242]                           muffled <- TRUE
[17:47:07.242]                           break
[17:47:07.242]                         }
[17:47:07.242]                       }
[17:47:07.242]                     }
[17:47:07.242]                     invisible(muffled)
[17:47:07.242]                   }
[17:47:07.242]                   muffleCondition(cond)
[17:47:07.242]                 })
[17:47:07.242]             }))
[17:47:07.242]             future::FutureResult(value = ...future.value$value, 
[17:47:07.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.242]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.242]                     ...future.globalenv.names))
[17:47:07.242]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.242]         }, condition = base::local({
[17:47:07.242]             c <- base::c
[17:47:07.242]             inherits <- base::inherits
[17:47:07.242]             invokeRestart <- base::invokeRestart
[17:47:07.242]             length <- base::length
[17:47:07.242]             list <- base::list
[17:47:07.242]             seq.int <- base::seq.int
[17:47:07.242]             signalCondition <- base::signalCondition
[17:47:07.242]             sys.calls <- base::sys.calls
[17:47:07.242]             `[[` <- base::`[[`
[17:47:07.242]             `+` <- base::`+`
[17:47:07.242]             `<<-` <- base::`<<-`
[17:47:07.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.242]                   3L)]
[17:47:07.242]             }
[17:47:07.242]             function(cond) {
[17:47:07.242]                 is_error <- inherits(cond, "error")
[17:47:07.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.242]                   NULL)
[17:47:07.242]                 if (is_error) {
[17:47:07.242]                   sessionInformation <- function() {
[17:47:07.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.242]                       search = base::search(), system = base::Sys.info())
[17:47:07.242]                   }
[17:47:07.242]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.242]                     cond$call), session = sessionInformation(), 
[17:47:07.242]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.242]                   signalCondition(cond)
[17:47:07.242]                 }
[17:47:07.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.242]                 "immediateCondition"))) {
[17:47:07.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.242]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.242]                   if (TRUE && !signal) {
[17:47:07.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.242]                     {
[17:47:07.242]                       inherits <- base::inherits
[17:47:07.242]                       invokeRestart <- base::invokeRestart
[17:47:07.242]                       is.null <- base::is.null
[17:47:07.242]                       muffled <- FALSE
[17:47:07.242]                       if (inherits(cond, "message")) {
[17:47:07.242]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.242]                         if (muffled) 
[17:47:07.242]                           invokeRestart("muffleMessage")
[17:47:07.242]                       }
[17:47:07.242]                       else if (inherits(cond, "warning")) {
[17:47:07.242]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.242]                         if (muffled) 
[17:47:07.242]                           invokeRestart("muffleWarning")
[17:47:07.242]                       }
[17:47:07.242]                       else if (inherits(cond, "condition")) {
[17:47:07.242]                         if (!is.null(pattern)) {
[17:47:07.242]                           computeRestarts <- base::computeRestarts
[17:47:07.242]                           grepl <- base::grepl
[17:47:07.242]                           restarts <- computeRestarts(cond)
[17:47:07.242]                           for (restart in restarts) {
[17:47:07.242]                             name <- restart$name
[17:47:07.242]                             if (is.null(name)) 
[17:47:07.242]                               next
[17:47:07.242]                             if (!grepl(pattern, name)) 
[17:47:07.242]                               next
[17:47:07.242]                             invokeRestart(restart)
[17:47:07.242]                             muffled <- TRUE
[17:47:07.242]                             break
[17:47:07.242]                           }
[17:47:07.242]                         }
[17:47:07.242]                       }
[17:47:07.242]                       invisible(muffled)
[17:47:07.242]                     }
[17:47:07.242]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.242]                   }
[17:47:07.242]                 }
[17:47:07.242]                 else {
[17:47:07.242]                   if (TRUE) {
[17:47:07.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.242]                     {
[17:47:07.242]                       inherits <- base::inherits
[17:47:07.242]                       invokeRestart <- base::invokeRestart
[17:47:07.242]                       is.null <- base::is.null
[17:47:07.242]                       muffled <- FALSE
[17:47:07.242]                       if (inherits(cond, "message")) {
[17:47:07.242]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.242]                         if (muffled) 
[17:47:07.242]                           invokeRestart("muffleMessage")
[17:47:07.242]                       }
[17:47:07.242]                       else if (inherits(cond, "warning")) {
[17:47:07.242]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.242]                         if (muffled) 
[17:47:07.242]                           invokeRestart("muffleWarning")
[17:47:07.242]                       }
[17:47:07.242]                       else if (inherits(cond, "condition")) {
[17:47:07.242]                         if (!is.null(pattern)) {
[17:47:07.242]                           computeRestarts <- base::computeRestarts
[17:47:07.242]                           grepl <- base::grepl
[17:47:07.242]                           restarts <- computeRestarts(cond)
[17:47:07.242]                           for (restart in restarts) {
[17:47:07.242]                             name <- restart$name
[17:47:07.242]                             if (is.null(name)) 
[17:47:07.242]                               next
[17:47:07.242]                             if (!grepl(pattern, name)) 
[17:47:07.242]                               next
[17:47:07.242]                             invokeRestart(restart)
[17:47:07.242]                             muffled <- TRUE
[17:47:07.242]                             break
[17:47:07.242]                           }
[17:47:07.242]                         }
[17:47:07.242]                       }
[17:47:07.242]                       invisible(muffled)
[17:47:07.242]                     }
[17:47:07.242]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.242]                   }
[17:47:07.242]                 }
[17:47:07.242]             }
[17:47:07.242]         }))
[17:47:07.242]     }, error = function(ex) {
[17:47:07.242]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.242]                 ...future.rng), started = ...future.startTime, 
[17:47:07.242]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.242]             version = "1.8"), class = "FutureResult")
[17:47:07.242]     }, finally = {
[17:47:07.242]         if (!identical(...future.workdir, getwd())) 
[17:47:07.242]             setwd(...future.workdir)
[17:47:07.242]         {
[17:47:07.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.242]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.242]             }
[17:47:07.242]             base::options(...future.oldOptions)
[17:47:07.242]             if (.Platform$OS.type == "windows") {
[17:47:07.242]                 old_names <- names(...future.oldEnvVars)
[17:47:07.242]                 envs <- base::Sys.getenv()
[17:47:07.242]                 names <- names(envs)
[17:47:07.242]                 common <- intersect(names, old_names)
[17:47:07.242]                 added <- setdiff(names, old_names)
[17:47:07.242]                 removed <- setdiff(old_names, names)
[17:47:07.242]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.242]                   envs[common]]
[17:47:07.242]                 NAMES <- toupper(changed)
[17:47:07.242]                 args <- list()
[17:47:07.242]                 for (kk in seq_along(NAMES)) {
[17:47:07.242]                   name <- changed[[kk]]
[17:47:07.242]                   NAME <- NAMES[[kk]]
[17:47:07.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.242]                     next
[17:47:07.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.242]                 }
[17:47:07.242]                 NAMES <- toupper(added)
[17:47:07.242]                 for (kk in seq_along(NAMES)) {
[17:47:07.242]                   name <- added[[kk]]
[17:47:07.242]                   NAME <- NAMES[[kk]]
[17:47:07.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.242]                     next
[17:47:07.242]                   args[[name]] <- ""
[17:47:07.242]                 }
[17:47:07.242]                 NAMES <- toupper(removed)
[17:47:07.242]                 for (kk in seq_along(NAMES)) {
[17:47:07.242]                   name <- removed[[kk]]
[17:47:07.242]                   NAME <- NAMES[[kk]]
[17:47:07.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.242]                     next
[17:47:07.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.242]                 }
[17:47:07.242]                 if (length(args) > 0) 
[17:47:07.242]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.242]             }
[17:47:07.242]             else {
[17:47:07.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.242]             }
[17:47:07.242]             {
[17:47:07.242]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.242]                   0L) {
[17:47:07.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.242]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.242]                   base::options(opts)
[17:47:07.242]                 }
[17:47:07.242]                 {
[17:47:07.242]                   {
[17:47:07.242]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.242]                     NULL
[17:47:07.242]                   }
[17:47:07.242]                   options(future.plan = NULL)
[17:47:07.242]                   if (is.na(NA_character_)) 
[17:47:07.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.242]                     .init = FALSE)
[17:47:07.242]                 }
[17:47:07.242]             }
[17:47:07.242]         }
[17:47:07.242]     })
[17:47:07.242]     if (TRUE) {
[17:47:07.242]         base::sink(type = "output", split = FALSE)
[17:47:07.242]         if (TRUE) {
[17:47:07.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.242]         }
[17:47:07.242]         else {
[17:47:07.242]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.242]         }
[17:47:07.242]         base::close(...future.stdout)
[17:47:07.242]         ...future.stdout <- NULL
[17:47:07.242]     }
[17:47:07.242]     ...future.result$conditions <- ...future.conditions
[17:47:07.242]     ...future.result$finished <- base::Sys.time()
[17:47:07.242]     ...future.result
[17:47:07.242] }
[17:47:07.244] requestCore(): workers = 2
[17:47:07.246] MulticoreFuture started
[17:47:07.246] - Launch lazy future ... done
[17:47:07.247] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.247] getGlobalsAndPackages() ...
[17:47:07.247] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.248] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.247] List of future strategies:
[17:47:07.247] 1. sequential:
[17:47:07.247]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.247]    - tweaked: FALSE
[17:47:07.247]    - call: NULL
[17:47:07.248] plan(): nbrOfWorkers() = 1
[17:47:07.250] plan(): Setting new future strategy stack:
[17:47:07.250] List of future strategies:
[17:47:07.250] 1. multicore:
[17:47:07.250]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.250]    - tweaked: FALSE
[17:47:07.250]    - call: plan(strategy)
[17:47:07.249] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:07.254] Searching for globals ... DONE
[17:47:07.254] Resolving globals: TRUE
[17:47:07.254] Resolving any globals that are futures ...
[17:47:07.255] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:07.255] Resolving any globals that are futures ... DONE
[17:47:07.256] Resolving futures part of globals (recursively) ...
[17:47:07.257] resolve() on list ...
[17:47:07.258]  recursive: 99
[17:47:07.258]  length: 1
[17:47:07.258] plan(): nbrOfWorkers() = 2
[17:47:07.258]  elements: ‘a’
[17:47:07.259] Future #1
[17:47:07.259] result() for MulticoreFuture ...
[17:47:07.260] result() for MulticoreFuture ...
[17:47:07.260] result() for MulticoreFuture ... done
[17:47:07.261] result() for MulticoreFuture ... done
[17:47:07.261] result() for MulticoreFuture ...
[17:47:07.261] result() for MulticoreFuture ... done
[17:47:07.261] A MulticoreFuture was resolved
[17:47:07.261]  length: 0 (resolved future 1)
[17:47:07.261] resolve() on list ... DONE
[17:47:07.262] - globals: [1] ‘a’
[17:47:07.262] Resolving futures part of globals (recursively) ... DONE
[17:47:07.263] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[17:47:07.263] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[17:47:07.264] - globals: [1] ‘a’
[17:47:07.264] - packages: [1] ‘future’
[17:47:07.264] getGlobalsAndPackages() ... DONE
[17:47:07.264] run() for ‘Future’ ...
[17:47:07.264] - state: ‘created’
[17:47:07.264] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.268] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.269] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.269]   - Field: ‘label’
[17:47:07.269]   - Field: ‘local’
[17:47:07.269]   - Field: ‘owner’
[17:47:07.269]   - Field: ‘envir’
[17:47:07.269]   - Field: ‘workers’
[17:47:07.269]   - Field: ‘packages’
[17:47:07.269]   - Field: ‘gc’
[17:47:07.270]   - Field: ‘job’
[17:47:07.270]   - Field: ‘conditions’
[17:47:07.270]   - Field: ‘expr’
[17:47:07.270]   - Field: ‘uuid’
[17:47:07.270]   - Field: ‘seed’
[17:47:07.270]   - Field: ‘version’
[17:47:07.270]   - Field: ‘result’
[17:47:07.270]   - Field: ‘asynchronous’
[17:47:07.270]   - Field: ‘calls’
[17:47:07.270]   - Field: ‘globals’
[17:47:07.271]   - Field: ‘stdout’
[17:47:07.271]   - Field: ‘earlySignal’
[17:47:07.271]   - Field: ‘lazy’
[17:47:07.271]   - Field: ‘state’
[17:47:07.271] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.271] - Launch lazy future ...
[17:47:07.271] Packages needed by the future expression (n = 1): ‘future’
[17:47:07.272] Packages needed by future strategies (n = 0): <none>
[17:47:07.272] {
[17:47:07.272]     {
[17:47:07.272]         {
[17:47:07.272]             ...future.startTime <- base::Sys.time()
[17:47:07.272]             {
[17:47:07.272]                 {
[17:47:07.272]                   {
[17:47:07.272]                     {
[17:47:07.272]                       {
[17:47:07.272]                         base::local({
[17:47:07.272]                           has_future <- base::requireNamespace("future", 
[17:47:07.272]                             quietly = TRUE)
[17:47:07.272]                           if (has_future) {
[17:47:07.272]                             ns <- base::getNamespace("future")
[17:47:07.272]                             version <- ns[[".package"]][["version"]]
[17:47:07.272]                             if (is.null(version)) 
[17:47:07.272]                               version <- utils::packageVersion("future")
[17:47:07.272]                           }
[17:47:07.272]                           else {
[17:47:07.272]                             version <- NULL
[17:47:07.272]                           }
[17:47:07.272]                           if (!has_future || version < "1.8.0") {
[17:47:07.272]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.272]                               "", base::R.version$version.string), 
[17:47:07.272]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:07.272]                                 base::R.version$platform, 8 * 
[17:47:07.272]                                   base::.Machine$sizeof.pointer), 
[17:47:07.272]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.272]                                 "release", "version")], collapse = " "), 
[17:47:07.272]                               hostname = base::Sys.info()[["nodename"]])
[17:47:07.272]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.272]                               info)
[17:47:07.272]                             info <- base::paste(info, collapse = "; ")
[17:47:07.272]                             if (!has_future) {
[17:47:07.272]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.272]                                 info)
[17:47:07.272]                             }
[17:47:07.272]                             else {
[17:47:07.272]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.272]                                 info, version)
[17:47:07.272]                             }
[17:47:07.272]                             base::stop(msg)
[17:47:07.272]                           }
[17:47:07.272]                         })
[17:47:07.272]                       }
[17:47:07.272]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.272]                       base::options(mc.cores = 1L)
[17:47:07.272]                     }
[17:47:07.272]                     base::local({
[17:47:07.272]                       for (pkg in "future") {
[17:47:07.272]                         base::loadNamespace(pkg)
[17:47:07.272]                         base::library(pkg, character.only = TRUE)
[17:47:07.272]                       }
[17:47:07.272]                     })
[17:47:07.272]                   }
[17:47:07.272]                   ...future.strategy.old <- future::plan("list")
[17:47:07.272]                   options(future.plan = NULL)
[17:47:07.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.272]                 }
[17:47:07.272]                 ...future.workdir <- getwd()
[17:47:07.272]             }
[17:47:07.272]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.272]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.272]         }
[17:47:07.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.272]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.272]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.272]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.272]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.272]             base::names(...future.oldOptions))
[17:47:07.272]     }
[17:47:07.272]     if (FALSE) {
[17:47:07.272]     }
[17:47:07.272]     else {
[17:47:07.272]         if (TRUE) {
[17:47:07.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.272]                 open = "w")
[17:47:07.272]         }
[17:47:07.272]         else {
[17:47:07.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.272]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.272]         }
[17:47:07.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.272]             base::sink(type = "output", split = FALSE)
[17:47:07.272]             base::close(...future.stdout)
[17:47:07.272]         }, add = TRUE)
[17:47:07.272]     }
[17:47:07.272]     ...future.frame <- base::sys.nframe()
[17:47:07.272]     ...future.conditions <- base::list()
[17:47:07.272]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.272]     if (FALSE) {
[17:47:07.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.272]     }
[17:47:07.272]     ...future.result <- base::tryCatch({
[17:47:07.272]         base::withCallingHandlers({
[17:47:07.272]             ...future.value <- base::withVisible(base::local({
[17:47:07.272]                 withCallingHandlers({
[17:47:07.272]                   value(a) + 1
[17:47:07.272]                 }, immediateCondition = function(cond) {
[17:47:07.272]                   save_rds <- function (object, pathname, ...) 
[17:47:07.272]                   {
[17:47:07.272]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.272]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.272]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.272]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.272]                         fi_tmp[["mtime"]])
[17:47:07.272]                     }
[17:47:07.272]                     tryCatch({
[17:47:07.272]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.272]                     }, error = function(ex) {
[17:47:07.272]                       msg <- conditionMessage(ex)
[17:47:07.272]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.272]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.272]                         fi_tmp[["mtime"]], msg)
[17:47:07.272]                       ex$message <- msg
[17:47:07.272]                       stop(ex)
[17:47:07.272]                     })
[17:47:07.272]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.272]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.272]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.272]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.272]                       fi <- file.info(pathname)
[17:47:07.272]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.272]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.272]                         fi[["size"]], fi[["mtime"]])
[17:47:07.272]                       stop(msg)
[17:47:07.272]                     }
[17:47:07.272]                     invisible(pathname)
[17:47:07.272]                   }
[17:47:07.272]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.272]                     rootPath = tempdir()) 
[17:47:07.272]                   {
[17:47:07.272]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.272]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.272]                       tmpdir = path, fileext = ".rds")
[17:47:07.272]                     save_rds(obj, file)
[17:47:07.272]                   }
[17:47:07.272]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.272]                   {
[17:47:07.272]                     inherits <- base::inherits
[17:47:07.272]                     invokeRestart <- base::invokeRestart
[17:47:07.272]                     is.null <- base::is.null
[17:47:07.272]                     muffled <- FALSE
[17:47:07.272]                     if (inherits(cond, "message")) {
[17:47:07.272]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.272]                       if (muffled) 
[17:47:07.272]                         invokeRestart("muffleMessage")
[17:47:07.272]                     }
[17:47:07.272]                     else if (inherits(cond, "warning")) {
[17:47:07.272]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.272]                       if (muffled) 
[17:47:07.272]                         invokeRestart("muffleWarning")
[17:47:07.272]                     }
[17:47:07.272]                     else if (inherits(cond, "condition")) {
[17:47:07.272]                       if (!is.null(pattern)) {
[17:47:07.272]                         computeRestarts <- base::computeRestarts
[17:47:07.272]                         grepl <- base::grepl
[17:47:07.272]                         restarts <- computeRestarts(cond)
[17:47:07.272]                         for (restart in restarts) {
[17:47:07.272]                           name <- restart$name
[17:47:07.272]                           if (is.null(name)) 
[17:47:07.272]                             next
[17:47:07.272]                           if (!grepl(pattern, name)) 
[17:47:07.272]                             next
[17:47:07.272]                           invokeRestart(restart)
[17:47:07.272]                           muffled <- TRUE
[17:47:07.272]                           break
[17:47:07.272]                         }
[17:47:07.272]                       }
[17:47:07.272]                     }
[17:47:07.272]                     invisible(muffled)
[17:47:07.272]                   }
[17:47:07.272]                   muffleCondition(cond)
[17:47:07.272]                 })
[17:47:07.272]             }))
[17:47:07.272]             future::FutureResult(value = ...future.value$value, 
[17:47:07.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.272]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.272]                     ...future.globalenv.names))
[17:47:07.272]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.272]         }, condition = base::local({
[17:47:07.272]             c <- base::c
[17:47:07.272]             inherits <- base::inherits
[17:47:07.272]             invokeRestart <- base::invokeRestart
[17:47:07.272]             length <- base::length
[17:47:07.272]             list <- base::list
[17:47:07.272]             seq.int <- base::seq.int
[17:47:07.272]             signalCondition <- base::signalCondition
[17:47:07.272]             sys.calls <- base::sys.calls
[17:47:07.272]             `[[` <- base::`[[`
[17:47:07.272]             `+` <- base::`+`
[17:47:07.272]             `<<-` <- base::`<<-`
[17:47:07.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.272]                   3L)]
[17:47:07.272]             }
[17:47:07.272]             function(cond) {
[17:47:07.272]                 is_error <- inherits(cond, "error")
[17:47:07.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.272]                   NULL)
[17:47:07.272]                 if (is_error) {
[17:47:07.272]                   sessionInformation <- function() {
[17:47:07.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.272]                       search = base::search(), system = base::Sys.info())
[17:47:07.272]                   }
[17:47:07.272]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.272]                     cond$call), session = sessionInformation(), 
[17:47:07.272]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.272]                   signalCondition(cond)
[17:47:07.272]                 }
[17:47:07.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.272]                 "immediateCondition"))) {
[17:47:07.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.272]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.272]                   if (TRUE && !signal) {
[17:47:07.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.272]                     {
[17:47:07.272]                       inherits <- base::inherits
[17:47:07.272]                       invokeRestart <- base::invokeRestart
[17:47:07.272]                       is.null <- base::is.null
[17:47:07.272]                       muffled <- FALSE
[17:47:07.272]                       if (inherits(cond, "message")) {
[17:47:07.272]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.272]                         if (muffled) 
[17:47:07.272]                           invokeRestart("muffleMessage")
[17:47:07.272]                       }
[17:47:07.272]                       else if (inherits(cond, "warning")) {
[17:47:07.272]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.272]                         if (muffled) 
[17:47:07.272]                           invokeRestart("muffleWarning")
[17:47:07.272]                       }
[17:47:07.272]                       else if (inherits(cond, "condition")) {
[17:47:07.272]                         if (!is.null(pattern)) {
[17:47:07.272]                           computeRestarts <- base::computeRestarts
[17:47:07.272]                           grepl <- base::grepl
[17:47:07.272]                           restarts <- computeRestarts(cond)
[17:47:07.272]                           for (restart in restarts) {
[17:47:07.272]                             name <- restart$name
[17:47:07.272]                             if (is.null(name)) 
[17:47:07.272]                               next
[17:47:07.272]                             if (!grepl(pattern, name)) 
[17:47:07.272]                               next
[17:47:07.272]                             invokeRestart(restart)
[17:47:07.272]                             muffled <- TRUE
[17:47:07.272]                             break
[17:47:07.272]                           }
[17:47:07.272]                         }
[17:47:07.272]                       }
[17:47:07.272]                       invisible(muffled)
[17:47:07.272]                     }
[17:47:07.272]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.272]                   }
[17:47:07.272]                 }
[17:47:07.272]                 else {
[17:47:07.272]                   if (TRUE) {
[17:47:07.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.272]                     {
[17:47:07.272]                       inherits <- base::inherits
[17:47:07.272]                       invokeRestart <- base::invokeRestart
[17:47:07.272]                       is.null <- base::is.null
[17:47:07.272]                       muffled <- FALSE
[17:47:07.272]                       if (inherits(cond, "message")) {
[17:47:07.272]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.272]                         if (muffled) 
[17:47:07.272]                           invokeRestart("muffleMessage")
[17:47:07.272]                       }
[17:47:07.272]                       else if (inherits(cond, "warning")) {
[17:47:07.272]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.272]                         if (muffled) 
[17:47:07.272]                           invokeRestart("muffleWarning")
[17:47:07.272]                       }
[17:47:07.272]                       else if (inherits(cond, "condition")) {
[17:47:07.272]                         if (!is.null(pattern)) {
[17:47:07.272]                           computeRestarts <- base::computeRestarts
[17:47:07.272]                           grepl <- base::grepl
[17:47:07.272]                           restarts <- computeRestarts(cond)
[17:47:07.272]                           for (restart in restarts) {
[17:47:07.272]                             name <- restart$name
[17:47:07.272]                             if (is.null(name)) 
[17:47:07.272]                               next
[17:47:07.272]                             if (!grepl(pattern, name)) 
[17:47:07.272]                               next
[17:47:07.272]                             invokeRestart(restart)
[17:47:07.272]                             muffled <- TRUE
[17:47:07.272]                             break
[17:47:07.272]                           }
[17:47:07.272]                         }
[17:47:07.272]                       }
[17:47:07.272]                       invisible(muffled)
[17:47:07.272]                     }
[17:47:07.272]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.272]                   }
[17:47:07.272]                 }
[17:47:07.272]             }
[17:47:07.272]         }))
[17:47:07.272]     }, error = function(ex) {
[17:47:07.272]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.272]                 ...future.rng), started = ...future.startTime, 
[17:47:07.272]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.272]             version = "1.8"), class = "FutureResult")
[17:47:07.272]     }, finally = {
[17:47:07.272]         if (!identical(...future.workdir, getwd())) 
[17:47:07.272]             setwd(...future.workdir)
[17:47:07.272]         {
[17:47:07.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.272]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.272]             }
[17:47:07.272]             base::options(...future.oldOptions)
[17:47:07.272]             if (.Platform$OS.type == "windows") {
[17:47:07.272]                 old_names <- names(...future.oldEnvVars)
[17:47:07.272]                 envs <- base::Sys.getenv()
[17:47:07.272]                 names <- names(envs)
[17:47:07.272]                 common <- intersect(names, old_names)
[17:47:07.272]                 added <- setdiff(names, old_names)
[17:47:07.272]                 removed <- setdiff(old_names, names)
[17:47:07.272]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.272]                   envs[common]]
[17:47:07.272]                 NAMES <- toupper(changed)
[17:47:07.272]                 args <- list()
[17:47:07.272]                 for (kk in seq_along(NAMES)) {
[17:47:07.272]                   name <- changed[[kk]]
[17:47:07.272]                   NAME <- NAMES[[kk]]
[17:47:07.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.272]                     next
[17:47:07.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.272]                 }
[17:47:07.272]                 NAMES <- toupper(added)
[17:47:07.272]                 for (kk in seq_along(NAMES)) {
[17:47:07.272]                   name <- added[[kk]]
[17:47:07.272]                   NAME <- NAMES[[kk]]
[17:47:07.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.272]                     next
[17:47:07.272]                   args[[name]] <- ""
[17:47:07.272]                 }
[17:47:07.272]                 NAMES <- toupper(removed)
[17:47:07.272]                 for (kk in seq_along(NAMES)) {
[17:47:07.272]                   name <- removed[[kk]]
[17:47:07.272]                   NAME <- NAMES[[kk]]
[17:47:07.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.272]                     next
[17:47:07.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.272]                 }
[17:47:07.272]                 if (length(args) > 0) 
[17:47:07.272]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.272]             }
[17:47:07.272]             else {
[17:47:07.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.272]             }
[17:47:07.272]             {
[17:47:07.272]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.272]                   0L) {
[17:47:07.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.272]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.272]                   base::options(opts)
[17:47:07.272]                 }
[17:47:07.272]                 {
[17:47:07.272]                   {
[17:47:07.272]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.272]                     NULL
[17:47:07.272]                   }
[17:47:07.272]                   options(future.plan = NULL)
[17:47:07.272]                   if (is.na(NA_character_)) 
[17:47:07.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.272]                     .init = FALSE)
[17:47:07.272]                 }
[17:47:07.272]             }
[17:47:07.272]         }
[17:47:07.272]     })
[17:47:07.272]     if (TRUE) {
[17:47:07.272]         base::sink(type = "output", split = FALSE)
[17:47:07.272]         if (TRUE) {
[17:47:07.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.272]         }
[17:47:07.272]         else {
[17:47:07.272]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.272]         }
[17:47:07.272]         base::close(...future.stdout)
[17:47:07.272]         ...future.stdout <- NULL
[17:47:07.272]     }
[17:47:07.272]     ...future.result$conditions <- ...future.conditions
[17:47:07.272]     ...future.result$finished <- base::Sys.time()
[17:47:07.272]     ...future.result
[17:47:07.272] }
[17:47:07.274] assign_globals() ...
[17:47:07.275] List of 1
[17:47:07.275]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558b32264638> 
[17:47:07.275]  - attr(*, "where")=List of 1
[17:47:07.275]   ..$ a:<environment: R_EmptyEnv> 
[17:47:07.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.275]  - attr(*, "resolved")= logi TRUE
[17:47:07.275]  - attr(*, "total_size")= num 10816
[17:47:07.275]  - attr(*, "already-done")= logi TRUE
[17:47:07.277] - copied ‘a’ to environment
[17:47:07.278] assign_globals() ... done
[17:47:07.278] requestCore(): workers = 2
[17:47:07.279] MulticoreFuture started
[17:47:07.280] - Launch lazy future ... done
[17:47:07.280] run() for ‘MulticoreFuture’ ... done
[17:47:07.280] result() for MulticoreFuture ...
[17:47:07.281] plan(): Setting new future strategy stack:
[17:47:07.281] List of future strategies:
[17:47:07.281] 1. sequential:
[17:47:07.281]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.281]    - tweaked: FALSE
[17:47:07.281]    - call: NULL
[17:47:07.282] plan(): nbrOfWorkers() = 1
[17:47:07.285] plan(): Setting new future strategy stack:
[17:47:07.286] List of future strategies:
[17:47:07.286] 1. multicore:
[17:47:07.286]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.286]    - tweaked: FALSE
[17:47:07.286]    - call: plan(strategy)
[17:47:07.290] plan(): nbrOfWorkers() = 2
[17:47:07.291] result() for MulticoreFuture ...
[17:47:07.291] result() for MulticoreFuture ... done
[17:47:07.292] signalConditions() ...
[17:47:07.292]  - include = ‘immediateCondition’
[17:47:07.292]  - exclude = 
[17:47:07.292]  - resignal = FALSE
[17:47:07.292]  - Number of conditions: 4
[17:47:07.292] signalConditions() ... done
[17:47:07.293] result() for MulticoreFuture ... done
[17:47:07.293] result() for MulticoreFuture ...
[17:47:07.293] result() for MulticoreFuture ... done
[17:47:07.293] signalConditions() ...
[17:47:07.293]  - include = ‘immediateCondition’
[17:47:07.293]  - exclude = 
[17:47:07.293]  - resignal = FALSE
[17:47:07.293]  - Number of conditions: 4
[17:47:07.293] signalConditions() ... done
[17:47:07.294] Future state: ‘finished’
[17:47:07.294] result() for MulticoreFuture ...
[17:47:07.294] result() for MulticoreFuture ... done
[17:47:07.294] signalConditions() ...
[17:47:07.294]  - include = ‘condition’
[17:47:07.294]  - exclude = ‘immediateCondition’
[17:47:07.294]  - resignal = TRUE
[17:47:07.294]  - Number of conditions: 4
[17:47:07.295]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.283] result() for MulticoreFuture ...
[17:47:07.295]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.284] result() for MulticoreFuture ... done
[17:47:07.295]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.284] result() for MulticoreFuture ...
[17:47:07.295]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.284] result() for MulticoreFuture ... done
[17:47:07.295] signalConditions() ... done
value(b) = 2
[17:47:07.296] result() for MulticoreFuture ...
[17:47:07.296] result() for MulticoreFuture ... done
[17:47:07.296] result() for MulticoreFuture ...
[17:47:07.296] result() for MulticoreFuture ... done
[17:47:07.296] signalConditions() ...
[17:47:07.296]  - include = ‘immediateCondition’
[17:47:07.296]  - exclude = 
[17:47:07.296]  - resignal = FALSE
[17:47:07.296]  - Number of conditions: 4
[17:47:07.297] signalConditions() ... done
[17:47:07.297] Future state: ‘finished’
[17:47:07.297] result() for MulticoreFuture ...
[17:47:07.297] result() for MulticoreFuture ... done
[17:47:07.297] signalConditions() ...
[17:47:07.297]  - include = ‘condition’
[17:47:07.297]  - exclude = ‘immediateCondition’
[17:47:07.297]  - resignal = TRUE
[17:47:07.297]  - Number of conditions: 4
[17:47:07.298]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.283] result() for MulticoreFuture ...
[17:47:07.298]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.284] result() for MulticoreFuture ... done
[17:47:07.298]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.284] result() for MulticoreFuture ...
[17:47:07.298]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.284] result() for MulticoreFuture ... done
[17:47:07.298] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.298] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.301] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.302] 
[17:47:07.302] Searching for globals ... DONE
[17:47:07.303] - globals: [0] <none>
[17:47:07.303] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.303] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.304] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.305] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:07.305] Searching for globals ... DONE
[17:47:07.305] Resolving globals: TRUE
[17:47:07.305] Resolving any globals that are futures ...
[17:47:07.306] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:07.306] Resolving any globals that are futures ... DONE
[17:47:07.306] Resolving futures part of globals (recursively) ...
[17:47:07.306] resolve() on list ...
[17:47:07.307]  recursive: 99
[17:47:07.307]  length: 1
[17:47:07.307]  elements: ‘a’
[17:47:07.307] run() for ‘Future’ ...
[17:47:07.307] - state: ‘created’
[17:47:07.307] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.311] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.311]   - Field: ‘label’
[17:47:07.311]   - Field: ‘local’
[17:47:07.312]   - Field: ‘owner’
[17:47:07.312]   - Field: ‘envir’
[17:47:07.312]   - Field: ‘workers’
[17:47:07.312]   - Field: ‘packages’
[17:47:07.312]   - Field: ‘gc’
[17:47:07.312]   - Field: ‘job’
[17:47:07.312]   - Field: ‘conditions’
[17:47:07.312]   - Field: ‘expr’
[17:47:07.312]   - Field: ‘uuid’
[17:47:07.312]   - Field: ‘seed’
[17:47:07.313]   - Field: ‘version’
[17:47:07.313]   - Field: ‘result’
[17:47:07.313]   - Field: ‘asynchronous’
[17:47:07.313]   - Field: ‘calls’
[17:47:07.313]   - Field: ‘globals’
[17:47:07.313]   - Field: ‘stdout’
[17:47:07.313]   - Field: ‘earlySignal’
[17:47:07.313]   - Field: ‘lazy’
[17:47:07.313]   - Field: ‘state’
[17:47:07.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.314] - Launch lazy future ...
[17:47:07.314] Packages needed by the future expression (n = 0): <none>
[17:47:07.314] Packages needed by future strategies (n = 0): <none>
[17:47:07.315] {
[17:47:07.315]     {
[17:47:07.315]         {
[17:47:07.315]             ...future.startTime <- base::Sys.time()
[17:47:07.315]             {
[17:47:07.315]                 {
[17:47:07.315]                   {
[17:47:07.315]                     {
[17:47:07.315]                       base::local({
[17:47:07.315]                         has_future <- base::requireNamespace("future", 
[17:47:07.315]                           quietly = TRUE)
[17:47:07.315]                         if (has_future) {
[17:47:07.315]                           ns <- base::getNamespace("future")
[17:47:07.315]                           version <- ns[[".package"]][["version"]]
[17:47:07.315]                           if (is.null(version)) 
[17:47:07.315]                             version <- utils::packageVersion("future")
[17:47:07.315]                         }
[17:47:07.315]                         else {
[17:47:07.315]                           version <- NULL
[17:47:07.315]                         }
[17:47:07.315]                         if (!has_future || version < "1.8.0") {
[17:47:07.315]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.315]                             "", base::R.version$version.string), 
[17:47:07.315]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.315]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.315]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.315]                               "release", "version")], collapse = " "), 
[17:47:07.315]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.315]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.315]                             info)
[17:47:07.315]                           info <- base::paste(info, collapse = "; ")
[17:47:07.315]                           if (!has_future) {
[17:47:07.315]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.315]                               info)
[17:47:07.315]                           }
[17:47:07.315]                           else {
[17:47:07.315]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.315]                               info, version)
[17:47:07.315]                           }
[17:47:07.315]                           base::stop(msg)
[17:47:07.315]                         }
[17:47:07.315]                       })
[17:47:07.315]                     }
[17:47:07.315]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.315]                     base::options(mc.cores = 1L)
[17:47:07.315]                   }
[17:47:07.315]                   ...future.strategy.old <- future::plan("list")
[17:47:07.315]                   options(future.plan = NULL)
[17:47:07.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.315]                 }
[17:47:07.315]                 ...future.workdir <- getwd()
[17:47:07.315]             }
[17:47:07.315]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.315]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.315]         }
[17:47:07.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.315]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.315]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.315]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.315]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.315]             base::names(...future.oldOptions))
[17:47:07.315]     }
[17:47:07.315]     if (FALSE) {
[17:47:07.315]     }
[17:47:07.315]     else {
[17:47:07.315]         if (TRUE) {
[17:47:07.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.315]                 open = "w")
[17:47:07.315]         }
[17:47:07.315]         else {
[17:47:07.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.315]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.315]         }
[17:47:07.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.315]             base::sink(type = "output", split = FALSE)
[17:47:07.315]             base::close(...future.stdout)
[17:47:07.315]         }, add = TRUE)
[17:47:07.315]     }
[17:47:07.315]     ...future.frame <- base::sys.nframe()
[17:47:07.315]     ...future.conditions <- base::list()
[17:47:07.315]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.315]     if (FALSE) {
[17:47:07.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.315]     }
[17:47:07.315]     ...future.result <- base::tryCatch({
[17:47:07.315]         base::withCallingHandlers({
[17:47:07.315]             ...future.value <- base::withVisible(base::local({
[17:47:07.315]                 withCallingHandlers({
[17:47:07.315]                   1
[17:47:07.315]                 }, immediateCondition = function(cond) {
[17:47:07.315]                   save_rds <- function (object, pathname, ...) 
[17:47:07.315]                   {
[17:47:07.315]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.315]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.315]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.315]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.315]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.315]                         fi_tmp[["mtime"]])
[17:47:07.315]                     }
[17:47:07.315]                     tryCatch({
[17:47:07.315]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.315]                     }, error = function(ex) {
[17:47:07.315]                       msg <- conditionMessage(ex)
[17:47:07.315]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.315]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.315]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.315]                         fi_tmp[["mtime"]], msg)
[17:47:07.315]                       ex$message <- msg
[17:47:07.315]                       stop(ex)
[17:47:07.315]                     })
[17:47:07.315]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.315]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.315]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.315]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.315]                       fi <- file.info(pathname)
[17:47:07.315]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.315]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.315]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.315]                         fi[["size"]], fi[["mtime"]])
[17:47:07.315]                       stop(msg)
[17:47:07.315]                     }
[17:47:07.315]                     invisible(pathname)
[17:47:07.315]                   }
[17:47:07.315]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.315]                     rootPath = tempdir()) 
[17:47:07.315]                   {
[17:47:07.315]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.315]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.315]                       tmpdir = path, fileext = ".rds")
[17:47:07.315]                     save_rds(obj, file)
[17:47:07.315]                   }
[17:47:07.315]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.315]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.315]                   {
[17:47:07.315]                     inherits <- base::inherits
[17:47:07.315]                     invokeRestart <- base::invokeRestart
[17:47:07.315]                     is.null <- base::is.null
[17:47:07.315]                     muffled <- FALSE
[17:47:07.315]                     if (inherits(cond, "message")) {
[17:47:07.315]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.315]                       if (muffled) 
[17:47:07.315]                         invokeRestart("muffleMessage")
[17:47:07.315]                     }
[17:47:07.315]                     else if (inherits(cond, "warning")) {
[17:47:07.315]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.315]                       if (muffled) 
[17:47:07.315]                         invokeRestart("muffleWarning")
[17:47:07.315]                     }
[17:47:07.315]                     else if (inherits(cond, "condition")) {
[17:47:07.315]                       if (!is.null(pattern)) {
[17:47:07.315]                         computeRestarts <- base::computeRestarts
[17:47:07.315]                         grepl <- base::grepl
[17:47:07.315]                         restarts <- computeRestarts(cond)
[17:47:07.315]                         for (restart in restarts) {
[17:47:07.315]                           name <- restart$name
[17:47:07.315]                           if (is.null(name)) 
[17:47:07.315]                             next
[17:47:07.315]                           if (!grepl(pattern, name)) 
[17:47:07.315]                             next
[17:47:07.315]                           invokeRestart(restart)
[17:47:07.315]                           muffled <- TRUE
[17:47:07.315]                           break
[17:47:07.315]                         }
[17:47:07.315]                       }
[17:47:07.315]                     }
[17:47:07.315]                     invisible(muffled)
[17:47:07.315]                   }
[17:47:07.315]                   muffleCondition(cond)
[17:47:07.315]                 })
[17:47:07.315]             }))
[17:47:07.315]             future::FutureResult(value = ...future.value$value, 
[17:47:07.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.315]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.315]                     ...future.globalenv.names))
[17:47:07.315]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.315]         }, condition = base::local({
[17:47:07.315]             c <- base::c
[17:47:07.315]             inherits <- base::inherits
[17:47:07.315]             invokeRestart <- base::invokeRestart
[17:47:07.315]             length <- base::length
[17:47:07.315]             list <- base::list
[17:47:07.315]             seq.int <- base::seq.int
[17:47:07.315]             signalCondition <- base::signalCondition
[17:47:07.315]             sys.calls <- base::sys.calls
[17:47:07.315]             `[[` <- base::`[[`
[17:47:07.315]             `+` <- base::`+`
[17:47:07.315]             `<<-` <- base::`<<-`
[17:47:07.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.315]                   3L)]
[17:47:07.315]             }
[17:47:07.315]             function(cond) {
[17:47:07.315]                 is_error <- inherits(cond, "error")
[17:47:07.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.315]                   NULL)
[17:47:07.315]                 if (is_error) {
[17:47:07.315]                   sessionInformation <- function() {
[17:47:07.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.315]                       search = base::search(), system = base::Sys.info())
[17:47:07.315]                   }
[17:47:07.315]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.315]                     cond$call), session = sessionInformation(), 
[17:47:07.315]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.315]                   signalCondition(cond)
[17:47:07.315]                 }
[17:47:07.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.315]                 "immediateCondition"))) {
[17:47:07.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.315]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.315]                   if (TRUE && !signal) {
[17:47:07.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.315]                     {
[17:47:07.315]                       inherits <- base::inherits
[17:47:07.315]                       invokeRestart <- base::invokeRestart
[17:47:07.315]                       is.null <- base::is.null
[17:47:07.315]                       muffled <- FALSE
[17:47:07.315]                       if (inherits(cond, "message")) {
[17:47:07.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.315]                         if (muffled) 
[17:47:07.315]                           invokeRestart("muffleMessage")
[17:47:07.315]                       }
[17:47:07.315]                       else if (inherits(cond, "warning")) {
[17:47:07.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.315]                         if (muffled) 
[17:47:07.315]                           invokeRestart("muffleWarning")
[17:47:07.315]                       }
[17:47:07.315]                       else if (inherits(cond, "condition")) {
[17:47:07.315]                         if (!is.null(pattern)) {
[17:47:07.315]                           computeRestarts <- base::computeRestarts
[17:47:07.315]                           grepl <- base::grepl
[17:47:07.315]                           restarts <- computeRestarts(cond)
[17:47:07.315]                           for (restart in restarts) {
[17:47:07.315]                             name <- restart$name
[17:47:07.315]                             if (is.null(name)) 
[17:47:07.315]                               next
[17:47:07.315]                             if (!grepl(pattern, name)) 
[17:47:07.315]                               next
[17:47:07.315]                             invokeRestart(restart)
[17:47:07.315]                             muffled <- TRUE
[17:47:07.315]                             break
[17:47:07.315]                           }
[17:47:07.315]                         }
[17:47:07.315]                       }
[17:47:07.315]                       invisible(muffled)
[17:47:07.315]                     }
[17:47:07.315]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.315]                   }
[17:47:07.315]                 }
[17:47:07.315]                 else {
[17:47:07.315]                   if (TRUE) {
[17:47:07.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.315]                     {
[17:47:07.315]                       inherits <- base::inherits
[17:47:07.315]                       invokeRestart <- base::invokeRestart
[17:47:07.315]                       is.null <- base::is.null
[17:47:07.315]                       muffled <- FALSE
[17:47:07.315]                       if (inherits(cond, "message")) {
[17:47:07.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.315]                         if (muffled) 
[17:47:07.315]                           invokeRestart("muffleMessage")
[17:47:07.315]                       }
[17:47:07.315]                       else if (inherits(cond, "warning")) {
[17:47:07.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.315]                         if (muffled) 
[17:47:07.315]                           invokeRestart("muffleWarning")
[17:47:07.315]                       }
[17:47:07.315]                       else if (inherits(cond, "condition")) {
[17:47:07.315]                         if (!is.null(pattern)) {
[17:47:07.315]                           computeRestarts <- base::computeRestarts
[17:47:07.315]                           grepl <- base::grepl
[17:47:07.315]                           restarts <- computeRestarts(cond)
[17:47:07.315]                           for (restart in restarts) {
[17:47:07.315]                             name <- restart$name
[17:47:07.315]                             if (is.null(name)) 
[17:47:07.315]                               next
[17:47:07.315]                             if (!grepl(pattern, name)) 
[17:47:07.315]                               next
[17:47:07.315]                             invokeRestart(restart)
[17:47:07.315]                             muffled <- TRUE
[17:47:07.315]                             break
[17:47:07.315]                           }
[17:47:07.315]                         }
[17:47:07.315]                       }
[17:47:07.315]                       invisible(muffled)
[17:47:07.315]                     }
[17:47:07.315]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.315]                   }
[17:47:07.315]                 }
[17:47:07.315]             }
[17:47:07.315]         }))
[17:47:07.315]     }, error = function(ex) {
[17:47:07.315]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.315]                 ...future.rng), started = ...future.startTime, 
[17:47:07.315]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.315]             version = "1.8"), class = "FutureResult")
[17:47:07.315]     }, finally = {
[17:47:07.315]         if (!identical(...future.workdir, getwd())) 
[17:47:07.315]             setwd(...future.workdir)
[17:47:07.315]         {
[17:47:07.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.315]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.315]             }
[17:47:07.315]             base::options(...future.oldOptions)
[17:47:07.315]             if (.Platform$OS.type == "windows") {
[17:47:07.315]                 old_names <- names(...future.oldEnvVars)
[17:47:07.315]                 envs <- base::Sys.getenv()
[17:47:07.315]                 names <- names(envs)
[17:47:07.315]                 common <- intersect(names, old_names)
[17:47:07.315]                 added <- setdiff(names, old_names)
[17:47:07.315]                 removed <- setdiff(old_names, names)
[17:47:07.315]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.315]                   envs[common]]
[17:47:07.315]                 NAMES <- toupper(changed)
[17:47:07.315]                 args <- list()
[17:47:07.315]                 for (kk in seq_along(NAMES)) {
[17:47:07.315]                   name <- changed[[kk]]
[17:47:07.315]                   NAME <- NAMES[[kk]]
[17:47:07.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.315]                     next
[17:47:07.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.315]                 }
[17:47:07.315]                 NAMES <- toupper(added)
[17:47:07.315]                 for (kk in seq_along(NAMES)) {
[17:47:07.315]                   name <- added[[kk]]
[17:47:07.315]                   NAME <- NAMES[[kk]]
[17:47:07.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.315]                     next
[17:47:07.315]                   args[[name]] <- ""
[17:47:07.315]                 }
[17:47:07.315]                 NAMES <- toupper(removed)
[17:47:07.315]                 for (kk in seq_along(NAMES)) {
[17:47:07.315]                   name <- removed[[kk]]
[17:47:07.315]                   NAME <- NAMES[[kk]]
[17:47:07.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.315]                     next
[17:47:07.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.315]                 }
[17:47:07.315]                 if (length(args) > 0) 
[17:47:07.315]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.315]             }
[17:47:07.315]             else {
[17:47:07.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.315]             }
[17:47:07.315]             {
[17:47:07.315]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.315]                   0L) {
[17:47:07.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.315]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.315]                   base::options(opts)
[17:47:07.315]                 }
[17:47:07.315]                 {
[17:47:07.315]                   {
[17:47:07.315]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.315]                     NULL
[17:47:07.315]                   }
[17:47:07.315]                   options(future.plan = NULL)
[17:47:07.315]                   if (is.na(NA_character_)) 
[17:47:07.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.315]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.315]                     .init = FALSE)
[17:47:07.315]                 }
[17:47:07.315]             }
[17:47:07.315]         }
[17:47:07.315]     })
[17:47:07.315]     if (TRUE) {
[17:47:07.315]         base::sink(type = "output", split = FALSE)
[17:47:07.315]         if (TRUE) {
[17:47:07.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.315]         }
[17:47:07.315]         else {
[17:47:07.315]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.315]         }
[17:47:07.315]         base::close(...future.stdout)
[17:47:07.315]         ...future.stdout <- NULL
[17:47:07.315]     }
[17:47:07.315]     ...future.result$conditions <- ...future.conditions
[17:47:07.315]     ...future.result$finished <- base::Sys.time()
[17:47:07.315]     ...future.result
[17:47:07.315] }
[17:47:07.317] requestCore(): workers = 2
[17:47:07.319] MulticoreFuture started
[17:47:07.319] - Launch lazy future ... done
[17:47:07.319] run() for ‘MulticoreFuture’ ... done
[17:47:07.320] plan(): Setting new future strategy stack:
[17:47:07.320] List of future strategies:
[17:47:07.320] 1. sequential:
[17:47:07.320]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.320]    - tweaked: FALSE
[17:47:07.320]    - call: NULL
[17:47:07.321] plan(): nbrOfWorkers() = 1
[17:47:07.323] plan(): Setting new future strategy stack:
[17:47:07.323] List of future strategies:
[17:47:07.323] 1. multicore:
[17:47:07.323]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.323]    - tweaked: FALSE
[17:47:07.323]    - call: plan(strategy)
[17:47:07.328] plan(): nbrOfWorkers() = 2
[17:47:07.329] Future #1
[17:47:07.329] result() for MulticoreFuture ...
[17:47:07.330] result() for MulticoreFuture ...
[17:47:07.331] result() for MulticoreFuture ... done
[17:47:07.331] result() for MulticoreFuture ... done
[17:47:07.331] result() for MulticoreFuture ...
[17:47:07.331] result() for MulticoreFuture ... done
[17:47:07.331] A MulticoreFuture was resolved
[17:47:07.331]  length: 0 (resolved future 1)
[17:47:07.331] resolve() on list ... DONE
[17:47:07.332] - globals: [1] ‘a’
[17:47:07.332] Resolving futures part of globals (recursively) ... DONE
[17:47:07.333] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[17:47:07.334] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[17:47:07.334] - globals: [1] ‘a’
[17:47:07.334] - packages: [1] ‘future’
[17:47:07.334] getGlobalsAndPackages() ... DONE
[17:47:07.335] run() for ‘Future’ ...
[17:47:07.335] - state: ‘created’
[17:47:07.335] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.339] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.339] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.339]   - Field: ‘label’
[17:47:07.339]   - Field: ‘local’
[17:47:07.339]   - Field: ‘owner’
[17:47:07.339]   - Field: ‘envir’
[17:47:07.340]   - Field: ‘workers’
[17:47:07.340]   - Field: ‘packages’
[17:47:07.340]   - Field: ‘gc’
[17:47:07.340]   - Field: ‘job’
[17:47:07.340]   - Field: ‘conditions’
[17:47:07.340]   - Field: ‘expr’
[17:47:07.340]   - Field: ‘uuid’
[17:47:07.340]   - Field: ‘seed’
[17:47:07.341]   - Field: ‘version’
[17:47:07.341]   - Field: ‘result’
[17:47:07.341]   - Field: ‘asynchronous’
[17:47:07.341]   - Field: ‘calls’
[17:47:07.341]   - Field: ‘globals’
[17:47:07.341]   - Field: ‘stdout’
[17:47:07.341]   - Field: ‘earlySignal’
[17:47:07.341]   - Field: ‘lazy’
[17:47:07.341]   - Field: ‘state’
[17:47:07.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.342] - Launch lazy future ...
[17:47:07.342] Packages needed by the future expression (n = 1): ‘future’
[17:47:07.342] Packages needed by future strategies (n = 0): <none>
[17:47:07.343] {
[17:47:07.343]     {
[17:47:07.343]         {
[17:47:07.343]             ...future.startTime <- base::Sys.time()
[17:47:07.343]             {
[17:47:07.343]                 {
[17:47:07.343]                   {
[17:47:07.343]                     {
[17:47:07.343]                       {
[17:47:07.343]                         base::local({
[17:47:07.343]                           has_future <- base::requireNamespace("future", 
[17:47:07.343]                             quietly = TRUE)
[17:47:07.343]                           if (has_future) {
[17:47:07.343]                             ns <- base::getNamespace("future")
[17:47:07.343]                             version <- ns[[".package"]][["version"]]
[17:47:07.343]                             if (is.null(version)) 
[17:47:07.343]                               version <- utils::packageVersion("future")
[17:47:07.343]                           }
[17:47:07.343]                           else {
[17:47:07.343]                             version <- NULL
[17:47:07.343]                           }
[17:47:07.343]                           if (!has_future || version < "1.8.0") {
[17:47:07.343]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.343]                               "", base::R.version$version.string), 
[17:47:07.343]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:07.343]                                 base::R.version$platform, 8 * 
[17:47:07.343]                                   base::.Machine$sizeof.pointer), 
[17:47:07.343]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.343]                                 "release", "version")], collapse = " "), 
[17:47:07.343]                               hostname = base::Sys.info()[["nodename"]])
[17:47:07.343]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.343]                               info)
[17:47:07.343]                             info <- base::paste(info, collapse = "; ")
[17:47:07.343]                             if (!has_future) {
[17:47:07.343]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.343]                                 info)
[17:47:07.343]                             }
[17:47:07.343]                             else {
[17:47:07.343]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.343]                                 info, version)
[17:47:07.343]                             }
[17:47:07.343]                             base::stop(msg)
[17:47:07.343]                           }
[17:47:07.343]                         })
[17:47:07.343]                       }
[17:47:07.343]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.343]                       base::options(mc.cores = 1L)
[17:47:07.343]                     }
[17:47:07.343]                     base::local({
[17:47:07.343]                       for (pkg in "future") {
[17:47:07.343]                         base::loadNamespace(pkg)
[17:47:07.343]                         base::library(pkg, character.only = TRUE)
[17:47:07.343]                       }
[17:47:07.343]                     })
[17:47:07.343]                   }
[17:47:07.343]                   ...future.strategy.old <- future::plan("list")
[17:47:07.343]                   options(future.plan = NULL)
[17:47:07.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.343]                 }
[17:47:07.343]                 ...future.workdir <- getwd()
[17:47:07.343]             }
[17:47:07.343]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.343]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.343]         }
[17:47:07.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.343]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.343]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.343]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.343]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.343]             base::names(...future.oldOptions))
[17:47:07.343]     }
[17:47:07.343]     if (FALSE) {
[17:47:07.343]     }
[17:47:07.343]     else {
[17:47:07.343]         if (TRUE) {
[17:47:07.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.343]                 open = "w")
[17:47:07.343]         }
[17:47:07.343]         else {
[17:47:07.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.343]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.343]         }
[17:47:07.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.343]             base::sink(type = "output", split = FALSE)
[17:47:07.343]             base::close(...future.stdout)
[17:47:07.343]         }, add = TRUE)
[17:47:07.343]     }
[17:47:07.343]     ...future.frame <- base::sys.nframe()
[17:47:07.343]     ...future.conditions <- base::list()
[17:47:07.343]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.343]     if (FALSE) {
[17:47:07.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.343]     }
[17:47:07.343]     ...future.result <- base::tryCatch({
[17:47:07.343]         base::withCallingHandlers({
[17:47:07.343]             ...future.value <- base::withVisible(base::local({
[17:47:07.343]                 withCallingHandlers({
[17:47:07.343]                   value(a) + 1
[17:47:07.343]                 }, immediateCondition = function(cond) {
[17:47:07.343]                   save_rds <- function (object, pathname, ...) 
[17:47:07.343]                   {
[17:47:07.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.343]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.343]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.343]                         fi_tmp[["mtime"]])
[17:47:07.343]                     }
[17:47:07.343]                     tryCatch({
[17:47:07.343]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.343]                     }, error = function(ex) {
[17:47:07.343]                       msg <- conditionMessage(ex)
[17:47:07.343]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.343]                         fi_tmp[["mtime"]], msg)
[17:47:07.343]                       ex$message <- msg
[17:47:07.343]                       stop(ex)
[17:47:07.343]                     })
[17:47:07.343]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.343]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.343]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.343]                       fi <- file.info(pathname)
[17:47:07.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.343]                         fi[["size"]], fi[["mtime"]])
[17:47:07.343]                       stop(msg)
[17:47:07.343]                     }
[17:47:07.343]                     invisible(pathname)
[17:47:07.343]                   }
[17:47:07.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.343]                     rootPath = tempdir()) 
[17:47:07.343]                   {
[17:47:07.343]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.343]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.343]                       tmpdir = path, fileext = ".rds")
[17:47:07.343]                     save_rds(obj, file)
[17:47:07.343]                   }
[17:47:07.343]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.343]                   {
[17:47:07.343]                     inherits <- base::inherits
[17:47:07.343]                     invokeRestart <- base::invokeRestart
[17:47:07.343]                     is.null <- base::is.null
[17:47:07.343]                     muffled <- FALSE
[17:47:07.343]                     if (inherits(cond, "message")) {
[17:47:07.343]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.343]                       if (muffled) 
[17:47:07.343]                         invokeRestart("muffleMessage")
[17:47:07.343]                     }
[17:47:07.343]                     else if (inherits(cond, "warning")) {
[17:47:07.343]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.343]                       if (muffled) 
[17:47:07.343]                         invokeRestart("muffleWarning")
[17:47:07.343]                     }
[17:47:07.343]                     else if (inherits(cond, "condition")) {
[17:47:07.343]                       if (!is.null(pattern)) {
[17:47:07.343]                         computeRestarts <- base::computeRestarts
[17:47:07.343]                         grepl <- base::grepl
[17:47:07.343]                         restarts <- computeRestarts(cond)
[17:47:07.343]                         for (restart in restarts) {
[17:47:07.343]                           name <- restart$name
[17:47:07.343]                           if (is.null(name)) 
[17:47:07.343]                             next
[17:47:07.343]                           if (!grepl(pattern, name)) 
[17:47:07.343]                             next
[17:47:07.343]                           invokeRestart(restart)
[17:47:07.343]                           muffled <- TRUE
[17:47:07.343]                           break
[17:47:07.343]                         }
[17:47:07.343]                       }
[17:47:07.343]                     }
[17:47:07.343]                     invisible(muffled)
[17:47:07.343]                   }
[17:47:07.343]                   muffleCondition(cond)
[17:47:07.343]                 })
[17:47:07.343]             }))
[17:47:07.343]             future::FutureResult(value = ...future.value$value, 
[17:47:07.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.343]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.343]                     ...future.globalenv.names))
[17:47:07.343]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.343]         }, condition = base::local({
[17:47:07.343]             c <- base::c
[17:47:07.343]             inherits <- base::inherits
[17:47:07.343]             invokeRestart <- base::invokeRestart
[17:47:07.343]             length <- base::length
[17:47:07.343]             list <- base::list
[17:47:07.343]             seq.int <- base::seq.int
[17:47:07.343]             signalCondition <- base::signalCondition
[17:47:07.343]             sys.calls <- base::sys.calls
[17:47:07.343]             `[[` <- base::`[[`
[17:47:07.343]             `+` <- base::`+`
[17:47:07.343]             `<<-` <- base::`<<-`
[17:47:07.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.343]                   3L)]
[17:47:07.343]             }
[17:47:07.343]             function(cond) {
[17:47:07.343]                 is_error <- inherits(cond, "error")
[17:47:07.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.343]                   NULL)
[17:47:07.343]                 if (is_error) {
[17:47:07.343]                   sessionInformation <- function() {
[17:47:07.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.343]                       search = base::search(), system = base::Sys.info())
[17:47:07.343]                   }
[17:47:07.343]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.343]                     cond$call), session = sessionInformation(), 
[17:47:07.343]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.343]                   signalCondition(cond)
[17:47:07.343]                 }
[17:47:07.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.343]                 "immediateCondition"))) {
[17:47:07.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.343]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.343]                   if (TRUE && !signal) {
[17:47:07.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.343]                     {
[17:47:07.343]                       inherits <- base::inherits
[17:47:07.343]                       invokeRestart <- base::invokeRestart
[17:47:07.343]                       is.null <- base::is.null
[17:47:07.343]                       muffled <- FALSE
[17:47:07.343]                       if (inherits(cond, "message")) {
[17:47:07.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.343]                         if (muffled) 
[17:47:07.343]                           invokeRestart("muffleMessage")
[17:47:07.343]                       }
[17:47:07.343]                       else if (inherits(cond, "warning")) {
[17:47:07.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.343]                         if (muffled) 
[17:47:07.343]                           invokeRestart("muffleWarning")
[17:47:07.343]                       }
[17:47:07.343]                       else if (inherits(cond, "condition")) {
[17:47:07.343]                         if (!is.null(pattern)) {
[17:47:07.343]                           computeRestarts <- base::computeRestarts
[17:47:07.343]                           grepl <- base::grepl
[17:47:07.343]                           restarts <- computeRestarts(cond)
[17:47:07.343]                           for (restart in restarts) {
[17:47:07.343]                             name <- restart$name
[17:47:07.343]                             if (is.null(name)) 
[17:47:07.343]                               next
[17:47:07.343]                             if (!grepl(pattern, name)) 
[17:47:07.343]                               next
[17:47:07.343]                             invokeRestart(restart)
[17:47:07.343]                             muffled <- TRUE
[17:47:07.343]                             break
[17:47:07.343]                           }
[17:47:07.343]                         }
[17:47:07.343]                       }
[17:47:07.343]                       invisible(muffled)
[17:47:07.343]                     }
[17:47:07.343]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.343]                   }
[17:47:07.343]                 }
[17:47:07.343]                 else {
[17:47:07.343]                   if (TRUE) {
[17:47:07.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.343]                     {
[17:47:07.343]                       inherits <- base::inherits
[17:47:07.343]                       invokeRestart <- base::invokeRestart
[17:47:07.343]                       is.null <- base::is.null
[17:47:07.343]                       muffled <- FALSE
[17:47:07.343]                       if (inherits(cond, "message")) {
[17:47:07.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.343]                         if (muffled) 
[17:47:07.343]                           invokeRestart("muffleMessage")
[17:47:07.343]                       }
[17:47:07.343]                       else if (inherits(cond, "warning")) {
[17:47:07.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.343]                         if (muffled) 
[17:47:07.343]                           invokeRestart("muffleWarning")
[17:47:07.343]                       }
[17:47:07.343]                       else if (inherits(cond, "condition")) {
[17:47:07.343]                         if (!is.null(pattern)) {
[17:47:07.343]                           computeRestarts <- base::computeRestarts
[17:47:07.343]                           grepl <- base::grepl
[17:47:07.343]                           restarts <- computeRestarts(cond)
[17:47:07.343]                           for (restart in restarts) {
[17:47:07.343]                             name <- restart$name
[17:47:07.343]                             if (is.null(name)) 
[17:47:07.343]                               next
[17:47:07.343]                             if (!grepl(pattern, name)) 
[17:47:07.343]                               next
[17:47:07.343]                             invokeRestart(restart)
[17:47:07.343]                             muffled <- TRUE
[17:47:07.343]                             break
[17:47:07.343]                           }
[17:47:07.343]                         }
[17:47:07.343]                       }
[17:47:07.343]                       invisible(muffled)
[17:47:07.343]                     }
[17:47:07.343]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.343]                   }
[17:47:07.343]                 }
[17:47:07.343]             }
[17:47:07.343]         }))
[17:47:07.343]     }, error = function(ex) {
[17:47:07.343]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.343]                 ...future.rng), started = ...future.startTime, 
[17:47:07.343]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.343]             version = "1.8"), class = "FutureResult")
[17:47:07.343]     }, finally = {
[17:47:07.343]         if (!identical(...future.workdir, getwd())) 
[17:47:07.343]             setwd(...future.workdir)
[17:47:07.343]         {
[17:47:07.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.343]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.343]             }
[17:47:07.343]             base::options(...future.oldOptions)
[17:47:07.343]             if (.Platform$OS.type == "windows") {
[17:47:07.343]                 old_names <- names(...future.oldEnvVars)
[17:47:07.343]                 envs <- base::Sys.getenv()
[17:47:07.343]                 names <- names(envs)
[17:47:07.343]                 common <- intersect(names, old_names)
[17:47:07.343]                 added <- setdiff(names, old_names)
[17:47:07.343]                 removed <- setdiff(old_names, names)
[17:47:07.343]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.343]                   envs[common]]
[17:47:07.343]                 NAMES <- toupper(changed)
[17:47:07.343]                 args <- list()
[17:47:07.343]                 for (kk in seq_along(NAMES)) {
[17:47:07.343]                   name <- changed[[kk]]
[17:47:07.343]                   NAME <- NAMES[[kk]]
[17:47:07.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.343]                     next
[17:47:07.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.343]                 }
[17:47:07.343]                 NAMES <- toupper(added)
[17:47:07.343]                 for (kk in seq_along(NAMES)) {
[17:47:07.343]                   name <- added[[kk]]
[17:47:07.343]                   NAME <- NAMES[[kk]]
[17:47:07.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.343]                     next
[17:47:07.343]                   args[[name]] <- ""
[17:47:07.343]                 }
[17:47:07.343]                 NAMES <- toupper(removed)
[17:47:07.343]                 for (kk in seq_along(NAMES)) {
[17:47:07.343]                   name <- removed[[kk]]
[17:47:07.343]                   NAME <- NAMES[[kk]]
[17:47:07.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.343]                     next
[17:47:07.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.343]                 }
[17:47:07.343]                 if (length(args) > 0) 
[17:47:07.343]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.343]             }
[17:47:07.343]             else {
[17:47:07.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.343]             }
[17:47:07.343]             {
[17:47:07.343]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.343]                   0L) {
[17:47:07.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.343]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.343]                   base::options(opts)
[17:47:07.343]                 }
[17:47:07.343]                 {
[17:47:07.343]                   {
[17:47:07.343]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.343]                     NULL
[17:47:07.343]                   }
[17:47:07.343]                   options(future.plan = NULL)
[17:47:07.343]                   if (is.na(NA_character_)) 
[17:47:07.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.343]                     .init = FALSE)
[17:47:07.343]                 }
[17:47:07.343]             }
[17:47:07.343]         }
[17:47:07.343]     })
[17:47:07.343]     if (TRUE) {
[17:47:07.343]         base::sink(type = "output", split = FALSE)
[17:47:07.343]         if (TRUE) {
[17:47:07.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.343]         }
[17:47:07.343]         else {
[17:47:07.343]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.343]         }
[17:47:07.343]         base::close(...future.stdout)
[17:47:07.343]         ...future.stdout <- NULL
[17:47:07.343]     }
[17:47:07.343]     ...future.result$conditions <- ...future.conditions
[17:47:07.343]     ...future.result$finished <- base::Sys.time()
[17:47:07.343]     ...future.result
[17:47:07.343] }
[17:47:07.345] assign_globals() ...
[17:47:07.346] List of 1
[17:47:07.346]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558b32e47b08> 
[17:47:07.346]  - attr(*, "where")=List of 1
[17:47:07.346]   ..$ a:<environment: R_EmptyEnv> 
[17:47:07.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.346]  - attr(*, "resolved")= logi TRUE
[17:47:07.346]  - attr(*, "total_size")= num 10984
[17:47:07.346]  - attr(*, "already-done")= logi TRUE
[17:47:07.351] - copied ‘a’ to environment
[17:47:07.352] assign_globals() ... done
[17:47:07.352] requestCore(): workers = 2
[17:47:07.354] MulticoreFuture started
[17:47:07.355] - Launch lazy future ... done
[17:47:07.355] run() for ‘MulticoreFuture’ ... done
[17:47:07.355] result() for MulticoreFuture ...
[17:47:07.355] plan(): Setting new future strategy stack:
[17:47:07.356] List of future strategies:
[17:47:07.356] 1. sequential:
[17:47:07.356]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.356]    - tweaked: FALSE
[17:47:07.356]    - call: NULL
[17:47:07.357] plan(): nbrOfWorkers() = 1
[17:47:07.361] plan(): Setting new future strategy stack:
[17:47:07.361] List of future strategies:
[17:47:07.361] 1. multicore:
[17:47:07.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.361]    - tweaked: FALSE
[17:47:07.361]    - call: plan(strategy)
[17:47:07.366] plan(): nbrOfWorkers() = 2
[17:47:07.367] result() for MulticoreFuture ...
[17:47:07.367] result() for MulticoreFuture ... done
[17:47:07.367] signalConditions() ...
[17:47:07.367]  - include = ‘immediateCondition’
[17:47:07.368]  - exclude = 
[17:47:07.368]  - resignal = FALSE
[17:47:07.368]  - Number of conditions: 4
[17:47:07.368] signalConditions() ... done
[17:47:07.368] result() for MulticoreFuture ... done
[17:47:07.368] result() for MulticoreFuture ...
[17:47:07.369] result() for MulticoreFuture ... done
[17:47:07.369] signalConditions() ...
[17:47:07.369]  - include = ‘immediateCondition’
[17:47:07.369]  - exclude = 
[17:47:07.369]  - resignal = FALSE
[17:47:07.369]  - Number of conditions: 4
[17:47:07.369] signalConditions() ... done
[17:47:07.370] Future state: ‘finished’
[17:47:07.370] result() for MulticoreFuture ...
[17:47:07.370] result() for MulticoreFuture ... done
[17:47:07.370] signalConditions() ...
[17:47:07.370]  - include = ‘condition’
[17:47:07.370]  - exclude = ‘immediateCondition’
[17:47:07.370]  - resignal = TRUE
[17:47:07.370]  - Number of conditions: 4
[17:47:07.371]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.358] result() for MulticoreFuture ...
[17:47:07.371]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.359] result() for MulticoreFuture ... done
[17:47:07.371]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.359] result() for MulticoreFuture ...
[17:47:07.371]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.359] result() for MulticoreFuture ... done
[17:47:07.371] signalConditions() ... done
value(b) = 2
[17:47:07.372] result() for MulticoreFuture ...
[17:47:07.372] result() for MulticoreFuture ... done
[17:47:07.372] result() for MulticoreFuture ...
[17:47:07.372] result() for MulticoreFuture ... done
[17:47:07.372] signalConditions() ...
[17:47:07.372]  - include = ‘immediateCondition’
[17:47:07.372]  - exclude = 
[17:47:07.372]  - resignal = FALSE
[17:47:07.372]  - Number of conditions: 4
[17:47:07.373] signalConditions() ... done
[17:47:07.373] Future state: ‘finished’
[17:47:07.373] result() for MulticoreFuture ...
[17:47:07.373] result() for MulticoreFuture ... done
[17:47:07.373] signalConditions() ...
[17:47:07.373]  - include = ‘condition’
[17:47:07.373]  - exclude = ‘immediateCondition’
[17:47:07.373]  - resignal = TRUE
[17:47:07.373]  - Number of conditions: 4
[17:47:07.374]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.358] result() for MulticoreFuture ...
[17:47:07.374]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.359] result() for MulticoreFuture ... done
[17:47:07.374]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.359] result() for MulticoreFuture ...
[17:47:07.374]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.359] result() for MulticoreFuture ... done
[17:47:07.374] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.375] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.375] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.375] 
[17:47:07.376] Searching for globals ... DONE
[17:47:07.376] - globals: [0] <none>
[17:47:07.376] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.376] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.377] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.378] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:07.378] Searching for globals ... DONE
[17:47:07.378] Resolving globals: TRUE
[17:47:07.378] Resolving any globals that are futures ...
[17:47:07.378] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:07.378] Resolving any globals that are futures ... DONE
[17:47:07.379] Resolving futures part of globals (recursively) ...
[17:47:07.379] resolve() on list ...
[17:47:07.379]  recursive: 99
[17:47:07.379]  length: 1
[17:47:07.379]  elements: ‘a’
[17:47:07.379] run() for ‘Future’ ...
[17:47:07.380] - state: ‘created’
[17:47:07.380] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.384] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.384]   - Field: ‘label’
[17:47:07.384]   - Field: ‘local’
[17:47:07.384]   - Field: ‘owner’
[17:47:07.384]   - Field: ‘envir’
[17:47:07.384]   - Field: ‘workers’
[17:47:07.385]   - Field: ‘packages’
[17:47:07.385]   - Field: ‘gc’
[17:47:07.385]   - Field: ‘job’
[17:47:07.385]   - Field: ‘conditions’
[17:47:07.385]   - Field: ‘expr’
[17:47:07.385]   - Field: ‘uuid’
[17:47:07.385]   - Field: ‘seed’
[17:47:07.385]   - Field: ‘version’
[17:47:07.385]   - Field: ‘result’
[17:47:07.386]   - Field: ‘asynchronous’
[17:47:07.386]   - Field: ‘calls’
[17:47:07.386]   - Field: ‘globals’
[17:47:07.386]   - Field: ‘stdout’
[17:47:07.386]   - Field: ‘earlySignal’
[17:47:07.386]   - Field: ‘lazy’
[17:47:07.386]   - Field: ‘state’
[17:47:07.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.386] - Launch lazy future ...
[17:47:07.387] Packages needed by the future expression (n = 0): <none>
[17:47:07.387] Packages needed by future strategies (n = 0): <none>
[17:47:07.387] {
[17:47:07.387]     {
[17:47:07.387]         {
[17:47:07.387]             ...future.startTime <- base::Sys.time()
[17:47:07.387]             {
[17:47:07.387]                 {
[17:47:07.387]                   {
[17:47:07.387]                     {
[17:47:07.387]                       base::local({
[17:47:07.387]                         has_future <- base::requireNamespace("future", 
[17:47:07.387]                           quietly = TRUE)
[17:47:07.387]                         if (has_future) {
[17:47:07.387]                           ns <- base::getNamespace("future")
[17:47:07.387]                           version <- ns[[".package"]][["version"]]
[17:47:07.387]                           if (is.null(version)) 
[17:47:07.387]                             version <- utils::packageVersion("future")
[17:47:07.387]                         }
[17:47:07.387]                         else {
[17:47:07.387]                           version <- NULL
[17:47:07.387]                         }
[17:47:07.387]                         if (!has_future || version < "1.8.0") {
[17:47:07.387]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.387]                             "", base::R.version$version.string), 
[17:47:07.387]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.387]                               "release", "version")], collapse = " "), 
[17:47:07.387]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.387]                             info)
[17:47:07.387]                           info <- base::paste(info, collapse = "; ")
[17:47:07.387]                           if (!has_future) {
[17:47:07.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.387]                               info)
[17:47:07.387]                           }
[17:47:07.387]                           else {
[17:47:07.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.387]                               info, version)
[17:47:07.387]                           }
[17:47:07.387]                           base::stop(msg)
[17:47:07.387]                         }
[17:47:07.387]                       })
[17:47:07.387]                     }
[17:47:07.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.387]                     base::options(mc.cores = 1L)
[17:47:07.387]                   }
[17:47:07.387]                   ...future.strategy.old <- future::plan("list")
[17:47:07.387]                   options(future.plan = NULL)
[17:47:07.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.387]                 }
[17:47:07.387]                 ...future.workdir <- getwd()
[17:47:07.387]             }
[17:47:07.387]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.387]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.387]         }
[17:47:07.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.387]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.387]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.387]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.387]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.387]             base::names(...future.oldOptions))
[17:47:07.387]     }
[17:47:07.387]     if (FALSE) {
[17:47:07.387]     }
[17:47:07.387]     else {
[17:47:07.387]         if (TRUE) {
[17:47:07.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.387]                 open = "w")
[17:47:07.387]         }
[17:47:07.387]         else {
[17:47:07.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.387]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.387]         }
[17:47:07.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.387]             base::sink(type = "output", split = FALSE)
[17:47:07.387]             base::close(...future.stdout)
[17:47:07.387]         }, add = TRUE)
[17:47:07.387]     }
[17:47:07.387]     ...future.frame <- base::sys.nframe()
[17:47:07.387]     ...future.conditions <- base::list()
[17:47:07.387]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.387]     if (FALSE) {
[17:47:07.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.387]     }
[17:47:07.387]     ...future.result <- base::tryCatch({
[17:47:07.387]         base::withCallingHandlers({
[17:47:07.387]             ...future.value <- base::withVisible(base::local({
[17:47:07.387]                 withCallingHandlers({
[17:47:07.387]                   1
[17:47:07.387]                 }, immediateCondition = function(cond) {
[17:47:07.387]                   save_rds <- function (object, pathname, ...) 
[17:47:07.387]                   {
[17:47:07.387]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.387]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.387]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.387]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.387]                         fi_tmp[["mtime"]])
[17:47:07.387]                     }
[17:47:07.387]                     tryCatch({
[17:47:07.387]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.387]                     }, error = function(ex) {
[17:47:07.387]                       msg <- conditionMessage(ex)
[17:47:07.387]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.387]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.387]                         fi_tmp[["mtime"]], msg)
[17:47:07.387]                       ex$message <- msg
[17:47:07.387]                       stop(ex)
[17:47:07.387]                     })
[17:47:07.387]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.387]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.387]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.387]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.387]                       fi <- file.info(pathname)
[17:47:07.387]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.387]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.387]                         fi[["size"]], fi[["mtime"]])
[17:47:07.387]                       stop(msg)
[17:47:07.387]                     }
[17:47:07.387]                     invisible(pathname)
[17:47:07.387]                   }
[17:47:07.387]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.387]                     rootPath = tempdir()) 
[17:47:07.387]                   {
[17:47:07.387]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.387]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.387]                       tmpdir = path, fileext = ".rds")
[17:47:07.387]                     save_rds(obj, file)
[17:47:07.387]                   }
[17:47:07.387]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.387]                   {
[17:47:07.387]                     inherits <- base::inherits
[17:47:07.387]                     invokeRestart <- base::invokeRestart
[17:47:07.387]                     is.null <- base::is.null
[17:47:07.387]                     muffled <- FALSE
[17:47:07.387]                     if (inherits(cond, "message")) {
[17:47:07.387]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.387]                       if (muffled) 
[17:47:07.387]                         invokeRestart("muffleMessage")
[17:47:07.387]                     }
[17:47:07.387]                     else if (inherits(cond, "warning")) {
[17:47:07.387]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.387]                       if (muffled) 
[17:47:07.387]                         invokeRestart("muffleWarning")
[17:47:07.387]                     }
[17:47:07.387]                     else if (inherits(cond, "condition")) {
[17:47:07.387]                       if (!is.null(pattern)) {
[17:47:07.387]                         computeRestarts <- base::computeRestarts
[17:47:07.387]                         grepl <- base::grepl
[17:47:07.387]                         restarts <- computeRestarts(cond)
[17:47:07.387]                         for (restart in restarts) {
[17:47:07.387]                           name <- restart$name
[17:47:07.387]                           if (is.null(name)) 
[17:47:07.387]                             next
[17:47:07.387]                           if (!grepl(pattern, name)) 
[17:47:07.387]                             next
[17:47:07.387]                           invokeRestart(restart)
[17:47:07.387]                           muffled <- TRUE
[17:47:07.387]                           break
[17:47:07.387]                         }
[17:47:07.387]                       }
[17:47:07.387]                     }
[17:47:07.387]                     invisible(muffled)
[17:47:07.387]                   }
[17:47:07.387]                   muffleCondition(cond)
[17:47:07.387]                 })
[17:47:07.387]             }))
[17:47:07.387]             future::FutureResult(value = ...future.value$value, 
[17:47:07.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.387]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.387]                     ...future.globalenv.names))
[17:47:07.387]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.387]         }, condition = base::local({
[17:47:07.387]             c <- base::c
[17:47:07.387]             inherits <- base::inherits
[17:47:07.387]             invokeRestart <- base::invokeRestart
[17:47:07.387]             length <- base::length
[17:47:07.387]             list <- base::list
[17:47:07.387]             seq.int <- base::seq.int
[17:47:07.387]             signalCondition <- base::signalCondition
[17:47:07.387]             sys.calls <- base::sys.calls
[17:47:07.387]             `[[` <- base::`[[`
[17:47:07.387]             `+` <- base::`+`
[17:47:07.387]             `<<-` <- base::`<<-`
[17:47:07.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.387]                   3L)]
[17:47:07.387]             }
[17:47:07.387]             function(cond) {
[17:47:07.387]                 is_error <- inherits(cond, "error")
[17:47:07.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.387]                   NULL)
[17:47:07.387]                 if (is_error) {
[17:47:07.387]                   sessionInformation <- function() {
[17:47:07.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.387]                       search = base::search(), system = base::Sys.info())
[17:47:07.387]                   }
[17:47:07.387]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.387]                     cond$call), session = sessionInformation(), 
[17:47:07.387]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.387]                   signalCondition(cond)
[17:47:07.387]                 }
[17:47:07.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.387]                 "immediateCondition"))) {
[17:47:07.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.387]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.387]                   if (TRUE && !signal) {
[17:47:07.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.387]                     {
[17:47:07.387]                       inherits <- base::inherits
[17:47:07.387]                       invokeRestart <- base::invokeRestart
[17:47:07.387]                       is.null <- base::is.null
[17:47:07.387]                       muffled <- FALSE
[17:47:07.387]                       if (inherits(cond, "message")) {
[17:47:07.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.387]                         if (muffled) 
[17:47:07.387]                           invokeRestart("muffleMessage")
[17:47:07.387]                       }
[17:47:07.387]                       else if (inherits(cond, "warning")) {
[17:47:07.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.387]                         if (muffled) 
[17:47:07.387]                           invokeRestart("muffleWarning")
[17:47:07.387]                       }
[17:47:07.387]                       else if (inherits(cond, "condition")) {
[17:47:07.387]                         if (!is.null(pattern)) {
[17:47:07.387]                           computeRestarts <- base::computeRestarts
[17:47:07.387]                           grepl <- base::grepl
[17:47:07.387]                           restarts <- computeRestarts(cond)
[17:47:07.387]                           for (restart in restarts) {
[17:47:07.387]                             name <- restart$name
[17:47:07.387]                             if (is.null(name)) 
[17:47:07.387]                               next
[17:47:07.387]                             if (!grepl(pattern, name)) 
[17:47:07.387]                               next
[17:47:07.387]                             invokeRestart(restart)
[17:47:07.387]                             muffled <- TRUE
[17:47:07.387]                             break
[17:47:07.387]                           }
[17:47:07.387]                         }
[17:47:07.387]                       }
[17:47:07.387]                       invisible(muffled)
[17:47:07.387]                     }
[17:47:07.387]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.387]                   }
[17:47:07.387]                 }
[17:47:07.387]                 else {
[17:47:07.387]                   if (TRUE) {
[17:47:07.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.387]                     {
[17:47:07.387]                       inherits <- base::inherits
[17:47:07.387]                       invokeRestart <- base::invokeRestart
[17:47:07.387]                       is.null <- base::is.null
[17:47:07.387]                       muffled <- FALSE
[17:47:07.387]                       if (inherits(cond, "message")) {
[17:47:07.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.387]                         if (muffled) 
[17:47:07.387]                           invokeRestart("muffleMessage")
[17:47:07.387]                       }
[17:47:07.387]                       else if (inherits(cond, "warning")) {
[17:47:07.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.387]                         if (muffled) 
[17:47:07.387]                           invokeRestart("muffleWarning")
[17:47:07.387]                       }
[17:47:07.387]                       else if (inherits(cond, "condition")) {
[17:47:07.387]                         if (!is.null(pattern)) {
[17:47:07.387]                           computeRestarts <- base::computeRestarts
[17:47:07.387]                           grepl <- base::grepl
[17:47:07.387]                           restarts <- computeRestarts(cond)
[17:47:07.387]                           for (restart in restarts) {
[17:47:07.387]                             name <- restart$name
[17:47:07.387]                             if (is.null(name)) 
[17:47:07.387]                               next
[17:47:07.387]                             if (!grepl(pattern, name)) 
[17:47:07.387]                               next
[17:47:07.387]                             invokeRestart(restart)
[17:47:07.387]                             muffled <- TRUE
[17:47:07.387]                             break
[17:47:07.387]                           }
[17:47:07.387]                         }
[17:47:07.387]                       }
[17:47:07.387]                       invisible(muffled)
[17:47:07.387]                     }
[17:47:07.387]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.387]                   }
[17:47:07.387]                 }
[17:47:07.387]             }
[17:47:07.387]         }))
[17:47:07.387]     }, error = function(ex) {
[17:47:07.387]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.387]                 ...future.rng), started = ...future.startTime, 
[17:47:07.387]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.387]             version = "1.8"), class = "FutureResult")
[17:47:07.387]     }, finally = {
[17:47:07.387]         if (!identical(...future.workdir, getwd())) 
[17:47:07.387]             setwd(...future.workdir)
[17:47:07.387]         {
[17:47:07.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.387]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.387]             }
[17:47:07.387]             base::options(...future.oldOptions)
[17:47:07.387]             if (.Platform$OS.type == "windows") {
[17:47:07.387]                 old_names <- names(...future.oldEnvVars)
[17:47:07.387]                 envs <- base::Sys.getenv()
[17:47:07.387]                 names <- names(envs)
[17:47:07.387]                 common <- intersect(names, old_names)
[17:47:07.387]                 added <- setdiff(names, old_names)
[17:47:07.387]                 removed <- setdiff(old_names, names)
[17:47:07.387]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.387]                   envs[common]]
[17:47:07.387]                 NAMES <- toupper(changed)
[17:47:07.387]                 args <- list()
[17:47:07.387]                 for (kk in seq_along(NAMES)) {
[17:47:07.387]                   name <- changed[[kk]]
[17:47:07.387]                   NAME <- NAMES[[kk]]
[17:47:07.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.387]                     next
[17:47:07.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.387]                 }
[17:47:07.387]                 NAMES <- toupper(added)
[17:47:07.387]                 for (kk in seq_along(NAMES)) {
[17:47:07.387]                   name <- added[[kk]]
[17:47:07.387]                   NAME <- NAMES[[kk]]
[17:47:07.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.387]                     next
[17:47:07.387]                   args[[name]] <- ""
[17:47:07.387]                 }
[17:47:07.387]                 NAMES <- toupper(removed)
[17:47:07.387]                 for (kk in seq_along(NAMES)) {
[17:47:07.387]                   name <- removed[[kk]]
[17:47:07.387]                   NAME <- NAMES[[kk]]
[17:47:07.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.387]                     next
[17:47:07.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.387]                 }
[17:47:07.387]                 if (length(args) > 0) 
[17:47:07.387]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.387]             }
[17:47:07.387]             else {
[17:47:07.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.387]             }
[17:47:07.387]             {
[17:47:07.387]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.387]                   0L) {
[17:47:07.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.387]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.387]                   base::options(opts)
[17:47:07.387]                 }
[17:47:07.387]                 {
[17:47:07.387]                   {
[17:47:07.387]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.387]                     NULL
[17:47:07.387]                   }
[17:47:07.387]                   options(future.plan = NULL)
[17:47:07.387]                   if (is.na(NA_character_)) 
[17:47:07.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.387]                     .init = FALSE)
[17:47:07.387]                 }
[17:47:07.387]             }
[17:47:07.387]         }
[17:47:07.387]     })
[17:47:07.387]     if (TRUE) {
[17:47:07.387]         base::sink(type = "output", split = FALSE)
[17:47:07.387]         if (TRUE) {
[17:47:07.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.387]         }
[17:47:07.387]         else {
[17:47:07.387]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.387]         }
[17:47:07.387]         base::close(...future.stdout)
[17:47:07.387]         ...future.stdout <- NULL
[17:47:07.387]     }
[17:47:07.387]     ...future.result$conditions <- ...future.conditions
[17:47:07.387]     ...future.result$finished <- base::Sys.time()
[17:47:07.387]     ...future.result
[17:47:07.387] }
[17:47:07.390] requestCore(): workers = 2
[17:47:07.392] MulticoreFuture started
[17:47:07.392] - Launch lazy future ... done
[17:47:07.392] run() for ‘MulticoreFuture’ ... done
[17:47:07.393] plan(): Setting new future strategy stack:
[17:47:07.393] List of future strategies:
[17:47:07.393] 1. sequential:
[17:47:07.393]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.393]    - tweaked: FALSE
[17:47:07.393]    - call: NULL
[17:47:07.394] plan(): nbrOfWorkers() = 1
[17:47:07.396] plan(): Setting new future strategy stack:
[17:47:07.396] List of future strategies:
[17:47:07.396] 1. multicore:
[17:47:07.396]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.396]    - tweaked: FALSE
[17:47:07.396]    - call: plan(strategy)
[17:47:07.407] plan(): nbrOfWorkers() = 2
[17:47:07.413] Future #1
[17:47:07.414] result() for MulticoreFuture ...
[17:47:07.415] result() for MulticoreFuture ...
[17:47:07.415] result() for MulticoreFuture ... done
[17:47:07.415] result() for MulticoreFuture ... done
[17:47:07.415] result() for MulticoreFuture ...
[17:47:07.415] result() for MulticoreFuture ... done
[17:47:07.416] A MulticoreFuture was resolved
[17:47:07.416]  length: 0 (resolved future 1)
[17:47:07.416] resolve() on list ... DONE
[17:47:07.419] - globals: [1] ‘a’
[17:47:07.419] Resolving futures part of globals (recursively) ... DONE
[17:47:07.421] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[17:47:07.422] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[17:47:07.422] - globals: [1] ‘a’
[17:47:07.422] - packages: [1] ‘future’
[17:47:07.423] getGlobalsAndPackages() ... DONE
[17:47:07.423] run() for ‘Future’ ...
[17:47:07.423] - state: ‘created’
[17:47:07.423] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.427] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.427] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.428]   - Field: ‘label’
[17:47:07.428]   - Field: ‘local’
[17:47:07.428]   - Field: ‘owner’
[17:47:07.428]   - Field: ‘envir’
[17:47:07.428]   - Field: ‘workers’
[17:47:07.428]   - Field: ‘packages’
[17:47:07.428]   - Field: ‘gc’
[17:47:07.428]   - Field: ‘job’
[17:47:07.428]   - Field: ‘conditions’
[17:47:07.429]   - Field: ‘expr’
[17:47:07.429]   - Field: ‘uuid’
[17:47:07.429]   - Field: ‘seed’
[17:47:07.429]   - Field: ‘version’
[17:47:07.429]   - Field: ‘result’
[17:47:07.429]   - Field: ‘asynchronous’
[17:47:07.429]   - Field: ‘calls’
[17:47:07.429]   - Field: ‘globals’
[17:47:07.430]   - Field: ‘stdout’
[17:47:07.430]   - Field: ‘earlySignal’
[17:47:07.430]   - Field: ‘lazy’
[17:47:07.430]   - Field: ‘state’
[17:47:07.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.430] - Launch lazy future ...
[17:47:07.430] Packages needed by the future expression (n = 1): ‘future’
[17:47:07.431] Packages needed by future strategies (n = 0): <none>
[17:47:07.431] {
[17:47:07.431]     {
[17:47:07.431]         {
[17:47:07.431]             ...future.startTime <- base::Sys.time()
[17:47:07.431]             {
[17:47:07.431]                 {
[17:47:07.431]                   {
[17:47:07.431]                     {
[17:47:07.431]                       {
[17:47:07.431]                         base::local({
[17:47:07.431]                           has_future <- base::requireNamespace("future", 
[17:47:07.431]                             quietly = TRUE)
[17:47:07.431]                           if (has_future) {
[17:47:07.431]                             ns <- base::getNamespace("future")
[17:47:07.431]                             version <- ns[[".package"]][["version"]]
[17:47:07.431]                             if (is.null(version)) 
[17:47:07.431]                               version <- utils::packageVersion("future")
[17:47:07.431]                           }
[17:47:07.431]                           else {
[17:47:07.431]                             version <- NULL
[17:47:07.431]                           }
[17:47:07.431]                           if (!has_future || version < "1.8.0") {
[17:47:07.431]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.431]                               "", base::R.version$version.string), 
[17:47:07.431]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:07.431]                                 base::R.version$platform, 8 * 
[17:47:07.431]                                   base::.Machine$sizeof.pointer), 
[17:47:07.431]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.431]                                 "release", "version")], collapse = " "), 
[17:47:07.431]                               hostname = base::Sys.info()[["nodename"]])
[17:47:07.431]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.431]                               info)
[17:47:07.431]                             info <- base::paste(info, collapse = "; ")
[17:47:07.431]                             if (!has_future) {
[17:47:07.431]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.431]                                 info)
[17:47:07.431]                             }
[17:47:07.431]                             else {
[17:47:07.431]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.431]                                 info, version)
[17:47:07.431]                             }
[17:47:07.431]                             base::stop(msg)
[17:47:07.431]                           }
[17:47:07.431]                         })
[17:47:07.431]                       }
[17:47:07.431]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.431]                       base::options(mc.cores = 1L)
[17:47:07.431]                     }
[17:47:07.431]                     base::local({
[17:47:07.431]                       for (pkg in "future") {
[17:47:07.431]                         base::loadNamespace(pkg)
[17:47:07.431]                         base::library(pkg, character.only = TRUE)
[17:47:07.431]                       }
[17:47:07.431]                     })
[17:47:07.431]                   }
[17:47:07.431]                   ...future.strategy.old <- future::plan("list")
[17:47:07.431]                   options(future.plan = NULL)
[17:47:07.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.431]                 }
[17:47:07.431]                 ...future.workdir <- getwd()
[17:47:07.431]             }
[17:47:07.431]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.431]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.431]         }
[17:47:07.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.431]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.431]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.431]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.431]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.431]             base::names(...future.oldOptions))
[17:47:07.431]     }
[17:47:07.431]     if (FALSE) {
[17:47:07.431]     }
[17:47:07.431]     else {
[17:47:07.431]         if (TRUE) {
[17:47:07.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.431]                 open = "w")
[17:47:07.431]         }
[17:47:07.431]         else {
[17:47:07.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.431]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.431]         }
[17:47:07.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.431]             base::sink(type = "output", split = FALSE)
[17:47:07.431]             base::close(...future.stdout)
[17:47:07.431]         }, add = TRUE)
[17:47:07.431]     }
[17:47:07.431]     ...future.frame <- base::sys.nframe()
[17:47:07.431]     ...future.conditions <- base::list()
[17:47:07.431]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.431]     if (FALSE) {
[17:47:07.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.431]     }
[17:47:07.431]     ...future.result <- base::tryCatch({
[17:47:07.431]         base::withCallingHandlers({
[17:47:07.431]             ...future.value <- base::withVisible(base::local({
[17:47:07.431]                 withCallingHandlers({
[17:47:07.431]                   value(a) + 1
[17:47:07.431]                 }, immediateCondition = function(cond) {
[17:47:07.431]                   save_rds <- function (object, pathname, ...) 
[17:47:07.431]                   {
[17:47:07.431]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.431]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.431]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.431]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.431]                         fi_tmp[["mtime"]])
[17:47:07.431]                     }
[17:47:07.431]                     tryCatch({
[17:47:07.431]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.431]                     }, error = function(ex) {
[17:47:07.431]                       msg <- conditionMessage(ex)
[17:47:07.431]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.431]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.431]                         fi_tmp[["mtime"]], msg)
[17:47:07.431]                       ex$message <- msg
[17:47:07.431]                       stop(ex)
[17:47:07.431]                     })
[17:47:07.431]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.431]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.431]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.431]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.431]                       fi <- file.info(pathname)
[17:47:07.431]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.431]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.431]                         fi[["size"]], fi[["mtime"]])
[17:47:07.431]                       stop(msg)
[17:47:07.431]                     }
[17:47:07.431]                     invisible(pathname)
[17:47:07.431]                   }
[17:47:07.431]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.431]                     rootPath = tempdir()) 
[17:47:07.431]                   {
[17:47:07.431]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.431]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.431]                       tmpdir = path, fileext = ".rds")
[17:47:07.431]                     save_rds(obj, file)
[17:47:07.431]                   }
[17:47:07.431]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.431]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.431]                   {
[17:47:07.431]                     inherits <- base::inherits
[17:47:07.431]                     invokeRestart <- base::invokeRestart
[17:47:07.431]                     is.null <- base::is.null
[17:47:07.431]                     muffled <- FALSE
[17:47:07.431]                     if (inherits(cond, "message")) {
[17:47:07.431]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.431]                       if (muffled) 
[17:47:07.431]                         invokeRestart("muffleMessage")
[17:47:07.431]                     }
[17:47:07.431]                     else if (inherits(cond, "warning")) {
[17:47:07.431]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.431]                       if (muffled) 
[17:47:07.431]                         invokeRestart("muffleWarning")
[17:47:07.431]                     }
[17:47:07.431]                     else if (inherits(cond, "condition")) {
[17:47:07.431]                       if (!is.null(pattern)) {
[17:47:07.431]                         computeRestarts <- base::computeRestarts
[17:47:07.431]                         grepl <- base::grepl
[17:47:07.431]                         restarts <- computeRestarts(cond)
[17:47:07.431]                         for (restart in restarts) {
[17:47:07.431]                           name <- restart$name
[17:47:07.431]                           if (is.null(name)) 
[17:47:07.431]                             next
[17:47:07.431]                           if (!grepl(pattern, name)) 
[17:47:07.431]                             next
[17:47:07.431]                           invokeRestart(restart)
[17:47:07.431]                           muffled <- TRUE
[17:47:07.431]                           break
[17:47:07.431]                         }
[17:47:07.431]                       }
[17:47:07.431]                     }
[17:47:07.431]                     invisible(muffled)
[17:47:07.431]                   }
[17:47:07.431]                   muffleCondition(cond)
[17:47:07.431]                 })
[17:47:07.431]             }))
[17:47:07.431]             future::FutureResult(value = ...future.value$value, 
[17:47:07.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.431]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.431]                     ...future.globalenv.names))
[17:47:07.431]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.431]         }, condition = base::local({
[17:47:07.431]             c <- base::c
[17:47:07.431]             inherits <- base::inherits
[17:47:07.431]             invokeRestart <- base::invokeRestart
[17:47:07.431]             length <- base::length
[17:47:07.431]             list <- base::list
[17:47:07.431]             seq.int <- base::seq.int
[17:47:07.431]             signalCondition <- base::signalCondition
[17:47:07.431]             sys.calls <- base::sys.calls
[17:47:07.431]             `[[` <- base::`[[`
[17:47:07.431]             `+` <- base::`+`
[17:47:07.431]             `<<-` <- base::`<<-`
[17:47:07.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.431]                   3L)]
[17:47:07.431]             }
[17:47:07.431]             function(cond) {
[17:47:07.431]                 is_error <- inherits(cond, "error")
[17:47:07.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.431]                   NULL)
[17:47:07.431]                 if (is_error) {
[17:47:07.431]                   sessionInformation <- function() {
[17:47:07.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.431]                       search = base::search(), system = base::Sys.info())
[17:47:07.431]                   }
[17:47:07.431]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.431]                     cond$call), session = sessionInformation(), 
[17:47:07.431]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.431]                   signalCondition(cond)
[17:47:07.431]                 }
[17:47:07.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.431]                 "immediateCondition"))) {
[17:47:07.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.431]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.431]                   if (TRUE && !signal) {
[17:47:07.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.431]                     {
[17:47:07.431]                       inherits <- base::inherits
[17:47:07.431]                       invokeRestart <- base::invokeRestart
[17:47:07.431]                       is.null <- base::is.null
[17:47:07.431]                       muffled <- FALSE
[17:47:07.431]                       if (inherits(cond, "message")) {
[17:47:07.431]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.431]                         if (muffled) 
[17:47:07.431]                           invokeRestart("muffleMessage")
[17:47:07.431]                       }
[17:47:07.431]                       else if (inherits(cond, "warning")) {
[17:47:07.431]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.431]                         if (muffled) 
[17:47:07.431]                           invokeRestart("muffleWarning")
[17:47:07.431]                       }
[17:47:07.431]                       else if (inherits(cond, "condition")) {
[17:47:07.431]                         if (!is.null(pattern)) {
[17:47:07.431]                           computeRestarts <- base::computeRestarts
[17:47:07.431]                           grepl <- base::grepl
[17:47:07.431]                           restarts <- computeRestarts(cond)
[17:47:07.431]                           for (restart in restarts) {
[17:47:07.431]                             name <- restart$name
[17:47:07.431]                             if (is.null(name)) 
[17:47:07.431]                               next
[17:47:07.431]                             if (!grepl(pattern, name)) 
[17:47:07.431]                               next
[17:47:07.431]                             invokeRestart(restart)
[17:47:07.431]                             muffled <- TRUE
[17:47:07.431]                             break
[17:47:07.431]                           }
[17:47:07.431]                         }
[17:47:07.431]                       }
[17:47:07.431]                       invisible(muffled)
[17:47:07.431]                     }
[17:47:07.431]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.431]                   }
[17:47:07.431]                 }
[17:47:07.431]                 else {
[17:47:07.431]                   if (TRUE) {
[17:47:07.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.431]                     {
[17:47:07.431]                       inherits <- base::inherits
[17:47:07.431]                       invokeRestart <- base::invokeRestart
[17:47:07.431]                       is.null <- base::is.null
[17:47:07.431]                       muffled <- FALSE
[17:47:07.431]                       if (inherits(cond, "message")) {
[17:47:07.431]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.431]                         if (muffled) 
[17:47:07.431]                           invokeRestart("muffleMessage")
[17:47:07.431]                       }
[17:47:07.431]                       else if (inherits(cond, "warning")) {
[17:47:07.431]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.431]                         if (muffled) 
[17:47:07.431]                           invokeRestart("muffleWarning")
[17:47:07.431]                       }
[17:47:07.431]                       else if (inherits(cond, "condition")) {
[17:47:07.431]                         if (!is.null(pattern)) {
[17:47:07.431]                           computeRestarts <- base::computeRestarts
[17:47:07.431]                           grepl <- base::grepl
[17:47:07.431]                           restarts <- computeRestarts(cond)
[17:47:07.431]                           for (restart in restarts) {
[17:47:07.431]                             name <- restart$name
[17:47:07.431]                             if (is.null(name)) 
[17:47:07.431]                               next
[17:47:07.431]                             if (!grepl(pattern, name)) 
[17:47:07.431]                               next
[17:47:07.431]                             invokeRestart(restart)
[17:47:07.431]                             muffled <- TRUE
[17:47:07.431]                             break
[17:47:07.431]                           }
[17:47:07.431]                         }
[17:47:07.431]                       }
[17:47:07.431]                       invisible(muffled)
[17:47:07.431]                     }
[17:47:07.431]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.431]                   }
[17:47:07.431]                 }
[17:47:07.431]             }
[17:47:07.431]         }))
[17:47:07.431]     }, error = function(ex) {
[17:47:07.431]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.431]                 ...future.rng), started = ...future.startTime, 
[17:47:07.431]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.431]             version = "1.8"), class = "FutureResult")
[17:47:07.431]     }, finally = {
[17:47:07.431]         if (!identical(...future.workdir, getwd())) 
[17:47:07.431]             setwd(...future.workdir)
[17:47:07.431]         {
[17:47:07.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.431]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.431]             }
[17:47:07.431]             base::options(...future.oldOptions)
[17:47:07.431]             if (.Platform$OS.type == "windows") {
[17:47:07.431]                 old_names <- names(...future.oldEnvVars)
[17:47:07.431]                 envs <- base::Sys.getenv()
[17:47:07.431]                 names <- names(envs)
[17:47:07.431]                 common <- intersect(names, old_names)
[17:47:07.431]                 added <- setdiff(names, old_names)
[17:47:07.431]                 removed <- setdiff(old_names, names)
[17:47:07.431]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.431]                   envs[common]]
[17:47:07.431]                 NAMES <- toupper(changed)
[17:47:07.431]                 args <- list()
[17:47:07.431]                 for (kk in seq_along(NAMES)) {
[17:47:07.431]                   name <- changed[[kk]]
[17:47:07.431]                   NAME <- NAMES[[kk]]
[17:47:07.431]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.431]                     next
[17:47:07.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.431]                 }
[17:47:07.431]                 NAMES <- toupper(added)
[17:47:07.431]                 for (kk in seq_along(NAMES)) {
[17:47:07.431]                   name <- added[[kk]]
[17:47:07.431]                   NAME <- NAMES[[kk]]
[17:47:07.431]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.431]                     next
[17:47:07.431]                   args[[name]] <- ""
[17:47:07.431]                 }
[17:47:07.431]                 NAMES <- toupper(removed)
[17:47:07.431]                 for (kk in seq_along(NAMES)) {
[17:47:07.431]                   name <- removed[[kk]]
[17:47:07.431]                   NAME <- NAMES[[kk]]
[17:47:07.431]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.431]                     next
[17:47:07.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.431]                 }
[17:47:07.431]                 if (length(args) > 0) 
[17:47:07.431]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.431]             }
[17:47:07.431]             else {
[17:47:07.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.431]             }
[17:47:07.431]             {
[17:47:07.431]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.431]                   0L) {
[17:47:07.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.431]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.431]                   base::options(opts)
[17:47:07.431]                 }
[17:47:07.431]                 {
[17:47:07.431]                   {
[17:47:07.431]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.431]                     NULL
[17:47:07.431]                   }
[17:47:07.431]                   options(future.plan = NULL)
[17:47:07.431]                   if (is.na(NA_character_)) 
[17:47:07.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.431]                     .init = FALSE)
[17:47:07.431]                 }
[17:47:07.431]             }
[17:47:07.431]         }
[17:47:07.431]     })
[17:47:07.431]     if (TRUE) {
[17:47:07.431]         base::sink(type = "output", split = FALSE)
[17:47:07.431]         if (TRUE) {
[17:47:07.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.431]         }
[17:47:07.431]         else {
[17:47:07.431]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.431]         }
[17:47:07.431]         base::close(...future.stdout)
[17:47:07.431]         ...future.stdout <- NULL
[17:47:07.431]     }
[17:47:07.431]     ...future.result$conditions <- ...future.conditions
[17:47:07.431]     ...future.result$finished <- base::Sys.time()
[17:47:07.431]     ...future.result
[17:47:07.431] }
[17:47:07.434] assign_globals() ...
[17:47:07.434] List of 1
[17:47:07.434]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558b31d093b0> 
[17:47:07.434]  - attr(*, "where")=List of 1
[17:47:07.434]   ..$ a:<environment: R_EmptyEnv> 
[17:47:07.434]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.434]  - attr(*, "resolved")= logi TRUE
[17:47:07.434]  - attr(*, "total_size")= num 10984
[17:47:07.434]  - attr(*, "already-done")= logi TRUE
[17:47:07.437] - copied ‘a’ to environment
[17:47:07.437] assign_globals() ... done
[17:47:07.437] requestCore(): workers = 2
[17:47:07.439] MulticoreFuture started
[17:47:07.439] - Launch lazy future ... done
[17:47:07.439] run() for ‘MulticoreFuture’ ... done
[17:47:07.440] result() for MulticoreFuture ...
[17:47:07.440] plan(): Setting new future strategy stack:
[17:47:07.440] List of future strategies:
[17:47:07.440] 1. sequential:
[17:47:07.440]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.440]    - tweaked: FALSE
[17:47:07.440]    - call: NULL
[17:47:07.441] plan(): nbrOfWorkers() = 1
[17:47:07.445] plan(): Setting new future strategy stack:
[17:47:07.445] List of future strategies:
[17:47:07.445] 1. multicore:
[17:47:07.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.445]    - tweaked: FALSE
[17:47:07.445]    - call: plan(strategy)
[17:47:07.450] plan(): nbrOfWorkers() = 2
[17:47:07.450] result() for MulticoreFuture ...
[17:47:07.451] result() for MulticoreFuture ... done
[17:47:07.451] signalConditions() ...
[17:47:07.451]  - include = ‘immediateCondition’
[17:47:07.451]  - exclude = 
[17:47:07.451]  - resignal = FALSE
[17:47:07.451]  - Number of conditions: 4
[17:47:07.451] signalConditions() ... done
[17:47:07.452] result() for MulticoreFuture ... done
[17:47:07.452] result() for MulticoreFuture ...
[17:47:07.452] result() for MulticoreFuture ... done
[17:47:07.452] signalConditions() ...
[17:47:07.452]  - include = ‘immediateCondition’
[17:47:07.452]  - exclude = 
[17:47:07.452]  - resignal = FALSE
[17:47:07.452]  - Number of conditions: 4
[17:47:07.453] signalConditions() ... done
[17:47:07.453] Future state: ‘finished’
[17:47:07.453] result() for MulticoreFuture ...
[17:47:07.453] result() for MulticoreFuture ... done
[17:47:07.453] signalConditions() ...
[17:47:07.453]  - include = ‘condition’
[17:47:07.453]  - exclude = ‘immediateCondition’
[17:47:07.453]  - resignal = TRUE
[17:47:07.454]  - Number of conditions: 4
[17:47:07.454]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.443] result() for MulticoreFuture ...
[17:47:07.454]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.443] result() for MulticoreFuture ... done
[17:47:07.454]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.443] result() for MulticoreFuture ...
[17:47:07.454]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.443] result() for MulticoreFuture ... done
[17:47:07.454] signalConditions() ... done
value(b) = 2
[17:47:07.455] result() for MulticoreFuture ...
[17:47:07.455] result() for MulticoreFuture ... done
[17:47:07.455] result() for MulticoreFuture ...
[17:47:07.455] result() for MulticoreFuture ... done
[17:47:07.455] signalConditions() ...
[17:47:07.455]  - include = ‘immediateCondition’
[17:47:07.455]  - exclude = 
[17:47:07.455]  - resignal = FALSE
[17:47:07.455]  - Number of conditions: 4
[17:47:07.456] signalConditions() ... done
[17:47:07.456] Future state: ‘finished’
[17:47:07.456] result() for MulticoreFuture ...
[17:47:07.456] result() for MulticoreFuture ... done
[17:47:07.456] signalConditions() ...
[17:47:07.456]  - include = ‘condition’
[17:47:07.456]  - exclude = ‘immediateCondition’
[17:47:07.456]  - resignal = TRUE
[17:47:07.456]  - Number of conditions: 4
[17:47:07.457]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.443] result() for MulticoreFuture ...
[17:47:07.457]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.443] result() for MulticoreFuture ... done
[17:47:07.457]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.443] result() for MulticoreFuture ...
[17:47:07.457]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.443] result() for MulticoreFuture ... done
[17:47:07.457] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.457] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.458] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:07.459] - globals found: [2] ‘{’, ‘pkg’
[17:47:07.459] Searching for globals ... DONE
[17:47:07.459] Resolving globals: TRUE
[17:47:07.459] Resolving any globals that are futures ...
[17:47:07.459] - globals: [2] ‘{’, ‘pkg’
[17:47:07.460] Resolving any globals that are futures ... DONE
[17:47:07.460] Resolving futures part of globals (recursively) ...
[17:47:07.460] resolve() on list ...
[17:47:07.460]  recursive: 99
[17:47:07.463]  length: 1
[17:47:07.463]  elements: ‘pkg’
[17:47:07.463]  length: 0 (resolved future 1)
[17:47:07.463] resolve() on list ... DONE
[17:47:07.464] - globals: [1] ‘pkg’
[17:47:07.464] Resolving futures part of globals (recursively) ... DONE
[17:47:07.464] The total size of the 1 globals is 112 bytes (112 bytes)
[17:47:07.465] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:47:07.465] - globals: [1] ‘pkg’
[17:47:07.465] 
[17:47:07.465] getGlobalsAndPackages() ... DONE
[17:47:07.466] Packages needed by the future expression (n = 0): <none>
[17:47:07.466] Packages needed by future strategies (n = 0): <none>
[17:47:07.466] {
[17:47:07.466]     {
[17:47:07.466]         {
[17:47:07.466]             ...future.startTime <- base::Sys.time()
[17:47:07.466]             {
[17:47:07.466]                 {
[17:47:07.466]                   {
[17:47:07.466]                     base::local({
[17:47:07.466]                       has_future <- base::requireNamespace("future", 
[17:47:07.466]                         quietly = TRUE)
[17:47:07.466]                       if (has_future) {
[17:47:07.466]                         ns <- base::getNamespace("future")
[17:47:07.466]                         version <- ns[[".package"]][["version"]]
[17:47:07.466]                         if (is.null(version)) 
[17:47:07.466]                           version <- utils::packageVersion("future")
[17:47:07.466]                       }
[17:47:07.466]                       else {
[17:47:07.466]                         version <- NULL
[17:47:07.466]                       }
[17:47:07.466]                       if (!has_future || version < "1.8.0") {
[17:47:07.466]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.466]                           "", base::R.version$version.string), 
[17:47:07.466]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:07.466]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.466]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.466]                             "release", "version")], collapse = " "), 
[17:47:07.466]                           hostname = base::Sys.info()[["nodename"]])
[17:47:07.466]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.466]                           info)
[17:47:07.466]                         info <- base::paste(info, collapse = "; ")
[17:47:07.466]                         if (!has_future) {
[17:47:07.466]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.466]                             info)
[17:47:07.466]                         }
[17:47:07.466]                         else {
[17:47:07.466]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.466]                             info, version)
[17:47:07.466]                         }
[17:47:07.466]                         base::stop(msg)
[17:47:07.466]                       }
[17:47:07.466]                     })
[17:47:07.466]                   }
[17:47:07.466]                   ...future.strategy.old <- future::plan("list")
[17:47:07.466]                   options(future.plan = NULL)
[17:47:07.466]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.466]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.466]                 }
[17:47:07.466]                 ...future.workdir <- getwd()
[17:47:07.466]             }
[17:47:07.466]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.466]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.466]         }
[17:47:07.466]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.466]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:07.466]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.466]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.466]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.466]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.466]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.466]             base::names(...future.oldOptions))
[17:47:07.466]     }
[17:47:07.466]     if (FALSE) {
[17:47:07.466]     }
[17:47:07.466]     else {
[17:47:07.466]         if (TRUE) {
[17:47:07.466]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.466]                 open = "w")
[17:47:07.466]         }
[17:47:07.466]         else {
[17:47:07.466]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.466]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.466]         }
[17:47:07.466]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.466]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.466]             base::sink(type = "output", split = FALSE)
[17:47:07.466]             base::close(...future.stdout)
[17:47:07.466]         }, add = TRUE)
[17:47:07.466]     }
[17:47:07.466]     ...future.frame <- base::sys.nframe()
[17:47:07.466]     ...future.conditions <- base::list()
[17:47:07.466]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.466]     if (FALSE) {
[17:47:07.466]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.466]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.466]     }
[17:47:07.466]     ...future.result <- base::tryCatch({
[17:47:07.466]         base::withCallingHandlers({
[17:47:07.466]             ...future.value <- base::withVisible(base::local({
[17:47:07.466]                 pkg
[17:47:07.466]             }))
[17:47:07.466]             future::FutureResult(value = ...future.value$value, 
[17:47:07.466]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.466]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.466]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.466]                     ...future.globalenv.names))
[17:47:07.466]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.466]         }, condition = base::local({
[17:47:07.466]             c <- base::c
[17:47:07.466]             inherits <- base::inherits
[17:47:07.466]             invokeRestart <- base::invokeRestart
[17:47:07.466]             length <- base::length
[17:47:07.466]             list <- base::list
[17:47:07.466]             seq.int <- base::seq.int
[17:47:07.466]             signalCondition <- base::signalCondition
[17:47:07.466]             sys.calls <- base::sys.calls
[17:47:07.466]             `[[` <- base::`[[`
[17:47:07.466]             `+` <- base::`+`
[17:47:07.466]             `<<-` <- base::`<<-`
[17:47:07.466]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.466]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.466]                   3L)]
[17:47:07.466]             }
[17:47:07.466]             function(cond) {
[17:47:07.466]                 is_error <- inherits(cond, "error")
[17:47:07.466]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.466]                   NULL)
[17:47:07.466]                 if (is_error) {
[17:47:07.466]                   sessionInformation <- function() {
[17:47:07.466]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.466]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.466]                       search = base::search(), system = base::Sys.info())
[17:47:07.466]                   }
[17:47:07.466]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.466]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.466]                     cond$call), session = sessionInformation(), 
[17:47:07.466]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.466]                   signalCondition(cond)
[17:47:07.466]                 }
[17:47:07.466]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.466]                 "immediateCondition"))) {
[17:47:07.466]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.466]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.466]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.466]                   if (TRUE && !signal) {
[17:47:07.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.466]                     {
[17:47:07.466]                       inherits <- base::inherits
[17:47:07.466]                       invokeRestart <- base::invokeRestart
[17:47:07.466]                       is.null <- base::is.null
[17:47:07.466]                       muffled <- FALSE
[17:47:07.466]                       if (inherits(cond, "message")) {
[17:47:07.466]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.466]                         if (muffled) 
[17:47:07.466]                           invokeRestart("muffleMessage")
[17:47:07.466]                       }
[17:47:07.466]                       else if (inherits(cond, "warning")) {
[17:47:07.466]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.466]                         if (muffled) 
[17:47:07.466]                           invokeRestart("muffleWarning")
[17:47:07.466]                       }
[17:47:07.466]                       else if (inherits(cond, "condition")) {
[17:47:07.466]                         if (!is.null(pattern)) {
[17:47:07.466]                           computeRestarts <- base::computeRestarts
[17:47:07.466]                           grepl <- base::grepl
[17:47:07.466]                           restarts <- computeRestarts(cond)
[17:47:07.466]                           for (restart in restarts) {
[17:47:07.466]                             name <- restart$name
[17:47:07.466]                             if (is.null(name)) 
[17:47:07.466]                               next
[17:47:07.466]                             if (!grepl(pattern, name)) 
[17:47:07.466]                               next
[17:47:07.466]                             invokeRestart(restart)
[17:47:07.466]                             muffled <- TRUE
[17:47:07.466]                             break
[17:47:07.466]                           }
[17:47:07.466]                         }
[17:47:07.466]                       }
[17:47:07.466]                       invisible(muffled)
[17:47:07.466]                     }
[17:47:07.466]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.466]                   }
[17:47:07.466]                 }
[17:47:07.466]                 else {
[17:47:07.466]                   if (TRUE) {
[17:47:07.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.466]                     {
[17:47:07.466]                       inherits <- base::inherits
[17:47:07.466]                       invokeRestart <- base::invokeRestart
[17:47:07.466]                       is.null <- base::is.null
[17:47:07.466]                       muffled <- FALSE
[17:47:07.466]                       if (inherits(cond, "message")) {
[17:47:07.466]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.466]                         if (muffled) 
[17:47:07.466]                           invokeRestart("muffleMessage")
[17:47:07.466]                       }
[17:47:07.466]                       else if (inherits(cond, "warning")) {
[17:47:07.466]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.466]                         if (muffled) 
[17:47:07.466]                           invokeRestart("muffleWarning")
[17:47:07.466]                       }
[17:47:07.466]                       else if (inherits(cond, "condition")) {
[17:47:07.466]                         if (!is.null(pattern)) {
[17:47:07.466]                           computeRestarts <- base::computeRestarts
[17:47:07.466]                           grepl <- base::grepl
[17:47:07.466]                           restarts <- computeRestarts(cond)
[17:47:07.466]                           for (restart in restarts) {
[17:47:07.466]                             name <- restart$name
[17:47:07.466]                             if (is.null(name)) 
[17:47:07.466]                               next
[17:47:07.466]                             if (!grepl(pattern, name)) 
[17:47:07.466]                               next
[17:47:07.466]                             invokeRestart(restart)
[17:47:07.466]                             muffled <- TRUE
[17:47:07.466]                             break
[17:47:07.466]                           }
[17:47:07.466]                         }
[17:47:07.466]                       }
[17:47:07.466]                       invisible(muffled)
[17:47:07.466]                     }
[17:47:07.466]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.466]                   }
[17:47:07.466]                 }
[17:47:07.466]             }
[17:47:07.466]         }))
[17:47:07.466]     }, error = function(ex) {
[17:47:07.466]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.466]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.466]                 ...future.rng), started = ...future.startTime, 
[17:47:07.466]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.466]             version = "1.8"), class = "FutureResult")
[17:47:07.466]     }, finally = {
[17:47:07.466]         if (!identical(...future.workdir, getwd())) 
[17:47:07.466]             setwd(...future.workdir)
[17:47:07.466]         {
[17:47:07.466]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.466]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.466]             }
[17:47:07.466]             base::options(...future.oldOptions)
[17:47:07.466]             if (.Platform$OS.type == "windows") {
[17:47:07.466]                 old_names <- names(...future.oldEnvVars)
[17:47:07.466]                 envs <- base::Sys.getenv()
[17:47:07.466]                 names <- names(envs)
[17:47:07.466]                 common <- intersect(names, old_names)
[17:47:07.466]                 added <- setdiff(names, old_names)
[17:47:07.466]                 removed <- setdiff(old_names, names)
[17:47:07.466]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.466]                   envs[common]]
[17:47:07.466]                 NAMES <- toupper(changed)
[17:47:07.466]                 args <- list()
[17:47:07.466]                 for (kk in seq_along(NAMES)) {
[17:47:07.466]                   name <- changed[[kk]]
[17:47:07.466]                   NAME <- NAMES[[kk]]
[17:47:07.466]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.466]                     next
[17:47:07.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.466]                 }
[17:47:07.466]                 NAMES <- toupper(added)
[17:47:07.466]                 for (kk in seq_along(NAMES)) {
[17:47:07.466]                   name <- added[[kk]]
[17:47:07.466]                   NAME <- NAMES[[kk]]
[17:47:07.466]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.466]                     next
[17:47:07.466]                   args[[name]] <- ""
[17:47:07.466]                 }
[17:47:07.466]                 NAMES <- toupper(removed)
[17:47:07.466]                 for (kk in seq_along(NAMES)) {
[17:47:07.466]                   name <- removed[[kk]]
[17:47:07.466]                   NAME <- NAMES[[kk]]
[17:47:07.466]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.466]                     next
[17:47:07.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.466]                 }
[17:47:07.466]                 if (length(args) > 0) 
[17:47:07.466]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.466]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.466]             }
[17:47:07.466]             else {
[17:47:07.466]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.466]             }
[17:47:07.466]             {
[17:47:07.466]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.466]                   0L) {
[17:47:07.466]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.466]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.466]                   base::options(opts)
[17:47:07.466]                 }
[17:47:07.466]                 {
[17:47:07.466]                   {
[17:47:07.466]                     NULL
[17:47:07.466]                     RNGkind("Mersenne-Twister")
[17:47:07.466]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:07.466]                       inherits = FALSE)
[17:47:07.466]                   }
[17:47:07.466]                   options(future.plan = NULL)
[17:47:07.466]                   if (is.na(NA_character_)) 
[17:47:07.466]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.466]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.466]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.466]                     .init = FALSE)
[17:47:07.466]                 }
[17:47:07.466]             }
[17:47:07.466]         }
[17:47:07.466]     })
[17:47:07.466]     if (TRUE) {
[17:47:07.466]         base::sink(type = "output", split = FALSE)
[17:47:07.466]         if (TRUE) {
[17:47:07.466]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.466]         }
[17:47:07.466]         else {
[17:47:07.466]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.466]         }
[17:47:07.466]         base::close(...future.stdout)
[17:47:07.466]         ...future.stdout <- NULL
[17:47:07.466]     }
[17:47:07.466]     ...future.result$conditions <- ...future.conditions
[17:47:07.466]     ...future.result$finished <- base::Sys.time()
[17:47:07.466]     ...future.result
[17:47:07.466] }
[17:47:07.468] assign_globals() ...
[17:47:07.468] List of 1
[17:47:07.468]  $ pkg: chr "foo"
[17:47:07.468]  - attr(*, "where")=List of 1
[17:47:07.468]   ..$ pkg:<environment: R_EmptyEnv> 
[17:47:07.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.468]  - attr(*, "resolved")= logi TRUE
[17:47:07.468]  - attr(*, "total_size")= num 112
[17:47:07.471] - copied ‘pkg’ to environment
[17:47:07.471] assign_globals() ... done
[17:47:07.471] plan(): Setting new future strategy stack:
[17:47:07.471] List of future strategies:
[17:47:07.471] 1. sequential:
[17:47:07.471]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.471]    - tweaked: FALSE
[17:47:07.471]    - call: NULL
[17:47:07.472] plan(): nbrOfWorkers() = 1
[17:47:07.473] plan(): Setting new future strategy stack:
[17:47:07.473] List of future strategies:
[17:47:07.473] 1. multicore:
[17:47:07.473]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.473]    - tweaked: FALSE
[17:47:07.473]    - call: plan(strategy)
[17:47:07.477] plan(): nbrOfWorkers() = 2
[17:47:07.477] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.478] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.478] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.480] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:07.480] Searching for globals ... DONE
[17:47:07.480] Resolving globals: TRUE
[17:47:07.480] Resolving any globals that are futures ...
[17:47:07.481] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:07.481] Resolving any globals that are futures ... DONE
[17:47:07.481] Resolving futures part of globals (recursively) ...
[17:47:07.481] resolve() on list ...
[17:47:07.481]  recursive: 99
[17:47:07.481]  length: 1
[17:47:07.481]  elements: ‘a’
[17:47:07.482]  length: 0 (resolved future 1)
[17:47:07.482] resolve() on list ... DONE
[17:47:07.482] - globals: [1] ‘a’
[17:47:07.482] Resolving futures part of globals (recursively) ... DONE
[17:47:07.482] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:07.482] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:47:07.482] - globals: [1] ‘a’
[17:47:07.483] 
[17:47:07.483] getGlobalsAndPackages() ... DONE
[17:47:07.483] run() for ‘Future’ ...
[17:47:07.483] - state: ‘created’
[17:47:07.483] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.486] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.487]   - Field: ‘label’
[17:47:07.487]   - Field: ‘local’
[17:47:07.487]   - Field: ‘owner’
[17:47:07.487]   - Field: ‘envir’
[17:47:07.487]   - Field: ‘workers’
[17:47:07.487]   - Field: ‘packages’
[17:47:07.487]   - Field: ‘gc’
[17:47:07.487]   - Field: ‘job’
[17:47:07.488]   - Field: ‘conditions’
[17:47:07.488]   - Field: ‘expr’
[17:47:07.488]   - Field: ‘uuid’
[17:47:07.488]   - Field: ‘seed’
[17:47:07.488]   - Field: ‘version’
[17:47:07.488]   - Field: ‘result’
[17:47:07.488]   - Field: ‘asynchronous’
[17:47:07.488]   - Field: ‘calls’
[17:47:07.488]   - Field: ‘globals’
[17:47:07.488]   - Field: ‘stdout’
[17:47:07.488]   - Field: ‘earlySignal’
[17:47:07.488]   - Field: ‘lazy’
[17:47:07.489]   - Field: ‘state’
[17:47:07.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.489] - Launch lazy future ...
[17:47:07.489] Packages needed by the future expression (n = 0): <none>
[17:47:07.489] Packages needed by future strategies (n = 0): <none>
[17:47:07.490] {
[17:47:07.490]     {
[17:47:07.490]         {
[17:47:07.490]             ...future.startTime <- base::Sys.time()
[17:47:07.490]             {
[17:47:07.490]                 {
[17:47:07.490]                   {
[17:47:07.490]                     {
[17:47:07.490]                       base::local({
[17:47:07.490]                         has_future <- base::requireNamespace("future", 
[17:47:07.490]                           quietly = TRUE)
[17:47:07.490]                         if (has_future) {
[17:47:07.490]                           ns <- base::getNamespace("future")
[17:47:07.490]                           version <- ns[[".package"]][["version"]]
[17:47:07.490]                           if (is.null(version)) 
[17:47:07.490]                             version <- utils::packageVersion("future")
[17:47:07.490]                         }
[17:47:07.490]                         else {
[17:47:07.490]                           version <- NULL
[17:47:07.490]                         }
[17:47:07.490]                         if (!has_future || version < "1.8.0") {
[17:47:07.490]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.490]                             "", base::R.version$version.string), 
[17:47:07.490]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.490]                               "release", "version")], collapse = " "), 
[17:47:07.490]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.490]                             info)
[17:47:07.490]                           info <- base::paste(info, collapse = "; ")
[17:47:07.490]                           if (!has_future) {
[17:47:07.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.490]                               info)
[17:47:07.490]                           }
[17:47:07.490]                           else {
[17:47:07.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.490]                               info, version)
[17:47:07.490]                           }
[17:47:07.490]                           base::stop(msg)
[17:47:07.490]                         }
[17:47:07.490]                       })
[17:47:07.490]                     }
[17:47:07.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.490]                     base::options(mc.cores = 1L)
[17:47:07.490]                   }
[17:47:07.490]                   ...future.strategy.old <- future::plan("list")
[17:47:07.490]                   options(future.plan = NULL)
[17:47:07.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.490]                 }
[17:47:07.490]                 ...future.workdir <- getwd()
[17:47:07.490]             }
[17:47:07.490]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.490]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.490]         }
[17:47:07.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.490]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.490]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.490]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.490]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.490]             base::names(...future.oldOptions))
[17:47:07.490]     }
[17:47:07.490]     if (FALSE) {
[17:47:07.490]     }
[17:47:07.490]     else {
[17:47:07.490]         if (TRUE) {
[17:47:07.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.490]                 open = "w")
[17:47:07.490]         }
[17:47:07.490]         else {
[17:47:07.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.490]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.490]         }
[17:47:07.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.490]             base::sink(type = "output", split = FALSE)
[17:47:07.490]             base::close(...future.stdout)
[17:47:07.490]         }, add = TRUE)
[17:47:07.490]     }
[17:47:07.490]     ...future.frame <- base::sys.nframe()
[17:47:07.490]     ...future.conditions <- base::list()
[17:47:07.490]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.490]     if (FALSE) {
[17:47:07.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.490]     }
[17:47:07.490]     ...future.result <- base::tryCatch({
[17:47:07.490]         base::withCallingHandlers({
[17:47:07.490]             ...future.value <- base::withVisible(base::local({
[17:47:07.490]                 withCallingHandlers({
[17:47:07.490]                   {
[17:47:07.490]                     b <- a
[17:47:07.490]                     a <- 2
[17:47:07.490]                     a * b
[17:47:07.490]                   }
[17:47:07.490]                 }, immediateCondition = function(cond) {
[17:47:07.490]                   save_rds <- function (object, pathname, ...) 
[17:47:07.490]                   {
[17:47:07.490]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.490]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.490]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.490]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.490]                         fi_tmp[["mtime"]])
[17:47:07.490]                     }
[17:47:07.490]                     tryCatch({
[17:47:07.490]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.490]                     }, error = function(ex) {
[17:47:07.490]                       msg <- conditionMessage(ex)
[17:47:07.490]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.490]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.490]                         fi_tmp[["mtime"]], msg)
[17:47:07.490]                       ex$message <- msg
[17:47:07.490]                       stop(ex)
[17:47:07.490]                     })
[17:47:07.490]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.490]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.490]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.490]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.490]                       fi <- file.info(pathname)
[17:47:07.490]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.490]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.490]                         fi[["size"]], fi[["mtime"]])
[17:47:07.490]                       stop(msg)
[17:47:07.490]                     }
[17:47:07.490]                     invisible(pathname)
[17:47:07.490]                   }
[17:47:07.490]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.490]                     rootPath = tempdir()) 
[17:47:07.490]                   {
[17:47:07.490]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.490]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.490]                       tmpdir = path, fileext = ".rds")
[17:47:07.490]                     save_rds(obj, file)
[17:47:07.490]                   }
[17:47:07.490]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.490]                   {
[17:47:07.490]                     inherits <- base::inherits
[17:47:07.490]                     invokeRestart <- base::invokeRestart
[17:47:07.490]                     is.null <- base::is.null
[17:47:07.490]                     muffled <- FALSE
[17:47:07.490]                     if (inherits(cond, "message")) {
[17:47:07.490]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.490]                       if (muffled) 
[17:47:07.490]                         invokeRestart("muffleMessage")
[17:47:07.490]                     }
[17:47:07.490]                     else if (inherits(cond, "warning")) {
[17:47:07.490]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.490]                       if (muffled) 
[17:47:07.490]                         invokeRestart("muffleWarning")
[17:47:07.490]                     }
[17:47:07.490]                     else if (inherits(cond, "condition")) {
[17:47:07.490]                       if (!is.null(pattern)) {
[17:47:07.490]                         computeRestarts <- base::computeRestarts
[17:47:07.490]                         grepl <- base::grepl
[17:47:07.490]                         restarts <- computeRestarts(cond)
[17:47:07.490]                         for (restart in restarts) {
[17:47:07.490]                           name <- restart$name
[17:47:07.490]                           if (is.null(name)) 
[17:47:07.490]                             next
[17:47:07.490]                           if (!grepl(pattern, name)) 
[17:47:07.490]                             next
[17:47:07.490]                           invokeRestart(restart)
[17:47:07.490]                           muffled <- TRUE
[17:47:07.490]                           break
[17:47:07.490]                         }
[17:47:07.490]                       }
[17:47:07.490]                     }
[17:47:07.490]                     invisible(muffled)
[17:47:07.490]                   }
[17:47:07.490]                   muffleCondition(cond)
[17:47:07.490]                 })
[17:47:07.490]             }))
[17:47:07.490]             future::FutureResult(value = ...future.value$value, 
[17:47:07.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.490]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.490]                     ...future.globalenv.names))
[17:47:07.490]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.490]         }, condition = base::local({
[17:47:07.490]             c <- base::c
[17:47:07.490]             inherits <- base::inherits
[17:47:07.490]             invokeRestart <- base::invokeRestart
[17:47:07.490]             length <- base::length
[17:47:07.490]             list <- base::list
[17:47:07.490]             seq.int <- base::seq.int
[17:47:07.490]             signalCondition <- base::signalCondition
[17:47:07.490]             sys.calls <- base::sys.calls
[17:47:07.490]             `[[` <- base::`[[`
[17:47:07.490]             `+` <- base::`+`
[17:47:07.490]             `<<-` <- base::`<<-`
[17:47:07.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.490]                   3L)]
[17:47:07.490]             }
[17:47:07.490]             function(cond) {
[17:47:07.490]                 is_error <- inherits(cond, "error")
[17:47:07.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.490]                   NULL)
[17:47:07.490]                 if (is_error) {
[17:47:07.490]                   sessionInformation <- function() {
[17:47:07.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.490]                       search = base::search(), system = base::Sys.info())
[17:47:07.490]                   }
[17:47:07.490]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.490]                     cond$call), session = sessionInformation(), 
[17:47:07.490]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.490]                   signalCondition(cond)
[17:47:07.490]                 }
[17:47:07.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.490]                 "immediateCondition"))) {
[17:47:07.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.490]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.490]                   if (TRUE && !signal) {
[17:47:07.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.490]                     {
[17:47:07.490]                       inherits <- base::inherits
[17:47:07.490]                       invokeRestart <- base::invokeRestart
[17:47:07.490]                       is.null <- base::is.null
[17:47:07.490]                       muffled <- FALSE
[17:47:07.490]                       if (inherits(cond, "message")) {
[17:47:07.490]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.490]                         if (muffled) 
[17:47:07.490]                           invokeRestart("muffleMessage")
[17:47:07.490]                       }
[17:47:07.490]                       else if (inherits(cond, "warning")) {
[17:47:07.490]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.490]                         if (muffled) 
[17:47:07.490]                           invokeRestart("muffleWarning")
[17:47:07.490]                       }
[17:47:07.490]                       else if (inherits(cond, "condition")) {
[17:47:07.490]                         if (!is.null(pattern)) {
[17:47:07.490]                           computeRestarts <- base::computeRestarts
[17:47:07.490]                           grepl <- base::grepl
[17:47:07.490]                           restarts <- computeRestarts(cond)
[17:47:07.490]                           for (restart in restarts) {
[17:47:07.490]                             name <- restart$name
[17:47:07.490]                             if (is.null(name)) 
[17:47:07.490]                               next
[17:47:07.490]                             if (!grepl(pattern, name)) 
[17:47:07.490]                               next
[17:47:07.490]                             invokeRestart(restart)
[17:47:07.490]                             muffled <- TRUE
[17:47:07.490]                             break
[17:47:07.490]                           }
[17:47:07.490]                         }
[17:47:07.490]                       }
[17:47:07.490]                       invisible(muffled)
[17:47:07.490]                     }
[17:47:07.490]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.490]                   }
[17:47:07.490]                 }
[17:47:07.490]                 else {
[17:47:07.490]                   if (TRUE) {
[17:47:07.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.490]                     {
[17:47:07.490]                       inherits <- base::inherits
[17:47:07.490]                       invokeRestart <- base::invokeRestart
[17:47:07.490]                       is.null <- base::is.null
[17:47:07.490]                       muffled <- FALSE
[17:47:07.490]                       if (inherits(cond, "message")) {
[17:47:07.490]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.490]                         if (muffled) 
[17:47:07.490]                           invokeRestart("muffleMessage")
[17:47:07.490]                       }
[17:47:07.490]                       else if (inherits(cond, "warning")) {
[17:47:07.490]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.490]                         if (muffled) 
[17:47:07.490]                           invokeRestart("muffleWarning")
[17:47:07.490]                       }
[17:47:07.490]                       else if (inherits(cond, "condition")) {
[17:47:07.490]                         if (!is.null(pattern)) {
[17:47:07.490]                           computeRestarts <- base::computeRestarts
[17:47:07.490]                           grepl <- base::grepl
[17:47:07.490]                           restarts <- computeRestarts(cond)
[17:47:07.490]                           for (restart in restarts) {
[17:47:07.490]                             name <- restart$name
[17:47:07.490]                             if (is.null(name)) 
[17:47:07.490]                               next
[17:47:07.490]                             if (!grepl(pattern, name)) 
[17:47:07.490]                               next
[17:47:07.490]                             invokeRestart(restart)
[17:47:07.490]                             muffled <- TRUE
[17:47:07.490]                             break
[17:47:07.490]                           }
[17:47:07.490]                         }
[17:47:07.490]                       }
[17:47:07.490]                       invisible(muffled)
[17:47:07.490]                     }
[17:47:07.490]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.490]                   }
[17:47:07.490]                 }
[17:47:07.490]             }
[17:47:07.490]         }))
[17:47:07.490]     }, error = function(ex) {
[17:47:07.490]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.490]                 ...future.rng), started = ...future.startTime, 
[17:47:07.490]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.490]             version = "1.8"), class = "FutureResult")
[17:47:07.490]     }, finally = {
[17:47:07.490]         if (!identical(...future.workdir, getwd())) 
[17:47:07.490]             setwd(...future.workdir)
[17:47:07.490]         {
[17:47:07.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.490]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.490]             }
[17:47:07.490]             base::options(...future.oldOptions)
[17:47:07.490]             if (.Platform$OS.type == "windows") {
[17:47:07.490]                 old_names <- names(...future.oldEnvVars)
[17:47:07.490]                 envs <- base::Sys.getenv()
[17:47:07.490]                 names <- names(envs)
[17:47:07.490]                 common <- intersect(names, old_names)
[17:47:07.490]                 added <- setdiff(names, old_names)
[17:47:07.490]                 removed <- setdiff(old_names, names)
[17:47:07.490]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.490]                   envs[common]]
[17:47:07.490]                 NAMES <- toupper(changed)
[17:47:07.490]                 args <- list()
[17:47:07.490]                 for (kk in seq_along(NAMES)) {
[17:47:07.490]                   name <- changed[[kk]]
[17:47:07.490]                   NAME <- NAMES[[kk]]
[17:47:07.490]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.490]                     next
[17:47:07.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.490]                 }
[17:47:07.490]                 NAMES <- toupper(added)
[17:47:07.490]                 for (kk in seq_along(NAMES)) {
[17:47:07.490]                   name <- added[[kk]]
[17:47:07.490]                   NAME <- NAMES[[kk]]
[17:47:07.490]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.490]                     next
[17:47:07.490]                   args[[name]] <- ""
[17:47:07.490]                 }
[17:47:07.490]                 NAMES <- toupper(removed)
[17:47:07.490]                 for (kk in seq_along(NAMES)) {
[17:47:07.490]                   name <- removed[[kk]]
[17:47:07.490]                   NAME <- NAMES[[kk]]
[17:47:07.490]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.490]                     next
[17:47:07.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.490]                 }
[17:47:07.490]                 if (length(args) > 0) 
[17:47:07.490]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.490]             }
[17:47:07.490]             else {
[17:47:07.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.490]             }
[17:47:07.490]             {
[17:47:07.490]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.490]                   0L) {
[17:47:07.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.490]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.490]                   base::options(opts)
[17:47:07.490]                 }
[17:47:07.490]                 {
[17:47:07.490]                   {
[17:47:07.490]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.490]                     NULL
[17:47:07.490]                   }
[17:47:07.490]                   options(future.plan = NULL)
[17:47:07.490]                   if (is.na(NA_character_)) 
[17:47:07.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.490]                     .init = FALSE)
[17:47:07.490]                 }
[17:47:07.490]             }
[17:47:07.490]         }
[17:47:07.490]     })
[17:47:07.490]     if (TRUE) {
[17:47:07.490]         base::sink(type = "output", split = FALSE)
[17:47:07.490]         if (TRUE) {
[17:47:07.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.490]         }
[17:47:07.490]         else {
[17:47:07.490]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.490]         }
[17:47:07.490]         base::close(...future.stdout)
[17:47:07.490]         ...future.stdout <- NULL
[17:47:07.490]     }
[17:47:07.490]     ...future.result$conditions <- ...future.conditions
[17:47:07.490]     ...future.result$finished <- base::Sys.time()
[17:47:07.490]     ...future.result
[17:47:07.490] }
[17:47:07.492] assign_globals() ...
[17:47:07.492] List of 1
[17:47:07.492]  $ a: num 3
[17:47:07.492]  - attr(*, "where")=List of 1
[17:47:07.492]   ..$ a:<environment: R_EmptyEnv> 
[17:47:07.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.492]  - attr(*, "resolved")= logi TRUE
[17:47:07.492]  - attr(*, "total_size")= num 56
[17:47:07.492]  - attr(*, "already-done")= logi TRUE
[17:47:07.496] - copied ‘a’ to environment
[17:47:07.496] assign_globals() ... done
[17:47:07.496] requestCore(): workers = 2
[17:47:07.498] MulticoreFuture started
[17:47:07.499] - Launch lazy future ... done
[17:47:07.499] run() for ‘MulticoreFuture’ ... done
[17:47:07.500] plan(): Setting new future strategy stack:
[17:47:07.500] result() for MulticoreFuture ...
[17:47:07.500] List of future strategies:
[17:47:07.500] 1. sequential:
[17:47:07.500]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.500]    - tweaked: FALSE
[17:47:07.500]    - call: NULL
[17:47:07.501] plan(): nbrOfWorkers() = 1
[17:47:07.503] plan(): Setting new future strategy stack:
[17:47:07.504] List of future strategies:
[17:47:07.504] 1. multicore:
[17:47:07.504]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.504]    - tweaked: FALSE
[17:47:07.504]    - call: plan(strategy)
[17:47:07.509] plan(): nbrOfWorkers() = 2
[17:47:07.510] result() for MulticoreFuture ...
[17:47:07.510] result() for MulticoreFuture ... done
[17:47:07.510] result() for MulticoreFuture ... done
[17:47:07.510] result() for MulticoreFuture ...
[17:47:07.511] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.512] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.512] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.515] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:07.515] Searching for globals ... DONE
[17:47:07.515] Resolving globals: TRUE
[17:47:07.515] Resolving any globals that are futures ...
[17:47:07.515] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:07.515] Resolving any globals that are futures ... DONE
[17:47:07.516] Resolving futures part of globals (recursively) ...
[17:47:07.516] resolve() on list ...
[17:47:07.516]  recursive: 99
[17:47:07.516]  length: 1
[17:47:07.517]  elements: ‘a’
[17:47:07.517]  length: 0 (resolved future 1)
[17:47:07.517] resolve() on list ... DONE
[17:47:07.517] - globals: [1] ‘a’
[17:47:07.517] Resolving futures part of globals (recursively) ... DONE
[17:47:07.517] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:07.518] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:47:07.518] - globals: [1] ‘a’
[17:47:07.518] 
[17:47:07.518] getGlobalsAndPackages() ... DONE
[17:47:07.518] run() for ‘Future’ ...
[17:47:07.519] - state: ‘created’
[17:47:07.519] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.523] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.523]   - Field: ‘label’
[17:47:07.523]   - Field: ‘local’
[17:47:07.523]   - Field: ‘owner’
[17:47:07.523]   - Field: ‘envir’
[17:47:07.523]   - Field: ‘workers’
[17:47:07.524]   - Field: ‘packages’
[17:47:07.524]   - Field: ‘gc’
[17:47:07.524]   - Field: ‘job’
[17:47:07.524]   - Field: ‘conditions’
[17:47:07.524]   - Field: ‘expr’
[17:47:07.524]   - Field: ‘uuid’
[17:47:07.524]   - Field: ‘seed’
[17:47:07.524]   - Field: ‘version’
[17:47:07.524]   - Field: ‘result’
[17:47:07.525]   - Field: ‘asynchronous’
[17:47:07.525]   - Field: ‘calls’
[17:47:07.525]   - Field: ‘globals’
[17:47:07.525]   - Field: ‘stdout’
[17:47:07.525]   - Field: ‘earlySignal’
[17:47:07.525]   - Field: ‘lazy’
[17:47:07.525]   - Field: ‘state’
[17:47:07.525] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.525] - Launch lazy future ...
[17:47:07.526] Packages needed by the future expression (n = 0): <none>
[17:47:07.526] Packages needed by future strategies (n = 0): <none>
[17:47:07.526] {
[17:47:07.526]     {
[17:47:07.526]         {
[17:47:07.526]             ...future.startTime <- base::Sys.time()
[17:47:07.526]             {
[17:47:07.526]                 {
[17:47:07.526]                   {
[17:47:07.526]                     {
[17:47:07.526]                       base::local({
[17:47:07.526]                         has_future <- base::requireNamespace("future", 
[17:47:07.526]                           quietly = TRUE)
[17:47:07.526]                         if (has_future) {
[17:47:07.526]                           ns <- base::getNamespace("future")
[17:47:07.526]                           version <- ns[[".package"]][["version"]]
[17:47:07.526]                           if (is.null(version)) 
[17:47:07.526]                             version <- utils::packageVersion("future")
[17:47:07.526]                         }
[17:47:07.526]                         else {
[17:47:07.526]                           version <- NULL
[17:47:07.526]                         }
[17:47:07.526]                         if (!has_future || version < "1.8.0") {
[17:47:07.526]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.526]                             "", base::R.version$version.string), 
[17:47:07.526]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.526]                               "release", "version")], collapse = " "), 
[17:47:07.526]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.526]                             info)
[17:47:07.526]                           info <- base::paste(info, collapse = "; ")
[17:47:07.526]                           if (!has_future) {
[17:47:07.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.526]                               info)
[17:47:07.526]                           }
[17:47:07.526]                           else {
[17:47:07.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.526]                               info, version)
[17:47:07.526]                           }
[17:47:07.526]                           base::stop(msg)
[17:47:07.526]                         }
[17:47:07.526]                       })
[17:47:07.526]                     }
[17:47:07.526]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.526]                     base::options(mc.cores = 1L)
[17:47:07.526]                   }
[17:47:07.526]                   ...future.strategy.old <- future::plan("list")
[17:47:07.526]                   options(future.plan = NULL)
[17:47:07.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.526]                 }
[17:47:07.526]                 ...future.workdir <- getwd()
[17:47:07.526]             }
[17:47:07.526]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.526]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.526]         }
[17:47:07.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.526]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.526]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.526]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.526]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.526]             base::names(...future.oldOptions))
[17:47:07.526]     }
[17:47:07.526]     if (FALSE) {
[17:47:07.526]     }
[17:47:07.526]     else {
[17:47:07.526]         if (TRUE) {
[17:47:07.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.526]                 open = "w")
[17:47:07.526]         }
[17:47:07.526]         else {
[17:47:07.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.526]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.526]         }
[17:47:07.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.526]             base::sink(type = "output", split = FALSE)
[17:47:07.526]             base::close(...future.stdout)
[17:47:07.526]         }, add = TRUE)
[17:47:07.526]     }
[17:47:07.526]     ...future.frame <- base::sys.nframe()
[17:47:07.526]     ...future.conditions <- base::list()
[17:47:07.526]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.526]     if (FALSE) {
[17:47:07.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.526]     }
[17:47:07.526]     ...future.result <- base::tryCatch({
[17:47:07.526]         base::withCallingHandlers({
[17:47:07.526]             ...future.value <- base::withVisible(base::local({
[17:47:07.526]                 withCallingHandlers({
[17:47:07.526]                   {
[17:47:07.526]                     b <- a
[17:47:07.526]                     a <- 2
[17:47:07.526]                     a * b
[17:47:07.526]                   }
[17:47:07.526]                 }, immediateCondition = function(cond) {
[17:47:07.526]                   save_rds <- function (object, pathname, ...) 
[17:47:07.526]                   {
[17:47:07.526]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.526]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.526]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.526]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.526]                         fi_tmp[["mtime"]])
[17:47:07.526]                     }
[17:47:07.526]                     tryCatch({
[17:47:07.526]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.526]                     }, error = function(ex) {
[17:47:07.526]                       msg <- conditionMessage(ex)
[17:47:07.526]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.526]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.526]                         fi_tmp[["mtime"]], msg)
[17:47:07.526]                       ex$message <- msg
[17:47:07.526]                       stop(ex)
[17:47:07.526]                     })
[17:47:07.526]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.526]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.526]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.526]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.526]                       fi <- file.info(pathname)
[17:47:07.526]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.526]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.526]                         fi[["size"]], fi[["mtime"]])
[17:47:07.526]                       stop(msg)
[17:47:07.526]                     }
[17:47:07.526]                     invisible(pathname)
[17:47:07.526]                   }
[17:47:07.526]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.526]                     rootPath = tempdir()) 
[17:47:07.526]                   {
[17:47:07.526]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.526]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.526]                       tmpdir = path, fileext = ".rds")
[17:47:07.526]                     save_rds(obj, file)
[17:47:07.526]                   }
[17:47:07.526]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.526]                   {
[17:47:07.526]                     inherits <- base::inherits
[17:47:07.526]                     invokeRestart <- base::invokeRestart
[17:47:07.526]                     is.null <- base::is.null
[17:47:07.526]                     muffled <- FALSE
[17:47:07.526]                     if (inherits(cond, "message")) {
[17:47:07.526]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.526]                       if (muffled) 
[17:47:07.526]                         invokeRestart("muffleMessage")
[17:47:07.526]                     }
[17:47:07.526]                     else if (inherits(cond, "warning")) {
[17:47:07.526]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.526]                       if (muffled) 
[17:47:07.526]                         invokeRestart("muffleWarning")
[17:47:07.526]                     }
[17:47:07.526]                     else if (inherits(cond, "condition")) {
[17:47:07.526]                       if (!is.null(pattern)) {
[17:47:07.526]                         computeRestarts <- base::computeRestarts
[17:47:07.526]                         grepl <- base::grepl
[17:47:07.526]                         restarts <- computeRestarts(cond)
[17:47:07.526]                         for (restart in restarts) {
[17:47:07.526]                           name <- restart$name
[17:47:07.526]                           if (is.null(name)) 
[17:47:07.526]                             next
[17:47:07.526]                           if (!grepl(pattern, name)) 
[17:47:07.526]                             next
[17:47:07.526]                           invokeRestart(restart)
[17:47:07.526]                           muffled <- TRUE
[17:47:07.526]                           break
[17:47:07.526]                         }
[17:47:07.526]                       }
[17:47:07.526]                     }
[17:47:07.526]                     invisible(muffled)
[17:47:07.526]                   }
[17:47:07.526]                   muffleCondition(cond)
[17:47:07.526]                 })
[17:47:07.526]             }))
[17:47:07.526]             future::FutureResult(value = ...future.value$value, 
[17:47:07.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.526]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.526]                     ...future.globalenv.names))
[17:47:07.526]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.526]         }, condition = base::local({
[17:47:07.526]             c <- base::c
[17:47:07.526]             inherits <- base::inherits
[17:47:07.526]             invokeRestart <- base::invokeRestart
[17:47:07.526]             length <- base::length
[17:47:07.526]             list <- base::list
[17:47:07.526]             seq.int <- base::seq.int
[17:47:07.526]             signalCondition <- base::signalCondition
[17:47:07.526]             sys.calls <- base::sys.calls
[17:47:07.526]             `[[` <- base::`[[`
[17:47:07.526]             `+` <- base::`+`
[17:47:07.526]             `<<-` <- base::`<<-`
[17:47:07.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.526]                   3L)]
[17:47:07.526]             }
[17:47:07.526]             function(cond) {
[17:47:07.526]                 is_error <- inherits(cond, "error")
[17:47:07.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.526]                   NULL)
[17:47:07.526]                 if (is_error) {
[17:47:07.526]                   sessionInformation <- function() {
[17:47:07.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.526]                       search = base::search(), system = base::Sys.info())
[17:47:07.526]                   }
[17:47:07.526]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.526]                     cond$call), session = sessionInformation(), 
[17:47:07.526]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.526]                   signalCondition(cond)
[17:47:07.526]                 }
[17:47:07.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.526]                 "immediateCondition"))) {
[17:47:07.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.526]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.526]                   if (TRUE && !signal) {
[17:47:07.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.526]                     {
[17:47:07.526]                       inherits <- base::inherits
[17:47:07.526]                       invokeRestart <- base::invokeRestart
[17:47:07.526]                       is.null <- base::is.null
[17:47:07.526]                       muffled <- FALSE
[17:47:07.526]                       if (inherits(cond, "message")) {
[17:47:07.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.526]                         if (muffled) 
[17:47:07.526]                           invokeRestart("muffleMessage")
[17:47:07.526]                       }
[17:47:07.526]                       else if (inherits(cond, "warning")) {
[17:47:07.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.526]                         if (muffled) 
[17:47:07.526]                           invokeRestart("muffleWarning")
[17:47:07.526]                       }
[17:47:07.526]                       else if (inherits(cond, "condition")) {
[17:47:07.526]                         if (!is.null(pattern)) {
[17:47:07.526]                           computeRestarts <- base::computeRestarts
[17:47:07.526]                           grepl <- base::grepl
[17:47:07.526]                           restarts <- computeRestarts(cond)
[17:47:07.526]                           for (restart in restarts) {
[17:47:07.526]                             name <- restart$name
[17:47:07.526]                             if (is.null(name)) 
[17:47:07.526]                               next
[17:47:07.526]                             if (!grepl(pattern, name)) 
[17:47:07.526]                               next
[17:47:07.526]                             invokeRestart(restart)
[17:47:07.526]                             muffled <- TRUE
[17:47:07.526]                             break
[17:47:07.526]                           }
[17:47:07.526]                         }
[17:47:07.526]                       }
[17:47:07.526]                       invisible(muffled)
[17:47:07.526]                     }
[17:47:07.526]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.526]                   }
[17:47:07.526]                 }
[17:47:07.526]                 else {
[17:47:07.526]                   if (TRUE) {
[17:47:07.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.526]                     {
[17:47:07.526]                       inherits <- base::inherits
[17:47:07.526]                       invokeRestart <- base::invokeRestart
[17:47:07.526]                       is.null <- base::is.null
[17:47:07.526]                       muffled <- FALSE
[17:47:07.526]                       if (inherits(cond, "message")) {
[17:47:07.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.526]                         if (muffled) 
[17:47:07.526]                           invokeRestart("muffleMessage")
[17:47:07.526]                       }
[17:47:07.526]                       else if (inherits(cond, "warning")) {
[17:47:07.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.526]                         if (muffled) 
[17:47:07.526]                           invokeRestart("muffleWarning")
[17:47:07.526]                       }
[17:47:07.526]                       else if (inherits(cond, "condition")) {
[17:47:07.526]                         if (!is.null(pattern)) {
[17:47:07.526]                           computeRestarts <- base::computeRestarts
[17:47:07.526]                           grepl <- base::grepl
[17:47:07.526]                           restarts <- computeRestarts(cond)
[17:47:07.526]                           for (restart in restarts) {
[17:47:07.526]                             name <- restart$name
[17:47:07.526]                             if (is.null(name)) 
[17:47:07.526]                               next
[17:47:07.526]                             if (!grepl(pattern, name)) 
[17:47:07.526]                               next
[17:47:07.526]                             invokeRestart(restart)
[17:47:07.526]                             muffled <- TRUE
[17:47:07.526]                             break
[17:47:07.526]                           }
[17:47:07.526]                         }
[17:47:07.526]                       }
[17:47:07.526]                       invisible(muffled)
[17:47:07.526]                     }
[17:47:07.526]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.526]                   }
[17:47:07.526]                 }
[17:47:07.526]             }
[17:47:07.526]         }))
[17:47:07.526]     }, error = function(ex) {
[17:47:07.526]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.526]                 ...future.rng), started = ...future.startTime, 
[17:47:07.526]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.526]             version = "1.8"), class = "FutureResult")
[17:47:07.526]     }, finally = {
[17:47:07.526]         if (!identical(...future.workdir, getwd())) 
[17:47:07.526]             setwd(...future.workdir)
[17:47:07.526]         {
[17:47:07.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.526]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.526]             }
[17:47:07.526]             base::options(...future.oldOptions)
[17:47:07.526]             if (.Platform$OS.type == "windows") {
[17:47:07.526]                 old_names <- names(...future.oldEnvVars)
[17:47:07.526]                 envs <- base::Sys.getenv()
[17:47:07.526]                 names <- names(envs)
[17:47:07.526]                 common <- intersect(names, old_names)
[17:47:07.526]                 added <- setdiff(names, old_names)
[17:47:07.526]                 removed <- setdiff(old_names, names)
[17:47:07.526]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.526]                   envs[common]]
[17:47:07.526]                 NAMES <- toupper(changed)
[17:47:07.526]                 args <- list()
[17:47:07.526]                 for (kk in seq_along(NAMES)) {
[17:47:07.526]                   name <- changed[[kk]]
[17:47:07.526]                   NAME <- NAMES[[kk]]
[17:47:07.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.526]                     next
[17:47:07.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.526]                 }
[17:47:07.526]                 NAMES <- toupper(added)
[17:47:07.526]                 for (kk in seq_along(NAMES)) {
[17:47:07.526]                   name <- added[[kk]]
[17:47:07.526]                   NAME <- NAMES[[kk]]
[17:47:07.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.526]                     next
[17:47:07.526]                   args[[name]] <- ""
[17:47:07.526]                 }
[17:47:07.526]                 NAMES <- toupper(removed)
[17:47:07.526]                 for (kk in seq_along(NAMES)) {
[17:47:07.526]                   name <- removed[[kk]]
[17:47:07.526]                   NAME <- NAMES[[kk]]
[17:47:07.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.526]                     next
[17:47:07.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.526]                 }
[17:47:07.526]                 if (length(args) > 0) 
[17:47:07.526]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.526]             }
[17:47:07.526]             else {
[17:47:07.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.526]             }
[17:47:07.526]             {
[17:47:07.526]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.526]                   0L) {
[17:47:07.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.526]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.526]                   base::options(opts)
[17:47:07.526]                 }
[17:47:07.526]                 {
[17:47:07.526]                   {
[17:47:07.526]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.526]                     NULL
[17:47:07.526]                   }
[17:47:07.526]                   options(future.plan = NULL)
[17:47:07.526]                   if (is.na(NA_character_)) 
[17:47:07.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.526]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.526]                     .init = FALSE)
[17:47:07.526]                 }
[17:47:07.526]             }
[17:47:07.526]         }
[17:47:07.526]     })
[17:47:07.526]     if (TRUE) {
[17:47:07.526]         base::sink(type = "output", split = FALSE)
[17:47:07.526]         if (TRUE) {
[17:47:07.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.526]         }
[17:47:07.526]         else {
[17:47:07.526]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.526]         }
[17:47:07.526]         base::close(...future.stdout)
[17:47:07.526]         ...future.stdout <- NULL
[17:47:07.526]     }
[17:47:07.526]     ...future.result$conditions <- ...future.conditions
[17:47:07.526]     ...future.result$finished <- base::Sys.time()
[17:47:07.526]     ...future.result
[17:47:07.526] }
[17:47:07.529] assign_globals() ...
[17:47:07.529] List of 1
[17:47:07.529]  $ a: num 3
[17:47:07.529]  - attr(*, "where")=List of 1
[17:47:07.529]   ..$ a:<environment: R_EmptyEnv> 
[17:47:07.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.529]  - attr(*, "resolved")= logi TRUE
[17:47:07.529]  - attr(*, "total_size")= num 56
[17:47:07.529]  - attr(*, "already-done")= logi TRUE
[17:47:07.532] - copied ‘a’ to environment
[17:47:07.532] assign_globals() ... done
[17:47:07.533] requestCore(): workers = 2
[17:47:07.534] MulticoreFuture started
[17:47:07.535] - Launch lazy future ... done
[17:47:07.535] run() for ‘MulticoreFuture’ ... done
[17:47:07.535] result() for MulticoreFuture ...
[17:47:07.535] plan(): Setting new future strategy stack:
[17:47:07.536] List of future strategies:
[17:47:07.536] 1. sequential:
[17:47:07.536]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.536]    - tweaked: FALSE
[17:47:07.536]    - call: NULL
[17:47:07.537] plan(): nbrOfWorkers() = 1
[17:47:07.543] plan(): Setting new future strategy stack:
[17:47:07.544] List of future strategies:
[17:47:07.544] 1. multicore:
[17:47:07.544]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.544]    - tweaked: FALSE
[17:47:07.544]    - call: plan(strategy)
[17:47:07.551] plan(): nbrOfWorkers() = 2
[17:47:07.552] result() for MulticoreFuture ...
[17:47:07.552] result() for MulticoreFuture ... done
[17:47:07.552] result() for MulticoreFuture ... done
[17:47:07.555] result() for MulticoreFuture ...
[17:47:07.555] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.556] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.557] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.560] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.560] Searching for globals ... DONE
[17:47:07.560] Resolving globals: TRUE
[17:47:07.560] Resolving any globals that are futures ...
[17:47:07.561] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.561] Resolving any globals that are futures ... DONE
[17:47:07.561] Resolving futures part of globals (recursively) ...
[17:47:07.561] resolve() on list ...
[17:47:07.562]  recursive: 99
[17:47:07.562]  length: 2
[17:47:07.562]  elements: ‘a’, ‘ii’
[17:47:07.562]  length: 1 (resolved future 1)
[17:47:07.562]  length: 0 (resolved future 2)
[17:47:07.562] resolve() on list ... DONE
[17:47:07.562] - globals: [2] ‘a’, ‘ii’
[17:47:07.562] Resolving futures part of globals (recursively) ... DONE
[17:47:07.563] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:07.563] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.563] - globals: [2] ‘a’, ‘ii’
[17:47:07.563] 
[17:47:07.564] getGlobalsAndPackages() ... DONE
[17:47:07.564] run() for ‘Future’ ...
[17:47:07.564] - state: ‘created’
[17:47:07.564] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.568] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.568] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.568]   - Field: ‘label’
[17:47:07.568]   - Field: ‘local’
[17:47:07.568]   - Field: ‘owner’
[17:47:07.569]   - Field: ‘envir’
[17:47:07.569]   - Field: ‘workers’
[17:47:07.569]   - Field: ‘packages’
[17:47:07.569]   - Field: ‘gc’
[17:47:07.569]   - Field: ‘job’
[17:47:07.569]   - Field: ‘conditions’
[17:47:07.569]   - Field: ‘expr’
[17:47:07.569]   - Field: ‘uuid’
[17:47:07.569]   - Field: ‘seed’
[17:47:07.570]   - Field: ‘version’
[17:47:07.570]   - Field: ‘result’
[17:47:07.570]   - Field: ‘asynchronous’
[17:47:07.570]   - Field: ‘calls’
[17:47:07.570]   - Field: ‘globals’
[17:47:07.570]   - Field: ‘stdout’
[17:47:07.570]   - Field: ‘earlySignal’
[17:47:07.570]   - Field: ‘lazy’
[17:47:07.570]   - Field: ‘state’
[17:47:07.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.571] - Launch lazy future ...
[17:47:07.571] Packages needed by the future expression (n = 0): <none>
[17:47:07.571] Packages needed by future strategies (n = 0): <none>
[17:47:07.572] {
[17:47:07.572]     {
[17:47:07.572]         {
[17:47:07.572]             ...future.startTime <- base::Sys.time()
[17:47:07.572]             {
[17:47:07.572]                 {
[17:47:07.572]                   {
[17:47:07.572]                     {
[17:47:07.572]                       base::local({
[17:47:07.572]                         has_future <- base::requireNamespace("future", 
[17:47:07.572]                           quietly = TRUE)
[17:47:07.572]                         if (has_future) {
[17:47:07.572]                           ns <- base::getNamespace("future")
[17:47:07.572]                           version <- ns[[".package"]][["version"]]
[17:47:07.572]                           if (is.null(version)) 
[17:47:07.572]                             version <- utils::packageVersion("future")
[17:47:07.572]                         }
[17:47:07.572]                         else {
[17:47:07.572]                           version <- NULL
[17:47:07.572]                         }
[17:47:07.572]                         if (!has_future || version < "1.8.0") {
[17:47:07.572]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.572]                             "", base::R.version$version.string), 
[17:47:07.572]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.572]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.572]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.572]                               "release", "version")], collapse = " "), 
[17:47:07.572]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.572]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.572]                             info)
[17:47:07.572]                           info <- base::paste(info, collapse = "; ")
[17:47:07.572]                           if (!has_future) {
[17:47:07.572]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.572]                               info)
[17:47:07.572]                           }
[17:47:07.572]                           else {
[17:47:07.572]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.572]                               info, version)
[17:47:07.572]                           }
[17:47:07.572]                           base::stop(msg)
[17:47:07.572]                         }
[17:47:07.572]                       })
[17:47:07.572]                     }
[17:47:07.572]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.572]                     base::options(mc.cores = 1L)
[17:47:07.572]                   }
[17:47:07.572]                   ...future.strategy.old <- future::plan("list")
[17:47:07.572]                   options(future.plan = NULL)
[17:47:07.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.572]                 }
[17:47:07.572]                 ...future.workdir <- getwd()
[17:47:07.572]             }
[17:47:07.572]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.572]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.572]         }
[17:47:07.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.572]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.572]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.572]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.572]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.572]             base::names(...future.oldOptions))
[17:47:07.572]     }
[17:47:07.572]     if (FALSE) {
[17:47:07.572]     }
[17:47:07.572]     else {
[17:47:07.572]         if (TRUE) {
[17:47:07.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.572]                 open = "w")
[17:47:07.572]         }
[17:47:07.572]         else {
[17:47:07.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.572]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.572]         }
[17:47:07.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.572]             base::sink(type = "output", split = FALSE)
[17:47:07.572]             base::close(...future.stdout)
[17:47:07.572]         }, add = TRUE)
[17:47:07.572]     }
[17:47:07.572]     ...future.frame <- base::sys.nframe()
[17:47:07.572]     ...future.conditions <- base::list()
[17:47:07.572]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.572]     if (FALSE) {
[17:47:07.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.572]     }
[17:47:07.572]     ...future.result <- base::tryCatch({
[17:47:07.572]         base::withCallingHandlers({
[17:47:07.572]             ...future.value <- base::withVisible(base::local({
[17:47:07.572]                 withCallingHandlers({
[17:47:07.572]                   {
[17:47:07.572]                     b <- a * ii
[17:47:07.572]                     a <- 0
[17:47:07.572]                     b
[17:47:07.572]                   }
[17:47:07.572]                 }, immediateCondition = function(cond) {
[17:47:07.572]                   save_rds <- function (object, pathname, ...) 
[17:47:07.572]                   {
[17:47:07.572]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.572]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.572]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.572]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.572]                         fi_tmp[["mtime"]])
[17:47:07.572]                     }
[17:47:07.572]                     tryCatch({
[17:47:07.572]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.572]                     }, error = function(ex) {
[17:47:07.572]                       msg <- conditionMessage(ex)
[17:47:07.572]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.572]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.572]                         fi_tmp[["mtime"]], msg)
[17:47:07.572]                       ex$message <- msg
[17:47:07.572]                       stop(ex)
[17:47:07.572]                     })
[17:47:07.572]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.572]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.572]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.572]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.572]                       fi <- file.info(pathname)
[17:47:07.572]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.572]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.572]                         fi[["size"]], fi[["mtime"]])
[17:47:07.572]                       stop(msg)
[17:47:07.572]                     }
[17:47:07.572]                     invisible(pathname)
[17:47:07.572]                   }
[17:47:07.572]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.572]                     rootPath = tempdir()) 
[17:47:07.572]                   {
[17:47:07.572]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.572]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.572]                       tmpdir = path, fileext = ".rds")
[17:47:07.572]                     save_rds(obj, file)
[17:47:07.572]                   }
[17:47:07.572]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.572]                   {
[17:47:07.572]                     inherits <- base::inherits
[17:47:07.572]                     invokeRestart <- base::invokeRestart
[17:47:07.572]                     is.null <- base::is.null
[17:47:07.572]                     muffled <- FALSE
[17:47:07.572]                     if (inherits(cond, "message")) {
[17:47:07.572]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.572]                       if (muffled) 
[17:47:07.572]                         invokeRestart("muffleMessage")
[17:47:07.572]                     }
[17:47:07.572]                     else if (inherits(cond, "warning")) {
[17:47:07.572]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.572]                       if (muffled) 
[17:47:07.572]                         invokeRestart("muffleWarning")
[17:47:07.572]                     }
[17:47:07.572]                     else if (inherits(cond, "condition")) {
[17:47:07.572]                       if (!is.null(pattern)) {
[17:47:07.572]                         computeRestarts <- base::computeRestarts
[17:47:07.572]                         grepl <- base::grepl
[17:47:07.572]                         restarts <- computeRestarts(cond)
[17:47:07.572]                         for (restart in restarts) {
[17:47:07.572]                           name <- restart$name
[17:47:07.572]                           if (is.null(name)) 
[17:47:07.572]                             next
[17:47:07.572]                           if (!grepl(pattern, name)) 
[17:47:07.572]                             next
[17:47:07.572]                           invokeRestart(restart)
[17:47:07.572]                           muffled <- TRUE
[17:47:07.572]                           break
[17:47:07.572]                         }
[17:47:07.572]                       }
[17:47:07.572]                     }
[17:47:07.572]                     invisible(muffled)
[17:47:07.572]                   }
[17:47:07.572]                   muffleCondition(cond)
[17:47:07.572]                 })
[17:47:07.572]             }))
[17:47:07.572]             future::FutureResult(value = ...future.value$value, 
[17:47:07.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.572]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.572]                     ...future.globalenv.names))
[17:47:07.572]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.572]         }, condition = base::local({
[17:47:07.572]             c <- base::c
[17:47:07.572]             inherits <- base::inherits
[17:47:07.572]             invokeRestart <- base::invokeRestart
[17:47:07.572]             length <- base::length
[17:47:07.572]             list <- base::list
[17:47:07.572]             seq.int <- base::seq.int
[17:47:07.572]             signalCondition <- base::signalCondition
[17:47:07.572]             sys.calls <- base::sys.calls
[17:47:07.572]             `[[` <- base::`[[`
[17:47:07.572]             `+` <- base::`+`
[17:47:07.572]             `<<-` <- base::`<<-`
[17:47:07.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.572]                   3L)]
[17:47:07.572]             }
[17:47:07.572]             function(cond) {
[17:47:07.572]                 is_error <- inherits(cond, "error")
[17:47:07.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.572]                   NULL)
[17:47:07.572]                 if (is_error) {
[17:47:07.572]                   sessionInformation <- function() {
[17:47:07.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.572]                       search = base::search(), system = base::Sys.info())
[17:47:07.572]                   }
[17:47:07.572]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.572]                     cond$call), session = sessionInformation(), 
[17:47:07.572]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.572]                   signalCondition(cond)
[17:47:07.572]                 }
[17:47:07.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.572]                 "immediateCondition"))) {
[17:47:07.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.572]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.572]                   if (TRUE && !signal) {
[17:47:07.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.572]                     {
[17:47:07.572]                       inherits <- base::inherits
[17:47:07.572]                       invokeRestart <- base::invokeRestart
[17:47:07.572]                       is.null <- base::is.null
[17:47:07.572]                       muffled <- FALSE
[17:47:07.572]                       if (inherits(cond, "message")) {
[17:47:07.572]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.572]                         if (muffled) 
[17:47:07.572]                           invokeRestart("muffleMessage")
[17:47:07.572]                       }
[17:47:07.572]                       else if (inherits(cond, "warning")) {
[17:47:07.572]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.572]                         if (muffled) 
[17:47:07.572]                           invokeRestart("muffleWarning")
[17:47:07.572]                       }
[17:47:07.572]                       else if (inherits(cond, "condition")) {
[17:47:07.572]                         if (!is.null(pattern)) {
[17:47:07.572]                           computeRestarts <- base::computeRestarts
[17:47:07.572]                           grepl <- base::grepl
[17:47:07.572]                           restarts <- computeRestarts(cond)
[17:47:07.572]                           for (restart in restarts) {
[17:47:07.572]                             name <- restart$name
[17:47:07.572]                             if (is.null(name)) 
[17:47:07.572]                               next
[17:47:07.572]                             if (!grepl(pattern, name)) 
[17:47:07.572]                               next
[17:47:07.572]                             invokeRestart(restart)
[17:47:07.572]                             muffled <- TRUE
[17:47:07.572]                             break
[17:47:07.572]                           }
[17:47:07.572]                         }
[17:47:07.572]                       }
[17:47:07.572]                       invisible(muffled)
[17:47:07.572]                     }
[17:47:07.572]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.572]                   }
[17:47:07.572]                 }
[17:47:07.572]                 else {
[17:47:07.572]                   if (TRUE) {
[17:47:07.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.572]                     {
[17:47:07.572]                       inherits <- base::inherits
[17:47:07.572]                       invokeRestart <- base::invokeRestart
[17:47:07.572]                       is.null <- base::is.null
[17:47:07.572]                       muffled <- FALSE
[17:47:07.572]                       if (inherits(cond, "message")) {
[17:47:07.572]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.572]                         if (muffled) 
[17:47:07.572]                           invokeRestart("muffleMessage")
[17:47:07.572]                       }
[17:47:07.572]                       else if (inherits(cond, "warning")) {
[17:47:07.572]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.572]                         if (muffled) 
[17:47:07.572]                           invokeRestart("muffleWarning")
[17:47:07.572]                       }
[17:47:07.572]                       else if (inherits(cond, "condition")) {
[17:47:07.572]                         if (!is.null(pattern)) {
[17:47:07.572]                           computeRestarts <- base::computeRestarts
[17:47:07.572]                           grepl <- base::grepl
[17:47:07.572]                           restarts <- computeRestarts(cond)
[17:47:07.572]                           for (restart in restarts) {
[17:47:07.572]                             name <- restart$name
[17:47:07.572]                             if (is.null(name)) 
[17:47:07.572]                               next
[17:47:07.572]                             if (!grepl(pattern, name)) 
[17:47:07.572]                               next
[17:47:07.572]                             invokeRestart(restart)
[17:47:07.572]                             muffled <- TRUE
[17:47:07.572]                             break
[17:47:07.572]                           }
[17:47:07.572]                         }
[17:47:07.572]                       }
[17:47:07.572]                       invisible(muffled)
[17:47:07.572]                     }
[17:47:07.572]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.572]                   }
[17:47:07.572]                 }
[17:47:07.572]             }
[17:47:07.572]         }))
[17:47:07.572]     }, error = function(ex) {
[17:47:07.572]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.572]                 ...future.rng), started = ...future.startTime, 
[17:47:07.572]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.572]             version = "1.8"), class = "FutureResult")
[17:47:07.572]     }, finally = {
[17:47:07.572]         if (!identical(...future.workdir, getwd())) 
[17:47:07.572]             setwd(...future.workdir)
[17:47:07.572]         {
[17:47:07.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.572]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.572]             }
[17:47:07.572]             base::options(...future.oldOptions)
[17:47:07.572]             if (.Platform$OS.type == "windows") {
[17:47:07.572]                 old_names <- names(...future.oldEnvVars)
[17:47:07.572]                 envs <- base::Sys.getenv()
[17:47:07.572]                 names <- names(envs)
[17:47:07.572]                 common <- intersect(names, old_names)
[17:47:07.572]                 added <- setdiff(names, old_names)
[17:47:07.572]                 removed <- setdiff(old_names, names)
[17:47:07.572]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.572]                   envs[common]]
[17:47:07.572]                 NAMES <- toupper(changed)
[17:47:07.572]                 args <- list()
[17:47:07.572]                 for (kk in seq_along(NAMES)) {
[17:47:07.572]                   name <- changed[[kk]]
[17:47:07.572]                   NAME <- NAMES[[kk]]
[17:47:07.572]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.572]                     next
[17:47:07.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.572]                 }
[17:47:07.572]                 NAMES <- toupper(added)
[17:47:07.572]                 for (kk in seq_along(NAMES)) {
[17:47:07.572]                   name <- added[[kk]]
[17:47:07.572]                   NAME <- NAMES[[kk]]
[17:47:07.572]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.572]                     next
[17:47:07.572]                   args[[name]] <- ""
[17:47:07.572]                 }
[17:47:07.572]                 NAMES <- toupper(removed)
[17:47:07.572]                 for (kk in seq_along(NAMES)) {
[17:47:07.572]                   name <- removed[[kk]]
[17:47:07.572]                   NAME <- NAMES[[kk]]
[17:47:07.572]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.572]                     next
[17:47:07.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.572]                 }
[17:47:07.572]                 if (length(args) > 0) 
[17:47:07.572]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.572]             }
[17:47:07.572]             else {
[17:47:07.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.572]             }
[17:47:07.572]             {
[17:47:07.572]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.572]                   0L) {
[17:47:07.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.572]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.572]                   base::options(opts)
[17:47:07.572]                 }
[17:47:07.572]                 {
[17:47:07.572]                   {
[17:47:07.572]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.572]                     NULL
[17:47:07.572]                   }
[17:47:07.572]                   options(future.plan = NULL)
[17:47:07.572]                   if (is.na(NA_character_)) 
[17:47:07.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.572]                     .init = FALSE)
[17:47:07.572]                 }
[17:47:07.572]             }
[17:47:07.572]         }
[17:47:07.572]     })
[17:47:07.572]     if (TRUE) {
[17:47:07.572]         base::sink(type = "output", split = FALSE)
[17:47:07.572]         if (TRUE) {
[17:47:07.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.572]         }
[17:47:07.572]         else {
[17:47:07.572]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.572]         }
[17:47:07.572]         base::close(...future.stdout)
[17:47:07.572]         ...future.stdout <- NULL
[17:47:07.572]     }
[17:47:07.572]     ...future.result$conditions <- ...future.conditions
[17:47:07.572]     ...future.result$finished <- base::Sys.time()
[17:47:07.572]     ...future.result
[17:47:07.572] }
[17:47:07.574] assign_globals() ...
[17:47:07.574] List of 2
[17:47:07.574]  $ a : num 1
[17:47:07.574]  $ ii: int 1
[17:47:07.574]  - attr(*, "where")=List of 2
[17:47:07.574]   ..$ a :<environment: R_EmptyEnv> 
[17:47:07.574]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:07.574]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.574]  - attr(*, "resolved")= logi TRUE
[17:47:07.574]  - attr(*, "total_size")= num 112
[17:47:07.574]  - attr(*, "already-done")= logi TRUE
[17:47:07.577] - copied ‘a’ to environment
[17:47:07.578] - copied ‘ii’ to environment
[17:47:07.578] assign_globals() ... done
[17:47:07.578] requestCore(): workers = 2
[17:47:07.580] MulticoreFuture started
[17:47:07.580] - Launch lazy future ... done
[17:47:07.580] run() for ‘MulticoreFuture’ ... done
[17:47:07.581] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.582] getGlobalsAndPackages() ...
[17:47:07.581] List of future strategies:
[17:47:07.581] 1. sequential:
[17:47:07.581]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.581]    - tweaked: FALSE
[17:47:07.581]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.582] Searching for globals...
[17:47:07.582] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.584] plan(): Setting new future strategy stack:
[17:47:07.584] List of future strategies:
[17:47:07.584] 1. multicore:
[17:47:07.584]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.584]    - tweaked: FALSE
[17:47:07.584]    - call: plan(strategy)
[17:47:07.586] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.589] plan(): nbrOfWorkers() = 2
[17:47:07.589] Searching for globals ... DONE
[17:47:07.590] Resolving globals: TRUE
[17:47:07.590] Resolving any globals that are futures ...
[17:47:07.590] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.591] Resolving any globals that are futures ... DONE
[17:47:07.592] Resolving futures part of globals (recursively) ...
[17:47:07.593] resolve() on list ...
[17:47:07.593]  recursive: 99
[17:47:07.594]  length: 2
[17:47:07.594]  elements: ‘a’, ‘ii’
[17:47:07.594]  length: 1 (resolved future 1)
[17:47:07.595]  length: 0 (resolved future 2)
[17:47:07.595] resolve() on list ... DONE
[17:47:07.595] - globals: [2] ‘a’, ‘ii’
[17:47:07.595] Resolving futures part of globals (recursively) ... DONE
[17:47:07.596] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:07.596] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.597] - globals: [2] ‘a’, ‘ii’
[17:47:07.597] 
[17:47:07.597] getGlobalsAndPackages() ... DONE
[17:47:07.597] run() for ‘Future’ ...
[17:47:07.597] - state: ‘created’
[17:47:07.598] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.602] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.602] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.603]   - Field: ‘label’
[17:47:07.603]   - Field: ‘local’
[17:47:07.603]   - Field: ‘owner’
[17:47:07.603]   - Field: ‘envir’
[17:47:07.603]   - Field: ‘workers’
[17:47:07.603]   - Field: ‘packages’
[17:47:07.604]   - Field: ‘gc’
[17:47:07.604]   - Field: ‘job’
[17:47:07.604]   - Field: ‘conditions’
[17:47:07.604]   - Field: ‘expr’
[17:47:07.604]   - Field: ‘uuid’
[17:47:07.604]   - Field: ‘seed’
[17:47:07.604]   - Field: ‘version’
[17:47:07.605]   - Field: ‘result’
[17:47:07.605]   - Field: ‘asynchronous’
[17:47:07.605]   - Field: ‘calls’
[17:47:07.605]   - Field: ‘globals’
[17:47:07.605]   - Field: ‘stdout’
[17:47:07.605]   - Field: ‘earlySignal’
[17:47:07.605]   - Field: ‘lazy’
[17:47:07.605]   - Field: ‘state’
[17:47:07.606] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.606] - Launch lazy future ...
[17:47:07.606] Packages needed by the future expression (n = 0): <none>
[17:47:07.606] Packages needed by future strategies (n = 0): <none>
[17:47:07.607] {
[17:47:07.607]     {
[17:47:07.607]         {
[17:47:07.607]             ...future.startTime <- base::Sys.time()
[17:47:07.607]             {
[17:47:07.607]                 {
[17:47:07.607]                   {
[17:47:07.607]                     {
[17:47:07.607]                       base::local({
[17:47:07.607]                         has_future <- base::requireNamespace("future", 
[17:47:07.607]                           quietly = TRUE)
[17:47:07.607]                         if (has_future) {
[17:47:07.607]                           ns <- base::getNamespace("future")
[17:47:07.607]                           version <- ns[[".package"]][["version"]]
[17:47:07.607]                           if (is.null(version)) 
[17:47:07.607]                             version <- utils::packageVersion("future")
[17:47:07.607]                         }
[17:47:07.607]                         else {
[17:47:07.607]                           version <- NULL
[17:47:07.607]                         }
[17:47:07.607]                         if (!has_future || version < "1.8.0") {
[17:47:07.607]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.607]                             "", base::R.version$version.string), 
[17:47:07.607]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.607]                               "release", "version")], collapse = " "), 
[17:47:07.607]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.607]                             info)
[17:47:07.607]                           info <- base::paste(info, collapse = "; ")
[17:47:07.607]                           if (!has_future) {
[17:47:07.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.607]                               info)
[17:47:07.607]                           }
[17:47:07.607]                           else {
[17:47:07.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.607]                               info, version)
[17:47:07.607]                           }
[17:47:07.607]                           base::stop(msg)
[17:47:07.607]                         }
[17:47:07.607]                       })
[17:47:07.607]                     }
[17:47:07.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.607]                     base::options(mc.cores = 1L)
[17:47:07.607]                   }
[17:47:07.607]                   ...future.strategy.old <- future::plan("list")
[17:47:07.607]                   options(future.plan = NULL)
[17:47:07.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.607]                 }
[17:47:07.607]                 ...future.workdir <- getwd()
[17:47:07.607]             }
[17:47:07.607]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.607]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.607]         }
[17:47:07.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.607]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.607]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.607]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.607]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.607]             base::names(...future.oldOptions))
[17:47:07.607]     }
[17:47:07.607]     if (FALSE) {
[17:47:07.607]     }
[17:47:07.607]     else {
[17:47:07.607]         if (TRUE) {
[17:47:07.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.607]                 open = "w")
[17:47:07.607]         }
[17:47:07.607]         else {
[17:47:07.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.607]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.607]         }
[17:47:07.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.607]             base::sink(type = "output", split = FALSE)
[17:47:07.607]             base::close(...future.stdout)
[17:47:07.607]         }, add = TRUE)
[17:47:07.607]     }
[17:47:07.607]     ...future.frame <- base::sys.nframe()
[17:47:07.607]     ...future.conditions <- base::list()
[17:47:07.607]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.607]     if (FALSE) {
[17:47:07.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.607]     }
[17:47:07.607]     ...future.result <- base::tryCatch({
[17:47:07.607]         base::withCallingHandlers({
[17:47:07.607]             ...future.value <- base::withVisible(base::local({
[17:47:07.607]                 withCallingHandlers({
[17:47:07.607]                   {
[17:47:07.607]                     b <- a * ii
[17:47:07.607]                     a <- 0
[17:47:07.607]                     b
[17:47:07.607]                   }
[17:47:07.607]                 }, immediateCondition = function(cond) {
[17:47:07.607]                   save_rds <- function (object, pathname, ...) 
[17:47:07.607]                   {
[17:47:07.607]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.607]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.607]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.607]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.607]                         fi_tmp[["mtime"]])
[17:47:07.607]                     }
[17:47:07.607]                     tryCatch({
[17:47:07.607]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.607]                     }, error = function(ex) {
[17:47:07.607]                       msg <- conditionMessage(ex)
[17:47:07.607]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.607]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.607]                         fi_tmp[["mtime"]], msg)
[17:47:07.607]                       ex$message <- msg
[17:47:07.607]                       stop(ex)
[17:47:07.607]                     })
[17:47:07.607]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.607]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.607]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.607]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.607]                       fi <- file.info(pathname)
[17:47:07.607]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.607]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.607]                         fi[["size"]], fi[["mtime"]])
[17:47:07.607]                       stop(msg)
[17:47:07.607]                     }
[17:47:07.607]                     invisible(pathname)
[17:47:07.607]                   }
[17:47:07.607]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.607]                     rootPath = tempdir()) 
[17:47:07.607]                   {
[17:47:07.607]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.607]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.607]                       tmpdir = path, fileext = ".rds")
[17:47:07.607]                     save_rds(obj, file)
[17:47:07.607]                   }
[17:47:07.607]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.607]                   {
[17:47:07.607]                     inherits <- base::inherits
[17:47:07.607]                     invokeRestart <- base::invokeRestart
[17:47:07.607]                     is.null <- base::is.null
[17:47:07.607]                     muffled <- FALSE
[17:47:07.607]                     if (inherits(cond, "message")) {
[17:47:07.607]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.607]                       if (muffled) 
[17:47:07.607]                         invokeRestart("muffleMessage")
[17:47:07.607]                     }
[17:47:07.607]                     else if (inherits(cond, "warning")) {
[17:47:07.607]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.607]                       if (muffled) 
[17:47:07.607]                         invokeRestart("muffleWarning")
[17:47:07.607]                     }
[17:47:07.607]                     else if (inherits(cond, "condition")) {
[17:47:07.607]                       if (!is.null(pattern)) {
[17:47:07.607]                         computeRestarts <- base::computeRestarts
[17:47:07.607]                         grepl <- base::grepl
[17:47:07.607]                         restarts <- computeRestarts(cond)
[17:47:07.607]                         for (restart in restarts) {
[17:47:07.607]                           name <- restart$name
[17:47:07.607]                           if (is.null(name)) 
[17:47:07.607]                             next
[17:47:07.607]                           if (!grepl(pattern, name)) 
[17:47:07.607]                             next
[17:47:07.607]                           invokeRestart(restart)
[17:47:07.607]                           muffled <- TRUE
[17:47:07.607]                           break
[17:47:07.607]                         }
[17:47:07.607]                       }
[17:47:07.607]                     }
[17:47:07.607]                     invisible(muffled)
[17:47:07.607]                   }
[17:47:07.607]                   muffleCondition(cond)
[17:47:07.607]                 })
[17:47:07.607]             }))
[17:47:07.607]             future::FutureResult(value = ...future.value$value, 
[17:47:07.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.607]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.607]                     ...future.globalenv.names))
[17:47:07.607]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.607]         }, condition = base::local({
[17:47:07.607]             c <- base::c
[17:47:07.607]             inherits <- base::inherits
[17:47:07.607]             invokeRestart <- base::invokeRestart
[17:47:07.607]             length <- base::length
[17:47:07.607]             list <- base::list
[17:47:07.607]             seq.int <- base::seq.int
[17:47:07.607]             signalCondition <- base::signalCondition
[17:47:07.607]             sys.calls <- base::sys.calls
[17:47:07.607]             `[[` <- base::`[[`
[17:47:07.607]             `+` <- base::`+`
[17:47:07.607]             `<<-` <- base::`<<-`
[17:47:07.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.607]                   3L)]
[17:47:07.607]             }
[17:47:07.607]             function(cond) {
[17:47:07.607]                 is_error <- inherits(cond, "error")
[17:47:07.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.607]                   NULL)
[17:47:07.607]                 if (is_error) {
[17:47:07.607]                   sessionInformation <- function() {
[17:47:07.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.607]                       search = base::search(), system = base::Sys.info())
[17:47:07.607]                   }
[17:47:07.607]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.607]                     cond$call), session = sessionInformation(), 
[17:47:07.607]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.607]                   signalCondition(cond)
[17:47:07.607]                 }
[17:47:07.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.607]                 "immediateCondition"))) {
[17:47:07.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.607]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.607]                   if (TRUE && !signal) {
[17:47:07.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.607]                     {
[17:47:07.607]                       inherits <- base::inherits
[17:47:07.607]                       invokeRestart <- base::invokeRestart
[17:47:07.607]                       is.null <- base::is.null
[17:47:07.607]                       muffled <- FALSE
[17:47:07.607]                       if (inherits(cond, "message")) {
[17:47:07.607]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.607]                         if (muffled) 
[17:47:07.607]                           invokeRestart("muffleMessage")
[17:47:07.607]                       }
[17:47:07.607]                       else if (inherits(cond, "warning")) {
[17:47:07.607]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.607]                         if (muffled) 
[17:47:07.607]                           invokeRestart("muffleWarning")
[17:47:07.607]                       }
[17:47:07.607]                       else if (inherits(cond, "condition")) {
[17:47:07.607]                         if (!is.null(pattern)) {
[17:47:07.607]                           computeRestarts <- base::computeRestarts
[17:47:07.607]                           grepl <- base::grepl
[17:47:07.607]                           restarts <- computeRestarts(cond)
[17:47:07.607]                           for (restart in restarts) {
[17:47:07.607]                             name <- restart$name
[17:47:07.607]                             if (is.null(name)) 
[17:47:07.607]                               next
[17:47:07.607]                             if (!grepl(pattern, name)) 
[17:47:07.607]                               next
[17:47:07.607]                             invokeRestart(restart)
[17:47:07.607]                             muffled <- TRUE
[17:47:07.607]                             break
[17:47:07.607]                           }
[17:47:07.607]                         }
[17:47:07.607]                       }
[17:47:07.607]                       invisible(muffled)
[17:47:07.607]                     }
[17:47:07.607]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.607]                   }
[17:47:07.607]                 }
[17:47:07.607]                 else {
[17:47:07.607]                   if (TRUE) {
[17:47:07.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.607]                     {
[17:47:07.607]                       inherits <- base::inherits
[17:47:07.607]                       invokeRestart <- base::invokeRestart
[17:47:07.607]                       is.null <- base::is.null
[17:47:07.607]                       muffled <- FALSE
[17:47:07.607]                       if (inherits(cond, "message")) {
[17:47:07.607]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.607]                         if (muffled) 
[17:47:07.607]                           invokeRestart("muffleMessage")
[17:47:07.607]                       }
[17:47:07.607]                       else if (inherits(cond, "warning")) {
[17:47:07.607]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.607]                         if (muffled) 
[17:47:07.607]                           invokeRestart("muffleWarning")
[17:47:07.607]                       }
[17:47:07.607]                       else if (inherits(cond, "condition")) {
[17:47:07.607]                         if (!is.null(pattern)) {
[17:47:07.607]                           computeRestarts <- base::computeRestarts
[17:47:07.607]                           grepl <- base::grepl
[17:47:07.607]                           restarts <- computeRestarts(cond)
[17:47:07.607]                           for (restart in restarts) {
[17:47:07.607]                             name <- restart$name
[17:47:07.607]                             if (is.null(name)) 
[17:47:07.607]                               next
[17:47:07.607]                             if (!grepl(pattern, name)) 
[17:47:07.607]                               next
[17:47:07.607]                             invokeRestart(restart)
[17:47:07.607]                             muffled <- TRUE
[17:47:07.607]                             break
[17:47:07.607]                           }
[17:47:07.607]                         }
[17:47:07.607]                       }
[17:47:07.607]                       invisible(muffled)
[17:47:07.607]                     }
[17:47:07.607]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.607]                   }
[17:47:07.607]                 }
[17:47:07.607]             }
[17:47:07.607]         }))
[17:47:07.607]     }, error = function(ex) {
[17:47:07.607]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.607]                 ...future.rng), started = ...future.startTime, 
[17:47:07.607]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.607]             version = "1.8"), class = "FutureResult")
[17:47:07.607]     }, finally = {
[17:47:07.607]         if (!identical(...future.workdir, getwd())) 
[17:47:07.607]             setwd(...future.workdir)
[17:47:07.607]         {
[17:47:07.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.607]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.607]             }
[17:47:07.607]             base::options(...future.oldOptions)
[17:47:07.607]             if (.Platform$OS.type == "windows") {
[17:47:07.607]                 old_names <- names(...future.oldEnvVars)
[17:47:07.607]                 envs <- base::Sys.getenv()
[17:47:07.607]                 names <- names(envs)
[17:47:07.607]                 common <- intersect(names, old_names)
[17:47:07.607]                 added <- setdiff(names, old_names)
[17:47:07.607]                 removed <- setdiff(old_names, names)
[17:47:07.607]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.607]                   envs[common]]
[17:47:07.607]                 NAMES <- toupper(changed)
[17:47:07.607]                 args <- list()
[17:47:07.607]                 for (kk in seq_along(NAMES)) {
[17:47:07.607]                   name <- changed[[kk]]
[17:47:07.607]                   NAME <- NAMES[[kk]]
[17:47:07.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.607]                     next
[17:47:07.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.607]                 }
[17:47:07.607]                 NAMES <- toupper(added)
[17:47:07.607]                 for (kk in seq_along(NAMES)) {
[17:47:07.607]                   name <- added[[kk]]
[17:47:07.607]                   NAME <- NAMES[[kk]]
[17:47:07.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.607]                     next
[17:47:07.607]                   args[[name]] <- ""
[17:47:07.607]                 }
[17:47:07.607]                 NAMES <- toupper(removed)
[17:47:07.607]                 for (kk in seq_along(NAMES)) {
[17:47:07.607]                   name <- removed[[kk]]
[17:47:07.607]                   NAME <- NAMES[[kk]]
[17:47:07.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.607]                     next
[17:47:07.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.607]                 }
[17:47:07.607]                 if (length(args) > 0) 
[17:47:07.607]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.607]             }
[17:47:07.607]             else {
[17:47:07.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.607]             }
[17:47:07.607]             {
[17:47:07.607]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.607]                   0L) {
[17:47:07.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.607]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.607]                   base::options(opts)
[17:47:07.607]                 }
[17:47:07.607]                 {
[17:47:07.607]                   {
[17:47:07.607]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.607]                     NULL
[17:47:07.607]                   }
[17:47:07.607]                   options(future.plan = NULL)
[17:47:07.607]                   if (is.na(NA_character_)) 
[17:47:07.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.607]                     .init = FALSE)
[17:47:07.607]                 }
[17:47:07.607]             }
[17:47:07.607]         }
[17:47:07.607]     })
[17:47:07.607]     if (TRUE) {
[17:47:07.607]         base::sink(type = "output", split = FALSE)
[17:47:07.607]         if (TRUE) {
[17:47:07.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.607]         }
[17:47:07.607]         else {
[17:47:07.607]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.607]         }
[17:47:07.607]         base::close(...future.stdout)
[17:47:07.607]         ...future.stdout <- NULL
[17:47:07.607]     }
[17:47:07.607]     ...future.result$conditions <- ...future.conditions
[17:47:07.607]     ...future.result$finished <- base::Sys.time()
[17:47:07.607]     ...future.result
[17:47:07.607] }
[17:47:07.610] assign_globals() ...
[17:47:07.610] List of 2
[17:47:07.610]  $ a : num 1
[17:47:07.610]  $ ii: int 2
[17:47:07.610]  - attr(*, "where")=List of 2
[17:47:07.610]   ..$ a :<environment: R_EmptyEnv> 
[17:47:07.610]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:07.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.610]  - attr(*, "resolved")= logi TRUE
[17:47:07.610]  - attr(*, "total_size")= num 112
[17:47:07.610]  - attr(*, "already-done")= logi TRUE
[17:47:07.614] - copied ‘a’ to environment
[17:47:07.614] - copied ‘ii’ to environment
[17:47:07.614] assign_globals() ... done
[17:47:07.614] requestCore(): workers = 2
[17:47:07.617] MulticoreFuture started
[17:47:07.617] - Launch lazy future ... done
[17:47:07.617] run() for ‘MulticoreFuture’ ... done
[17:47:07.618] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.619] getGlobalsAndPackages() ...
[17:47:07.618] List of future strategies:
[17:47:07.618] 1. sequential:
[17:47:07.618]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.618]    - tweaked: FALSE
[17:47:07.618]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.619] Searching for globals...
[17:47:07.619] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.621] plan(): Setting new future strategy stack:
[17:47:07.621] List of future strategies:
[17:47:07.621] 1. multicore:
[17:47:07.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.621]    - tweaked: FALSE
[17:47:07.621]    - call: plan(strategy)
[17:47:07.623] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.623] Searching for globals ... DONE
[17:47:07.623] Resolving globals: TRUE
[17:47:07.623] Resolving any globals that are futures ...
[17:47:07.623] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.624] Resolving any globals that are futures ... DONE
[17:47:07.624] Resolving futures part of globals (recursively) ...
[17:47:07.625] resolve() on list ...
[17:47:07.625]  recursive: 99
[17:47:07.625]  length: 2
[17:47:07.625]  elements: ‘a’, ‘ii’
[17:47:07.625]  length: 1 (resolved future 1)
[17:47:07.626]  length: 0 (resolved future 2)
[17:47:07.626] resolve() on list ... DONE
[17:47:07.626] - globals: [2] ‘a’, ‘ii’
[17:47:07.626] plan(): nbrOfWorkers() = 2
[17:47:07.626] Resolving futures part of globals (recursively) ... DONE
[17:47:07.626] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:07.627] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.627] - globals: [2] ‘a’, ‘ii’
[17:47:07.627] 
[17:47:07.628] getGlobalsAndPackages() ... DONE
[17:47:07.628] run() for ‘Future’ ...
[17:47:07.628] - state: ‘created’
[17:47:07.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.637] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.638] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.638]   - Field: ‘label’
[17:47:07.638]   - Field: ‘local’
[17:47:07.639]   - Field: ‘owner’
[17:47:07.639]   - Field: ‘envir’
[17:47:07.639]   - Field: ‘workers’
[17:47:07.639]   - Field: ‘packages’
[17:47:07.639]   - Field: ‘gc’
[17:47:07.640]   - Field: ‘job’
[17:47:07.640]   - Field: ‘conditions’
[17:47:07.640]   - Field: ‘expr’
[17:47:07.640]   - Field: ‘uuid’
[17:47:07.640]   - Field: ‘seed’
[17:47:07.640]   - Field: ‘version’
[17:47:07.641]   - Field: ‘result’
[17:47:07.641]   - Field: ‘asynchronous’
[17:47:07.641]   - Field: ‘calls’
[17:47:07.641]   - Field: ‘globals’
[17:47:07.641]   - Field: ‘stdout’
[17:47:07.641]   - Field: ‘earlySignal’
[17:47:07.642]   - Field: ‘lazy’
[17:47:07.642]   - Field: ‘state’
[17:47:07.642] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.642] - Launch lazy future ...
[17:47:07.642] Packages needed by the future expression (n = 0): <none>
[17:47:07.643] Packages needed by future strategies (n = 0): <none>
[17:47:07.643] {
[17:47:07.643]     {
[17:47:07.643]         {
[17:47:07.643]             ...future.startTime <- base::Sys.time()
[17:47:07.643]             {
[17:47:07.643]                 {
[17:47:07.643]                   {
[17:47:07.643]                     {
[17:47:07.643]                       base::local({
[17:47:07.643]                         has_future <- base::requireNamespace("future", 
[17:47:07.643]                           quietly = TRUE)
[17:47:07.643]                         if (has_future) {
[17:47:07.643]                           ns <- base::getNamespace("future")
[17:47:07.643]                           version <- ns[[".package"]][["version"]]
[17:47:07.643]                           if (is.null(version)) 
[17:47:07.643]                             version <- utils::packageVersion("future")
[17:47:07.643]                         }
[17:47:07.643]                         else {
[17:47:07.643]                           version <- NULL
[17:47:07.643]                         }
[17:47:07.643]                         if (!has_future || version < "1.8.0") {
[17:47:07.643]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.643]                             "", base::R.version$version.string), 
[17:47:07.643]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.643]                               "release", "version")], collapse = " "), 
[17:47:07.643]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.643]                             info)
[17:47:07.643]                           info <- base::paste(info, collapse = "; ")
[17:47:07.643]                           if (!has_future) {
[17:47:07.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.643]                               info)
[17:47:07.643]                           }
[17:47:07.643]                           else {
[17:47:07.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.643]                               info, version)
[17:47:07.643]                           }
[17:47:07.643]                           base::stop(msg)
[17:47:07.643]                         }
[17:47:07.643]                       })
[17:47:07.643]                     }
[17:47:07.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.643]                     base::options(mc.cores = 1L)
[17:47:07.643]                   }
[17:47:07.643]                   ...future.strategy.old <- future::plan("list")
[17:47:07.643]                   options(future.plan = NULL)
[17:47:07.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.643]                 }
[17:47:07.643]                 ...future.workdir <- getwd()
[17:47:07.643]             }
[17:47:07.643]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.643]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.643]         }
[17:47:07.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.643]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.643]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.643]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.643]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.643]             base::names(...future.oldOptions))
[17:47:07.643]     }
[17:47:07.643]     if (FALSE) {
[17:47:07.643]     }
[17:47:07.643]     else {
[17:47:07.643]         if (TRUE) {
[17:47:07.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.643]                 open = "w")
[17:47:07.643]         }
[17:47:07.643]         else {
[17:47:07.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.643]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.643]         }
[17:47:07.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.643]             base::sink(type = "output", split = FALSE)
[17:47:07.643]             base::close(...future.stdout)
[17:47:07.643]         }, add = TRUE)
[17:47:07.643]     }
[17:47:07.643]     ...future.frame <- base::sys.nframe()
[17:47:07.643]     ...future.conditions <- base::list()
[17:47:07.643]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.643]     if (FALSE) {
[17:47:07.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.643]     }
[17:47:07.643]     ...future.result <- base::tryCatch({
[17:47:07.643]         base::withCallingHandlers({
[17:47:07.643]             ...future.value <- base::withVisible(base::local({
[17:47:07.643]                 withCallingHandlers({
[17:47:07.643]                   {
[17:47:07.643]                     b <- a * ii
[17:47:07.643]                     a <- 0
[17:47:07.643]                     b
[17:47:07.643]                   }
[17:47:07.643]                 }, immediateCondition = function(cond) {
[17:47:07.643]                   save_rds <- function (object, pathname, ...) 
[17:47:07.643]                   {
[17:47:07.643]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.643]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.643]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.643]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.643]                         fi_tmp[["mtime"]])
[17:47:07.643]                     }
[17:47:07.643]                     tryCatch({
[17:47:07.643]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.643]                     }, error = function(ex) {
[17:47:07.643]                       msg <- conditionMessage(ex)
[17:47:07.643]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.643]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.643]                         fi_tmp[["mtime"]], msg)
[17:47:07.643]                       ex$message <- msg
[17:47:07.643]                       stop(ex)
[17:47:07.643]                     })
[17:47:07.643]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.643]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.643]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.643]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.643]                       fi <- file.info(pathname)
[17:47:07.643]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.643]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.643]                         fi[["size"]], fi[["mtime"]])
[17:47:07.643]                       stop(msg)
[17:47:07.643]                     }
[17:47:07.643]                     invisible(pathname)
[17:47:07.643]                   }
[17:47:07.643]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.643]                     rootPath = tempdir()) 
[17:47:07.643]                   {
[17:47:07.643]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.643]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.643]                       tmpdir = path, fileext = ".rds")
[17:47:07.643]                     save_rds(obj, file)
[17:47:07.643]                   }
[17:47:07.643]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.643]                   {
[17:47:07.643]                     inherits <- base::inherits
[17:47:07.643]                     invokeRestart <- base::invokeRestart
[17:47:07.643]                     is.null <- base::is.null
[17:47:07.643]                     muffled <- FALSE
[17:47:07.643]                     if (inherits(cond, "message")) {
[17:47:07.643]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.643]                       if (muffled) 
[17:47:07.643]                         invokeRestart("muffleMessage")
[17:47:07.643]                     }
[17:47:07.643]                     else if (inherits(cond, "warning")) {
[17:47:07.643]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.643]                       if (muffled) 
[17:47:07.643]                         invokeRestart("muffleWarning")
[17:47:07.643]                     }
[17:47:07.643]                     else if (inherits(cond, "condition")) {
[17:47:07.643]                       if (!is.null(pattern)) {
[17:47:07.643]                         computeRestarts <- base::computeRestarts
[17:47:07.643]                         grepl <- base::grepl
[17:47:07.643]                         restarts <- computeRestarts(cond)
[17:47:07.643]                         for (restart in restarts) {
[17:47:07.643]                           name <- restart$name
[17:47:07.643]                           if (is.null(name)) 
[17:47:07.643]                             next
[17:47:07.643]                           if (!grepl(pattern, name)) 
[17:47:07.643]                             next
[17:47:07.643]                           invokeRestart(restart)
[17:47:07.643]                           muffled <- TRUE
[17:47:07.643]                           break
[17:47:07.643]                         }
[17:47:07.643]                       }
[17:47:07.643]                     }
[17:47:07.643]                     invisible(muffled)
[17:47:07.643]                   }
[17:47:07.643]                   muffleCondition(cond)
[17:47:07.643]                 })
[17:47:07.643]             }))
[17:47:07.643]             future::FutureResult(value = ...future.value$value, 
[17:47:07.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.643]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.643]                     ...future.globalenv.names))
[17:47:07.643]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.643]         }, condition = base::local({
[17:47:07.643]             c <- base::c
[17:47:07.643]             inherits <- base::inherits
[17:47:07.643]             invokeRestart <- base::invokeRestart
[17:47:07.643]             length <- base::length
[17:47:07.643]             list <- base::list
[17:47:07.643]             seq.int <- base::seq.int
[17:47:07.643]             signalCondition <- base::signalCondition
[17:47:07.643]             sys.calls <- base::sys.calls
[17:47:07.643]             `[[` <- base::`[[`
[17:47:07.643]             `+` <- base::`+`
[17:47:07.643]             `<<-` <- base::`<<-`
[17:47:07.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.643]                   3L)]
[17:47:07.643]             }
[17:47:07.643]             function(cond) {
[17:47:07.643]                 is_error <- inherits(cond, "error")
[17:47:07.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.643]                   NULL)
[17:47:07.643]                 if (is_error) {
[17:47:07.643]                   sessionInformation <- function() {
[17:47:07.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.643]                       search = base::search(), system = base::Sys.info())
[17:47:07.643]                   }
[17:47:07.643]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.643]                     cond$call), session = sessionInformation(), 
[17:47:07.643]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.643]                   signalCondition(cond)
[17:47:07.643]                 }
[17:47:07.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.643]                 "immediateCondition"))) {
[17:47:07.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.643]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.643]                   if (TRUE && !signal) {
[17:47:07.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.643]                     {
[17:47:07.643]                       inherits <- base::inherits
[17:47:07.643]                       invokeRestart <- base::invokeRestart
[17:47:07.643]                       is.null <- base::is.null
[17:47:07.643]                       muffled <- FALSE
[17:47:07.643]                       if (inherits(cond, "message")) {
[17:47:07.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.643]                         if (muffled) 
[17:47:07.643]                           invokeRestart("muffleMessage")
[17:47:07.643]                       }
[17:47:07.643]                       else if (inherits(cond, "warning")) {
[17:47:07.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.643]                         if (muffled) 
[17:47:07.643]                           invokeRestart("muffleWarning")
[17:47:07.643]                       }
[17:47:07.643]                       else if (inherits(cond, "condition")) {
[17:47:07.643]                         if (!is.null(pattern)) {
[17:47:07.643]                           computeRestarts <- base::computeRestarts
[17:47:07.643]                           grepl <- base::grepl
[17:47:07.643]                           restarts <- computeRestarts(cond)
[17:47:07.643]                           for (restart in restarts) {
[17:47:07.643]                             name <- restart$name
[17:47:07.643]                             if (is.null(name)) 
[17:47:07.643]                               next
[17:47:07.643]                             if (!grepl(pattern, name)) 
[17:47:07.643]                               next
[17:47:07.643]                             invokeRestart(restart)
[17:47:07.643]                             muffled <- TRUE
[17:47:07.643]                             break
[17:47:07.643]                           }
[17:47:07.643]                         }
[17:47:07.643]                       }
[17:47:07.643]                       invisible(muffled)
[17:47:07.643]                     }
[17:47:07.643]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.643]                   }
[17:47:07.643]                 }
[17:47:07.643]                 else {
[17:47:07.643]                   if (TRUE) {
[17:47:07.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.643]                     {
[17:47:07.643]                       inherits <- base::inherits
[17:47:07.643]                       invokeRestart <- base::invokeRestart
[17:47:07.643]                       is.null <- base::is.null
[17:47:07.643]                       muffled <- FALSE
[17:47:07.643]                       if (inherits(cond, "message")) {
[17:47:07.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.643]                         if (muffled) 
[17:47:07.643]                           invokeRestart("muffleMessage")
[17:47:07.643]                       }
[17:47:07.643]                       else if (inherits(cond, "warning")) {
[17:47:07.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.643]                         if (muffled) 
[17:47:07.643]                           invokeRestart("muffleWarning")
[17:47:07.643]                       }
[17:47:07.643]                       else if (inherits(cond, "condition")) {
[17:47:07.643]                         if (!is.null(pattern)) {
[17:47:07.643]                           computeRestarts <- base::computeRestarts
[17:47:07.643]                           grepl <- base::grepl
[17:47:07.643]                           restarts <- computeRestarts(cond)
[17:47:07.643]                           for (restart in restarts) {
[17:47:07.643]                             name <- restart$name
[17:47:07.643]                             if (is.null(name)) 
[17:47:07.643]                               next
[17:47:07.643]                             if (!grepl(pattern, name)) 
[17:47:07.643]                               next
[17:47:07.643]                             invokeRestart(restart)
[17:47:07.643]                             muffled <- TRUE
[17:47:07.643]                             break
[17:47:07.643]                           }
[17:47:07.643]                         }
[17:47:07.643]                       }
[17:47:07.643]                       invisible(muffled)
[17:47:07.643]                     }
[17:47:07.643]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.643]                   }
[17:47:07.643]                 }
[17:47:07.643]             }
[17:47:07.643]         }))
[17:47:07.643]     }, error = function(ex) {
[17:47:07.643]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.643]                 ...future.rng), started = ...future.startTime, 
[17:47:07.643]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.643]             version = "1.8"), class = "FutureResult")
[17:47:07.643]     }, finally = {
[17:47:07.643]         if (!identical(...future.workdir, getwd())) 
[17:47:07.643]             setwd(...future.workdir)
[17:47:07.643]         {
[17:47:07.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.643]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.643]             }
[17:47:07.643]             base::options(...future.oldOptions)
[17:47:07.643]             if (.Platform$OS.type == "windows") {
[17:47:07.643]                 old_names <- names(...future.oldEnvVars)
[17:47:07.643]                 envs <- base::Sys.getenv()
[17:47:07.643]                 names <- names(envs)
[17:47:07.643]                 common <- intersect(names, old_names)
[17:47:07.643]                 added <- setdiff(names, old_names)
[17:47:07.643]                 removed <- setdiff(old_names, names)
[17:47:07.643]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.643]                   envs[common]]
[17:47:07.643]                 NAMES <- toupper(changed)
[17:47:07.643]                 args <- list()
[17:47:07.643]                 for (kk in seq_along(NAMES)) {
[17:47:07.643]                   name <- changed[[kk]]
[17:47:07.643]                   NAME <- NAMES[[kk]]
[17:47:07.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.643]                     next
[17:47:07.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.643]                 }
[17:47:07.643]                 NAMES <- toupper(added)
[17:47:07.643]                 for (kk in seq_along(NAMES)) {
[17:47:07.643]                   name <- added[[kk]]
[17:47:07.643]                   NAME <- NAMES[[kk]]
[17:47:07.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.643]                     next
[17:47:07.643]                   args[[name]] <- ""
[17:47:07.643]                 }
[17:47:07.643]                 NAMES <- toupper(removed)
[17:47:07.643]                 for (kk in seq_along(NAMES)) {
[17:47:07.643]                   name <- removed[[kk]]
[17:47:07.643]                   NAME <- NAMES[[kk]]
[17:47:07.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.643]                     next
[17:47:07.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.643]                 }
[17:47:07.643]                 if (length(args) > 0) 
[17:47:07.643]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.643]             }
[17:47:07.643]             else {
[17:47:07.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.643]             }
[17:47:07.643]             {
[17:47:07.643]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.643]                   0L) {
[17:47:07.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.643]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.643]                   base::options(opts)
[17:47:07.643]                 }
[17:47:07.643]                 {
[17:47:07.643]                   {
[17:47:07.643]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.643]                     NULL
[17:47:07.643]                   }
[17:47:07.643]                   options(future.plan = NULL)
[17:47:07.643]                   if (is.na(NA_character_)) 
[17:47:07.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.643]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.643]                     .init = FALSE)
[17:47:07.643]                 }
[17:47:07.643]             }
[17:47:07.643]         }
[17:47:07.643]     })
[17:47:07.643]     if (TRUE) {
[17:47:07.643]         base::sink(type = "output", split = FALSE)
[17:47:07.643]         if (TRUE) {
[17:47:07.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.643]         }
[17:47:07.643]         else {
[17:47:07.643]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.643]         }
[17:47:07.643]         base::close(...future.stdout)
[17:47:07.643]         ...future.stdout <- NULL
[17:47:07.643]     }
[17:47:07.643]     ...future.result$conditions <- ...future.conditions
[17:47:07.643]     ...future.result$finished <- base::Sys.time()
[17:47:07.643]     ...future.result
[17:47:07.643] }
[17:47:07.646] assign_globals() ...
[17:47:07.646] List of 2
[17:47:07.646]  $ a : num 1
[17:47:07.646]  $ ii: int 3
[17:47:07.646]  - attr(*, "where")=List of 2
[17:47:07.646]   ..$ a :<environment: R_EmptyEnv> 
[17:47:07.646]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:07.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.646]  - attr(*, "resolved")= logi TRUE
[17:47:07.646]  - attr(*, "total_size")= num 112
[17:47:07.646]  - attr(*, "already-done")= logi TRUE
[17:47:07.650] - copied ‘a’ to environment
[17:47:07.651] - copied ‘ii’ to environment
[17:47:07.651] assign_globals() ... done
[17:47:07.651] requestCore(): workers = 2
[17:47:07.651] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:07.678] result() for MulticoreFuture ...
[17:47:07.679] result() for MulticoreFuture ...
[17:47:07.679] result() for MulticoreFuture ... done
[17:47:07.679] result() for MulticoreFuture ... done
[17:47:07.679] result() for MulticoreFuture ...
[17:47:07.680] result() for MulticoreFuture ... done
[17:47:07.682] MulticoreFuture started
[17:47:07.682] - Launch lazy future ... done
[17:47:07.683] run() for ‘MulticoreFuture’ ... done
[17:47:07.683] plan(): Setting new future strategy stack:
[17:47:07.684] result() for MulticoreFuture ...
[17:47:07.684] result() for MulticoreFuture ... done
[17:47:07.684] List of future strategies:
[17:47:07.684] 1. sequential:
[17:47:07.684]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.684]    - tweaked: FALSE
[17:47:07.684]    - call: NULL
[17:47:07.685] result() for MulticoreFuture ...
[17:47:07.685] result() for MulticoreFuture ... done
[17:47:07.685] plan(): nbrOfWorkers() = 1
[17:47:07.686] result() for MulticoreFuture ...
[17:47:07.687] result() for MulticoreFuture ...
[17:47:07.688] result() for MulticoreFuture ... done
[17:47:07.688] result() for MulticoreFuture ... done
[17:47:07.688] plan(): Setting new future strategy stack:
[17:47:07.688] result() for MulticoreFuture ...
[17:47:07.688] result() for MulticoreFuture ... done
[17:47:07.689] result() for MulticoreFuture ...
[17:47:07.688] List of future strategies:
[17:47:07.688] 1. multicore:
[17:47:07.688]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.688]    - tweaked: FALSE
[17:47:07.688]    - call: plan(strategy)
[17:47:07.695] plan(): nbrOfWorkers() = 2
[17:47:07.696] result() for MulticoreFuture ...
[17:47:07.697] result() for MulticoreFuture ... done
[17:47:07.697] result() for MulticoreFuture ... done
[17:47:07.697] result() for MulticoreFuture ...
[17:47:07.697] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.699] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.700] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.703] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.703] Searching for globals ... DONE
[17:47:07.703] Resolving globals: TRUE
[17:47:07.703] Resolving any globals that are futures ...
[17:47:07.703] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.703] Resolving any globals that are futures ... DONE
[17:47:07.704] Resolving futures part of globals (recursively) ...
[17:47:07.704] resolve() on list ...
[17:47:07.704]  recursive: 99
[17:47:07.704]  length: 2
[17:47:07.704]  elements: ‘a’, ‘ii’
[17:47:07.705]  length: 1 (resolved future 1)
[17:47:07.705]  length: 0 (resolved future 2)
[17:47:07.705] resolve() on list ... DONE
[17:47:07.705] - globals: [2] ‘a’, ‘ii’
[17:47:07.705] Resolving futures part of globals (recursively) ... DONE
[17:47:07.705] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:07.706] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.706] - globals: [2] ‘a’, ‘ii’
[17:47:07.706] 
[17:47:07.706] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.707] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.707] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.709] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.709] Searching for globals ... DONE
[17:47:07.709] Resolving globals: TRUE
[17:47:07.710] Resolving any globals that are futures ...
[17:47:07.710] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.710] Resolving any globals that are futures ... DONE
[17:47:07.710] Resolving futures part of globals (recursively) ...
[17:47:07.710] resolve() on list ...
[17:47:07.711]  recursive: 99
[17:47:07.711]  length: 2
[17:47:07.711]  elements: ‘a’, ‘ii’
[17:47:07.711]  length: 1 (resolved future 1)
[17:47:07.711]  length: 0 (resolved future 2)
[17:47:07.711] resolve() on list ... DONE
[17:47:07.711] - globals: [2] ‘a’, ‘ii’
[17:47:07.711] Resolving futures part of globals (recursively) ... DONE
[17:47:07.712] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:07.712] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.712] - globals: [2] ‘a’, ‘ii’
[17:47:07.712] 
[17:47:07.712] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.713] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.713] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.715] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.715] Searching for globals ... DONE
[17:47:07.715] Resolving globals: TRUE
[17:47:07.716] Resolving any globals that are futures ...
[17:47:07.716] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:07.716] Resolving any globals that are futures ... DONE
[17:47:07.716] Resolving futures part of globals (recursively) ...
[17:47:07.716] resolve() on list ...
[17:47:07.716]  recursive: 99
[17:47:07.717]  length: 2
[17:47:07.717]  elements: ‘a’, ‘ii’
[17:47:07.717]  length: 1 (resolved future 1)
[17:47:07.717]  length: 0 (resolved future 2)
[17:47:07.717] resolve() on list ... DONE
[17:47:07.717] - globals: [2] ‘a’, ‘ii’
[17:47:07.717] Resolving futures part of globals (recursively) ... DONE
[17:47:07.717] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:07.718] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:07.718] - globals: [2] ‘a’, ‘ii’
[17:47:07.718] 
[17:47:07.718] getGlobalsAndPackages() ... DONE
[17:47:07.718] run() for ‘Future’ ...
[17:47:07.719] - state: ‘created’
[17:47:07.719] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.723] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.723] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.723]   - Field: ‘label’
[17:47:07.723]   - Field: ‘local’
[17:47:07.723]   - Field: ‘owner’
[17:47:07.723]   - Field: ‘envir’
[17:47:07.725]   - Field: ‘workers’
[17:47:07.725]   - Field: ‘packages’
[17:47:07.725]   - Field: ‘gc’
[17:47:07.726]   - Field: ‘job’
[17:47:07.726]   - Field: ‘conditions’
[17:47:07.726]   - Field: ‘expr’
[17:47:07.726]   - Field: ‘uuid’
[17:47:07.726]   - Field: ‘seed’
[17:47:07.726]   - Field: ‘version’
[17:47:07.726]   - Field: ‘result’
[17:47:07.726]   - Field: ‘asynchronous’
[17:47:07.726]   - Field: ‘calls’
[17:47:07.727]   - Field: ‘globals’
[17:47:07.727]   - Field: ‘stdout’
[17:47:07.727]   - Field: ‘earlySignal’
[17:47:07.727]   - Field: ‘lazy’
[17:47:07.727]   - Field: ‘state’
[17:47:07.727] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.727] - Launch lazy future ...
[17:47:07.727] Packages needed by the future expression (n = 0): <none>
[17:47:07.728] Packages needed by future strategies (n = 0): <none>
[17:47:07.728] {
[17:47:07.728]     {
[17:47:07.728]         {
[17:47:07.728]             ...future.startTime <- base::Sys.time()
[17:47:07.728]             {
[17:47:07.728]                 {
[17:47:07.728]                   {
[17:47:07.728]                     {
[17:47:07.728]                       base::local({
[17:47:07.728]                         has_future <- base::requireNamespace("future", 
[17:47:07.728]                           quietly = TRUE)
[17:47:07.728]                         if (has_future) {
[17:47:07.728]                           ns <- base::getNamespace("future")
[17:47:07.728]                           version <- ns[[".package"]][["version"]]
[17:47:07.728]                           if (is.null(version)) 
[17:47:07.728]                             version <- utils::packageVersion("future")
[17:47:07.728]                         }
[17:47:07.728]                         else {
[17:47:07.728]                           version <- NULL
[17:47:07.728]                         }
[17:47:07.728]                         if (!has_future || version < "1.8.0") {
[17:47:07.728]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.728]                             "", base::R.version$version.string), 
[17:47:07.728]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.728]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.728]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.728]                               "release", "version")], collapse = " "), 
[17:47:07.728]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.728]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.728]                             info)
[17:47:07.728]                           info <- base::paste(info, collapse = "; ")
[17:47:07.728]                           if (!has_future) {
[17:47:07.728]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.728]                               info)
[17:47:07.728]                           }
[17:47:07.728]                           else {
[17:47:07.728]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.728]                               info, version)
[17:47:07.728]                           }
[17:47:07.728]                           base::stop(msg)
[17:47:07.728]                         }
[17:47:07.728]                       })
[17:47:07.728]                     }
[17:47:07.728]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.728]                     base::options(mc.cores = 1L)
[17:47:07.728]                   }
[17:47:07.728]                   ...future.strategy.old <- future::plan("list")
[17:47:07.728]                   options(future.plan = NULL)
[17:47:07.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.728]                 }
[17:47:07.728]                 ...future.workdir <- getwd()
[17:47:07.728]             }
[17:47:07.728]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.728]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.728]         }
[17:47:07.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.728]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.728]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.728]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.728]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.728]             base::names(...future.oldOptions))
[17:47:07.728]     }
[17:47:07.728]     if (FALSE) {
[17:47:07.728]     }
[17:47:07.728]     else {
[17:47:07.728]         if (TRUE) {
[17:47:07.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.728]                 open = "w")
[17:47:07.728]         }
[17:47:07.728]         else {
[17:47:07.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.728]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.728]         }
[17:47:07.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.728]             base::sink(type = "output", split = FALSE)
[17:47:07.728]             base::close(...future.stdout)
[17:47:07.728]         }, add = TRUE)
[17:47:07.728]     }
[17:47:07.728]     ...future.frame <- base::sys.nframe()
[17:47:07.728]     ...future.conditions <- base::list()
[17:47:07.728]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.728]     if (FALSE) {
[17:47:07.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.728]     }
[17:47:07.728]     ...future.result <- base::tryCatch({
[17:47:07.728]         base::withCallingHandlers({
[17:47:07.728]             ...future.value <- base::withVisible(base::local({
[17:47:07.728]                 withCallingHandlers({
[17:47:07.728]                   {
[17:47:07.728]                     b <- a * ii
[17:47:07.728]                     a <- 0
[17:47:07.728]                     b
[17:47:07.728]                   }
[17:47:07.728]                 }, immediateCondition = function(cond) {
[17:47:07.728]                   save_rds <- function (object, pathname, ...) 
[17:47:07.728]                   {
[17:47:07.728]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.728]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.728]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.728]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.728]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.728]                         fi_tmp[["mtime"]])
[17:47:07.728]                     }
[17:47:07.728]                     tryCatch({
[17:47:07.728]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.728]                     }, error = function(ex) {
[17:47:07.728]                       msg <- conditionMessage(ex)
[17:47:07.728]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.728]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.728]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.728]                         fi_tmp[["mtime"]], msg)
[17:47:07.728]                       ex$message <- msg
[17:47:07.728]                       stop(ex)
[17:47:07.728]                     })
[17:47:07.728]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.728]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.728]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.728]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.728]                       fi <- file.info(pathname)
[17:47:07.728]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.728]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.728]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.728]                         fi[["size"]], fi[["mtime"]])
[17:47:07.728]                       stop(msg)
[17:47:07.728]                     }
[17:47:07.728]                     invisible(pathname)
[17:47:07.728]                   }
[17:47:07.728]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.728]                     rootPath = tempdir()) 
[17:47:07.728]                   {
[17:47:07.728]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.728]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.728]                       tmpdir = path, fileext = ".rds")
[17:47:07.728]                     save_rds(obj, file)
[17:47:07.728]                   }
[17:47:07.728]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.728]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.728]                   {
[17:47:07.728]                     inherits <- base::inherits
[17:47:07.728]                     invokeRestart <- base::invokeRestart
[17:47:07.728]                     is.null <- base::is.null
[17:47:07.728]                     muffled <- FALSE
[17:47:07.728]                     if (inherits(cond, "message")) {
[17:47:07.728]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.728]                       if (muffled) 
[17:47:07.728]                         invokeRestart("muffleMessage")
[17:47:07.728]                     }
[17:47:07.728]                     else if (inherits(cond, "warning")) {
[17:47:07.728]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.728]                       if (muffled) 
[17:47:07.728]                         invokeRestart("muffleWarning")
[17:47:07.728]                     }
[17:47:07.728]                     else if (inherits(cond, "condition")) {
[17:47:07.728]                       if (!is.null(pattern)) {
[17:47:07.728]                         computeRestarts <- base::computeRestarts
[17:47:07.728]                         grepl <- base::grepl
[17:47:07.728]                         restarts <- computeRestarts(cond)
[17:47:07.728]                         for (restart in restarts) {
[17:47:07.728]                           name <- restart$name
[17:47:07.728]                           if (is.null(name)) 
[17:47:07.728]                             next
[17:47:07.728]                           if (!grepl(pattern, name)) 
[17:47:07.728]                             next
[17:47:07.728]                           invokeRestart(restart)
[17:47:07.728]                           muffled <- TRUE
[17:47:07.728]                           break
[17:47:07.728]                         }
[17:47:07.728]                       }
[17:47:07.728]                     }
[17:47:07.728]                     invisible(muffled)
[17:47:07.728]                   }
[17:47:07.728]                   muffleCondition(cond)
[17:47:07.728]                 })
[17:47:07.728]             }))
[17:47:07.728]             future::FutureResult(value = ...future.value$value, 
[17:47:07.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.728]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.728]                     ...future.globalenv.names))
[17:47:07.728]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.728]         }, condition = base::local({
[17:47:07.728]             c <- base::c
[17:47:07.728]             inherits <- base::inherits
[17:47:07.728]             invokeRestart <- base::invokeRestart
[17:47:07.728]             length <- base::length
[17:47:07.728]             list <- base::list
[17:47:07.728]             seq.int <- base::seq.int
[17:47:07.728]             signalCondition <- base::signalCondition
[17:47:07.728]             sys.calls <- base::sys.calls
[17:47:07.728]             `[[` <- base::`[[`
[17:47:07.728]             `+` <- base::`+`
[17:47:07.728]             `<<-` <- base::`<<-`
[17:47:07.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.728]                   3L)]
[17:47:07.728]             }
[17:47:07.728]             function(cond) {
[17:47:07.728]                 is_error <- inherits(cond, "error")
[17:47:07.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.728]                   NULL)
[17:47:07.728]                 if (is_error) {
[17:47:07.728]                   sessionInformation <- function() {
[17:47:07.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.728]                       search = base::search(), system = base::Sys.info())
[17:47:07.728]                   }
[17:47:07.728]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.728]                     cond$call), session = sessionInformation(), 
[17:47:07.728]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.728]                   signalCondition(cond)
[17:47:07.728]                 }
[17:47:07.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.728]                 "immediateCondition"))) {
[17:47:07.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.728]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.728]                   if (TRUE && !signal) {
[17:47:07.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.728]                     {
[17:47:07.728]                       inherits <- base::inherits
[17:47:07.728]                       invokeRestart <- base::invokeRestart
[17:47:07.728]                       is.null <- base::is.null
[17:47:07.728]                       muffled <- FALSE
[17:47:07.728]                       if (inherits(cond, "message")) {
[17:47:07.728]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.728]                         if (muffled) 
[17:47:07.728]                           invokeRestart("muffleMessage")
[17:47:07.728]                       }
[17:47:07.728]                       else if (inherits(cond, "warning")) {
[17:47:07.728]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.728]                         if (muffled) 
[17:47:07.728]                           invokeRestart("muffleWarning")
[17:47:07.728]                       }
[17:47:07.728]                       else if (inherits(cond, "condition")) {
[17:47:07.728]                         if (!is.null(pattern)) {
[17:47:07.728]                           computeRestarts <- base::computeRestarts
[17:47:07.728]                           grepl <- base::grepl
[17:47:07.728]                           restarts <- computeRestarts(cond)
[17:47:07.728]                           for (restart in restarts) {
[17:47:07.728]                             name <- restart$name
[17:47:07.728]                             if (is.null(name)) 
[17:47:07.728]                               next
[17:47:07.728]                             if (!grepl(pattern, name)) 
[17:47:07.728]                               next
[17:47:07.728]                             invokeRestart(restart)
[17:47:07.728]                             muffled <- TRUE
[17:47:07.728]                             break
[17:47:07.728]                           }
[17:47:07.728]                         }
[17:47:07.728]                       }
[17:47:07.728]                       invisible(muffled)
[17:47:07.728]                     }
[17:47:07.728]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.728]                   }
[17:47:07.728]                 }
[17:47:07.728]                 else {
[17:47:07.728]                   if (TRUE) {
[17:47:07.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.728]                     {
[17:47:07.728]                       inherits <- base::inherits
[17:47:07.728]                       invokeRestart <- base::invokeRestart
[17:47:07.728]                       is.null <- base::is.null
[17:47:07.728]                       muffled <- FALSE
[17:47:07.728]                       if (inherits(cond, "message")) {
[17:47:07.728]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.728]                         if (muffled) 
[17:47:07.728]                           invokeRestart("muffleMessage")
[17:47:07.728]                       }
[17:47:07.728]                       else if (inherits(cond, "warning")) {
[17:47:07.728]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.728]                         if (muffled) 
[17:47:07.728]                           invokeRestart("muffleWarning")
[17:47:07.728]                       }
[17:47:07.728]                       else if (inherits(cond, "condition")) {
[17:47:07.728]                         if (!is.null(pattern)) {
[17:47:07.728]                           computeRestarts <- base::computeRestarts
[17:47:07.728]                           grepl <- base::grepl
[17:47:07.728]                           restarts <- computeRestarts(cond)
[17:47:07.728]                           for (restart in restarts) {
[17:47:07.728]                             name <- restart$name
[17:47:07.728]                             if (is.null(name)) 
[17:47:07.728]                               next
[17:47:07.728]                             if (!grepl(pattern, name)) 
[17:47:07.728]                               next
[17:47:07.728]                             invokeRestart(restart)
[17:47:07.728]                             muffled <- TRUE
[17:47:07.728]                             break
[17:47:07.728]                           }
[17:47:07.728]                         }
[17:47:07.728]                       }
[17:47:07.728]                       invisible(muffled)
[17:47:07.728]                     }
[17:47:07.728]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.728]                   }
[17:47:07.728]                 }
[17:47:07.728]             }
[17:47:07.728]         }))
[17:47:07.728]     }, error = function(ex) {
[17:47:07.728]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.728]                 ...future.rng), started = ...future.startTime, 
[17:47:07.728]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.728]             version = "1.8"), class = "FutureResult")
[17:47:07.728]     }, finally = {
[17:47:07.728]         if (!identical(...future.workdir, getwd())) 
[17:47:07.728]             setwd(...future.workdir)
[17:47:07.728]         {
[17:47:07.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.728]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.728]             }
[17:47:07.728]             base::options(...future.oldOptions)
[17:47:07.728]             if (.Platform$OS.type == "windows") {
[17:47:07.728]                 old_names <- names(...future.oldEnvVars)
[17:47:07.728]                 envs <- base::Sys.getenv()
[17:47:07.728]                 names <- names(envs)
[17:47:07.728]                 common <- intersect(names, old_names)
[17:47:07.728]                 added <- setdiff(names, old_names)
[17:47:07.728]                 removed <- setdiff(old_names, names)
[17:47:07.728]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.728]                   envs[common]]
[17:47:07.728]                 NAMES <- toupper(changed)
[17:47:07.728]                 args <- list()
[17:47:07.728]                 for (kk in seq_along(NAMES)) {
[17:47:07.728]                   name <- changed[[kk]]
[17:47:07.728]                   NAME <- NAMES[[kk]]
[17:47:07.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.728]                     next
[17:47:07.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.728]                 }
[17:47:07.728]                 NAMES <- toupper(added)
[17:47:07.728]                 for (kk in seq_along(NAMES)) {
[17:47:07.728]                   name <- added[[kk]]
[17:47:07.728]                   NAME <- NAMES[[kk]]
[17:47:07.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.728]                     next
[17:47:07.728]                   args[[name]] <- ""
[17:47:07.728]                 }
[17:47:07.728]                 NAMES <- toupper(removed)
[17:47:07.728]                 for (kk in seq_along(NAMES)) {
[17:47:07.728]                   name <- removed[[kk]]
[17:47:07.728]                   NAME <- NAMES[[kk]]
[17:47:07.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.728]                     next
[17:47:07.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.728]                 }
[17:47:07.728]                 if (length(args) > 0) 
[17:47:07.728]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.728]             }
[17:47:07.728]             else {
[17:47:07.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.728]             }
[17:47:07.728]             {
[17:47:07.728]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.728]                   0L) {
[17:47:07.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.728]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.728]                   base::options(opts)
[17:47:07.728]                 }
[17:47:07.728]                 {
[17:47:07.728]                   {
[17:47:07.728]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.728]                     NULL
[17:47:07.728]                   }
[17:47:07.728]                   options(future.plan = NULL)
[17:47:07.728]                   if (is.na(NA_character_)) 
[17:47:07.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.728]                     .init = FALSE)
[17:47:07.728]                 }
[17:47:07.728]             }
[17:47:07.728]         }
[17:47:07.728]     })
[17:47:07.728]     if (TRUE) {
[17:47:07.728]         base::sink(type = "output", split = FALSE)
[17:47:07.728]         if (TRUE) {
[17:47:07.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.728]         }
[17:47:07.728]         else {
[17:47:07.728]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.728]         }
[17:47:07.728]         base::close(...future.stdout)
[17:47:07.728]         ...future.stdout <- NULL
[17:47:07.728]     }
[17:47:07.728]     ...future.result$conditions <- ...future.conditions
[17:47:07.728]     ...future.result$finished <- base::Sys.time()
[17:47:07.728]     ...future.result
[17:47:07.728] }
[17:47:07.730] assign_globals() ...
[17:47:07.731] List of 2
[17:47:07.731]  $ a : num 1
[17:47:07.731]  $ ii: int 1
[17:47:07.731]  - attr(*, "where")=List of 2
[17:47:07.731]   ..$ a :<environment: R_EmptyEnv> 
[17:47:07.731]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:07.731]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.731]  - attr(*, "resolved")= logi TRUE
[17:47:07.731]  - attr(*, "total_size")= num 112
[17:47:07.731]  - attr(*, "already-done")= logi TRUE
[17:47:07.734] - copied ‘a’ to environment
[17:47:07.734] - copied ‘ii’ to environment
[17:47:07.734] assign_globals() ... done
[17:47:07.734] requestCore(): workers = 2
[17:47:07.737] MulticoreFuture started
[17:47:07.737] - Launch lazy future ... done
[17:47:07.737] run() for ‘MulticoreFuture’ ... done
[17:47:07.738] plan(): Setting new future strategy stack:
[17:47:07.738] result() for MulticoreFuture ...
[17:47:07.738] List of future strategies:
[17:47:07.738] 1. sequential:
[17:47:07.738]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.738]    - tweaked: FALSE
[17:47:07.738]    - call: NULL
[17:47:07.739] plan(): nbrOfWorkers() = 1
[17:47:07.742] plan(): Setting new future strategy stack:
[17:47:07.742] List of future strategies:
[17:47:07.742] 1. multicore:
[17:47:07.742]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.742]    - tweaked: FALSE
[17:47:07.742]    - call: plan(strategy)
[17:47:07.747] plan(): nbrOfWorkers() = 2
[17:47:07.748] result() for MulticoreFuture ...
[17:47:07.749] result() for MulticoreFuture ... done
[17:47:07.749] result() for MulticoreFuture ... done
[17:47:07.749] result() for MulticoreFuture ...
[17:47:07.749] result() for MulticoreFuture ... done
[17:47:07.749] run() for ‘Future’ ...
[17:47:07.750] - state: ‘created’
[17:47:07.750] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.754] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.754]   - Field: ‘label’
[17:47:07.754]   - Field: ‘local’
[17:47:07.755]   - Field: ‘owner’
[17:47:07.755]   - Field: ‘envir’
[17:47:07.755]   - Field: ‘workers’
[17:47:07.755]   - Field: ‘packages’
[17:47:07.755]   - Field: ‘gc’
[17:47:07.755]   - Field: ‘job’
[17:47:07.755]   - Field: ‘conditions’
[17:47:07.756]   - Field: ‘expr’
[17:47:07.756]   - Field: ‘uuid’
[17:47:07.756]   - Field: ‘seed’
[17:47:07.756]   - Field: ‘version’
[17:47:07.756]   - Field: ‘result’
[17:47:07.756]   - Field: ‘asynchronous’
[17:47:07.756]   - Field: ‘calls’
[17:47:07.756]   - Field: ‘globals’
[17:47:07.757]   - Field: ‘stdout’
[17:47:07.757]   - Field: ‘earlySignal’
[17:47:07.757]   - Field: ‘lazy’
[17:47:07.757]   - Field: ‘state’
[17:47:07.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.757] - Launch lazy future ...
[17:47:07.757] Packages needed by the future expression (n = 0): <none>
[17:47:07.758] Packages needed by future strategies (n = 0): <none>
[17:47:07.758] {
[17:47:07.758]     {
[17:47:07.758]         {
[17:47:07.758]             ...future.startTime <- base::Sys.time()
[17:47:07.758]             {
[17:47:07.758]                 {
[17:47:07.758]                   {
[17:47:07.758]                     {
[17:47:07.758]                       base::local({
[17:47:07.758]                         has_future <- base::requireNamespace("future", 
[17:47:07.758]                           quietly = TRUE)
[17:47:07.758]                         if (has_future) {
[17:47:07.758]                           ns <- base::getNamespace("future")
[17:47:07.758]                           version <- ns[[".package"]][["version"]]
[17:47:07.758]                           if (is.null(version)) 
[17:47:07.758]                             version <- utils::packageVersion("future")
[17:47:07.758]                         }
[17:47:07.758]                         else {
[17:47:07.758]                           version <- NULL
[17:47:07.758]                         }
[17:47:07.758]                         if (!has_future || version < "1.8.0") {
[17:47:07.758]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.758]                             "", base::R.version$version.string), 
[17:47:07.758]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.758]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.758]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.758]                               "release", "version")], collapse = " "), 
[17:47:07.758]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.758]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.758]                             info)
[17:47:07.758]                           info <- base::paste(info, collapse = "; ")
[17:47:07.758]                           if (!has_future) {
[17:47:07.758]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.758]                               info)
[17:47:07.758]                           }
[17:47:07.758]                           else {
[17:47:07.758]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.758]                               info, version)
[17:47:07.758]                           }
[17:47:07.758]                           base::stop(msg)
[17:47:07.758]                         }
[17:47:07.758]                       })
[17:47:07.758]                     }
[17:47:07.758]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.758]                     base::options(mc.cores = 1L)
[17:47:07.758]                   }
[17:47:07.758]                   ...future.strategy.old <- future::plan("list")
[17:47:07.758]                   options(future.plan = NULL)
[17:47:07.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.758]                 }
[17:47:07.758]                 ...future.workdir <- getwd()
[17:47:07.758]             }
[17:47:07.758]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.758]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.758]         }
[17:47:07.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.758]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.758]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.758]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.758]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.758]             base::names(...future.oldOptions))
[17:47:07.758]     }
[17:47:07.758]     if (FALSE) {
[17:47:07.758]     }
[17:47:07.758]     else {
[17:47:07.758]         if (TRUE) {
[17:47:07.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.758]                 open = "w")
[17:47:07.758]         }
[17:47:07.758]         else {
[17:47:07.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.758]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.758]         }
[17:47:07.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.758]             base::sink(type = "output", split = FALSE)
[17:47:07.758]             base::close(...future.stdout)
[17:47:07.758]         }, add = TRUE)
[17:47:07.758]     }
[17:47:07.758]     ...future.frame <- base::sys.nframe()
[17:47:07.758]     ...future.conditions <- base::list()
[17:47:07.758]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.758]     if (FALSE) {
[17:47:07.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.758]     }
[17:47:07.758]     ...future.result <- base::tryCatch({
[17:47:07.758]         base::withCallingHandlers({
[17:47:07.758]             ...future.value <- base::withVisible(base::local({
[17:47:07.758]                 withCallingHandlers({
[17:47:07.758]                   {
[17:47:07.758]                     b <- a * ii
[17:47:07.758]                     a <- 0
[17:47:07.758]                     b
[17:47:07.758]                   }
[17:47:07.758]                 }, immediateCondition = function(cond) {
[17:47:07.758]                   save_rds <- function (object, pathname, ...) 
[17:47:07.758]                   {
[17:47:07.758]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.758]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.758]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.758]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.758]                         fi_tmp[["mtime"]])
[17:47:07.758]                     }
[17:47:07.758]                     tryCatch({
[17:47:07.758]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.758]                     }, error = function(ex) {
[17:47:07.758]                       msg <- conditionMessage(ex)
[17:47:07.758]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.758]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.758]                         fi_tmp[["mtime"]], msg)
[17:47:07.758]                       ex$message <- msg
[17:47:07.758]                       stop(ex)
[17:47:07.758]                     })
[17:47:07.758]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.758]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.758]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.758]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.758]                       fi <- file.info(pathname)
[17:47:07.758]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.758]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.758]                         fi[["size"]], fi[["mtime"]])
[17:47:07.758]                       stop(msg)
[17:47:07.758]                     }
[17:47:07.758]                     invisible(pathname)
[17:47:07.758]                   }
[17:47:07.758]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.758]                     rootPath = tempdir()) 
[17:47:07.758]                   {
[17:47:07.758]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.758]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.758]                       tmpdir = path, fileext = ".rds")
[17:47:07.758]                     save_rds(obj, file)
[17:47:07.758]                   }
[17:47:07.758]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.758]                   {
[17:47:07.758]                     inherits <- base::inherits
[17:47:07.758]                     invokeRestart <- base::invokeRestart
[17:47:07.758]                     is.null <- base::is.null
[17:47:07.758]                     muffled <- FALSE
[17:47:07.758]                     if (inherits(cond, "message")) {
[17:47:07.758]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.758]                       if (muffled) 
[17:47:07.758]                         invokeRestart("muffleMessage")
[17:47:07.758]                     }
[17:47:07.758]                     else if (inherits(cond, "warning")) {
[17:47:07.758]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.758]                       if (muffled) 
[17:47:07.758]                         invokeRestart("muffleWarning")
[17:47:07.758]                     }
[17:47:07.758]                     else if (inherits(cond, "condition")) {
[17:47:07.758]                       if (!is.null(pattern)) {
[17:47:07.758]                         computeRestarts <- base::computeRestarts
[17:47:07.758]                         grepl <- base::grepl
[17:47:07.758]                         restarts <- computeRestarts(cond)
[17:47:07.758]                         for (restart in restarts) {
[17:47:07.758]                           name <- restart$name
[17:47:07.758]                           if (is.null(name)) 
[17:47:07.758]                             next
[17:47:07.758]                           if (!grepl(pattern, name)) 
[17:47:07.758]                             next
[17:47:07.758]                           invokeRestart(restart)
[17:47:07.758]                           muffled <- TRUE
[17:47:07.758]                           break
[17:47:07.758]                         }
[17:47:07.758]                       }
[17:47:07.758]                     }
[17:47:07.758]                     invisible(muffled)
[17:47:07.758]                   }
[17:47:07.758]                   muffleCondition(cond)
[17:47:07.758]                 })
[17:47:07.758]             }))
[17:47:07.758]             future::FutureResult(value = ...future.value$value, 
[17:47:07.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.758]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.758]                     ...future.globalenv.names))
[17:47:07.758]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.758]         }, condition = base::local({
[17:47:07.758]             c <- base::c
[17:47:07.758]             inherits <- base::inherits
[17:47:07.758]             invokeRestart <- base::invokeRestart
[17:47:07.758]             length <- base::length
[17:47:07.758]             list <- base::list
[17:47:07.758]             seq.int <- base::seq.int
[17:47:07.758]             signalCondition <- base::signalCondition
[17:47:07.758]             sys.calls <- base::sys.calls
[17:47:07.758]             `[[` <- base::`[[`
[17:47:07.758]             `+` <- base::`+`
[17:47:07.758]             `<<-` <- base::`<<-`
[17:47:07.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.758]                   3L)]
[17:47:07.758]             }
[17:47:07.758]             function(cond) {
[17:47:07.758]                 is_error <- inherits(cond, "error")
[17:47:07.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.758]                   NULL)
[17:47:07.758]                 if (is_error) {
[17:47:07.758]                   sessionInformation <- function() {
[17:47:07.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.758]                       search = base::search(), system = base::Sys.info())
[17:47:07.758]                   }
[17:47:07.758]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.758]                     cond$call), session = sessionInformation(), 
[17:47:07.758]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.758]                   signalCondition(cond)
[17:47:07.758]                 }
[17:47:07.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.758]                 "immediateCondition"))) {
[17:47:07.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.758]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.758]                   if (TRUE && !signal) {
[17:47:07.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.758]                     {
[17:47:07.758]                       inherits <- base::inherits
[17:47:07.758]                       invokeRestart <- base::invokeRestart
[17:47:07.758]                       is.null <- base::is.null
[17:47:07.758]                       muffled <- FALSE
[17:47:07.758]                       if (inherits(cond, "message")) {
[17:47:07.758]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.758]                         if (muffled) 
[17:47:07.758]                           invokeRestart("muffleMessage")
[17:47:07.758]                       }
[17:47:07.758]                       else if (inherits(cond, "warning")) {
[17:47:07.758]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.758]                         if (muffled) 
[17:47:07.758]                           invokeRestart("muffleWarning")
[17:47:07.758]                       }
[17:47:07.758]                       else if (inherits(cond, "condition")) {
[17:47:07.758]                         if (!is.null(pattern)) {
[17:47:07.758]                           computeRestarts <- base::computeRestarts
[17:47:07.758]                           grepl <- base::grepl
[17:47:07.758]                           restarts <- computeRestarts(cond)
[17:47:07.758]                           for (restart in restarts) {
[17:47:07.758]                             name <- restart$name
[17:47:07.758]                             if (is.null(name)) 
[17:47:07.758]                               next
[17:47:07.758]                             if (!grepl(pattern, name)) 
[17:47:07.758]                               next
[17:47:07.758]                             invokeRestart(restart)
[17:47:07.758]                             muffled <- TRUE
[17:47:07.758]                             break
[17:47:07.758]                           }
[17:47:07.758]                         }
[17:47:07.758]                       }
[17:47:07.758]                       invisible(muffled)
[17:47:07.758]                     }
[17:47:07.758]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.758]                   }
[17:47:07.758]                 }
[17:47:07.758]                 else {
[17:47:07.758]                   if (TRUE) {
[17:47:07.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.758]                     {
[17:47:07.758]                       inherits <- base::inherits
[17:47:07.758]                       invokeRestart <- base::invokeRestart
[17:47:07.758]                       is.null <- base::is.null
[17:47:07.758]                       muffled <- FALSE
[17:47:07.758]                       if (inherits(cond, "message")) {
[17:47:07.758]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.758]                         if (muffled) 
[17:47:07.758]                           invokeRestart("muffleMessage")
[17:47:07.758]                       }
[17:47:07.758]                       else if (inherits(cond, "warning")) {
[17:47:07.758]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.758]                         if (muffled) 
[17:47:07.758]                           invokeRestart("muffleWarning")
[17:47:07.758]                       }
[17:47:07.758]                       else if (inherits(cond, "condition")) {
[17:47:07.758]                         if (!is.null(pattern)) {
[17:47:07.758]                           computeRestarts <- base::computeRestarts
[17:47:07.758]                           grepl <- base::grepl
[17:47:07.758]                           restarts <- computeRestarts(cond)
[17:47:07.758]                           for (restart in restarts) {
[17:47:07.758]                             name <- restart$name
[17:47:07.758]                             if (is.null(name)) 
[17:47:07.758]                               next
[17:47:07.758]                             if (!grepl(pattern, name)) 
[17:47:07.758]                               next
[17:47:07.758]                             invokeRestart(restart)
[17:47:07.758]                             muffled <- TRUE
[17:47:07.758]                             break
[17:47:07.758]                           }
[17:47:07.758]                         }
[17:47:07.758]                       }
[17:47:07.758]                       invisible(muffled)
[17:47:07.758]                     }
[17:47:07.758]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.758]                   }
[17:47:07.758]                 }
[17:47:07.758]             }
[17:47:07.758]         }))
[17:47:07.758]     }, error = function(ex) {
[17:47:07.758]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.758]                 ...future.rng), started = ...future.startTime, 
[17:47:07.758]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.758]             version = "1.8"), class = "FutureResult")
[17:47:07.758]     }, finally = {
[17:47:07.758]         if (!identical(...future.workdir, getwd())) 
[17:47:07.758]             setwd(...future.workdir)
[17:47:07.758]         {
[17:47:07.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.758]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.758]             }
[17:47:07.758]             base::options(...future.oldOptions)
[17:47:07.758]             if (.Platform$OS.type == "windows") {
[17:47:07.758]                 old_names <- names(...future.oldEnvVars)
[17:47:07.758]                 envs <- base::Sys.getenv()
[17:47:07.758]                 names <- names(envs)
[17:47:07.758]                 common <- intersect(names, old_names)
[17:47:07.758]                 added <- setdiff(names, old_names)
[17:47:07.758]                 removed <- setdiff(old_names, names)
[17:47:07.758]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.758]                   envs[common]]
[17:47:07.758]                 NAMES <- toupper(changed)
[17:47:07.758]                 args <- list()
[17:47:07.758]                 for (kk in seq_along(NAMES)) {
[17:47:07.758]                   name <- changed[[kk]]
[17:47:07.758]                   NAME <- NAMES[[kk]]
[17:47:07.758]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.758]                     next
[17:47:07.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.758]                 }
[17:47:07.758]                 NAMES <- toupper(added)
[17:47:07.758]                 for (kk in seq_along(NAMES)) {
[17:47:07.758]                   name <- added[[kk]]
[17:47:07.758]                   NAME <- NAMES[[kk]]
[17:47:07.758]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.758]                     next
[17:47:07.758]                   args[[name]] <- ""
[17:47:07.758]                 }
[17:47:07.758]                 NAMES <- toupper(removed)
[17:47:07.758]                 for (kk in seq_along(NAMES)) {
[17:47:07.758]                   name <- removed[[kk]]
[17:47:07.758]                   NAME <- NAMES[[kk]]
[17:47:07.758]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.758]                     next
[17:47:07.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.758]                 }
[17:47:07.758]                 if (length(args) > 0) 
[17:47:07.758]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.758]             }
[17:47:07.758]             else {
[17:47:07.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.758]             }
[17:47:07.758]             {
[17:47:07.758]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.758]                   0L) {
[17:47:07.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.758]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.758]                   base::options(opts)
[17:47:07.758]                 }
[17:47:07.758]                 {
[17:47:07.758]                   {
[17:47:07.758]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.758]                     NULL
[17:47:07.758]                   }
[17:47:07.758]                   options(future.plan = NULL)
[17:47:07.758]                   if (is.na(NA_character_)) 
[17:47:07.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.758]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.758]                     .init = FALSE)
[17:47:07.758]                 }
[17:47:07.758]             }
[17:47:07.758]         }
[17:47:07.758]     })
[17:47:07.758]     if (TRUE) {
[17:47:07.758]         base::sink(type = "output", split = FALSE)
[17:47:07.758]         if (TRUE) {
[17:47:07.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.758]         }
[17:47:07.758]         else {
[17:47:07.758]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.758]         }
[17:47:07.758]         base::close(...future.stdout)
[17:47:07.758]         ...future.stdout <- NULL
[17:47:07.758]     }
[17:47:07.758]     ...future.result$conditions <- ...future.conditions
[17:47:07.758]     ...future.result$finished <- base::Sys.time()
[17:47:07.758]     ...future.result
[17:47:07.758] }
[17:47:07.761] assign_globals() ...
[17:47:07.761] List of 2
[17:47:07.761]  $ a : num 1
[17:47:07.761]  $ ii: int 2
[17:47:07.761]  - attr(*, "where")=List of 2
[17:47:07.761]   ..$ a :<environment: R_EmptyEnv> 
[17:47:07.761]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:07.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.761]  - attr(*, "resolved")= logi TRUE
[17:47:07.761]  - attr(*, "total_size")= num 112
[17:47:07.761]  - attr(*, "already-done")= logi TRUE
[17:47:07.765] - copied ‘a’ to environment
[17:47:07.765] - copied ‘ii’ to environment
[17:47:07.765] assign_globals() ... done
[17:47:07.765] requestCore(): workers = 2
[17:47:07.767] MulticoreFuture started
[17:47:07.767] - Launch lazy future ... done
[17:47:07.768] run() for ‘MulticoreFuture’ ... done
[17:47:07.768] result() for MulticoreFuture ...
[17:47:07.768] plan(): Setting new future strategy stack:
[17:47:07.768] List of future strategies:
[17:47:07.768] 1. sequential:
[17:47:07.768]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.768]    - tweaked: FALSE
[17:47:07.768]    - call: NULL
[17:47:07.769] plan(): nbrOfWorkers() = 1
[17:47:07.771] plan(): Setting new future strategy stack:
[17:47:07.772] List of future strategies:
[17:47:07.772] 1. multicore:
[17:47:07.772]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.772]    - tweaked: FALSE
[17:47:07.772]    - call: plan(strategy)
[17:47:07.777] plan(): nbrOfWorkers() = 2
[17:47:07.778] result() for MulticoreFuture ...
[17:47:07.778] result() for MulticoreFuture ... done
[17:47:07.778] result() for MulticoreFuture ... done
[17:47:07.778] result() for MulticoreFuture ...
[17:47:07.778] result() for MulticoreFuture ... done
[17:47:07.779] run() for ‘Future’ ...
[17:47:07.779] - state: ‘created’
[17:47:07.779] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.784] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.784]   - Field: ‘label’
[17:47:07.784]   - Field: ‘local’
[17:47:07.784]   - Field: ‘owner’
[17:47:07.784]   - Field: ‘envir’
[17:47:07.784]   - Field: ‘workers’
[17:47:07.784]   - Field: ‘packages’
[17:47:07.785]   - Field: ‘gc’
[17:47:07.785]   - Field: ‘job’
[17:47:07.785]   - Field: ‘conditions’
[17:47:07.785]   - Field: ‘expr’
[17:47:07.785]   - Field: ‘uuid’
[17:47:07.785]   - Field: ‘seed’
[17:47:07.785]   - Field: ‘version’
[17:47:07.785]   - Field: ‘result’
[17:47:07.786]   - Field: ‘asynchronous’
[17:47:07.786]   - Field: ‘calls’
[17:47:07.786]   - Field: ‘globals’
[17:47:07.786]   - Field: ‘stdout’
[17:47:07.786]   - Field: ‘earlySignal’
[17:47:07.786]   - Field: ‘lazy’
[17:47:07.786]   - Field: ‘state’
[17:47:07.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.787] - Launch lazy future ...
[17:47:07.787] Packages needed by the future expression (n = 0): <none>
[17:47:07.787] Packages needed by future strategies (n = 0): <none>
[17:47:07.788] {
[17:47:07.788]     {
[17:47:07.788]         {
[17:47:07.788]             ...future.startTime <- base::Sys.time()
[17:47:07.788]             {
[17:47:07.788]                 {
[17:47:07.788]                   {
[17:47:07.788]                     {
[17:47:07.788]                       base::local({
[17:47:07.788]                         has_future <- base::requireNamespace("future", 
[17:47:07.788]                           quietly = TRUE)
[17:47:07.788]                         if (has_future) {
[17:47:07.788]                           ns <- base::getNamespace("future")
[17:47:07.788]                           version <- ns[[".package"]][["version"]]
[17:47:07.788]                           if (is.null(version)) 
[17:47:07.788]                             version <- utils::packageVersion("future")
[17:47:07.788]                         }
[17:47:07.788]                         else {
[17:47:07.788]                           version <- NULL
[17:47:07.788]                         }
[17:47:07.788]                         if (!has_future || version < "1.8.0") {
[17:47:07.788]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.788]                             "", base::R.version$version.string), 
[17:47:07.788]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.788]                               "release", "version")], collapse = " "), 
[17:47:07.788]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.788]                             info)
[17:47:07.788]                           info <- base::paste(info, collapse = "; ")
[17:47:07.788]                           if (!has_future) {
[17:47:07.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.788]                               info)
[17:47:07.788]                           }
[17:47:07.788]                           else {
[17:47:07.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.788]                               info, version)
[17:47:07.788]                           }
[17:47:07.788]                           base::stop(msg)
[17:47:07.788]                         }
[17:47:07.788]                       })
[17:47:07.788]                     }
[17:47:07.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.788]                     base::options(mc.cores = 1L)
[17:47:07.788]                   }
[17:47:07.788]                   ...future.strategy.old <- future::plan("list")
[17:47:07.788]                   options(future.plan = NULL)
[17:47:07.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.788]                 }
[17:47:07.788]                 ...future.workdir <- getwd()
[17:47:07.788]             }
[17:47:07.788]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.788]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.788]         }
[17:47:07.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.788]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.788]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.788]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.788]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.788]             base::names(...future.oldOptions))
[17:47:07.788]     }
[17:47:07.788]     if (FALSE) {
[17:47:07.788]     }
[17:47:07.788]     else {
[17:47:07.788]         if (TRUE) {
[17:47:07.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.788]                 open = "w")
[17:47:07.788]         }
[17:47:07.788]         else {
[17:47:07.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.788]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.788]         }
[17:47:07.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.788]             base::sink(type = "output", split = FALSE)
[17:47:07.788]             base::close(...future.stdout)
[17:47:07.788]         }, add = TRUE)
[17:47:07.788]     }
[17:47:07.788]     ...future.frame <- base::sys.nframe()
[17:47:07.788]     ...future.conditions <- base::list()
[17:47:07.788]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.788]     if (FALSE) {
[17:47:07.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.788]     }
[17:47:07.788]     ...future.result <- base::tryCatch({
[17:47:07.788]         base::withCallingHandlers({
[17:47:07.788]             ...future.value <- base::withVisible(base::local({
[17:47:07.788]                 withCallingHandlers({
[17:47:07.788]                   {
[17:47:07.788]                     b <- a * ii
[17:47:07.788]                     a <- 0
[17:47:07.788]                     b
[17:47:07.788]                   }
[17:47:07.788]                 }, immediateCondition = function(cond) {
[17:47:07.788]                   save_rds <- function (object, pathname, ...) 
[17:47:07.788]                   {
[17:47:07.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.788]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.788]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.788]                         fi_tmp[["mtime"]])
[17:47:07.788]                     }
[17:47:07.788]                     tryCatch({
[17:47:07.788]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.788]                     }, error = function(ex) {
[17:47:07.788]                       msg <- conditionMessage(ex)
[17:47:07.788]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.788]                         fi_tmp[["mtime"]], msg)
[17:47:07.788]                       ex$message <- msg
[17:47:07.788]                       stop(ex)
[17:47:07.788]                     })
[17:47:07.788]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.788]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.788]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.788]                       fi <- file.info(pathname)
[17:47:07.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.788]                         fi[["size"]], fi[["mtime"]])
[17:47:07.788]                       stop(msg)
[17:47:07.788]                     }
[17:47:07.788]                     invisible(pathname)
[17:47:07.788]                   }
[17:47:07.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.788]                     rootPath = tempdir()) 
[17:47:07.788]                   {
[17:47:07.788]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.788]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.788]                       tmpdir = path, fileext = ".rds")
[17:47:07.788]                     save_rds(obj, file)
[17:47:07.788]                   }
[17:47:07.788]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.788]                   {
[17:47:07.788]                     inherits <- base::inherits
[17:47:07.788]                     invokeRestart <- base::invokeRestart
[17:47:07.788]                     is.null <- base::is.null
[17:47:07.788]                     muffled <- FALSE
[17:47:07.788]                     if (inherits(cond, "message")) {
[17:47:07.788]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.788]                       if (muffled) 
[17:47:07.788]                         invokeRestart("muffleMessage")
[17:47:07.788]                     }
[17:47:07.788]                     else if (inherits(cond, "warning")) {
[17:47:07.788]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.788]                       if (muffled) 
[17:47:07.788]                         invokeRestart("muffleWarning")
[17:47:07.788]                     }
[17:47:07.788]                     else if (inherits(cond, "condition")) {
[17:47:07.788]                       if (!is.null(pattern)) {
[17:47:07.788]                         computeRestarts <- base::computeRestarts
[17:47:07.788]                         grepl <- base::grepl
[17:47:07.788]                         restarts <- computeRestarts(cond)
[17:47:07.788]                         for (restart in restarts) {
[17:47:07.788]                           name <- restart$name
[17:47:07.788]                           if (is.null(name)) 
[17:47:07.788]                             next
[17:47:07.788]                           if (!grepl(pattern, name)) 
[17:47:07.788]                             next
[17:47:07.788]                           invokeRestart(restart)
[17:47:07.788]                           muffled <- TRUE
[17:47:07.788]                           break
[17:47:07.788]                         }
[17:47:07.788]                       }
[17:47:07.788]                     }
[17:47:07.788]                     invisible(muffled)
[17:47:07.788]                   }
[17:47:07.788]                   muffleCondition(cond)
[17:47:07.788]                 })
[17:47:07.788]             }))
[17:47:07.788]             future::FutureResult(value = ...future.value$value, 
[17:47:07.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.788]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.788]                     ...future.globalenv.names))
[17:47:07.788]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.788]         }, condition = base::local({
[17:47:07.788]             c <- base::c
[17:47:07.788]             inherits <- base::inherits
[17:47:07.788]             invokeRestart <- base::invokeRestart
[17:47:07.788]             length <- base::length
[17:47:07.788]             list <- base::list
[17:47:07.788]             seq.int <- base::seq.int
[17:47:07.788]             signalCondition <- base::signalCondition
[17:47:07.788]             sys.calls <- base::sys.calls
[17:47:07.788]             `[[` <- base::`[[`
[17:47:07.788]             `+` <- base::`+`
[17:47:07.788]             `<<-` <- base::`<<-`
[17:47:07.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.788]                   3L)]
[17:47:07.788]             }
[17:47:07.788]             function(cond) {
[17:47:07.788]                 is_error <- inherits(cond, "error")
[17:47:07.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.788]                   NULL)
[17:47:07.788]                 if (is_error) {
[17:47:07.788]                   sessionInformation <- function() {
[17:47:07.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.788]                       search = base::search(), system = base::Sys.info())
[17:47:07.788]                   }
[17:47:07.788]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.788]                     cond$call), session = sessionInformation(), 
[17:47:07.788]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.788]                   signalCondition(cond)
[17:47:07.788]                 }
[17:47:07.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.788]                 "immediateCondition"))) {
[17:47:07.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.788]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.788]                   if (TRUE && !signal) {
[17:47:07.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.788]                     {
[17:47:07.788]                       inherits <- base::inherits
[17:47:07.788]                       invokeRestart <- base::invokeRestart
[17:47:07.788]                       is.null <- base::is.null
[17:47:07.788]                       muffled <- FALSE
[17:47:07.788]                       if (inherits(cond, "message")) {
[17:47:07.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.788]                         if (muffled) 
[17:47:07.788]                           invokeRestart("muffleMessage")
[17:47:07.788]                       }
[17:47:07.788]                       else if (inherits(cond, "warning")) {
[17:47:07.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.788]                         if (muffled) 
[17:47:07.788]                           invokeRestart("muffleWarning")
[17:47:07.788]                       }
[17:47:07.788]                       else if (inherits(cond, "condition")) {
[17:47:07.788]                         if (!is.null(pattern)) {
[17:47:07.788]                           computeRestarts <- base::computeRestarts
[17:47:07.788]                           grepl <- base::grepl
[17:47:07.788]                           restarts <- computeRestarts(cond)
[17:47:07.788]                           for (restart in restarts) {
[17:47:07.788]                             name <- restart$name
[17:47:07.788]                             if (is.null(name)) 
[17:47:07.788]                               next
[17:47:07.788]                             if (!grepl(pattern, name)) 
[17:47:07.788]                               next
[17:47:07.788]                             invokeRestart(restart)
[17:47:07.788]                             muffled <- TRUE
[17:47:07.788]                             break
[17:47:07.788]                           }
[17:47:07.788]                         }
[17:47:07.788]                       }
[17:47:07.788]                       invisible(muffled)
[17:47:07.788]                     }
[17:47:07.788]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.788]                   }
[17:47:07.788]                 }
[17:47:07.788]                 else {
[17:47:07.788]                   if (TRUE) {
[17:47:07.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.788]                     {
[17:47:07.788]                       inherits <- base::inherits
[17:47:07.788]                       invokeRestart <- base::invokeRestart
[17:47:07.788]                       is.null <- base::is.null
[17:47:07.788]                       muffled <- FALSE
[17:47:07.788]                       if (inherits(cond, "message")) {
[17:47:07.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.788]                         if (muffled) 
[17:47:07.788]                           invokeRestart("muffleMessage")
[17:47:07.788]                       }
[17:47:07.788]                       else if (inherits(cond, "warning")) {
[17:47:07.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.788]                         if (muffled) 
[17:47:07.788]                           invokeRestart("muffleWarning")
[17:47:07.788]                       }
[17:47:07.788]                       else if (inherits(cond, "condition")) {
[17:47:07.788]                         if (!is.null(pattern)) {
[17:47:07.788]                           computeRestarts <- base::computeRestarts
[17:47:07.788]                           grepl <- base::grepl
[17:47:07.788]                           restarts <- computeRestarts(cond)
[17:47:07.788]                           for (restart in restarts) {
[17:47:07.788]                             name <- restart$name
[17:47:07.788]                             if (is.null(name)) 
[17:47:07.788]                               next
[17:47:07.788]                             if (!grepl(pattern, name)) 
[17:47:07.788]                               next
[17:47:07.788]                             invokeRestart(restart)
[17:47:07.788]                             muffled <- TRUE
[17:47:07.788]                             break
[17:47:07.788]                           }
[17:47:07.788]                         }
[17:47:07.788]                       }
[17:47:07.788]                       invisible(muffled)
[17:47:07.788]                     }
[17:47:07.788]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.788]                   }
[17:47:07.788]                 }
[17:47:07.788]             }
[17:47:07.788]         }))
[17:47:07.788]     }, error = function(ex) {
[17:47:07.788]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.788]                 ...future.rng), started = ...future.startTime, 
[17:47:07.788]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.788]             version = "1.8"), class = "FutureResult")
[17:47:07.788]     }, finally = {
[17:47:07.788]         if (!identical(...future.workdir, getwd())) 
[17:47:07.788]             setwd(...future.workdir)
[17:47:07.788]         {
[17:47:07.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.788]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.788]             }
[17:47:07.788]             base::options(...future.oldOptions)
[17:47:07.788]             if (.Platform$OS.type == "windows") {
[17:47:07.788]                 old_names <- names(...future.oldEnvVars)
[17:47:07.788]                 envs <- base::Sys.getenv()
[17:47:07.788]                 names <- names(envs)
[17:47:07.788]                 common <- intersect(names, old_names)
[17:47:07.788]                 added <- setdiff(names, old_names)
[17:47:07.788]                 removed <- setdiff(old_names, names)
[17:47:07.788]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.788]                   envs[common]]
[17:47:07.788]                 NAMES <- toupper(changed)
[17:47:07.788]                 args <- list()
[17:47:07.788]                 for (kk in seq_along(NAMES)) {
[17:47:07.788]                   name <- changed[[kk]]
[17:47:07.788]                   NAME <- NAMES[[kk]]
[17:47:07.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.788]                     next
[17:47:07.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.788]                 }
[17:47:07.788]                 NAMES <- toupper(added)
[17:47:07.788]                 for (kk in seq_along(NAMES)) {
[17:47:07.788]                   name <- added[[kk]]
[17:47:07.788]                   NAME <- NAMES[[kk]]
[17:47:07.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.788]                     next
[17:47:07.788]                   args[[name]] <- ""
[17:47:07.788]                 }
[17:47:07.788]                 NAMES <- toupper(removed)
[17:47:07.788]                 for (kk in seq_along(NAMES)) {
[17:47:07.788]                   name <- removed[[kk]]
[17:47:07.788]                   NAME <- NAMES[[kk]]
[17:47:07.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.788]                     next
[17:47:07.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.788]                 }
[17:47:07.788]                 if (length(args) > 0) 
[17:47:07.788]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.788]             }
[17:47:07.788]             else {
[17:47:07.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.788]             }
[17:47:07.788]             {
[17:47:07.788]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.788]                   0L) {
[17:47:07.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.788]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.788]                   base::options(opts)
[17:47:07.788]                 }
[17:47:07.788]                 {
[17:47:07.788]                   {
[17:47:07.788]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.788]                     NULL
[17:47:07.788]                   }
[17:47:07.788]                   options(future.plan = NULL)
[17:47:07.788]                   if (is.na(NA_character_)) 
[17:47:07.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.788]                     .init = FALSE)
[17:47:07.788]                 }
[17:47:07.788]             }
[17:47:07.788]         }
[17:47:07.788]     })
[17:47:07.788]     if (TRUE) {
[17:47:07.788]         base::sink(type = "output", split = FALSE)
[17:47:07.788]         if (TRUE) {
[17:47:07.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.788]         }
[17:47:07.788]         else {
[17:47:07.788]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.788]         }
[17:47:07.788]         base::close(...future.stdout)
[17:47:07.788]         ...future.stdout <- NULL
[17:47:07.788]     }
[17:47:07.788]     ...future.result$conditions <- ...future.conditions
[17:47:07.788]     ...future.result$finished <- base::Sys.time()
[17:47:07.788]     ...future.result
[17:47:07.788] }
[17:47:07.790] assign_globals() ...
[17:47:07.790] List of 2
[17:47:07.790]  $ a : num 1
[17:47:07.790]  $ ii: int 3
[17:47:07.790]  - attr(*, "where")=List of 2
[17:47:07.790]   ..$ a :<environment: R_EmptyEnv> 
[17:47:07.790]   ..$ ii:<environment: R_EmptyEnv> 
[17:47:07.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.790]  - attr(*, "resolved")= logi TRUE
[17:47:07.790]  - attr(*, "total_size")= num 112
[17:47:07.790]  - attr(*, "already-done")= logi TRUE
[17:47:07.797] - copied ‘a’ to environment
[17:47:07.797] - copied ‘ii’ to environment
[17:47:07.797] assign_globals() ... done
[17:47:07.797] requestCore(): workers = 2
[17:47:07.799] MulticoreFuture started
[17:47:07.800] - Launch lazy future ... done
[17:47:07.800] run() for ‘MulticoreFuture’ ... done
[17:47:07.800] result() for MulticoreFuture ...
[17:47:07.800] plan(): Setting new future strategy stack:
[17:47:07.801] List of future strategies:
[17:47:07.801] 1. sequential:
[17:47:07.801]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.801]    - tweaked: FALSE
[17:47:07.801]    - call: NULL
[17:47:07.802] plan(): nbrOfWorkers() = 1
[17:47:07.805] plan(): Setting new future strategy stack:
[17:47:07.806] List of future strategies:
[17:47:07.806] 1. multicore:
[17:47:07.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.806]    - tweaked: FALSE
[17:47:07.806]    - call: plan(strategy)
[17:47:07.812] plan(): nbrOfWorkers() = 2
[17:47:07.813] result() for MulticoreFuture ...
[17:47:07.814] result() for MulticoreFuture ... done
[17:47:07.814] result() for MulticoreFuture ... done
[17:47:07.814] result() for MulticoreFuture ...
[17:47:07.814] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.816] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.816] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.817] 
[17:47:07.817] Searching for globals ... DONE
[17:47:07.817] - globals: [0] <none>
[17:47:07.817] getGlobalsAndPackages() ... DONE
[17:47:07.818] run() for ‘Future’ ...
[17:47:07.818] - state: ‘created’
[17:47:07.818] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.822] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.823]   - Field: ‘label’
[17:47:07.823]   - Field: ‘local’
[17:47:07.823]   - Field: ‘owner’
[17:47:07.823]   - Field: ‘envir’
[17:47:07.823]   - Field: ‘workers’
[17:47:07.823]   - Field: ‘packages’
[17:47:07.824]   - Field: ‘gc’
[17:47:07.824]   - Field: ‘job’
[17:47:07.824]   - Field: ‘conditions’
[17:47:07.824]   - Field: ‘expr’
[17:47:07.824]   - Field: ‘uuid’
[17:47:07.824]   - Field: ‘seed’
[17:47:07.824]   - Field: ‘version’
[17:47:07.824]   - Field: ‘result’
[17:47:07.824]   - Field: ‘asynchronous’
[17:47:07.825]   - Field: ‘calls’
[17:47:07.825]   - Field: ‘globals’
[17:47:07.825]   - Field: ‘stdout’
[17:47:07.825]   - Field: ‘earlySignal’
[17:47:07.825]   - Field: ‘lazy’
[17:47:07.825]   - Field: ‘state’
[17:47:07.825] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.825] - Launch lazy future ...
[17:47:07.826] Packages needed by the future expression (n = 0): <none>
[17:47:07.826] Packages needed by future strategies (n = 0): <none>
[17:47:07.826] {
[17:47:07.826]     {
[17:47:07.826]         {
[17:47:07.826]             ...future.startTime <- base::Sys.time()
[17:47:07.826]             {
[17:47:07.826]                 {
[17:47:07.826]                   {
[17:47:07.826]                     {
[17:47:07.826]                       base::local({
[17:47:07.826]                         has_future <- base::requireNamespace("future", 
[17:47:07.826]                           quietly = TRUE)
[17:47:07.826]                         if (has_future) {
[17:47:07.826]                           ns <- base::getNamespace("future")
[17:47:07.826]                           version <- ns[[".package"]][["version"]]
[17:47:07.826]                           if (is.null(version)) 
[17:47:07.826]                             version <- utils::packageVersion("future")
[17:47:07.826]                         }
[17:47:07.826]                         else {
[17:47:07.826]                           version <- NULL
[17:47:07.826]                         }
[17:47:07.826]                         if (!has_future || version < "1.8.0") {
[17:47:07.826]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.826]                             "", base::R.version$version.string), 
[17:47:07.826]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.826]                               "release", "version")], collapse = " "), 
[17:47:07.826]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.826]                             info)
[17:47:07.826]                           info <- base::paste(info, collapse = "; ")
[17:47:07.826]                           if (!has_future) {
[17:47:07.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.826]                               info)
[17:47:07.826]                           }
[17:47:07.826]                           else {
[17:47:07.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.826]                               info, version)
[17:47:07.826]                           }
[17:47:07.826]                           base::stop(msg)
[17:47:07.826]                         }
[17:47:07.826]                       })
[17:47:07.826]                     }
[17:47:07.826]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.826]                     base::options(mc.cores = 1L)
[17:47:07.826]                   }
[17:47:07.826]                   ...future.strategy.old <- future::plan("list")
[17:47:07.826]                   options(future.plan = NULL)
[17:47:07.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.826]                 }
[17:47:07.826]                 ...future.workdir <- getwd()
[17:47:07.826]             }
[17:47:07.826]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.826]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.826]         }
[17:47:07.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.826]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.826]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.826]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.826]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.826]             base::names(...future.oldOptions))
[17:47:07.826]     }
[17:47:07.826]     if (FALSE) {
[17:47:07.826]     }
[17:47:07.826]     else {
[17:47:07.826]         if (TRUE) {
[17:47:07.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.826]                 open = "w")
[17:47:07.826]         }
[17:47:07.826]         else {
[17:47:07.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.826]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.826]         }
[17:47:07.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.826]             base::sink(type = "output", split = FALSE)
[17:47:07.826]             base::close(...future.stdout)
[17:47:07.826]         }, add = TRUE)
[17:47:07.826]     }
[17:47:07.826]     ...future.frame <- base::sys.nframe()
[17:47:07.826]     ...future.conditions <- base::list()
[17:47:07.826]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.826]     if (FALSE) {
[17:47:07.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.826]     }
[17:47:07.826]     ...future.result <- base::tryCatch({
[17:47:07.826]         base::withCallingHandlers({
[17:47:07.826]             ...future.value <- base::withVisible(base::local({
[17:47:07.826]                 withCallingHandlers({
[17:47:07.826]                   1
[17:47:07.826]                 }, immediateCondition = function(cond) {
[17:47:07.826]                   save_rds <- function (object, pathname, ...) 
[17:47:07.826]                   {
[17:47:07.826]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.826]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.826]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.826]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.826]                         fi_tmp[["mtime"]])
[17:47:07.826]                     }
[17:47:07.826]                     tryCatch({
[17:47:07.826]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.826]                     }, error = function(ex) {
[17:47:07.826]                       msg <- conditionMessage(ex)
[17:47:07.826]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.826]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.826]                         fi_tmp[["mtime"]], msg)
[17:47:07.826]                       ex$message <- msg
[17:47:07.826]                       stop(ex)
[17:47:07.826]                     })
[17:47:07.826]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.826]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.826]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.826]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.826]                       fi <- file.info(pathname)
[17:47:07.826]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.826]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.826]                         fi[["size"]], fi[["mtime"]])
[17:47:07.826]                       stop(msg)
[17:47:07.826]                     }
[17:47:07.826]                     invisible(pathname)
[17:47:07.826]                   }
[17:47:07.826]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.826]                     rootPath = tempdir()) 
[17:47:07.826]                   {
[17:47:07.826]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.826]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.826]                       tmpdir = path, fileext = ".rds")
[17:47:07.826]                     save_rds(obj, file)
[17:47:07.826]                   }
[17:47:07.826]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.826]                   {
[17:47:07.826]                     inherits <- base::inherits
[17:47:07.826]                     invokeRestart <- base::invokeRestart
[17:47:07.826]                     is.null <- base::is.null
[17:47:07.826]                     muffled <- FALSE
[17:47:07.826]                     if (inherits(cond, "message")) {
[17:47:07.826]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.826]                       if (muffled) 
[17:47:07.826]                         invokeRestart("muffleMessage")
[17:47:07.826]                     }
[17:47:07.826]                     else if (inherits(cond, "warning")) {
[17:47:07.826]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.826]                       if (muffled) 
[17:47:07.826]                         invokeRestart("muffleWarning")
[17:47:07.826]                     }
[17:47:07.826]                     else if (inherits(cond, "condition")) {
[17:47:07.826]                       if (!is.null(pattern)) {
[17:47:07.826]                         computeRestarts <- base::computeRestarts
[17:47:07.826]                         grepl <- base::grepl
[17:47:07.826]                         restarts <- computeRestarts(cond)
[17:47:07.826]                         for (restart in restarts) {
[17:47:07.826]                           name <- restart$name
[17:47:07.826]                           if (is.null(name)) 
[17:47:07.826]                             next
[17:47:07.826]                           if (!grepl(pattern, name)) 
[17:47:07.826]                             next
[17:47:07.826]                           invokeRestart(restart)
[17:47:07.826]                           muffled <- TRUE
[17:47:07.826]                           break
[17:47:07.826]                         }
[17:47:07.826]                       }
[17:47:07.826]                     }
[17:47:07.826]                     invisible(muffled)
[17:47:07.826]                   }
[17:47:07.826]                   muffleCondition(cond)
[17:47:07.826]                 })
[17:47:07.826]             }))
[17:47:07.826]             future::FutureResult(value = ...future.value$value, 
[17:47:07.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.826]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.826]                     ...future.globalenv.names))
[17:47:07.826]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.826]         }, condition = base::local({
[17:47:07.826]             c <- base::c
[17:47:07.826]             inherits <- base::inherits
[17:47:07.826]             invokeRestart <- base::invokeRestart
[17:47:07.826]             length <- base::length
[17:47:07.826]             list <- base::list
[17:47:07.826]             seq.int <- base::seq.int
[17:47:07.826]             signalCondition <- base::signalCondition
[17:47:07.826]             sys.calls <- base::sys.calls
[17:47:07.826]             `[[` <- base::`[[`
[17:47:07.826]             `+` <- base::`+`
[17:47:07.826]             `<<-` <- base::`<<-`
[17:47:07.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.826]                   3L)]
[17:47:07.826]             }
[17:47:07.826]             function(cond) {
[17:47:07.826]                 is_error <- inherits(cond, "error")
[17:47:07.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.826]                   NULL)
[17:47:07.826]                 if (is_error) {
[17:47:07.826]                   sessionInformation <- function() {
[17:47:07.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.826]                       search = base::search(), system = base::Sys.info())
[17:47:07.826]                   }
[17:47:07.826]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.826]                     cond$call), session = sessionInformation(), 
[17:47:07.826]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.826]                   signalCondition(cond)
[17:47:07.826]                 }
[17:47:07.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.826]                 "immediateCondition"))) {
[17:47:07.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.826]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.826]                   if (TRUE && !signal) {
[17:47:07.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.826]                     {
[17:47:07.826]                       inherits <- base::inherits
[17:47:07.826]                       invokeRestart <- base::invokeRestart
[17:47:07.826]                       is.null <- base::is.null
[17:47:07.826]                       muffled <- FALSE
[17:47:07.826]                       if (inherits(cond, "message")) {
[17:47:07.826]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.826]                         if (muffled) 
[17:47:07.826]                           invokeRestart("muffleMessage")
[17:47:07.826]                       }
[17:47:07.826]                       else if (inherits(cond, "warning")) {
[17:47:07.826]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.826]                         if (muffled) 
[17:47:07.826]                           invokeRestart("muffleWarning")
[17:47:07.826]                       }
[17:47:07.826]                       else if (inherits(cond, "condition")) {
[17:47:07.826]                         if (!is.null(pattern)) {
[17:47:07.826]                           computeRestarts <- base::computeRestarts
[17:47:07.826]                           grepl <- base::grepl
[17:47:07.826]                           restarts <- computeRestarts(cond)
[17:47:07.826]                           for (restart in restarts) {
[17:47:07.826]                             name <- restart$name
[17:47:07.826]                             if (is.null(name)) 
[17:47:07.826]                               next
[17:47:07.826]                             if (!grepl(pattern, name)) 
[17:47:07.826]                               next
[17:47:07.826]                             invokeRestart(restart)
[17:47:07.826]                             muffled <- TRUE
[17:47:07.826]                             break
[17:47:07.826]                           }
[17:47:07.826]                         }
[17:47:07.826]                       }
[17:47:07.826]                       invisible(muffled)
[17:47:07.826]                     }
[17:47:07.826]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.826]                   }
[17:47:07.826]                 }
[17:47:07.826]                 else {
[17:47:07.826]                   if (TRUE) {
[17:47:07.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.826]                     {
[17:47:07.826]                       inherits <- base::inherits
[17:47:07.826]                       invokeRestart <- base::invokeRestart
[17:47:07.826]                       is.null <- base::is.null
[17:47:07.826]                       muffled <- FALSE
[17:47:07.826]                       if (inherits(cond, "message")) {
[17:47:07.826]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.826]                         if (muffled) 
[17:47:07.826]                           invokeRestart("muffleMessage")
[17:47:07.826]                       }
[17:47:07.826]                       else if (inherits(cond, "warning")) {
[17:47:07.826]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.826]                         if (muffled) 
[17:47:07.826]                           invokeRestart("muffleWarning")
[17:47:07.826]                       }
[17:47:07.826]                       else if (inherits(cond, "condition")) {
[17:47:07.826]                         if (!is.null(pattern)) {
[17:47:07.826]                           computeRestarts <- base::computeRestarts
[17:47:07.826]                           grepl <- base::grepl
[17:47:07.826]                           restarts <- computeRestarts(cond)
[17:47:07.826]                           for (restart in restarts) {
[17:47:07.826]                             name <- restart$name
[17:47:07.826]                             if (is.null(name)) 
[17:47:07.826]                               next
[17:47:07.826]                             if (!grepl(pattern, name)) 
[17:47:07.826]                               next
[17:47:07.826]                             invokeRestart(restart)
[17:47:07.826]                             muffled <- TRUE
[17:47:07.826]                             break
[17:47:07.826]                           }
[17:47:07.826]                         }
[17:47:07.826]                       }
[17:47:07.826]                       invisible(muffled)
[17:47:07.826]                     }
[17:47:07.826]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.826]                   }
[17:47:07.826]                 }
[17:47:07.826]             }
[17:47:07.826]         }))
[17:47:07.826]     }, error = function(ex) {
[17:47:07.826]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.826]                 ...future.rng), started = ...future.startTime, 
[17:47:07.826]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.826]             version = "1.8"), class = "FutureResult")
[17:47:07.826]     }, finally = {
[17:47:07.826]         if (!identical(...future.workdir, getwd())) 
[17:47:07.826]             setwd(...future.workdir)
[17:47:07.826]         {
[17:47:07.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.826]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.826]             }
[17:47:07.826]             base::options(...future.oldOptions)
[17:47:07.826]             if (.Platform$OS.type == "windows") {
[17:47:07.826]                 old_names <- names(...future.oldEnvVars)
[17:47:07.826]                 envs <- base::Sys.getenv()
[17:47:07.826]                 names <- names(envs)
[17:47:07.826]                 common <- intersect(names, old_names)
[17:47:07.826]                 added <- setdiff(names, old_names)
[17:47:07.826]                 removed <- setdiff(old_names, names)
[17:47:07.826]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.826]                   envs[common]]
[17:47:07.826]                 NAMES <- toupper(changed)
[17:47:07.826]                 args <- list()
[17:47:07.826]                 for (kk in seq_along(NAMES)) {
[17:47:07.826]                   name <- changed[[kk]]
[17:47:07.826]                   NAME <- NAMES[[kk]]
[17:47:07.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.826]                     next
[17:47:07.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.826]                 }
[17:47:07.826]                 NAMES <- toupper(added)
[17:47:07.826]                 for (kk in seq_along(NAMES)) {
[17:47:07.826]                   name <- added[[kk]]
[17:47:07.826]                   NAME <- NAMES[[kk]]
[17:47:07.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.826]                     next
[17:47:07.826]                   args[[name]] <- ""
[17:47:07.826]                 }
[17:47:07.826]                 NAMES <- toupper(removed)
[17:47:07.826]                 for (kk in seq_along(NAMES)) {
[17:47:07.826]                   name <- removed[[kk]]
[17:47:07.826]                   NAME <- NAMES[[kk]]
[17:47:07.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.826]                     next
[17:47:07.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.826]                 }
[17:47:07.826]                 if (length(args) > 0) 
[17:47:07.826]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.826]             }
[17:47:07.826]             else {
[17:47:07.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.826]             }
[17:47:07.826]             {
[17:47:07.826]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.826]                   0L) {
[17:47:07.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.826]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.826]                   base::options(opts)
[17:47:07.826]                 }
[17:47:07.826]                 {
[17:47:07.826]                   {
[17:47:07.826]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.826]                     NULL
[17:47:07.826]                   }
[17:47:07.826]                   options(future.plan = NULL)
[17:47:07.826]                   if (is.na(NA_character_)) 
[17:47:07.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.826]                     .init = FALSE)
[17:47:07.826]                 }
[17:47:07.826]             }
[17:47:07.826]         }
[17:47:07.826]     })
[17:47:07.826]     if (TRUE) {
[17:47:07.826]         base::sink(type = "output", split = FALSE)
[17:47:07.826]         if (TRUE) {
[17:47:07.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.826]         }
[17:47:07.826]         else {
[17:47:07.826]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.826]         }
[17:47:07.826]         base::close(...future.stdout)
[17:47:07.826]         ...future.stdout <- NULL
[17:47:07.826]     }
[17:47:07.826]     ...future.result$conditions <- ...future.conditions
[17:47:07.826]     ...future.result$finished <- base::Sys.time()
[17:47:07.826]     ...future.result
[17:47:07.826] }
[17:47:07.829] requestCore(): workers = 2
[17:47:07.831] MulticoreFuture started
[17:47:07.831] - Launch lazy future ... done
[17:47:07.832] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.832] plan(): Setting new future strategy stack:
[17:47:07.832] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.833] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.832] List of future strategies:
[17:47:07.832] 1. sequential:
[17:47:07.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.832]    - tweaked: FALSE
[17:47:07.832]    - call: NULL
[17:47:07.833] plan(): nbrOfWorkers() = 1
[17:47:07.834] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:07.834] Searching for globals ... DONE
[17:47:07.835] Resolving globals: TRUE
[17:47:07.835] Resolving any globals that are futures ...
[17:47:07.835] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:07.835] Resolving any globals that are futures ... DONE
[17:47:07.835] plan(): Setting new future strategy stack:
[17:47:07.836] Resolving futures part of globals (recursively) ...
[17:47:07.835] List of future strategies:
[17:47:07.835] 1. multicore:
[17:47:07.835]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.835]    - tweaked: FALSE
[17:47:07.835]    - call: plan(strategy)
[17:47:07.836] resolve() on list ...
[17:47:07.836]  recursive: 99
[17:47:07.837]  length: 1
[17:47:07.837]  elements: ‘a’
[17:47:07.840] plan(): nbrOfWorkers() = 2
[17:47:07.840] Future #1
[17:47:07.841] result() for MulticoreFuture ...
[17:47:07.842] result() for MulticoreFuture ...
[17:47:07.842] result() for MulticoreFuture ... done
[17:47:07.842] result() for MulticoreFuture ... done
[17:47:07.842] result() for MulticoreFuture ...
[17:47:07.842] result() for MulticoreFuture ... done
[17:47:07.842] A MulticoreFuture was resolved
[17:47:07.843]  length: 0 (resolved future 1)
[17:47:07.843] resolve() on list ... DONE
[17:47:07.843] - globals: [1] ‘a’
[17:47:07.843] Resolving futures part of globals (recursively) ... DONE
[17:47:07.846] The total size of the 1 globals is 1.57 MiB (1647480 bytes)
[17:47:07.846] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:47:07.846] - globals: [1] ‘a’
[17:47:07.846] - packages: [1] ‘future’
[17:47:07.846] getGlobalsAndPackages() ... DONE
[17:47:07.847] run() for ‘Future’ ...
[17:47:07.847] - state: ‘created’
[17:47:07.847] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.851] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.851]   - Field: ‘label’
[17:47:07.851]   - Field: ‘local’
[17:47:07.852]   - Field: ‘owner’
[17:47:07.852]   - Field: ‘envir’
[17:47:07.852]   - Field: ‘workers’
[17:47:07.852]   - Field: ‘packages’
[17:47:07.852]   - Field: ‘gc’
[17:47:07.852]   - Field: ‘job’
[17:47:07.852]   - Field: ‘conditions’
[17:47:07.852]   - Field: ‘expr’
[17:47:07.852]   - Field: ‘uuid’
[17:47:07.853]   - Field: ‘seed’
[17:47:07.853]   - Field: ‘version’
[17:47:07.853]   - Field: ‘result’
[17:47:07.853]   - Field: ‘asynchronous’
[17:47:07.853]   - Field: ‘calls’
[17:47:07.853]   - Field: ‘globals’
[17:47:07.853]   - Field: ‘stdout’
[17:47:07.853]   - Field: ‘earlySignal’
[17:47:07.853]   - Field: ‘lazy’
[17:47:07.854]   - Field: ‘state’
[17:47:07.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.854] - Launch lazy future ...
[17:47:07.854] Packages needed by the future expression (n = 1): ‘future’
[17:47:07.854] Packages needed by future strategies (n = 0): <none>
[17:47:07.855] {
[17:47:07.855]     {
[17:47:07.855]         {
[17:47:07.855]             ...future.startTime <- base::Sys.time()
[17:47:07.855]             {
[17:47:07.855]                 {
[17:47:07.855]                   {
[17:47:07.855]                     {
[17:47:07.855]                       {
[17:47:07.855]                         base::local({
[17:47:07.855]                           has_future <- base::requireNamespace("future", 
[17:47:07.855]                             quietly = TRUE)
[17:47:07.855]                           if (has_future) {
[17:47:07.855]                             ns <- base::getNamespace("future")
[17:47:07.855]                             version <- ns[[".package"]][["version"]]
[17:47:07.855]                             if (is.null(version)) 
[17:47:07.855]                               version <- utils::packageVersion("future")
[17:47:07.855]                           }
[17:47:07.855]                           else {
[17:47:07.855]                             version <- NULL
[17:47:07.855]                           }
[17:47:07.855]                           if (!has_future || version < "1.8.0") {
[17:47:07.855]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.855]                               "", base::R.version$version.string), 
[17:47:07.855]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:07.855]                                 base::R.version$platform, 8 * 
[17:47:07.855]                                   base::.Machine$sizeof.pointer), 
[17:47:07.855]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.855]                                 "release", "version")], collapse = " "), 
[17:47:07.855]                               hostname = base::Sys.info()[["nodename"]])
[17:47:07.855]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.855]                               info)
[17:47:07.855]                             info <- base::paste(info, collapse = "; ")
[17:47:07.855]                             if (!has_future) {
[17:47:07.855]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.855]                                 info)
[17:47:07.855]                             }
[17:47:07.855]                             else {
[17:47:07.855]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.855]                                 info, version)
[17:47:07.855]                             }
[17:47:07.855]                             base::stop(msg)
[17:47:07.855]                           }
[17:47:07.855]                         })
[17:47:07.855]                       }
[17:47:07.855]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.855]                       base::options(mc.cores = 1L)
[17:47:07.855]                     }
[17:47:07.855]                     base::local({
[17:47:07.855]                       for (pkg in "future") {
[17:47:07.855]                         base::loadNamespace(pkg)
[17:47:07.855]                         base::library(pkg, character.only = TRUE)
[17:47:07.855]                       }
[17:47:07.855]                     })
[17:47:07.855]                   }
[17:47:07.855]                   ...future.strategy.old <- future::plan("list")
[17:47:07.855]                   options(future.plan = NULL)
[17:47:07.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.855]                 }
[17:47:07.855]                 ...future.workdir <- getwd()
[17:47:07.855]             }
[17:47:07.855]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.855]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.855]         }
[17:47:07.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.855]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.855]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.855]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.855]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.855]             base::names(...future.oldOptions))
[17:47:07.855]     }
[17:47:07.855]     if (FALSE) {
[17:47:07.855]     }
[17:47:07.855]     else {
[17:47:07.855]         if (TRUE) {
[17:47:07.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.855]                 open = "w")
[17:47:07.855]         }
[17:47:07.855]         else {
[17:47:07.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.855]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.855]         }
[17:47:07.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.855]             base::sink(type = "output", split = FALSE)
[17:47:07.855]             base::close(...future.stdout)
[17:47:07.855]         }, add = TRUE)
[17:47:07.855]     }
[17:47:07.855]     ...future.frame <- base::sys.nframe()
[17:47:07.855]     ...future.conditions <- base::list()
[17:47:07.855]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.855]     if (FALSE) {
[17:47:07.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.855]     }
[17:47:07.855]     ...future.result <- base::tryCatch({
[17:47:07.855]         base::withCallingHandlers({
[17:47:07.855]             ...future.value <- base::withVisible(base::local({
[17:47:07.855]                 withCallingHandlers({
[17:47:07.855]                   value(a) + 1
[17:47:07.855]                 }, immediateCondition = function(cond) {
[17:47:07.855]                   save_rds <- function (object, pathname, ...) 
[17:47:07.855]                   {
[17:47:07.855]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.855]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.855]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.855]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.855]                         fi_tmp[["mtime"]])
[17:47:07.855]                     }
[17:47:07.855]                     tryCatch({
[17:47:07.855]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.855]                     }, error = function(ex) {
[17:47:07.855]                       msg <- conditionMessage(ex)
[17:47:07.855]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.855]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.855]                         fi_tmp[["mtime"]], msg)
[17:47:07.855]                       ex$message <- msg
[17:47:07.855]                       stop(ex)
[17:47:07.855]                     })
[17:47:07.855]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.855]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.855]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.855]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.855]                       fi <- file.info(pathname)
[17:47:07.855]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.855]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.855]                         fi[["size"]], fi[["mtime"]])
[17:47:07.855]                       stop(msg)
[17:47:07.855]                     }
[17:47:07.855]                     invisible(pathname)
[17:47:07.855]                   }
[17:47:07.855]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.855]                     rootPath = tempdir()) 
[17:47:07.855]                   {
[17:47:07.855]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.855]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.855]                       tmpdir = path, fileext = ".rds")
[17:47:07.855]                     save_rds(obj, file)
[17:47:07.855]                   }
[17:47:07.855]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.855]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.855]                   {
[17:47:07.855]                     inherits <- base::inherits
[17:47:07.855]                     invokeRestart <- base::invokeRestart
[17:47:07.855]                     is.null <- base::is.null
[17:47:07.855]                     muffled <- FALSE
[17:47:07.855]                     if (inherits(cond, "message")) {
[17:47:07.855]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.855]                       if (muffled) 
[17:47:07.855]                         invokeRestart("muffleMessage")
[17:47:07.855]                     }
[17:47:07.855]                     else if (inherits(cond, "warning")) {
[17:47:07.855]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.855]                       if (muffled) 
[17:47:07.855]                         invokeRestart("muffleWarning")
[17:47:07.855]                     }
[17:47:07.855]                     else if (inherits(cond, "condition")) {
[17:47:07.855]                       if (!is.null(pattern)) {
[17:47:07.855]                         computeRestarts <- base::computeRestarts
[17:47:07.855]                         grepl <- base::grepl
[17:47:07.855]                         restarts <- computeRestarts(cond)
[17:47:07.855]                         for (restart in restarts) {
[17:47:07.855]                           name <- restart$name
[17:47:07.855]                           if (is.null(name)) 
[17:47:07.855]                             next
[17:47:07.855]                           if (!grepl(pattern, name)) 
[17:47:07.855]                             next
[17:47:07.855]                           invokeRestart(restart)
[17:47:07.855]                           muffled <- TRUE
[17:47:07.855]                           break
[17:47:07.855]                         }
[17:47:07.855]                       }
[17:47:07.855]                     }
[17:47:07.855]                     invisible(muffled)
[17:47:07.855]                   }
[17:47:07.855]                   muffleCondition(cond)
[17:47:07.855]                 })
[17:47:07.855]             }))
[17:47:07.855]             future::FutureResult(value = ...future.value$value, 
[17:47:07.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.855]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.855]                     ...future.globalenv.names))
[17:47:07.855]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.855]         }, condition = base::local({
[17:47:07.855]             c <- base::c
[17:47:07.855]             inherits <- base::inherits
[17:47:07.855]             invokeRestart <- base::invokeRestart
[17:47:07.855]             length <- base::length
[17:47:07.855]             list <- base::list
[17:47:07.855]             seq.int <- base::seq.int
[17:47:07.855]             signalCondition <- base::signalCondition
[17:47:07.855]             sys.calls <- base::sys.calls
[17:47:07.855]             `[[` <- base::`[[`
[17:47:07.855]             `+` <- base::`+`
[17:47:07.855]             `<<-` <- base::`<<-`
[17:47:07.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.855]                   3L)]
[17:47:07.855]             }
[17:47:07.855]             function(cond) {
[17:47:07.855]                 is_error <- inherits(cond, "error")
[17:47:07.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.855]                   NULL)
[17:47:07.855]                 if (is_error) {
[17:47:07.855]                   sessionInformation <- function() {
[17:47:07.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.855]                       search = base::search(), system = base::Sys.info())
[17:47:07.855]                   }
[17:47:07.855]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.855]                     cond$call), session = sessionInformation(), 
[17:47:07.855]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.855]                   signalCondition(cond)
[17:47:07.855]                 }
[17:47:07.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.855]                 "immediateCondition"))) {
[17:47:07.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.855]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.855]                   if (TRUE && !signal) {
[17:47:07.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.855]                     {
[17:47:07.855]                       inherits <- base::inherits
[17:47:07.855]                       invokeRestart <- base::invokeRestart
[17:47:07.855]                       is.null <- base::is.null
[17:47:07.855]                       muffled <- FALSE
[17:47:07.855]                       if (inherits(cond, "message")) {
[17:47:07.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.855]                         if (muffled) 
[17:47:07.855]                           invokeRestart("muffleMessage")
[17:47:07.855]                       }
[17:47:07.855]                       else if (inherits(cond, "warning")) {
[17:47:07.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.855]                         if (muffled) 
[17:47:07.855]                           invokeRestart("muffleWarning")
[17:47:07.855]                       }
[17:47:07.855]                       else if (inherits(cond, "condition")) {
[17:47:07.855]                         if (!is.null(pattern)) {
[17:47:07.855]                           computeRestarts <- base::computeRestarts
[17:47:07.855]                           grepl <- base::grepl
[17:47:07.855]                           restarts <- computeRestarts(cond)
[17:47:07.855]                           for (restart in restarts) {
[17:47:07.855]                             name <- restart$name
[17:47:07.855]                             if (is.null(name)) 
[17:47:07.855]                               next
[17:47:07.855]                             if (!grepl(pattern, name)) 
[17:47:07.855]                               next
[17:47:07.855]                             invokeRestart(restart)
[17:47:07.855]                             muffled <- TRUE
[17:47:07.855]                             break
[17:47:07.855]                           }
[17:47:07.855]                         }
[17:47:07.855]                       }
[17:47:07.855]                       invisible(muffled)
[17:47:07.855]                     }
[17:47:07.855]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.855]                   }
[17:47:07.855]                 }
[17:47:07.855]                 else {
[17:47:07.855]                   if (TRUE) {
[17:47:07.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.855]                     {
[17:47:07.855]                       inherits <- base::inherits
[17:47:07.855]                       invokeRestart <- base::invokeRestart
[17:47:07.855]                       is.null <- base::is.null
[17:47:07.855]                       muffled <- FALSE
[17:47:07.855]                       if (inherits(cond, "message")) {
[17:47:07.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.855]                         if (muffled) 
[17:47:07.855]                           invokeRestart("muffleMessage")
[17:47:07.855]                       }
[17:47:07.855]                       else if (inherits(cond, "warning")) {
[17:47:07.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.855]                         if (muffled) 
[17:47:07.855]                           invokeRestart("muffleWarning")
[17:47:07.855]                       }
[17:47:07.855]                       else if (inherits(cond, "condition")) {
[17:47:07.855]                         if (!is.null(pattern)) {
[17:47:07.855]                           computeRestarts <- base::computeRestarts
[17:47:07.855]                           grepl <- base::grepl
[17:47:07.855]                           restarts <- computeRestarts(cond)
[17:47:07.855]                           for (restart in restarts) {
[17:47:07.855]                             name <- restart$name
[17:47:07.855]                             if (is.null(name)) 
[17:47:07.855]                               next
[17:47:07.855]                             if (!grepl(pattern, name)) 
[17:47:07.855]                               next
[17:47:07.855]                             invokeRestart(restart)
[17:47:07.855]                             muffled <- TRUE
[17:47:07.855]                             break
[17:47:07.855]                           }
[17:47:07.855]                         }
[17:47:07.855]                       }
[17:47:07.855]                       invisible(muffled)
[17:47:07.855]                     }
[17:47:07.855]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.855]                   }
[17:47:07.855]                 }
[17:47:07.855]             }
[17:47:07.855]         }))
[17:47:07.855]     }, error = function(ex) {
[17:47:07.855]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.855]                 ...future.rng), started = ...future.startTime, 
[17:47:07.855]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.855]             version = "1.8"), class = "FutureResult")
[17:47:07.855]     }, finally = {
[17:47:07.855]         if (!identical(...future.workdir, getwd())) 
[17:47:07.855]             setwd(...future.workdir)
[17:47:07.855]         {
[17:47:07.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.855]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.855]             }
[17:47:07.855]             base::options(...future.oldOptions)
[17:47:07.855]             if (.Platform$OS.type == "windows") {
[17:47:07.855]                 old_names <- names(...future.oldEnvVars)
[17:47:07.855]                 envs <- base::Sys.getenv()
[17:47:07.855]                 names <- names(envs)
[17:47:07.855]                 common <- intersect(names, old_names)
[17:47:07.855]                 added <- setdiff(names, old_names)
[17:47:07.855]                 removed <- setdiff(old_names, names)
[17:47:07.855]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.855]                   envs[common]]
[17:47:07.855]                 NAMES <- toupper(changed)
[17:47:07.855]                 args <- list()
[17:47:07.855]                 for (kk in seq_along(NAMES)) {
[17:47:07.855]                   name <- changed[[kk]]
[17:47:07.855]                   NAME <- NAMES[[kk]]
[17:47:07.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.855]                     next
[17:47:07.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.855]                 }
[17:47:07.855]                 NAMES <- toupper(added)
[17:47:07.855]                 for (kk in seq_along(NAMES)) {
[17:47:07.855]                   name <- added[[kk]]
[17:47:07.855]                   NAME <- NAMES[[kk]]
[17:47:07.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.855]                     next
[17:47:07.855]                   args[[name]] <- ""
[17:47:07.855]                 }
[17:47:07.855]                 NAMES <- toupper(removed)
[17:47:07.855]                 for (kk in seq_along(NAMES)) {
[17:47:07.855]                   name <- removed[[kk]]
[17:47:07.855]                   NAME <- NAMES[[kk]]
[17:47:07.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.855]                     next
[17:47:07.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.855]                 }
[17:47:07.855]                 if (length(args) > 0) 
[17:47:07.855]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.855]             }
[17:47:07.855]             else {
[17:47:07.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.855]             }
[17:47:07.855]             {
[17:47:07.855]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.855]                   0L) {
[17:47:07.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.855]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.855]                   base::options(opts)
[17:47:07.855]                 }
[17:47:07.855]                 {
[17:47:07.855]                   {
[17:47:07.855]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.855]                     NULL
[17:47:07.855]                   }
[17:47:07.855]                   options(future.plan = NULL)
[17:47:07.855]                   if (is.na(NA_character_)) 
[17:47:07.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.855]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.855]                     .init = FALSE)
[17:47:07.855]                 }
[17:47:07.855]             }
[17:47:07.855]         }
[17:47:07.855]     })
[17:47:07.855]     if (TRUE) {
[17:47:07.855]         base::sink(type = "output", split = FALSE)
[17:47:07.855]         if (TRUE) {
[17:47:07.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.855]         }
[17:47:07.855]         else {
[17:47:07.855]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.855]         }
[17:47:07.855]         base::close(...future.stdout)
[17:47:07.855]         ...future.stdout <- NULL
[17:47:07.855]     }
[17:47:07.855]     ...future.result$conditions <- ...future.conditions
[17:47:07.855]     ...future.result$finished <- base::Sys.time()
[17:47:07.855]     ...future.result
[17:47:07.855] }
[17:47:07.860] assign_globals() ...
[17:47:07.860] List of 1
[17:47:07.860]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558b32e0ceb8> 
[17:47:07.860]  - attr(*, "where")=List of 1
[17:47:07.860]   ..$ a:<environment: R_EmptyEnv> 
[17:47:07.860]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.860]  - attr(*, "resolved")= logi TRUE
[17:47:07.860]  - attr(*, "total_size")= num 1647480
[17:47:07.860]  - attr(*, "already-done")= logi TRUE
[17:47:07.863] - copied ‘a’ to environment
[17:47:07.863] assign_globals() ... done
[17:47:07.864] requestCore(): workers = 2
[17:47:07.866] MulticoreFuture started
[17:47:07.866] - Launch lazy future ... done
[17:47:07.866] run() for ‘MulticoreFuture’ ... done
[17:47:07.867] result() for MulticoreFuture ...
[17:47:07.867] plan(): Setting new future strategy stack:
[17:47:07.867] List of future strategies:
[17:47:07.867] 1. sequential:
[17:47:07.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.867]    - tweaked: FALSE
[17:47:07.867]    - call: NULL
[17:47:07.869] plan(): nbrOfWorkers() = 1
[17:47:07.874] plan(): Setting new future strategy stack:
[17:47:07.874] List of future strategies:
[17:47:07.874] 1. multicore:
[17:47:07.874]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.874]    - tweaked: FALSE
[17:47:07.874]    - call: plan(strategy)
[17:47:07.880] plan(): nbrOfWorkers() = 2
[17:47:07.881] result() for MulticoreFuture ...
[17:47:07.881] result() for MulticoreFuture ... done
[17:47:07.881] signalConditions() ...
[17:47:07.882]  - include = ‘immediateCondition’
[17:47:07.882]  - exclude = 
[17:47:07.882]  - resignal = FALSE
[17:47:07.882]  - Number of conditions: 4
[17:47:07.882] signalConditions() ... done
[17:47:07.883] result() for MulticoreFuture ... done
[17:47:07.883] result() for MulticoreFuture ...
[17:47:07.883] result() for MulticoreFuture ... done
[17:47:07.883] signalConditions() ...
[17:47:07.883]  - include = ‘immediateCondition’
[17:47:07.884]  - exclude = 
[17:47:07.884]  - resignal = FALSE
[17:47:07.884]  - Number of conditions: 4
[17:47:07.884] signalConditions() ... done
[17:47:07.884] Future state: ‘finished’
[17:47:07.885] result() for MulticoreFuture ...
[17:47:07.885] result() for MulticoreFuture ... done
[17:47:07.885] signalConditions() ...
[17:47:07.885]  - include = ‘condition’
[17:47:07.885]  - exclude = ‘immediateCondition’
[17:47:07.885]  - resignal = TRUE
[17:47:07.885]  - Number of conditions: 4
[17:47:07.886]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.871] result() for MulticoreFuture ...
[17:47:07.886]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.871] result() for MulticoreFuture ... done
[17:47:07.886]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.872] result() for MulticoreFuture ...
[17:47:07.886]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.872] result() for MulticoreFuture ... done
[17:47:07.886] signalConditions() ... done
value(b) = 2
[17:47:07.887] result() for MulticoreFuture ...
[17:47:07.887] result() for MulticoreFuture ... done
[17:47:07.887] result() for MulticoreFuture ...
[17:47:07.887] result() for MulticoreFuture ... done
[17:47:07.887] signalConditions() ...
[17:47:07.887]  - include = ‘immediateCondition’
[17:47:07.887]  - exclude = 
[17:47:07.888]  - resignal = FALSE
[17:47:07.888]  - Number of conditions: 4
[17:47:07.888] signalConditions() ... done
[17:47:07.888] Future state: ‘finished’
[17:47:07.888] result() for MulticoreFuture ...
[17:47:07.888] result() for MulticoreFuture ... done
[17:47:07.888] signalConditions() ...
[17:47:07.888]  - include = ‘condition’
[17:47:07.888]  - exclude = ‘immediateCondition’
[17:47:07.889]  - resignal = TRUE
[17:47:07.889]  - Number of conditions: 4
[17:47:07.889]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.871] result() for MulticoreFuture ...
[17:47:07.889]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.871] result() for MulticoreFuture ... done
[17:47:07.889]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.872] result() for MulticoreFuture ...
[17:47:07.889]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.872] result() for MulticoreFuture ... done
[17:47:07.889] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.890] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.890] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.891] 
[17:47:07.891] Searching for globals ... DONE
[17:47:07.891] - globals: [0] <none>
[17:47:07.891] getGlobalsAndPackages() ... DONE
[17:47:07.891] run() for ‘Future’ ...
[17:47:07.891] - state: ‘created’
[17:47:07.892] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.896] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.896] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.896]   - Field: ‘label’
[17:47:07.896]   - Field: ‘local’
[17:47:07.896]   - Field: ‘owner’
[17:47:07.896]   - Field: ‘envir’
[17:47:07.896]   - Field: ‘workers’
[17:47:07.896]   - Field: ‘packages’
[17:47:07.897]   - Field: ‘gc’
[17:47:07.897]   - Field: ‘job’
[17:47:07.897]   - Field: ‘conditions’
[17:47:07.897]   - Field: ‘expr’
[17:47:07.897]   - Field: ‘uuid’
[17:47:07.897]   - Field: ‘seed’
[17:47:07.897]   - Field: ‘version’
[17:47:07.897]   - Field: ‘result’
[17:47:07.897]   - Field: ‘asynchronous’
[17:47:07.898]   - Field: ‘calls’
[17:47:07.898]   - Field: ‘globals’
[17:47:07.898]   - Field: ‘stdout’
[17:47:07.898]   - Field: ‘earlySignal’
[17:47:07.898]   - Field: ‘lazy’
[17:47:07.898]   - Field: ‘state’
[17:47:07.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.898] - Launch lazy future ...
[17:47:07.899] Packages needed by the future expression (n = 0): <none>
[17:47:07.899] Packages needed by future strategies (n = 0): <none>
[17:47:07.899] {
[17:47:07.899]     {
[17:47:07.899]         {
[17:47:07.899]             ...future.startTime <- base::Sys.time()
[17:47:07.899]             {
[17:47:07.899]                 {
[17:47:07.899]                   {
[17:47:07.899]                     {
[17:47:07.899]                       base::local({
[17:47:07.899]                         has_future <- base::requireNamespace("future", 
[17:47:07.899]                           quietly = TRUE)
[17:47:07.899]                         if (has_future) {
[17:47:07.899]                           ns <- base::getNamespace("future")
[17:47:07.899]                           version <- ns[[".package"]][["version"]]
[17:47:07.899]                           if (is.null(version)) 
[17:47:07.899]                             version <- utils::packageVersion("future")
[17:47:07.899]                         }
[17:47:07.899]                         else {
[17:47:07.899]                           version <- NULL
[17:47:07.899]                         }
[17:47:07.899]                         if (!has_future || version < "1.8.0") {
[17:47:07.899]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.899]                             "", base::R.version$version.string), 
[17:47:07.899]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.899]                               "release", "version")], collapse = " "), 
[17:47:07.899]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.899]                             info)
[17:47:07.899]                           info <- base::paste(info, collapse = "; ")
[17:47:07.899]                           if (!has_future) {
[17:47:07.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.899]                               info)
[17:47:07.899]                           }
[17:47:07.899]                           else {
[17:47:07.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.899]                               info, version)
[17:47:07.899]                           }
[17:47:07.899]                           base::stop(msg)
[17:47:07.899]                         }
[17:47:07.899]                       })
[17:47:07.899]                     }
[17:47:07.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.899]                     base::options(mc.cores = 1L)
[17:47:07.899]                   }
[17:47:07.899]                   ...future.strategy.old <- future::plan("list")
[17:47:07.899]                   options(future.plan = NULL)
[17:47:07.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.899]                 }
[17:47:07.899]                 ...future.workdir <- getwd()
[17:47:07.899]             }
[17:47:07.899]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.899]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.899]         }
[17:47:07.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.899]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.899]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.899]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.899]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.899]             base::names(...future.oldOptions))
[17:47:07.899]     }
[17:47:07.899]     if (FALSE) {
[17:47:07.899]     }
[17:47:07.899]     else {
[17:47:07.899]         if (TRUE) {
[17:47:07.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.899]                 open = "w")
[17:47:07.899]         }
[17:47:07.899]         else {
[17:47:07.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.899]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.899]         }
[17:47:07.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.899]             base::sink(type = "output", split = FALSE)
[17:47:07.899]             base::close(...future.stdout)
[17:47:07.899]         }, add = TRUE)
[17:47:07.899]     }
[17:47:07.899]     ...future.frame <- base::sys.nframe()
[17:47:07.899]     ...future.conditions <- base::list()
[17:47:07.899]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.899]     if (FALSE) {
[17:47:07.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.899]     }
[17:47:07.899]     ...future.result <- base::tryCatch({
[17:47:07.899]         base::withCallingHandlers({
[17:47:07.899]             ...future.value <- base::withVisible(base::local({
[17:47:07.899]                 withCallingHandlers({
[17:47:07.899]                   1
[17:47:07.899]                 }, immediateCondition = function(cond) {
[17:47:07.899]                   save_rds <- function (object, pathname, ...) 
[17:47:07.899]                   {
[17:47:07.899]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.899]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.899]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.899]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.899]                         fi_tmp[["mtime"]])
[17:47:07.899]                     }
[17:47:07.899]                     tryCatch({
[17:47:07.899]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.899]                     }, error = function(ex) {
[17:47:07.899]                       msg <- conditionMessage(ex)
[17:47:07.899]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.899]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.899]                         fi_tmp[["mtime"]], msg)
[17:47:07.899]                       ex$message <- msg
[17:47:07.899]                       stop(ex)
[17:47:07.899]                     })
[17:47:07.899]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.899]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.899]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.899]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.899]                       fi <- file.info(pathname)
[17:47:07.899]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.899]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.899]                         fi[["size"]], fi[["mtime"]])
[17:47:07.899]                       stop(msg)
[17:47:07.899]                     }
[17:47:07.899]                     invisible(pathname)
[17:47:07.899]                   }
[17:47:07.899]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.899]                     rootPath = tempdir()) 
[17:47:07.899]                   {
[17:47:07.899]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.899]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.899]                       tmpdir = path, fileext = ".rds")
[17:47:07.899]                     save_rds(obj, file)
[17:47:07.899]                   }
[17:47:07.899]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.899]                   {
[17:47:07.899]                     inherits <- base::inherits
[17:47:07.899]                     invokeRestart <- base::invokeRestart
[17:47:07.899]                     is.null <- base::is.null
[17:47:07.899]                     muffled <- FALSE
[17:47:07.899]                     if (inherits(cond, "message")) {
[17:47:07.899]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.899]                       if (muffled) 
[17:47:07.899]                         invokeRestart("muffleMessage")
[17:47:07.899]                     }
[17:47:07.899]                     else if (inherits(cond, "warning")) {
[17:47:07.899]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.899]                       if (muffled) 
[17:47:07.899]                         invokeRestart("muffleWarning")
[17:47:07.899]                     }
[17:47:07.899]                     else if (inherits(cond, "condition")) {
[17:47:07.899]                       if (!is.null(pattern)) {
[17:47:07.899]                         computeRestarts <- base::computeRestarts
[17:47:07.899]                         grepl <- base::grepl
[17:47:07.899]                         restarts <- computeRestarts(cond)
[17:47:07.899]                         for (restart in restarts) {
[17:47:07.899]                           name <- restart$name
[17:47:07.899]                           if (is.null(name)) 
[17:47:07.899]                             next
[17:47:07.899]                           if (!grepl(pattern, name)) 
[17:47:07.899]                             next
[17:47:07.899]                           invokeRestart(restart)
[17:47:07.899]                           muffled <- TRUE
[17:47:07.899]                           break
[17:47:07.899]                         }
[17:47:07.899]                       }
[17:47:07.899]                     }
[17:47:07.899]                     invisible(muffled)
[17:47:07.899]                   }
[17:47:07.899]                   muffleCondition(cond)
[17:47:07.899]                 })
[17:47:07.899]             }))
[17:47:07.899]             future::FutureResult(value = ...future.value$value, 
[17:47:07.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.899]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.899]                     ...future.globalenv.names))
[17:47:07.899]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.899]         }, condition = base::local({
[17:47:07.899]             c <- base::c
[17:47:07.899]             inherits <- base::inherits
[17:47:07.899]             invokeRestart <- base::invokeRestart
[17:47:07.899]             length <- base::length
[17:47:07.899]             list <- base::list
[17:47:07.899]             seq.int <- base::seq.int
[17:47:07.899]             signalCondition <- base::signalCondition
[17:47:07.899]             sys.calls <- base::sys.calls
[17:47:07.899]             `[[` <- base::`[[`
[17:47:07.899]             `+` <- base::`+`
[17:47:07.899]             `<<-` <- base::`<<-`
[17:47:07.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.899]                   3L)]
[17:47:07.899]             }
[17:47:07.899]             function(cond) {
[17:47:07.899]                 is_error <- inherits(cond, "error")
[17:47:07.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.899]                   NULL)
[17:47:07.899]                 if (is_error) {
[17:47:07.899]                   sessionInformation <- function() {
[17:47:07.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.899]                       search = base::search(), system = base::Sys.info())
[17:47:07.899]                   }
[17:47:07.899]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.899]                     cond$call), session = sessionInformation(), 
[17:47:07.899]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.899]                   signalCondition(cond)
[17:47:07.899]                 }
[17:47:07.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.899]                 "immediateCondition"))) {
[17:47:07.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.899]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.899]                   if (TRUE && !signal) {
[17:47:07.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.899]                     {
[17:47:07.899]                       inherits <- base::inherits
[17:47:07.899]                       invokeRestart <- base::invokeRestart
[17:47:07.899]                       is.null <- base::is.null
[17:47:07.899]                       muffled <- FALSE
[17:47:07.899]                       if (inherits(cond, "message")) {
[17:47:07.899]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.899]                         if (muffled) 
[17:47:07.899]                           invokeRestart("muffleMessage")
[17:47:07.899]                       }
[17:47:07.899]                       else if (inherits(cond, "warning")) {
[17:47:07.899]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.899]                         if (muffled) 
[17:47:07.899]                           invokeRestart("muffleWarning")
[17:47:07.899]                       }
[17:47:07.899]                       else if (inherits(cond, "condition")) {
[17:47:07.899]                         if (!is.null(pattern)) {
[17:47:07.899]                           computeRestarts <- base::computeRestarts
[17:47:07.899]                           grepl <- base::grepl
[17:47:07.899]                           restarts <- computeRestarts(cond)
[17:47:07.899]                           for (restart in restarts) {
[17:47:07.899]                             name <- restart$name
[17:47:07.899]                             if (is.null(name)) 
[17:47:07.899]                               next
[17:47:07.899]                             if (!grepl(pattern, name)) 
[17:47:07.899]                               next
[17:47:07.899]                             invokeRestart(restart)
[17:47:07.899]                             muffled <- TRUE
[17:47:07.899]                             break
[17:47:07.899]                           }
[17:47:07.899]                         }
[17:47:07.899]                       }
[17:47:07.899]                       invisible(muffled)
[17:47:07.899]                     }
[17:47:07.899]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.899]                   }
[17:47:07.899]                 }
[17:47:07.899]                 else {
[17:47:07.899]                   if (TRUE) {
[17:47:07.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.899]                     {
[17:47:07.899]                       inherits <- base::inherits
[17:47:07.899]                       invokeRestart <- base::invokeRestart
[17:47:07.899]                       is.null <- base::is.null
[17:47:07.899]                       muffled <- FALSE
[17:47:07.899]                       if (inherits(cond, "message")) {
[17:47:07.899]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.899]                         if (muffled) 
[17:47:07.899]                           invokeRestart("muffleMessage")
[17:47:07.899]                       }
[17:47:07.899]                       else if (inherits(cond, "warning")) {
[17:47:07.899]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.899]                         if (muffled) 
[17:47:07.899]                           invokeRestart("muffleWarning")
[17:47:07.899]                       }
[17:47:07.899]                       else if (inherits(cond, "condition")) {
[17:47:07.899]                         if (!is.null(pattern)) {
[17:47:07.899]                           computeRestarts <- base::computeRestarts
[17:47:07.899]                           grepl <- base::grepl
[17:47:07.899]                           restarts <- computeRestarts(cond)
[17:47:07.899]                           for (restart in restarts) {
[17:47:07.899]                             name <- restart$name
[17:47:07.899]                             if (is.null(name)) 
[17:47:07.899]                               next
[17:47:07.899]                             if (!grepl(pattern, name)) 
[17:47:07.899]                               next
[17:47:07.899]                             invokeRestart(restart)
[17:47:07.899]                             muffled <- TRUE
[17:47:07.899]                             break
[17:47:07.899]                           }
[17:47:07.899]                         }
[17:47:07.899]                       }
[17:47:07.899]                       invisible(muffled)
[17:47:07.899]                     }
[17:47:07.899]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.899]                   }
[17:47:07.899]                 }
[17:47:07.899]             }
[17:47:07.899]         }))
[17:47:07.899]     }, error = function(ex) {
[17:47:07.899]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.899]                 ...future.rng), started = ...future.startTime, 
[17:47:07.899]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.899]             version = "1.8"), class = "FutureResult")
[17:47:07.899]     }, finally = {
[17:47:07.899]         if (!identical(...future.workdir, getwd())) 
[17:47:07.899]             setwd(...future.workdir)
[17:47:07.899]         {
[17:47:07.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.899]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.899]             }
[17:47:07.899]             base::options(...future.oldOptions)
[17:47:07.899]             if (.Platform$OS.type == "windows") {
[17:47:07.899]                 old_names <- names(...future.oldEnvVars)
[17:47:07.899]                 envs <- base::Sys.getenv()
[17:47:07.899]                 names <- names(envs)
[17:47:07.899]                 common <- intersect(names, old_names)
[17:47:07.899]                 added <- setdiff(names, old_names)
[17:47:07.899]                 removed <- setdiff(old_names, names)
[17:47:07.899]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.899]                   envs[common]]
[17:47:07.899]                 NAMES <- toupper(changed)
[17:47:07.899]                 args <- list()
[17:47:07.899]                 for (kk in seq_along(NAMES)) {
[17:47:07.899]                   name <- changed[[kk]]
[17:47:07.899]                   NAME <- NAMES[[kk]]
[17:47:07.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.899]                     next
[17:47:07.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.899]                 }
[17:47:07.899]                 NAMES <- toupper(added)
[17:47:07.899]                 for (kk in seq_along(NAMES)) {
[17:47:07.899]                   name <- added[[kk]]
[17:47:07.899]                   NAME <- NAMES[[kk]]
[17:47:07.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.899]                     next
[17:47:07.899]                   args[[name]] <- ""
[17:47:07.899]                 }
[17:47:07.899]                 NAMES <- toupper(removed)
[17:47:07.899]                 for (kk in seq_along(NAMES)) {
[17:47:07.899]                   name <- removed[[kk]]
[17:47:07.899]                   NAME <- NAMES[[kk]]
[17:47:07.899]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.899]                     next
[17:47:07.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.899]                 }
[17:47:07.899]                 if (length(args) > 0) 
[17:47:07.899]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.899]             }
[17:47:07.899]             else {
[17:47:07.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.899]             }
[17:47:07.899]             {
[17:47:07.899]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.899]                   0L) {
[17:47:07.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.899]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.899]                   base::options(opts)
[17:47:07.899]                 }
[17:47:07.899]                 {
[17:47:07.899]                   {
[17:47:07.899]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.899]                     NULL
[17:47:07.899]                   }
[17:47:07.899]                   options(future.plan = NULL)
[17:47:07.899]                   if (is.na(NA_character_)) 
[17:47:07.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.899]                     .init = FALSE)
[17:47:07.899]                 }
[17:47:07.899]             }
[17:47:07.899]         }
[17:47:07.899]     })
[17:47:07.899]     if (TRUE) {
[17:47:07.899]         base::sink(type = "output", split = FALSE)
[17:47:07.899]         if (TRUE) {
[17:47:07.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.899]         }
[17:47:07.899]         else {
[17:47:07.899]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.899]         }
[17:47:07.899]         base::close(...future.stdout)
[17:47:07.899]         ...future.stdout <- NULL
[17:47:07.899]     }
[17:47:07.899]     ...future.result$conditions <- ...future.conditions
[17:47:07.899]     ...future.result$finished <- base::Sys.time()
[17:47:07.899]     ...future.result
[17:47:07.899] }
[17:47:07.902] requestCore(): workers = 2
[17:47:07.904] MulticoreFuture started
[17:47:07.904] - Launch lazy future ... done
[17:47:07.904] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.905] plan(): Setting new future strategy stack:
[17:47:07.905] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.905] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.905] List of future strategies:
[17:47:07.905] 1. sequential:
[17:47:07.905]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.905]    - tweaked: FALSE
[17:47:07.905]    - call: NULL
[17:47:07.906] plan(): nbrOfWorkers() = 1
[17:47:07.907] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:07.907] Searching for globals ... DONE
[17:47:07.907] Resolving globals: TRUE
[17:47:07.907] Resolving any globals that are futures ...
[17:47:07.908] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:07.908] Resolving any globals that are futures ... DONE
[17:47:07.908] plan(): Setting new future strategy stack:
[17:47:07.908] Resolving futures part of globals (recursively) ...
[17:47:07.908] List of future strategies:
[17:47:07.908] 1. multicore:
[17:47:07.908]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.908]    - tweaked: FALSE
[17:47:07.908]    - call: plan(strategy)
[17:47:07.909] resolve() on list ...
[17:47:07.909]  recursive: 99
[17:47:07.909]  length: 1
[17:47:07.909]  elements: ‘a’
[17:47:07.913] plan(): nbrOfWorkers() = 2
[17:47:07.913] Future #1
[17:47:07.913] result() for MulticoreFuture ...
[17:47:07.914] result() for MulticoreFuture ...
[17:47:07.915] result() for MulticoreFuture ... done
[17:47:07.915] result() for MulticoreFuture ... done
[17:47:07.915] result() for MulticoreFuture ...
[17:47:07.915] result() for MulticoreFuture ... done
[17:47:07.915] A MulticoreFuture was resolved
[17:47:07.915]  length: 0 (resolved future 1)
[17:47:07.916] resolve() on list ... DONE
[17:47:07.916] - globals: [1] ‘a’
[17:47:07.916] Resolving futures part of globals (recursively) ... DONE
[17:47:07.919] The total size of the 1 globals is 1.57 MiB (1647480 bytes)
[17:47:07.919] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:47:07.919] - globals: [1] ‘a’
[17:47:07.919] - packages: [1] ‘future’
[17:47:07.922] getGlobalsAndPackages() ... DONE
[17:47:07.922] run() for ‘Future’ ...
[17:47:07.923] - state: ‘created’
[17:47:07.923] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.927] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.927] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.927]   - Field: ‘label’
[17:47:07.927]   - Field: ‘local’
[17:47:07.928]   - Field: ‘owner’
[17:47:07.928]   - Field: ‘envir’
[17:47:07.928]   - Field: ‘workers’
[17:47:07.928]   - Field: ‘packages’
[17:47:07.928]   - Field: ‘gc’
[17:47:07.928]   - Field: ‘job’
[17:47:07.928]   - Field: ‘conditions’
[17:47:07.928]   - Field: ‘expr’
[17:47:07.929]   - Field: ‘uuid’
[17:47:07.929]   - Field: ‘seed’
[17:47:07.929]   - Field: ‘version’
[17:47:07.929]   - Field: ‘result’
[17:47:07.929]   - Field: ‘asynchronous’
[17:47:07.929]   - Field: ‘calls’
[17:47:07.929]   - Field: ‘globals’
[17:47:07.929]   - Field: ‘stdout’
[17:47:07.930]   - Field: ‘earlySignal’
[17:47:07.930]   - Field: ‘lazy’
[17:47:07.930]   - Field: ‘state’
[17:47:07.930] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.930] - Launch lazy future ...
[17:47:07.930] Packages needed by the future expression (n = 1): ‘future’
[17:47:07.931] Packages needed by future strategies (n = 0): <none>
[17:47:07.931] {
[17:47:07.931]     {
[17:47:07.931]         {
[17:47:07.931]             ...future.startTime <- base::Sys.time()
[17:47:07.931]             {
[17:47:07.931]                 {
[17:47:07.931]                   {
[17:47:07.931]                     {
[17:47:07.931]                       {
[17:47:07.931]                         base::local({
[17:47:07.931]                           has_future <- base::requireNamespace("future", 
[17:47:07.931]                             quietly = TRUE)
[17:47:07.931]                           if (has_future) {
[17:47:07.931]                             ns <- base::getNamespace("future")
[17:47:07.931]                             version <- ns[[".package"]][["version"]]
[17:47:07.931]                             if (is.null(version)) 
[17:47:07.931]                               version <- utils::packageVersion("future")
[17:47:07.931]                           }
[17:47:07.931]                           else {
[17:47:07.931]                             version <- NULL
[17:47:07.931]                           }
[17:47:07.931]                           if (!has_future || version < "1.8.0") {
[17:47:07.931]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.931]                               "", base::R.version$version.string), 
[17:47:07.931]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:07.931]                                 base::R.version$platform, 8 * 
[17:47:07.931]                                   base::.Machine$sizeof.pointer), 
[17:47:07.931]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.931]                                 "release", "version")], collapse = " "), 
[17:47:07.931]                               hostname = base::Sys.info()[["nodename"]])
[17:47:07.931]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.931]                               info)
[17:47:07.931]                             info <- base::paste(info, collapse = "; ")
[17:47:07.931]                             if (!has_future) {
[17:47:07.931]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.931]                                 info)
[17:47:07.931]                             }
[17:47:07.931]                             else {
[17:47:07.931]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.931]                                 info, version)
[17:47:07.931]                             }
[17:47:07.931]                             base::stop(msg)
[17:47:07.931]                           }
[17:47:07.931]                         })
[17:47:07.931]                       }
[17:47:07.931]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.931]                       base::options(mc.cores = 1L)
[17:47:07.931]                     }
[17:47:07.931]                     base::local({
[17:47:07.931]                       for (pkg in "future") {
[17:47:07.931]                         base::loadNamespace(pkg)
[17:47:07.931]                         base::library(pkg, character.only = TRUE)
[17:47:07.931]                       }
[17:47:07.931]                     })
[17:47:07.931]                   }
[17:47:07.931]                   ...future.strategy.old <- future::plan("list")
[17:47:07.931]                   options(future.plan = NULL)
[17:47:07.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.931]                 }
[17:47:07.931]                 ...future.workdir <- getwd()
[17:47:07.931]             }
[17:47:07.931]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.931]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.931]         }
[17:47:07.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.931]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.931]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.931]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.931]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.931]             base::names(...future.oldOptions))
[17:47:07.931]     }
[17:47:07.931]     if (FALSE) {
[17:47:07.931]     }
[17:47:07.931]     else {
[17:47:07.931]         if (TRUE) {
[17:47:07.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.931]                 open = "w")
[17:47:07.931]         }
[17:47:07.931]         else {
[17:47:07.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.931]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.931]         }
[17:47:07.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.931]             base::sink(type = "output", split = FALSE)
[17:47:07.931]             base::close(...future.stdout)
[17:47:07.931]         }, add = TRUE)
[17:47:07.931]     }
[17:47:07.931]     ...future.frame <- base::sys.nframe()
[17:47:07.931]     ...future.conditions <- base::list()
[17:47:07.931]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.931]     if (FALSE) {
[17:47:07.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.931]     }
[17:47:07.931]     ...future.result <- base::tryCatch({
[17:47:07.931]         base::withCallingHandlers({
[17:47:07.931]             ...future.value <- base::withVisible(base::local({
[17:47:07.931]                 withCallingHandlers({
[17:47:07.931]                   value(a) + 1
[17:47:07.931]                 }, immediateCondition = function(cond) {
[17:47:07.931]                   save_rds <- function (object, pathname, ...) 
[17:47:07.931]                   {
[17:47:07.931]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.931]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.931]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.931]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.931]                         fi_tmp[["mtime"]])
[17:47:07.931]                     }
[17:47:07.931]                     tryCatch({
[17:47:07.931]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.931]                     }, error = function(ex) {
[17:47:07.931]                       msg <- conditionMessage(ex)
[17:47:07.931]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.931]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.931]                         fi_tmp[["mtime"]], msg)
[17:47:07.931]                       ex$message <- msg
[17:47:07.931]                       stop(ex)
[17:47:07.931]                     })
[17:47:07.931]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.931]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.931]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.931]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.931]                       fi <- file.info(pathname)
[17:47:07.931]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.931]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.931]                         fi[["size"]], fi[["mtime"]])
[17:47:07.931]                       stop(msg)
[17:47:07.931]                     }
[17:47:07.931]                     invisible(pathname)
[17:47:07.931]                   }
[17:47:07.931]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.931]                     rootPath = tempdir()) 
[17:47:07.931]                   {
[17:47:07.931]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.931]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.931]                       tmpdir = path, fileext = ".rds")
[17:47:07.931]                     save_rds(obj, file)
[17:47:07.931]                   }
[17:47:07.931]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.931]                   {
[17:47:07.931]                     inherits <- base::inherits
[17:47:07.931]                     invokeRestart <- base::invokeRestart
[17:47:07.931]                     is.null <- base::is.null
[17:47:07.931]                     muffled <- FALSE
[17:47:07.931]                     if (inherits(cond, "message")) {
[17:47:07.931]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.931]                       if (muffled) 
[17:47:07.931]                         invokeRestart("muffleMessage")
[17:47:07.931]                     }
[17:47:07.931]                     else if (inherits(cond, "warning")) {
[17:47:07.931]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.931]                       if (muffled) 
[17:47:07.931]                         invokeRestart("muffleWarning")
[17:47:07.931]                     }
[17:47:07.931]                     else if (inherits(cond, "condition")) {
[17:47:07.931]                       if (!is.null(pattern)) {
[17:47:07.931]                         computeRestarts <- base::computeRestarts
[17:47:07.931]                         grepl <- base::grepl
[17:47:07.931]                         restarts <- computeRestarts(cond)
[17:47:07.931]                         for (restart in restarts) {
[17:47:07.931]                           name <- restart$name
[17:47:07.931]                           if (is.null(name)) 
[17:47:07.931]                             next
[17:47:07.931]                           if (!grepl(pattern, name)) 
[17:47:07.931]                             next
[17:47:07.931]                           invokeRestart(restart)
[17:47:07.931]                           muffled <- TRUE
[17:47:07.931]                           break
[17:47:07.931]                         }
[17:47:07.931]                       }
[17:47:07.931]                     }
[17:47:07.931]                     invisible(muffled)
[17:47:07.931]                   }
[17:47:07.931]                   muffleCondition(cond)
[17:47:07.931]                 })
[17:47:07.931]             }))
[17:47:07.931]             future::FutureResult(value = ...future.value$value, 
[17:47:07.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.931]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.931]                     ...future.globalenv.names))
[17:47:07.931]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.931]         }, condition = base::local({
[17:47:07.931]             c <- base::c
[17:47:07.931]             inherits <- base::inherits
[17:47:07.931]             invokeRestart <- base::invokeRestart
[17:47:07.931]             length <- base::length
[17:47:07.931]             list <- base::list
[17:47:07.931]             seq.int <- base::seq.int
[17:47:07.931]             signalCondition <- base::signalCondition
[17:47:07.931]             sys.calls <- base::sys.calls
[17:47:07.931]             `[[` <- base::`[[`
[17:47:07.931]             `+` <- base::`+`
[17:47:07.931]             `<<-` <- base::`<<-`
[17:47:07.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.931]                   3L)]
[17:47:07.931]             }
[17:47:07.931]             function(cond) {
[17:47:07.931]                 is_error <- inherits(cond, "error")
[17:47:07.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.931]                   NULL)
[17:47:07.931]                 if (is_error) {
[17:47:07.931]                   sessionInformation <- function() {
[17:47:07.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.931]                       search = base::search(), system = base::Sys.info())
[17:47:07.931]                   }
[17:47:07.931]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.931]                     cond$call), session = sessionInformation(), 
[17:47:07.931]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.931]                   signalCondition(cond)
[17:47:07.931]                 }
[17:47:07.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.931]                 "immediateCondition"))) {
[17:47:07.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.931]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.931]                   if (TRUE && !signal) {
[17:47:07.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.931]                     {
[17:47:07.931]                       inherits <- base::inherits
[17:47:07.931]                       invokeRestart <- base::invokeRestart
[17:47:07.931]                       is.null <- base::is.null
[17:47:07.931]                       muffled <- FALSE
[17:47:07.931]                       if (inherits(cond, "message")) {
[17:47:07.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.931]                         if (muffled) 
[17:47:07.931]                           invokeRestart("muffleMessage")
[17:47:07.931]                       }
[17:47:07.931]                       else if (inherits(cond, "warning")) {
[17:47:07.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.931]                         if (muffled) 
[17:47:07.931]                           invokeRestart("muffleWarning")
[17:47:07.931]                       }
[17:47:07.931]                       else if (inherits(cond, "condition")) {
[17:47:07.931]                         if (!is.null(pattern)) {
[17:47:07.931]                           computeRestarts <- base::computeRestarts
[17:47:07.931]                           grepl <- base::grepl
[17:47:07.931]                           restarts <- computeRestarts(cond)
[17:47:07.931]                           for (restart in restarts) {
[17:47:07.931]                             name <- restart$name
[17:47:07.931]                             if (is.null(name)) 
[17:47:07.931]                               next
[17:47:07.931]                             if (!grepl(pattern, name)) 
[17:47:07.931]                               next
[17:47:07.931]                             invokeRestart(restart)
[17:47:07.931]                             muffled <- TRUE
[17:47:07.931]                             break
[17:47:07.931]                           }
[17:47:07.931]                         }
[17:47:07.931]                       }
[17:47:07.931]                       invisible(muffled)
[17:47:07.931]                     }
[17:47:07.931]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.931]                   }
[17:47:07.931]                 }
[17:47:07.931]                 else {
[17:47:07.931]                   if (TRUE) {
[17:47:07.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.931]                     {
[17:47:07.931]                       inherits <- base::inherits
[17:47:07.931]                       invokeRestart <- base::invokeRestart
[17:47:07.931]                       is.null <- base::is.null
[17:47:07.931]                       muffled <- FALSE
[17:47:07.931]                       if (inherits(cond, "message")) {
[17:47:07.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.931]                         if (muffled) 
[17:47:07.931]                           invokeRestart("muffleMessage")
[17:47:07.931]                       }
[17:47:07.931]                       else if (inherits(cond, "warning")) {
[17:47:07.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.931]                         if (muffled) 
[17:47:07.931]                           invokeRestart("muffleWarning")
[17:47:07.931]                       }
[17:47:07.931]                       else if (inherits(cond, "condition")) {
[17:47:07.931]                         if (!is.null(pattern)) {
[17:47:07.931]                           computeRestarts <- base::computeRestarts
[17:47:07.931]                           grepl <- base::grepl
[17:47:07.931]                           restarts <- computeRestarts(cond)
[17:47:07.931]                           for (restart in restarts) {
[17:47:07.931]                             name <- restart$name
[17:47:07.931]                             if (is.null(name)) 
[17:47:07.931]                               next
[17:47:07.931]                             if (!grepl(pattern, name)) 
[17:47:07.931]                               next
[17:47:07.931]                             invokeRestart(restart)
[17:47:07.931]                             muffled <- TRUE
[17:47:07.931]                             break
[17:47:07.931]                           }
[17:47:07.931]                         }
[17:47:07.931]                       }
[17:47:07.931]                       invisible(muffled)
[17:47:07.931]                     }
[17:47:07.931]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.931]                   }
[17:47:07.931]                 }
[17:47:07.931]             }
[17:47:07.931]         }))
[17:47:07.931]     }, error = function(ex) {
[17:47:07.931]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.931]                 ...future.rng), started = ...future.startTime, 
[17:47:07.931]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.931]             version = "1.8"), class = "FutureResult")
[17:47:07.931]     }, finally = {
[17:47:07.931]         if (!identical(...future.workdir, getwd())) 
[17:47:07.931]             setwd(...future.workdir)
[17:47:07.931]         {
[17:47:07.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.931]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.931]             }
[17:47:07.931]             base::options(...future.oldOptions)
[17:47:07.931]             if (.Platform$OS.type == "windows") {
[17:47:07.931]                 old_names <- names(...future.oldEnvVars)
[17:47:07.931]                 envs <- base::Sys.getenv()
[17:47:07.931]                 names <- names(envs)
[17:47:07.931]                 common <- intersect(names, old_names)
[17:47:07.931]                 added <- setdiff(names, old_names)
[17:47:07.931]                 removed <- setdiff(old_names, names)
[17:47:07.931]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.931]                   envs[common]]
[17:47:07.931]                 NAMES <- toupper(changed)
[17:47:07.931]                 args <- list()
[17:47:07.931]                 for (kk in seq_along(NAMES)) {
[17:47:07.931]                   name <- changed[[kk]]
[17:47:07.931]                   NAME <- NAMES[[kk]]
[17:47:07.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.931]                     next
[17:47:07.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.931]                 }
[17:47:07.931]                 NAMES <- toupper(added)
[17:47:07.931]                 for (kk in seq_along(NAMES)) {
[17:47:07.931]                   name <- added[[kk]]
[17:47:07.931]                   NAME <- NAMES[[kk]]
[17:47:07.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.931]                     next
[17:47:07.931]                   args[[name]] <- ""
[17:47:07.931]                 }
[17:47:07.931]                 NAMES <- toupper(removed)
[17:47:07.931]                 for (kk in seq_along(NAMES)) {
[17:47:07.931]                   name <- removed[[kk]]
[17:47:07.931]                   NAME <- NAMES[[kk]]
[17:47:07.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.931]                     next
[17:47:07.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.931]                 }
[17:47:07.931]                 if (length(args) > 0) 
[17:47:07.931]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.931]             }
[17:47:07.931]             else {
[17:47:07.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.931]             }
[17:47:07.931]             {
[17:47:07.931]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.931]                   0L) {
[17:47:07.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.931]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.931]                   base::options(opts)
[17:47:07.931]                 }
[17:47:07.931]                 {
[17:47:07.931]                   {
[17:47:07.931]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.931]                     NULL
[17:47:07.931]                   }
[17:47:07.931]                   options(future.plan = NULL)
[17:47:07.931]                   if (is.na(NA_character_)) 
[17:47:07.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.931]                     .init = FALSE)
[17:47:07.931]                 }
[17:47:07.931]             }
[17:47:07.931]         }
[17:47:07.931]     })
[17:47:07.931]     if (TRUE) {
[17:47:07.931]         base::sink(type = "output", split = FALSE)
[17:47:07.931]         if (TRUE) {
[17:47:07.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.931]         }
[17:47:07.931]         else {
[17:47:07.931]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.931]         }
[17:47:07.931]         base::close(...future.stdout)
[17:47:07.931]         ...future.stdout <- NULL
[17:47:07.931]     }
[17:47:07.931]     ...future.result$conditions <- ...future.conditions
[17:47:07.931]     ...future.result$finished <- base::Sys.time()
[17:47:07.931]     ...future.result
[17:47:07.931] }
[17:47:07.934] assign_globals() ...
[17:47:07.934] List of 1
[17:47:07.934]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558b30d03c08> 
[17:47:07.934]  - attr(*, "where")=List of 1
[17:47:07.934]   ..$ a:<environment: R_EmptyEnv> 
[17:47:07.934]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:07.934]  - attr(*, "resolved")= logi TRUE
[17:47:07.934]  - attr(*, "total_size")= num 1647480
[17:47:07.934]  - attr(*, "already-done")= logi TRUE
[17:47:07.937] - copied ‘a’ to environment
[17:47:07.937] assign_globals() ... done
[17:47:07.937] requestCore(): workers = 2
[17:47:07.939] MulticoreFuture started
[17:47:07.940] - Launch lazy future ... done
[17:47:07.940] run() for ‘MulticoreFuture’ ... done
[17:47:07.940] result() for MulticoreFuture ...
[17:47:07.941] plan(): Setting new future strategy stack:
[17:47:07.941] List of future strategies:
[17:47:07.941] 1. sequential:
[17:47:07.941]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.941]    - tweaked: FALSE
[17:47:07.941]    - call: NULL
[17:47:07.942] plan(): nbrOfWorkers() = 1
[17:47:07.946] plan(): Setting new future strategy stack:
[17:47:07.946] List of future strategies:
[17:47:07.946] 1. multicore:
[17:47:07.946]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.946]    - tweaked: FALSE
[17:47:07.946]    - call: plan(strategy)
[17:47:07.951] plan(): nbrOfWorkers() = 2
[17:47:07.952] result() for MulticoreFuture ...
[17:47:07.952] result() for MulticoreFuture ... done
[17:47:07.953] signalConditions() ...
[17:47:07.953]  - include = ‘immediateCondition’
[17:47:07.953]  - exclude = 
[17:47:07.953]  - resignal = FALSE
[17:47:07.953]  - Number of conditions: 4
[17:47:07.953] signalConditions() ... done
[17:47:07.954] result() for MulticoreFuture ... done
[17:47:07.954] result() for MulticoreFuture ...
[17:47:07.954] result() for MulticoreFuture ... done
[17:47:07.954] signalConditions() ...
[17:47:07.954]  - include = ‘immediateCondition’
[17:47:07.955]  - exclude = 
[17:47:07.955]  - resignal = FALSE
[17:47:07.955]  - Number of conditions: 4
[17:47:07.955] signalConditions() ... done
[17:47:07.955] Future state: ‘finished’
[17:47:07.955] result() for MulticoreFuture ...
[17:47:07.955] result() for MulticoreFuture ... done
[17:47:07.956] signalConditions() ...
[17:47:07.956]  - include = ‘condition’
[17:47:07.956]  - exclude = ‘immediateCondition’
[17:47:07.956]  - resignal = TRUE
[17:47:07.956]  - Number of conditions: 4
[17:47:07.956]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.944] result() for MulticoreFuture ...
[17:47:07.956]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.944] result() for MulticoreFuture ... done
[17:47:07.956]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.944] result() for MulticoreFuture ...
[17:47:07.957]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.944] result() for MulticoreFuture ... done
[17:47:07.957] signalConditions() ... done
value(b) = 2
[17:47:07.957] result() for MulticoreFuture ...
[17:47:07.957] result() for MulticoreFuture ... done
[17:47:07.957] result() for MulticoreFuture ...
[17:47:07.957] result() for MulticoreFuture ... done
[17:47:07.957] signalConditions() ...
[17:47:07.958]  - include = ‘immediateCondition’
[17:47:07.958]  - exclude = 
[17:47:07.958]  - resignal = FALSE
[17:47:07.958]  - Number of conditions: 4
[17:47:07.958] signalConditions() ... done
[17:47:07.958] Future state: ‘finished’
[17:47:07.958] result() for MulticoreFuture ...
[17:47:07.958] result() for MulticoreFuture ... done
[17:47:07.958] signalConditions() ...
[17:47:07.959]  - include = ‘condition’
[17:47:07.959]  - exclude = ‘immediateCondition’
[17:47:07.959]  - resignal = TRUE
[17:47:07.959]  - Number of conditions: 4
[17:47:07.959]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.944] result() for MulticoreFuture ...
[17:47:07.959]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.944] result() for MulticoreFuture ... done
[17:47:07.959]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.944] result() for MulticoreFuture ...
[17:47:07.959]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:07.944] result() for MulticoreFuture ... done
[17:47:07.960] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.960] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.960] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.961] 
[17:47:07.961] Searching for globals ... DONE
[17:47:07.961] - globals: [0] <none>
[17:47:07.961] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:07.962] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:07.962] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:07.963] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:07.963] Searching for globals ... DONE
[17:47:07.963] Resolving globals: TRUE
[17:47:07.963] Resolving any globals that are futures ...
[17:47:07.963] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:07.963] Resolving any globals that are futures ... DONE
[17:47:07.964] Resolving futures part of globals (recursively) ...
[17:47:07.964] resolve() on list ...
[17:47:07.964]  recursive: 99
[17:47:07.964]  length: 1
[17:47:07.964]  elements: ‘a’
[17:47:07.965] run() for ‘Future’ ...
[17:47:07.965] - state: ‘created’
[17:47:07.965] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:07.969] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:07.969] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:07.969]   - Field: ‘label’
[17:47:07.969]   - Field: ‘local’
[17:47:07.970]   - Field: ‘owner’
[17:47:07.970]   - Field: ‘envir’
[17:47:07.970]   - Field: ‘workers’
[17:47:07.970]   - Field: ‘packages’
[17:47:07.970]   - Field: ‘gc’
[17:47:07.970]   - Field: ‘job’
[17:47:07.970]   - Field: ‘conditions’
[17:47:07.970]   - Field: ‘expr’
[17:47:07.970]   - Field: ‘uuid’
[17:47:07.971]   - Field: ‘seed’
[17:47:07.971]   - Field: ‘version’
[17:47:07.971]   - Field: ‘result’
[17:47:07.971]   - Field: ‘asynchronous’
[17:47:07.971]   - Field: ‘calls’
[17:47:07.971]   - Field: ‘globals’
[17:47:07.971]   - Field: ‘stdout’
[17:47:07.971]   - Field: ‘earlySignal’
[17:47:07.972]   - Field: ‘lazy’
[17:47:07.972]   - Field: ‘state’
[17:47:07.972] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:07.972] - Launch lazy future ...
[17:47:07.972] Packages needed by the future expression (n = 0): <none>
[17:47:07.972] Packages needed by future strategies (n = 0): <none>
[17:47:07.975] {
[17:47:07.975]     {
[17:47:07.975]         {
[17:47:07.975]             ...future.startTime <- base::Sys.time()
[17:47:07.975]             {
[17:47:07.975]                 {
[17:47:07.975]                   {
[17:47:07.975]                     {
[17:47:07.975]                       base::local({
[17:47:07.975]                         has_future <- base::requireNamespace("future", 
[17:47:07.975]                           quietly = TRUE)
[17:47:07.975]                         if (has_future) {
[17:47:07.975]                           ns <- base::getNamespace("future")
[17:47:07.975]                           version <- ns[[".package"]][["version"]]
[17:47:07.975]                           if (is.null(version)) 
[17:47:07.975]                             version <- utils::packageVersion("future")
[17:47:07.975]                         }
[17:47:07.975]                         else {
[17:47:07.975]                           version <- NULL
[17:47:07.975]                         }
[17:47:07.975]                         if (!has_future || version < "1.8.0") {
[17:47:07.975]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:07.975]                             "", base::R.version$version.string), 
[17:47:07.975]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:07.975]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:07.975]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:07.975]                               "release", "version")], collapse = " "), 
[17:47:07.975]                             hostname = base::Sys.info()[["nodename"]])
[17:47:07.975]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:07.975]                             info)
[17:47:07.975]                           info <- base::paste(info, collapse = "; ")
[17:47:07.975]                           if (!has_future) {
[17:47:07.975]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:07.975]                               info)
[17:47:07.975]                           }
[17:47:07.975]                           else {
[17:47:07.975]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:07.975]                               info, version)
[17:47:07.975]                           }
[17:47:07.975]                           base::stop(msg)
[17:47:07.975]                         }
[17:47:07.975]                       })
[17:47:07.975]                     }
[17:47:07.975]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:07.975]                     base::options(mc.cores = 1L)
[17:47:07.975]                   }
[17:47:07.975]                   ...future.strategy.old <- future::plan("list")
[17:47:07.975]                   options(future.plan = NULL)
[17:47:07.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:07.975]                 }
[17:47:07.975]                 ...future.workdir <- getwd()
[17:47:07.975]             }
[17:47:07.975]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:07.975]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:07.975]         }
[17:47:07.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:07.975]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:07.975]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:07.975]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:07.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:07.975]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:07.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:07.975]             base::names(...future.oldOptions))
[17:47:07.975]     }
[17:47:07.975]     if (FALSE) {
[17:47:07.975]     }
[17:47:07.975]     else {
[17:47:07.975]         if (TRUE) {
[17:47:07.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:07.975]                 open = "w")
[17:47:07.975]         }
[17:47:07.975]         else {
[17:47:07.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:07.975]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:07.975]         }
[17:47:07.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:07.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:07.975]             base::sink(type = "output", split = FALSE)
[17:47:07.975]             base::close(...future.stdout)
[17:47:07.975]         }, add = TRUE)
[17:47:07.975]     }
[17:47:07.975]     ...future.frame <- base::sys.nframe()
[17:47:07.975]     ...future.conditions <- base::list()
[17:47:07.975]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:07.975]     if (FALSE) {
[17:47:07.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:07.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:07.975]     }
[17:47:07.975]     ...future.result <- base::tryCatch({
[17:47:07.975]         base::withCallingHandlers({
[17:47:07.975]             ...future.value <- base::withVisible(base::local({
[17:47:07.975]                 withCallingHandlers({
[17:47:07.975]                   1
[17:47:07.975]                 }, immediateCondition = function(cond) {
[17:47:07.975]                   save_rds <- function (object, pathname, ...) 
[17:47:07.975]                   {
[17:47:07.975]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:07.975]                     if (file_test("-f", pathname_tmp)) {
[17:47:07.975]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.975]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:07.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.975]                         fi_tmp[["mtime"]])
[17:47:07.975]                     }
[17:47:07.975]                     tryCatch({
[17:47:07.975]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:07.975]                     }, error = function(ex) {
[17:47:07.975]                       msg <- conditionMessage(ex)
[17:47:07.975]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.975]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:07.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.975]                         fi_tmp[["mtime"]], msg)
[17:47:07.975]                       ex$message <- msg
[17:47:07.975]                       stop(ex)
[17:47:07.975]                     })
[17:47:07.975]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:07.975]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:07.975]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:07.975]                       fi_tmp <- file.info(pathname_tmp)
[17:47:07.975]                       fi <- file.info(pathname)
[17:47:07.975]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:07.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:07.975]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:07.975]                         fi[["size"]], fi[["mtime"]])
[17:47:07.975]                       stop(msg)
[17:47:07.975]                     }
[17:47:07.975]                     invisible(pathname)
[17:47:07.975]                   }
[17:47:07.975]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:07.975]                     rootPath = tempdir()) 
[17:47:07.975]                   {
[17:47:07.975]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:07.975]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:07.975]                       tmpdir = path, fileext = ".rds")
[17:47:07.975]                     save_rds(obj, file)
[17:47:07.975]                   }
[17:47:07.975]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:07.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.975]                   {
[17:47:07.975]                     inherits <- base::inherits
[17:47:07.975]                     invokeRestart <- base::invokeRestart
[17:47:07.975]                     is.null <- base::is.null
[17:47:07.975]                     muffled <- FALSE
[17:47:07.975]                     if (inherits(cond, "message")) {
[17:47:07.975]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:07.975]                       if (muffled) 
[17:47:07.975]                         invokeRestart("muffleMessage")
[17:47:07.975]                     }
[17:47:07.975]                     else if (inherits(cond, "warning")) {
[17:47:07.975]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:07.975]                       if (muffled) 
[17:47:07.975]                         invokeRestart("muffleWarning")
[17:47:07.975]                     }
[17:47:07.975]                     else if (inherits(cond, "condition")) {
[17:47:07.975]                       if (!is.null(pattern)) {
[17:47:07.975]                         computeRestarts <- base::computeRestarts
[17:47:07.975]                         grepl <- base::grepl
[17:47:07.975]                         restarts <- computeRestarts(cond)
[17:47:07.975]                         for (restart in restarts) {
[17:47:07.975]                           name <- restart$name
[17:47:07.975]                           if (is.null(name)) 
[17:47:07.975]                             next
[17:47:07.975]                           if (!grepl(pattern, name)) 
[17:47:07.975]                             next
[17:47:07.975]                           invokeRestart(restart)
[17:47:07.975]                           muffled <- TRUE
[17:47:07.975]                           break
[17:47:07.975]                         }
[17:47:07.975]                       }
[17:47:07.975]                     }
[17:47:07.975]                     invisible(muffled)
[17:47:07.975]                   }
[17:47:07.975]                   muffleCondition(cond)
[17:47:07.975]                 })
[17:47:07.975]             }))
[17:47:07.975]             future::FutureResult(value = ...future.value$value, 
[17:47:07.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.975]                   ...future.rng), globalenv = if (FALSE) 
[17:47:07.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:07.975]                     ...future.globalenv.names))
[17:47:07.975]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:07.975]         }, condition = base::local({
[17:47:07.975]             c <- base::c
[17:47:07.975]             inherits <- base::inherits
[17:47:07.975]             invokeRestart <- base::invokeRestart
[17:47:07.975]             length <- base::length
[17:47:07.975]             list <- base::list
[17:47:07.975]             seq.int <- base::seq.int
[17:47:07.975]             signalCondition <- base::signalCondition
[17:47:07.975]             sys.calls <- base::sys.calls
[17:47:07.975]             `[[` <- base::`[[`
[17:47:07.975]             `+` <- base::`+`
[17:47:07.975]             `<<-` <- base::`<<-`
[17:47:07.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:07.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:07.975]                   3L)]
[17:47:07.975]             }
[17:47:07.975]             function(cond) {
[17:47:07.975]                 is_error <- inherits(cond, "error")
[17:47:07.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:07.975]                   NULL)
[17:47:07.975]                 if (is_error) {
[17:47:07.975]                   sessionInformation <- function() {
[17:47:07.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:07.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:07.975]                       search = base::search(), system = base::Sys.info())
[17:47:07.975]                   }
[17:47:07.975]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:07.975]                     cond$call), session = sessionInformation(), 
[17:47:07.975]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:07.975]                   signalCondition(cond)
[17:47:07.975]                 }
[17:47:07.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:07.975]                 "immediateCondition"))) {
[17:47:07.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:07.975]                   ...future.conditions[[length(...future.conditions) + 
[17:47:07.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:07.975]                   if (TRUE && !signal) {
[17:47:07.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.975]                     {
[17:47:07.975]                       inherits <- base::inherits
[17:47:07.975]                       invokeRestart <- base::invokeRestart
[17:47:07.975]                       is.null <- base::is.null
[17:47:07.975]                       muffled <- FALSE
[17:47:07.975]                       if (inherits(cond, "message")) {
[17:47:07.975]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.975]                         if (muffled) 
[17:47:07.975]                           invokeRestart("muffleMessage")
[17:47:07.975]                       }
[17:47:07.975]                       else if (inherits(cond, "warning")) {
[17:47:07.975]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.975]                         if (muffled) 
[17:47:07.975]                           invokeRestart("muffleWarning")
[17:47:07.975]                       }
[17:47:07.975]                       else if (inherits(cond, "condition")) {
[17:47:07.975]                         if (!is.null(pattern)) {
[17:47:07.975]                           computeRestarts <- base::computeRestarts
[17:47:07.975]                           grepl <- base::grepl
[17:47:07.975]                           restarts <- computeRestarts(cond)
[17:47:07.975]                           for (restart in restarts) {
[17:47:07.975]                             name <- restart$name
[17:47:07.975]                             if (is.null(name)) 
[17:47:07.975]                               next
[17:47:07.975]                             if (!grepl(pattern, name)) 
[17:47:07.975]                               next
[17:47:07.975]                             invokeRestart(restart)
[17:47:07.975]                             muffled <- TRUE
[17:47:07.975]                             break
[17:47:07.975]                           }
[17:47:07.975]                         }
[17:47:07.975]                       }
[17:47:07.975]                       invisible(muffled)
[17:47:07.975]                     }
[17:47:07.975]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.975]                   }
[17:47:07.975]                 }
[17:47:07.975]                 else {
[17:47:07.975]                   if (TRUE) {
[17:47:07.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:07.975]                     {
[17:47:07.975]                       inherits <- base::inherits
[17:47:07.975]                       invokeRestart <- base::invokeRestart
[17:47:07.975]                       is.null <- base::is.null
[17:47:07.975]                       muffled <- FALSE
[17:47:07.975]                       if (inherits(cond, "message")) {
[17:47:07.975]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:07.975]                         if (muffled) 
[17:47:07.975]                           invokeRestart("muffleMessage")
[17:47:07.975]                       }
[17:47:07.975]                       else if (inherits(cond, "warning")) {
[17:47:07.975]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:07.975]                         if (muffled) 
[17:47:07.975]                           invokeRestart("muffleWarning")
[17:47:07.975]                       }
[17:47:07.975]                       else if (inherits(cond, "condition")) {
[17:47:07.975]                         if (!is.null(pattern)) {
[17:47:07.975]                           computeRestarts <- base::computeRestarts
[17:47:07.975]                           grepl <- base::grepl
[17:47:07.975]                           restarts <- computeRestarts(cond)
[17:47:07.975]                           for (restart in restarts) {
[17:47:07.975]                             name <- restart$name
[17:47:07.975]                             if (is.null(name)) 
[17:47:07.975]                               next
[17:47:07.975]                             if (!grepl(pattern, name)) 
[17:47:07.975]                               next
[17:47:07.975]                             invokeRestart(restart)
[17:47:07.975]                             muffled <- TRUE
[17:47:07.975]                             break
[17:47:07.975]                           }
[17:47:07.975]                         }
[17:47:07.975]                       }
[17:47:07.975]                       invisible(muffled)
[17:47:07.975]                     }
[17:47:07.975]                     muffleCondition(cond, pattern = "^muffle")
[17:47:07.975]                   }
[17:47:07.975]                 }
[17:47:07.975]             }
[17:47:07.975]         }))
[17:47:07.975]     }, error = function(ex) {
[17:47:07.975]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:07.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:07.975]                 ...future.rng), started = ...future.startTime, 
[17:47:07.975]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:07.975]             version = "1.8"), class = "FutureResult")
[17:47:07.975]     }, finally = {
[17:47:07.975]         if (!identical(...future.workdir, getwd())) 
[17:47:07.975]             setwd(...future.workdir)
[17:47:07.975]         {
[17:47:07.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:07.975]                 ...future.oldOptions$nwarnings <- NULL
[17:47:07.975]             }
[17:47:07.975]             base::options(...future.oldOptions)
[17:47:07.975]             if (.Platform$OS.type == "windows") {
[17:47:07.975]                 old_names <- names(...future.oldEnvVars)
[17:47:07.975]                 envs <- base::Sys.getenv()
[17:47:07.975]                 names <- names(envs)
[17:47:07.975]                 common <- intersect(names, old_names)
[17:47:07.975]                 added <- setdiff(names, old_names)
[17:47:07.975]                 removed <- setdiff(old_names, names)
[17:47:07.975]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:07.975]                   envs[common]]
[17:47:07.975]                 NAMES <- toupper(changed)
[17:47:07.975]                 args <- list()
[17:47:07.975]                 for (kk in seq_along(NAMES)) {
[17:47:07.975]                   name <- changed[[kk]]
[17:47:07.975]                   NAME <- NAMES[[kk]]
[17:47:07.975]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.975]                     next
[17:47:07.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.975]                 }
[17:47:07.975]                 NAMES <- toupper(added)
[17:47:07.975]                 for (kk in seq_along(NAMES)) {
[17:47:07.975]                   name <- added[[kk]]
[17:47:07.975]                   NAME <- NAMES[[kk]]
[17:47:07.975]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.975]                     next
[17:47:07.975]                   args[[name]] <- ""
[17:47:07.975]                 }
[17:47:07.975]                 NAMES <- toupper(removed)
[17:47:07.975]                 for (kk in seq_along(NAMES)) {
[17:47:07.975]                   name <- removed[[kk]]
[17:47:07.975]                   NAME <- NAMES[[kk]]
[17:47:07.975]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:07.975]                     next
[17:47:07.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:07.975]                 }
[17:47:07.975]                 if (length(args) > 0) 
[17:47:07.975]                   base::do.call(base::Sys.setenv, args = args)
[17:47:07.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:07.975]             }
[17:47:07.975]             else {
[17:47:07.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:07.975]             }
[17:47:07.975]             {
[17:47:07.975]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:07.975]                   0L) {
[17:47:07.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:07.975]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:07.975]                   base::options(opts)
[17:47:07.975]                 }
[17:47:07.975]                 {
[17:47:07.975]                   {
[17:47:07.975]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:07.975]                     NULL
[17:47:07.975]                   }
[17:47:07.975]                   options(future.plan = NULL)
[17:47:07.975]                   if (is.na(NA_character_)) 
[17:47:07.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:07.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:07.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:07.975]                     .init = FALSE)
[17:47:07.975]                 }
[17:47:07.975]             }
[17:47:07.975]         }
[17:47:07.975]     })
[17:47:07.975]     if (TRUE) {
[17:47:07.975]         base::sink(type = "output", split = FALSE)
[17:47:07.975]         if (TRUE) {
[17:47:07.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:07.975]         }
[17:47:07.975]         else {
[17:47:07.975]             ...future.result["stdout"] <- base::list(NULL)
[17:47:07.975]         }
[17:47:07.975]         base::close(...future.stdout)
[17:47:07.975]         ...future.stdout <- NULL
[17:47:07.975]     }
[17:47:07.975]     ...future.result$conditions <- ...future.conditions
[17:47:07.975]     ...future.result$finished <- base::Sys.time()
[17:47:07.975]     ...future.result
[17:47:07.975] }
[17:47:07.978] requestCore(): workers = 2
[17:47:07.980] MulticoreFuture started
[17:47:07.980] - Launch lazy future ... done
[17:47:07.981] run() for ‘MulticoreFuture’ ... done
[17:47:07.981] plan(): Setting new future strategy stack:
[17:47:07.981] List of future strategies:
[17:47:07.981] 1. sequential:
[17:47:07.981]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:07.981]    - tweaked: FALSE
[17:47:07.981]    - call: NULL
[17:47:07.983] plan(): nbrOfWorkers() = 1
[17:47:07.985] plan(): Setting new future strategy stack:
[17:47:07.985] List of future strategies:
[17:47:07.985] 1. multicore:
[17:47:07.985]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:07.985]    - tweaked: FALSE
[17:47:07.985]    - call: plan(strategy)
[17:47:07.991] plan(): nbrOfWorkers() = 2
[17:47:08.002] Future #1
[17:47:08.002] result() for MulticoreFuture ...
[17:47:08.003] result() for MulticoreFuture ...
[17:47:08.003] result() for MulticoreFuture ... done
[17:47:08.003] result() for MulticoreFuture ... done
[17:47:08.003] result() for MulticoreFuture ...
[17:47:08.003] result() for MulticoreFuture ... done
[17:47:08.004] A MulticoreFuture was resolved
[17:47:08.004]  length: 0 (resolved future 1)
[17:47:08.004] resolve() on list ... DONE
[17:47:08.004] - globals: [1] ‘a’
[17:47:08.005] Resolving futures part of globals (recursively) ... DONE
[17:47:08.008] The total size of the 1 globals is 1.57 MiB (1647648 bytes)
[17:47:08.009] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:47:08.009] - globals: [1] ‘a’
[17:47:08.009] - packages: [1] ‘future’
[17:47:08.010] getGlobalsAndPackages() ... DONE
[17:47:08.010] run() for ‘Future’ ...
[17:47:08.010] - state: ‘created’
[17:47:08.010] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:08.014] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:08.015] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:08.015]   - Field: ‘label’
[17:47:08.015]   - Field: ‘local’
[17:47:08.015]   - Field: ‘owner’
[17:47:08.015]   - Field: ‘envir’
[17:47:08.015]   - Field: ‘workers’
[17:47:08.015]   - Field: ‘packages’
[17:47:08.016]   - Field: ‘gc’
[17:47:08.016]   - Field: ‘job’
[17:47:08.016]   - Field: ‘conditions’
[17:47:08.016]   - Field: ‘expr’
[17:47:08.016]   - Field: ‘uuid’
[17:47:08.016]   - Field: ‘seed’
[17:47:08.016]   - Field: ‘version’
[17:47:08.016]   - Field: ‘result’
[17:47:08.016]   - Field: ‘asynchronous’
[17:47:08.017]   - Field: ‘calls’
[17:47:08.017]   - Field: ‘globals’
[17:47:08.017]   - Field: ‘stdout’
[17:47:08.017]   - Field: ‘earlySignal’
[17:47:08.017]   - Field: ‘lazy’
[17:47:08.017]   - Field: ‘state’
[17:47:08.017] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:08.017] - Launch lazy future ...
[17:47:08.018] Packages needed by the future expression (n = 1): ‘future’
[17:47:08.018] Packages needed by future strategies (n = 0): <none>
[17:47:08.018] {
[17:47:08.018]     {
[17:47:08.018]         {
[17:47:08.018]             ...future.startTime <- base::Sys.time()
[17:47:08.018]             {
[17:47:08.018]                 {
[17:47:08.018]                   {
[17:47:08.018]                     {
[17:47:08.018]                       {
[17:47:08.018]                         base::local({
[17:47:08.018]                           has_future <- base::requireNamespace("future", 
[17:47:08.018]                             quietly = TRUE)
[17:47:08.018]                           if (has_future) {
[17:47:08.018]                             ns <- base::getNamespace("future")
[17:47:08.018]                             version <- ns[[".package"]][["version"]]
[17:47:08.018]                             if (is.null(version)) 
[17:47:08.018]                               version <- utils::packageVersion("future")
[17:47:08.018]                           }
[17:47:08.018]                           else {
[17:47:08.018]                             version <- NULL
[17:47:08.018]                           }
[17:47:08.018]                           if (!has_future || version < "1.8.0") {
[17:47:08.018]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.018]                               "", base::R.version$version.string), 
[17:47:08.018]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:08.018]                                 base::R.version$platform, 8 * 
[17:47:08.018]                                   base::.Machine$sizeof.pointer), 
[17:47:08.018]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.018]                                 "release", "version")], collapse = " "), 
[17:47:08.018]                               hostname = base::Sys.info()[["nodename"]])
[17:47:08.018]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.018]                               info)
[17:47:08.018]                             info <- base::paste(info, collapse = "; ")
[17:47:08.018]                             if (!has_future) {
[17:47:08.018]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.018]                                 info)
[17:47:08.018]                             }
[17:47:08.018]                             else {
[17:47:08.018]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.018]                                 info, version)
[17:47:08.018]                             }
[17:47:08.018]                             base::stop(msg)
[17:47:08.018]                           }
[17:47:08.018]                         })
[17:47:08.018]                       }
[17:47:08.018]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:08.018]                       base::options(mc.cores = 1L)
[17:47:08.018]                     }
[17:47:08.018]                     base::local({
[17:47:08.018]                       for (pkg in "future") {
[17:47:08.018]                         base::loadNamespace(pkg)
[17:47:08.018]                         base::library(pkg, character.only = TRUE)
[17:47:08.018]                       }
[17:47:08.018]                     })
[17:47:08.018]                   }
[17:47:08.018]                   ...future.strategy.old <- future::plan("list")
[17:47:08.018]                   options(future.plan = NULL)
[17:47:08.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.018]                 }
[17:47:08.018]                 ...future.workdir <- getwd()
[17:47:08.018]             }
[17:47:08.018]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.018]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.018]         }
[17:47:08.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.018]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:08.018]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.018]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.018]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.018]             base::names(...future.oldOptions))
[17:47:08.018]     }
[17:47:08.018]     if (FALSE) {
[17:47:08.018]     }
[17:47:08.018]     else {
[17:47:08.018]         if (TRUE) {
[17:47:08.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.018]                 open = "w")
[17:47:08.018]         }
[17:47:08.018]         else {
[17:47:08.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.018]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.018]         }
[17:47:08.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.018]             base::sink(type = "output", split = FALSE)
[17:47:08.018]             base::close(...future.stdout)
[17:47:08.018]         }, add = TRUE)
[17:47:08.018]     }
[17:47:08.018]     ...future.frame <- base::sys.nframe()
[17:47:08.018]     ...future.conditions <- base::list()
[17:47:08.018]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.018]     if (FALSE) {
[17:47:08.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.018]     }
[17:47:08.018]     ...future.result <- base::tryCatch({
[17:47:08.018]         base::withCallingHandlers({
[17:47:08.018]             ...future.value <- base::withVisible(base::local({
[17:47:08.018]                 withCallingHandlers({
[17:47:08.018]                   value(a) + 1
[17:47:08.018]                 }, immediateCondition = function(cond) {
[17:47:08.018]                   save_rds <- function (object, pathname, ...) 
[17:47:08.018]                   {
[17:47:08.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:08.018]                     if (file_test("-f", pathname_tmp)) {
[17:47:08.018]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:08.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.018]                         fi_tmp[["mtime"]])
[17:47:08.018]                     }
[17:47:08.018]                     tryCatch({
[17:47:08.018]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:08.018]                     }, error = function(ex) {
[17:47:08.018]                       msg <- conditionMessage(ex)
[17:47:08.018]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:08.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.018]                         fi_tmp[["mtime"]], msg)
[17:47:08.018]                       ex$message <- msg
[17:47:08.018]                       stop(ex)
[17:47:08.018]                     })
[17:47:08.018]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:08.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:08.018]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:08.018]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.018]                       fi <- file.info(pathname)
[17:47:08.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:08.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:08.018]                         fi[["size"]], fi[["mtime"]])
[17:47:08.018]                       stop(msg)
[17:47:08.018]                     }
[17:47:08.018]                     invisible(pathname)
[17:47:08.018]                   }
[17:47:08.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:08.018]                     rootPath = tempdir()) 
[17:47:08.018]                   {
[17:47:08.018]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:08.018]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:08.018]                       tmpdir = path, fileext = ".rds")
[17:47:08.018]                     save_rds(obj, file)
[17:47:08.018]                   }
[17:47:08.018]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:08.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.018]                   {
[17:47:08.018]                     inherits <- base::inherits
[17:47:08.018]                     invokeRestart <- base::invokeRestart
[17:47:08.018]                     is.null <- base::is.null
[17:47:08.018]                     muffled <- FALSE
[17:47:08.018]                     if (inherits(cond, "message")) {
[17:47:08.018]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:08.018]                       if (muffled) 
[17:47:08.018]                         invokeRestart("muffleMessage")
[17:47:08.018]                     }
[17:47:08.018]                     else if (inherits(cond, "warning")) {
[17:47:08.018]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:08.018]                       if (muffled) 
[17:47:08.018]                         invokeRestart("muffleWarning")
[17:47:08.018]                     }
[17:47:08.018]                     else if (inherits(cond, "condition")) {
[17:47:08.018]                       if (!is.null(pattern)) {
[17:47:08.018]                         computeRestarts <- base::computeRestarts
[17:47:08.018]                         grepl <- base::grepl
[17:47:08.018]                         restarts <- computeRestarts(cond)
[17:47:08.018]                         for (restart in restarts) {
[17:47:08.018]                           name <- restart$name
[17:47:08.018]                           if (is.null(name)) 
[17:47:08.018]                             next
[17:47:08.018]                           if (!grepl(pattern, name)) 
[17:47:08.018]                             next
[17:47:08.018]                           invokeRestart(restart)
[17:47:08.018]                           muffled <- TRUE
[17:47:08.018]                           break
[17:47:08.018]                         }
[17:47:08.018]                       }
[17:47:08.018]                     }
[17:47:08.018]                     invisible(muffled)
[17:47:08.018]                   }
[17:47:08.018]                   muffleCondition(cond)
[17:47:08.018]                 })
[17:47:08.018]             }))
[17:47:08.018]             future::FutureResult(value = ...future.value$value, 
[17:47:08.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.018]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.018]                     ...future.globalenv.names))
[17:47:08.018]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.018]         }, condition = base::local({
[17:47:08.018]             c <- base::c
[17:47:08.018]             inherits <- base::inherits
[17:47:08.018]             invokeRestart <- base::invokeRestart
[17:47:08.018]             length <- base::length
[17:47:08.018]             list <- base::list
[17:47:08.018]             seq.int <- base::seq.int
[17:47:08.018]             signalCondition <- base::signalCondition
[17:47:08.018]             sys.calls <- base::sys.calls
[17:47:08.018]             `[[` <- base::`[[`
[17:47:08.018]             `+` <- base::`+`
[17:47:08.018]             `<<-` <- base::`<<-`
[17:47:08.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.018]                   3L)]
[17:47:08.018]             }
[17:47:08.018]             function(cond) {
[17:47:08.018]                 is_error <- inherits(cond, "error")
[17:47:08.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.018]                   NULL)
[17:47:08.018]                 if (is_error) {
[17:47:08.018]                   sessionInformation <- function() {
[17:47:08.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.018]                       search = base::search(), system = base::Sys.info())
[17:47:08.018]                   }
[17:47:08.018]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.018]                     cond$call), session = sessionInformation(), 
[17:47:08.018]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.018]                   signalCondition(cond)
[17:47:08.018]                 }
[17:47:08.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.018]                 "immediateCondition"))) {
[17:47:08.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.018]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.018]                   if (TRUE && !signal) {
[17:47:08.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.018]                     {
[17:47:08.018]                       inherits <- base::inherits
[17:47:08.018]                       invokeRestart <- base::invokeRestart
[17:47:08.018]                       is.null <- base::is.null
[17:47:08.018]                       muffled <- FALSE
[17:47:08.018]                       if (inherits(cond, "message")) {
[17:47:08.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.018]                         if (muffled) 
[17:47:08.018]                           invokeRestart("muffleMessage")
[17:47:08.018]                       }
[17:47:08.018]                       else if (inherits(cond, "warning")) {
[17:47:08.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.018]                         if (muffled) 
[17:47:08.018]                           invokeRestart("muffleWarning")
[17:47:08.018]                       }
[17:47:08.018]                       else if (inherits(cond, "condition")) {
[17:47:08.018]                         if (!is.null(pattern)) {
[17:47:08.018]                           computeRestarts <- base::computeRestarts
[17:47:08.018]                           grepl <- base::grepl
[17:47:08.018]                           restarts <- computeRestarts(cond)
[17:47:08.018]                           for (restart in restarts) {
[17:47:08.018]                             name <- restart$name
[17:47:08.018]                             if (is.null(name)) 
[17:47:08.018]                               next
[17:47:08.018]                             if (!grepl(pattern, name)) 
[17:47:08.018]                               next
[17:47:08.018]                             invokeRestart(restart)
[17:47:08.018]                             muffled <- TRUE
[17:47:08.018]                             break
[17:47:08.018]                           }
[17:47:08.018]                         }
[17:47:08.018]                       }
[17:47:08.018]                       invisible(muffled)
[17:47:08.018]                     }
[17:47:08.018]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.018]                   }
[17:47:08.018]                 }
[17:47:08.018]                 else {
[17:47:08.018]                   if (TRUE) {
[17:47:08.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.018]                     {
[17:47:08.018]                       inherits <- base::inherits
[17:47:08.018]                       invokeRestart <- base::invokeRestart
[17:47:08.018]                       is.null <- base::is.null
[17:47:08.018]                       muffled <- FALSE
[17:47:08.018]                       if (inherits(cond, "message")) {
[17:47:08.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.018]                         if (muffled) 
[17:47:08.018]                           invokeRestart("muffleMessage")
[17:47:08.018]                       }
[17:47:08.018]                       else if (inherits(cond, "warning")) {
[17:47:08.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.018]                         if (muffled) 
[17:47:08.018]                           invokeRestart("muffleWarning")
[17:47:08.018]                       }
[17:47:08.018]                       else if (inherits(cond, "condition")) {
[17:47:08.018]                         if (!is.null(pattern)) {
[17:47:08.018]                           computeRestarts <- base::computeRestarts
[17:47:08.018]                           grepl <- base::grepl
[17:47:08.018]                           restarts <- computeRestarts(cond)
[17:47:08.018]                           for (restart in restarts) {
[17:47:08.018]                             name <- restart$name
[17:47:08.018]                             if (is.null(name)) 
[17:47:08.018]                               next
[17:47:08.018]                             if (!grepl(pattern, name)) 
[17:47:08.018]                               next
[17:47:08.018]                             invokeRestart(restart)
[17:47:08.018]                             muffled <- TRUE
[17:47:08.018]                             break
[17:47:08.018]                           }
[17:47:08.018]                         }
[17:47:08.018]                       }
[17:47:08.018]                       invisible(muffled)
[17:47:08.018]                     }
[17:47:08.018]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.018]                   }
[17:47:08.018]                 }
[17:47:08.018]             }
[17:47:08.018]         }))
[17:47:08.018]     }, error = function(ex) {
[17:47:08.018]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.018]                 ...future.rng), started = ...future.startTime, 
[17:47:08.018]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.018]             version = "1.8"), class = "FutureResult")
[17:47:08.018]     }, finally = {
[17:47:08.018]         if (!identical(...future.workdir, getwd())) 
[17:47:08.018]             setwd(...future.workdir)
[17:47:08.018]         {
[17:47:08.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.018]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.018]             }
[17:47:08.018]             base::options(...future.oldOptions)
[17:47:08.018]             if (.Platform$OS.type == "windows") {
[17:47:08.018]                 old_names <- names(...future.oldEnvVars)
[17:47:08.018]                 envs <- base::Sys.getenv()
[17:47:08.018]                 names <- names(envs)
[17:47:08.018]                 common <- intersect(names, old_names)
[17:47:08.018]                 added <- setdiff(names, old_names)
[17:47:08.018]                 removed <- setdiff(old_names, names)
[17:47:08.018]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.018]                   envs[common]]
[17:47:08.018]                 NAMES <- toupper(changed)
[17:47:08.018]                 args <- list()
[17:47:08.018]                 for (kk in seq_along(NAMES)) {
[17:47:08.018]                   name <- changed[[kk]]
[17:47:08.018]                   NAME <- NAMES[[kk]]
[17:47:08.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.018]                     next
[17:47:08.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.018]                 }
[17:47:08.018]                 NAMES <- toupper(added)
[17:47:08.018]                 for (kk in seq_along(NAMES)) {
[17:47:08.018]                   name <- added[[kk]]
[17:47:08.018]                   NAME <- NAMES[[kk]]
[17:47:08.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.018]                     next
[17:47:08.018]                   args[[name]] <- ""
[17:47:08.018]                 }
[17:47:08.018]                 NAMES <- toupper(removed)
[17:47:08.018]                 for (kk in seq_along(NAMES)) {
[17:47:08.018]                   name <- removed[[kk]]
[17:47:08.018]                   NAME <- NAMES[[kk]]
[17:47:08.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.018]                     next
[17:47:08.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.018]                 }
[17:47:08.018]                 if (length(args) > 0) 
[17:47:08.018]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.018]             }
[17:47:08.018]             else {
[17:47:08.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.018]             }
[17:47:08.018]             {
[17:47:08.018]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.018]                   0L) {
[17:47:08.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.018]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.018]                   base::options(opts)
[17:47:08.018]                 }
[17:47:08.018]                 {
[17:47:08.018]                   {
[17:47:08.018]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:08.018]                     NULL
[17:47:08.018]                   }
[17:47:08.018]                   options(future.plan = NULL)
[17:47:08.018]                   if (is.na(NA_character_)) 
[17:47:08.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.018]                     .init = FALSE)
[17:47:08.018]                 }
[17:47:08.018]             }
[17:47:08.018]         }
[17:47:08.018]     })
[17:47:08.018]     if (TRUE) {
[17:47:08.018]         base::sink(type = "output", split = FALSE)
[17:47:08.018]         if (TRUE) {
[17:47:08.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.018]         }
[17:47:08.018]         else {
[17:47:08.018]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.018]         }
[17:47:08.018]         base::close(...future.stdout)
[17:47:08.018]         ...future.stdout <- NULL
[17:47:08.018]     }
[17:47:08.018]     ...future.result$conditions <- ...future.conditions
[17:47:08.018]     ...future.result$finished <- base::Sys.time()
[17:47:08.018]     ...future.result
[17:47:08.018] }
[17:47:08.021] assign_globals() ...
[17:47:08.021] List of 1
[17:47:08.021]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558b321cf808> 
[17:47:08.021]  - attr(*, "where")=List of 1
[17:47:08.021]   ..$ a:<environment: R_EmptyEnv> 
[17:47:08.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:08.021]  - attr(*, "resolved")= logi TRUE
[17:47:08.021]  - attr(*, "total_size")= num 1647648
[17:47:08.021]  - attr(*, "already-done")= logi TRUE
[17:47:08.024] - copied ‘a’ to environment
[17:47:08.024] assign_globals() ... done
[17:47:08.024] requestCore(): workers = 2
[17:47:08.026] MulticoreFuture started
[17:47:08.027] - Launch lazy future ... done
[17:47:08.027] run() for ‘MulticoreFuture’ ... done
[17:47:08.027] result() for MulticoreFuture ...
[17:47:08.028] plan(): Setting new future strategy stack:
[17:47:08.028] List of future strategies:
[17:47:08.028] 1. sequential:
[17:47:08.028]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:08.028]    - tweaked: FALSE
[17:47:08.028]    - call: NULL
[17:47:08.029] plan(): nbrOfWorkers() = 1
[17:47:08.032] plan(): Setting new future strategy stack:
[17:47:08.033] List of future strategies:
[17:47:08.033] 1. multicore:
[17:47:08.033]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:08.033]    - tweaked: FALSE
[17:47:08.033]    - call: plan(strategy)
[17:47:08.038] plan(): nbrOfWorkers() = 2
[17:47:08.039] result() for MulticoreFuture ...
[17:47:08.039] result() for MulticoreFuture ... done
[17:47:08.039] signalConditions() ...
[17:47:08.039]  - include = ‘immediateCondition’
[17:47:08.039]  - exclude = 
[17:47:08.039]  - resignal = FALSE
[17:47:08.039]  - Number of conditions: 4
[17:47:08.040] signalConditions() ... done
[17:47:08.040] result() for MulticoreFuture ... done
[17:47:08.040] result() for MulticoreFuture ...
[17:47:08.040] result() for MulticoreFuture ... done
[17:47:08.040] signalConditions() ...
[17:47:08.040]  - include = ‘immediateCondition’
[17:47:08.040]  - exclude = 
[17:47:08.040]  - resignal = FALSE
[17:47:08.041]  - Number of conditions: 4
[17:47:08.041] signalConditions() ... done
[17:47:08.041] Future state: ‘finished’
[17:47:08.041] result() for MulticoreFuture ...
[17:47:08.041] result() for MulticoreFuture ... done
[17:47:08.041] signalConditions() ...
[17:47:08.041]  - include = ‘condition’
[17:47:08.041]  - exclude = ‘immediateCondition’
[17:47:08.042]  - resignal = TRUE
[17:47:08.042]  - Number of conditions: 4
[17:47:08.042]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.030] result() for MulticoreFuture ...
[17:47:08.042]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.031] result() for MulticoreFuture ... done
[17:47:08.042]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.031] result() for MulticoreFuture ...
[17:47:08.042]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.031] result() for MulticoreFuture ... done
[17:47:08.042] signalConditions() ... done
value(b) = 2
[17:47:08.043] result() for MulticoreFuture ...
[17:47:08.043] result() for MulticoreFuture ... done
[17:47:08.043] result() for MulticoreFuture ...
[17:47:08.043] result() for MulticoreFuture ... done
[17:47:08.043] signalConditions() ...
[17:47:08.043]  - include = ‘immediateCondition’
[17:47:08.043]  - exclude = 
[17:47:08.043]  - resignal = FALSE
[17:47:08.044]  - Number of conditions: 4
[17:47:08.044] signalConditions() ... done
[17:47:08.044] Future state: ‘finished’
[17:47:08.044] result() for MulticoreFuture ...
[17:47:08.044] result() for MulticoreFuture ... done
[17:47:08.044] signalConditions() ...
[17:47:08.044]  - include = ‘condition’
[17:47:08.044]  - exclude = ‘immediateCondition’
[17:47:08.045]  - resignal = TRUE
[17:47:08.045]  - Number of conditions: 4
[17:47:08.045]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.030] result() for MulticoreFuture ...
[17:47:08.045]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.031] result() for MulticoreFuture ... done
[17:47:08.045]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.031] result() for MulticoreFuture ...
[17:47:08.045]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.031] result() for MulticoreFuture ... done
[17:47:08.045] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.046] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.046] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:08.047] 
[17:47:08.047] Searching for globals ... DONE
[17:47:08.047] - globals: [0] <none>
[17:47:08.047] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.047] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.048] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:08.049] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:08.049] Searching for globals ... DONE
[17:47:08.049] Resolving globals: TRUE
[17:47:08.049] Resolving any globals that are futures ...
[17:47:08.049] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:08.052] Resolving any globals that are futures ... DONE
[17:47:08.053] Resolving futures part of globals (recursively) ...
[17:47:08.053] resolve() on list ...
[17:47:08.053]  recursive: 99
[17:47:08.053]  length: 1
[17:47:08.053]  elements: ‘a’
[17:47:08.054] run() for ‘Future’ ...
[17:47:08.054] - state: ‘created’
[17:47:08.054] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:08.058] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:08.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:08.058]   - Field: ‘label’
[17:47:08.058]   - Field: ‘local’
[17:47:08.059]   - Field: ‘owner’
[17:47:08.059]   - Field: ‘envir’
[17:47:08.059]   - Field: ‘workers’
[17:47:08.059]   - Field: ‘packages’
[17:47:08.059]   - Field: ‘gc’
[17:47:08.059]   - Field: ‘job’
[17:47:08.059]   - Field: ‘conditions’
[17:47:08.059]   - Field: ‘expr’
[17:47:08.060]   - Field: ‘uuid’
[17:47:08.060]   - Field: ‘seed’
[17:47:08.060]   - Field: ‘version’
[17:47:08.060]   - Field: ‘result’
[17:47:08.060]   - Field: ‘asynchronous’
[17:47:08.060]   - Field: ‘calls’
[17:47:08.060]   - Field: ‘globals’
[17:47:08.060]   - Field: ‘stdout’
[17:47:08.061]   - Field: ‘earlySignal’
[17:47:08.061]   - Field: ‘lazy’
[17:47:08.061]   - Field: ‘state’
[17:47:08.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:08.061] - Launch lazy future ...
[17:47:08.062] Packages needed by the future expression (n = 0): <none>
[17:47:08.062] Packages needed by future strategies (n = 0): <none>
[17:47:08.062] {
[17:47:08.062]     {
[17:47:08.062]         {
[17:47:08.062]             ...future.startTime <- base::Sys.time()
[17:47:08.062]             {
[17:47:08.062]                 {
[17:47:08.062]                   {
[17:47:08.062]                     {
[17:47:08.062]                       base::local({
[17:47:08.062]                         has_future <- base::requireNamespace("future", 
[17:47:08.062]                           quietly = TRUE)
[17:47:08.062]                         if (has_future) {
[17:47:08.062]                           ns <- base::getNamespace("future")
[17:47:08.062]                           version <- ns[[".package"]][["version"]]
[17:47:08.062]                           if (is.null(version)) 
[17:47:08.062]                             version <- utils::packageVersion("future")
[17:47:08.062]                         }
[17:47:08.062]                         else {
[17:47:08.062]                           version <- NULL
[17:47:08.062]                         }
[17:47:08.062]                         if (!has_future || version < "1.8.0") {
[17:47:08.062]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.062]                             "", base::R.version$version.string), 
[17:47:08.062]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:08.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:08.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.062]                               "release", "version")], collapse = " "), 
[17:47:08.062]                             hostname = base::Sys.info()[["nodename"]])
[17:47:08.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.062]                             info)
[17:47:08.062]                           info <- base::paste(info, collapse = "; ")
[17:47:08.062]                           if (!has_future) {
[17:47:08.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.062]                               info)
[17:47:08.062]                           }
[17:47:08.062]                           else {
[17:47:08.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.062]                               info, version)
[17:47:08.062]                           }
[17:47:08.062]                           base::stop(msg)
[17:47:08.062]                         }
[17:47:08.062]                       })
[17:47:08.062]                     }
[17:47:08.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:08.062]                     base::options(mc.cores = 1L)
[17:47:08.062]                   }
[17:47:08.062]                   ...future.strategy.old <- future::plan("list")
[17:47:08.062]                   options(future.plan = NULL)
[17:47:08.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.062]                 }
[17:47:08.062]                 ...future.workdir <- getwd()
[17:47:08.062]             }
[17:47:08.062]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.062]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.062]         }
[17:47:08.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.062]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:08.062]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.062]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.062]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.062]             base::names(...future.oldOptions))
[17:47:08.062]     }
[17:47:08.062]     if (FALSE) {
[17:47:08.062]     }
[17:47:08.062]     else {
[17:47:08.062]         if (TRUE) {
[17:47:08.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.062]                 open = "w")
[17:47:08.062]         }
[17:47:08.062]         else {
[17:47:08.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.062]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.062]         }
[17:47:08.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.062]             base::sink(type = "output", split = FALSE)
[17:47:08.062]             base::close(...future.stdout)
[17:47:08.062]         }, add = TRUE)
[17:47:08.062]     }
[17:47:08.062]     ...future.frame <- base::sys.nframe()
[17:47:08.062]     ...future.conditions <- base::list()
[17:47:08.062]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.062]     if (FALSE) {
[17:47:08.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.062]     }
[17:47:08.062]     ...future.result <- base::tryCatch({
[17:47:08.062]         base::withCallingHandlers({
[17:47:08.062]             ...future.value <- base::withVisible(base::local({
[17:47:08.062]                 withCallingHandlers({
[17:47:08.062]                   1
[17:47:08.062]                 }, immediateCondition = function(cond) {
[17:47:08.062]                   save_rds <- function (object, pathname, ...) 
[17:47:08.062]                   {
[17:47:08.062]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:08.062]                     if (file_test("-f", pathname_tmp)) {
[17:47:08.062]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.062]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:08.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.062]                         fi_tmp[["mtime"]])
[17:47:08.062]                     }
[17:47:08.062]                     tryCatch({
[17:47:08.062]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:08.062]                     }, error = function(ex) {
[17:47:08.062]                       msg <- conditionMessage(ex)
[17:47:08.062]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.062]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:08.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.062]                         fi_tmp[["mtime"]], msg)
[17:47:08.062]                       ex$message <- msg
[17:47:08.062]                       stop(ex)
[17:47:08.062]                     })
[17:47:08.062]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:08.062]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:08.062]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:08.062]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.062]                       fi <- file.info(pathname)
[17:47:08.062]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:08.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.062]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:08.062]                         fi[["size"]], fi[["mtime"]])
[17:47:08.062]                       stop(msg)
[17:47:08.062]                     }
[17:47:08.062]                     invisible(pathname)
[17:47:08.062]                   }
[17:47:08.062]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:08.062]                     rootPath = tempdir()) 
[17:47:08.062]                   {
[17:47:08.062]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:08.062]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:08.062]                       tmpdir = path, fileext = ".rds")
[17:47:08.062]                     save_rds(obj, file)
[17:47:08.062]                   }
[17:47:08.062]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:08.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.062]                   {
[17:47:08.062]                     inherits <- base::inherits
[17:47:08.062]                     invokeRestart <- base::invokeRestart
[17:47:08.062]                     is.null <- base::is.null
[17:47:08.062]                     muffled <- FALSE
[17:47:08.062]                     if (inherits(cond, "message")) {
[17:47:08.062]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:08.062]                       if (muffled) 
[17:47:08.062]                         invokeRestart("muffleMessage")
[17:47:08.062]                     }
[17:47:08.062]                     else if (inherits(cond, "warning")) {
[17:47:08.062]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:08.062]                       if (muffled) 
[17:47:08.062]                         invokeRestart("muffleWarning")
[17:47:08.062]                     }
[17:47:08.062]                     else if (inherits(cond, "condition")) {
[17:47:08.062]                       if (!is.null(pattern)) {
[17:47:08.062]                         computeRestarts <- base::computeRestarts
[17:47:08.062]                         grepl <- base::grepl
[17:47:08.062]                         restarts <- computeRestarts(cond)
[17:47:08.062]                         for (restart in restarts) {
[17:47:08.062]                           name <- restart$name
[17:47:08.062]                           if (is.null(name)) 
[17:47:08.062]                             next
[17:47:08.062]                           if (!grepl(pattern, name)) 
[17:47:08.062]                             next
[17:47:08.062]                           invokeRestart(restart)
[17:47:08.062]                           muffled <- TRUE
[17:47:08.062]                           break
[17:47:08.062]                         }
[17:47:08.062]                       }
[17:47:08.062]                     }
[17:47:08.062]                     invisible(muffled)
[17:47:08.062]                   }
[17:47:08.062]                   muffleCondition(cond)
[17:47:08.062]                 })
[17:47:08.062]             }))
[17:47:08.062]             future::FutureResult(value = ...future.value$value, 
[17:47:08.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.062]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.062]                     ...future.globalenv.names))
[17:47:08.062]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.062]         }, condition = base::local({
[17:47:08.062]             c <- base::c
[17:47:08.062]             inherits <- base::inherits
[17:47:08.062]             invokeRestart <- base::invokeRestart
[17:47:08.062]             length <- base::length
[17:47:08.062]             list <- base::list
[17:47:08.062]             seq.int <- base::seq.int
[17:47:08.062]             signalCondition <- base::signalCondition
[17:47:08.062]             sys.calls <- base::sys.calls
[17:47:08.062]             `[[` <- base::`[[`
[17:47:08.062]             `+` <- base::`+`
[17:47:08.062]             `<<-` <- base::`<<-`
[17:47:08.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.062]                   3L)]
[17:47:08.062]             }
[17:47:08.062]             function(cond) {
[17:47:08.062]                 is_error <- inherits(cond, "error")
[17:47:08.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.062]                   NULL)
[17:47:08.062]                 if (is_error) {
[17:47:08.062]                   sessionInformation <- function() {
[17:47:08.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.062]                       search = base::search(), system = base::Sys.info())
[17:47:08.062]                   }
[17:47:08.062]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.062]                     cond$call), session = sessionInformation(), 
[17:47:08.062]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.062]                   signalCondition(cond)
[17:47:08.062]                 }
[17:47:08.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.062]                 "immediateCondition"))) {
[17:47:08.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.062]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.062]                   if (TRUE && !signal) {
[17:47:08.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.062]                     {
[17:47:08.062]                       inherits <- base::inherits
[17:47:08.062]                       invokeRestart <- base::invokeRestart
[17:47:08.062]                       is.null <- base::is.null
[17:47:08.062]                       muffled <- FALSE
[17:47:08.062]                       if (inherits(cond, "message")) {
[17:47:08.062]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.062]                         if (muffled) 
[17:47:08.062]                           invokeRestart("muffleMessage")
[17:47:08.062]                       }
[17:47:08.062]                       else if (inherits(cond, "warning")) {
[17:47:08.062]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.062]                         if (muffled) 
[17:47:08.062]                           invokeRestart("muffleWarning")
[17:47:08.062]                       }
[17:47:08.062]                       else if (inherits(cond, "condition")) {
[17:47:08.062]                         if (!is.null(pattern)) {
[17:47:08.062]                           computeRestarts <- base::computeRestarts
[17:47:08.062]                           grepl <- base::grepl
[17:47:08.062]                           restarts <- computeRestarts(cond)
[17:47:08.062]                           for (restart in restarts) {
[17:47:08.062]                             name <- restart$name
[17:47:08.062]                             if (is.null(name)) 
[17:47:08.062]                               next
[17:47:08.062]                             if (!grepl(pattern, name)) 
[17:47:08.062]                               next
[17:47:08.062]                             invokeRestart(restart)
[17:47:08.062]                             muffled <- TRUE
[17:47:08.062]                             break
[17:47:08.062]                           }
[17:47:08.062]                         }
[17:47:08.062]                       }
[17:47:08.062]                       invisible(muffled)
[17:47:08.062]                     }
[17:47:08.062]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.062]                   }
[17:47:08.062]                 }
[17:47:08.062]                 else {
[17:47:08.062]                   if (TRUE) {
[17:47:08.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.062]                     {
[17:47:08.062]                       inherits <- base::inherits
[17:47:08.062]                       invokeRestart <- base::invokeRestart
[17:47:08.062]                       is.null <- base::is.null
[17:47:08.062]                       muffled <- FALSE
[17:47:08.062]                       if (inherits(cond, "message")) {
[17:47:08.062]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.062]                         if (muffled) 
[17:47:08.062]                           invokeRestart("muffleMessage")
[17:47:08.062]                       }
[17:47:08.062]                       else if (inherits(cond, "warning")) {
[17:47:08.062]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.062]                         if (muffled) 
[17:47:08.062]                           invokeRestart("muffleWarning")
[17:47:08.062]                       }
[17:47:08.062]                       else if (inherits(cond, "condition")) {
[17:47:08.062]                         if (!is.null(pattern)) {
[17:47:08.062]                           computeRestarts <- base::computeRestarts
[17:47:08.062]                           grepl <- base::grepl
[17:47:08.062]                           restarts <- computeRestarts(cond)
[17:47:08.062]                           for (restart in restarts) {
[17:47:08.062]                             name <- restart$name
[17:47:08.062]                             if (is.null(name)) 
[17:47:08.062]                               next
[17:47:08.062]                             if (!grepl(pattern, name)) 
[17:47:08.062]                               next
[17:47:08.062]                             invokeRestart(restart)
[17:47:08.062]                             muffled <- TRUE
[17:47:08.062]                             break
[17:47:08.062]                           }
[17:47:08.062]                         }
[17:47:08.062]                       }
[17:47:08.062]                       invisible(muffled)
[17:47:08.062]                     }
[17:47:08.062]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.062]                   }
[17:47:08.062]                 }
[17:47:08.062]             }
[17:47:08.062]         }))
[17:47:08.062]     }, error = function(ex) {
[17:47:08.062]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.062]                 ...future.rng), started = ...future.startTime, 
[17:47:08.062]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.062]             version = "1.8"), class = "FutureResult")
[17:47:08.062]     }, finally = {
[17:47:08.062]         if (!identical(...future.workdir, getwd())) 
[17:47:08.062]             setwd(...future.workdir)
[17:47:08.062]         {
[17:47:08.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.062]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.062]             }
[17:47:08.062]             base::options(...future.oldOptions)
[17:47:08.062]             if (.Platform$OS.type == "windows") {
[17:47:08.062]                 old_names <- names(...future.oldEnvVars)
[17:47:08.062]                 envs <- base::Sys.getenv()
[17:47:08.062]                 names <- names(envs)
[17:47:08.062]                 common <- intersect(names, old_names)
[17:47:08.062]                 added <- setdiff(names, old_names)
[17:47:08.062]                 removed <- setdiff(old_names, names)
[17:47:08.062]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.062]                   envs[common]]
[17:47:08.062]                 NAMES <- toupper(changed)
[17:47:08.062]                 args <- list()
[17:47:08.062]                 for (kk in seq_along(NAMES)) {
[17:47:08.062]                   name <- changed[[kk]]
[17:47:08.062]                   NAME <- NAMES[[kk]]
[17:47:08.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.062]                     next
[17:47:08.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.062]                 }
[17:47:08.062]                 NAMES <- toupper(added)
[17:47:08.062]                 for (kk in seq_along(NAMES)) {
[17:47:08.062]                   name <- added[[kk]]
[17:47:08.062]                   NAME <- NAMES[[kk]]
[17:47:08.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.062]                     next
[17:47:08.062]                   args[[name]] <- ""
[17:47:08.062]                 }
[17:47:08.062]                 NAMES <- toupper(removed)
[17:47:08.062]                 for (kk in seq_along(NAMES)) {
[17:47:08.062]                   name <- removed[[kk]]
[17:47:08.062]                   NAME <- NAMES[[kk]]
[17:47:08.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.062]                     next
[17:47:08.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.062]                 }
[17:47:08.062]                 if (length(args) > 0) 
[17:47:08.062]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.062]             }
[17:47:08.062]             else {
[17:47:08.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.062]             }
[17:47:08.062]             {
[17:47:08.062]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.062]                   0L) {
[17:47:08.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.062]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.062]                   base::options(opts)
[17:47:08.062]                 }
[17:47:08.062]                 {
[17:47:08.062]                   {
[17:47:08.062]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:08.062]                     NULL
[17:47:08.062]                   }
[17:47:08.062]                   options(future.plan = NULL)
[17:47:08.062]                   if (is.na(NA_character_)) 
[17:47:08.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.062]                     .init = FALSE)
[17:47:08.062]                 }
[17:47:08.062]             }
[17:47:08.062]         }
[17:47:08.062]     })
[17:47:08.062]     if (TRUE) {
[17:47:08.062]         base::sink(type = "output", split = FALSE)
[17:47:08.062]         if (TRUE) {
[17:47:08.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.062]         }
[17:47:08.062]         else {
[17:47:08.062]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.062]         }
[17:47:08.062]         base::close(...future.stdout)
[17:47:08.062]         ...future.stdout <- NULL
[17:47:08.062]     }
[17:47:08.062]     ...future.result$conditions <- ...future.conditions
[17:47:08.062]     ...future.result$finished <- base::Sys.time()
[17:47:08.062]     ...future.result
[17:47:08.062] }
[17:47:08.065] requestCore(): workers = 2
[17:47:08.067] MulticoreFuture started
[17:47:08.068] - Launch lazy future ... done
[17:47:08.068] run() for ‘MulticoreFuture’ ... done
[17:47:08.068] plan(): Setting new future strategy stack:
[17:47:08.069] List of future strategies:
[17:47:08.069] 1. sequential:
[17:47:08.069]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:08.069]    - tweaked: FALSE
[17:47:08.069]    - call: NULL
[17:47:08.070] plan(): nbrOfWorkers() = 1
[17:47:08.073] plan(): Setting new future strategy stack:
[17:47:08.073] List of future strategies:
[17:47:08.073] 1. multicore:
[17:47:08.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:08.073]    - tweaked: FALSE
[17:47:08.073]    - call: plan(strategy)
[17:47:08.079] plan(): nbrOfWorkers() = 2
[17:47:08.089] Future #1
[17:47:08.089] result() for MulticoreFuture ...
[17:47:08.091] result() for MulticoreFuture ...
[17:47:08.091] result() for MulticoreFuture ... done
[17:47:08.091] result() for MulticoreFuture ... done
[17:47:08.091] result() for MulticoreFuture ...
[17:47:08.091] result() for MulticoreFuture ... done
[17:47:08.092] A MulticoreFuture was resolved
[17:47:08.092]  length: 0 (resolved future 1)
[17:47:08.092] resolve() on list ... DONE
[17:47:08.092] - globals: [1] ‘a’
[17:47:08.092] Resolving futures part of globals (recursively) ... DONE
[17:47:08.095] The total size of the 1 globals is 1.57 MiB (1647648 bytes)
[17:47:08.096] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:47:08.096] - globals: [1] ‘a’
[17:47:08.096] - packages: [1] ‘future’
[17:47:08.096] getGlobalsAndPackages() ... DONE
[17:47:08.096] run() for ‘Future’ ...
[17:47:08.097] - state: ‘created’
[17:47:08.097] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:08.101] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:08.101] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:08.101]   - Field: ‘label’
[17:47:08.101]   - Field: ‘local’
[17:47:08.101]   - Field: ‘owner’
[17:47:08.101]   - Field: ‘envir’
[17:47:08.102]   - Field: ‘workers’
[17:47:08.102]   - Field: ‘packages’
[17:47:08.102]   - Field: ‘gc’
[17:47:08.102]   - Field: ‘job’
[17:47:08.102]   - Field: ‘conditions’
[17:47:08.102]   - Field: ‘expr’
[17:47:08.102]   - Field: ‘uuid’
[17:47:08.102]   - Field: ‘seed’
[17:47:08.102]   - Field: ‘version’
[17:47:08.103]   - Field: ‘result’
[17:47:08.103]   - Field: ‘asynchronous’
[17:47:08.103]   - Field: ‘calls’
[17:47:08.103]   - Field: ‘globals’
[17:47:08.103]   - Field: ‘stdout’
[17:47:08.103]   - Field: ‘earlySignal’
[17:47:08.103]   - Field: ‘lazy’
[17:47:08.103]   - Field: ‘state’
[17:47:08.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:08.104] - Launch lazy future ...
[17:47:08.104] Packages needed by the future expression (n = 1): ‘future’
[17:47:08.104] Packages needed by future strategies (n = 0): <none>
[17:47:08.105] {
[17:47:08.105]     {
[17:47:08.105]         {
[17:47:08.105]             ...future.startTime <- base::Sys.time()
[17:47:08.105]             {
[17:47:08.105]                 {
[17:47:08.105]                   {
[17:47:08.105]                     {
[17:47:08.105]                       {
[17:47:08.105]                         base::local({
[17:47:08.105]                           has_future <- base::requireNamespace("future", 
[17:47:08.105]                             quietly = TRUE)
[17:47:08.105]                           if (has_future) {
[17:47:08.105]                             ns <- base::getNamespace("future")
[17:47:08.105]                             version <- ns[[".package"]][["version"]]
[17:47:08.105]                             if (is.null(version)) 
[17:47:08.105]                               version <- utils::packageVersion("future")
[17:47:08.105]                           }
[17:47:08.105]                           else {
[17:47:08.105]                             version <- NULL
[17:47:08.105]                           }
[17:47:08.105]                           if (!has_future || version < "1.8.0") {
[17:47:08.105]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.105]                               "", base::R.version$version.string), 
[17:47:08.105]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:08.105]                                 base::R.version$platform, 8 * 
[17:47:08.105]                                   base::.Machine$sizeof.pointer), 
[17:47:08.105]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.105]                                 "release", "version")], collapse = " "), 
[17:47:08.105]                               hostname = base::Sys.info()[["nodename"]])
[17:47:08.105]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.105]                               info)
[17:47:08.105]                             info <- base::paste(info, collapse = "; ")
[17:47:08.105]                             if (!has_future) {
[17:47:08.105]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.105]                                 info)
[17:47:08.105]                             }
[17:47:08.105]                             else {
[17:47:08.105]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.105]                                 info, version)
[17:47:08.105]                             }
[17:47:08.105]                             base::stop(msg)
[17:47:08.105]                           }
[17:47:08.105]                         })
[17:47:08.105]                       }
[17:47:08.105]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:08.105]                       base::options(mc.cores = 1L)
[17:47:08.105]                     }
[17:47:08.105]                     base::local({
[17:47:08.105]                       for (pkg in "future") {
[17:47:08.105]                         base::loadNamespace(pkg)
[17:47:08.105]                         base::library(pkg, character.only = TRUE)
[17:47:08.105]                       }
[17:47:08.105]                     })
[17:47:08.105]                   }
[17:47:08.105]                   ...future.strategy.old <- future::plan("list")
[17:47:08.105]                   options(future.plan = NULL)
[17:47:08.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.105]                 }
[17:47:08.105]                 ...future.workdir <- getwd()
[17:47:08.105]             }
[17:47:08.105]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.105]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.105]         }
[17:47:08.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.105]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:08.105]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.105]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.105]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.105]             base::names(...future.oldOptions))
[17:47:08.105]     }
[17:47:08.105]     if (FALSE) {
[17:47:08.105]     }
[17:47:08.105]     else {
[17:47:08.105]         if (TRUE) {
[17:47:08.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.105]                 open = "w")
[17:47:08.105]         }
[17:47:08.105]         else {
[17:47:08.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.105]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.105]         }
[17:47:08.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.105]             base::sink(type = "output", split = FALSE)
[17:47:08.105]             base::close(...future.stdout)
[17:47:08.105]         }, add = TRUE)
[17:47:08.105]     }
[17:47:08.105]     ...future.frame <- base::sys.nframe()
[17:47:08.105]     ...future.conditions <- base::list()
[17:47:08.105]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.105]     if (FALSE) {
[17:47:08.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.105]     }
[17:47:08.105]     ...future.result <- base::tryCatch({
[17:47:08.105]         base::withCallingHandlers({
[17:47:08.105]             ...future.value <- base::withVisible(base::local({
[17:47:08.105]                 withCallingHandlers({
[17:47:08.105]                   value(a) + 1
[17:47:08.105]                 }, immediateCondition = function(cond) {
[17:47:08.105]                   save_rds <- function (object, pathname, ...) 
[17:47:08.105]                   {
[17:47:08.105]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:08.105]                     if (file_test("-f", pathname_tmp)) {
[17:47:08.105]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.105]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:08.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.105]                         fi_tmp[["mtime"]])
[17:47:08.105]                     }
[17:47:08.105]                     tryCatch({
[17:47:08.105]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:08.105]                     }, error = function(ex) {
[17:47:08.105]                       msg <- conditionMessage(ex)
[17:47:08.105]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.105]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:08.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.105]                         fi_tmp[["mtime"]], msg)
[17:47:08.105]                       ex$message <- msg
[17:47:08.105]                       stop(ex)
[17:47:08.105]                     })
[17:47:08.105]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:08.105]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:08.105]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:08.105]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.105]                       fi <- file.info(pathname)
[17:47:08.105]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:08.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.105]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:08.105]                         fi[["size"]], fi[["mtime"]])
[17:47:08.105]                       stop(msg)
[17:47:08.105]                     }
[17:47:08.105]                     invisible(pathname)
[17:47:08.105]                   }
[17:47:08.105]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:08.105]                     rootPath = tempdir()) 
[17:47:08.105]                   {
[17:47:08.105]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:08.105]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:08.105]                       tmpdir = path, fileext = ".rds")
[17:47:08.105]                     save_rds(obj, file)
[17:47:08.105]                   }
[17:47:08.105]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:08.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.105]                   {
[17:47:08.105]                     inherits <- base::inherits
[17:47:08.105]                     invokeRestart <- base::invokeRestart
[17:47:08.105]                     is.null <- base::is.null
[17:47:08.105]                     muffled <- FALSE
[17:47:08.105]                     if (inherits(cond, "message")) {
[17:47:08.105]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:08.105]                       if (muffled) 
[17:47:08.105]                         invokeRestart("muffleMessage")
[17:47:08.105]                     }
[17:47:08.105]                     else if (inherits(cond, "warning")) {
[17:47:08.105]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:08.105]                       if (muffled) 
[17:47:08.105]                         invokeRestart("muffleWarning")
[17:47:08.105]                     }
[17:47:08.105]                     else if (inherits(cond, "condition")) {
[17:47:08.105]                       if (!is.null(pattern)) {
[17:47:08.105]                         computeRestarts <- base::computeRestarts
[17:47:08.105]                         grepl <- base::grepl
[17:47:08.105]                         restarts <- computeRestarts(cond)
[17:47:08.105]                         for (restart in restarts) {
[17:47:08.105]                           name <- restart$name
[17:47:08.105]                           if (is.null(name)) 
[17:47:08.105]                             next
[17:47:08.105]                           if (!grepl(pattern, name)) 
[17:47:08.105]                             next
[17:47:08.105]                           invokeRestart(restart)
[17:47:08.105]                           muffled <- TRUE
[17:47:08.105]                           break
[17:47:08.105]                         }
[17:47:08.105]                       }
[17:47:08.105]                     }
[17:47:08.105]                     invisible(muffled)
[17:47:08.105]                   }
[17:47:08.105]                   muffleCondition(cond)
[17:47:08.105]                 })
[17:47:08.105]             }))
[17:47:08.105]             future::FutureResult(value = ...future.value$value, 
[17:47:08.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.105]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.105]                     ...future.globalenv.names))
[17:47:08.105]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.105]         }, condition = base::local({
[17:47:08.105]             c <- base::c
[17:47:08.105]             inherits <- base::inherits
[17:47:08.105]             invokeRestart <- base::invokeRestart
[17:47:08.105]             length <- base::length
[17:47:08.105]             list <- base::list
[17:47:08.105]             seq.int <- base::seq.int
[17:47:08.105]             signalCondition <- base::signalCondition
[17:47:08.105]             sys.calls <- base::sys.calls
[17:47:08.105]             `[[` <- base::`[[`
[17:47:08.105]             `+` <- base::`+`
[17:47:08.105]             `<<-` <- base::`<<-`
[17:47:08.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.105]                   3L)]
[17:47:08.105]             }
[17:47:08.105]             function(cond) {
[17:47:08.105]                 is_error <- inherits(cond, "error")
[17:47:08.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.105]                   NULL)
[17:47:08.105]                 if (is_error) {
[17:47:08.105]                   sessionInformation <- function() {
[17:47:08.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.105]                       search = base::search(), system = base::Sys.info())
[17:47:08.105]                   }
[17:47:08.105]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.105]                     cond$call), session = sessionInformation(), 
[17:47:08.105]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.105]                   signalCondition(cond)
[17:47:08.105]                 }
[17:47:08.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.105]                 "immediateCondition"))) {
[17:47:08.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.105]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.105]                   if (TRUE && !signal) {
[17:47:08.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.105]                     {
[17:47:08.105]                       inherits <- base::inherits
[17:47:08.105]                       invokeRestart <- base::invokeRestart
[17:47:08.105]                       is.null <- base::is.null
[17:47:08.105]                       muffled <- FALSE
[17:47:08.105]                       if (inherits(cond, "message")) {
[17:47:08.105]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.105]                         if (muffled) 
[17:47:08.105]                           invokeRestart("muffleMessage")
[17:47:08.105]                       }
[17:47:08.105]                       else if (inherits(cond, "warning")) {
[17:47:08.105]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.105]                         if (muffled) 
[17:47:08.105]                           invokeRestart("muffleWarning")
[17:47:08.105]                       }
[17:47:08.105]                       else if (inherits(cond, "condition")) {
[17:47:08.105]                         if (!is.null(pattern)) {
[17:47:08.105]                           computeRestarts <- base::computeRestarts
[17:47:08.105]                           grepl <- base::grepl
[17:47:08.105]                           restarts <- computeRestarts(cond)
[17:47:08.105]                           for (restart in restarts) {
[17:47:08.105]                             name <- restart$name
[17:47:08.105]                             if (is.null(name)) 
[17:47:08.105]                               next
[17:47:08.105]                             if (!grepl(pattern, name)) 
[17:47:08.105]                               next
[17:47:08.105]                             invokeRestart(restart)
[17:47:08.105]                             muffled <- TRUE
[17:47:08.105]                             break
[17:47:08.105]                           }
[17:47:08.105]                         }
[17:47:08.105]                       }
[17:47:08.105]                       invisible(muffled)
[17:47:08.105]                     }
[17:47:08.105]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.105]                   }
[17:47:08.105]                 }
[17:47:08.105]                 else {
[17:47:08.105]                   if (TRUE) {
[17:47:08.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.105]                     {
[17:47:08.105]                       inherits <- base::inherits
[17:47:08.105]                       invokeRestart <- base::invokeRestart
[17:47:08.105]                       is.null <- base::is.null
[17:47:08.105]                       muffled <- FALSE
[17:47:08.105]                       if (inherits(cond, "message")) {
[17:47:08.105]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.105]                         if (muffled) 
[17:47:08.105]                           invokeRestart("muffleMessage")
[17:47:08.105]                       }
[17:47:08.105]                       else if (inherits(cond, "warning")) {
[17:47:08.105]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.105]                         if (muffled) 
[17:47:08.105]                           invokeRestart("muffleWarning")
[17:47:08.105]                       }
[17:47:08.105]                       else if (inherits(cond, "condition")) {
[17:47:08.105]                         if (!is.null(pattern)) {
[17:47:08.105]                           computeRestarts <- base::computeRestarts
[17:47:08.105]                           grepl <- base::grepl
[17:47:08.105]                           restarts <- computeRestarts(cond)
[17:47:08.105]                           for (restart in restarts) {
[17:47:08.105]                             name <- restart$name
[17:47:08.105]                             if (is.null(name)) 
[17:47:08.105]                               next
[17:47:08.105]                             if (!grepl(pattern, name)) 
[17:47:08.105]                               next
[17:47:08.105]                             invokeRestart(restart)
[17:47:08.105]                             muffled <- TRUE
[17:47:08.105]                             break
[17:47:08.105]                           }
[17:47:08.105]                         }
[17:47:08.105]                       }
[17:47:08.105]                       invisible(muffled)
[17:47:08.105]                     }
[17:47:08.105]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.105]                   }
[17:47:08.105]                 }
[17:47:08.105]             }
[17:47:08.105]         }))
[17:47:08.105]     }, error = function(ex) {
[17:47:08.105]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.105]                 ...future.rng), started = ...future.startTime, 
[17:47:08.105]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.105]             version = "1.8"), class = "FutureResult")
[17:47:08.105]     }, finally = {
[17:47:08.105]         if (!identical(...future.workdir, getwd())) 
[17:47:08.105]             setwd(...future.workdir)
[17:47:08.105]         {
[17:47:08.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.105]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.105]             }
[17:47:08.105]             base::options(...future.oldOptions)
[17:47:08.105]             if (.Platform$OS.type == "windows") {
[17:47:08.105]                 old_names <- names(...future.oldEnvVars)
[17:47:08.105]                 envs <- base::Sys.getenv()
[17:47:08.105]                 names <- names(envs)
[17:47:08.105]                 common <- intersect(names, old_names)
[17:47:08.105]                 added <- setdiff(names, old_names)
[17:47:08.105]                 removed <- setdiff(old_names, names)
[17:47:08.105]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.105]                   envs[common]]
[17:47:08.105]                 NAMES <- toupper(changed)
[17:47:08.105]                 args <- list()
[17:47:08.105]                 for (kk in seq_along(NAMES)) {
[17:47:08.105]                   name <- changed[[kk]]
[17:47:08.105]                   NAME <- NAMES[[kk]]
[17:47:08.105]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.105]                     next
[17:47:08.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.105]                 }
[17:47:08.105]                 NAMES <- toupper(added)
[17:47:08.105]                 for (kk in seq_along(NAMES)) {
[17:47:08.105]                   name <- added[[kk]]
[17:47:08.105]                   NAME <- NAMES[[kk]]
[17:47:08.105]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.105]                     next
[17:47:08.105]                   args[[name]] <- ""
[17:47:08.105]                 }
[17:47:08.105]                 NAMES <- toupper(removed)
[17:47:08.105]                 for (kk in seq_along(NAMES)) {
[17:47:08.105]                   name <- removed[[kk]]
[17:47:08.105]                   NAME <- NAMES[[kk]]
[17:47:08.105]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.105]                     next
[17:47:08.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.105]                 }
[17:47:08.105]                 if (length(args) > 0) 
[17:47:08.105]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.105]             }
[17:47:08.105]             else {
[17:47:08.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.105]             }
[17:47:08.105]             {
[17:47:08.105]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.105]                   0L) {
[17:47:08.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.105]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.105]                   base::options(opts)
[17:47:08.105]                 }
[17:47:08.105]                 {
[17:47:08.105]                   {
[17:47:08.105]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:08.105]                     NULL
[17:47:08.105]                   }
[17:47:08.105]                   options(future.plan = NULL)
[17:47:08.105]                   if (is.na(NA_character_)) 
[17:47:08.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.105]                     .init = FALSE)
[17:47:08.105]                 }
[17:47:08.105]             }
[17:47:08.105]         }
[17:47:08.105]     })
[17:47:08.105]     if (TRUE) {
[17:47:08.105]         base::sink(type = "output", split = FALSE)
[17:47:08.105]         if (TRUE) {
[17:47:08.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.105]         }
[17:47:08.105]         else {
[17:47:08.105]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.105]         }
[17:47:08.105]         base::close(...future.stdout)
[17:47:08.105]         ...future.stdout <- NULL
[17:47:08.105]     }
[17:47:08.105]     ...future.result$conditions <- ...future.conditions
[17:47:08.105]     ...future.result$finished <- base::Sys.time()
[17:47:08.105]     ...future.result
[17:47:08.105] }
[17:47:08.108] assign_globals() ...
[17:47:08.108] List of 1
[17:47:08.108]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x558b32a56578> 
[17:47:08.108]  - attr(*, "where")=List of 1
[17:47:08.108]   ..$ a:<environment: R_EmptyEnv> 
[17:47:08.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:08.108]  - attr(*, "resolved")= logi TRUE
[17:47:08.108]  - attr(*, "total_size")= num 1647648
[17:47:08.108]  - attr(*, "already-done")= logi TRUE
[17:47:08.111] - copied ‘a’ to environment
[17:47:08.111] assign_globals() ... done
[17:47:08.111] requestCore(): workers = 2
[17:47:08.113] MulticoreFuture started
[17:47:08.113] - Launch lazy future ... done
[17:47:08.114] run() for ‘MulticoreFuture’ ... done
[17:47:08.114] result() for MulticoreFuture ...
[17:47:08.114] plan(): Setting new future strategy stack:
[17:47:08.115] List of future strategies:
[17:47:08.115] 1. sequential:
[17:47:08.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:08.115]    - tweaked: FALSE
[17:47:08.115]    - call: NULL
[17:47:08.116] plan(): nbrOfWorkers() = 1
[17:47:08.119] plan(): Setting new future strategy stack:
[17:47:08.119] List of future strategies:
[17:47:08.119] 1. multicore:
[17:47:08.119]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:08.119]    - tweaked: FALSE
[17:47:08.119]    - call: plan(strategy)
[17:47:08.129] plan(): nbrOfWorkers() = 2
[17:47:08.130] result() for MulticoreFuture ...
[17:47:08.130] result() for MulticoreFuture ... done
[17:47:08.131] signalConditions() ...
[17:47:08.131]  - include = ‘immediateCondition’
[17:47:08.131]  - exclude = 
[17:47:08.131]  - resignal = FALSE
[17:47:08.131]  - Number of conditions: 4
[17:47:08.131] signalConditions() ... done
[17:47:08.131] result() for MulticoreFuture ... done
[17:47:08.131] result() for MulticoreFuture ...
[17:47:08.132] result() for MulticoreFuture ... done
[17:47:08.132] signalConditions() ...
[17:47:08.132]  - include = ‘immediateCondition’
[17:47:08.132]  - exclude = 
[17:47:08.132]  - resignal = FALSE
[17:47:08.132]  - Number of conditions: 4
[17:47:08.132] signalConditions() ... done
[17:47:08.133] Future state: ‘finished’
[17:47:08.133] result() for MulticoreFuture ...
[17:47:08.133] result() for MulticoreFuture ... done
[17:47:08.133] signalConditions() ...
[17:47:08.133]  - include = ‘condition’
[17:47:08.133]  - exclude = ‘immediateCondition’
[17:47:08.133]  - resignal = TRUE
[17:47:08.133]  - Number of conditions: 4
[17:47:08.133]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.117] result() for MulticoreFuture ...
[17:47:08.136]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.117] result() for MulticoreFuture ... done
[17:47:08.137]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.118] result() for MulticoreFuture ...
[17:47:08.137]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.118] result() for MulticoreFuture ... done
[17:47:08.137] signalConditions() ... done
value(b) = 2
[17:47:08.137] result() for MulticoreFuture ...
[17:47:08.137] result() for MulticoreFuture ... done
[17:47:08.138] result() for MulticoreFuture ...
[17:47:08.138] result() for MulticoreFuture ... done
[17:47:08.138] signalConditions() ...
[17:47:08.138]  - include = ‘immediateCondition’
[17:47:08.138]  - exclude = 
[17:47:08.138]  - resignal = FALSE
[17:47:08.138]  - Number of conditions: 4
[17:47:08.138] signalConditions() ... done
[17:47:08.139] Future state: ‘finished’
[17:47:08.139] result() for MulticoreFuture ...
[17:47:08.139] result() for MulticoreFuture ... done
[17:47:08.139] signalConditions() ...
[17:47:08.139]  - include = ‘condition’
[17:47:08.139]  - exclude = ‘immediateCondition’
[17:47:08.139]  - resignal = TRUE
[17:47:08.139]  - Number of conditions: 4
[17:47:08.140]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.117] result() for MulticoreFuture ...
[17:47:08.140]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.117] result() for MulticoreFuture ... done
[17:47:08.140]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.118] result() for MulticoreFuture ...
[17:47:08.140]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:08.118] result() for MulticoreFuture ... done
[17:47:08.140] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.141] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.141] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:08.142] - globals found: [2] ‘{’, ‘pkg’
[17:47:08.142] Searching for globals ... DONE
[17:47:08.143] Resolving globals: TRUE
[17:47:08.143] Resolving any globals that are futures ...
[17:47:08.143] - globals: [2] ‘{’, ‘pkg’
[17:47:08.143] Resolving any globals that are futures ... DONE
[17:47:08.144] Resolving futures part of globals (recursively) ...
[17:47:08.144] resolve() on list ...
[17:47:08.144]  recursive: 99
[17:47:08.144]  length: 1
[17:47:08.144]  elements: ‘pkg’
[17:47:08.145]  length: 0 (resolved future 1)
[17:47:08.145] resolve() on list ... DONE
[17:47:08.145] - globals: [1] ‘pkg’
[17:47:08.145] Resolving futures part of globals (recursively) ... DONE
[17:47:08.145] The total size of the 1 globals is 112 bytes (112 bytes)
[17:47:08.146] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:47:08.146] - globals: [1] ‘pkg’
[17:47:08.146] 
[17:47:08.146] getGlobalsAndPackages() ... DONE
[17:47:08.146] Packages needed by the future expression (n = 0): <none>
[17:47:08.147] Packages needed by future strategies (n = 0): <none>
[17:47:08.147] {
[17:47:08.147]     {
[17:47:08.147]         {
[17:47:08.147]             ...future.startTime <- base::Sys.time()
[17:47:08.147]             {
[17:47:08.147]                 {
[17:47:08.147]                   {
[17:47:08.147]                     base::local({
[17:47:08.147]                       has_future <- base::requireNamespace("future", 
[17:47:08.147]                         quietly = TRUE)
[17:47:08.147]                       if (has_future) {
[17:47:08.147]                         ns <- base::getNamespace("future")
[17:47:08.147]                         version <- ns[[".package"]][["version"]]
[17:47:08.147]                         if (is.null(version)) 
[17:47:08.147]                           version <- utils::packageVersion("future")
[17:47:08.147]                       }
[17:47:08.147]                       else {
[17:47:08.147]                         version <- NULL
[17:47:08.147]                       }
[17:47:08.147]                       if (!has_future || version < "1.8.0") {
[17:47:08.147]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.147]                           "", base::R.version$version.string), 
[17:47:08.147]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:08.147]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:08.147]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.147]                             "release", "version")], collapse = " "), 
[17:47:08.147]                           hostname = base::Sys.info()[["nodename"]])
[17:47:08.147]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.147]                           info)
[17:47:08.147]                         info <- base::paste(info, collapse = "; ")
[17:47:08.147]                         if (!has_future) {
[17:47:08.147]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.147]                             info)
[17:47:08.147]                         }
[17:47:08.147]                         else {
[17:47:08.147]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.147]                             info, version)
[17:47:08.147]                         }
[17:47:08.147]                         base::stop(msg)
[17:47:08.147]                       }
[17:47:08.147]                     })
[17:47:08.147]                   }
[17:47:08.147]                   ...future.strategy.old <- future::plan("list")
[17:47:08.147]                   options(future.plan = NULL)
[17:47:08.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.147]                 }
[17:47:08.147]                 ...future.workdir <- getwd()
[17:47:08.147]             }
[17:47:08.147]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.147]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.147]         }
[17:47:08.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.147]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:08.147]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.147]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.147]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.147]             base::names(...future.oldOptions))
[17:47:08.147]     }
[17:47:08.147]     if (FALSE) {
[17:47:08.147]     }
[17:47:08.147]     else {
[17:47:08.147]         if (TRUE) {
[17:47:08.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.147]                 open = "w")
[17:47:08.147]         }
[17:47:08.147]         else {
[17:47:08.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.147]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.147]         }
[17:47:08.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.147]             base::sink(type = "output", split = FALSE)
[17:47:08.147]             base::close(...future.stdout)
[17:47:08.147]         }, add = TRUE)
[17:47:08.147]     }
[17:47:08.147]     ...future.frame <- base::sys.nframe()
[17:47:08.147]     ...future.conditions <- base::list()
[17:47:08.147]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.147]     if (FALSE) {
[17:47:08.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.147]     }
[17:47:08.147]     ...future.result <- base::tryCatch({
[17:47:08.147]         base::withCallingHandlers({
[17:47:08.147]             ...future.value <- base::withVisible(base::local({
[17:47:08.147]                 pkg
[17:47:08.147]             }))
[17:47:08.147]             future::FutureResult(value = ...future.value$value, 
[17:47:08.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.147]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.147]                     ...future.globalenv.names))
[17:47:08.147]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.147]         }, condition = base::local({
[17:47:08.147]             c <- base::c
[17:47:08.147]             inherits <- base::inherits
[17:47:08.147]             invokeRestart <- base::invokeRestart
[17:47:08.147]             length <- base::length
[17:47:08.147]             list <- base::list
[17:47:08.147]             seq.int <- base::seq.int
[17:47:08.147]             signalCondition <- base::signalCondition
[17:47:08.147]             sys.calls <- base::sys.calls
[17:47:08.147]             `[[` <- base::`[[`
[17:47:08.147]             `+` <- base::`+`
[17:47:08.147]             `<<-` <- base::`<<-`
[17:47:08.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.147]                   3L)]
[17:47:08.147]             }
[17:47:08.147]             function(cond) {
[17:47:08.147]                 is_error <- inherits(cond, "error")
[17:47:08.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.147]                   NULL)
[17:47:08.147]                 if (is_error) {
[17:47:08.147]                   sessionInformation <- function() {
[17:47:08.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.147]                       search = base::search(), system = base::Sys.info())
[17:47:08.147]                   }
[17:47:08.147]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.147]                     cond$call), session = sessionInformation(), 
[17:47:08.147]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.147]                   signalCondition(cond)
[17:47:08.147]                 }
[17:47:08.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.147]                 "immediateCondition"))) {
[17:47:08.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.147]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.147]                   if (TRUE && !signal) {
[17:47:08.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.147]                     {
[17:47:08.147]                       inherits <- base::inherits
[17:47:08.147]                       invokeRestart <- base::invokeRestart
[17:47:08.147]                       is.null <- base::is.null
[17:47:08.147]                       muffled <- FALSE
[17:47:08.147]                       if (inherits(cond, "message")) {
[17:47:08.147]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.147]                         if (muffled) 
[17:47:08.147]                           invokeRestart("muffleMessage")
[17:47:08.147]                       }
[17:47:08.147]                       else if (inherits(cond, "warning")) {
[17:47:08.147]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.147]                         if (muffled) 
[17:47:08.147]                           invokeRestart("muffleWarning")
[17:47:08.147]                       }
[17:47:08.147]                       else if (inherits(cond, "condition")) {
[17:47:08.147]                         if (!is.null(pattern)) {
[17:47:08.147]                           computeRestarts <- base::computeRestarts
[17:47:08.147]                           grepl <- base::grepl
[17:47:08.147]                           restarts <- computeRestarts(cond)
[17:47:08.147]                           for (restart in restarts) {
[17:47:08.147]                             name <- restart$name
[17:47:08.147]                             if (is.null(name)) 
[17:47:08.147]                               next
[17:47:08.147]                             if (!grepl(pattern, name)) 
[17:47:08.147]                               next
[17:47:08.147]                             invokeRestart(restart)
[17:47:08.147]                             muffled <- TRUE
[17:47:08.147]                             break
[17:47:08.147]                           }
[17:47:08.147]                         }
[17:47:08.147]                       }
[17:47:08.147]                       invisible(muffled)
[17:47:08.147]                     }
[17:47:08.147]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.147]                   }
[17:47:08.147]                 }
[17:47:08.147]                 else {
[17:47:08.147]                   if (TRUE) {
[17:47:08.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.147]                     {
[17:47:08.147]                       inherits <- base::inherits
[17:47:08.147]                       invokeRestart <- base::invokeRestart
[17:47:08.147]                       is.null <- base::is.null
[17:47:08.147]                       muffled <- FALSE
[17:47:08.147]                       if (inherits(cond, "message")) {
[17:47:08.147]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.147]                         if (muffled) 
[17:47:08.147]                           invokeRestart("muffleMessage")
[17:47:08.147]                       }
[17:47:08.147]                       else if (inherits(cond, "warning")) {
[17:47:08.147]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.147]                         if (muffled) 
[17:47:08.147]                           invokeRestart("muffleWarning")
[17:47:08.147]                       }
[17:47:08.147]                       else if (inherits(cond, "condition")) {
[17:47:08.147]                         if (!is.null(pattern)) {
[17:47:08.147]                           computeRestarts <- base::computeRestarts
[17:47:08.147]                           grepl <- base::grepl
[17:47:08.147]                           restarts <- computeRestarts(cond)
[17:47:08.147]                           for (restart in restarts) {
[17:47:08.147]                             name <- restart$name
[17:47:08.147]                             if (is.null(name)) 
[17:47:08.147]                               next
[17:47:08.147]                             if (!grepl(pattern, name)) 
[17:47:08.147]                               next
[17:47:08.147]                             invokeRestart(restart)
[17:47:08.147]                             muffled <- TRUE
[17:47:08.147]                             break
[17:47:08.147]                           }
[17:47:08.147]                         }
[17:47:08.147]                       }
[17:47:08.147]                       invisible(muffled)
[17:47:08.147]                     }
[17:47:08.147]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.147]                   }
[17:47:08.147]                 }
[17:47:08.147]             }
[17:47:08.147]         }))
[17:47:08.147]     }, error = function(ex) {
[17:47:08.147]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.147]                 ...future.rng), started = ...future.startTime, 
[17:47:08.147]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.147]             version = "1.8"), class = "FutureResult")
[17:47:08.147]     }, finally = {
[17:47:08.147]         if (!identical(...future.workdir, getwd())) 
[17:47:08.147]             setwd(...future.workdir)
[17:47:08.147]         {
[17:47:08.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.147]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.147]             }
[17:47:08.147]             base::options(...future.oldOptions)
[17:47:08.147]             if (.Platform$OS.type == "windows") {
[17:47:08.147]                 old_names <- names(...future.oldEnvVars)
[17:47:08.147]                 envs <- base::Sys.getenv()
[17:47:08.147]                 names <- names(envs)
[17:47:08.147]                 common <- intersect(names, old_names)
[17:47:08.147]                 added <- setdiff(names, old_names)
[17:47:08.147]                 removed <- setdiff(old_names, names)
[17:47:08.147]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.147]                   envs[common]]
[17:47:08.147]                 NAMES <- toupper(changed)
[17:47:08.147]                 args <- list()
[17:47:08.147]                 for (kk in seq_along(NAMES)) {
[17:47:08.147]                   name <- changed[[kk]]
[17:47:08.147]                   NAME <- NAMES[[kk]]
[17:47:08.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.147]                     next
[17:47:08.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.147]                 }
[17:47:08.147]                 NAMES <- toupper(added)
[17:47:08.147]                 for (kk in seq_along(NAMES)) {
[17:47:08.147]                   name <- added[[kk]]
[17:47:08.147]                   NAME <- NAMES[[kk]]
[17:47:08.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.147]                     next
[17:47:08.147]                   args[[name]] <- ""
[17:47:08.147]                 }
[17:47:08.147]                 NAMES <- toupper(removed)
[17:47:08.147]                 for (kk in seq_along(NAMES)) {
[17:47:08.147]                   name <- removed[[kk]]
[17:47:08.147]                   NAME <- NAMES[[kk]]
[17:47:08.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.147]                     next
[17:47:08.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.147]                 }
[17:47:08.147]                 if (length(args) > 0) 
[17:47:08.147]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.147]             }
[17:47:08.147]             else {
[17:47:08.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.147]             }
[17:47:08.147]             {
[17:47:08.147]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.147]                   0L) {
[17:47:08.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.147]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.147]                   base::options(opts)
[17:47:08.147]                 }
[17:47:08.147]                 {
[17:47:08.147]                   {
[17:47:08.147]                     NULL
[17:47:08.147]                     RNGkind("Mersenne-Twister")
[17:47:08.147]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:08.147]                       inherits = FALSE)
[17:47:08.147]                   }
[17:47:08.147]                   options(future.plan = NULL)
[17:47:08.147]                   if (is.na(NA_character_)) 
[17:47:08.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.147]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.147]                     .init = FALSE)
[17:47:08.147]                 }
[17:47:08.147]             }
[17:47:08.147]         }
[17:47:08.147]     })
[17:47:08.147]     if (TRUE) {
[17:47:08.147]         base::sink(type = "output", split = FALSE)
[17:47:08.147]         if (TRUE) {
[17:47:08.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.147]         }
[17:47:08.147]         else {
[17:47:08.147]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.147]         }
[17:47:08.147]         base::close(...future.stdout)
[17:47:08.147]         ...future.stdout <- NULL
[17:47:08.147]     }
[17:47:08.147]     ...future.result$conditions <- ...future.conditions
[17:47:08.147]     ...future.result$finished <- base::Sys.time()
[17:47:08.147]     ...future.result
[17:47:08.147] }
[17:47:08.149] assign_globals() ...
[17:47:08.149] List of 1
[17:47:08.149]  $ pkg: chr "foo"
[17:47:08.149]  - attr(*, "where")=List of 1
[17:47:08.149]   ..$ pkg:<environment: R_EmptyEnv> 
[17:47:08.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:08.149]  - attr(*, "resolved")= logi TRUE
[17:47:08.149]  - attr(*, "total_size")= num 112
[17:47:08.152] - copied ‘pkg’ to environment
[17:47:08.152] assign_globals() ... done
[17:47:08.152] plan(): Setting new future strategy stack:
[17:47:08.152] List of future strategies:
[17:47:08.152] 1. sequential:
[17:47:08.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:08.152]    - tweaked: FALSE
[17:47:08.152]    - call: NULL
[17:47:08.153] plan(): nbrOfWorkers() = 1
[17:47:08.154] plan(): Setting new future strategy stack:
[17:47:08.154] List of future strategies:
[17:47:08.154] 1. multicore:
[17:47:08.154]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:08.154]    - tweaked: FALSE
[17:47:08.154]    - call: plan(strategy)
[17:47:08.158] plan(): nbrOfWorkers() = 2
[17:47:08.158] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.158] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.159] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:08.161] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:47:08.161] Searching for globals ... DONE
[17:47:08.161] Resolving globals: TRUE
[17:47:08.161] Resolving any globals that are futures ...
[17:47:08.161] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:47:08.161] Resolving any globals that are futures ... DONE
[17:47:08.162] 
[17:47:08.162] 
[17:47:08.162] getGlobalsAndPackages() ... DONE
[17:47:08.162] run() for ‘Future’ ...
[17:47:08.162] - state: ‘created’
[17:47:08.162] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:08.166] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:08.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:08.166]   - Field: ‘label’
[17:47:08.166]   - Field: ‘local’
[17:47:08.166]   - Field: ‘owner’
[17:47:08.167]   - Field: ‘envir’
[17:47:08.167]   - Field: ‘workers’
[17:47:08.167]   - Field: ‘packages’
[17:47:08.167]   - Field: ‘gc’
[17:47:08.167]   - Field: ‘job’
[17:47:08.167]   - Field: ‘conditions’
[17:47:08.167]   - Field: ‘expr’
[17:47:08.167]   - Field: ‘uuid’
[17:47:08.167]   - Field: ‘seed’
[17:47:08.168]   - Field: ‘version’
[17:47:08.168]   - Field: ‘result’
[17:47:08.168]   - Field: ‘asynchronous’
[17:47:08.168]   - Field: ‘calls’
[17:47:08.168]   - Field: ‘globals’
[17:47:08.168]   - Field: ‘stdout’
[17:47:08.168]   - Field: ‘earlySignal’
[17:47:08.168]   - Field: ‘lazy’
[17:47:08.168]   - Field: ‘state’
[17:47:08.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:08.168] - Launch lazy future ...
[17:47:08.169] Packages needed by the future expression (n = 0): <none>
[17:47:08.169] Packages needed by future strategies (n = 0): <none>
[17:47:08.169] {
[17:47:08.169]     {
[17:47:08.169]         {
[17:47:08.169]             ...future.startTime <- base::Sys.time()
[17:47:08.169]             {
[17:47:08.169]                 {
[17:47:08.169]                   {
[17:47:08.169]                     {
[17:47:08.169]                       base::local({
[17:47:08.169]                         has_future <- base::requireNamespace("future", 
[17:47:08.169]                           quietly = TRUE)
[17:47:08.169]                         if (has_future) {
[17:47:08.169]                           ns <- base::getNamespace("future")
[17:47:08.169]                           version <- ns[[".package"]][["version"]]
[17:47:08.169]                           if (is.null(version)) 
[17:47:08.169]                             version <- utils::packageVersion("future")
[17:47:08.169]                         }
[17:47:08.169]                         else {
[17:47:08.169]                           version <- NULL
[17:47:08.169]                         }
[17:47:08.169]                         if (!has_future || version < "1.8.0") {
[17:47:08.169]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.169]                             "", base::R.version$version.string), 
[17:47:08.169]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:08.169]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:08.169]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.169]                               "release", "version")], collapse = " "), 
[17:47:08.169]                             hostname = base::Sys.info()[["nodename"]])
[17:47:08.169]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.169]                             info)
[17:47:08.169]                           info <- base::paste(info, collapse = "; ")
[17:47:08.169]                           if (!has_future) {
[17:47:08.169]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.169]                               info)
[17:47:08.169]                           }
[17:47:08.169]                           else {
[17:47:08.169]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.169]                               info, version)
[17:47:08.169]                           }
[17:47:08.169]                           base::stop(msg)
[17:47:08.169]                         }
[17:47:08.169]                       })
[17:47:08.169]                     }
[17:47:08.169]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:08.169]                     base::options(mc.cores = 1L)
[17:47:08.169]                   }
[17:47:08.169]                   ...future.strategy.old <- future::plan("list")
[17:47:08.169]                   options(future.plan = NULL)
[17:47:08.169]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.169]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.169]                 }
[17:47:08.169]                 ...future.workdir <- getwd()
[17:47:08.169]             }
[17:47:08.169]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.169]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.169]         }
[17:47:08.169]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.169]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:08.169]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.169]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.169]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.169]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.169]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.169]             base::names(...future.oldOptions))
[17:47:08.169]     }
[17:47:08.169]     if (FALSE) {
[17:47:08.169]     }
[17:47:08.169]     else {
[17:47:08.169]         if (TRUE) {
[17:47:08.169]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.169]                 open = "w")
[17:47:08.169]         }
[17:47:08.169]         else {
[17:47:08.169]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.169]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.169]         }
[17:47:08.169]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.169]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.169]             base::sink(type = "output", split = FALSE)
[17:47:08.169]             base::close(...future.stdout)
[17:47:08.169]         }, add = TRUE)
[17:47:08.169]     }
[17:47:08.169]     ...future.frame <- base::sys.nframe()
[17:47:08.169]     ...future.conditions <- base::list()
[17:47:08.169]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.169]     if (FALSE) {
[17:47:08.169]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.169]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.169]     }
[17:47:08.169]     ...future.result <- base::tryCatch({
[17:47:08.169]         base::withCallingHandlers({
[17:47:08.169]             ...future.value <- base::withVisible(base::local({
[17:47:08.169]                 withCallingHandlers({
[17:47:08.169]                   {
[17:47:08.169]                     x <- 0
[17:47:08.169]                     x <- x + 1
[17:47:08.169]                     x
[17:47:08.169]                   }
[17:47:08.169]                 }, immediateCondition = function(cond) {
[17:47:08.169]                   save_rds <- function (object, pathname, ...) 
[17:47:08.169]                   {
[17:47:08.169]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:08.169]                     if (file_test("-f", pathname_tmp)) {
[17:47:08.169]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.169]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:08.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.169]                         fi_tmp[["mtime"]])
[17:47:08.169]                     }
[17:47:08.169]                     tryCatch({
[17:47:08.169]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:08.169]                     }, error = function(ex) {
[17:47:08.169]                       msg <- conditionMessage(ex)
[17:47:08.169]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.169]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:08.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.169]                         fi_tmp[["mtime"]], msg)
[17:47:08.169]                       ex$message <- msg
[17:47:08.169]                       stop(ex)
[17:47:08.169]                     })
[17:47:08.169]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:08.169]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:08.169]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:08.169]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.169]                       fi <- file.info(pathname)
[17:47:08.169]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:08.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.169]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:08.169]                         fi[["size"]], fi[["mtime"]])
[17:47:08.169]                       stop(msg)
[17:47:08.169]                     }
[17:47:08.169]                     invisible(pathname)
[17:47:08.169]                   }
[17:47:08.169]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:08.169]                     rootPath = tempdir()) 
[17:47:08.169]                   {
[17:47:08.169]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:08.169]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:08.169]                       tmpdir = path, fileext = ".rds")
[17:47:08.169]                     save_rds(obj, file)
[17:47:08.169]                   }
[17:47:08.169]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:08.169]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.169]                   {
[17:47:08.169]                     inherits <- base::inherits
[17:47:08.169]                     invokeRestart <- base::invokeRestart
[17:47:08.169]                     is.null <- base::is.null
[17:47:08.169]                     muffled <- FALSE
[17:47:08.169]                     if (inherits(cond, "message")) {
[17:47:08.169]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:08.169]                       if (muffled) 
[17:47:08.169]                         invokeRestart("muffleMessage")
[17:47:08.169]                     }
[17:47:08.169]                     else if (inherits(cond, "warning")) {
[17:47:08.169]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:08.169]                       if (muffled) 
[17:47:08.169]                         invokeRestart("muffleWarning")
[17:47:08.169]                     }
[17:47:08.169]                     else if (inherits(cond, "condition")) {
[17:47:08.169]                       if (!is.null(pattern)) {
[17:47:08.169]                         computeRestarts <- base::computeRestarts
[17:47:08.169]                         grepl <- base::grepl
[17:47:08.169]                         restarts <- computeRestarts(cond)
[17:47:08.169]                         for (restart in restarts) {
[17:47:08.169]                           name <- restart$name
[17:47:08.169]                           if (is.null(name)) 
[17:47:08.169]                             next
[17:47:08.169]                           if (!grepl(pattern, name)) 
[17:47:08.169]                             next
[17:47:08.169]                           invokeRestart(restart)
[17:47:08.169]                           muffled <- TRUE
[17:47:08.169]                           break
[17:47:08.169]                         }
[17:47:08.169]                       }
[17:47:08.169]                     }
[17:47:08.169]                     invisible(muffled)
[17:47:08.169]                   }
[17:47:08.169]                   muffleCondition(cond)
[17:47:08.169]                 })
[17:47:08.169]             }))
[17:47:08.169]             future::FutureResult(value = ...future.value$value, 
[17:47:08.169]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.169]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.169]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.169]                     ...future.globalenv.names))
[17:47:08.169]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.169]         }, condition = base::local({
[17:47:08.169]             c <- base::c
[17:47:08.169]             inherits <- base::inherits
[17:47:08.169]             invokeRestart <- base::invokeRestart
[17:47:08.169]             length <- base::length
[17:47:08.169]             list <- base::list
[17:47:08.169]             seq.int <- base::seq.int
[17:47:08.169]             signalCondition <- base::signalCondition
[17:47:08.169]             sys.calls <- base::sys.calls
[17:47:08.169]             `[[` <- base::`[[`
[17:47:08.169]             `+` <- base::`+`
[17:47:08.169]             `<<-` <- base::`<<-`
[17:47:08.169]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.169]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.169]                   3L)]
[17:47:08.169]             }
[17:47:08.169]             function(cond) {
[17:47:08.169]                 is_error <- inherits(cond, "error")
[17:47:08.169]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.169]                   NULL)
[17:47:08.169]                 if (is_error) {
[17:47:08.169]                   sessionInformation <- function() {
[17:47:08.169]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.169]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.169]                       search = base::search(), system = base::Sys.info())
[17:47:08.169]                   }
[17:47:08.169]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.169]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.169]                     cond$call), session = sessionInformation(), 
[17:47:08.169]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.169]                   signalCondition(cond)
[17:47:08.169]                 }
[17:47:08.169]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.169]                 "immediateCondition"))) {
[17:47:08.169]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.169]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.169]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.169]                   if (TRUE && !signal) {
[17:47:08.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.169]                     {
[17:47:08.169]                       inherits <- base::inherits
[17:47:08.169]                       invokeRestart <- base::invokeRestart
[17:47:08.169]                       is.null <- base::is.null
[17:47:08.169]                       muffled <- FALSE
[17:47:08.169]                       if (inherits(cond, "message")) {
[17:47:08.169]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.169]                         if (muffled) 
[17:47:08.169]                           invokeRestart("muffleMessage")
[17:47:08.169]                       }
[17:47:08.169]                       else if (inherits(cond, "warning")) {
[17:47:08.169]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.169]                         if (muffled) 
[17:47:08.169]                           invokeRestart("muffleWarning")
[17:47:08.169]                       }
[17:47:08.169]                       else if (inherits(cond, "condition")) {
[17:47:08.169]                         if (!is.null(pattern)) {
[17:47:08.169]                           computeRestarts <- base::computeRestarts
[17:47:08.169]                           grepl <- base::grepl
[17:47:08.169]                           restarts <- computeRestarts(cond)
[17:47:08.169]                           for (restart in restarts) {
[17:47:08.169]                             name <- restart$name
[17:47:08.169]                             if (is.null(name)) 
[17:47:08.169]                               next
[17:47:08.169]                             if (!grepl(pattern, name)) 
[17:47:08.169]                               next
[17:47:08.169]                             invokeRestart(restart)
[17:47:08.169]                             muffled <- TRUE
[17:47:08.169]                             break
[17:47:08.169]                           }
[17:47:08.169]                         }
[17:47:08.169]                       }
[17:47:08.169]                       invisible(muffled)
[17:47:08.169]                     }
[17:47:08.169]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.169]                   }
[17:47:08.169]                 }
[17:47:08.169]                 else {
[17:47:08.169]                   if (TRUE) {
[17:47:08.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.169]                     {
[17:47:08.169]                       inherits <- base::inherits
[17:47:08.169]                       invokeRestart <- base::invokeRestart
[17:47:08.169]                       is.null <- base::is.null
[17:47:08.169]                       muffled <- FALSE
[17:47:08.169]                       if (inherits(cond, "message")) {
[17:47:08.169]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.169]                         if (muffled) 
[17:47:08.169]                           invokeRestart("muffleMessage")
[17:47:08.169]                       }
[17:47:08.169]                       else if (inherits(cond, "warning")) {
[17:47:08.169]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.169]                         if (muffled) 
[17:47:08.169]                           invokeRestart("muffleWarning")
[17:47:08.169]                       }
[17:47:08.169]                       else if (inherits(cond, "condition")) {
[17:47:08.169]                         if (!is.null(pattern)) {
[17:47:08.169]                           computeRestarts <- base::computeRestarts
[17:47:08.169]                           grepl <- base::grepl
[17:47:08.169]                           restarts <- computeRestarts(cond)
[17:47:08.169]                           for (restart in restarts) {
[17:47:08.169]                             name <- restart$name
[17:47:08.169]                             if (is.null(name)) 
[17:47:08.169]                               next
[17:47:08.169]                             if (!grepl(pattern, name)) 
[17:47:08.169]                               next
[17:47:08.169]                             invokeRestart(restart)
[17:47:08.169]                             muffled <- TRUE
[17:47:08.169]                             break
[17:47:08.169]                           }
[17:47:08.169]                         }
[17:47:08.169]                       }
[17:47:08.169]                       invisible(muffled)
[17:47:08.169]                     }
[17:47:08.169]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.169]                   }
[17:47:08.169]                 }
[17:47:08.169]             }
[17:47:08.169]         }))
[17:47:08.169]     }, error = function(ex) {
[17:47:08.169]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.169]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.169]                 ...future.rng), started = ...future.startTime, 
[17:47:08.169]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.169]             version = "1.8"), class = "FutureResult")
[17:47:08.169]     }, finally = {
[17:47:08.169]         if (!identical(...future.workdir, getwd())) 
[17:47:08.169]             setwd(...future.workdir)
[17:47:08.169]         {
[17:47:08.169]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.169]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.169]             }
[17:47:08.169]             base::options(...future.oldOptions)
[17:47:08.169]             if (.Platform$OS.type == "windows") {
[17:47:08.169]                 old_names <- names(...future.oldEnvVars)
[17:47:08.169]                 envs <- base::Sys.getenv()
[17:47:08.169]                 names <- names(envs)
[17:47:08.169]                 common <- intersect(names, old_names)
[17:47:08.169]                 added <- setdiff(names, old_names)
[17:47:08.169]                 removed <- setdiff(old_names, names)
[17:47:08.169]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.169]                   envs[common]]
[17:47:08.169]                 NAMES <- toupper(changed)
[17:47:08.169]                 args <- list()
[17:47:08.169]                 for (kk in seq_along(NAMES)) {
[17:47:08.169]                   name <- changed[[kk]]
[17:47:08.169]                   NAME <- NAMES[[kk]]
[17:47:08.169]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.169]                     next
[17:47:08.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.169]                 }
[17:47:08.169]                 NAMES <- toupper(added)
[17:47:08.169]                 for (kk in seq_along(NAMES)) {
[17:47:08.169]                   name <- added[[kk]]
[17:47:08.169]                   NAME <- NAMES[[kk]]
[17:47:08.169]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.169]                     next
[17:47:08.169]                   args[[name]] <- ""
[17:47:08.169]                 }
[17:47:08.169]                 NAMES <- toupper(removed)
[17:47:08.169]                 for (kk in seq_along(NAMES)) {
[17:47:08.169]                   name <- removed[[kk]]
[17:47:08.169]                   NAME <- NAMES[[kk]]
[17:47:08.169]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.169]                     next
[17:47:08.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.169]                 }
[17:47:08.169]                 if (length(args) > 0) 
[17:47:08.169]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.169]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.169]             }
[17:47:08.169]             else {
[17:47:08.169]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.169]             }
[17:47:08.169]             {
[17:47:08.169]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.169]                   0L) {
[17:47:08.169]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.169]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.169]                   base::options(opts)
[17:47:08.169]                 }
[17:47:08.169]                 {
[17:47:08.169]                   {
[17:47:08.169]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:08.169]                     NULL
[17:47:08.169]                   }
[17:47:08.169]                   options(future.plan = NULL)
[17:47:08.169]                   if (is.na(NA_character_)) 
[17:47:08.169]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.169]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.169]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.169]                     .init = FALSE)
[17:47:08.169]                 }
[17:47:08.169]             }
[17:47:08.169]         }
[17:47:08.169]     })
[17:47:08.169]     if (TRUE) {
[17:47:08.169]         base::sink(type = "output", split = FALSE)
[17:47:08.169]         if (TRUE) {
[17:47:08.169]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.169]         }
[17:47:08.169]         else {
[17:47:08.169]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.169]         }
[17:47:08.169]         base::close(...future.stdout)
[17:47:08.169]         ...future.stdout <- NULL
[17:47:08.169]     }
[17:47:08.169]     ...future.result$conditions <- ...future.conditions
[17:47:08.169]     ...future.result$finished <- base::Sys.time()
[17:47:08.169]     ...future.result
[17:47:08.169] }
[17:47:08.172] requestCore(): workers = 2
[17:47:08.174] MulticoreFuture started
[17:47:08.174] - Launch lazy future ... done
[17:47:08.174] run() for ‘MulticoreFuture’ ... done
[17:47:08.175] plan(): Setting new future strategy stack:
[17:47:08.175] result() for MulticoreFuture ...
[17:47:08.175] List of future strategies:
[17:47:08.175] 1. sequential:
[17:47:08.175]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:08.175]    - tweaked: FALSE
[17:47:08.175]    - call: NULL
[17:47:08.181] plan(): nbrOfWorkers() = 1
[17:47:08.183] plan(): Setting new future strategy stack:
[17:47:08.183] List of future strategies:
[17:47:08.183] 1. multicore:
[17:47:08.183]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:08.183]    - tweaked: FALSE
[17:47:08.183]    - call: plan(strategy)
[17:47:08.188] plan(): nbrOfWorkers() = 2
[17:47:08.189] result() for MulticoreFuture ...
[17:47:08.189] result() for MulticoreFuture ... done
[17:47:08.190] result() for MulticoreFuture ... done
[17:47:08.190] result() for MulticoreFuture ...
[17:47:08.190] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.190] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.191] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:08.193] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:47:08.193] Searching for globals ... DONE
[17:47:08.193] Resolving globals: TRUE
[17:47:08.193] Resolving any globals that are futures ...
[17:47:08.194] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:47:08.194] Resolving any globals that are futures ... DONE
[17:47:08.194] Resolving futures part of globals (recursively) ...
[17:47:08.195] resolve() on list ...
[17:47:08.195]  recursive: 99
[17:47:08.195]  length: 1
[17:47:08.195]  elements: ‘x’
[17:47:08.195]  length: 0 (resolved future 1)
[17:47:08.195] resolve() on list ... DONE
[17:47:08.196] - globals: [1] ‘x’
[17:47:08.196] Resolving futures part of globals (recursively) ... DONE
[17:47:08.196] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:08.197] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:47:08.197] - globals: [1] ‘x’
[17:47:08.197] 
[17:47:08.197] getGlobalsAndPackages() ... DONE
[17:47:08.197] run() for ‘Future’ ...
[17:47:08.198] - state: ‘created’
[17:47:08.198] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:08.202] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:08.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:08.202]   - Field: ‘label’
[17:47:08.202]   - Field: ‘local’
[17:47:08.202]   - Field: ‘owner’
[17:47:08.203]   - Field: ‘envir’
[17:47:08.203]   - Field: ‘workers’
[17:47:08.203]   - Field: ‘packages’
[17:47:08.203]   - Field: ‘gc’
[17:47:08.203]   - Field: ‘job’
[17:47:08.203]   - Field: ‘conditions’
[17:47:08.203]   - Field: ‘expr’
[17:47:08.203]   - Field: ‘uuid’
[17:47:08.203]   - Field: ‘seed’
[17:47:08.204]   - Field: ‘version’
[17:47:08.204]   - Field: ‘result’
[17:47:08.204]   - Field: ‘asynchronous’
[17:47:08.204]   - Field: ‘calls’
[17:47:08.204]   - Field: ‘globals’
[17:47:08.204]   - Field: ‘stdout’
[17:47:08.204]   - Field: ‘earlySignal’
[17:47:08.204]   - Field: ‘lazy’
[17:47:08.204]   - Field: ‘state’
[17:47:08.205] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:08.205] - Launch lazy future ...
[17:47:08.205] Packages needed by the future expression (n = 0): <none>
[17:47:08.205] Packages needed by future strategies (n = 0): <none>
[17:47:08.206] {
[17:47:08.206]     {
[17:47:08.206]         {
[17:47:08.206]             ...future.startTime <- base::Sys.time()
[17:47:08.206]             {
[17:47:08.206]                 {
[17:47:08.206]                   {
[17:47:08.206]                     {
[17:47:08.206]                       base::local({
[17:47:08.206]                         has_future <- base::requireNamespace("future", 
[17:47:08.206]                           quietly = TRUE)
[17:47:08.206]                         if (has_future) {
[17:47:08.206]                           ns <- base::getNamespace("future")
[17:47:08.206]                           version <- ns[[".package"]][["version"]]
[17:47:08.206]                           if (is.null(version)) 
[17:47:08.206]                             version <- utils::packageVersion("future")
[17:47:08.206]                         }
[17:47:08.206]                         else {
[17:47:08.206]                           version <- NULL
[17:47:08.206]                         }
[17:47:08.206]                         if (!has_future || version < "1.8.0") {
[17:47:08.206]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.206]                             "", base::R.version$version.string), 
[17:47:08.206]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:08.206]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:08.206]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.206]                               "release", "version")], collapse = " "), 
[17:47:08.206]                             hostname = base::Sys.info()[["nodename"]])
[17:47:08.206]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.206]                             info)
[17:47:08.206]                           info <- base::paste(info, collapse = "; ")
[17:47:08.206]                           if (!has_future) {
[17:47:08.206]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.206]                               info)
[17:47:08.206]                           }
[17:47:08.206]                           else {
[17:47:08.206]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.206]                               info, version)
[17:47:08.206]                           }
[17:47:08.206]                           base::stop(msg)
[17:47:08.206]                         }
[17:47:08.206]                       })
[17:47:08.206]                     }
[17:47:08.206]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:08.206]                     base::options(mc.cores = 1L)
[17:47:08.206]                   }
[17:47:08.206]                   ...future.strategy.old <- future::plan("list")
[17:47:08.206]                   options(future.plan = NULL)
[17:47:08.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.206]                 }
[17:47:08.206]                 ...future.workdir <- getwd()
[17:47:08.206]             }
[17:47:08.206]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.206]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.206]         }
[17:47:08.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.206]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:08.206]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.206]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.206]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.206]             base::names(...future.oldOptions))
[17:47:08.206]     }
[17:47:08.206]     if (FALSE) {
[17:47:08.206]     }
[17:47:08.206]     else {
[17:47:08.206]         if (TRUE) {
[17:47:08.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.206]                 open = "w")
[17:47:08.206]         }
[17:47:08.206]         else {
[17:47:08.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.206]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.206]         }
[17:47:08.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.206]             base::sink(type = "output", split = FALSE)
[17:47:08.206]             base::close(...future.stdout)
[17:47:08.206]         }, add = TRUE)
[17:47:08.206]     }
[17:47:08.206]     ...future.frame <- base::sys.nframe()
[17:47:08.206]     ...future.conditions <- base::list()
[17:47:08.206]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.206]     if (FALSE) {
[17:47:08.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.206]     }
[17:47:08.206]     ...future.result <- base::tryCatch({
[17:47:08.206]         base::withCallingHandlers({
[17:47:08.206]             ...future.value <- base::withVisible(base::local({
[17:47:08.206]                 withCallingHandlers({
[17:47:08.206]                   {
[17:47:08.206]                     x <- x + 1
[17:47:08.206]                     x
[17:47:08.206]                   }
[17:47:08.206]                 }, immediateCondition = function(cond) {
[17:47:08.206]                   save_rds <- function (object, pathname, ...) 
[17:47:08.206]                   {
[17:47:08.206]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:08.206]                     if (file_test("-f", pathname_tmp)) {
[17:47:08.206]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.206]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:08.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.206]                         fi_tmp[["mtime"]])
[17:47:08.206]                     }
[17:47:08.206]                     tryCatch({
[17:47:08.206]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:08.206]                     }, error = function(ex) {
[17:47:08.206]                       msg <- conditionMessage(ex)
[17:47:08.206]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.206]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:08.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.206]                         fi_tmp[["mtime"]], msg)
[17:47:08.206]                       ex$message <- msg
[17:47:08.206]                       stop(ex)
[17:47:08.206]                     })
[17:47:08.206]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:08.206]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:08.206]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:08.206]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.206]                       fi <- file.info(pathname)
[17:47:08.206]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:08.206]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.206]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:08.206]                         fi[["size"]], fi[["mtime"]])
[17:47:08.206]                       stop(msg)
[17:47:08.206]                     }
[17:47:08.206]                     invisible(pathname)
[17:47:08.206]                   }
[17:47:08.206]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:08.206]                     rootPath = tempdir()) 
[17:47:08.206]                   {
[17:47:08.206]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:08.206]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:08.206]                       tmpdir = path, fileext = ".rds")
[17:47:08.206]                     save_rds(obj, file)
[17:47:08.206]                   }
[17:47:08.206]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:08.206]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.206]                   {
[17:47:08.206]                     inherits <- base::inherits
[17:47:08.206]                     invokeRestart <- base::invokeRestart
[17:47:08.206]                     is.null <- base::is.null
[17:47:08.206]                     muffled <- FALSE
[17:47:08.206]                     if (inherits(cond, "message")) {
[17:47:08.206]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:08.206]                       if (muffled) 
[17:47:08.206]                         invokeRestart("muffleMessage")
[17:47:08.206]                     }
[17:47:08.206]                     else if (inherits(cond, "warning")) {
[17:47:08.206]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:08.206]                       if (muffled) 
[17:47:08.206]                         invokeRestart("muffleWarning")
[17:47:08.206]                     }
[17:47:08.206]                     else if (inherits(cond, "condition")) {
[17:47:08.206]                       if (!is.null(pattern)) {
[17:47:08.206]                         computeRestarts <- base::computeRestarts
[17:47:08.206]                         grepl <- base::grepl
[17:47:08.206]                         restarts <- computeRestarts(cond)
[17:47:08.206]                         for (restart in restarts) {
[17:47:08.206]                           name <- restart$name
[17:47:08.206]                           if (is.null(name)) 
[17:47:08.206]                             next
[17:47:08.206]                           if (!grepl(pattern, name)) 
[17:47:08.206]                             next
[17:47:08.206]                           invokeRestart(restart)
[17:47:08.206]                           muffled <- TRUE
[17:47:08.206]                           break
[17:47:08.206]                         }
[17:47:08.206]                       }
[17:47:08.206]                     }
[17:47:08.206]                     invisible(muffled)
[17:47:08.206]                   }
[17:47:08.206]                   muffleCondition(cond)
[17:47:08.206]                 })
[17:47:08.206]             }))
[17:47:08.206]             future::FutureResult(value = ...future.value$value, 
[17:47:08.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.206]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.206]                     ...future.globalenv.names))
[17:47:08.206]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.206]         }, condition = base::local({
[17:47:08.206]             c <- base::c
[17:47:08.206]             inherits <- base::inherits
[17:47:08.206]             invokeRestart <- base::invokeRestart
[17:47:08.206]             length <- base::length
[17:47:08.206]             list <- base::list
[17:47:08.206]             seq.int <- base::seq.int
[17:47:08.206]             signalCondition <- base::signalCondition
[17:47:08.206]             sys.calls <- base::sys.calls
[17:47:08.206]             `[[` <- base::`[[`
[17:47:08.206]             `+` <- base::`+`
[17:47:08.206]             `<<-` <- base::`<<-`
[17:47:08.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.206]                   3L)]
[17:47:08.206]             }
[17:47:08.206]             function(cond) {
[17:47:08.206]                 is_error <- inherits(cond, "error")
[17:47:08.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.206]                   NULL)
[17:47:08.206]                 if (is_error) {
[17:47:08.206]                   sessionInformation <- function() {
[17:47:08.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.206]                       search = base::search(), system = base::Sys.info())
[17:47:08.206]                   }
[17:47:08.206]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.206]                     cond$call), session = sessionInformation(), 
[17:47:08.206]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.206]                   signalCondition(cond)
[17:47:08.206]                 }
[17:47:08.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.206]                 "immediateCondition"))) {
[17:47:08.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.206]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.206]                   if (TRUE && !signal) {
[17:47:08.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.206]                     {
[17:47:08.206]                       inherits <- base::inherits
[17:47:08.206]                       invokeRestart <- base::invokeRestart
[17:47:08.206]                       is.null <- base::is.null
[17:47:08.206]                       muffled <- FALSE
[17:47:08.206]                       if (inherits(cond, "message")) {
[17:47:08.206]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.206]                         if (muffled) 
[17:47:08.206]                           invokeRestart("muffleMessage")
[17:47:08.206]                       }
[17:47:08.206]                       else if (inherits(cond, "warning")) {
[17:47:08.206]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.206]                         if (muffled) 
[17:47:08.206]                           invokeRestart("muffleWarning")
[17:47:08.206]                       }
[17:47:08.206]                       else if (inherits(cond, "condition")) {
[17:47:08.206]                         if (!is.null(pattern)) {
[17:47:08.206]                           computeRestarts <- base::computeRestarts
[17:47:08.206]                           grepl <- base::grepl
[17:47:08.206]                           restarts <- computeRestarts(cond)
[17:47:08.206]                           for (restart in restarts) {
[17:47:08.206]                             name <- restart$name
[17:47:08.206]                             if (is.null(name)) 
[17:47:08.206]                               next
[17:47:08.206]                             if (!grepl(pattern, name)) 
[17:47:08.206]                               next
[17:47:08.206]                             invokeRestart(restart)
[17:47:08.206]                             muffled <- TRUE
[17:47:08.206]                             break
[17:47:08.206]                           }
[17:47:08.206]                         }
[17:47:08.206]                       }
[17:47:08.206]                       invisible(muffled)
[17:47:08.206]                     }
[17:47:08.206]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.206]                   }
[17:47:08.206]                 }
[17:47:08.206]                 else {
[17:47:08.206]                   if (TRUE) {
[17:47:08.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.206]                     {
[17:47:08.206]                       inherits <- base::inherits
[17:47:08.206]                       invokeRestart <- base::invokeRestart
[17:47:08.206]                       is.null <- base::is.null
[17:47:08.206]                       muffled <- FALSE
[17:47:08.206]                       if (inherits(cond, "message")) {
[17:47:08.206]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.206]                         if (muffled) 
[17:47:08.206]                           invokeRestart("muffleMessage")
[17:47:08.206]                       }
[17:47:08.206]                       else if (inherits(cond, "warning")) {
[17:47:08.206]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.206]                         if (muffled) 
[17:47:08.206]                           invokeRestart("muffleWarning")
[17:47:08.206]                       }
[17:47:08.206]                       else if (inherits(cond, "condition")) {
[17:47:08.206]                         if (!is.null(pattern)) {
[17:47:08.206]                           computeRestarts <- base::computeRestarts
[17:47:08.206]                           grepl <- base::grepl
[17:47:08.206]                           restarts <- computeRestarts(cond)
[17:47:08.206]                           for (restart in restarts) {
[17:47:08.206]                             name <- restart$name
[17:47:08.206]                             if (is.null(name)) 
[17:47:08.206]                               next
[17:47:08.206]                             if (!grepl(pattern, name)) 
[17:47:08.206]                               next
[17:47:08.206]                             invokeRestart(restart)
[17:47:08.206]                             muffled <- TRUE
[17:47:08.206]                             break
[17:47:08.206]                           }
[17:47:08.206]                         }
[17:47:08.206]                       }
[17:47:08.206]                       invisible(muffled)
[17:47:08.206]                     }
[17:47:08.206]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.206]                   }
[17:47:08.206]                 }
[17:47:08.206]             }
[17:47:08.206]         }))
[17:47:08.206]     }, error = function(ex) {
[17:47:08.206]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.206]                 ...future.rng), started = ...future.startTime, 
[17:47:08.206]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.206]             version = "1.8"), class = "FutureResult")
[17:47:08.206]     }, finally = {
[17:47:08.206]         if (!identical(...future.workdir, getwd())) 
[17:47:08.206]             setwd(...future.workdir)
[17:47:08.206]         {
[17:47:08.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.206]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.206]             }
[17:47:08.206]             base::options(...future.oldOptions)
[17:47:08.206]             if (.Platform$OS.type == "windows") {
[17:47:08.206]                 old_names <- names(...future.oldEnvVars)
[17:47:08.206]                 envs <- base::Sys.getenv()
[17:47:08.206]                 names <- names(envs)
[17:47:08.206]                 common <- intersect(names, old_names)
[17:47:08.206]                 added <- setdiff(names, old_names)
[17:47:08.206]                 removed <- setdiff(old_names, names)
[17:47:08.206]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.206]                   envs[common]]
[17:47:08.206]                 NAMES <- toupper(changed)
[17:47:08.206]                 args <- list()
[17:47:08.206]                 for (kk in seq_along(NAMES)) {
[17:47:08.206]                   name <- changed[[kk]]
[17:47:08.206]                   NAME <- NAMES[[kk]]
[17:47:08.206]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.206]                     next
[17:47:08.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.206]                 }
[17:47:08.206]                 NAMES <- toupper(added)
[17:47:08.206]                 for (kk in seq_along(NAMES)) {
[17:47:08.206]                   name <- added[[kk]]
[17:47:08.206]                   NAME <- NAMES[[kk]]
[17:47:08.206]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.206]                     next
[17:47:08.206]                   args[[name]] <- ""
[17:47:08.206]                 }
[17:47:08.206]                 NAMES <- toupper(removed)
[17:47:08.206]                 for (kk in seq_along(NAMES)) {
[17:47:08.206]                   name <- removed[[kk]]
[17:47:08.206]                   NAME <- NAMES[[kk]]
[17:47:08.206]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.206]                     next
[17:47:08.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.206]                 }
[17:47:08.206]                 if (length(args) > 0) 
[17:47:08.206]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.206]             }
[17:47:08.206]             else {
[17:47:08.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.206]             }
[17:47:08.206]             {
[17:47:08.206]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.206]                   0L) {
[17:47:08.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.206]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.206]                   base::options(opts)
[17:47:08.206]                 }
[17:47:08.206]                 {
[17:47:08.206]                   {
[17:47:08.206]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:08.206]                     NULL
[17:47:08.206]                   }
[17:47:08.206]                   options(future.plan = NULL)
[17:47:08.206]                   if (is.na(NA_character_)) 
[17:47:08.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.206]                     .init = FALSE)
[17:47:08.206]                 }
[17:47:08.206]             }
[17:47:08.206]         }
[17:47:08.206]     })
[17:47:08.206]     if (TRUE) {
[17:47:08.206]         base::sink(type = "output", split = FALSE)
[17:47:08.206]         if (TRUE) {
[17:47:08.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.206]         }
[17:47:08.206]         else {
[17:47:08.206]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.206]         }
[17:47:08.206]         base::close(...future.stdout)
[17:47:08.206]         ...future.stdout <- NULL
[17:47:08.206]     }
[17:47:08.206]     ...future.result$conditions <- ...future.conditions
[17:47:08.206]     ...future.result$finished <- base::Sys.time()
[17:47:08.206]     ...future.result
[17:47:08.206] }
[17:47:08.208] assign_globals() ...
[17:47:08.208] List of 1
[17:47:08.208]  $ x: num 1
[17:47:08.208]  - attr(*, "where")=List of 1
[17:47:08.208]   ..$ x:<environment: R_EmptyEnv> 
[17:47:08.208]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:08.208]  - attr(*, "resolved")= logi TRUE
[17:47:08.208]  - attr(*, "total_size")= num 56
[17:47:08.208]  - attr(*, "already-done")= logi TRUE
[17:47:08.211] - copied ‘x’ to environment
[17:47:08.211] assign_globals() ... done
[17:47:08.211] requestCore(): workers = 2
[17:47:08.213] MulticoreFuture started
[17:47:08.214] - Launch lazy future ... done
[17:47:08.214] run() for ‘MulticoreFuture’ ... done
[17:47:08.214] result() for MulticoreFuture ...
[17:47:08.214] plan(): Setting new future strategy stack:
[17:47:08.214] List of future strategies:
[17:47:08.214] 1. sequential:
[17:47:08.214]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:08.214]    - tweaked: FALSE
[17:47:08.214]    - call: NULL
[17:47:08.215] plan(): nbrOfWorkers() = 1
[17:47:08.218] plan(): Setting new future strategy stack:
[17:47:08.218] List of future strategies:
[17:47:08.218] 1. multicore:
[17:47:08.218]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:08.218]    - tweaked: FALSE
[17:47:08.218]    - call: plan(strategy)
[17:47:08.223] plan(): nbrOfWorkers() = 2
[17:47:08.224] result() for MulticoreFuture ...
[17:47:08.224] result() for MulticoreFuture ... done
[17:47:08.225] result() for MulticoreFuture ... done
[17:47:08.225] result() for MulticoreFuture ...
[17:47:08.225] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.225] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.226] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:08.228] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:47:08.228] Searching for globals ... DONE
[17:47:08.228] Resolving globals: TRUE
[17:47:08.228] Resolving any globals that are futures ...
[17:47:08.229] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:47:08.229] Resolving any globals that are futures ... DONE
[17:47:08.229] Resolving futures part of globals (recursively) ...
[17:47:08.229] resolve() on list ...
[17:47:08.230]  recursive: 99
[17:47:08.230]  length: 1
[17:47:08.230]  elements: ‘x’
[17:47:08.230]  length: 0 (resolved future 1)
[17:47:08.230] resolve() on list ... DONE
[17:47:08.230] - globals: [1] ‘x’
[17:47:08.230] Resolving futures part of globals (recursively) ... DONE
[17:47:08.231] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:47:08.231] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:47:08.231] - globals: [1] ‘x’
[17:47:08.231] 
[17:47:08.232] getGlobalsAndPackages() ... DONE
[17:47:08.232] run() for ‘Future’ ...
[17:47:08.232] - state: ‘created’
[17:47:08.232] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:08.236] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:08.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:08.237]   - Field: ‘label’
[17:47:08.237]   - Field: ‘local’
[17:47:08.237]   - Field: ‘owner’
[17:47:08.237]   - Field: ‘envir’
[17:47:08.237]   - Field: ‘workers’
[17:47:08.237]   - Field: ‘packages’
[17:47:08.237]   - Field: ‘gc’
[17:47:08.237]   - Field: ‘job’
[17:47:08.238]   - Field: ‘conditions’
[17:47:08.240]   - Field: ‘expr’
[17:47:08.240]   - Field: ‘uuid’
[17:47:08.240]   - Field: ‘seed’
[17:47:08.241]   - Field: ‘version’
[17:47:08.241]   - Field: ‘result’
[17:47:08.241]   - Field: ‘asynchronous’
[17:47:08.241]   - Field: ‘calls’
[17:47:08.241]   - Field: ‘globals’
[17:47:08.241]   - Field: ‘stdout’
[17:47:08.241]   - Field: ‘earlySignal’
[17:47:08.241]   - Field: ‘lazy’
[17:47:08.242]   - Field: ‘state’
[17:47:08.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:08.242] - Launch lazy future ...
[17:47:08.242] Packages needed by the future expression (n = 0): <none>
[17:47:08.242] Packages needed by future strategies (n = 0): <none>
[17:47:08.243] {
[17:47:08.243]     {
[17:47:08.243]         {
[17:47:08.243]             ...future.startTime <- base::Sys.time()
[17:47:08.243]             {
[17:47:08.243]                 {
[17:47:08.243]                   {
[17:47:08.243]                     {
[17:47:08.243]                       base::local({
[17:47:08.243]                         has_future <- base::requireNamespace("future", 
[17:47:08.243]                           quietly = TRUE)
[17:47:08.243]                         if (has_future) {
[17:47:08.243]                           ns <- base::getNamespace("future")
[17:47:08.243]                           version <- ns[[".package"]][["version"]]
[17:47:08.243]                           if (is.null(version)) 
[17:47:08.243]                             version <- utils::packageVersion("future")
[17:47:08.243]                         }
[17:47:08.243]                         else {
[17:47:08.243]                           version <- NULL
[17:47:08.243]                         }
[17:47:08.243]                         if (!has_future || version < "1.8.0") {
[17:47:08.243]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.243]                             "", base::R.version$version.string), 
[17:47:08.243]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:08.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:08.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.243]                               "release", "version")], collapse = " "), 
[17:47:08.243]                             hostname = base::Sys.info()[["nodename"]])
[17:47:08.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.243]                             info)
[17:47:08.243]                           info <- base::paste(info, collapse = "; ")
[17:47:08.243]                           if (!has_future) {
[17:47:08.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.243]                               info)
[17:47:08.243]                           }
[17:47:08.243]                           else {
[17:47:08.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.243]                               info, version)
[17:47:08.243]                           }
[17:47:08.243]                           base::stop(msg)
[17:47:08.243]                         }
[17:47:08.243]                       })
[17:47:08.243]                     }
[17:47:08.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:08.243]                     base::options(mc.cores = 1L)
[17:47:08.243]                   }
[17:47:08.243]                   ...future.strategy.old <- future::plan("list")
[17:47:08.243]                   options(future.plan = NULL)
[17:47:08.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.243]                 }
[17:47:08.243]                 ...future.workdir <- getwd()
[17:47:08.243]             }
[17:47:08.243]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.243]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.243]         }
[17:47:08.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.243]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:08.243]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.243]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.243]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.243]             base::names(...future.oldOptions))
[17:47:08.243]     }
[17:47:08.243]     if (FALSE) {
[17:47:08.243]     }
[17:47:08.243]     else {
[17:47:08.243]         if (TRUE) {
[17:47:08.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.243]                 open = "w")
[17:47:08.243]         }
[17:47:08.243]         else {
[17:47:08.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.243]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.243]         }
[17:47:08.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.243]             base::sink(type = "output", split = FALSE)
[17:47:08.243]             base::close(...future.stdout)
[17:47:08.243]         }, add = TRUE)
[17:47:08.243]     }
[17:47:08.243]     ...future.frame <- base::sys.nframe()
[17:47:08.243]     ...future.conditions <- base::list()
[17:47:08.243]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.243]     if (FALSE) {
[17:47:08.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.243]     }
[17:47:08.243]     ...future.result <- base::tryCatch({
[17:47:08.243]         base::withCallingHandlers({
[17:47:08.243]             ...future.value <- base::withVisible(base::local({
[17:47:08.243]                 withCallingHandlers({
[17:47:08.243]                   {
[17:47:08.243]                     x <- x()
[17:47:08.243]                     x
[17:47:08.243]                   }
[17:47:08.243]                 }, immediateCondition = function(cond) {
[17:47:08.243]                   save_rds <- function (object, pathname, ...) 
[17:47:08.243]                   {
[17:47:08.243]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:08.243]                     if (file_test("-f", pathname_tmp)) {
[17:47:08.243]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.243]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:08.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.243]                         fi_tmp[["mtime"]])
[17:47:08.243]                     }
[17:47:08.243]                     tryCatch({
[17:47:08.243]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:08.243]                     }, error = function(ex) {
[17:47:08.243]                       msg <- conditionMessage(ex)
[17:47:08.243]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.243]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:08.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.243]                         fi_tmp[["mtime"]], msg)
[17:47:08.243]                       ex$message <- msg
[17:47:08.243]                       stop(ex)
[17:47:08.243]                     })
[17:47:08.243]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:08.243]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:08.243]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:08.243]                       fi_tmp <- file.info(pathname_tmp)
[17:47:08.243]                       fi <- file.info(pathname)
[17:47:08.243]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:08.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:08.243]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:08.243]                         fi[["size"]], fi[["mtime"]])
[17:47:08.243]                       stop(msg)
[17:47:08.243]                     }
[17:47:08.243]                     invisible(pathname)
[17:47:08.243]                   }
[17:47:08.243]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:08.243]                     rootPath = tempdir()) 
[17:47:08.243]                   {
[17:47:08.243]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:08.243]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:08.243]                       tmpdir = path, fileext = ".rds")
[17:47:08.243]                     save_rds(obj, file)
[17:47:08.243]                   }
[17:47:08.243]                   saveImmediateCondition(cond, path = "/tmp/RtmpebkiEd/.future/immediateConditions")
[17:47:08.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.243]                   {
[17:47:08.243]                     inherits <- base::inherits
[17:47:08.243]                     invokeRestart <- base::invokeRestart
[17:47:08.243]                     is.null <- base::is.null
[17:47:08.243]                     muffled <- FALSE
[17:47:08.243]                     if (inherits(cond, "message")) {
[17:47:08.243]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:08.243]                       if (muffled) 
[17:47:08.243]                         invokeRestart("muffleMessage")
[17:47:08.243]                     }
[17:47:08.243]                     else if (inherits(cond, "warning")) {
[17:47:08.243]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:08.243]                       if (muffled) 
[17:47:08.243]                         invokeRestart("muffleWarning")
[17:47:08.243]                     }
[17:47:08.243]                     else if (inherits(cond, "condition")) {
[17:47:08.243]                       if (!is.null(pattern)) {
[17:47:08.243]                         computeRestarts <- base::computeRestarts
[17:47:08.243]                         grepl <- base::grepl
[17:47:08.243]                         restarts <- computeRestarts(cond)
[17:47:08.243]                         for (restart in restarts) {
[17:47:08.243]                           name <- restart$name
[17:47:08.243]                           if (is.null(name)) 
[17:47:08.243]                             next
[17:47:08.243]                           if (!grepl(pattern, name)) 
[17:47:08.243]                             next
[17:47:08.243]                           invokeRestart(restart)
[17:47:08.243]                           muffled <- TRUE
[17:47:08.243]                           break
[17:47:08.243]                         }
[17:47:08.243]                       }
[17:47:08.243]                     }
[17:47:08.243]                     invisible(muffled)
[17:47:08.243]                   }
[17:47:08.243]                   muffleCondition(cond)
[17:47:08.243]                 })
[17:47:08.243]             }))
[17:47:08.243]             future::FutureResult(value = ...future.value$value, 
[17:47:08.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.243]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.243]                     ...future.globalenv.names))
[17:47:08.243]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.243]         }, condition = base::local({
[17:47:08.243]             c <- base::c
[17:47:08.243]             inherits <- base::inherits
[17:47:08.243]             invokeRestart <- base::invokeRestart
[17:47:08.243]             length <- base::length
[17:47:08.243]             list <- base::list
[17:47:08.243]             seq.int <- base::seq.int
[17:47:08.243]             signalCondition <- base::signalCondition
[17:47:08.243]             sys.calls <- base::sys.calls
[17:47:08.243]             `[[` <- base::`[[`
[17:47:08.243]             `+` <- base::`+`
[17:47:08.243]             `<<-` <- base::`<<-`
[17:47:08.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.243]                   3L)]
[17:47:08.243]             }
[17:47:08.243]             function(cond) {
[17:47:08.243]                 is_error <- inherits(cond, "error")
[17:47:08.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.243]                   NULL)
[17:47:08.243]                 if (is_error) {
[17:47:08.243]                   sessionInformation <- function() {
[17:47:08.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.243]                       search = base::search(), system = base::Sys.info())
[17:47:08.243]                   }
[17:47:08.243]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.243]                     cond$call), session = sessionInformation(), 
[17:47:08.243]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.243]                   signalCondition(cond)
[17:47:08.243]                 }
[17:47:08.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.243]                 "immediateCondition"))) {
[17:47:08.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.243]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.243]                   if (TRUE && !signal) {
[17:47:08.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.243]                     {
[17:47:08.243]                       inherits <- base::inherits
[17:47:08.243]                       invokeRestart <- base::invokeRestart
[17:47:08.243]                       is.null <- base::is.null
[17:47:08.243]                       muffled <- FALSE
[17:47:08.243]                       if (inherits(cond, "message")) {
[17:47:08.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.243]                         if (muffled) 
[17:47:08.243]                           invokeRestart("muffleMessage")
[17:47:08.243]                       }
[17:47:08.243]                       else if (inherits(cond, "warning")) {
[17:47:08.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.243]                         if (muffled) 
[17:47:08.243]                           invokeRestart("muffleWarning")
[17:47:08.243]                       }
[17:47:08.243]                       else if (inherits(cond, "condition")) {
[17:47:08.243]                         if (!is.null(pattern)) {
[17:47:08.243]                           computeRestarts <- base::computeRestarts
[17:47:08.243]                           grepl <- base::grepl
[17:47:08.243]                           restarts <- computeRestarts(cond)
[17:47:08.243]                           for (restart in restarts) {
[17:47:08.243]                             name <- restart$name
[17:47:08.243]                             if (is.null(name)) 
[17:47:08.243]                               next
[17:47:08.243]                             if (!grepl(pattern, name)) 
[17:47:08.243]                               next
[17:47:08.243]                             invokeRestart(restart)
[17:47:08.243]                             muffled <- TRUE
[17:47:08.243]                             break
[17:47:08.243]                           }
[17:47:08.243]                         }
[17:47:08.243]                       }
[17:47:08.243]                       invisible(muffled)
[17:47:08.243]                     }
[17:47:08.243]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.243]                   }
[17:47:08.243]                 }
[17:47:08.243]                 else {
[17:47:08.243]                   if (TRUE) {
[17:47:08.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.243]                     {
[17:47:08.243]                       inherits <- base::inherits
[17:47:08.243]                       invokeRestart <- base::invokeRestart
[17:47:08.243]                       is.null <- base::is.null
[17:47:08.243]                       muffled <- FALSE
[17:47:08.243]                       if (inherits(cond, "message")) {
[17:47:08.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.243]                         if (muffled) 
[17:47:08.243]                           invokeRestart("muffleMessage")
[17:47:08.243]                       }
[17:47:08.243]                       else if (inherits(cond, "warning")) {
[17:47:08.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.243]                         if (muffled) 
[17:47:08.243]                           invokeRestart("muffleWarning")
[17:47:08.243]                       }
[17:47:08.243]                       else if (inherits(cond, "condition")) {
[17:47:08.243]                         if (!is.null(pattern)) {
[17:47:08.243]                           computeRestarts <- base::computeRestarts
[17:47:08.243]                           grepl <- base::grepl
[17:47:08.243]                           restarts <- computeRestarts(cond)
[17:47:08.243]                           for (restart in restarts) {
[17:47:08.243]                             name <- restart$name
[17:47:08.243]                             if (is.null(name)) 
[17:47:08.243]                               next
[17:47:08.243]                             if (!grepl(pattern, name)) 
[17:47:08.243]                               next
[17:47:08.243]                             invokeRestart(restart)
[17:47:08.243]                             muffled <- TRUE
[17:47:08.243]                             break
[17:47:08.243]                           }
[17:47:08.243]                         }
[17:47:08.243]                       }
[17:47:08.243]                       invisible(muffled)
[17:47:08.243]                     }
[17:47:08.243]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.243]                   }
[17:47:08.243]                 }
[17:47:08.243]             }
[17:47:08.243]         }))
[17:47:08.243]     }, error = function(ex) {
[17:47:08.243]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.243]                 ...future.rng), started = ...future.startTime, 
[17:47:08.243]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.243]             version = "1.8"), class = "FutureResult")
[17:47:08.243]     }, finally = {
[17:47:08.243]         if (!identical(...future.workdir, getwd())) 
[17:47:08.243]             setwd(...future.workdir)
[17:47:08.243]         {
[17:47:08.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.243]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.243]             }
[17:47:08.243]             base::options(...future.oldOptions)
[17:47:08.243]             if (.Platform$OS.type == "windows") {
[17:47:08.243]                 old_names <- names(...future.oldEnvVars)
[17:47:08.243]                 envs <- base::Sys.getenv()
[17:47:08.243]                 names <- names(envs)
[17:47:08.243]                 common <- intersect(names, old_names)
[17:47:08.243]                 added <- setdiff(names, old_names)
[17:47:08.243]                 removed <- setdiff(old_names, names)
[17:47:08.243]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.243]                   envs[common]]
[17:47:08.243]                 NAMES <- toupper(changed)
[17:47:08.243]                 args <- list()
[17:47:08.243]                 for (kk in seq_along(NAMES)) {
[17:47:08.243]                   name <- changed[[kk]]
[17:47:08.243]                   NAME <- NAMES[[kk]]
[17:47:08.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.243]                     next
[17:47:08.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.243]                 }
[17:47:08.243]                 NAMES <- toupper(added)
[17:47:08.243]                 for (kk in seq_along(NAMES)) {
[17:47:08.243]                   name <- added[[kk]]
[17:47:08.243]                   NAME <- NAMES[[kk]]
[17:47:08.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.243]                     next
[17:47:08.243]                   args[[name]] <- ""
[17:47:08.243]                 }
[17:47:08.243]                 NAMES <- toupper(removed)
[17:47:08.243]                 for (kk in seq_along(NAMES)) {
[17:47:08.243]                   name <- removed[[kk]]
[17:47:08.243]                   NAME <- NAMES[[kk]]
[17:47:08.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.243]                     next
[17:47:08.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.243]                 }
[17:47:08.243]                 if (length(args) > 0) 
[17:47:08.243]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.243]             }
[17:47:08.243]             else {
[17:47:08.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.243]             }
[17:47:08.243]             {
[17:47:08.243]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.243]                   0L) {
[17:47:08.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.243]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.243]                   base::options(opts)
[17:47:08.243]                 }
[17:47:08.243]                 {
[17:47:08.243]                   {
[17:47:08.243]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:08.243]                     NULL
[17:47:08.243]                   }
[17:47:08.243]                   options(future.plan = NULL)
[17:47:08.243]                   if (is.na(NA_character_)) 
[17:47:08.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.243]                     .init = FALSE)
[17:47:08.243]                 }
[17:47:08.243]             }
[17:47:08.243]         }
[17:47:08.243]     })
[17:47:08.243]     if (TRUE) {
[17:47:08.243]         base::sink(type = "output", split = FALSE)
[17:47:08.243]         if (TRUE) {
[17:47:08.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.243]         }
[17:47:08.243]         else {
[17:47:08.243]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.243]         }
[17:47:08.243]         base::close(...future.stdout)
[17:47:08.243]         ...future.stdout <- NULL
[17:47:08.243]     }
[17:47:08.243]     ...future.result$conditions <- ...future.conditions
[17:47:08.243]     ...future.result$finished <- base::Sys.time()
[17:47:08.243]     ...future.result
[17:47:08.243] }
[17:47:08.245] assign_globals() ...
[17:47:08.245] List of 1
[17:47:08.245]  $ x:function ()  
[17:47:08.245]  - attr(*, "where")=List of 1
[17:47:08.245]   ..$ x:<environment: R_EmptyEnv> 
[17:47:08.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:08.245]  - attr(*, "resolved")= logi TRUE
[17:47:08.245]  - attr(*, "total_size")= num 1032
[17:47:08.245]  - attr(*, "already-done")= logi TRUE
[17:47:08.249] - reassign environment for ‘x’
[17:47:08.249] - copied ‘x’ to environment
[17:47:08.249] assign_globals() ... done
[17:47:08.249] requestCore(): workers = 2
[17:47:08.251] MulticoreFuture started
[17:47:08.252] - Launch lazy future ... done
[17:47:08.253] run() for ‘MulticoreFuture’ ... done
[17:47:08.253] plan(): Setting new future strategy stack:
[17:47:08.253] result() for MulticoreFuture ...
[17:47:08.253] List of future strategies:
[17:47:08.253] 1. sequential:
[17:47:08.253]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:08.253]    - tweaked: FALSE
[17:47:08.253]    - call: NULL
[17:47:08.254] plan(): nbrOfWorkers() = 1
[17:47:08.257] plan(): Setting new future strategy stack:
[17:47:08.257] List of future strategies:
[17:47:08.257] 1. multicore:
[17:47:08.257]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:08.257]    - tweaked: FALSE
[17:47:08.257]    - call: plan(strategy)
[17:47:08.263] plan(): nbrOfWorkers() = 2
[17:47:08.264] result() for MulticoreFuture ...
[17:47:08.264] result() for MulticoreFuture ... done
[17:47:08.264] result() for MulticoreFuture ... done
[17:47:08.265] result() for MulticoreFuture ...
[17:47:08.265] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[17:47:08.266] plan(): Setting new future strategy stack:
[17:47:08.266] List of future strategies:
[17:47:08.266] 1. multisession:
[17:47:08.266]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:08.266]    - tweaked: FALSE
[17:47:08.266]    - call: plan(strategy)
[17:47:08.266] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:47:08.266] multisession:
[17:47:08.266] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:08.266] - tweaked: FALSE
[17:47:08.266] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.273] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.274] Not searching for globals
[17:47:08.274] - globals: [0] <none>
[17:47:08.274] getGlobalsAndPackages() ... DONE
[17:47:08.275] [local output] makeClusterPSOCK() ...
[17:47:08.321] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:47:08.322] [local output] Base port: 11394
[17:47:08.322] [local output] Getting setup options for 2 cluster nodes ...
[17:47:08.322] [local output]  - Node 1 of 2 ...
[17:47:08.323] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:08.324] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpebkiEd/worker.rank=1.parallelly.parent=44744.aec824e3b347.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpebkiEd/worker.rank=1.parallelly.parent=44744.aec824e3b347.pid")'’
[17:47:08.511] - Possible to infer worker's PID: TRUE
[17:47:08.511] [local output] Rscript port: 11394

[17:47:08.512] [local output]  - Node 2 of 2 ...
[17:47:08.512] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:08.513] [local output] Rscript port: 11394

[17:47:08.513] [local output] Getting setup options for 2 cluster nodes ... done
[17:47:08.513] [local output]  - Parallel setup requested for some PSOCK nodes
[17:47:08.513] [local output] Setting up PSOCK nodes in parallel
[17:47:08.514] List of 36
[17:47:08.514]  $ worker          : chr "localhost"
[17:47:08.514]   ..- attr(*, "localhost")= logi TRUE
[17:47:08.514]  $ master          : chr "localhost"
[17:47:08.514]  $ port            : int 11394
[17:47:08.514]  $ connectTimeout  : num 120
[17:47:08.514]  $ timeout         : num 2592000
[17:47:08.514]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:47:08.514]  $ homogeneous     : logi TRUE
[17:47:08.514]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:47:08.514]  $ rscript_envs    : NULL
[17:47:08.514]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:08.514]  $ rscript_startup : NULL
[17:47:08.514]  $ rscript_sh      : chr "sh"
[17:47:08.514]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:08.514]  $ methods         : logi TRUE
[17:47:08.514]  $ socketOptions   : chr "no-delay"
[17:47:08.514]  $ useXDR          : logi FALSE
[17:47:08.514]  $ outfile         : chr "/dev/null"
[17:47:08.514]  $ renice          : int NA
[17:47:08.514]  $ rshcmd          : NULL
[17:47:08.514]  $ user            : chr(0) 
[17:47:08.514]  $ revtunnel       : logi FALSE
[17:47:08.514]  $ rshlogfile      : NULL
[17:47:08.514]  $ rshopts         : chr(0) 
[17:47:08.514]  $ rank            : int 1
[17:47:08.514]  $ manual          : logi FALSE
[17:47:08.514]  $ dryrun          : logi FALSE
[17:47:08.514]  $ quiet           : logi FALSE
[17:47:08.514]  $ setup_strategy  : chr "parallel"
[17:47:08.514]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:08.514]  $ pidfile         : chr "/tmp/RtmpebkiEd/worker.rank=1.parallelly.parent=44744.aec824e3b347.pid"
[17:47:08.514]  $ rshcmd_label    : NULL
[17:47:08.514]  $ rsh_call        : NULL
[17:47:08.514]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:08.514]  $ localMachine    : logi TRUE
[17:47:08.514]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:47:08.514]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:47:08.514]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:47:08.514]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:47:08.514]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:47:08.514]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:47:08.514]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:47:08.514]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:47:08.514]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:47:08.514]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:47:08.514]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:47:08.514]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:47:08.514]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:47:08.514]  $ arguments       :List of 28
[17:47:08.514]   ..$ worker          : chr "localhost"
[17:47:08.514]   ..$ master          : NULL
[17:47:08.514]   ..$ port            : int 11394
[17:47:08.514]   ..$ connectTimeout  : num 120
[17:47:08.514]   ..$ timeout         : num 2592000
[17:47:08.514]   ..$ rscript         : NULL
[17:47:08.514]   ..$ homogeneous     : NULL
[17:47:08.514]   ..$ rscript_args    : NULL
[17:47:08.514]   ..$ rscript_envs    : NULL
[17:47:08.514]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:08.514]   ..$ rscript_startup : NULL
[17:47:08.514]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:47:08.514]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:08.514]   ..$ methods         : logi TRUE
[17:47:08.514]   ..$ socketOptions   : chr "no-delay"
[17:47:08.514]   ..$ useXDR          : logi FALSE
[17:47:08.514]   ..$ outfile         : chr "/dev/null"
[17:47:08.514]   ..$ renice          : int NA
[17:47:08.514]   ..$ rshcmd          : NULL
[17:47:08.514]   ..$ user            : NULL
[17:47:08.514]   ..$ revtunnel       : logi NA
[17:47:08.514]   ..$ rshlogfile      : NULL
[17:47:08.514]   ..$ rshopts         : NULL
[17:47:08.514]   ..$ rank            : int 1
[17:47:08.514]   ..$ manual          : logi FALSE
[17:47:08.514]   ..$ dryrun          : logi FALSE
[17:47:08.514]   ..$ quiet           : logi FALSE
[17:47:08.514]   ..$ setup_strategy  : chr "parallel"
[17:47:08.514]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:47:08.530] [local output] System call to launch all workers:
[17:47:08.530] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpebkiEd/worker.rank=1.parallelly.parent=44744.aec824e3b347.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11394 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:47:08.530] [local output] Starting PSOCK main server
[17:47:08.536] [local output] Workers launched
[17:47:08.536] [local output] Waiting for workers to connect back
[17:47:08.537]  - [local output] 0 workers out of 2 ready
[17:47:08.785]  - [local output] 0 workers out of 2 ready
[17:47:08.786]  - [local output] 1 workers out of 2 ready
[17:47:08.789]  - [local output] 1 workers out of 2 ready
[17:47:08.789]  - [local output] 2 workers out of 2 ready
[17:47:08.789] [local output] Launching of workers completed
[17:47:08.789] [local output] Collecting session information from workers
[17:47:08.790] [local output]  - Worker #1 of 2
[17:47:08.791] [local output]  - Worker #2 of 2
[17:47:08.791] [local output] makeClusterPSOCK() ... done
[17:47:08.802] Packages needed by the future expression (n = 0): <none>
[17:47:08.802] Packages needed by future strategies (n = 0): <none>
[17:47:08.802] {
[17:47:08.802]     {
[17:47:08.802]         {
[17:47:08.802]             ...future.startTime <- base::Sys.time()
[17:47:08.802]             {
[17:47:08.802]                 {
[17:47:08.802]                   {
[17:47:08.802]                     {
[17:47:08.802]                       base::local({
[17:47:08.802]                         has_future <- base::requireNamespace("future", 
[17:47:08.802]                           quietly = TRUE)
[17:47:08.802]                         if (has_future) {
[17:47:08.802]                           ns <- base::getNamespace("future")
[17:47:08.802]                           version <- ns[[".package"]][["version"]]
[17:47:08.802]                           if (is.null(version)) 
[17:47:08.802]                             version <- utils::packageVersion("future")
[17:47:08.802]                         }
[17:47:08.802]                         else {
[17:47:08.802]                           version <- NULL
[17:47:08.802]                         }
[17:47:08.802]                         if (!has_future || version < "1.8.0") {
[17:47:08.802]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.802]                             "", base::R.version$version.string), 
[17:47:08.802]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:08.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:08.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.802]                               "release", "version")], collapse = " "), 
[17:47:08.802]                             hostname = base::Sys.info()[["nodename"]])
[17:47:08.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.802]                             info)
[17:47:08.802]                           info <- base::paste(info, collapse = "; ")
[17:47:08.802]                           if (!has_future) {
[17:47:08.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.802]                               info)
[17:47:08.802]                           }
[17:47:08.802]                           else {
[17:47:08.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.802]                               info, version)
[17:47:08.802]                           }
[17:47:08.802]                           base::stop(msg)
[17:47:08.802]                         }
[17:47:08.802]                       })
[17:47:08.802]                     }
[17:47:08.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:08.802]                     base::options(mc.cores = 1L)
[17:47:08.802]                   }
[17:47:08.802]                   ...future.strategy.old <- future::plan("list")
[17:47:08.802]                   options(future.plan = NULL)
[17:47:08.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.802]                 }
[17:47:08.802]                 ...future.workdir <- getwd()
[17:47:08.802]             }
[17:47:08.802]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.802]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.802]         }
[17:47:08.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.802]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:08.802]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.802]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.802]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.802]             base::names(...future.oldOptions))
[17:47:08.802]     }
[17:47:08.802]     if (FALSE) {
[17:47:08.802]     }
[17:47:08.802]     else {
[17:47:08.802]         if (TRUE) {
[17:47:08.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.802]                 open = "w")
[17:47:08.802]         }
[17:47:08.802]         else {
[17:47:08.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.802]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.802]         }
[17:47:08.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.802]             base::sink(type = "output", split = FALSE)
[17:47:08.802]             base::close(...future.stdout)
[17:47:08.802]         }, add = TRUE)
[17:47:08.802]     }
[17:47:08.802]     ...future.frame <- base::sys.nframe()
[17:47:08.802]     ...future.conditions <- base::list()
[17:47:08.802]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.802]     if (FALSE) {
[17:47:08.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.802]     }
[17:47:08.802]     ...future.result <- base::tryCatch({
[17:47:08.802]         base::withCallingHandlers({
[17:47:08.802]             ...future.value <- base::withVisible(base::local({
[17:47:08.802]                 ...future.makeSendCondition <- base::local({
[17:47:08.802]                   sendCondition <- NULL
[17:47:08.802]                   function(frame = 1L) {
[17:47:08.802]                     if (is.function(sendCondition)) 
[17:47:08.802]                       return(sendCondition)
[17:47:08.802]                     ns <- getNamespace("parallel")
[17:47:08.802]                     if (exists("sendData", mode = "function", 
[17:47:08.802]                       envir = ns)) {
[17:47:08.802]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:08.802]                         envir = ns)
[17:47:08.802]                       envir <- sys.frame(frame)
[17:47:08.802]                       master <- NULL
[17:47:08.802]                       while (!identical(envir, .GlobalEnv) && 
[17:47:08.802]                         !identical(envir, emptyenv())) {
[17:47:08.802]                         if (exists("master", mode = "list", envir = envir, 
[17:47:08.802]                           inherits = FALSE)) {
[17:47:08.802]                           master <- get("master", mode = "list", 
[17:47:08.802]                             envir = envir, inherits = FALSE)
[17:47:08.802]                           if (inherits(master, c("SOCKnode", 
[17:47:08.802]                             "SOCK0node"))) {
[17:47:08.802]                             sendCondition <<- function(cond) {
[17:47:08.802]                               data <- list(type = "VALUE", value = cond, 
[17:47:08.802]                                 success = TRUE)
[17:47:08.802]                               parallel_sendData(master, data)
[17:47:08.802]                             }
[17:47:08.802]                             return(sendCondition)
[17:47:08.802]                           }
[17:47:08.802]                         }
[17:47:08.802]                         frame <- frame + 1L
[17:47:08.802]                         envir <- sys.frame(frame)
[17:47:08.802]                       }
[17:47:08.802]                     }
[17:47:08.802]                     sendCondition <<- function(cond) NULL
[17:47:08.802]                   }
[17:47:08.802]                 })
[17:47:08.802]                 withCallingHandlers({
[17:47:08.802]                   NA
[17:47:08.802]                 }, immediateCondition = function(cond) {
[17:47:08.802]                   sendCondition <- ...future.makeSendCondition()
[17:47:08.802]                   sendCondition(cond)
[17:47:08.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.802]                   {
[17:47:08.802]                     inherits <- base::inherits
[17:47:08.802]                     invokeRestart <- base::invokeRestart
[17:47:08.802]                     is.null <- base::is.null
[17:47:08.802]                     muffled <- FALSE
[17:47:08.802]                     if (inherits(cond, "message")) {
[17:47:08.802]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:08.802]                       if (muffled) 
[17:47:08.802]                         invokeRestart("muffleMessage")
[17:47:08.802]                     }
[17:47:08.802]                     else if (inherits(cond, "warning")) {
[17:47:08.802]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:08.802]                       if (muffled) 
[17:47:08.802]                         invokeRestart("muffleWarning")
[17:47:08.802]                     }
[17:47:08.802]                     else if (inherits(cond, "condition")) {
[17:47:08.802]                       if (!is.null(pattern)) {
[17:47:08.802]                         computeRestarts <- base::computeRestarts
[17:47:08.802]                         grepl <- base::grepl
[17:47:08.802]                         restarts <- computeRestarts(cond)
[17:47:08.802]                         for (restart in restarts) {
[17:47:08.802]                           name <- restart$name
[17:47:08.802]                           if (is.null(name)) 
[17:47:08.802]                             next
[17:47:08.802]                           if (!grepl(pattern, name)) 
[17:47:08.802]                             next
[17:47:08.802]                           invokeRestart(restart)
[17:47:08.802]                           muffled <- TRUE
[17:47:08.802]                           break
[17:47:08.802]                         }
[17:47:08.802]                       }
[17:47:08.802]                     }
[17:47:08.802]                     invisible(muffled)
[17:47:08.802]                   }
[17:47:08.802]                   muffleCondition(cond)
[17:47:08.802]                 })
[17:47:08.802]             }))
[17:47:08.802]             future::FutureResult(value = ...future.value$value, 
[17:47:08.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.802]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.802]                     ...future.globalenv.names))
[17:47:08.802]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.802]         }, condition = base::local({
[17:47:08.802]             c <- base::c
[17:47:08.802]             inherits <- base::inherits
[17:47:08.802]             invokeRestart <- base::invokeRestart
[17:47:08.802]             length <- base::length
[17:47:08.802]             list <- base::list
[17:47:08.802]             seq.int <- base::seq.int
[17:47:08.802]             signalCondition <- base::signalCondition
[17:47:08.802]             sys.calls <- base::sys.calls
[17:47:08.802]             `[[` <- base::`[[`
[17:47:08.802]             `+` <- base::`+`
[17:47:08.802]             `<<-` <- base::`<<-`
[17:47:08.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.802]                   3L)]
[17:47:08.802]             }
[17:47:08.802]             function(cond) {
[17:47:08.802]                 is_error <- inherits(cond, "error")
[17:47:08.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.802]                   NULL)
[17:47:08.802]                 if (is_error) {
[17:47:08.802]                   sessionInformation <- function() {
[17:47:08.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.802]                       search = base::search(), system = base::Sys.info())
[17:47:08.802]                   }
[17:47:08.802]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.802]                     cond$call), session = sessionInformation(), 
[17:47:08.802]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.802]                   signalCondition(cond)
[17:47:08.802]                 }
[17:47:08.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.802]                 "immediateCondition"))) {
[17:47:08.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.802]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.802]                   if (TRUE && !signal) {
[17:47:08.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.802]                     {
[17:47:08.802]                       inherits <- base::inherits
[17:47:08.802]                       invokeRestart <- base::invokeRestart
[17:47:08.802]                       is.null <- base::is.null
[17:47:08.802]                       muffled <- FALSE
[17:47:08.802]                       if (inherits(cond, "message")) {
[17:47:08.802]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.802]                         if (muffled) 
[17:47:08.802]                           invokeRestart("muffleMessage")
[17:47:08.802]                       }
[17:47:08.802]                       else if (inherits(cond, "warning")) {
[17:47:08.802]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.802]                         if (muffled) 
[17:47:08.802]                           invokeRestart("muffleWarning")
[17:47:08.802]                       }
[17:47:08.802]                       else if (inherits(cond, "condition")) {
[17:47:08.802]                         if (!is.null(pattern)) {
[17:47:08.802]                           computeRestarts <- base::computeRestarts
[17:47:08.802]                           grepl <- base::grepl
[17:47:08.802]                           restarts <- computeRestarts(cond)
[17:47:08.802]                           for (restart in restarts) {
[17:47:08.802]                             name <- restart$name
[17:47:08.802]                             if (is.null(name)) 
[17:47:08.802]                               next
[17:47:08.802]                             if (!grepl(pattern, name)) 
[17:47:08.802]                               next
[17:47:08.802]                             invokeRestart(restart)
[17:47:08.802]                             muffled <- TRUE
[17:47:08.802]                             break
[17:47:08.802]                           }
[17:47:08.802]                         }
[17:47:08.802]                       }
[17:47:08.802]                       invisible(muffled)
[17:47:08.802]                     }
[17:47:08.802]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.802]                   }
[17:47:08.802]                 }
[17:47:08.802]                 else {
[17:47:08.802]                   if (TRUE) {
[17:47:08.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.802]                     {
[17:47:08.802]                       inherits <- base::inherits
[17:47:08.802]                       invokeRestart <- base::invokeRestart
[17:47:08.802]                       is.null <- base::is.null
[17:47:08.802]                       muffled <- FALSE
[17:47:08.802]                       if (inherits(cond, "message")) {
[17:47:08.802]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.802]                         if (muffled) 
[17:47:08.802]                           invokeRestart("muffleMessage")
[17:47:08.802]                       }
[17:47:08.802]                       else if (inherits(cond, "warning")) {
[17:47:08.802]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.802]                         if (muffled) 
[17:47:08.802]                           invokeRestart("muffleWarning")
[17:47:08.802]                       }
[17:47:08.802]                       else if (inherits(cond, "condition")) {
[17:47:08.802]                         if (!is.null(pattern)) {
[17:47:08.802]                           computeRestarts <- base::computeRestarts
[17:47:08.802]                           grepl <- base::grepl
[17:47:08.802]                           restarts <- computeRestarts(cond)
[17:47:08.802]                           for (restart in restarts) {
[17:47:08.802]                             name <- restart$name
[17:47:08.802]                             if (is.null(name)) 
[17:47:08.802]                               next
[17:47:08.802]                             if (!grepl(pattern, name)) 
[17:47:08.802]                               next
[17:47:08.802]                             invokeRestart(restart)
[17:47:08.802]                             muffled <- TRUE
[17:47:08.802]                             break
[17:47:08.802]                           }
[17:47:08.802]                         }
[17:47:08.802]                       }
[17:47:08.802]                       invisible(muffled)
[17:47:08.802]                     }
[17:47:08.802]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.802]                   }
[17:47:08.802]                 }
[17:47:08.802]             }
[17:47:08.802]         }))
[17:47:08.802]     }, error = function(ex) {
[17:47:08.802]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.802]                 ...future.rng), started = ...future.startTime, 
[17:47:08.802]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.802]             version = "1.8"), class = "FutureResult")
[17:47:08.802]     }, finally = {
[17:47:08.802]         if (!identical(...future.workdir, getwd())) 
[17:47:08.802]             setwd(...future.workdir)
[17:47:08.802]         {
[17:47:08.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.802]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.802]             }
[17:47:08.802]             base::options(...future.oldOptions)
[17:47:08.802]             if (.Platform$OS.type == "windows") {
[17:47:08.802]                 old_names <- names(...future.oldEnvVars)
[17:47:08.802]                 envs <- base::Sys.getenv()
[17:47:08.802]                 names <- names(envs)
[17:47:08.802]                 common <- intersect(names, old_names)
[17:47:08.802]                 added <- setdiff(names, old_names)
[17:47:08.802]                 removed <- setdiff(old_names, names)
[17:47:08.802]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.802]                   envs[common]]
[17:47:08.802]                 NAMES <- toupper(changed)
[17:47:08.802]                 args <- list()
[17:47:08.802]                 for (kk in seq_along(NAMES)) {
[17:47:08.802]                   name <- changed[[kk]]
[17:47:08.802]                   NAME <- NAMES[[kk]]
[17:47:08.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.802]                     next
[17:47:08.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.802]                 }
[17:47:08.802]                 NAMES <- toupper(added)
[17:47:08.802]                 for (kk in seq_along(NAMES)) {
[17:47:08.802]                   name <- added[[kk]]
[17:47:08.802]                   NAME <- NAMES[[kk]]
[17:47:08.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.802]                     next
[17:47:08.802]                   args[[name]] <- ""
[17:47:08.802]                 }
[17:47:08.802]                 NAMES <- toupper(removed)
[17:47:08.802]                 for (kk in seq_along(NAMES)) {
[17:47:08.802]                   name <- removed[[kk]]
[17:47:08.802]                   NAME <- NAMES[[kk]]
[17:47:08.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.802]                     next
[17:47:08.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.802]                 }
[17:47:08.802]                 if (length(args) > 0) 
[17:47:08.802]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.802]             }
[17:47:08.802]             else {
[17:47:08.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.802]             }
[17:47:08.802]             {
[17:47:08.802]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.802]                   0L) {
[17:47:08.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.802]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.802]                   base::options(opts)
[17:47:08.802]                 }
[17:47:08.802]                 {
[17:47:08.802]                   {
[17:47:08.802]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:08.802]                     NULL
[17:47:08.802]                   }
[17:47:08.802]                   options(future.plan = NULL)
[17:47:08.802]                   if (is.na(NA_character_)) 
[17:47:08.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.802]                     .init = FALSE)
[17:47:08.802]                 }
[17:47:08.802]             }
[17:47:08.802]         }
[17:47:08.802]     })
[17:47:08.802]     if (TRUE) {
[17:47:08.802]         base::sink(type = "output", split = FALSE)
[17:47:08.802]         if (TRUE) {
[17:47:08.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.802]         }
[17:47:08.802]         else {
[17:47:08.802]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.802]         }
[17:47:08.802]         base::close(...future.stdout)
[17:47:08.802]         ...future.stdout <- NULL
[17:47:08.802]     }
[17:47:08.802]     ...future.result$conditions <- ...future.conditions
[17:47:08.802]     ...future.result$finished <- base::Sys.time()
[17:47:08.802]     ...future.result
[17:47:08.802] }
[17:47:08.854] MultisessionFuture started
[17:47:08.854] result() for ClusterFuture ...
[17:47:08.855] receiveMessageFromWorker() for ClusterFuture ...
[17:47:08.855] - Validating connection of MultisessionFuture
[17:47:08.886] - received message: FutureResult
[17:47:08.886] - Received FutureResult
[17:47:08.886] - Erased future from FutureRegistry
[17:47:08.887] result() for ClusterFuture ...
[17:47:08.887] - result already collected: FutureResult
[17:47:08.887] result() for ClusterFuture ... done
[17:47:08.887] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:08.887] result() for ClusterFuture ... done
[17:47:08.887] result() for ClusterFuture ...
[17:47:08.887] - result already collected: FutureResult
[17:47:08.887] result() for ClusterFuture ... done
[17:47:08.888] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:47:08.891] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.892] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.892] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:08.894] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:47:08.894] Searching for globals ... DONE
[17:47:08.894] Resolving globals: TRUE
[17:47:08.894] Resolving any globals that are futures ...
[17:47:08.895] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:47:08.895] Resolving any globals that are futures ... DONE
[17:47:08.895] 
[17:47:08.895] 
[17:47:08.895] getGlobalsAndPackages() ... DONE
[17:47:08.896] run() for ‘Future’ ...
[17:47:08.896] - state: ‘created’
[17:47:08.896] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:08.910] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:08.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:08.910]   - Field: ‘node’
[17:47:08.910]   - Field: ‘label’
[17:47:08.910]   - Field: ‘local’
[17:47:08.910]   - Field: ‘owner’
[17:47:08.911]   - Field: ‘envir’
[17:47:08.911]   - Field: ‘workers’
[17:47:08.911]   - Field: ‘packages’
[17:47:08.911]   - Field: ‘gc’
[17:47:08.911]   - Field: ‘conditions’
[17:47:08.911]   - Field: ‘persistent’
[17:47:08.911]   - Field: ‘expr’
[17:47:08.911]   - Field: ‘uuid’
[17:47:08.911]   - Field: ‘seed’
[17:47:08.912]   - Field: ‘version’
[17:47:08.912]   - Field: ‘result’
[17:47:08.912]   - Field: ‘asynchronous’
[17:47:08.912]   - Field: ‘calls’
[17:47:08.912]   - Field: ‘globals’
[17:47:08.912]   - Field: ‘stdout’
[17:47:08.912]   - Field: ‘earlySignal’
[17:47:08.912]   - Field: ‘lazy’
[17:47:08.912]   - Field: ‘state’
[17:47:08.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:08.913] - Launch lazy future ...
[17:47:08.913] Packages needed by the future expression (n = 0): <none>
[17:47:08.913] Packages needed by future strategies (n = 0): <none>
[17:47:08.914] {
[17:47:08.914]     {
[17:47:08.914]         {
[17:47:08.914]             ...future.startTime <- base::Sys.time()
[17:47:08.914]             {
[17:47:08.914]                 {
[17:47:08.914]                   {
[17:47:08.914]                     {
[17:47:08.914]                       base::local({
[17:47:08.914]                         has_future <- base::requireNamespace("future", 
[17:47:08.914]                           quietly = TRUE)
[17:47:08.914]                         if (has_future) {
[17:47:08.914]                           ns <- base::getNamespace("future")
[17:47:08.914]                           version <- ns[[".package"]][["version"]]
[17:47:08.914]                           if (is.null(version)) 
[17:47:08.914]                             version <- utils::packageVersion("future")
[17:47:08.914]                         }
[17:47:08.914]                         else {
[17:47:08.914]                           version <- NULL
[17:47:08.914]                         }
[17:47:08.914]                         if (!has_future || version < "1.8.0") {
[17:47:08.914]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.914]                             "", base::R.version$version.string), 
[17:47:08.914]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:08.914]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:08.914]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.914]                               "release", "version")], collapse = " "), 
[17:47:08.914]                             hostname = base::Sys.info()[["nodename"]])
[17:47:08.914]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.914]                             info)
[17:47:08.914]                           info <- base::paste(info, collapse = "; ")
[17:47:08.914]                           if (!has_future) {
[17:47:08.914]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.914]                               info)
[17:47:08.914]                           }
[17:47:08.914]                           else {
[17:47:08.914]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.914]                               info, version)
[17:47:08.914]                           }
[17:47:08.914]                           base::stop(msg)
[17:47:08.914]                         }
[17:47:08.914]                       })
[17:47:08.914]                     }
[17:47:08.914]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:08.914]                     base::options(mc.cores = 1L)
[17:47:08.914]                   }
[17:47:08.914]                   ...future.strategy.old <- future::plan("list")
[17:47:08.914]                   options(future.plan = NULL)
[17:47:08.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.914]                 }
[17:47:08.914]                 ...future.workdir <- getwd()
[17:47:08.914]             }
[17:47:08.914]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.914]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.914]         }
[17:47:08.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.914]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:08.914]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.914]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.914]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.914]             base::names(...future.oldOptions))
[17:47:08.914]     }
[17:47:08.914]     if (FALSE) {
[17:47:08.914]     }
[17:47:08.914]     else {
[17:47:08.914]         if (TRUE) {
[17:47:08.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.914]                 open = "w")
[17:47:08.914]         }
[17:47:08.914]         else {
[17:47:08.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.914]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.914]         }
[17:47:08.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.914]             base::sink(type = "output", split = FALSE)
[17:47:08.914]             base::close(...future.stdout)
[17:47:08.914]         }, add = TRUE)
[17:47:08.914]     }
[17:47:08.914]     ...future.frame <- base::sys.nframe()
[17:47:08.914]     ...future.conditions <- base::list()
[17:47:08.914]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.914]     if (FALSE) {
[17:47:08.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.914]     }
[17:47:08.914]     ...future.result <- base::tryCatch({
[17:47:08.914]         base::withCallingHandlers({
[17:47:08.914]             ...future.value <- base::withVisible(base::local({
[17:47:08.914]                 ...future.makeSendCondition <- base::local({
[17:47:08.914]                   sendCondition <- NULL
[17:47:08.914]                   function(frame = 1L) {
[17:47:08.914]                     if (is.function(sendCondition)) 
[17:47:08.914]                       return(sendCondition)
[17:47:08.914]                     ns <- getNamespace("parallel")
[17:47:08.914]                     if (exists("sendData", mode = "function", 
[17:47:08.914]                       envir = ns)) {
[17:47:08.914]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:08.914]                         envir = ns)
[17:47:08.914]                       envir <- sys.frame(frame)
[17:47:08.914]                       master <- NULL
[17:47:08.914]                       while (!identical(envir, .GlobalEnv) && 
[17:47:08.914]                         !identical(envir, emptyenv())) {
[17:47:08.914]                         if (exists("master", mode = "list", envir = envir, 
[17:47:08.914]                           inherits = FALSE)) {
[17:47:08.914]                           master <- get("master", mode = "list", 
[17:47:08.914]                             envir = envir, inherits = FALSE)
[17:47:08.914]                           if (inherits(master, c("SOCKnode", 
[17:47:08.914]                             "SOCK0node"))) {
[17:47:08.914]                             sendCondition <<- function(cond) {
[17:47:08.914]                               data <- list(type = "VALUE", value = cond, 
[17:47:08.914]                                 success = TRUE)
[17:47:08.914]                               parallel_sendData(master, data)
[17:47:08.914]                             }
[17:47:08.914]                             return(sendCondition)
[17:47:08.914]                           }
[17:47:08.914]                         }
[17:47:08.914]                         frame <- frame + 1L
[17:47:08.914]                         envir <- sys.frame(frame)
[17:47:08.914]                       }
[17:47:08.914]                     }
[17:47:08.914]                     sendCondition <<- function(cond) NULL
[17:47:08.914]                   }
[17:47:08.914]                 })
[17:47:08.914]                 withCallingHandlers({
[17:47:08.914]                   {
[17:47:08.914]                     b <- a
[17:47:08.914]                     a <- 2
[17:47:08.914]                     a * b
[17:47:08.914]                   }
[17:47:08.914]                 }, immediateCondition = function(cond) {
[17:47:08.914]                   sendCondition <- ...future.makeSendCondition()
[17:47:08.914]                   sendCondition(cond)
[17:47:08.914]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.914]                   {
[17:47:08.914]                     inherits <- base::inherits
[17:47:08.914]                     invokeRestart <- base::invokeRestart
[17:47:08.914]                     is.null <- base::is.null
[17:47:08.914]                     muffled <- FALSE
[17:47:08.914]                     if (inherits(cond, "message")) {
[17:47:08.914]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:08.914]                       if (muffled) 
[17:47:08.914]                         invokeRestart("muffleMessage")
[17:47:08.914]                     }
[17:47:08.914]                     else if (inherits(cond, "warning")) {
[17:47:08.914]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:08.914]                       if (muffled) 
[17:47:08.914]                         invokeRestart("muffleWarning")
[17:47:08.914]                     }
[17:47:08.914]                     else if (inherits(cond, "condition")) {
[17:47:08.914]                       if (!is.null(pattern)) {
[17:47:08.914]                         computeRestarts <- base::computeRestarts
[17:47:08.914]                         grepl <- base::grepl
[17:47:08.914]                         restarts <- computeRestarts(cond)
[17:47:08.914]                         for (restart in restarts) {
[17:47:08.914]                           name <- restart$name
[17:47:08.914]                           if (is.null(name)) 
[17:47:08.914]                             next
[17:47:08.914]                           if (!grepl(pattern, name)) 
[17:47:08.914]                             next
[17:47:08.914]                           invokeRestart(restart)
[17:47:08.914]                           muffled <- TRUE
[17:47:08.914]                           break
[17:47:08.914]                         }
[17:47:08.914]                       }
[17:47:08.914]                     }
[17:47:08.914]                     invisible(muffled)
[17:47:08.914]                   }
[17:47:08.914]                   muffleCondition(cond)
[17:47:08.914]                 })
[17:47:08.914]             }))
[17:47:08.914]             future::FutureResult(value = ...future.value$value, 
[17:47:08.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.914]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.914]                     ...future.globalenv.names))
[17:47:08.914]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.914]         }, condition = base::local({
[17:47:08.914]             c <- base::c
[17:47:08.914]             inherits <- base::inherits
[17:47:08.914]             invokeRestart <- base::invokeRestart
[17:47:08.914]             length <- base::length
[17:47:08.914]             list <- base::list
[17:47:08.914]             seq.int <- base::seq.int
[17:47:08.914]             signalCondition <- base::signalCondition
[17:47:08.914]             sys.calls <- base::sys.calls
[17:47:08.914]             `[[` <- base::`[[`
[17:47:08.914]             `+` <- base::`+`
[17:47:08.914]             `<<-` <- base::`<<-`
[17:47:08.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.914]                   3L)]
[17:47:08.914]             }
[17:47:08.914]             function(cond) {
[17:47:08.914]                 is_error <- inherits(cond, "error")
[17:47:08.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.914]                   NULL)
[17:47:08.914]                 if (is_error) {
[17:47:08.914]                   sessionInformation <- function() {
[17:47:08.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.914]                       search = base::search(), system = base::Sys.info())
[17:47:08.914]                   }
[17:47:08.914]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.914]                     cond$call), session = sessionInformation(), 
[17:47:08.914]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.914]                   signalCondition(cond)
[17:47:08.914]                 }
[17:47:08.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.914]                 "immediateCondition"))) {
[17:47:08.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.914]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.914]                   if (TRUE && !signal) {
[17:47:08.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.914]                     {
[17:47:08.914]                       inherits <- base::inherits
[17:47:08.914]                       invokeRestart <- base::invokeRestart
[17:47:08.914]                       is.null <- base::is.null
[17:47:08.914]                       muffled <- FALSE
[17:47:08.914]                       if (inherits(cond, "message")) {
[17:47:08.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.914]                         if (muffled) 
[17:47:08.914]                           invokeRestart("muffleMessage")
[17:47:08.914]                       }
[17:47:08.914]                       else if (inherits(cond, "warning")) {
[17:47:08.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.914]                         if (muffled) 
[17:47:08.914]                           invokeRestart("muffleWarning")
[17:47:08.914]                       }
[17:47:08.914]                       else if (inherits(cond, "condition")) {
[17:47:08.914]                         if (!is.null(pattern)) {
[17:47:08.914]                           computeRestarts <- base::computeRestarts
[17:47:08.914]                           grepl <- base::grepl
[17:47:08.914]                           restarts <- computeRestarts(cond)
[17:47:08.914]                           for (restart in restarts) {
[17:47:08.914]                             name <- restart$name
[17:47:08.914]                             if (is.null(name)) 
[17:47:08.914]                               next
[17:47:08.914]                             if (!grepl(pattern, name)) 
[17:47:08.914]                               next
[17:47:08.914]                             invokeRestart(restart)
[17:47:08.914]                             muffled <- TRUE
[17:47:08.914]                             break
[17:47:08.914]                           }
[17:47:08.914]                         }
[17:47:08.914]                       }
[17:47:08.914]                       invisible(muffled)
[17:47:08.914]                     }
[17:47:08.914]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.914]                   }
[17:47:08.914]                 }
[17:47:08.914]                 else {
[17:47:08.914]                   if (TRUE) {
[17:47:08.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.914]                     {
[17:47:08.914]                       inherits <- base::inherits
[17:47:08.914]                       invokeRestart <- base::invokeRestart
[17:47:08.914]                       is.null <- base::is.null
[17:47:08.914]                       muffled <- FALSE
[17:47:08.914]                       if (inherits(cond, "message")) {
[17:47:08.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.914]                         if (muffled) 
[17:47:08.914]                           invokeRestart("muffleMessage")
[17:47:08.914]                       }
[17:47:08.914]                       else if (inherits(cond, "warning")) {
[17:47:08.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.914]                         if (muffled) 
[17:47:08.914]                           invokeRestart("muffleWarning")
[17:47:08.914]                       }
[17:47:08.914]                       else if (inherits(cond, "condition")) {
[17:47:08.914]                         if (!is.null(pattern)) {
[17:47:08.914]                           computeRestarts <- base::computeRestarts
[17:47:08.914]                           grepl <- base::grepl
[17:47:08.914]                           restarts <- computeRestarts(cond)
[17:47:08.914]                           for (restart in restarts) {
[17:47:08.914]                             name <- restart$name
[17:47:08.914]                             if (is.null(name)) 
[17:47:08.914]                               next
[17:47:08.914]                             if (!grepl(pattern, name)) 
[17:47:08.914]                               next
[17:47:08.914]                             invokeRestart(restart)
[17:47:08.914]                             muffled <- TRUE
[17:47:08.914]                             break
[17:47:08.914]                           }
[17:47:08.914]                         }
[17:47:08.914]                       }
[17:47:08.914]                       invisible(muffled)
[17:47:08.914]                     }
[17:47:08.914]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.914]                   }
[17:47:08.914]                 }
[17:47:08.914]             }
[17:47:08.914]         }))
[17:47:08.914]     }, error = function(ex) {
[17:47:08.914]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.914]                 ...future.rng), started = ...future.startTime, 
[17:47:08.914]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.914]             version = "1.8"), class = "FutureResult")
[17:47:08.914]     }, finally = {
[17:47:08.914]         if (!identical(...future.workdir, getwd())) 
[17:47:08.914]             setwd(...future.workdir)
[17:47:08.914]         {
[17:47:08.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.914]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.914]             }
[17:47:08.914]             base::options(...future.oldOptions)
[17:47:08.914]             if (.Platform$OS.type == "windows") {
[17:47:08.914]                 old_names <- names(...future.oldEnvVars)
[17:47:08.914]                 envs <- base::Sys.getenv()
[17:47:08.914]                 names <- names(envs)
[17:47:08.914]                 common <- intersect(names, old_names)
[17:47:08.914]                 added <- setdiff(names, old_names)
[17:47:08.914]                 removed <- setdiff(old_names, names)
[17:47:08.914]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.914]                   envs[common]]
[17:47:08.914]                 NAMES <- toupper(changed)
[17:47:08.914]                 args <- list()
[17:47:08.914]                 for (kk in seq_along(NAMES)) {
[17:47:08.914]                   name <- changed[[kk]]
[17:47:08.914]                   NAME <- NAMES[[kk]]
[17:47:08.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.914]                     next
[17:47:08.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.914]                 }
[17:47:08.914]                 NAMES <- toupper(added)
[17:47:08.914]                 for (kk in seq_along(NAMES)) {
[17:47:08.914]                   name <- added[[kk]]
[17:47:08.914]                   NAME <- NAMES[[kk]]
[17:47:08.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.914]                     next
[17:47:08.914]                   args[[name]] <- ""
[17:47:08.914]                 }
[17:47:08.914]                 NAMES <- toupper(removed)
[17:47:08.914]                 for (kk in seq_along(NAMES)) {
[17:47:08.914]                   name <- removed[[kk]]
[17:47:08.914]                   NAME <- NAMES[[kk]]
[17:47:08.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.914]                     next
[17:47:08.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.914]                 }
[17:47:08.914]                 if (length(args) > 0) 
[17:47:08.914]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.914]             }
[17:47:08.914]             else {
[17:47:08.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.914]             }
[17:47:08.914]             {
[17:47:08.914]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.914]                   0L) {
[17:47:08.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.914]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.914]                   base::options(opts)
[17:47:08.914]                 }
[17:47:08.914]                 {
[17:47:08.914]                   {
[17:47:08.914]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:08.914]                     NULL
[17:47:08.914]                   }
[17:47:08.914]                   options(future.plan = NULL)
[17:47:08.914]                   if (is.na(NA_character_)) 
[17:47:08.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.914]                     .init = FALSE)
[17:47:08.914]                 }
[17:47:08.914]             }
[17:47:08.914]         }
[17:47:08.914]     })
[17:47:08.914]     if (TRUE) {
[17:47:08.914]         base::sink(type = "output", split = FALSE)
[17:47:08.914]         if (TRUE) {
[17:47:08.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.914]         }
[17:47:08.914]         else {
[17:47:08.914]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.914]         }
[17:47:08.914]         base::close(...future.stdout)
[17:47:08.914]         ...future.stdout <- NULL
[17:47:08.914]     }
[17:47:08.914]     ...future.result$conditions <- ...future.conditions
[17:47:08.914]     ...future.result$finished <- base::Sys.time()
[17:47:08.914]     ...future.result
[17:47:08.914] }
[17:47:08.917] MultisessionFuture started
[17:47:08.917] - Launch lazy future ... done
[17:47:08.917] run() for ‘MultisessionFuture’ ... done
[17:47:08.917] result() for ClusterFuture ...
[17:47:08.918] receiveMessageFromWorker() for ClusterFuture ...
[17:47:08.918] - Validating connection of MultisessionFuture
[17:47:08.919] - received message: FutureResult
[17:47:08.919] - Received FutureResult
[17:47:08.919] - Erased future from FutureRegistry
[17:47:08.920] result() for ClusterFuture ...
[17:47:08.920] - result already collected: FutureResult
[17:47:08.920] result() for ClusterFuture ... done
[17:47:08.920] signalConditions() ...
[17:47:08.920]  - include = ‘immediateCondition’
[17:47:08.920]  - exclude = 
[17:47:08.920]  - resignal = FALSE
[17:47:08.920]  - Number of conditions: 1
[17:47:08.920] signalConditions() ... done
[17:47:08.921] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:08.921] result() for ClusterFuture ... done
[17:47:08.921] result() for ClusterFuture ...
[17:47:08.921] - result already collected: FutureResult
[17:47:08.921] result() for ClusterFuture ... done
[17:47:08.921] signalConditions() ...
[17:47:08.921]  - include = ‘immediateCondition’
[17:47:08.921]  - exclude = 
[17:47:08.921]  - resignal = FALSE
[17:47:08.922]  - Number of conditions: 1
[17:47:08.922] signalConditions() ... done
[17:47:08.922] Future state: ‘finished’
[17:47:08.922] result() for ClusterFuture ...
[17:47:08.922] - result already collected: FutureResult
[17:47:08.922] result() for ClusterFuture ... done
[17:47:08.922] signalConditions() ...
[17:47:08.922]  - include = ‘condition’
[17:47:08.922]  - exclude = ‘immediateCondition’
[17:47:08.923]  - resignal = TRUE
[17:47:08.923]  - Number of conditions: 1
[17:47:08.923]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:47:08.923] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-22 17:47:08"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.939] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.939] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:08.941] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:47:08.941] Searching for globals ... DONE
[17:47:08.941] Resolving globals: TRUE
[17:47:08.941] Resolving any globals that are futures ...
[17:47:08.941] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:47:08.942] Resolving any globals that are futures ... DONE
[17:47:08.942] 
[17:47:08.942] 
[17:47:08.942] getGlobalsAndPackages() ... DONE
[17:47:08.942] run() for ‘Future’ ...
[17:47:08.943] - state: ‘created’
[17:47:08.943] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:08.957] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:08.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:08.957]   - Field: ‘node’
[17:47:08.957]   - Field: ‘label’
[17:47:08.957]   - Field: ‘local’
[17:47:08.957]   - Field: ‘owner’
[17:47:08.957]   - Field: ‘envir’
[17:47:08.958]   - Field: ‘workers’
[17:47:08.958]   - Field: ‘packages’
[17:47:08.958]   - Field: ‘gc’
[17:47:08.958]   - Field: ‘conditions’
[17:47:08.958]   - Field: ‘persistent’
[17:47:08.958]   - Field: ‘expr’
[17:47:08.958]   - Field: ‘uuid’
[17:47:08.958]   - Field: ‘seed’
[17:47:08.958]   - Field: ‘version’
[17:47:08.959]   - Field: ‘result’
[17:47:08.959]   - Field: ‘asynchronous’
[17:47:08.959]   - Field: ‘calls’
[17:47:08.959]   - Field: ‘globals’
[17:47:08.959]   - Field: ‘stdout’
[17:47:08.959]   - Field: ‘earlySignal’
[17:47:08.959]   - Field: ‘lazy’
[17:47:08.959]   - Field: ‘state’
[17:47:08.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:08.960] - Launch lazy future ...
[17:47:08.960] Packages needed by the future expression (n = 0): <none>
[17:47:08.960] Packages needed by future strategies (n = 0): <none>
[17:47:08.961] {
[17:47:08.961]     {
[17:47:08.961]         {
[17:47:08.961]             ...future.startTime <- base::Sys.time()
[17:47:08.961]             {
[17:47:08.961]                 {
[17:47:08.961]                   {
[17:47:08.961]                     {
[17:47:08.961]                       base::local({
[17:47:08.961]                         has_future <- base::requireNamespace("future", 
[17:47:08.961]                           quietly = TRUE)
[17:47:08.961]                         if (has_future) {
[17:47:08.961]                           ns <- base::getNamespace("future")
[17:47:08.961]                           version <- ns[[".package"]][["version"]]
[17:47:08.961]                           if (is.null(version)) 
[17:47:08.961]                             version <- utils::packageVersion("future")
[17:47:08.961]                         }
[17:47:08.961]                         else {
[17:47:08.961]                           version <- NULL
[17:47:08.961]                         }
[17:47:08.961]                         if (!has_future || version < "1.8.0") {
[17:47:08.961]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:08.961]                             "", base::R.version$version.string), 
[17:47:08.961]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:08.961]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:08.961]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:08.961]                               "release", "version")], collapse = " "), 
[17:47:08.961]                             hostname = base::Sys.info()[["nodename"]])
[17:47:08.961]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:08.961]                             info)
[17:47:08.961]                           info <- base::paste(info, collapse = "; ")
[17:47:08.961]                           if (!has_future) {
[17:47:08.961]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:08.961]                               info)
[17:47:08.961]                           }
[17:47:08.961]                           else {
[17:47:08.961]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:08.961]                               info, version)
[17:47:08.961]                           }
[17:47:08.961]                           base::stop(msg)
[17:47:08.961]                         }
[17:47:08.961]                       })
[17:47:08.961]                     }
[17:47:08.961]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:08.961]                     base::options(mc.cores = 1L)
[17:47:08.961]                   }
[17:47:08.961]                   ...future.strategy.old <- future::plan("list")
[17:47:08.961]                   options(future.plan = NULL)
[17:47:08.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:08.961]                 }
[17:47:08.961]                 ...future.workdir <- getwd()
[17:47:08.961]             }
[17:47:08.961]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:08.961]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:08.961]         }
[17:47:08.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:08.961]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:08.961]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:08.961]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:08.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:08.961]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:08.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:08.961]             base::names(...future.oldOptions))
[17:47:08.961]     }
[17:47:08.961]     if (FALSE) {
[17:47:08.961]     }
[17:47:08.961]     else {
[17:47:08.961]         if (TRUE) {
[17:47:08.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:08.961]                 open = "w")
[17:47:08.961]         }
[17:47:08.961]         else {
[17:47:08.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:08.961]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:08.961]         }
[17:47:08.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:08.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:08.961]             base::sink(type = "output", split = FALSE)
[17:47:08.961]             base::close(...future.stdout)
[17:47:08.961]         }, add = TRUE)
[17:47:08.961]     }
[17:47:08.961]     ...future.frame <- base::sys.nframe()
[17:47:08.961]     ...future.conditions <- base::list()
[17:47:08.961]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:08.961]     if (FALSE) {
[17:47:08.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:08.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:08.961]     }
[17:47:08.961]     ...future.result <- base::tryCatch({
[17:47:08.961]         base::withCallingHandlers({
[17:47:08.961]             ...future.value <- base::withVisible(base::local({
[17:47:08.961]                 ...future.makeSendCondition <- base::local({
[17:47:08.961]                   sendCondition <- NULL
[17:47:08.961]                   function(frame = 1L) {
[17:47:08.961]                     if (is.function(sendCondition)) 
[17:47:08.961]                       return(sendCondition)
[17:47:08.961]                     ns <- getNamespace("parallel")
[17:47:08.961]                     if (exists("sendData", mode = "function", 
[17:47:08.961]                       envir = ns)) {
[17:47:08.961]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:08.961]                         envir = ns)
[17:47:08.961]                       envir <- sys.frame(frame)
[17:47:08.961]                       master <- NULL
[17:47:08.961]                       while (!identical(envir, .GlobalEnv) && 
[17:47:08.961]                         !identical(envir, emptyenv())) {
[17:47:08.961]                         if (exists("master", mode = "list", envir = envir, 
[17:47:08.961]                           inherits = FALSE)) {
[17:47:08.961]                           master <- get("master", mode = "list", 
[17:47:08.961]                             envir = envir, inherits = FALSE)
[17:47:08.961]                           if (inherits(master, c("SOCKnode", 
[17:47:08.961]                             "SOCK0node"))) {
[17:47:08.961]                             sendCondition <<- function(cond) {
[17:47:08.961]                               data <- list(type = "VALUE", value = cond, 
[17:47:08.961]                                 success = TRUE)
[17:47:08.961]                               parallel_sendData(master, data)
[17:47:08.961]                             }
[17:47:08.961]                             return(sendCondition)
[17:47:08.961]                           }
[17:47:08.961]                         }
[17:47:08.961]                         frame <- frame + 1L
[17:47:08.961]                         envir <- sys.frame(frame)
[17:47:08.961]                       }
[17:47:08.961]                     }
[17:47:08.961]                     sendCondition <<- function(cond) NULL
[17:47:08.961]                   }
[17:47:08.961]                 })
[17:47:08.961]                 withCallingHandlers({
[17:47:08.961]                   {
[17:47:08.961]                     b <- a
[17:47:08.961]                     a <- 2
[17:47:08.961]                     a * b
[17:47:08.961]                   }
[17:47:08.961]                 }, immediateCondition = function(cond) {
[17:47:08.961]                   sendCondition <- ...future.makeSendCondition()
[17:47:08.961]                   sendCondition(cond)
[17:47:08.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.961]                   {
[17:47:08.961]                     inherits <- base::inherits
[17:47:08.961]                     invokeRestart <- base::invokeRestart
[17:47:08.961]                     is.null <- base::is.null
[17:47:08.961]                     muffled <- FALSE
[17:47:08.961]                     if (inherits(cond, "message")) {
[17:47:08.961]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:08.961]                       if (muffled) 
[17:47:08.961]                         invokeRestart("muffleMessage")
[17:47:08.961]                     }
[17:47:08.961]                     else if (inherits(cond, "warning")) {
[17:47:08.961]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:08.961]                       if (muffled) 
[17:47:08.961]                         invokeRestart("muffleWarning")
[17:47:08.961]                     }
[17:47:08.961]                     else if (inherits(cond, "condition")) {
[17:47:08.961]                       if (!is.null(pattern)) {
[17:47:08.961]                         computeRestarts <- base::computeRestarts
[17:47:08.961]                         grepl <- base::grepl
[17:47:08.961]                         restarts <- computeRestarts(cond)
[17:47:08.961]                         for (restart in restarts) {
[17:47:08.961]                           name <- restart$name
[17:47:08.961]                           if (is.null(name)) 
[17:47:08.961]                             next
[17:47:08.961]                           if (!grepl(pattern, name)) 
[17:47:08.961]                             next
[17:47:08.961]                           invokeRestart(restart)
[17:47:08.961]                           muffled <- TRUE
[17:47:08.961]                           break
[17:47:08.961]                         }
[17:47:08.961]                       }
[17:47:08.961]                     }
[17:47:08.961]                     invisible(muffled)
[17:47:08.961]                   }
[17:47:08.961]                   muffleCondition(cond)
[17:47:08.961]                 })
[17:47:08.961]             }))
[17:47:08.961]             future::FutureResult(value = ...future.value$value, 
[17:47:08.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.961]                   ...future.rng), globalenv = if (FALSE) 
[17:47:08.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:08.961]                     ...future.globalenv.names))
[17:47:08.961]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:08.961]         }, condition = base::local({
[17:47:08.961]             c <- base::c
[17:47:08.961]             inherits <- base::inherits
[17:47:08.961]             invokeRestart <- base::invokeRestart
[17:47:08.961]             length <- base::length
[17:47:08.961]             list <- base::list
[17:47:08.961]             seq.int <- base::seq.int
[17:47:08.961]             signalCondition <- base::signalCondition
[17:47:08.961]             sys.calls <- base::sys.calls
[17:47:08.961]             `[[` <- base::`[[`
[17:47:08.961]             `+` <- base::`+`
[17:47:08.961]             `<<-` <- base::`<<-`
[17:47:08.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:08.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:08.961]                   3L)]
[17:47:08.961]             }
[17:47:08.961]             function(cond) {
[17:47:08.961]                 is_error <- inherits(cond, "error")
[17:47:08.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:08.961]                   NULL)
[17:47:08.961]                 if (is_error) {
[17:47:08.961]                   sessionInformation <- function() {
[17:47:08.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:08.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:08.961]                       search = base::search(), system = base::Sys.info())
[17:47:08.961]                   }
[17:47:08.961]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:08.961]                     cond$call), session = sessionInformation(), 
[17:47:08.961]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:08.961]                   signalCondition(cond)
[17:47:08.961]                 }
[17:47:08.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:08.961]                 "immediateCondition"))) {
[17:47:08.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:08.961]                   ...future.conditions[[length(...future.conditions) + 
[17:47:08.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:08.961]                   if (TRUE && !signal) {
[17:47:08.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.961]                     {
[17:47:08.961]                       inherits <- base::inherits
[17:47:08.961]                       invokeRestart <- base::invokeRestart
[17:47:08.961]                       is.null <- base::is.null
[17:47:08.961]                       muffled <- FALSE
[17:47:08.961]                       if (inherits(cond, "message")) {
[17:47:08.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.961]                         if (muffled) 
[17:47:08.961]                           invokeRestart("muffleMessage")
[17:47:08.961]                       }
[17:47:08.961]                       else if (inherits(cond, "warning")) {
[17:47:08.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.961]                         if (muffled) 
[17:47:08.961]                           invokeRestart("muffleWarning")
[17:47:08.961]                       }
[17:47:08.961]                       else if (inherits(cond, "condition")) {
[17:47:08.961]                         if (!is.null(pattern)) {
[17:47:08.961]                           computeRestarts <- base::computeRestarts
[17:47:08.961]                           grepl <- base::grepl
[17:47:08.961]                           restarts <- computeRestarts(cond)
[17:47:08.961]                           for (restart in restarts) {
[17:47:08.961]                             name <- restart$name
[17:47:08.961]                             if (is.null(name)) 
[17:47:08.961]                               next
[17:47:08.961]                             if (!grepl(pattern, name)) 
[17:47:08.961]                               next
[17:47:08.961]                             invokeRestart(restart)
[17:47:08.961]                             muffled <- TRUE
[17:47:08.961]                             break
[17:47:08.961]                           }
[17:47:08.961]                         }
[17:47:08.961]                       }
[17:47:08.961]                       invisible(muffled)
[17:47:08.961]                     }
[17:47:08.961]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.961]                   }
[17:47:08.961]                 }
[17:47:08.961]                 else {
[17:47:08.961]                   if (TRUE) {
[17:47:08.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:08.961]                     {
[17:47:08.961]                       inherits <- base::inherits
[17:47:08.961]                       invokeRestart <- base::invokeRestart
[17:47:08.961]                       is.null <- base::is.null
[17:47:08.961]                       muffled <- FALSE
[17:47:08.961]                       if (inherits(cond, "message")) {
[17:47:08.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:08.961]                         if (muffled) 
[17:47:08.961]                           invokeRestart("muffleMessage")
[17:47:08.961]                       }
[17:47:08.961]                       else if (inherits(cond, "warning")) {
[17:47:08.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:08.961]                         if (muffled) 
[17:47:08.961]                           invokeRestart("muffleWarning")
[17:47:08.961]                       }
[17:47:08.961]                       else if (inherits(cond, "condition")) {
[17:47:08.961]                         if (!is.null(pattern)) {
[17:47:08.961]                           computeRestarts <- base::computeRestarts
[17:47:08.961]                           grepl <- base::grepl
[17:47:08.961]                           restarts <- computeRestarts(cond)
[17:47:08.961]                           for (restart in restarts) {
[17:47:08.961]                             name <- restart$name
[17:47:08.961]                             if (is.null(name)) 
[17:47:08.961]                               next
[17:47:08.961]                             if (!grepl(pattern, name)) 
[17:47:08.961]                               next
[17:47:08.961]                             invokeRestart(restart)
[17:47:08.961]                             muffled <- TRUE
[17:47:08.961]                             break
[17:47:08.961]                           }
[17:47:08.961]                         }
[17:47:08.961]                       }
[17:47:08.961]                       invisible(muffled)
[17:47:08.961]                     }
[17:47:08.961]                     muffleCondition(cond, pattern = "^muffle")
[17:47:08.961]                   }
[17:47:08.961]                 }
[17:47:08.961]             }
[17:47:08.961]         }))
[17:47:08.961]     }, error = function(ex) {
[17:47:08.961]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:08.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:08.961]                 ...future.rng), started = ...future.startTime, 
[17:47:08.961]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:08.961]             version = "1.8"), class = "FutureResult")
[17:47:08.961]     }, finally = {
[17:47:08.961]         if (!identical(...future.workdir, getwd())) 
[17:47:08.961]             setwd(...future.workdir)
[17:47:08.961]         {
[17:47:08.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:08.961]                 ...future.oldOptions$nwarnings <- NULL
[17:47:08.961]             }
[17:47:08.961]             base::options(...future.oldOptions)
[17:47:08.961]             if (.Platform$OS.type == "windows") {
[17:47:08.961]                 old_names <- names(...future.oldEnvVars)
[17:47:08.961]                 envs <- base::Sys.getenv()
[17:47:08.961]                 names <- names(envs)
[17:47:08.961]                 common <- intersect(names, old_names)
[17:47:08.961]                 added <- setdiff(names, old_names)
[17:47:08.961]                 removed <- setdiff(old_names, names)
[17:47:08.961]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:08.961]                   envs[common]]
[17:47:08.961]                 NAMES <- toupper(changed)
[17:47:08.961]                 args <- list()
[17:47:08.961]                 for (kk in seq_along(NAMES)) {
[17:47:08.961]                   name <- changed[[kk]]
[17:47:08.961]                   NAME <- NAMES[[kk]]
[17:47:08.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.961]                     next
[17:47:08.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.961]                 }
[17:47:08.961]                 NAMES <- toupper(added)
[17:47:08.961]                 for (kk in seq_along(NAMES)) {
[17:47:08.961]                   name <- added[[kk]]
[17:47:08.961]                   NAME <- NAMES[[kk]]
[17:47:08.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.961]                     next
[17:47:08.961]                   args[[name]] <- ""
[17:47:08.961]                 }
[17:47:08.961]                 NAMES <- toupper(removed)
[17:47:08.961]                 for (kk in seq_along(NAMES)) {
[17:47:08.961]                   name <- removed[[kk]]
[17:47:08.961]                   NAME <- NAMES[[kk]]
[17:47:08.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:08.961]                     next
[17:47:08.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:08.961]                 }
[17:47:08.961]                 if (length(args) > 0) 
[17:47:08.961]                   base::do.call(base::Sys.setenv, args = args)
[17:47:08.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:08.961]             }
[17:47:08.961]             else {
[17:47:08.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:08.961]             }
[17:47:08.961]             {
[17:47:08.961]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:08.961]                   0L) {
[17:47:08.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:08.961]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:08.961]                   base::options(opts)
[17:47:08.961]                 }
[17:47:08.961]                 {
[17:47:08.961]                   {
[17:47:08.961]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:08.961]                     NULL
[17:47:08.961]                   }
[17:47:08.961]                   options(future.plan = NULL)
[17:47:08.961]                   if (is.na(NA_character_)) 
[17:47:08.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:08.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:08.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:08.961]                     .init = FALSE)
[17:47:08.961]                 }
[17:47:08.961]             }
[17:47:08.961]         }
[17:47:08.961]     })
[17:47:08.961]     if (TRUE) {
[17:47:08.961]         base::sink(type = "output", split = FALSE)
[17:47:08.961]         if (TRUE) {
[17:47:08.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:08.961]         }
[17:47:08.961]         else {
[17:47:08.961]             ...future.result["stdout"] <- base::list(NULL)
[17:47:08.961]         }
[17:47:08.961]         base::close(...future.stdout)
[17:47:08.961]         ...future.stdout <- NULL
[17:47:08.961]     }
[17:47:08.961]     ...future.result$conditions <- ...future.conditions
[17:47:08.961]     ...future.result$finished <- base::Sys.time()
[17:47:08.961]     ...future.result
[17:47:08.961] }
[17:47:08.964] MultisessionFuture started
[17:47:08.964] - Launch lazy future ... done
[17:47:08.964] run() for ‘MultisessionFuture’ ... done
[17:47:08.964] result() for ClusterFuture ...
[17:47:08.964] receiveMessageFromWorker() for ClusterFuture ...
[17:47:08.964] - Validating connection of MultisessionFuture
[17:47:08.969] - received message: FutureResult
[17:47:08.971] - Received FutureResult
[17:47:08.971] - Erased future from FutureRegistry
[17:47:08.971] result() for ClusterFuture ...
[17:47:08.971] - result already collected: FutureResult
[17:47:08.972] result() for ClusterFuture ... done
[17:47:08.972] signalConditions() ...
[17:47:08.972]  - include = ‘immediateCondition’
[17:47:08.972]  - exclude = 
[17:47:08.972]  - resignal = FALSE
[17:47:08.972]  - Number of conditions: 1
[17:47:08.972] signalConditions() ... done
[17:47:08.972] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:08.972] result() for ClusterFuture ... done
[17:47:08.972] result() for ClusterFuture ...
[17:47:08.972] - result already collected: FutureResult
[17:47:08.972] result() for ClusterFuture ... done
[17:47:08.973] signalConditions() ...
[17:47:08.973]  - include = ‘immediateCondition’
[17:47:08.973]  - exclude = 
[17:47:08.973]  - resignal = FALSE
[17:47:08.973]  - Number of conditions: 1
[17:47:08.973] signalConditions() ... done
[17:47:08.973] Future state: ‘finished’
[17:47:08.973] result() for ClusterFuture ...
[17:47:08.973] - result already collected: FutureResult
[17:47:08.973] result() for ClusterFuture ... done
[17:47:08.973] signalConditions() ...
[17:47:08.973]  - include = ‘condition’
[17:47:08.974]  - exclude = ‘immediateCondition’
[17:47:08.974]  - resignal = TRUE
[17:47:08.974]  - Number of conditions: 1
[17:47:08.974]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:47:08.974] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-22 17:47:08"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:08.987] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:08.987] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:08.989] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:08.989] Searching for globals ... DONE
[17:47:08.989] Resolving globals: TRUE
[17:47:08.989] Resolving any globals that are futures ...
[17:47:08.989] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:08.989] Resolving any globals that are futures ... DONE
[17:47:08.990] Resolving futures part of globals (recursively) ...
[17:47:08.990] resolve() on list ...
[17:47:08.990]  recursive: 99
[17:47:08.990]  length: 1
[17:47:08.990]  elements: ‘ii’
[17:47:08.990]  length: 0 (resolved future 1)
[17:47:08.990] resolve() on list ... DONE
[17:47:08.990] - globals: [1] ‘ii’
[17:47:08.991] Resolving futures part of globals (recursively) ... DONE
[17:47:08.991] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:08.991] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:08.991] - globals: [1] ‘ii’
[17:47:08.991] 
[17:47:08.991] getGlobalsAndPackages() ... DONE
[17:47:08.992] run() for ‘Future’ ...
[17:47:08.992] - state: ‘created’
[17:47:08.992] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.006] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.006] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.006]   - Field: ‘node’
[17:47:09.007]   - Field: ‘label’
[17:47:09.007]   - Field: ‘local’
[17:47:09.007]   - Field: ‘owner’
[17:47:09.007]   - Field: ‘envir’
[17:47:09.007]   - Field: ‘workers’
[17:47:09.007]   - Field: ‘packages’
[17:47:09.007]   - Field: ‘gc’
[17:47:09.007]   - Field: ‘conditions’
[17:47:09.007]   - Field: ‘persistent’
[17:47:09.007]   - Field: ‘expr’
[17:47:09.008]   - Field: ‘uuid’
[17:47:09.008]   - Field: ‘seed’
[17:47:09.008]   - Field: ‘version’
[17:47:09.008]   - Field: ‘result’
[17:47:09.008]   - Field: ‘asynchronous’
[17:47:09.008]   - Field: ‘calls’
[17:47:09.008]   - Field: ‘globals’
[17:47:09.008]   - Field: ‘stdout’
[17:47:09.008]   - Field: ‘earlySignal’
[17:47:09.008]   - Field: ‘lazy’
[17:47:09.008]   - Field: ‘state’
[17:47:09.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.009] - Launch lazy future ...
[17:47:09.009] Packages needed by the future expression (n = 0): <none>
[17:47:09.009] Packages needed by future strategies (n = 0): <none>
[17:47:09.009] {
[17:47:09.009]     {
[17:47:09.009]         {
[17:47:09.009]             ...future.startTime <- base::Sys.time()
[17:47:09.009]             {
[17:47:09.009]                 {
[17:47:09.009]                   {
[17:47:09.009]                     {
[17:47:09.009]                       base::local({
[17:47:09.009]                         has_future <- base::requireNamespace("future", 
[17:47:09.009]                           quietly = TRUE)
[17:47:09.009]                         if (has_future) {
[17:47:09.009]                           ns <- base::getNamespace("future")
[17:47:09.009]                           version <- ns[[".package"]][["version"]]
[17:47:09.009]                           if (is.null(version)) 
[17:47:09.009]                             version <- utils::packageVersion("future")
[17:47:09.009]                         }
[17:47:09.009]                         else {
[17:47:09.009]                           version <- NULL
[17:47:09.009]                         }
[17:47:09.009]                         if (!has_future || version < "1.8.0") {
[17:47:09.009]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.009]                             "", base::R.version$version.string), 
[17:47:09.009]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:09.009]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.009]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.009]                               "release", "version")], collapse = " "), 
[17:47:09.009]                             hostname = base::Sys.info()[["nodename"]])
[17:47:09.009]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.009]                             info)
[17:47:09.009]                           info <- base::paste(info, collapse = "; ")
[17:47:09.009]                           if (!has_future) {
[17:47:09.009]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.009]                               info)
[17:47:09.009]                           }
[17:47:09.009]                           else {
[17:47:09.009]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.009]                               info, version)
[17:47:09.009]                           }
[17:47:09.009]                           base::stop(msg)
[17:47:09.009]                         }
[17:47:09.009]                       })
[17:47:09.009]                     }
[17:47:09.009]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.009]                     base::options(mc.cores = 1L)
[17:47:09.009]                   }
[17:47:09.009]                   ...future.strategy.old <- future::plan("list")
[17:47:09.009]                   options(future.plan = NULL)
[17:47:09.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.009]                 }
[17:47:09.009]                 ...future.workdir <- getwd()
[17:47:09.009]             }
[17:47:09.009]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.009]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.009]         }
[17:47:09.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.009]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.009]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.009]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.009]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.009]             base::names(...future.oldOptions))
[17:47:09.009]     }
[17:47:09.009]     if (FALSE) {
[17:47:09.009]     }
[17:47:09.009]     else {
[17:47:09.009]         if (TRUE) {
[17:47:09.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.009]                 open = "w")
[17:47:09.009]         }
[17:47:09.009]         else {
[17:47:09.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.009]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.009]         }
[17:47:09.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.009]             base::sink(type = "output", split = FALSE)
[17:47:09.009]             base::close(...future.stdout)
[17:47:09.009]         }, add = TRUE)
[17:47:09.009]     }
[17:47:09.009]     ...future.frame <- base::sys.nframe()
[17:47:09.009]     ...future.conditions <- base::list()
[17:47:09.009]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.009]     if (FALSE) {
[17:47:09.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.009]     }
[17:47:09.009]     ...future.result <- base::tryCatch({
[17:47:09.009]         base::withCallingHandlers({
[17:47:09.009]             ...future.value <- base::withVisible(base::local({
[17:47:09.009]                 ...future.makeSendCondition <- base::local({
[17:47:09.009]                   sendCondition <- NULL
[17:47:09.009]                   function(frame = 1L) {
[17:47:09.009]                     if (is.function(sendCondition)) 
[17:47:09.009]                       return(sendCondition)
[17:47:09.009]                     ns <- getNamespace("parallel")
[17:47:09.009]                     if (exists("sendData", mode = "function", 
[17:47:09.009]                       envir = ns)) {
[17:47:09.009]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.009]                         envir = ns)
[17:47:09.009]                       envir <- sys.frame(frame)
[17:47:09.009]                       master <- NULL
[17:47:09.009]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.009]                         !identical(envir, emptyenv())) {
[17:47:09.009]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.009]                           inherits = FALSE)) {
[17:47:09.009]                           master <- get("master", mode = "list", 
[17:47:09.009]                             envir = envir, inherits = FALSE)
[17:47:09.009]                           if (inherits(master, c("SOCKnode", 
[17:47:09.009]                             "SOCK0node"))) {
[17:47:09.009]                             sendCondition <<- function(cond) {
[17:47:09.009]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.009]                                 success = TRUE)
[17:47:09.009]                               parallel_sendData(master, data)
[17:47:09.009]                             }
[17:47:09.009]                             return(sendCondition)
[17:47:09.009]                           }
[17:47:09.009]                         }
[17:47:09.009]                         frame <- frame + 1L
[17:47:09.009]                         envir <- sys.frame(frame)
[17:47:09.009]                       }
[17:47:09.009]                     }
[17:47:09.009]                     sendCondition <<- function(cond) NULL
[17:47:09.009]                   }
[17:47:09.009]                 })
[17:47:09.009]                 withCallingHandlers({
[17:47:09.009]                   {
[17:47:09.009]                     b <- a * ii
[17:47:09.009]                     a <- 0
[17:47:09.009]                     b
[17:47:09.009]                   }
[17:47:09.009]                 }, immediateCondition = function(cond) {
[17:47:09.009]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.009]                   sendCondition(cond)
[17:47:09.009]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.009]                   {
[17:47:09.009]                     inherits <- base::inherits
[17:47:09.009]                     invokeRestart <- base::invokeRestart
[17:47:09.009]                     is.null <- base::is.null
[17:47:09.009]                     muffled <- FALSE
[17:47:09.009]                     if (inherits(cond, "message")) {
[17:47:09.009]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.009]                       if (muffled) 
[17:47:09.009]                         invokeRestart("muffleMessage")
[17:47:09.009]                     }
[17:47:09.009]                     else if (inherits(cond, "warning")) {
[17:47:09.009]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.009]                       if (muffled) 
[17:47:09.009]                         invokeRestart("muffleWarning")
[17:47:09.009]                     }
[17:47:09.009]                     else if (inherits(cond, "condition")) {
[17:47:09.009]                       if (!is.null(pattern)) {
[17:47:09.009]                         computeRestarts <- base::computeRestarts
[17:47:09.009]                         grepl <- base::grepl
[17:47:09.009]                         restarts <- computeRestarts(cond)
[17:47:09.009]                         for (restart in restarts) {
[17:47:09.009]                           name <- restart$name
[17:47:09.009]                           if (is.null(name)) 
[17:47:09.009]                             next
[17:47:09.009]                           if (!grepl(pattern, name)) 
[17:47:09.009]                             next
[17:47:09.009]                           invokeRestart(restart)
[17:47:09.009]                           muffled <- TRUE
[17:47:09.009]                           break
[17:47:09.009]                         }
[17:47:09.009]                       }
[17:47:09.009]                     }
[17:47:09.009]                     invisible(muffled)
[17:47:09.009]                   }
[17:47:09.009]                   muffleCondition(cond)
[17:47:09.009]                 })
[17:47:09.009]             }))
[17:47:09.009]             future::FutureResult(value = ...future.value$value, 
[17:47:09.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.009]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.009]                     ...future.globalenv.names))
[17:47:09.009]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.009]         }, condition = base::local({
[17:47:09.009]             c <- base::c
[17:47:09.009]             inherits <- base::inherits
[17:47:09.009]             invokeRestart <- base::invokeRestart
[17:47:09.009]             length <- base::length
[17:47:09.009]             list <- base::list
[17:47:09.009]             seq.int <- base::seq.int
[17:47:09.009]             signalCondition <- base::signalCondition
[17:47:09.009]             sys.calls <- base::sys.calls
[17:47:09.009]             `[[` <- base::`[[`
[17:47:09.009]             `+` <- base::`+`
[17:47:09.009]             `<<-` <- base::`<<-`
[17:47:09.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.009]                   3L)]
[17:47:09.009]             }
[17:47:09.009]             function(cond) {
[17:47:09.009]                 is_error <- inherits(cond, "error")
[17:47:09.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.009]                   NULL)
[17:47:09.009]                 if (is_error) {
[17:47:09.009]                   sessionInformation <- function() {
[17:47:09.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.009]                       search = base::search(), system = base::Sys.info())
[17:47:09.009]                   }
[17:47:09.009]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.009]                     cond$call), session = sessionInformation(), 
[17:47:09.009]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.009]                   signalCondition(cond)
[17:47:09.009]                 }
[17:47:09.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.009]                 "immediateCondition"))) {
[17:47:09.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.009]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.009]                   if (TRUE && !signal) {
[17:47:09.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.009]                     {
[17:47:09.009]                       inherits <- base::inherits
[17:47:09.009]                       invokeRestart <- base::invokeRestart
[17:47:09.009]                       is.null <- base::is.null
[17:47:09.009]                       muffled <- FALSE
[17:47:09.009]                       if (inherits(cond, "message")) {
[17:47:09.009]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.009]                         if (muffled) 
[17:47:09.009]                           invokeRestart("muffleMessage")
[17:47:09.009]                       }
[17:47:09.009]                       else if (inherits(cond, "warning")) {
[17:47:09.009]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.009]                         if (muffled) 
[17:47:09.009]                           invokeRestart("muffleWarning")
[17:47:09.009]                       }
[17:47:09.009]                       else if (inherits(cond, "condition")) {
[17:47:09.009]                         if (!is.null(pattern)) {
[17:47:09.009]                           computeRestarts <- base::computeRestarts
[17:47:09.009]                           grepl <- base::grepl
[17:47:09.009]                           restarts <- computeRestarts(cond)
[17:47:09.009]                           for (restart in restarts) {
[17:47:09.009]                             name <- restart$name
[17:47:09.009]                             if (is.null(name)) 
[17:47:09.009]                               next
[17:47:09.009]                             if (!grepl(pattern, name)) 
[17:47:09.009]                               next
[17:47:09.009]                             invokeRestart(restart)
[17:47:09.009]                             muffled <- TRUE
[17:47:09.009]                             break
[17:47:09.009]                           }
[17:47:09.009]                         }
[17:47:09.009]                       }
[17:47:09.009]                       invisible(muffled)
[17:47:09.009]                     }
[17:47:09.009]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.009]                   }
[17:47:09.009]                 }
[17:47:09.009]                 else {
[17:47:09.009]                   if (TRUE) {
[17:47:09.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.009]                     {
[17:47:09.009]                       inherits <- base::inherits
[17:47:09.009]                       invokeRestart <- base::invokeRestart
[17:47:09.009]                       is.null <- base::is.null
[17:47:09.009]                       muffled <- FALSE
[17:47:09.009]                       if (inherits(cond, "message")) {
[17:47:09.009]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.009]                         if (muffled) 
[17:47:09.009]                           invokeRestart("muffleMessage")
[17:47:09.009]                       }
[17:47:09.009]                       else if (inherits(cond, "warning")) {
[17:47:09.009]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.009]                         if (muffled) 
[17:47:09.009]                           invokeRestart("muffleWarning")
[17:47:09.009]                       }
[17:47:09.009]                       else if (inherits(cond, "condition")) {
[17:47:09.009]                         if (!is.null(pattern)) {
[17:47:09.009]                           computeRestarts <- base::computeRestarts
[17:47:09.009]                           grepl <- base::grepl
[17:47:09.009]                           restarts <- computeRestarts(cond)
[17:47:09.009]                           for (restart in restarts) {
[17:47:09.009]                             name <- restart$name
[17:47:09.009]                             if (is.null(name)) 
[17:47:09.009]                               next
[17:47:09.009]                             if (!grepl(pattern, name)) 
[17:47:09.009]                               next
[17:47:09.009]                             invokeRestart(restart)
[17:47:09.009]                             muffled <- TRUE
[17:47:09.009]                             break
[17:47:09.009]                           }
[17:47:09.009]                         }
[17:47:09.009]                       }
[17:47:09.009]                       invisible(muffled)
[17:47:09.009]                     }
[17:47:09.009]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.009]                   }
[17:47:09.009]                 }
[17:47:09.009]             }
[17:47:09.009]         }))
[17:47:09.009]     }, error = function(ex) {
[17:47:09.009]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.009]                 ...future.rng), started = ...future.startTime, 
[17:47:09.009]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.009]             version = "1.8"), class = "FutureResult")
[17:47:09.009]     }, finally = {
[17:47:09.009]         if (!identical(...future.workdir, getwd())) 
[17:47:09.009]             setwd(...future.workdir)
[17:47:09.009]         {
[17:47:09.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.009]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.009]             }
[17:47:09.009]             base::options(...future.oldOptions)
[17:47:09.009]             if (.Platform$OS.type == "windows") {
[17:47:09.009]                 old_names <- names(...future.oldEnvVars)
[17:47:09.009]                 envs <- base::Sys.getenv()
[17:47:09.009]                 names <- names(envs)
[17:47:09.009]                 common <- intersect(names, old_names)
[17:47:09.009]                 added <- setdiff(names, old_names)
[17:47:09.009]                 removed <- setdiff(old_names, names)
[17:47:09.009]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.009]                   envs[common]]
[17:47:09.009]                 NAMES <- toupper(changed)
[17:47:09.009]                 args <- list()
[17:47:09.009]                 for (kk in seq_along(NAMES)) {
[17:47:09.009]                   name <- changed[[kk]]
[17:47:09.009]                   NAME <- NAMES[[kk]]
[17:47:09.009]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.009]                     next
[17:47:09.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.009]                 }
[17:47:09.009]                 NAMES <- toupper(added)
[17:47:09.009]                 for (kk in seq_along(NAMES)) {
[17:47:09.009]                   name <- added[[kk]]
[17:47:09.009]                   NAME <- NAMES[[kk]]
[17:47:09.009]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.009]                     next
[17:47:09.009]                   args[[name]] <- ""
[17:47:09.009]                 }
[17:47:09.009]                 NAMES <- toupper(removed)
[17:47:09.009]                 for (kk in seq_along(NAMES)) {
[17:47:09.009]                   name <- removed[[kk]]
[17:47:09.009]                   NAME <- NAMES[[kk]]
[17:47:09.009]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.009]                     next
[17:47:09.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.009]                 }
[17:47:09.009]                 if (length(args) > 0) 
[17:47:09.009]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.009]             }
[17:47:09.009]             else {
[17:47:09.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.009]             }
[17:47:09.009]             {
[17:47:09.009]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.009]                   0L) {
[17:47:09.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.009]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.009]                   base::options(opts)
[17:47:09.009]                 }
[17:47:09.009]                 {
[17:47:09.009]                   {
[17:47:09.009]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.009]                     NULL
[17:47:09.009]                   }
[17:47:09.009]                   options(future.plan = NULL)
[17:47:09.009]                   if (is.na(NA_character_)) 
[17:47:09.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.009]                     .init = FALSE)
[17:47:09.009]                 }
[17:47:09.009]             }
[17:47:09.009]         }
[17:47:09.009]     })
[17:47:09.009]     if (TRUE) {
[17:47:09.009]         base::sink(type = "output", split = FALSE)
[17:47:09.009]         if (TRUE) {
[17:47:09.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.009]         }
[17:47:09.009]         else {
[17:47:09.009]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.009]         }
[17:47:09.009]         base::close(...future.stdout)
[17:47:09.009]         ...future.stdout <- NULL
[17:47:09.009]     }
[17:47:09.009]     ...future.result$conditions <- ...future.conditions
[17:47:09.009]     ...future.result$finished <- base::Sys.time()
[17:47:09.009]     ...future.result
[17:47:09.009] }
[17:47:09.012] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:47:09.012] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:47:09.012] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:47:09.013] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:47:09.013] MultisessionFuture started
[17:47:09.013] - Launch lazy future ... done
[17:47:09.013] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.014] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.014] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.015] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.015] Searching for globals ... DONE
[17:47:09.015] Resolving globals: TRUE
[17:47:09.015] Resolving any globals that are futures ...
[17:47:09.016] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.016] Resolving any globals that are futures ... DONE
[17:47:09.016] Resolving futures part of globals (recursively) ...
[17:47:09.016] resolve() on list ...
[17:47:09.016]  recursive: 99
[17:47:09.016]  length: 1
[17:47:09.016]  elements: ‘ii’
[17:47:09.017]  length: 0 (resolved future 1)
[17:47:09.017] resolve() on list ... DONE
[17:47:09.017] - globals: [1] ‘ii’
[17:47:09.017] Resolving futures part of globals (recursively) ... DONE
[17:47:09.017] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:09.017] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:09.017] - globals: [1] ‘ii’
[17:47:09.018] 
[17:47:09.018] getGlobalsAndPackages() ... DONE
[17:47:09.018] run() for ‘Future’ ...
[17:47:09.018] - state: ‘created’
[17:47:09.018] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.032]   - Field: ‘node’
[17:47:09.032]   - Field: ‘label’
[17:47:09.032]   - Field: ‘local’
[17:47:09.032]   - Field: ‘owner’
[17:47:09.032]   - Field: ‘envir’
[17:47:09.032]   - Field: ‘workers’
[17:47:09.032]   - Field: ‘packages’
[17:47:09.032]   - Field: ‘gc’
[17:47:09.033]   - Field: ‘conditions’
[17:47:09.033]   - Field: ‘persistent’
[17:47:09.033]   - Field: ‘expr’
[17:47:09.033]   - Field: ‘uuid’
[17:47:09.033]   - Field: ‘seed’
[17:47:09.033]   - Field: ‘version’
[17:47:09.033]   - Field: ‘result’
[17:47:09.033]   - Field: ‘asynchronous’
[17:47:09.033]   - Field: ‘calls’
[17:47:09.033]   - Field: ‘globals’
[17:47:09.033]   - Field: ‘stdout’
[17:47:09.034]   - Field: ‘earlySignal’
[17:47:09.034]   - Field: ‘lazy’
[17:47:09.034]   - Field: ‘state’
[17:47:09.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.034] - Launch lazy future ...
[17:47:09.034] Packages needed by the future expression (n = 0): <none>
[17:47:09.034] Packages needed by future strategies (n = 0): <none>
[17:47:09.035] {
[17:47:09.035]     {
[17:47:09.035]         {
[17:47:09.035]             ...future.startTime <- base::Sys.time()
[17:47:09.035]             {
[17:47:09.035]                 {
[17:47:09.035]                   {
[17:47:09.035]                     {
[17:47:09.035]                       base::local({
[17:47:09.035]                         has_future <- base::requireNamespace("future", 
[17:47:09.035]                           quietly = TRUE)
[17:47:09.035]                         if (has_future) {
[17:47:09.035]                           ns <- base::getNamespace("future")
[17:47:09.035]                           version <- ns[[".package"]][["version"]]
[17:47:09.035]                           if (is.null(version)) 
[17:47:09.035]                             version <- utils::packageVersion("future")
[17:47:09.035]                         }
[17:47:09.035]                         else {
[17:47:09.035]                           version <- NULL
[17:47:09.035]                         }
[17:47:09.035]                         if (!has_future || version < "1.8.0") {
[17:47:09.035]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.035]                             "", base::R.version$version.string), 
[17:47:09.035]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:09.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.035]                               "release", "version")], collapse = " "), 
[17:47:09.035]                             hostname = base::Sys.info()[["nodename"]])
[17:47:09.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.035]                             info)
[17:47:09.035]                           info <- base::paste(info, collapse = "; ")
[17:47:09.035]                           if (!has_future) {
[17:47:09.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.035]                               info)
[17:47:09.035]                           }
[17:47:09.035]                           else {
[17:47:09.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.035]                               info, version)
[17:47:09.035]                           }
[17:47:09.035]                           base::stop(msg)
[17:47:09.035]                         }
[17:47:09.035]                       })
[17:47:09.035]                     }
[17:47:09.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.035]                     base::options(mc.cores = 1L)
[17:47:09.035]                   }
[17:47:09.035]                   ...future.strategy.old <- future::plan("list")
[17:47:09.035]                   options(future.plan = NULL)
[17:47:09.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.035]                 }
[17:47:09.035]                 ...future.workdir <- getwd()
[17:47:09.035]             }
[17:47:09.035]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.035]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.035]         }
[17:47:09.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.035]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.035]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.035]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.035]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.035]             base::names(...future.oldOptions))
[17:47:09.035]     }
[17:47:09.035]     if (FALSE) {
[17:47:09.035]     }
[17:47:09.035]     else {
[17:47:09.035]         if (TRUE) {
[17:47:09.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.035]                 open = "w")
[17:47:09.035]         }
[17:47:09.035]         else {
[17:47:09.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.035]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.035]         }
[17:47:09.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.035]             base::sink(type = "output", split = FALSE)
[17:47:09.035]             base::close(...future.stdout)
[17:47:09.035]         }, add = TRUE)
[17:47:09.035]     }
[17:47:09.035]     ...future.frame <- base::sys.nframe()
[17:47:09.035]     ...future.conditions <- base::list()
[17:47:09.035]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.035]     if (FALSE) {
[17:47:09.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.035]     }
[17:47:09.035]     ...future.result <- base::tryCatch({
[17:47:09.035]         base::withCallingHandlers({
[17:47:09.035]             ...future.value <- base::withVisible(base::local({
[17:47:09.035]                 ...future.makeSendCondition <- base::local({
[17:47:09.035]                   sendCondition <- NULL
[17:47:09.035]                   function(frame = 1L) {
[17:47:09.035]                     if (is.function(sendCondition)) 
[17:47:09.035]                       return(sendCondition)
[17:47:09.035]                     ns <- getNamespace("parallel")
[17:47:09.035]                     if (exists("sendData", mode = "function", 
[17:47:09.035]                       envir = ns)) {
[17:47:09.035]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.035]                         envir = ns)
[17:47:09.035]                       envir <- sys.frame(frame)
[17:47:09.035]                       master <- NULL
[17:47:09.035]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.035]                         !identical(envir, emptyenv())) {
[17:47:09.035]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.035]                           inherits = FALSE)) {
[17:47:09.035]                           master <- get("master", mode = "list", 
[17:47:09.035]                             envir = envir, inherits = FALSE)
[17:47:09.035]                           if (inherits(master, c("SOCKnode", 
[17:47:09.035]                             "SOCK0node"))) {
[17:47:09.035]                             sendCondition <<- function(cond) {
[17:47:09.035]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.035]                                 success = TRUE)
[17:47:09.035]                               parallel_sendData(master, data)
[17:47:09.035]                             }
[17:47:09.035]                             return(sendCondition)
[17:47:09.035]                           }
[17:47:09.035]                         }
[17:47:09.035]                         frame <- frame + 1L
[17:47:09.035]                         envir <- sys.frame(frame)
[17:47:09.035]                       }
[17:47:09.035]                     }
[17:47:09.035]                     sendCondition <<- function(cond) NULL
[17:47:09.035]                   }
[17:47:09.035]                 })
[17:47:09.035]                 withCallingHandlers({
[17:47:09.035]                   {
[17:47:09.035]                     b <- a * ii
[17:47:09.035]                     a <- 0
[17:47:09.035]                     b
[17:47:09.035]                   }
[17:47:09.035]                 }, immediateCondition = function(cond) {
[17:47:09.035]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.035]                   sendCondition(cond)
[17:47:09.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.035]                   {
[17:47:09.035]                     inherits <- base::inherits
[17:47:09.035]                     invokeRestart <- base::invokeRestart
[17:47:09.035]                     is.null <- base::is.null
[17:47:09.035]                     muffled <- FALSE
[17:47:09.035]                     if (inherits(cond, "message")) {
[17:47:09.035]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.035]                       if (muffled) 
[17:47:09.035]                         invokeRestart("muffleMessage")
[17:47:09.035]                     }
[17:47:09.035]                     else if (inherits(cond, "warning")) {
[17:47:09.035]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.035]                       if (muffled) 
[17:47:09.035]                         invokeRestart("muffleWarning")
[17:47:09.035]                     }
[17:47:09.035]                     else if (inherits(cond, "condition")) {
[17:47:09.035]                       if (!is.null(pattern)) {
[17:47:09.035]                         computeRestarts <- base::computeRestarts
[17:47:09.035]                         grepl <- base::grepl
[17:47:09.035]                         restarts <- computeRestarts(cond)
[17:47:09.035]                         for (restart in restarts) {
[17:47:09.035]                           name <- restart$name
[17:47:09.035]                           if (is.null(name)) 
[17:47:09.035]                             next
[17:47:09.035]                           if (!grepl(pattern, name)) 
[17:47:09.035]                             next
[17:47:09.035]                           invokeRestart(restart)
[17:47:09.035]                           muffled <- TRUE
[17:47:09.035]                           break
[17:47:09.035]                         }
[17:47:09.035]                       }
[17:47:09.035]                     }
[17:47:09.035]                     invisible(muffled)
[17:47:09.035]                   }
[17:47:09.035]                   muffleCondition(cond)
[17:47:09.035]                 })
[17:47:09.035]             }))
[17:47:09.035]             future::FutureResult(value = ...future.value$value, 
[17:47:09.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.035]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.035]                     ...future.globalenv.names))
[17:47:09.035]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.035]         }, condition = base::local({
[17:47:09.035]             c <- base::c
[17:47:09.035]             inherits <- base::inherits
[17:47:09.035]             invokeRestart <- base::invokeRestart
[17:47:09.035]             length <- base::length
[17:47:09.035]             list <- base::list
[17:47:09.035]             seq.int <- base::seq.int
[17:47:09.035]             signalCondition <- base::signalCondition
[17:47:09.035]             sys.calls <- base::sys.calls
[17:47:09.035]             `[[` <- base::`[[`
[17:47:09.035]             `+` <- base::`+`
[17:47:09.035]             `<<-` <- base::`<<-`
[17:47:09.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.035]                   3L)]
[17:47:09.035]             }
[17:47:09.035]             function(cond) {
[17:47:09.035]                 is_error <- inherits(cond, "error")
[17:47:09.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.035]                   NULL)
[17:47:09.035]                 if (is_error) {
[17:47:09.035]                   sessionInformation <- function() {
[17:47:09.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.035]                       search = base::search(), system = base::Sys.info())
[17:47:09.035]                   }
[17:47:09.035]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.035]                     cond$call), session = sessionInformation(), 
[17:47:09.035]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.035]                   signalCondition(cond)
[17:47:09.035]                 }
[17:47:09.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.035]                 "immediateCondition"))) {
[17:47:09.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.035]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.035]                   if (TRUE && !signal) {
[17:47:09.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.035]                     {
[17:47:09.035]                       inherits <- base::inherits
[17:47:09.035]                       invokeRestart <- base::invokeRestart
[17:47:09.035]                       is.null <- base::is.null
[17:47:09.035]                       muffled <- FALSE
[17:47:09.035]                       if (inherits(cond, "message")) {
[17:47:09.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.035]                         if (muffled) 
[17:47:09.035]                           invokeRestart("muffleMessage")
[17:47:09.035]                       }
[17:47:09.035]                       else if (inherits(cond, "warning")) {
[17:47:09.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.035]                         if (muffled) 
[17:47:09.035]                           invokeRestart("muffleWarning")
[17:47:09.035]                       }
[17:47:09.035]                       else if (inherits(cond, "condition")) {
[17:47:09.035]                         if (!is.null(pattern)) {
[17:47:09.035]                           computeRestarts <- base::computeRestarts
[17:47:09.035]                           grepl <- base::grepl
[17:47:09.035]                           restarts <- computeRestarts(cond)
[17:47:09.035]                           for (restart in restarts) {
[17:47:09.035]                             name <- restart$name
[17:47:09.035]                             if (is.null(name)) 
[17:47:09.035]                               next
[17:47:09.035]                             if (!grepl(pattern, name)) 
[17:47:09.035]                               next
[17:47:09.035]                             invokeRestart(restart)
[17:47:09.035]                             muffled <- TRUE
[17:47:09.035]                             break
[17:47:09.035]                           }
[17:47:09.035]                         }
[17:47:09.035]                       }
[17:47:09.035]                       invisible(muffled)
[17:47:09.035]                     }
[17:47:09.035]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.035]                   }
[17:47:09.035]                 }
[17:47:09.035]                 else {
[17:47:09.035]                   if (TRUE) {
[17:47:09.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.035]                     {
[17:47:09.035]                       inherits <- base::inherits
[17:47:09.035]                       invokeRestart <- base::invokeRestart
[17:47:09.035]                       is.null <- base::is.null
[17:47:09.035]                       muffled <- FALSE
[17:47:09.035]                       if (inherits(cond, "message")) {
[17:47:09.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.035]                         if (muffled) 
[17:47:09.035]                           invokeRestart("muffleMessage")
[17:47:09.035]                       }
[17:47:09.035]                       else if (inherits(cond, "warning")) {
[17:47:09.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.035]                         if (muffled) 
[17:47:09.035]                           invokeRestart("muffleWarning")
[17:47:09.035]                       }
[17:47:09.035]                       else if (inherits(cond, "condition")) {
[17:47:09.035]                         if (!is.null(pattern)) {
[17:47:09.035]                           computeRestarts <- base::computeRestarts
[17:47:09.035]                           grepl <- base::grepl
[17:47:09.035]                           restarts <- computeRestarts(cond)
[17:47:09.035]                           for (restart in restarts) {
[17:47:09.035]                             name <- restart$name
[17:47:09.035]                             if (is.null(name)) 
[17:47:09.035]                               next
[17:47:09.035]                             if (!grepl(pattern, name)) 
[17:47:09.035]                               next
[17:47:09.035]                             invokeRestart(restart)
[17:47:09.035]                             muffled <- TRUE
[17:47:09.035]                             break
[17:47:09.035]                           }
[17:47:09.035]                         }
[17:47:09.035]                       }
[17:47:09.035]                       invisible(muffled)
[17:47:09.035]                     }
[17:47:09.035]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.035]                   }
[17:47:09.035]                 }
[17:47:09.035]             }
[17:47:09.035]         }))
[17:47:09.035]     }, error = function(ex) {
[17:47:09.035]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.035]                 ...future.rng), started = ...future.startTime, 
[17:47:09.035]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.035]             version = "1.8"), class = "FutureResult")
[17:47:09.035]     }, finally = {
[17:47:09.035]         if (!identical(...future.workdir, getwd())) 
[17:47:09.035]             setwd(...future.workdir)
[17:47:09.035]         {
[17:47:09.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.035]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.035]             }
[17:47:09.035]             base::options(...future.oldOptions)
[17:47:09.035]             if (.Platform$OS.type == "windows") {
[17:47:09.035]                 old_names <- names(...future.oldEnvVars)
[17:47:09.035]                 envs <- base::Sys.getenv()
[17:47:09.035]                 names <- names(envs)
[17:47:09.035]                 common <- intersect(names, old_names)
[17:47:09.035]                 added <- setdiff(names, old_names)
[17:47:09.035]                 removed <- setdiff(old_names, names)
[17:47:09.035]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.035]                   envs[common]]
[17:47:09.035]                 NAMES <- toupper(changed)
[17:47:09.035]                 args <- list()
[17:47:09.035]                 for (kk in seq_along(NAMES)) {
[17:47:09.035]                   name <- changed[[kk]]
[17:47:09.035]                   NAME <- NAMES[[kk]]
[17:47:09.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.035]                     next
[17:47:09.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.035]                 }
[17:47:09.035]                 NAMES <- toupper(added)
[17:47:09.035]                 for (kk in seq_along(NAMES)) {
[17:47:09.035]                   name <- added[[kk]]
[17:47:09.035]                   NAME <- NAMES[[kk]]
[17:47:09.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.035]                     next
[17:47:09.035]                   args[[name]] <- ""
[17:47:09.035]                 }
[17:47:09.035]                 NAMES <- toupper(removed)
[17:47:09.035]                 for (kk in seq_along(NAMES)) {
[17:47:09.035]                   name <- removed[[kk]]
[17:47:09.035]                   NAME <- NAMES[[kk]]
[17:47:09.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.035]                     next
[17:47:09.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.035]                 }
[17:47:09.035]                 if (length(args) > 0) 
[17:47:09.035]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.035]             }
[17:47:09.035]             else {
[17:47:09.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.035]             }
[17:47:09.035]             {
[17:47:09.035]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.035]                   0L) {
[17:47:09.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.035]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.035]                   base::options(opts)
[17:47:09.035]                 }
[17:47:09.035]                 {
[17:47:09.035]                   {
[17:47:09.035]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.035]                     NULL
[17:47:09.035]                   }
[17:47:09.035]                   options(future.plan = NULL)
[17:47:09.035]                   if (is.na(NA_character_)) 
[17:47:09.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.035]                     .init = FALSE)
[17:47:09.035]                 }
[17:47:09.035]             }
[17:47:09.035]         }
[17:47:09.035]     })
[17:47:09.035]     if (TRUE) {
[17:47:09.035]         base::sink(type = "output", split = FALSE)
[17:47:09.035]         if (TRUE) {
[17:47:09.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.035]         }
[17:47:09.035]         else {
[17:47:09.035]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.035]         }
[17:47:09.035]         base::close(...future.stdout)
[17:47:09.035]         ...future.stdout <- NULL
[17:47:09.035]     }
[17:47:09.035]     ...future.result$conditions <- ...future.conditions
[17:47:09.035]     ...future.result$finished <- base::Sys.time()
[17:47:09.035]     ...future.result
[17:47:09.035] }
[17:47:09.087] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:47:09.087] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:47:09.087] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:47:09.087] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:47:09.088] MultisessionFuture started
[17:47:09.088] - Launch lazy future ... done
[17:47:09.088] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.089] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.089] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.090] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.090] Searching for globals ... DONE
[17:47:09.090] Resolving globals: TRUE
[17:47:09.091] Resolving any globals that are futures ...
[17:47:09.091] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.091] Resolving any globals that are futures ... DONE
[17:47:09.091] Resolving futures part of globals (recursively) ...
[17:47:09.091] resolve() on list ...
[17:47:09.091]  recursive: 99
[17:47:09.092]  length: 1
[17:47:09.092]  elements: ‘ii’
[17:47:09.092]  length: 0 (resolved future 1)
[17:47:09.092] resolve() on list ... DONE
[17:47:09.092] - globals: [1] ‘ii’
[17:47:09.092] Resolving futures part of globals (recursively) ... DONE
[17:47:09.092] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:09.092] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:09.093] - globals: [1] ‘ii’
[17:47:09.093] 
[17:47:09.093] getGlobalsAndPackages() ... DONE
[17:47:09.093] run() for ‘Future’ ...
[17:47:09.093] - state: ‘created’
[17:47:09.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.107] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.107]   - Field: ‘node’
[17:47:09.107]   - Field: ‘label’
[17:47:09.107]   - Field: ‘local’
[17:47:09.107]   - Field: ‘owner’
[17:47:09.108]   - Field: ‘envir’
[17:47:09.108]   - Field: ‘workers’
[17:47:09.108]   - Field: ‘packages’
[17:47:09.108]   - Field: ‘gc’
[17:47:09.108]   - Field: ‘conditions’
[17:47:09.108]   - Field: ‘persistent’
[17:47:09.108]   - Field: ‘expr’
[17:47:09.108]   - Field: ‘uuid’
[17:47:09.108]   - Field: ‘seed’
[17:47:09.108]   - Field: ‘version’
[17:47:09.108]   - Field: ‘result’
[17:47:09.108]   - Field: ‘asynchronous’
[17:47:09.109]   - Field: ‘calls’
[17:47:09.109]   - Field: ‘globals’
[17:47:09.109]   - Field: ‘stdout’
[17:47:09.109]   - Field: ‘earlySignal’
[17:47:09.109]   - Field: ‘lazy’
[17:47:09.109]   - Field: ‘state’
[17:47:09.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.109] - Launch lazy future ...
[17:47:09.109] Packages needed by the future expression (n = 0): <none>
[17:47:09.110] Packages needed by future strategies (n = 0): <none>
[17:47:09.110] {
[17:47:09.110]     {
[17:47:09.110]         {
[17:47:09.110]             ...future.startTime <- base::Sys.time()
[17:47:09.110]             {
[17:47:09.110]                 {
[17:47:09.110]                   {
[17:47:09.110]                     {
[17:47:09.110]                       base::local({
[17:47:09.110]                         has_future <- base::requireNamespace("future", 
[17:47:09.110]                           quietly = TRUE)
[17:47:09.110]                         if (has_future) {
[17:47:09.110]                           ns <- base::getNamespace("future")
[17:47:09.110]                           version <- ns[[".package"]][["version"]]
[17:47:09.110]                           if (is.null(version)) 
[17:47:09.110]                             version <- utils::packageVersion("future")
[17:47:09.110]                         }
[17:47:09.110]                         else {
[17:47:09.110]                           version <- NULL
[17:47:09.110]                         }
[17:47:09.110]                         if (!has_future || version < "1.8.0") {
[17:47:09.110]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.110]                             "", base::R.version$version.string), 
[17:47:09.110]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:09.110]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.110]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.110]                               "release", "version")], collapse = " "), 
[17:47:09.110]                             hostname = base::Sys.info()[["nodename"]])
[17:47:09.110]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.110]                             info)
[17:47:09.110]                           info <- base::paste(info, collapse = "; ")
[17:47:09.110]                           if (!has_future) {
[17:47:09.110]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.110]                               info)
[17:47:09.110]                           }
[17:47:09.110]                           else {
[17:47:09.110]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.110]                               info, version)
[17:47:09.110]                           }
[17:47:09.110]                           base::stop(msg)
[17:47:09.110]                         }
[17:47:09.110]                       })
[17:47:09.110]                     }
[17:47:09.110]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.110]                     base::options(mc.cores = 1L)
[17:47:09.110]                   }
[17:47:09.110]                   ...future.strategy.old <- future::plan("list")
[17:47:09.110]                   options(future.plan = NULL)
[17:47:09.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.110]                 }
[17:47:09.110]                 ...future.workdir <- getwd()
[17:47:09.110]             }
[17:47:09.110]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.110]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.110]         }
[17:47:09.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.110]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.110]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.110]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.110]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.110]             base::names(...future.oldOptions))
[17:47:09.110]     }
[17:47:09.110]     if (FALSE) {
[17:47:09.110]     }
[17:47:09.110]     else {
[17:47:09.110]         if (TRUE) {
[17:47:09.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.110]                 open = "w")
[17:47:09.110]         }
[17:47:09.110]         else {
[17:47:09.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.110]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.110]         }
[17:47:09.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.110]             base::sink(type = "output", split = FALSE)
[17:47:09.110]             base::close(...future.stdout)
[17:47:09.110]         }, add = TRUE)
[17:47:09.110]     }
[17:47:09.110]     ...future.frame <- base::sys.nframe()
[17:47:09.110]     ...future.conditions <- base::list()
[17:47:09.110]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.110]     if (FALSE) {
[17:47:09.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.110]     }
[17:47:09.110]     ...future.result <- base::tryCatch({
[17:47:09.110]         base::withCallingHandlers({
[17:47:09.110]             ...future.value <- base::withVisible(base::local({
[17:47:09.110]                 ...future.makeSendCondition <- base::local({
[17:47:09.110]                   sendCondition <- NULL
[17:47:09.110]                   function(frame = 1L) {
[17:47:09.110]                     if (is.function(sendCondition)) 
[17:47:09.110]                       return(sendCondition)
[17:47:09.110]                     ns <- getNamespace("parallel")
[17:47:09.110]                     if (exists("sendData", mode = "function", 
[17:47:09.110]                       envir = ns)) {
[17:47:09.110]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.110]                         envir = ns)
[17:47:09.110]                       envir <- sys.frame(frame)
[17:47:09.110]                       master <- NULL
[17:47:09.110]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.110]                         !identical(envir, emptyenv())) {
[17:47:09.110]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.110]                           inherits = FALSE)) {
[17:47:09.110]                           master <- get("master", mode = "list", 
[17:47:09.110]                             envir = envir, inherits = FALSE)
[17:47:09.110]                           if (inherits(master, c("SOCKnode", 
[17:47:09.110]                             "SOCK0node"))) {
[17:47:09.110]                             sendCondition <<- function(cond) {
[17:47:09.110]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.110]                                 success = TRUE)
[17:47:09.110]                               parallel_sendData(master, data)
[17:47:09.110]                             }
[17:47:09.110]                             return(sendCondition)
[17:47:09.110]                           }
[17:47:09.110]                         }
[17:47:09.110]                         frame <- frame + 1L
[17:47:09.110]                         envir <- sys.frame(frame)
[17:47:09.110]                       }
[17:47:09.110]                     }
[17:47:09.110]                     sendCondition <<- function(cond) NULL
[17:47:09.110]                   }
[17:47:09.110]                 })
[17:47:09.110]                 withCallingHandlers({
[17:47:09.110]                   {
[17:47:09.110]                     b <- a * ii
[17:47:09.110]                     a <- 0
[17:47:09.110]                     b
[17:47:09.110]                   }
[17:47:09.110]                 }, immediateCondition = function(cond) {
[17:47:09.110]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.110]                   sendCondition(cond)
[17:47:09.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.110]                   {
[17:47:09.110]                     inherits <- base::inherits
[17:47:09.110]                     invokeRestart <- base::invokeRestart
[17:47:09.110]                     is.null <- base::is.null
[17:47:09.110]                     muffled <- FALSE
[17:47:09.110]                     if (inherits(cond, "message")) {
[17:47:09.110]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.110]                       if (muffled) 
[17:47:09.110]                         invokeRestart("muffleMessage")
[17:47:09.110]                     }
[17:47:09.110]                     else if (inherits(cond, "warning")) {
[17:47:09.110]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.110]                       if (muffled) 
[17:47:09.110]                         invokeRestart("muffleWarning")
[17:47:09.110]                     }
[17:47:09.110]                     else if (inherits(cond, "condition")) {
[17:47:09.110]                       if (!is.null(pattern)) {
[17:47:09.110]                         computeRestarts <- base::computeRestarts
[17:47:09.110]                         grepl <- base::grepl
[17:47:09.110]                         restarts <- computeRestarts(cond)
[17:47:09.110]                         for (restart in restarts) {
[17:47:09.110]                           name <- restart$name
[17:47:09.110]                           if (is.null(name)) 
[17:47:09.110]                             next
[17:47:09.110]                           if (!grepl(pattern, name)) 
[17:47:09.110]                             next
[17:47:09.110]                           invokeRestart(restart)
[17:47:09.110]                           muffled <- TRUE
[17:47:09.110]                           break
[17:47:09.110]                         }
[17:47:09.110]                       }
[17:47:09.110]                     }
[17:47:09.110]                     invisible(muffled)
[17:47:09.110]                   }
[17:47:09.110]                   muffleCondition(cond)
[17:47:09.110]                 })
[17:47:09.110]             }))
[17:47:09.110]             future::FutureResult(value = ...future.value$value, 
[17:47:09.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.110]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.110]                     ...future.globalenv.names))
[17:47:09.110]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.110]         }, condition = base::local({
[17:47:09.110]             c <- base::c
[17:47:09.110]             inherits <- base::inherits
[17:47:09.110]             invokeRestart <- base::invokeRestart
[17:47:09.110]             length <- base::length
[17:47:09.110]             list <- base::list
[17:47:09.110]             seq.int <- base::seq.int
[17:47:09.110]             signalCondition <- base::signalCondition
[17:47:09.110]             sys.calls <- base::sys.calls
[17:47:09.110]             `[[` <- base::`[[`
[17:47:09.110]             `+` <- base::`+`
[17:47:09.110]             `<<-` <- base::`<<-`
[17:47:09.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.110]                   3L)]
[17:47:09.110]             }
[17:47:09.110]             function(cond) {
[17:47:09.110]                 is_error <- inherits(cond, "error")
[17:47:09.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.110]                   NULL)
[17:47:09.110]                 if (is_error) {
[17:47:09.110]                   sessionInformation <- function() {
[17:47:09.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.110]                       search = base::search(), system = base::Sys.info())
[17:47:09.110]                   }
[17:47:09.110]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.110]                     cond$call), session = sessionInformation(), 
[17:47:09.110]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.110]                   signalCondition(cond)
[17:47:09.110]                 }
[17:47:09.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.110]                 "immediateCondition"))) {
[17:47:09.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.110]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.110]                   if (TRUE && !signal) {
[17:47:09.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.110]                     {
[17:47:09.110]                       inherits <- base::inherits
[17:47:09.110]                       invokeRestart <- base::invokeRestart
[17:47:09.110]                       is.null <- base::is.null
[17:47:09.110]                       muffled <- FALSE
[17:47:09.110]                       if (inherits(cond, "message")) {
[17:47:09.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.110]                         if (muffled) 
[17:47:09.110]                           invokeRestart("muffleMessage")
[17:47:09.110]                       }
[17:47:09.110]                       else if (inherits(cond, "warning")) {
[17:47:09.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.110]                         if (muffled) 
[17:47:09.110]                           invokeRestart("muffleWarning")
[17:47:09.110]                       }
[17:47:09.110]                       else if (inherits(cond, "condition")) {
[17:47:09.110]                         if (!is.null(pattern)) {
[17:47:09.110]                           computeRestarts <- base::computeRestarts
[17:47:09.110]                           grepl <- base::grepl
[17:47:09.110]                           restarts <- computeRestarts(cond)
[17:47:09.110]                           for (restart in restarts) {
[17:47:09.110]                             name <- restart$name
[17:47:09.110]                             if (is.null(name)) 
[17:47:09.110]                               next
[17:47:09.110]                             if (!grepl(pattern, name)) 
[17:47:09.110]                               next
[17:47:09.110]                             invokeRestart(restart)
[17:47:09.110]                             muffled <- TRUE
[17:47:09.110]                             break
[17:47:09.110]                           }
[17:47:09.110]                         }
[17:47:09.110]                       }
[17:47:09.110]                       invisible(muffled)
[17:47:09.110]                     }
[17:47:09.110]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.110]                   }
[17:47:09.110]                 }
[17:47:09.110]                 else {
[17:47:09.110]                   if (TRUE) {
[17:47:09.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.110]                     {
[17:47:09.110]                       inherits <- base::inherits
[17:47:09.110]                       invokeRestart <- base::invokeRestart
[17:47:09.110]                       is.null <- base::is.null
[17:47:09.110]                       muffled <- FALSE
[17:47:09.110]                       if (inherits(cond, "message")) {
[17:47:09.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.110]                         if (muffled) 
[17:47:09.110]                           invokeRestart("muffleMessage")
[17:47:09.110]                       }
[17:47:09.110]                       else if (inherits(cond, "warning")) {
[17:47:09.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.110]                         if (muffled) 
[17:47:09.110]                           invokeRestart("muffleWarning")
[17:47:09.110]                       }
[17:47:09.110]                       else if (inherits(cond, "condition")) {
[17:47:09.110]                         if (!is.null(pattern)) {
[17:47:09.110]                           computeRestarts <- base::computeRestarts
[17:47:09.110]                           grepl <- base::grepl
[17:47:09.110]                           restarts <- computeRestarts(cond)
[17:47:09.110]                           for (restart in restarts) {
[17:47:09.110]                             name <- restart$name
[17:47:09.110]                             if (is.null(name)) 
[17:47:09.110]                               next
[17:47:09.110]                             if (!grepl(pattern, name)) 
[17:47:09.110]                               next
[17:47:09.110]                             invokeRestart(restart)
[17:47:09.110]                             muffled <- TRUE
[17:47:09.110]                             break
[17:47:09.110]                           }
[17:47:09.110]                         }
[17:47:09.110]                       }
[17:47:09.110]                       invisible(muffled)
[17:47:09.110]                     }
[17:47:09.110]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.110]                   }
[17:47:09.110]                 }
[17:47:09.110]             }
[17:47:09.110]         }))
[17:47:09.110]     }, error = function(ex) {
[17:47:09.110]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.110]                 ...future.rng), started = ...future.startTime, 
[17:47:09.110]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.110]             version = "1.8"), class = "FutureResult")
[17:47:09.110]     }, finally = {
[17:47:09.110]         if (!identical(...future.workdir, getwd())) 
[17:47:09.110]             setwd(...future.workdir)
[17:47:09.110]         {
[17:47:09.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.110]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.110]             }
[17:47:09.110]             base::options(...future.oldOptions)
[17:47:09.110]             if (.Platform$OS.type == "windows") {
[17:47:09.110]                 old_names <- names(...future.oldEnvVars)
[17:47:09.110]                 envs <- base::Sys.getenv()
[17:47:09.110]                 names <- names(envs)
[17:47:09.110]                 common <- intersect(names, old_names)
[17:47:09.110]                 added <- setdiff(names, old_names)
[17:47:09.110]                 removed <- setdiff(old_names, names)
[17:47:09.110]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.110]                   envs[common]]
[17:47:09.110]                 NAMES <- toupper(changed)
[17:47:09.110]                 args <- list()
[17:47:09.110]                 for (kk in seq_along(NAMES)) {
[17:47:09.110]                   name <- changed[[kk]]
[17:47:09.110]                   NAME <- NAMES[[kk]]
[17:47:09.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.110]                     next
[17:47:09.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.110]                 }
[17:47:09.110]                 NAMES <- toupper(added)
[17:47:09.110]                 for (kk in seq_along(NAMES)) {
[17:47:09.110]                   name <- added[[kk]]
[17:47:09.110]                   NAME <- NAMES[[kk]]
[17:47:09.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.110]                     next
[17:47:09.110]                   args[[name]] <- ""
[17:47:09.110]                 }
[17:47:09.110]                 NAMES <- toupper(removed)
[17:47:09.110]                 for (kk in seq_along(NAMES)) {
[17:47:09.110]                   name <- removed[[kk]]
[17:47:09.110]                   NAME <- NAMES[[kk]]
[17:47:09.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.110]                     next
[17:47:09.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.110]                 }
[17:47:09.110]                 if (length(args) > 0) 
[17:47:09.110]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.110]             }
[17:47:09.110]             else {
[17:47:09.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.110]             }
[17:47:09.110]             {
[17:47:09.110]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.110]                   0L) {
[17:47:09.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.110]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.110]                   base::options(opts)
[17:47:09.110]                 }
[17:47:09.110]                 {
[17:47:09.110]                   {
[17:47:09.110]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.110]                     NULL
[17:47:09.110]                   }
[17:47:09.110]                   options(future.plan = NULL)
[17:47:09.110]                   if (is.na(NA_character_)) 
[17:47:09.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.110]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.110]                     .init = FALSE)
[17:47:09.110]                 }
[17:47:09.110]             }
[17:47:09.110]         }
[17:47:09.110]     })
[17:47:09.110]     if (TRUE) {
[17:47:09.110]         base::sink(type = "output", split = FALSE)
[17:47:09.110]         if (TRUE) {
[17:47:09.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.110]         }
[17:47:09.110]         else {
[17:47:09.110]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.110]         }
[17:47:09.110]         base::close(...future.stdout)
[17:47:09.110]         ...future.stdout <- NULL
[17:47:09.110]     }
[17:47:09.110]     ...future.result$conditions <- ...future.conditions
[17:47:09.110]     ...future.result$finished <- base::Sys.time()
[17:47:09.110]     ...future.result
[17:47:09.110] }
[17:47:09.112] Poll #1 (0): usedNodes() = 2, workers = 2
[17:47:09.123] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.123] - Validating connection of MultisessionFuture
[17:47:09.124] - received message: FutureResult
[17:47:09.124] - Received FutureResult
[17:47:09.124] - Erased future from FutureRegistry
[17:47:09.124] result() for ClusterFuture ...
[17:47:09.124] - result already collected: FutureResult
[17:47:09.124] result() for ClusterFuture ... done
[17:47:09.124] signalConditions() ...
[17:47:09.124]  - include = ‘immediateCondition’
[17:47:09.125]  - exclude = 
[17:47:09.125]  - resignal = FALSE
[17:47:09.125]  - Number of conditions: 1
[17:47:09.125] signalConditions() ... done
[17:47:09.125] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.125] result() for ClusterFuture ...
[17:47:09.125] - result already collected: FutureResult
[17:47:09.125] result() for ClusterFuture ... done
[17:47:09.125] result() for ClusterFuture ...
[17:47:09.125] - result already collected: FutureResult
[17:47:09.125] result() for ClusterFuture ... done
[17:47:09.125] signalConditions() ...
[17:47:09.126]  - include = ‘immediateCondition’
[17:47:09.126]  - exclude = 
[17:47:09.126]  - resignal = FALSE
[17:47:09.126]  - Number of conditions: 1
[17:47:09.126] signalConditions() ... done
[17:47:09.127] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:47:09.127] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:47:09.127] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:47:09.127] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:47:09.128] MultisessionFuture started
[17:47:09.128] - Launch lazy future ... done
[17:47:09.128] run() for ‘MultisessionFuture’ ... done
[17:47:09.128] result() for ClusterFuture ...
[17:47:09.129] - result already collected: FutureResult
[17:47:09.129] result() for ClusterFuture ... done
[17:47:09.129] result() for ClusterFuture ...
[17:47:09.129] - result already collected: FutureResult
[17:47:09.129] result() for ClusterFuture ... done
[17:47:09.129] signalConditions() ...
[17:47:09.129]  - include = ‘immediateCondition’
[17:47:09.130]  - exclude = 
[17:47:09.130]  - resignal = FALSE
[17:47:09.130]  - Number of conditions: 1
[17:47:09.130] signalConditions() ... done
[17:47:09.130] Future state: ‘finished’
[17:47:09.130] result() for ClusterFuture ...
[17:47:09.131] - result already collected: FutureResult
[17:47:09.131] result() for ClusterFuture ... done
[17:47:09.131] signalConditions() ...
[17:47:09.131]  - include = ‘condition’
[17:47:09.131]  - exclude = ‘immediateCondition’
[17:47:09.131]  - resignal = TRUE
[17:47:09.131]  - Number of conditions: 1
[17:47:09.131]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:47:09.131] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-22 17:47:09"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.146] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.146] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.148] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.148] Searching for globals ... DONE
[17:47:09.148] Resolving globals: TRUE
[17:47:09.148] Resolving any globals that are futures ...
[17:47:09.148] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.148] Resolving any globals that are futures ... DONE
[17:47:09.149] Resolving futures part of globals (recursively) ...
[17:47:09.149] resolve() on list ...
[17:47:09.149]  recursive: 99
[17:47:09.149]  length: 1
[17:47:09.149]  elements: ‘ii’
[17:47:09.149]  length: 0 (resolved future 1)
[17:47:09.149] resolve() on list ... DONE
[17:47:09.149] - globals: [1] ‘ii’
[17:47:09.149] Resolving futures part of globals (recursively) ... DONE
[17:47:09.150] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:09.150] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:09.150] - globals: [1] ‘ii’
[17:47:09.150] 
[17:47:09.150] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.151] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.151] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.152] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.152] Searching for globals ... DONE
[17:47:09.152] Resolving globals: TRUE
[17:47:09.152] Resolving any globals that are futures ...
[17:47:09.153] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.153] Resolving any globals that are futures ... DONE
[17:47:09.153] Resolving futures part of globals (recursively) ...
[17:47:09.153] resolve() on list ...
[17:47:09.153]  recursive: 99
[17:47:09.153]  length: 1
[17:47:09.153]  elements: ‘ii’
[17:47:09.153]  length: 0 (resolved future 1)
[17:47:09.154] resolve() on list ... DONE
[17:47:09.154] - globals: [1] ‘ii’
[17:47:09.154] Resolving futures part of globals (recursively) ... DONE
[17:47:09.154] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:09.154] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:09.154] - globals: [1] ‘ii’
[17:47:09.154] 
[17:47:09.154] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.155] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.155] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.156] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.156] Searching for globals ... DONE
[17:47:09.157] Resolving globals: TRUE
[17:47:09.157] Resolving any globals that are futures ...
[17:47:09.157] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:47:09.157] Resolving any globals that are futures ... DONE
[17:47:09.157] Resolving futures part of globals (recursively) ...
[17:47:09.157] resolve() on list ...
[17:47:09.157]  recursive: 99
[17:47:09.158]  length: 1
[17:47:09.158]  elements: ‘ii’
[17:47:09.158]  length: 0 (resolved future 1)
[17:47:09.158] resolve() on list ... DONE
[17:47:09.158] - globals: [1] ‘ii’
[17:47:09.158] Resolving futures part of globals (recursively) ... DONE
[17:47:09.158] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:09.158] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:47:09.159] - globals: [1] ‘ii’
[17:47:09.159] 
[17:47:09.159] getGlobalsAndPackages() ... DONE
[17:47:09.159] run() for ‘Future’ ...
[17:47:09.159] - state: ‘created’
[17:47:09.159] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.174] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.174]   - Field: ‘node’
[17:47:09.174]   - Field: ‘label’
[17:47:09.174]   - Field: ‘local’
[17:47:09.175]   - Field: ‘owner’
[17:47:09.175]   - Field: ‘envir’
[17:47:09.175]   - Field: ‘workers’
[17:47:09.175]   - Field: ‘packages’
[17:47:09.175]   - Field: ‘gc’
[17:47:09.175]   - Field: ‘conditions’
[17:47:09.175]   - Field: ‘persistent’
[17:47:09.175]   - Field: ‘expr’
[17:47:09.175]   - Field: ‘uuid’
[17:47:09.175]   - Field: ‘seed’
[17:47:09.175]   - Field: ‘version’
[17:47:09.176]   - Field: ‘result’
[17:47:09.176]   - Field: ‘asynchronous’
[17:47:09.176]   - Field: ‘calls’
[17:47:09.176]   - Field: ‘globals’
[17:47:09.176]   - Field: ‘stdout’
[17:47:09.176]   - Field: ‘earlySignal’
[17:47:09.176]   - Field: ‘lazy’
[17:47:09.176]   - Field: ‘state’
[17:47:09.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.176] - Launch lazy future ...
[17:47:09.177] Packages needed by the future expression (n = 0): <none>
[17:47:09.177] Packages needed by future strategies (n = 0): <none>
[17:47:09.177] {
[17:47:09.177]     {
[17:47:09.177]         {
[17:47:09.177]             ...future.startTime <- base::Sys.time()
[17:47:09.177]             {
[17:47:09.177]                 {
[17:47:09.177]                   {
[17:47:09.177]                     {
[17:47:09.177]                       base::local({
[17:47:09.177]                         has_future <- base::requireNamespace("future", 
[17:47:09.177]                           quietly = TRUE)
[17:47:09.177]                         if (has_future) {
[17:47:09.177]                           ns <- base::getNamespace("future")
[17:47:09.177]                           version <- ns[[".package"]][["version"]]
[17:47:09.177]                           if (is.null(version)) 
[17:47:09.177]                             version <- utils::packageVersion("future")
[17:47:09.177]                         }
[17:47:09.177]                         else {
[17:47:09.177]                           version <- NULL
[17:47:09.177]                         }
[17:47:09.177]                         if (!has_future || version < "1.8.0") {
[17:47:09.177]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.177]                             "", base::R.version$version.string), 
[17:47:09.177]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:09.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.177]                               "release", "version")], collapse = " "), 
[17:47:09.177]                             hostname = base::Sys.info()[["nodename"]])
[17:47:09.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.177]                             info)
[17:47:09.177]                           info <- base::paste(info, collapse = "; ")
[17:47:09.177]                           if (!has_future) {
[17:47:09.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.177]                               info)
[17:47:09.177]                           }
[17:47:09.177]                           else {
[17:47:09.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.177]                               info, version)
[17:47:09.177]                           }
[17:47:09.177]                           base::stop(msg)
[17:47:09.177]                         }
[17:47:09.177]                       })
[17:47:09.177]                     }
[17:47:09.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.177]                     base::options(mc.cores = 1L)
[17:47:09.177]                   }
[17:47:09.177]                   ...future.strategy.old <- future::plan("list")
[17:47:09.177]                   options(future.plan = NULL)
[17:47:09.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.177]                 }
[17:47:09.177]                 ...future.workdir <- getwd()
[17:47:09.177]             }
[17:47:09.177]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.177]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.177]         }
[17:47:09.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.177]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.177]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.177]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.177]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.177]             base::names(...future.oldOptions))
[17:47:09.177]     }
[17:47:09.177]     if (FALSE) {
[17:47:09.177]     }
[17:47:09.177]     else {
[17:47:09.177]         if (TRUE) {
[17:47:09.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.177]                 open = "w")
[17:47:09.177]         }
[17:47:09.177]         else {
[17:47:09.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.177]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.177]         }
[17:47:09.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.177]             base::sink(type = "output", split = FALSE)
[17:47:09.177]             base::close(...future.stdout)
[17:47:09.177]         }, add = TRUE)
[17:47:09.177]     }
[17:47:09.177]     ...future.frame <- base::sys.nframe()
[17:47:09.177]     ...future.conditions <- base::list()
[17:47:09.177]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.177]     if (FALSE) {
[17:47:09.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.177]     }
[17:47:09.177]     ...future.result <- base::tryCatch({
[17:47:09.177]         base::withCallingHandlers({
[17:47:09.177]             ...future.value <- base::withVisible(base::local({
[17:47:09.177]                 ...future.makeSendCondition <- base::local({
[17:47:09.177]                   sendCondition <- NULL
[17:47:09.177]                   function(frame = 1L) {
[17:47:09.177]                     if (is.function(sendCondition)) 
[17:47:09.177]                       return(sendCondition)
[17:47:09.177]                     ns <- getNamespace("parallel")
[17:47:09.177]                     if (exists("sendData", mode = "function", 
[17:47:09.177]                       envir = ns)) {
[17:47:09.177]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.177]                         envir = ns)
[17:47:09.177]                       envir <- sys.frame(frame)
[17:47:09.177]                       master <- NULL
[17:47:09.177]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.177]                         !identical(envir, emptyenv())) {
[17:47:09.177]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.177]                           inherits = FALSE)) {
[17:47:09.177]                           master <- get("master", mode = "list", 
[17:47:09.177]                             envir = envir, inherits = FALSE)
[17:47:09.177]                           if (inherits(master, c("SOCKnode", 
[17:47:09.177]                             "SOCK0node"))) {
[17:47:09.177]                             sendCondition <<- function(cond) {
[17:47:09.177]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.177]                                 success = TRUE)
[17:47:09.177]                               parallel_sendData(master, data)
[17:47:09.177]                             }
[17:47:09.177]                             return(sendCondition)
[17:47:09.177]                           }
[17:47:09.177]                         }
[17:47:09.177]                         frame <- frame + 1L
[17:47:09.177]                         envir <- sys.frame(frame)
[17:47:09.177]                       }
[17:47:09.177]                     }
[17:47:09.177]                     sendCondition <<- function(cond) NULL
[17:47:09.177]                   }
[17:47:09.177]                 })
[17:47:09.177]                 withCallingHandlers({
[17:47:09.177]                   {
[17:47:09.177]                     b <- a * ii
[17:47:09.177]                     a <- 0
[17:47:09.177]                     b
[17:47:09.177]                   }
[17:47:09.177]                 }, immediateCondition = function(cond) {
[17:47:09.177]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.177]                   sendCondition(cond)
[17:47:09.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.177]                   {
[17:47:09.177]                     inherits <- base::inherits
[17:47:09.177]                     invokeRestart <- base::invokeRestart
[17:47:09.177]                     is.null <- base::is.null
[17:47:09.177]                     muffled <- FALSE
[17:47:09.177]                     if (inherits(cond, "message")) {
[17:47:09.177]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.177]                       if (muffled) 
[17:47:09.177]                         invokeRestart("muffleMessage")
[17:47:09.177]                     }
[17:47:09.177]                     else if (inherits(cond, "warning")) {
[17:47:09.177]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.177]                       if (muffled) 
[17:47:09.177]                         invokeRestart("muffleWarning")
[17:47:09.177]                     }
[17:47:09.177]                     else if (inherits(cond, "condition")) {
[17:47:09.177]                       if (!is.null(pattern)) {
[17:47:09.177]                         computeRestarts <- base::computeRestarts
[17:47:09.177]                         grepl <- base::grepl
[17:47:09.177]                         restarts <- computeRestarts(cond)
[17:47:09.177]                         for (restart in restarts) {
[17:47:09.177]                           name <- restart$name
[17:47:09.177]                           if (is.null(name)) 
[17:47:09.177]                             next
[17:47:09.177]                           if (!grepl(pattern, name)) 
[17:47:09.177]                             next
[17:47:09.177]                           invokeRestart(restart)
[17:47:09.177]                           muffled <- TRUE
[17:47:09.177]                           break
[17:47:09.177]                         }
[17:47:09.177]                       }
[17:47:09.177]                     }
[17:47:09.177]                     invisible(muffled)
[17:47:09.177]                   }
[17:47:09.177]                   muffleCondition(cond)
[17:47:09.177]                 })
[17:47:09.177]             }))
[17:47:09.177]             future::FutureResult(value = ...future.value$value, 
[17:47:09.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.177]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.177]                     ...future.globalenv.names))
[17:47:09.177]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.177]         }, condition = base::local({
[17:47:09.177]             c <- base::c
[17:47:09.177]             inherits <- base::inherits
[17:47:09.177]             invokeRestart <- base::invokeRestart
[17:47:09.177]             length <- base::length
[17:47:09.177]             list <- base::list
[17:47:09.177]             seq.int <- base::seq.int
[17:47:09.177]             signalCondition <- base::signalCondition
[17:47:09.177]             sys.calls <- base::sys.calls
[17:47:09.177]             `[[` <- base::`[[`
[17:47:09.177]             `+` <- base::`+`
[17:47:09.177]             `<<-` <- base::`<<-`
[17:47:09.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.177]                   3L)]
[17:47:09.177]             }
[17:47:09.177]             function(cond) {
[17:47:09.177]                 is_error <- inherits(cond, "error")
[17:47:09.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.177]                   NULL)
[17:47:09.177]                 if (is_error) {
[17:47:09.177]                   sessionInformation <- function() {
[17:47:09.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.177]                       search = base::search(), system = base::Sys.info())
[17:47:09.177]                   }
[17:47:09.177]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.177]                     cond$call), session = sessionInformation(), 
[17:47:09.177]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.177]                   signalCondition(cond)
[17:47:09.177]                 }
[17:47:09.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.177]                 "immediateCondition"))) {
[17:47:09.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.177]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.177]                   if (TRUE && !signal) {
[17:47:09.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.177]                     {
[17:47:09.177]                       inherits <- base::inherits
[17:47:09.177]                       invokeRestart <- base::invokeRestart
[17:47:09.177]                       is.null <- base::is.null
[17:47:09.177]                       muffled <- FALSE
[17:47:09.177]                       if (inherits(cond, "message")) {
[17:47:09.177]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.177]                         if (muffled) 
[17:47:09.177]                           invokeRestart("muffleMessage")
[17:47:09.177]                       }
[17:47:09.177]                       else if (inherits(cond, "warning")) {
[17:47:09.177]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.177]                         if (muffled) 
[17:47:09.177]                           invokeRestart("muffleWarning")
[17:47:09.177]                       }
[17:47:09.177]                       else if (inherits(cond, "condition")) {
[17:47:09.177]                         if (!is.null(pattern)) {
[17:47:09.177]                           computeRestarts <- base::computeRestarts
[17:47:09.177]                           grepl <- base::grepl
[17:47:09.177]                           restarts <- computeRestarts(cond)
[17:47:09.177]                           for (restart in restarts) {
[17:47:09.177]                             name <- restart$name
[17:47:09.177]                             if (is.null(name)) 
[17:47:09.177]                               next
[17:47:09.177]                             if (!grepl(pattern, name)) 
[17:47:09.177]                               next
[17:47:09.177]                             invokeRestart(restart)
[17:47:09.177]                             muffled <- TRUE
[17:47:09.177]                             break
[17:47:09.177]                           }
[17:47:09.177]                         }
[17:47:09.177]                       }
[17:47:09.177]                       invisible(muffled)
[17:47:09.177]                     }
[17:47:09.177]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.177]                   }
[17:47:09.177]                 }
[17:47:09.177]                 else {
[17:47:09.177]                   if (TRUE) {
[17:47:09.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.177]                     {
[17:47:09.177]                       inherits <- base::inherits
[17:47:09.177]                       invokeRestart <- base::invokeRestart
[17:47:09.177]                       is.null <- base::is.null
[17:47:09.177]                       muffled <- FALSE
[17:47:09.177]                       if (inherits(cond, "message")) {
[17:47:09.177]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.177]                         if (muffled) 
[17:47:09.177]                           invokeRestart("muffleMessage")
[17:47:09.177]                       }
[17:47:09.177]                       else if (inherits(cond, "warning")) {
[17:47:09.177]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.177]                         if (muffled) 
[17:47:09.177]                           invokeRestart("muffleWarning")
[17:47:09.177]                       }
[17:47:09.177]                       else if (inherits(cond, "condition")) {
[17:47:09.177]                         if (!is.null(pattern)) {
[17:47:09.177]                           computeRestarts <- base::computeRestarts
[17:47:09.177]                           grepl <- base::grepl
[17:47:09.177]                           restarts <- computeRestarts(cond)
[17:47:09.177]                           for (restart in restarts) {
[17:47:09.177]                             name <- restart$name
[17:47:09.177]                             if (is.null(name)) 
[17:47:09.177]                               next
[17:47:09.177]                             if (!grepl(pattern, name)) 
[17:47:09.177]                               next
[17:47:09.177]                             invokeRestart(restart)
[17:47:09.177]                             muffled <- TRUE
[17:47:09.177]                             break
[17:47:09.177]                           }
[17:47:09.177]                         }
[17:47:09.177]                       }
[17:47:09.177]                       invisible(muffled)
[17:47:09.177]                     }
[17:47:09.177]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.177]                   }
[17:47:09.177]                 }
[17:47:09.177]             }
[17:47:09.177]         }))
[17:47:09.177]     }, error = function(ex) {
[17:47:09.177]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.177]                 ...future.rng), started = ...future.startTime, 
[17:47:09.177]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.177]             version = "1.8"), class = "FutureResult")
[17:47:09.177]     }, finally = {
[17:47:09.177]         if (!identical(...future.workdir, getwd())) 
[17:47:09.177]             setwd(...future.workdir)
[17:47:09.177]         {
[17:47:09.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.177]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.177]             }
[17:47:09.177]             base::options(...future.oldOptions)
[17:47:09.177]             if (.Platform$OS.type == "windows") {
[17:47:09.177]                 old_names <- names(...future.oldEnvVars)
[17:47:09.177]                 envs <- base::Sys.getenv()
[17:47:09.177]                 names <- names(envs)
[17:47:09.177]                 common <- intersect(names, old_names)
[17:47:09.177]                 added <- setdiff(names, old_names)
[17:47:09.177]                 removed <- setdiff(old_names, names)
[17:47:09.177]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.177]                   envs[common]]
[17:47:09.177]                 NAMES <- toupper(changed)
[17:47:09.177]                 args <- list()
[17:47:09.177]                 for (kk in seq_along(NAMES)) {
[17:47:09.177]                   name <- changed[[kk]]
[17:47:09.177]                   NAME <- NAMES[[kk]]
[17:47:09.177]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.177]                     next
[17:47:09.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.177]                 }
[17:47:09.177]                 NAMES <- toupper(added)
[17:47:09.177]                 for (kk in seq_along(NAMES)) {
[17:47:09.177]                   name <- added[[kk]]
[17:47:09.177]                   NAME <- NAMES[[kk]]
[17:47:09.177]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.177]                     next
[17:47:09.177]                   args[[name]] <- ""
[17:47:09.177]                 }
[17:47:09.177]                 NAMES <- toupper(removed)
[17:47:09.177]                 for (kk in seq_along(NAMES)) {
[17:47:09.177]                   name <- removed[[kk]]
[17:47:09.177]                   NAME <- NAMES[[kk]]
[17:47:09.177]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.177]                     next
[17:47:09.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.177]                 }
[17:47:09.177]                 if (length(args) > 0) 
[17:47:09.177]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.177]             }
[17:47:09.177]             else {
[17:47:09.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.177]             }
[17:47:09.177]             {
[17:47:09.177]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.177]                   0L) {
[17:47:09.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.177]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.177]                   base::options(opts)
[17:47:09.177]                 }
[17:47:09.177]                 {
[17:47:09.177]                   {
[17:47:09.177]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.177]                     NULL
[17:47:09.177]                   }
[17:47:09.177]                   options(future.plan = NULL)
[17:47:09.177]                   if (is.na(NA_character_)) 
[17:47:09.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.177]                     .init = FALSE)
[17:47:09.177]                 }
[17:47:09.177]             }
[17:47:09.177]         }
[17:47:09.177]     })
[17:47:09.177]     if (TRUE) {
[17:47:09.177]         base::sink(type = "output", split = FALSE)
[17:47:09.177]         if (TRUE) {
[17:47:09.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.177]         }
[17:47:09.177]         else {
[17:47:09.177]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.177]         }
[17:47:09.177]         base::close(...future.stdout)
[17:47:09.177]         ...future.stdout <- NULL
[17:47:09.177]     }
[17:47:09.177]     ...future.result$conditions <- ...future.conditions
[17:47:09.177]     ...future.result$finished <- base::Sys.time()
[17:47:09.177]     ...future.result
[17:47:09.177] }
[17:47:09.179] Poll #1 (0): usedNodes() = 2, workers = 2
[17:47:09.190] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.190] - Validating connection of MultisessionFuture
[17:47:09.191] - received message: FutureResult
[17:47:09.191] - Received FutureResult
[17:47:09.191] - Erased future from FutureRegistry
[17:47:09.191] result() for ClusterFuture ...
[17:47:09.191] - result already collected: FutureResult
[17:47:09.191] result() for ClusterFuture ... done
[17:47:09.191] signalConditions() ...
[17:47:09.191]  - include = ‘immediateCondition’
[17:47:09.191]  - exclude = 
[17:47:09.192]  - resignal = FALSE
[17:47:09.192]  - Number of conditions: 1
[17:47:09.192] signalConditions() ... done
[17:47:09.192] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.192] result() for ClusterFuture ...
[17:47:09.192] - result already collected: FutureResult
[17:47:09.192] result() for ClusterFuture ... done
[17:47:09.192] result() for ClusterFuture ...
[17:47:09.192] - result already collected: FutureResult
[17:47:09.192] result() for ClusterFuture ... done
[17:47:09.192] signalConditions() ...
[17:47:09.192]  - include = ‘immediateCondition’
[17:47:09.193]  - exclude = 
[17:47:09.193]  - resignal = FALSE
[17:47:09.193]  - Number of conditions: 1
[17:47:09.193] signalConditions() ... done
[17:47:09.194] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:47:09.194] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:47:09.194] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:47:09.194] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:47:09.195] MultisessionFuture started
[17:47:09.195] - Launch lazy future ... done
[17:47:09.195] run() for ‘MultisessionFuture’ ... done
[17:47:09.195] result() for ClusterFuture ...
[17:47:09.195] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.195] - Validating connection of MultisessionFuture
[17:47:09.197] - received message: FutureResult
[17:47:09.197] - Received FutureResult
[17:47:09.197] - Erased future from FutureRegistry
[17:47:09.197] result() for ClusterFuture ...
[17:47:09.197] - result already collected: FutureResult
[17:47:09.197] result() for ClusterFuture ... done
[17:47:09.197] signalConditions() ...
[17:47:09.197]  - include = ‘immediateCondition’
[17:47:09.197]  - exclude = 
[17:47:09.198]  - resignal = FALSE
[17:47:09.198]  - Number of conditions: 1
[17:47:09.198] signalConditions() ... done
[17:47:09.198] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.198] result() for ClusterFuture ... done
[17:47:09.198] result() for ClusterFuture ...
[17:47:09.198] - result already collected: FutureResult
[17:47:09.198] result() for ClusterFuture ... done
[17:47:09.198] signalConditions() ...
[17:47:09.198]  - include = ‘immediateCondition’
[17:47:09.198]  - exclude = 
[17:47:09.198]  - resignal = FALSE
[17:47:09.198]  - Number of conditions: 1
[17:47:09.199] signalConditions() ... done
[17:47:09.199] Future state: ‘finished’
[17:47:09.199] result() for ClusterFuture ...
[17:47:09.199] - result already collected: FutureResult
[17:47:09.199] result() for ClusterFuture ... done
[17:47:09.199] signalConditions() ...
[17:47:09.199]  - include = ‘condition’
[17:47:09.199]  - exclude = ‘immediateCondition’
[17:47:09.199]  - resignal = TRUE
[17:47:09.199]  - Number of conditions: 1
[17:47:09.200]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:47:09.200] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-22 17:47:09"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.213] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.213] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.214] 
[17:47:09.214] Searching for globals ... DONE
[17:47:09.214] - globals: [0] <none>
[17:47:09.214] getGlobalsAndPackages() ... DONE
[17:47:09.214] run() for ‘Future’ ...
[17:47:09.214] - state: ‘created’
[17:47:09.214] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.228] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.228]   - Field: ‘node’
[17:47:09.228]   - Field: ‘label’
[17:47:09.228]   - Field: ‘local’
[17:47:09.228]   - Field: ‘owner’
[17:47:09.229]   - Field: ‘envir’
[17:47:09.229]   - Field: ‘workers’
[17:47:09.229]   - Field: ‘packages’
[17:47:09.229]   - Field: ‘gc’
[17:47:09.229]   - Field: ‘conditions’
[17:47:09.229]   - Field: ‘persistent’
[17:47:09.229]   - Field: ‘expr’
[17:47:09.229]   - Field: ‘uuid’
[17:47:09.229]   - Field: ‘seed’
[17:47:09.229]   - Field: ‘version’
[17:47:09.229]   - Field: ‘result’
[17:47:09.230]   - Field: ‘asynchronous’
[17:47:09.230]   - Field: ‘calls’
[17:47:09.230]   - Field: ‘globals’
[17:47:09.230]   - Field: ‘stdout’
[17:47:09.230]   - Field: ‘earlySignal’
[17:47:09.230]   - Field: ‘lazy’
[17:47:09.230]   - Field: ‘state’
[17:47:09.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.230] - Launch lazy future ...
[17:47:09.231] Packages needed by the future expression (n = 0): <none>
[17:47:09.231] Packages needed by future strategies (n = 0): <none>
[17:47:09.231] {
[17:47:09.231]     {
[17:47:09.231]         {
[17:47:09.231]             ...future.startTime <- base::Sys.time()
[17:47:09.231]             {
[17:47:09.231]                 {
[17:47:09.231]                   {
[17:47:09.231]                     {
[17:47:09.231]                       base::local({
[17:47:09.231]                         has_future <- base::requireNamespace("future", 
[17:47:09.231]                           quietly = TRUE)
[17:47:09.231]                         if (has_future) {
[17:47:09.231]                           ns <- base::getNamespace("future")
[17:47:09.231]                           version <- ns[[".package"]][["version"]]
[17:47:09.231]                           if (is.null(version)) 
[17:47:09.231]                             version <- utils::packageVersion("future")
[17:47:09.231]                         }
[17:47:09.231]                         else {
[17:47:09.231]                           version <- NULL
[17:47:09.231]                         }
[17:47:09.231]                         if (!has_future || version < "1.8.0") {
[17:47:09.231]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.231]                             "", base::R.version$version.string), 
[17:47:09.231]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:09.231]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.231]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.231]                               "release", "version")], collapse = " "), 
[17:47:09.231]                             hostname = base::Sys.info()[["nodename"]])
[17:47:09.231]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.231]                             info)
[17:47:09.231]                           info <- base::paste(info, collapse = "; ")
[17:47:09.231]                           if (!has_future) {
[17:47:09.231]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.231]                               info)
[17:47:09.231]                           }
[17:47:09.231]                           else {
[17:47:09.231]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.231]                               info, version)
[17:47:09.231]                           }
[17:47:09.231]                           base::stop(msg)
[17:47:09.231]                         }
[17:47:09.231]                       })
[17:47:09.231]                     }
[17:47:09.231]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.231]                     base::options(mc.cores = 1L)
[17:47:09.231]                   }
[17:47:09.231]                   ...future.strategy.old <- future::plan("list")
[17:47:09.231]                   options(future.plan = NULL)
[17:47:09.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.231]                 }
[17:47:09.231]                 ...future.workdir <- getwd()
[17:47:09.231]             }
[17:47:09.231]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.231]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.231]         }
[17:47:09.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.231]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.231]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.231]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.231]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.231]             base::names(...future.oldOptions))
[17:47:09.231]     }
[17:47:09.231]     if (FALSE) {
[17:47:09.231]     }
[17:47:09.231]     else {
[17:47:09.231]         if (TRUE) {
[17:47:09.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.231]                 open = "w")
[17:47:09.231]         }
[17:47:09.231]         else {
[17:47:09.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.231]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.231]         }
[17:47:09.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.231]             base::sink(type = "output", split = FALSE)
[17:47:09.231]             base::close(...future.stdout)
[17:47:09.231]         }, add = TRUE)
[17:47:09.231]     }
[17:47:09.231]     ...future.frame <- base::sys.nframe()
[17:47:09.231]     ...future.conditions <- base::list()
[17:47:09.231]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.231]     if (FALSE) {
[17:47:09.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.231]     }
[17:47:09.231]     ...future.result <- base::tryCatch({
[17:47:09.231]         base::withCallingHandlers({
[17:47:09.231]             ...future.value <- base::withVisible(base::local({
[17:47:09.231]                 ...future.makeSendCondition <- base::local({
[17:47:09.231]                   sendCondition <- NULL
[17:47:09.231]                   function(frame = 1L) {
[17:47:09.231]                     if (is.function(sendCondition)) 
[17:47:09.231]                       return(sendCondition)
[17:47:09.231]                     ns <- getNamespace("parallel")
[17:47:09.231]                     if (exists("sendData", mode = "function", 
[17:47:09.231]                       envir = ns)) {
[17:47:09.231]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.231]                         envir = ns)
[17:47:09.231]                       envir <- sys.frame(frame)
[17:47:09.231]                       master <- NULL
[17:47:09.231]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.231]                         !identical(envir, emptyenv())) {
[17:47:09.231]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.231]                           inherits = FALSE)) {
[17:47:09.231]                           master <- get("master", mode = "list", 
[17:47:09.231]                             envir = envir, inherits = FALSE)
[17:47:09.231]                           if (inherits(master, c("SOCKnode", 
[17:47:09.231]                             "SOCK0node"))) {
[17:47:09.231]                             sendCondition <<- function(cond) {
[17:47:09.231]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.231]                                 success = TRUE)
[17:47:09.231]                               parallel_sendData(master, data)
[17:47:09.231]                             }
[17:47:09.231]                             return(sendCondition)
[17:47:09.231]                           }
[17:47:09.231]                         }
[17:47:09.231]                         frame <- frame + 1L
[17:47:09.231]                         envir <- sys.frame(frame)
[17:47:09.231]                       }
[17:47:09.231]                     }
[17:47:09.231]                     sendCondition <<- function(cond) NULL
[17:47:09.231]                   }
[17:47:09.231]                 })
[17:47:09.231]                 withCallingHandlers({
[17:47:09.231]                   1
[17:47:09.231]                 }, immediateCondition = function(cond) {
[17:47:09.231]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.231]                   sendCondition(cond)
[17:47:09.231]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.231]                   {
[17:47:09.231]                     inherits <- base::inherits
[17:47:09.231]                     invokeRestart <- base::invokeRestart
[17:47:09.231]                     is.null <- base::is.null
[17:47:09.231]                     muffled <- FALSE
[17:47:09.231]                     if (inherits(cond, "message")) {
[17:47:09.231]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.231]                       if (muffled) 
[17:47:09.231]                         invokeRestart("muffleMessage")
[17:47:09.231]                     }
[17:47:09.231]                     else if (inherits(cond, "warning")) {
[17:47:09.231]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.231]                       if (muffled) 
[17:47:09.231]                         invokeRestart("muffleWarning")
[17:47:09.231]                     }
[17:47:09.231]                     else if (inherits(cond, "condition")) {
[17:47:09.231]                       if (!is.null(pattern)) {
[17:47:09.231]                         computeRestarts <- base::computeRestarts
[17:47:09.231]                         grepl <- base::grepl
[17:47:09.231]                         restarts <- computeRestarts(cond)
[17:47:09.231]                         for (restart in restarts) {
[17:47:09.231]                           name <- restart$name
[17:47:09.231]                           if (is.null(name)) 
[17:47:09.231]                             next
[17:47:09.231]                           if (!grepl(pattern, name)) 
[17:47:09.231]                             next
[17:47:09.231]                           invokeRestart(restart)
[17:47:09.231]                           muffled <- TRUE
[17:47:09.231]                           break
[17:47:09.231]                         }
[17:47:09.231]                       }
[17:47:09.231]                     }
[17:47:09.231]                     invisible(muffled)
[17:47:09.231]                   }
[17:47:09.231]                   muffleCondition(cond)
[17:47:09.231]                 })
[17:47:09.231]             }))
[17:47:09.231]             future::FutureResult(value = ...future.value$value, 
[17:47:09.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.231]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.231]                     ...future.globalenv.names))
[17:47:09.231]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.231]         }, condition = base::local({
[17:47:09.231]             c <- base::c
[17:47:09.231]             inherits <- base::inherits
[17:47:09.231]             invokeRestart <- base::invokeRestart
[17:47:09.231]             length <- base::length
[17:47:09.231]             list <- base::list
[17:47:09.231]             seq.int <- base::seq.int
[17:47:09.231]             signalCondition <- base::signalCondition
[17:47:09.231]             sys.calls <- base::sys.calls
[17:47:09.231]             `[[` <- base::`[[`
[17:47:09.231]             `+` <- base::`+`
[17:47:09.231]             `<<-` <- base::`<<-`
[17:47:09.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.231]                   3L)]
[17:47:09.231]             }
[17:47:09.231]             function(cond) {
[17:47:09.231]                 is_error <- inherits(cond, "error")
[17:47:09.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.231]                   NULL)
[17:47:09.231]                 if (is_error) {
[17:47:09.231]                   sessionInformation <- function() {
[17:47:09.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.231]                       search = base::search(), system = base::Sys.info())
[17:47:09.231]                   }
[17:47:09.231]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.231]                     cond$call), session = sessionInformation(), 
[17:47:09.231]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.231]                   signalCondition(cond)
[17:47:09.231]                 }
[17:47:09.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.231]                 "immediateCondition"))) {
[17:47:09.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.231]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.231]                   if (TRUE && !signal) {
[17:47:09.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.231]                     {
[17:47:09.231]                       inherits <- base::inherits
[17:47:09.231]                       invokeRestart <- base::invokeRestart
[17:47:09.231]                       is.null <- base::is.null
[17:47:09.231]                       muffled <- FALSE
[17:47:09.231]                       if (inherits(cond, "message")) {
[17:47:09.231]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.231]                         if (muffled) 
[17:47:09.231]                           invokeRestart("muffleMessage")
[17:47:09.231]                       }
[17:47:09.231]                       else if (inherits(cond, "warning")) {
[17:47:09.231]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.231]                         if (muffled) 
[17:47:09.231]                           invokeRestart("muffleWarning")
[17:47:09.231]                       }
[17:47:09.231]                       else if (inherits(cond, "condition")) {
[17:47:09.231]                         if (!is.null(pattern)) {
[17:47:09.231]                           computeRestarts <- base::computeRestarts
[17:47:09.231]                           grepl <- base::grepl
[17:47:09.231]                           restarts <- computeRestarts(cond)
[17:47:09.231]                           for (restart in restarts) {
[17:47:09.231]                             name <- restart$name
[17:47:09.231]                             if (is.null(name)) 
[17:47:09.231]                               next
[17:47:09.231]                             if (!grepl(pattern, name)) 
[17:47:09.231]                               next
[17:47:09.231]                             invokeRestart(restart)
[17:47:09.231]                             muffled <- TRUE
[17:47:09.231]                             break
[17:47:09.231]                           }
[17:47:09.231]                         }
[17:47:09.231]                       }
[17:47:09.231]                       invisible(muffled)
[17:47:09.231]                     }
[17:47:09.231]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.231]                   }
[17:47:09.231]                 }
[17:47:09.231]                 else {
[17:47:09.231]                   if (TRUE) {
[17:47:09.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.231]                     {
[17:47:09.231]                       inherits <- base::inherits
[17:47:09.231]                       invokeRestart <- base::invokeRestart
[17:47:09.231]                       is.null <- base::is.null
[17:47:09.231]                       muffled <- FALSE
[17:47:09.231]                       if (inherits(cond, "message")) {
[17:47:09.231]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.231]                         if (muffled) 
[17:47:09.231]                           invokeRestart("muffleMessage")
[17:47:09.231]                       }
[17:47:09.231]                       else if (inherits(cond, "warning")) {
[17:47:09.231]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.231]                         if (muffled) 
[17:47:09.231]                           invokeRestart("muffleWarning")
[17:47:09.231]                       }
[17:47:09.231]                       else if (inherits(cond, "condition")) {
[17:47:09.231]                         if (!is.null(pattern)) {
[17:47:09.231]                           computeRestarts <- base::computeRestarts
[17:47:09.231]                           grepl <- base::grepl
[17:47:09.231]                           restarts <- computeRestarts(cond)
[17:47:09.231]                           for (restart in restarts) {
[17:47:09.231]                             name <- restart$name
[17:47:09.231]                             if (is.null(name)) 
[17:47:09.231]                               next
[17:47:09.231]                             if (!grepl(pattern, name)) 
[17:47:09.231]                               next
[17:47:09.231]                             invokeRestart(restart)
[17:47:09.231]                             muffled <- TRUE
[17:47:09.231]                             break
[17:47:09.231]                           }
[17:47:09.231]                         }
[17:47:09.231]                       }
[17:47:09.231]                       invisible(muffled)
[17:47:09.231]                     }
[17:47:09.231]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.231]                   }
[17:47:09.231]                 }
[17:47:09.231]             }
[17:47:09.231]         }))
[17:47:09.231]     }, error = function(ex) {
[17:47:09.231]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.231]                 ...future.rng), started = ...future.startTime, 
[17:47:09.231]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.231]             version = "1.8"), class = "FutureResult")
[17:47:09.231]     }, finally = {
[17:47:09.231]         if (!identical(...future.workdir, getwd())) 
[17:47:09.231]             setwd(...future.workdir)
[17:47:09.231]         {
[17:47:09.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.231]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.231]             }
[17:47:09.231]             base::options(...future.oldOptions)
[17:47:09.231]             if (.Platform$OS.type == "windows") {
[17:47:09.231]                 old_names <- names(...future.oldEnvVars)
[17:47:09.231]                 envs <- base::Sys.getenv()
[17:47:09.231]                 names <- names(envs)
[17:47:09.231]                 common <- intersect(names, old_names)
[17:47:09.231]                 added <- setdiff(names, old_names)
[17:47:09.231]                 removed <- setdiff(old_names, names)
[17:47:09.231]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.231]                   envs[common]]
[17:47:09.231]                 NAMES <- toupper(changed)
[17:47:09.231]                 args <- list()
[17:47:09.231]                 for (kk in seq_along(NAMES)) {
[17:47:09.231]                   name <- changed[[kk]]
[17:47:09.231]                   NAME <- NAMES[[kk]]
[17:47:09.231]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.231]                     next
[17:47:09.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.231]                 }
[17:47:09.231]                 NAMES <- toupper(added)
[17:47:09.231]                 for (kk in seq_along(NAMES)) {
[17:47:09.231]                   name <- added[[kk]]
[17:47:09.231]                   NAME <- NAMES[[kk]]
[17:47:09.231]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.231]                     next
[17:47:09.231]                   args[[name]] <- ""
[17:47:09.231]                 }
[17:47:09.231]                 NAMES <- toupper(removed)
[17:47:09.231]                 for (kk in seq_along(NAMES)) {
[17:47:09.231]                   name <- removed[[kk]]
[17:47:09.231]                   NAME <- NAMES[[kk]]
[17:47:09.231]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.231]                     next
[17:47:09.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.231]                 }
[17:47:09.231]                 if (length(args) > 0) 
[17:47:09.231]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.231]             }
[17:47:09.231]             else {
[17:47:09.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.231]             }
[17:47:09.231]             {
[17:47:09.231]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.231]                   0L) {
[17:47:09.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.231]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.231]                   base::options(opts)
[17:47:09.231]                 }
[17:47:09.231]                 {
[17:47:09.231]                   {
[17:47:09.231]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.231]                     NULL
[17:47:09.231]                   }
[17:47:09.231]                   options(future.plan = NULL)
[17:47:09.231]                   if (is.na(NA_character_)) 
[17:47:09.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.231]                     .init = FALSE)
[17:47:09.231]                 }
[17:47:09.231]             }
[17:47:09.231]         }
[17:47:09.231]     })
[17:47:09.231]     if (TRUE) {
[17:47:09.231]         base::sink(type = "output", split = FALSE)
[17:47:09.231]         if (TRUE) {
[17:47:09.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.231]         }
[17:47:09.231]         else {
[17:47:09.231]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.231]         }
[17:47:09.231]         base::close(...future.stdout)
[17:47:09.231]         ...future.stdout <- NULL
[17:47:09.231]     }
[17:47:09.231]     ...future.result$conditions <- ...future.conditions
[17:47:09.231]     ...future.result$finished <- base::Sys.time()
[17:47:09.231]     ...future.result
[17:47:09.231] }
[17:47:09.234] MultisessionFuture started
[17:47:09.234] - Launch lazy future ... done
[17:47:09.234] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.234] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.234] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.235] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:09.236] Searching for globals ... DONE
[17:47:09.236] Resolving globals: TRUE
[17:47:09.236] Resolving any globals that are futures ...
[17:47:09.236] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:09.236] Resolving any globals that are futures ... DONE
[17:47:09.236] Resolving futures part of globals (recursively) ...
[17:47:09.236] resolve() on list ...
[17:47:09.237]  recursive: 99
[17:47:09.237]  length: 1
[17:47:09.237]  elements: ‘a’
[17:47:09.239] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.239] - Validating connection of MultisessionFuture
[17:47:09.239] - received message: FutureResult
[17:47:09.240] - Received FutureResult
[17:47:09.240] - Erased future from FutureRegistry
[17:47:09.240] result() for ClusterFuture ...
[17:47:09.240] - result already collected: FutureResult
[17:47:09.240] result() for ClusterFuture ... done
[17:47:09.240] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.240] Future #1
[17:47:09.240] result() for ClusterFuture ...
[17:47:09.240] - result already collected: FutureResult
[17:47:09.241] result() for ClusterFuture ... done
[17:47:09.241] result() for ClusterFuture ...
[17:47:09.241] - result already collected: FutureResult
[17:47:09.241] result() for ClusterFuture ... done
[17:47:09.241] A MultisessionFuture was resolved
[17:47:09.241]  length: 0 (resolved future 1)
[17:47:09.241] resolve() on list ... DONE
[17:47:09.241] - globals: [1] ‘a’
[17:47:09.241] Resolving futures part of globals (recursively) ... DONE
[17:47:09.242] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[17:47:09.242] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[17:47:09.243] - globals: [1] ‘a’
[17:47:09.243] - packages: [1] ‘future’
[17:47:09.243] getGlobalsAndPackages() ... DONE
[17:47:09.243] run() for ‘Future’ ...
[17:47:09.243] - state: ‘created’
[17:47:09.243] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.257] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.257] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.257]   - Field: ‘node’
[17:47:09.257]   - Field: ‘label’
[17:47:09.257]   - Field: ‘local’
[17:47:09.257]   - Field: ‘owner’
[17:47:09.257]   - Field: ‘envir’
[17:47:09.258]   - Field: ‘workers’
[17:47:09.258]   - Field: ‘packages’
[17:47:09.258]   - Field: ‘gc’
[17:47:09.258]   - Field: ‘conditions’
[17:47:09.258]   - Field: ‘persistent’
[17:47:09.258]   - Field: ‘expr’
[17:47:09.258]   - Field: ‘uuid’
[17:47:09.258]   - Field: ‘seed’
[17:47:09.258]   - Field: ‘version’
[17:47:09.258]   - Field: ‘result’
[17:47:09.258]   - Field: ‘asynchronous’
[17:47:09.259]   - Field: ‘calls’
[17:47:09.259]   - Field: ‘globals’
[17:47:09.259]   - Field: ‘stdout’
[17:47:09.259]   - Field: ‘earlySignal’
[17:47:09.259]   - Field: ‘lazy’
[17:47:09.259]   - Field: ‘state’
[17:47:09.259] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.259] - Launch lazy future ...
[17:47:09.259] Packages needed by the future expression (n = 1): ‘future’
[17:47:09.260] Packages needed by future strategies (n = 0): <none>
[17:47:09.260] {
[17:47:09.260]     {
[17:47:09.260]         {
[17:47:09.260]             ...future.startTime <- base::Sys.time()
[17:47:09.260]             {
[17:47:09.260]                 {
[17:47:09.260]                   {
[17:47:09.260]                     {
[17:47:09.260]                       {
[17:47:09.260]                         base::local({
[17:47:09.260]                           has_future <- base::requireNamespace("future", 
[17:47:09.260]                             quietly = TRUE)
[17:47:09.260]                           if (has_future) {
[17:47:09.260]                             ns <- base::getNamespace("future")
[17:47:09.260]                             version <- ns[[".package"]][["version"]]
[17:47:09.260]                             if (is.null(version)) 
[17:47:09.260]                               version <- utils::packageVersion("future")
[17:47:09.260]                           }
[17:47:09.260]                           else {
[17:47:09.260]                             version <- NULL
[17:47:09.260]                           }
[17:47:09.260]                           if (!has_future || version < "1.8.0") {
[17:47:09.260]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.260]                               "", base::R.version$version.string), 
[17:47:09.260]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:09.260]                                 base::R.version$platform, 8 * 
[17:47:09.260]                                   base::.Machine$sizeof.pointer), 
[17:47:09.260]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.260]                                 "release", "version")], collapse = " "), 
[17:47:09.260]                               hostname = base::Sys.info()[["nodename"]])
[17:47:09.260]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.260]                               info)
[17:47:09.260]                             info <- base::paste(info, collapse = "; ")
[17:47:09.260]                             if (!has_future) {
[17:47:09.260]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.260]                                 info)
[17:47:09.260]                             }
[17:47:09.260]                             else {
[17:47:09.260]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.260]                                 info, version)
[17:47:09.260]                             }
[17:47:09.260]                             base::stop(msg)
[17:47:09.260]                           }
[17:47:09.260]                         })
[17:47:09.260]                       }
[17:47:09.260]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.260]                       base::options(mc.cores = 1L)
[17:47:09.260]                     }
[17:47:09.260]                     base::local({
[17:47:09.260]                       for (pkg in "future") {
[17:47:09.260]                         base::loadNamespace(pkg)
[17:47:09.260]                         base::library(pkg, character.only = TRUE)
[17:47:09.260]                       }
[17:47:09.260]                     })
[17:47:09.260]                   }
[17:47:09.260]                   ...future.strategy.old <- future::plan("list")
[17:47:09.260]                   options(future.plan = NULL)
[17:47:09.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.260]                 }
[17:47:09.260]                 ...future.workdir <- getwd()
[17:47:09.260]             }
[17:47:09.260]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.260]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.260]         }
[17:47:09.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.260]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.260]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.260]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.260]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.260]             base::names(...future.oldOptions))
[17:47:09.260]     }
[17:47:09.260]     if (FALSE) {
[17:47:09.260]     }
[17:47:09.260]     else {
[17:47:09.260]         if (TRUE) {
[17:47:09.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.260]                 open = "w")
[17:47:09.260]         }
[17:47:09.260]         else {
[17:47:09.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.260]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.260]         }
[17:47:09.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.260]             base::sink(type = "output", split = FALSE)
[17:47:09.260]             base::close(...future.stdout)
[17:47:09.260]         }, add = TRUE)
[17:47:09.260]     }
[17:47:09.260]     ...future.frame <- base::sys.nframe()
[17:47:09.260]     ...future.conditions <- base::list()
[17:47:09.260]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.260]     if (FALSE) {
[17:47:09.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.260]     }
[17:47:09.260]     ...future.result <- base::tryCatch({
[17:47:09.260]         base::withCallingHandlers({
[17:47:09.260]             ...future.value <- base::withVisible(base::local({
[17:47:09.260]                 ...future.makeSendCondition <- base::local({
[17:47:09.260]                   sendCondition <- NULL
[17:47:09.260]                   function(frame = 1L) {
[17:47:09.260]                     if (is.function(sendCondition)) 
[17:47:09.260]                       return(sendCondition)
[17:47:09.260]                     ns <- getNamespace("parallel")
[17:47:09.260]                     if (exists("sendData", mode = "function", 
[17:47:09.260]                       envir = ns)) {
[17:47:09.260]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.260]                         envir = ns)
[17:47:09.260]                       envir <- sys.frame(frame)
[17:47:09.260]                       master <- NULL
[17:47:09.260]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.260]                         !identical(envir, emptyenv())) {
[17:47:09.260]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.260]                           inherits = FALSE)) {
[17:47:09.260]                           master <- get("master", mode = "list", 
[17:47:09.260]                             envir = envir, inherits = FALSE)
[17:47:09.260]                           if (inherits(master, c("SOCKnode", 
[17:47:09.260]                             "SOCK0node"))) {
[17:47:09.260]                             sendCondition <<- function(cond) {
[17:47:09.260]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.260]                                 success = TRUE)
[17:47:09.260]                               parallel_sendData(master, data)
[17:47:09.260]                             }
[17:47:09.260]                             return(sendCondition)
[17:47:09.260]                           }
[17:47:09.260]                         }
[17:47:09.260]                         frame <- frame + 1L
[17:47:09.260]                         envir <- sys.frame(frame)
[17:47:09.260]                       }
[17:47:09.260]                     }
[17:47:09.260]                     sendCondition <<- function(cond) NULL
[17:47:09.260]                   }
[17:47:09.260]                 })
[17:47:09.260]                 withCallingHandlers({
[17:47:09.260]                   value(a) + 1
[17:47:09.260]                 }, immediateCondition = function(cond) {
[17:47:09.260]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.260]                   sendCondition(cond)
[17:47:09.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.260]                   {
[17:47:09.260]                     inherits <- base::inherits
[17:47:09.260]                     invokeRestart <- base::invokeRestart
[17:47:09.260]                     is.null <- base::is.null
[17:47:09.260]                     muffled <- FALSE
[17:47:09.260]                     if (inherits(cond, "message")) {
[17:47:09.260]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.260]                       if (muffled) 
[17:47:09.260]                         invokeRestart("muffleMessage")
[17:47:09.260]                     }
[17:47:09.260]                     else if (inherits(cond, "warning")) {
[17:47:09.260]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.260]                       if (muffled) 
[17:47:09.260]                         invokeRestart("muffleWarning")
[17:47:09.260]                     }
[17:47:09.260]                     else if (inherits(cond, "condition")) {
[17:47:09.260]                       if (!is.null(pattern)) {
[17:47:09.260]                         computeRestarts <- base::computeRestarts
[17:47:09.260]                         grepl <- base::grepl
[17:47:09.260]                         restarts <- computeRestarts(cond)
[17:47:09.260]                         for (restart in restarts) {
[17:47:09.260]                           name <- restart$name
[17:47:09.260]                           if (is.null(name)) 
[17:47:09.260]                             next
[17:47:09.260]                           if (!grepl(pattern, name)) 
[17:47:09.260]                             next
[17:47:09.260]                           invokeRestart(restart)
[17:47:09.260]                           muffled <- TRUE
[17:47:09.260]                           break
[17:47:09.260]                         }
[17:47:09.260]                       }
[17:47:09.260]                     }
[17:47:09.260]                     invisible(muffled)
[17:47:09.260]                   }
[17:47:09.260]                   muffleCondition(cond)
[17:47:09.260]                 })
[17:47:09.260]             }))
[17:47:09.260]             future::FutureResult(value = ...future.value$value, 
[17:47:09.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.260]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.260]                     ...future.globalenv.names))
[17:47:09.260]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.260]         }, condition = base::local({
[17:47:09.260]             c <- base::c
[17:47:09.260]             inherits <- base::inherits
[17:47:09.260]             invokeRestart <- base::invokeRestart
[17:47:09.260]             length <- base::length
[17:47:09.260]             list <- base::list
[17:47:09.260]             seq.int <- base::seq.int
[17:47:09.260]             signalCondition <- base::signalCondition
[17:47:09.260]             sys.calls <- base::sys.calls
[17:47:09.260]             `[[` <- base::`[[`
[17:47:09.260]             `+` <- base::`+`
[17:47:09.260]             `<<-` <- base::`<<-`
[17:47:09.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.260]                   3L)]
[17:47:09.260]             }
[17:47:09.260]             function(cond) {
[17:47:09.260]                 is_error <- inherits(cond, "error")
[17:47:09.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.260]                   NULL)
[17:47:09.260]                 if (is_error) {
[17:47:09.260]                   sessionInformation <- function() {
[17:47:09.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.260]                       search = base::search(), system = base::Sys.info())
[17:47:09.260]                   }
[17:47:09.260]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.260]                     cond$call), session = sessionInformation(), 
[17:47:09.260]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.260]                   signalCondition(cond)
[17:47:09.260]                 }
[17:47:09.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.260]                 "immediateCondition"))) {
[17:47:09.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.260]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.260]                   if (TRUE && !signal) {
[17:47:09.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.260]                     {
[17:47:09.260]                       inherits <- base::inherits
[17:47:09.260]                       invokeRestart <- base::invokeRestart
[17:47:09.260]                       is.null <- base::is.null
[17:47:09.260]                       muffled <- FALSE
[17:47:09.260]                       if (inherits(cond, "message")) {
[17:47:09.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.260]                         if (muffled) 
[17:47:09.260]                           invokeRestart("muffleMessage")
[17:47:09.260]                       }
[17:47:09.260]                       else if (inherits(cond, "warning")) {
[17:47:09.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.260]                         if (muffled) 
[17:47:09.260]                           invokeRestart("muffleWarning")
[17:47:09.260]                       }
[17:47:09.260]                       else if (inherits(cond, "condition")) {
[17:47:09.260]                         if (!is.null(pattern)) {
[17:47:09.260]                           computeRestarts <- base::computeRestarts
[17:47:09.260]                           grepl <- base::grepl
[17:47:09.260]                           restarts <- computeRestarts(cond)
[17:47:09.260]                           for (restart in restarts) {
[17:47:09.260]                             name <- restart$name
[17:47:09.260]                             if (is.null(name)) 
[17:47:09.260]                               next
[17:47:09.260]                             if (!grepl(pattern, name)) 
[17:47:09.260]                               next
[17:47:09.260]                             invokeRestart(restart)
[17:47:09.260]                             muffled <- TRUE
[17:47:09.260]                             break
[17:47:09.260]                           }
[17:47:09.260]                         }
[17:47:09.260]                       }
[17:47:09.260]                       invisible(muffled)
[17:47:09.260]                     }
[17:47:09.260]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.260]                   }
[17:47:09.260]                 }
[17:47:09.260]                 else {
[17:47:09.260]                   if (TRUE) {
[17:47:09.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.260]                     {
[17:47:09.260]                       inherits <- base::inherits
[17:47:09.260]                       invokeRestart <- base::invokeRestart
[17:47:09.260]                       is.null <- base::is.null
[17:47:09.260]                       muffled <- FALSE
[17:47:09.260]                       if (inherits(cond, "message")) {
[17:47:09.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.260]                         if (muffled) 
[17:47:09.260]                           invokeRestart("muffleMessage")
[17:47:09.260]                       }
[17:47:09.260]                       else if (inherits(cond, "warning")) {
[17:47:09.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.260]                         if (muffled) 
[17:47:09.260]                           invokeRestart("muffleWarning")
[17:47:09.260]                       }
[17:47:09.260]                       else if (inherits(cond, "condition")) {
[17:47:09.260]                         if (!is.null(pattern)) {
[17:47:09.260]                           computeRestarts <- base::computeRestarts
[17:47:09.260]                           grepl <- base::grepl
[17:47:09.260]                           restarts <- computeRestarts(cond)
[17:47:09.260]                           for (restart in restarts) {
[17:47:09.260]                             name <- restart$name
[17:47:09.260]                             if (is.null(name)) 
[17:47:09.260]                               next
[17:47:09.260]                             if (!grepl(pattern, name)) 
[17:47:09.260]                               next
[17:47:09.260]                             invokeRestart(restart)
[17:47:09.260]                             muffled <- TRUE
[17:47:09.260]                             break
[17:47:09.260]                           }
[17:47:09.260]                         }
[17:47:09.260]                       }
[17:47:09.260]                       invisible(muffled)
[17:47:09.260]                     }
[17:47:09.260]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.260]                   }
[17:47:09.260]                 }
[17:47:09.260]             }
[17:47:09.260]         }))
[17:47:09.260]     }, error = function(ex) {
[17:47:09.260]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.260]                 ...future.rng), started = ...future.startTime, 
[17:47:09.260]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.260]             version = "1.8"), class = "FutureResult")
[17:47:09.260]     }, finally = {
[17:47:09.260]         if (!identical(...future.workdir, getwd())) 
[17:47:09.260]             setwd(...future.workdir)
[17:47:09.260]         {
[17:47:09.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.260]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.260]             }
[17:47:09.260]             base::options(...future.oldOptions)
[17:47:09.260]             if (.Platform$OS.type == "windows") {
[17:47:09.260]                 old_names <- names(...future.oldEnvVars)
[17:47:09.260]                 envs <- base::Sys.getenv()
[17:47:09.260]                 names <- names(envs)
[17:47:09.260]                 common <- intersect(names, old_names)
[17:47:09.260]                 added <- setdiff(names, old_names)
[17:47:09.260]                 removed <- setdiff(old_names, names)
[17:47:09.260]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.260]                   envs[common]]
[17:47:09.260]                 NAMES <- toupper(changed)
[17:47:09.260]                 args <- list()
[17:47:09.260]                 for (kk in seq_along(NAMES)) {
[17:47:09.260]                   name <- changed[[kk]]
[17:47:09.260]                   NAME <- NAMES[[kk]]
[17:47:09.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.260]                     next
[17:47:09.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.260]                 }
[17:47:09.260]                 NAMES <- toupper(added)
[17:47:09.260]                 for (kk in seq_along(NAMES)) {
[17:47:09.260]                   name <- added[[kk]]
[17:47:09.260]                   NAME <- NAMES[[kk]]
[17:47:09.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.260]                     next
[17:47:09.260]                   args[[name]] <- ""
[17:47:09.260]                 }
[17:47:09.260]                 NAMES <- toupper(removed)
[17:47:09.260]                 for (kk in seq_along(NAMES)) {
[17:47:09.260]                   name <- removed[[kk]]
[17:47:09.260]                   NAME <- NAMES[[kk]]
[17:47:09.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.260]                     next
[17:47:09.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.260]                 }
[17:47:09.260]                 if (length(args) > 0) 
[17:47:09.260]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.260]             }
[17:47:09.260]             else {
[17:47:09.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.260]             }
[17:47:09.260]             {
[17:47:09.260]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.260]                   0L) {
[17:47:09.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.260]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.260]                   base::options(opts)
[17:47:09.260]                 }
[17:47:09.260]                 {
[17:47:09.260]                   {
[17:47:09.260]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.260]                     NULL
[17:47:09.260]                   }
[17:47:09.260]                   options(future.plan = NULL)
[17:47:09.260]                   if (is.na(NA_character_)) 
[17:47:09.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.260]                     .init = FALSE)
[17:47:09.260]                 }
[17:47:09.260]             }
[17:47:09.260]         }
[17:47:09.260]     })
[17:47:09.260]     if (TRUE) {
[17:47:09.260]         base::sink(type = "output", split = FALSE)
[17:47:09.260]         if (TRUE) {
[17:47:09.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.260]         }
[17:47:09.260]         else {
[17:47:09.260]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.260]         }
[17:47:09.260]         base::close(...future.stdout)
[17:47:09.260]         ...future.stdout <- NULL
[17:47:09.260]     }
[17:47:09.260]     ...future.result$conditions <- ...future.conditions
[17:47:09.260]     ...future.result$finished <- base::Sys.time()
[17:47:09.260]     ...future.result
[17:47:09.260] }
[17:47:09.262] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[17:47:09.265] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[17:47:09.316] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[17:47:09.316] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[17:47:09.316] MultisessionFuture started
[17:47:09.317] - Launch lazy future ... done
[17:47:09.317] run() for ‘MultisessionFuture’ ... done
[17:47:09.317] result() for ClusterFuture ...
[17:47:09.317] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.317] - Validating connection of MultisessionFuture
[17:47:09.365] - received message: FutureResult
[17:47:09.365] - Received FutureResult
[17:47:09.365] - Erased future from FutureRegistry
[17:47:09.365] result() for ClusterFuture ...
[17:47:09.365] - result already collected: FutureResult
[17:47:09.365] result() for ClusterFuture ... done
[17:47:09.365] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.365] result() for ClusterFuture ... done
[17:47:09.366] result() for ClusterFuture ...
[17:47:09.366] - result already collected: FutureResult
[17:47:09.366] result() for ClusterFuture ... done
value(b) = 2
[17:47:09.366] result() for ClusterFuture ...
[17:47:09.366] - result already collected: FutureResult
[17:47:09.366] result() for ClusterFuture ... done
[17:47:09.366] result() for ClusterFuture ...
[17:47:09.366] - result already collected: FutureResult
[17:47:09.366] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.367] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.367] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.367] 
[17:47:09.368] Searching for globals ... DONE
[17:47:09.368] - globals: [0] <none>
[17:47:09.368] getGlobalsAndPackages() ... DONE
[17:47:09.368] run() for ‘Future’ ...
[17:47:09.368] - state: ‘created’
[17:47:09.368] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.382] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.383]   - Field: ‘node’
[17:47:09.383]   - Field: ‘label’
[17:47:09.383]   - Field: ‘local’
[17:47:09.383]   - Field: ‘owner’
[17:47:09.383]   - Field: ‘envir’
[17:47:09.383]   - Field: ‘workers’
[17:47:09.383]   - Field: ‘packages’
[17:47:09.383]   - Field: ‘gc’
[17:47:09.383]   - Field: ‘conditions’
[17:47:09.383]   - Field: ‘persistent’
[17:47:09.383]   - Field: ‘expr’
[17:47:09.384]   - Field: ‘uuid’
[17:47:09.384]   - Field: ‘seed’
[17:47:09.384]   - Field: ‘version’
[17:47:09.384]   - Field: ‘result’
[17:47:09.384]   - Field: ‘asynchronous’
[17:47:09.384]   - Field: ‘calls’
[17:47:09.384]   - Field: ‘globals’
[17:47:09.384]   - Field: ‘stdout’
[17:47:09.384]   - Field: ‘earlySignal’
[17:47:09.384]   - Field: ‘lazy’
[17:47:09.384]   - Field: ‘state’
[17:47:09.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.385] - Launch lazy future ...
[17:47:09.385] Packages needed by the future expression (n = 0): <none>
[17:47:09.385] Packages needed by future strategies (n = 0): <none>
[17:47:09.385] {
[17:47:09.385]     {
[17:47:09.385]         {
[17:47:09.385]             ...future.startTime <- base::Sys.time()
[17:47:09.385]             {
[17:47:09.385]                 {
[17:47:09.385]                   {
[17:47:09.385]                     {
[17:47:09.385]                       base::local({
[17:47:09.385]                         has_future <- base::requireNamespace("future", 
[17:47:09.385]                           quietly = TRUE)
[17:47:09.385]                         if (has_future) {
[17:47:09.385]                           ns <- base::getNamespace("future")
[17:47:09.385]                           version <- ns[[".package"]][["version"]]
[17:47:09.385]                           if (is.null(version)) 
[17:47:09.385]                             version <- utils::packageVersion("future")
[17:47:09.385]                         }
[17:47:09.385]                         else {
[17:47:09.385]                           version <- NULL
[17:47:09.385]                         }
[17:47:09.385]                         if (!has_future || version < "1.8.0") {
[17:47:09.385]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.385]                             "", base::R.version$version.string), 
[17:47:09.385]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:09.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.385]                               "release", "version")], collapse = " "), 
[17:47:09.385]                             hostname = base::Sys.info()[["nodename"]])
[17:47:09.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.385]                             info)
[17:47:09.385]                           info <- base::paste(info, collapse = "; ")
[17:47:09.385]                           if (!has_future) {
[17:47:09.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.385]                               info)
[17:47:09.385]                           }
[17:47:09.385]                           else {
[17:47:09.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.385]                               info, version)
[17:47:09.385]                           }
[17:47:09.385]                           base::stop(msg)
[17:47:09.385]                         }
[17:47:09.385]                       })
[17:47:09.385]                     }
[17:47:09.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.385]                     base::options(mc.cores = 1L)
[17:47:09.385]                   }
[17:47:09.385]                   ...future.strategy.old <- future::plan("list")
[17:47:09.385]                   options(future.plan = NULL)
[17:47:09.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.385]                 }
[17:47:09.385]                 ...future.workdir <- getwd()
[17:47:09.385]             }
[17:47:09.385]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.385]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.385]         }
[17:47:09.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.385]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.385]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.385]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.385]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.385]             base::names(...future.oldOptions))
[17:47:09.385]     }
[17:47:09.385]     if (FALSE) {
[17:47:09.385]     }
[17:47:09.385]     else {
[17:47:09.385]         if (TRUE) {
[17:47:09.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.385]                 open = "w")
[17:47:09.385]         }
[17:47:09.385]         else {
[17:47:09.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.385]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.385]         }
[17:47:09.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.385]             base::sink(type = "output", split = FALSE)
[17:47:09.385]             base::close(...future.stdout)
[17:47:09.385]         }, add = TRUE)
[17:47:09.385]     }
[17:47:09.385]     ...future.frame <- base::sys.nframe()
[17:47:09.385]     ...future.conditions <- base::list()
[17:47:09.385]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.385]     if (FALSE) {
[17:47:09.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.385]     }
[17:47:09.385]     ...future.result <- base::tryCatch({
[17:47:09.385]         base::withCallingHandlers({
[17:47:09.385]             ...future.value <- base::withVisible(base::local({
[17:47:09.385]                 ...future.makeSendCondition <- base::local({
[17:47:09.385]                   sendCondition <- NULL
[17:47:09.385]                   function(frame = 1L) {
[17:47:09.385]                     if (is.function(sendCondition)) 
[17:47:09.385]                       return(sendCondition)
[17:47:09.385]                     ns <- getNamespace("parallel")
[17:47:09.385]                     if (exists("sendData", mode = "function", 
[17:47:09.385]                       envir = ns)) {
[17:47:09.385]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.385]                         envir = ns)
[17:47:09.385]                       envir <- sys.frame(frame)
[17:47:09.385]                       master <- NULL
[17:47:09.385]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.385]                         !identical(envir, emptyenv())) {
[17:47:09.385]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.385]                           inherits = FALSE)) {
[17:47:09.385]                           master <- get("master", mode = "list", 
[17:47:09.385]                             envir = envir, inherits = FALSE)
[17:47:09.385]                           if (inherits(master, c("SOCKnode", 
[17:47:09.385]                             "SOCK0node"))) {
[17:47:09.385]                             sendCondition <<- function(cond) {
[17:47:09.385]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.385]                                 success = TRUE)
[17:47:09.385]                               parallel_sendData(master, data)
[17:47:09.385]                             }
[17:47:09.385]                             return(sendCondition)
[17:47:09.385]                           }
[17:47:09.385]                         }
[17:47:09.385]                         frame <- frame + 1L
[17:47:09.385]                         envir <- sys.frame(frame)
[17:47:09.385]                       }
[17:47:09.385]                     }
[17:47:09.385]                     sendCondition <<- function(cond) NULL
[17:47:09.385]                   }
[17:47:09.385]                 })
[17:47:09.385]                 withCallingHandlers({
[17:47:09.385]                   1
[17:47:09.385]                 }, immediateCondition = function(cond) {
[17:47:09.385]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.385]                   sendCondition(cond)
[17:47:09.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.385]                   {
[17:47:09.385]                     inherits <- base::inherits
[17:47:09.385]                     invokeRestart <- base::invokeRestart
[17:47:09.385]                     is.null <- base::is.null
[17:47:09.385]                     muffled <- FALSE
[17:47:09.385]                     if (inherits(cond, "message")) {
[17:47:09.385]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.385]                       if (muffled) 
[17:47:09.385]                         invokeRestart("muffleMessage")
[17:47:09.385]                     }
[17:47:09.385]                     else if (inherits(cond, "warning")) {
[17:47:09.385]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.385]                       if (muffled) 
[17:47:09.385]                         invokeRestart("muffleWarning")
[17:47:09.385]                     }
[17:47:09.385]                     else if (inherits(cond, "condition")) {
[17:47:09.385]                       if (!is.null(pattern)) {
[17:47:09.385]                         computeRestarts <- base::computeRestarts
[17:47:09.385]                         grepl <- base::grepl
[17:47:09.385]                         restarts <- computeRestarts(cond)
[17:47:09.385]                         for (restart in restarts) {
[17:47:09.385]                           name <- restart$name
[17:47:09.385]                           if (is.null(name)) 
[17:47:09.385]                             next
[17:47:09.385]                           if (!grepl(pattern, name)) 
[17:47:09.385]                             next
[17:47:09.385]                           invokeRestart(restart)
[17:47:09.385]                           muffled <- TRUE
[17:47:09.385]                           break
[17:47:09.385]                         }
[17:47:09.385]                       }
[17:47:09.385]                     }
[17:47:09.385]                     invisible(muffled)
[17:47:09.385]                   }
[17:47:09.385]                   muffleCondition(cond)
[17:47:09.385]                 })
[17:47:09.385]             }))
[17:47:09.385]             future::FutureResult(value = ...future.value$value, 
[17:47:09.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.385]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.385]                     ...future.globalenv.names))
[17:47:09.385]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.385]         }, condition = base::local({
[17:47:09.385]             c <- base::c
[17:47:09.385]             inherits <- base::inherits
[17:47:09.385]             invokeRestart <- base::invokeRestart
[17:47:09.385]             length <- base::length
[17:47:09.385]             list <- base::list
[17:47:09.385]             seq.int <- base::seq.int
[17:47:09.385]             signalCondition <- base::signalCondition
[17:47:09.385]             sys.calls <- base::sys.calls
[17:47:09.385]             `[[` <- base::`[[`
[17:47:09.385]             `+` <- base::`+`
[17:47:09.385]             `<<-` <- base::`<<-`
[17:47:09.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.385]                   3L)]
[17:47:09.385]             }
[17:47:09.385]             function(cond) {
[17:47:09.385]                 is_error <- inherits(cond, "error")
[17:47:09.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.385]                   NULL)
[17:47:09.385]                 if (is_error) {
[17:47:09.385]                   sessionInformation <- function() {
[17:47:09.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.385]                       search = base::search(), system = base::Sys.info())
[17:47:09.385]                   }
[17:47:09.385]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.385]                     cond$call), session = sessionInformation(), 
[17:47:09.385]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.385]                   signalCondition(cond)
[17:47:09.385]                 }
[17:47:09.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.385]                 "immediateCondition"))) {
[17:47:09.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.385]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.385]                   if (TRUE && !signal) {
[17:47:09.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.385]                     {
[17:47:09.385]                       inherits <- base::inherits
[17:47:09.385]                       invokeRestart <- base::invokeRestart
[17:47:09.385]                       is.null <- base::is.null
[17:47:09.385]                       muffled <- FALSE
[17:47:09.385]                       if (inherits(cond, "message")) {
[17:47:09.385]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.385]                         if (muffled) 
[17:47:09.385]                           invokeRestart("muffleMessage")
[17:47:09.385]                       }
[17:47:09.385]                       else if (inherits(cond, "warning")) {
[17:47:09.385]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.385]                         if (muffled) 
[17:47:09.385]                           invokeRestart("muffleWarning")
[17:47:09.385]                       }
[17:47:09.385]                       else if (inherits(cond, "condition")) {
[17:47:09.385]                         if (!is.null(pattern)) {
[17:47:09.385]                           computeRestarts <- base::computeRestarts
[17:47:09.385]                           grepl <- base::grepl
[17:47:09.385]                           restarts <- computeRestarts(cond)
[17:47:09.385]                           for (restart in restarts) {
[17:47:09.385]                             name <- restart$name
[17:47:09.385]                             if (is.null(name)) 
[17:47:09.385]                               next
[17:47:09.385]                             if (!grepl(pattern, name)) 
[17:47:09.385]                               next
[17:47:09.385]                             invokeRestart(restart)
[17:47:09.385]                             muffled <- TRUE
[17:47:09.385]                             break
[17:47:09.385]                           }
[17:47:09.385]                         }
[17:47:09.385]                       }
[17:47:09.385]                       invisible(muffled)
[17:47:09.385]                     }
[17:47:09.385]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.385]                   }
[17:47:09.385]                 }
[17:47:09.385]                 else {
[17:47:09.385]                   if (TRUE) {
[17:47:09.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.385]                     {
[17:47:09.385]                       inherits <- base::inherits
[17:47:09.385]                       invokeRestart <- base::invokeRestart
[17:47:09.385]                       is.null <- base::is.null
[17:47:09.385]                       muffled <- FALSE
[17:47:09.385]                       if (inherits(cond, "message")) {
[17:47:09.385]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.385]                         if (muffled) 
[17:47:09.385]                           invokeRestart("muffleMessage")
[17:47:09.385]                       }
[17:47:09.385]                       else if (inherits(cond, "warning")) {
[17:47:09.385]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.385]                         if (muffled) 
[17:47:09.385]                           invokeRestart("muffleWarning")
[17:47:09.385]                       }
[17:47:09.385]                       else if (inherits(cond, "condition")) {
[17:47:09.385]                         if (!is.null(pattern)) {
[17:47:09.385]                           computeRestarts <- base::computeRestarts
[17:47:09.385]                           grepl <- base::grepl
[17:47:09.385]                           restarts <- computeRestarts(cond)
[17:47:09.385]                           for (restart in restarts) {
[17:47:09.385]                             name <- restart$name
[17:47:09.385]                             if (is.null(name)) 
[17:47:09.385]                               next
[17:47:09.385]                             if (!grepl(pattern, name)) 
[17:47:09.385]                               next
[17:47:09.385]                             invokeRestart(restart)
[17:47:09.385]                             muffled <- TRUE
[17:47:09.385]                             break
[17:47:09.385]                           }
[17:47:09.385]                         }
[17:47:09.385]                       }
[17:47:09.385]                       invisible(muffled)
[17:47:09.385]                     }
[17:47:09.385]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.385]                   }
[17:47:09.385]                 }
[17:47:09.385]             }
[17:47:09.385]         }))
[17:47:09.385]     }, error = function(ex) {
[17:47:09.385]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.385]                 ...future.rng), started = ...future.startTime, 
[17:47:09.385]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.385]             version = "1.8"), class = "FutureResult")
[17:47:09.385]     }, finally = {
[17:47:09.385]         if (!identical(...future.workdir, getwd())) 
[17:47:09.385]             setwd(...future.workdir)
[17:47:09.385]         {
[17:47:09.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.385]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.385]             }
[17:47:09.385]             base::options(...future.oldOptions)
[17:47:09.385]             if (.Platform$OS.type == "windows") {
[17:47:09.385]                 old_names <- names(...future.oldEnvVars)
[17:47:09.385]                 envs <- base::Sys.getenv()
[17:47:09.385]                 names <- names(envs)
[17:47:09.385]                 common <- intersect(names, old_names)
[17:47:09.385]                 added <- setdiff(names, old_names)
[17:47:09.385]                 removed <- setdiff(old_names, names)
[17:47:09.385]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.385]                   envs[common]]
[17:47:09.385]                 NAMES <- toupper(changed)
[17:47:09.385]                 args <- list()
[17:47:09.385]                 for (kk in seq_along(NAMES)) {
[17:47:09.385]                   name <- changed[[kk]]
[17:47:09.385]                   NAME <- NAMES[[kk]]
[17:47:09.385]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.385]                     next
[17:47:09.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.385]                 }
[17:47:09.385]                 NAMES <- toupper(added)
[17:47:09.385]                 for (kk in seq_along(NAMES)) {
[17:47:09.385]                   name <- added[[kk]]
[17:47:09.385]                   NAME <- NAMES[[kk]]
[17:47:09.385]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.385]                     next
[17:47:09.385]                   args[[name]] <- ""
[17:47:09.385]                 }
[17:47:09.385]                 NAMES <- toupper(removed)
[17:47:09.385]                 for (kk in seq_along(NAMES)) {
[17:47:09.385]                   name <- removed[[kk]]
[17:47:09.385]                   NAME <- NAMES[[kk]]
[17:47:09.385]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.385]                     next
[17:47:09.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.385]                 }
[17:47:09.385]                 if (length(args) > 0) 
[17:47:09.385]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.385]             }
[17:47:09.385]             else {
[17:47:09.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.385]             }
[17:47:09.385]             {
[17:47:09.385]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.385]                   0L) {
[17:47:09.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.385]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.385]                   base::options(opts)
[17:47:09.385]                 }
[17:47:09.385]                 {
[17:47:09.385]                   {
[17:47:09.385]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.385]                     NULL
[17:47:09.385]                   }
[17:47:09.385]                   options(future.plan = NULL)
[17:47:09.385]                   if (is.na(NA_character_)) 
[17:47:09.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.385]                     .init = FALSE)
[17:47:09.385]                 }
[17:47:09.385]             }
[17:47:09.385]         }
[17:47:09.385]     })
[17:47:09.385]     if (TRUE) {
[17:47:09.385]         base::sink(type = "output", split = FALSE)
[17:47:09.385]         if (TRUE) {
[17:47:09.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.385]         }
[17:47:09.385]         else {
[17:47:09.385]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.385]         }
[17:47:09.385]         base::close(...future.stdout)
[17:47:09.385]         ...future.stdout <- NULL
[17:47:09.385]     }
[17:47:09.385]     ...future.result$conditions <- ...future.conditions
[17:47:09.385]     ...future.result$finished <- base::Sys.time()
[17:47:09.385]     ...future.result
[17:47:09.385] }
[17:47:09.388] MultisessionFuture started
[17:47:09.388] - Launch lazy future ... done
[17:47:09.388] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.389] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.389] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.390] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:09.390] Searching for globals ... DONE
[17:47:09.390] Resolving globals: TRUE
[17:47:09.390] Resolving any globals that are futures ...
[17:47:09.390] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:09.390] Resolving any globals that are futures ... DONE
[17:47:09.390] Resolving futures part of globals (recursively) ...
[17:47:09.391] resolve() on list ...
[17:47:09.391]  recursive: 99
[17:47:09.391]  length: 1
[17:47:09.391]  elements: ‘a’
[17:47:09.433] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.433] - Validating connection of MultisessionFuture
[17:47:09.433] - received message: FutureResult
[17:47:09.433] - Received FutureResult
[17:47:09.434] - Erased future from FutureRegistry
[17:47:09.434] result() for ClusterFuture ...
[17:47:09.434] - result already collected: FutureResult
[17:47:09.434] result() for ClusterFuture ... done
[17:47:09.434] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.434] Future #1
[17:47:09.434] result() for ClusterFuture ...
[17:47:09.434] - result already collected: FutureResult
[17:47:09.434] result() for ClusterFuture ... done
[17:47:09.434] result() for ClusterFuture ...
[17:47:09.435] - result already collected: FutureResult
[17:47:09.435] result() for ClusterFuture ... done
[17:47:09.435] A MultisessionFuture was resolved
[17:47:09.435]  length: 0 (resolved future 1)
[17:47:09.435] resolve() on list ... DONE
[17:47:09.435] - globals: [1] ‘a’
[17:47:09.435] Resolving futures part of globals (recursively) ... DONE
[17:47:09.436] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[17:47:09.436] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[17:47:09.437] - globals: [1] ‘a’
[17:47:09.437] - packages: [1] ‘future’
[17:47:09.437] getGlobalsAndPackages() ... DONE
[17:47:09.437] run() for ‘Future’ ...
[17:47:09.437] - state: ‘created’
[17:47:09.437] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.453] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.453]   - Field: ‘node’
[17:47:09.453]   - Field: ‘label’
[17:47:09.454]   - Field: ‘local’
[17:47:09.454]   - Field: ‘owner’
[17:47:09.454]   - Field: ‘envir’
[17:47:09.454]   - Field: ‘workers’
[17:47:09.454]   - Field: ‘packages’
[17:47:09.454]   - Field: ‘gc’
[17:47:09.454]   - Field: ‘conditions’
[17:47:09.454]   - Field: ‘persistent’
[17:47:09.454]   - Field: ‘expr’
[17:47:09.454]   - Field: ‘uuid’
[17:47:09.454]   - Field: ‘seed’
[17:47:09.455]   - Field: ‘version’
[17:47:09.455]   - Field: ‘result’
[17:47:09.455]   - Field: ‘asynchronous’
[17:47:09.455]   - Field: ‘calls’
[17:47:09.455]   - Field: ‘globals’
[17:47:09.455]   - Field: ‘stdout’
[17:47:09.455]   - Field: ‘earlySignal’
[17:47:09.455]   - Field: ‘lazy’
[17:47:09.455]   - Field: ‘state’
[17:47:09.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.455] - Launch lazy future ...
[17:47:09.456] Packages needed by the future expression (n = 1): ‘future’
[17:47:09.456] Packages needed by future strategies (n = 0): <none>
[17:47:09.456] {
[17:47:09.456]     {
[17:47:09.456]         {
[17:47:09.456]             ...future.startTime <- base::Sys.time()
[17:47:09.456]             {
[17:47:09.456]                 {
[17:47:09.456]                   {
[17:47:09.456]                     {
[17:47:09.456]                       {
[17:47:09.456]                         base::local({
[17:47:09.456]                           has_future <- base::requireNamespace("future", 
[17:47:09.456]                             quietly = TRUE)
[17:47:09.456]                           if (has_future) {
[17:47:09.456]                             ns <- base::getNamespace("future")
[17:47:09.456]                             version <- ns[[".package"]][["version"]]
[17:47:09.456]                             if (is.null(version)) 
[17:47:09.456]                               version <- utils::packageVersion("future")
[17:47:09.456]                           }
[17:47:09.456]                           else {
[17:47:09.456]                             version <- NULL
[17:47:09.456]                           }
[17:47:09.456]                           if (!has_future || version < "1.8.0") {
[17:47:09.456]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.456]                               "", base::R.version$version.string), 
[17:47:09.456]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:09.456]                                 base::R.version$platform, 8 * 
[17:47:09.456]                                   base::.Machine$sizeof.pointer), 
[17:47:09.456]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.456]                                 "release", "version")], collapse = " "), 
[17:47:09.456]                               hostname = base::Sys.info()[["nodename"]])
[17:47:09.456]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.456]                               info)
[17:47:09.456]                             info <- base::paste(info, collapse = "; ")
[17:47:09.456]                             if (!has_future) {
[17:47:09.456]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.456]                                 info)
[17:47:09.456]                             }
[17:47:09.456]                             else {
[17:47:09.456]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.456]                                 info, version)
[17:47:09.456]                             }
[17:47:09.456]                             base::stop(msg)
[17:47:09.456]                           }
[17:47:09.456]                         })
[17:47:09.456]                       }
[17:47:09.456]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.456]                       base::options(mc.cores = 1L)
[17:47:09.456]                     }
[17:47:09.456]                     base::local({
[17:47:09.456]                       for (pkg in "future") {
[17:47:09.456]                         base::loadNamespace(pkg)
[17:47:09.456]                         base::library(pkg, character.only = TRUE)
[17:47:09.456]                       }
[17:47:09.456]                     })
[17:47:09.456]                   }
[17:47:09.456]                   ...future.strategy.old <- future::plan("list")
[17:47:09.456]                   options(future.plan = NULL)
[17:47:09.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.456]                 }
[17:47:09.456]                 ...future.workdir <- getwd()
[17:47:09.456]             }
[17:47:09.456]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.456]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.456]         }
[17:47:09.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.456]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.456]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.456]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.456]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.456]             base::names(...future.oldOptions))
[17:47:09.456]     }
[17:47:09.456]     if (FALSE) {
[17:47:09.456]     }
[17:47:09.456]     else {
[17:47:09.456]         if (TRUE) {
[17:47:09.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.456]                 open = "w")
[17:47:09.456]         }
[17:47:09.456]         else {
[17:47:09.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.456]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.456]         }
[17:47:09.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.456]             base::sink(type = "output", split = FALSE)
[17:47:09.456]             base::close(...future.stdout)
[17:47:09.456]         }, add = TRUE)
[17:47:09.456]     }
[17:47:09.456]     ...future.frame <- base::sys.nframe()
[17:47:09.456]     ...future.conditions <- base::list()
[17:47:09.456]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.456]     if (FALSE) {
[17:47:09.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.456]     }
[17:47:09.456]     ...future.result <- base::tryCatch({
[17:47:09.456]         base::withCallingHandlers({
[17:47:09.456]             ...future.value <- base::withVisible(base::local({
[17:47:09.456]                 ...future.makeSendCondition <- base::local({
[17:47:09.456]                   sendCondition <- NULL
[17:47:09.456]                   function(frame = 1L) {
[17:47:09.456]                     if (is.function(sendCondition)) 
[17:47:09.456]                       return(sendCondition)
[17:47:09.456]                     ns <- getNamespace("parallel")
[17:47:09.456]                     if (exists("sendData", mode = "function", 
[17:47:09.456]                       envir = ns)) {
[17:47:09.456]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.456]                         envir = ns)
[17:47:09.456]                       envir <- sys.frame(frame)
[17:47:09.456]                       master <- NULL
[17:47:09.456]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.456]                         !identical(envir, emptyenv())) {
[17:47:09.456]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.456]                           inherits = FALSE)) {
[17:47:09.456]                           master <- get("master", mode = "list", 
[17:47:09.456]                             envir = envir, inherits = FALSE)
[17:47:09.456]                           if (inherits(master, c("SOCKnode", 
[17:47:09.456]                             "SOCK0node"))) {
[17:47:09.456]                             sendCondition <<- function(cond) {
[17:47:09.456]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.456]                                 success = TRUE)
[17:47:09.456]                               parallel_sendData(master, data)
[17:47:09.456]                             }
[17:47:09.456]                             return(sendCondition)
[17:47:09.456]                           }
[17:47:09.456]                         }
[17:47:09.456]                         frame <- frame + 1L
[17:47:09.456]                         envir <- sys.frame(frame)
[17:47:09.456]                       }
[17:47:09.456]                     }
[17:47:09.456]                     sendCondition <<- function(cond) NULL
[17:47:09.456]                   }
[17:47:09.456]                 })
[17:47:09.456]                 withCallingHandlers({
[17:47:09.456]                   value(a) + 1
[17:47:09.456]                 }, immediateCondition = function(cond) {
[17:47:09.456]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.456]                   sendCondition(cond)
[17:47:09.456]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.456]                   {
[17:47:09.456]                     inherits <- base::inherits
[17:47:09.456]                     invokeRestart <- base::invokeRestart
[17:47:09.456]                     is.null <- base::is.null
[17:47:09.456]                     muffled <- FALSE
[17:47:09.456]                     if (inherits(cond, "message")) {
[17:47:09.456]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.456]                       if (muffled) 
[17:47:09.456]                         invokeRestart("muffleMessage")
[17:47:09.456]                     }
[17:47:09.456]                     else if (inherits(cond, "warning")) {
[17:47:09.456]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.456]                       if (muffled) 
[17:47:09.456]                         invokeRestart("muffleWarning")
[17:47:09.456]                     }
[17:47:09.456]                     else if (inherits(cond, "condition")) {
[17:47:09.456]                       if (!is.null(pattern)) {
[17:47:09.456]                         computeRestarts <- base::computeRestarts
[17:47:09.456]                         grepl <- base::grepl
[17:47:09.456]                         restarts <- computeRestarts(cond)
[17:47:09.456]                         for (restart in restarts) {
[17:47:09.456]                           name <- restart$name
[17:47:09.456]                           if (is.null(name)) 
[17:47:09.456]                             next
[17:47:09.456]                           if (!grepl(pattern, name)) 
[17:47:09.456]                             next
[17:47:09.456]                           invokeRestart(restart)
[17:47:09.456]                           muffled <- TRUE
[17:47:09.456]                           break
[17:47:09.456]                         }
[17:47:09.456]                       }
[17:47:09.456]                     }
[17:47:09.456]                     invisible(muffled)
[17:47:09.456]                   }
[17:47:09.456]                   muffleCondition(cond)
[17:47:09.456]                 })
[17:47:09.456]             }))
[17:47:09.456]             future::FutureResult(value = ...future.value$value, 
[17:47:09.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.456]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.456]                     ...future.globalenv.names))
[17:47:09.456]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.456]         }, condition = base::local({
[17:47:09.456]             c <- base::c
[17:47:09.456]             inherits <- base::inherits
[17:47:09.456]             invokeRestart <- base::invokeRestart
[17:47:09.456]             length <- base::length
[17:47:09.456]             list <- base::list
[17:47:09.456]             seq.int <- base::seq.int
[17:47:09.456]             signalCondition <- base::signalCondition
[17:47:09.456]             sys.calls <- base::sys.calls
[17:47:09.456]             `[[` <- base::`[[`
[17:47:09.456]             `+` <- base::`+`
[17:47:09.456]             `<<-` <- base::`<<-`
[17:47:09.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.456]                   3L)]
[17:47:09.456]             }
[17:47:09.456]             function(cond) {
[17:47:09.456]                 is_error <- inherits(cond, "error")
[17:47:09.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.456]                   NULL)
[17:47:09.456]                 if (is_error) {
[17:47:09.456]                   sessionInformation <- function() {
[17:47:09.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.456]                       search = base::search(), system = base::Sys.info())
[17:47:09.456]                   }
[17:47:09.456]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.456]                     cond$call), session = sessionInformation(), 
[17:47:09.456]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.456]                   signalCondition(cond)
[17:47:09.456]                 }
[17:47:09.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.456]                 "immediateCondition"))) {
[17:47:09.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.456]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.456]                   if (TRUE && !signal) {
[17:47:09.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.456]                     {
[17:47:09.456]                       inherits <- base::inherits
[17:47:09.456]                       invokeRestart <- base::invokeRestart
[17:47:09.456]                       is.null <- base::is.null
[17:47:09.456]                       muffled <- FALSE
[17:47:09.456]                       if (inherits(cond, "message")) {
[17:47:09.456]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.456]                         if (muffled) 
[17:47:09.456]                           invokeRestart("muffleMessage")
[17:47:09.456]                       }
[17:47:09.456]                       else if (inherits(cond, "warning")) {
[17:47:09.456]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.456]                         if (muffled) 
[17:47:09.456]                           invokeRestart("muffleWarning")
[17:47:09.456]                       }
[17:47:09.456]                       else if (inherits(cond, "condition")) {
[17:47:09.456]                         if (!is.null(pattern)) {
[17:47:09.456]                           computeRestarts <- base::computeRestarts
[17:47:09.456]                           grepl <- base::grepl
[17:47:09.456]                           restarts <- computeRestarts(cond)
[17:47:09.456]                           for (restart in restarts) {
[17:47:09.456]                             name <- restart$name
[17:47:09.456]                             if (is.null(name)) 
[17:47:09.456]                               next
[17:47:09.456]                             if (!grepl(pattern, name)) 
[17:47:09.456]                               next
[17:47:09.456]                             invokeRestart(restart)
[17:47:09.456]                             muffled <- TRUE
[17:47:09.456]                             break
[17:47:09.456]                           }
[17:47:09.456]                         }
[17:47:09.456]                       }
[17:47:09.456]                       invisible(muffled)
[17:47:09.456]                     }
[17:47:09.456]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.456]                   }
[17:47:09.456]                 }
[17:47:09.456]                 else {
[17:47:09.456]                   if (TRUE) {
[17:47:09.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.456]                     {
[17:47:09.456]                       inherits <- base::inherits
[17:47:09.456]                       invokeRestart <- base::invokeRestart
[17:47:09.456]                       is.null <- base::is.null
[17:47:09.456]                       muffled <- FALSE
[17:47:09.456]                       if (inherits(cond, "message")) {
[17:47:09.456]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.456]                         if (muffled) 
[17:47:09.456]                           invokeRestart("muffleMessage")
[17:47:09.456]                       }
[17:47:09.456]                       else if (inherits(cond, "warning")) {
[17:47:09.456]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.456]                         if (muffled) 
[17:47:09.456]                           invokeRestart("muffleWarning")
[17:47:09.456]                       }
[17:47:09.456]                       else if (inherits(cond, "condition")) {
[17:47:09.456]                         if (!is.null(pattern)) {
[17:47:09.456]                           computeRestarts <- base::computeRestarts
[17:47:09.456]                           grepl <- base::grepl
[17:47:09.456]                           restarts <- computeRestarts(cond)
[17:47:09.456]                           for (restart in restarts) {
[17:47:09.456]                             name <- restart$name
[17:47:09.456]                             if (is.null(name)) 
[17:47:09.456]                               next
[17:47:09.456]                             if (!grepl(pattern, name)) 
[17:47:09.456]                               next
[17:47:09.456]                             invokeRestart(restart)
[17:47:09.456]                             muffled <- TRUE
[17:47:09.456]                             break
[17:47:09.456]                           }
[17:47:09.456]                         }
[17:47:09.456]                       }
[17:47:09.456]                       invisible(muffled)
[17:47:09.456]                     }
[17:47:09.456]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.456]                   }
[17:47:09.456]                 }
[17:47:09.456]             }
[17:47:09.456]         }))
[17:47:09.456]     }, error = function(ex) {
[17:47:09.456]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.456]                 ...future.rng), started = ...future.startTime, 
[17:47:09.456]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.456]             version = "1.8"), class = "FutureResult")
[17:47:09.456]     }, finally = {
[17:47:09.456]         if (!identical(...future.workdir, getwd())) 
[17:47:09.456]             setwd(...future.workdir)
[17:47:09.456]         {
[17:47:09.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.456]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.456]             }
[17:47:09.456]             base::options(...future.oldOptions)
[17:47:09.456]             if (.Platform$OS.type == "windows") {
[17:47:09.456]                 old_names <- names(...future.oldEnvVars)
[17:47:09.456]                 envs <- base::Sys.getenv()
[17:47:09.456]                 names <- names(envs)
[17:47:09.456]                 common <- intersect(names, old_names)
[17:47:09.456]                 added <- setdiff(names, old_names)
[17:47:09.456]                 removed <- setdiff(old_names, names)
[17:47:09.456]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.456]                   envs[common]]
[17:47:09.456]                 NAMES <- toupper(changed)
[17:47:09.456]                 args <- list()
[17:47:09.456]                 for (kk in seq_along(NAMES)) {
[17:47:09.456]                   name <- changed[[kk]]
[17:47:09.456]                   NAME <- NAMES[[kk]]
[17:47:09.456]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.456]                     next
[17:47:09.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.456]                 }
[17:47:09.456]                 NAMES <- toupper(added)
[17:47:09.456]                 for (kk in seq_along(NAMES)) {
[17:47:09.456]                   name <- added[[kk]]
[17:47:09.456]                   NAME <- NAMES[[kk]]
[17:47:09.456]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.456]                     next
[17:47:09.456]                   args[[name]] <- ""
[17:47:09.456]                 }
[17:47:09.456]                 NAMES <- toupper(removed)
[17:47:09.456]                 for (kk in seq_along(NAMES)) {
[17:47:09.456]                   name <- removed[[kk]]
[17:47:09.456]                   NAME <- NAMES[[kk]]
[17:47:09.456]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.456]                     next
[17:47:09.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.456]                 }
[17:47:09.456]                 if (length(args) > 0) 
[17:47:09.456]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.456]             }
[17:47:09.456]             else {
[17:47:09.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.456]             }
[17:47:09.456]             {
[17:47:09.456]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.456]                   0L) {
[17:47:09.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.456]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.456]                   base::options(opts)
[17:47:09.456]                 }
[17:47:09.456]                 {
[17:47:09.456]                   {
[17:47:09.456]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.456]                     NULL
[17:47:09.456]                   }
[17:47:09.456]                   options(future.plan = NULL)
[17:47:09.456]                   if (is.na(NA_character_)) 
[17:47:09.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.456]                     .init = FALSE)
[17:47:09.456]                 }
[17:47:09.456]             }
[17:47:09.456]         }
[17:47:09.456]     })
[17:47:09.456]     if (TRUE) {
[17:47:09.456]         base::sink(type = "output", split = FALSE)
[17:47:09.456]         if (TRUE) {
[17:47:09.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.456]         }
[17:47:09.456]         else {
[17:47:09.456]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.456]         }
[17:47:09.456]         base::close(...future.stdout)
[17:47:09.456]         ...future.stdout <- NULL
[17:47:09.456]     }
[17:47:09.456]     ...future.result$conditions <- ...future.conditions
[17:47:09.456]     ...future.result$finished <- base::Sys.time()
[17:47:09.456]     ...future.result
[17:47:09.456] }
[17:47:09.459] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[17:47:09.460] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[17:47:09.512] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[17:47:09.512] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[17:47:09.512] MultisessionFuture started
[17:47:09.512] - Launch lazy future ... done
[17:47:09.513] run() for ‘MultisessionFuture’ ... done
[17:47:09.513] result() for ClusterFuture ...
[17:47:09.513] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.513] - Validating connection of MultisessionFuture
[17:47:09.557] - received message: FutureResult
[17:47:09.558] - Received FutureResult
[17:47:09.558] - Erased future from FutureRegistry
[17:47:09.558] result() for ClusterFuture ...
[17:47:09.558] - result already collected: FutureResult
[17:47:09.558] result() for ClusterFuture ... done
[17:47:09.558] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.558] result() for ClusterFuture ... done
[17:47:09.558] result() for ClusterFuture ...
[17:47:09.558] - result already collected: FutureResult
[17:47:09.558] result() for ClusterFuture ... done
value(b) = 2
[17:47:09.559] result() for ClusterFuture ...
[17:47:09.559] - result already collected: FutureResult
[17:47:09.559] result() for ClusterFuture ... done
[17:47:09.559] result() for ClusterFuture ...
[17:47:09.559] - result already collected: FutureResult
[17:47:09.559] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.559] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.560] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.560] 
[17:47:09.560] Searching for globals ... DONE
[17:47:09.560] - globals: [0] <none>
[17:47:09.560] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.561] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.561] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.562] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:09.562] Searching for globals ... DONE
[17:47:09.562] Resolving globals: TRUE
[17:47:09.562] Resolving any globals that are futures ...
[17:47:09.562] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:09.562] Resolving any globals that are futures ... DONE
[17:47:09.563] Resolving futures part of globals (recursively) ...
[17:47:09.563] resolve() on list ...
[17:47:09.563]  recursive: 99
[17:47:09.563]  length: 1
[17:47:09.563]  elements: ‘a’
[17:47:09.563] run() for ‘Future’ ...
[17:47:09.563] - state: ‘created’
[17:47:09.563] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.577] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.577]   - Field: ‘node’
[17:47:09.578]   - Field: ‘label’
[17:47:09.578]   - Field: ‘local’
[17:47:09.578]   - Field: ‘owner’
[17:47:09.578]   - Field: ‘envir’
[17:47:09.578]   - Field: ‘workers’
[17:47:09.578]   - Field: ‘packages’
[17:47:09.578]   - Field: ‘gc’
[17:47:09.578]   - Field: ‘conditions’
[17:47:09.578]   - Field: ‘persistent’
[17:47:09.578]   - Field: ‘expr’
[17:47:09.578]   - Field: ‘uuid’
[17:47:09.578]   - Field: ‘seed’
[17:47:09.579]   - Field: ‘version’
[17:47:09.579]   - Field: ‘result’
[17:47:09.579]   - Field: ‘asynchronous’
[17:47:09.579]   - Field: ‘calls’
[17:47:09.579]   - Field: ‘globals’
[17:47:09.579]   - Field: ‘stdout’
[17:47:09.579]   - Field: ‘earlySignal’
[17:47:09.579]   - Field: ‘lazy’
[17:47:09.579]   - Field: ‘state’
[17:47:09.579] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.580] - Launch lazy future ...
[17:47:09.580] Packages needed by the future expression (n = 0): <none>
[17:47:09.580] Packages needed by future strategies (n = 0): <none>
[17:47:09.580] {
[17:47:09.580]     {
[17:47:09.580]         {
[17:47:09.580]             ...future.startTime <- base::Sys.time()
[17:47:09.580]             {
[17:47:09.580]                 {
[17:47:09.580]                   {
[17:47:09.580]                     {
[17:47:09.580]                       base::local({
[17:47:09.580]                         has_future <- base::requireNamespace("future", 
[17:47:09.580]                           quietly = TRUE)
[17:47:09.580]                         if (has_future) {
[17:47:09.580]                           ns <- base::getNamespace("future")
[17:47:09.580]                           version <- ns[[".package"]][["version"]]
[17:47:09.580]                           if (is.null(version)) 
[17:47:09.580]                             version <- utils::packageVersion("future")
[17:47:09.580]                         }
[17:47:09.580]                         else {
[17:47:09.580]                           version <- NULL
[17:47:09.580]                         }
[17:47:09.580]                         if (!has_future || version < "1.8.0") {
[17:47:09.580]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.580]                             "", base::R.version$version.string), 
[17:47:09.580]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:09.580]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.580]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.580]                               "release", "version")], collapse = " "), 
[17:47:09.580]                             hostname = base::Sys.info()[["nodename"]])
[17:47:09.580]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.580]                             info)
[17:47:09.580]                           info <- base::paste(info, collapse = "; ")
[17:47:09.580]                           if (!has_future) {
[17:47:09.580]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.580]                               info)
[17:47:09.580]                           }
[17:47:09.580]                           else {
[17:47:09.580]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.580]                               info, version)
[17:47:09.580]                           }
[17:47:09.580]                           base::stop(msg)
[17:47:09.580]                         }
[17:47:09.580]                       })
[17:47:09.580]                     }
[17:47:09.580]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.580]                     base::options(mc.cores = 1L)
[17:47:09.580]                   }
[17:47:09.580]                   ...future.strategy.old <- future::plan("list")
[17:47:09.580]                   options(future.plan = NULL)
[17:47:09.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.580]                 }
[17:47:09.580]                 ...future.workdir <- getwd()
[17:47:09.580]             }
[17:47:09.580]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.580]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.580]         }
[17:47:09.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.580]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.580]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.580]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.580]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.580]             base::names(...future.oldOptions))
[17:47:09.580]     }
[17:47:09.580]     if (FALSE) {
[17:47:09.580]     }
[17:47:09.580]     else {
[17:47:09.580]         if (TRUE) {
[17:47:09.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.580]                 open = "w")
[17:47:09.580]         }
[17:47:09.580]         else {
[17:47:09.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.580]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.580]         }
[17:47:09.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.580]             base::sink(type = "output", split = FALSE)
[17:47:09.580]             base::close(...future.stdout)
[17:47:09.580]         }, add = TRUE)
[17:47:09.580]     }
[17:47:09.580]     ...future.frame <- base::sys.nframe()
[17:47:09.580]     ...future.conditions <- base::list()
[17:47:09.580]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.580]     if (FALSE) {
[17:47:09.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.580]     }
[17:47:09.580]     ...future.result <- base::tryCatch({
[17:47:09.580]         base::withCallingHandlers({
[17:47:09.580]             ...future.value <- base::withVisible(base::local({
[17:47:09.580]                 ...future.makeSendCondition <- base::local({
[17:47:09.580]                   sendCondition <- NULL
[17:47:09.580]                   function(frame = 1L) {
[17:47:09.580]                     if (is.function(sendCondition)) 
[17:47:09.580]                       return(sendCondition)
[17:47:09.580]                     ns <- getNamespace("parallel")
[17:47:09.580]                     if (exists("sendData", mode = "function", 
[17:47:09.580]                       envir = ns)) {
[17:47:09.580]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.580]                         envir = ns)
[17:47:09.580]                       envir <- sys.frame(frame)
[17:47:09.580]                       master <- NULL
[17:47:09.580]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.580]                         !identical(envir, emptyenv())) {
[17:47:09.580]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.580]                           inherits = FALSE)) {
[17:47:09.580]                           master <- get("master", mode = "list", 
[17:47:09.580]                             envir = envir, inherits = FALSE)
[17:47:09.580]                           if (inherits(master, c("SOCKnode", 
[17:47:09.580]                             "SOCK0node"))) {
[17:47:09.580]                             sendCondition <<- function(cond) {
[17:47:09.580]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.580]                                 success = TRUE)
[17:47:09.580]                               parallel_sendData(master, data)
[17:47:09.580]                             }
[17:47:09.580]                             return(sendCondition)
[17:47:09.580]                           }
[17:47:09.580]                         }
[17:47:09.580]                         frame <- frame + 1L
[17:47:09.580]                         envir <- sys.frame(frame)
[17:47:09.580]                       }
[17:47:09.580]                     }
[17:47:09.580]                     sendCondition <<- function(cond) NULL
[17:47:09.580]                   }
[17:47:09.580]                 })
[17:47:09.580]                 withCallingHandlers({
[17:47:09.580]                   1
[17:47:09.580]                 }, immediateCondition = function(cond) {
[17:47:09.580]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.580]                   sendCondition(cond)
[17:47:09.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.580]                   {
[17:47:09.580]                     inherits <- base::inherits
[17:47:09.580]                     invokeRestart <- base::invokeRestart
[17:47:09.580]                     is.null <- base::is.null
[17:47:09.580]                     muffled <- FALSE
[17:47:09.580]                     if (inherits(cond, "message")) {
[17:47:09.580]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.580]                       if (muffled) 
[17:47:09.580]                         invokeRestart("muffleMessage")
[17:47:09.580]                     }
[17:47:09.580]                     else if (inherits(cond, "warning")) {
[17:47:09.580]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.580]                       if (muffled) 
[17:47:09.580]                         invokeRestart("muffleWarning")
[17:47:09.580]                     }
[17:47:09.580]                     else if (inherits(cond, "condition")) {
[17:47:09.580]                       if (!is.null(pattern)) {
[17:47:09.580]                         computeRestarts <- base::computeRestarts
[17:47:09.580]                         grepl <- base::grepl
[17:47:09.580]                         restarts <- computeRestarts(cond)
[17:47:09.580]                         for (restart in restarts) {
[17:47:09.580]                           name <- restart$name
[17:47:09.580]                           if (is.null(name)) 
[17:47:09.580]                             next
[17:47:09.580]                           if (!grepl(pattern, name)) 
[17:47:09.580]                             next
[17:47:09.580]                           invokeRestart(restart)
[17:47:09.580]                           muffled <- TRUE
[17:47:09.580]                           break
[17:47:09.580]                         }
[17:47:09.580]                       }
[17:47:09.580]                     }
[17:47:09.580]                     invisible(muffled)
[17:47:09.580]                   }
[17:47:09.580]                   muffleCondition(cond)
[17:47:09.580]                 })
[17:47:09.580]             }))
[17:47:09.580]             future::FutureResult(value = ...future.value$value, 
[17:47:09.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.580]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.580]                     ...future.globalenv.names))
[17:47:09.580]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.580]         }, condition = base::local({
[17:47:09.580]             c <- base::c
[17:47:09.580]             inherits <- base::inherits
[17:47:09.580]             invokeRestart <- base::invokeRestart
[17:47:09.580]             length <- base::length
[17:47:09.580]             list <- base::list
[17:47:09.580]             seq.int <- base::seq.int
[17:47:09.580]             signalCondition <- base::signalCondition
[17:47:09.580]             sys.calls <- base::sys.calls
[17:47:09.580]             `[[` <- base::`[[`
[17:47:09.580]             `+` <- base::`+`
[17:47:09.580]             `<<-` <- base::`<<-`
[17:47:09.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.580]                   3L)]
[17:47:09.580]             }
[17:47:09.580]             function(cond) {
[17:47:09.580]                 is_error <- inherits(cond, "error")
[17:47:09.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.580]                   NULL)
[17:47:09.580]                 if (is_error) {
[17:47:09.580]                   sessionInformation <- function() {
[17:47:09.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.580]                       search = base::search(), system = base::Sys.info())
[17:47:09.580]                   }
[17:47:09.580]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.580]                     cond$call), session = sessionInformation(), 
[17:47:09.580]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.580]                   signalCondition(cond)
[17:47:09.580]                 }
[17:47:09.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.580]                 "immediateCondition"))) {
[17:47:09.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.580]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.580]                   if (TRUE && !signal) {
[17:47:09.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.580]                     {
[17:47:09.580]                       inherits <- base::inherits
[17:47:09.580]                       invokeRestart <- base::invokeRestart
[17:47:09.580]                       is.null <- base::is.null
[17:47:09.580]                       muffled <- FALSE
[17:47:09.580]                       if (inherits(cond, "message")) {
[17:47:09.580]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.580]                         if (muffled) 
[17:47:09.580]                           invokeRestart("muffleMessage")
[17:47:09.580]                       }
[17:47:09.580]                       else if (inherits(cond, "warning")) {
[17:47:09.580]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.580]                         if (muffled) 
[17:47:09.580]                           invokeRestart("muffleWarning")
[17:47:09.580]                       }
[17:47:09.580]                       else if (inherits(cond, "condition")) {
[17:47:09.580]                         if (!is.null(pattern)) {
[17:47:09.580]                           computeRestarts <- base::computeRestarts
[17:47:09.580]                           grepl <- base::grepl
[17:47:09.580]                           restarts <- computeRestarts(cond)
[17:47:09.580]                           for (restart in restarts) {
[17:47:09.580]                             name <- restart$name
[17:47:09.580]                             if (is.null(name)) 
[17:47:09.580]                               next
[17:47:09.580]                             if (!grepl(pattern, name)) 
[17:47:09.580]                               next
[17:47:09.580]                             invokeRestart(restart)
[17:47:09.580]                             muffled <- TRUE
[17:47:09.580]                             break
[17:47:09.580]                           }
[17:47:09.580]                         }
[17:47:09.580]                       }
[17:47:09.580]                       invisible(muffled)
[17:47:09.580]                     }
[17:47:09.580]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.580]                   }
[17:47:09.580]                 }
[17:47:09.580]                 else {
[17:47:09.580]                   if (TRUE) {
[17:47:09.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.580]                     {
[17:47:09.580]                       inherits <- base::inherits
[17:47:09.580]                       invokeRestart <- base::invokeRestart
[17:47:09.580]                       is.null <- base::is.null
[17:47:09.580]                       muffled <- FALSE
[17:47:09.580]                       if (inherits(cond, "message")) {
[17:47:09.580]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.580]                         if (muffled) 
[17:47:09.580]                           invokeRestart("muffleMessage")
[17:47:09.580]                       }
[17:47:09.580]                       else if (inherits(cond, "warning")) {
[17:47:09.580]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.580]                         if (muffled) 
[17:47:09.580]                           invokeRestart("muffleWarning")
[17:47:09.580]                       }
[17:47:09.580]                       else if (inherits(cond, "condition")) {
[17:47:09.580]                         if (!is.null(pattern)) {
[17:47:09.580]                           computeRestarts <- base::computeRestarts
[17:47:09.580]                           grepl <- base::grepl
[17:47:09.580]                           restarts <- computeRestarts(cond)
[17:47:09.580]                           for (restart in restarts) {
[17:47:09.580]                             name <- restart$name
[17:47:09.580]                             if (is.null(name)) 
[17:47:09.580]                               next
[17:47:09.580]                             if (!grepl(pattern, name)) 
[17:47:09.580]                               next
[17:47:09.580]                             invokeRestart(restart)
[17:47:09.580]                             muffled <- TRUE
[17:47:09.580]                             break
[17:47:09.580]                           }
[17:47:09.580]                         }
[17:47:09.580]                       }
[17:47:09.580]                       invisible(muffled)
[17:47:09.580]                     }
[17:47:09.580]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.580]                   }
[17:47:09.580]                 }
[17:47:09.580]             }
[17:47:09.580]         }))
[17:47:09.580]     }, error = function(ex) {
[17:47:09.580]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.580]                 ...future.rng), started = ...future.startTime, 
[17:47:09.580]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.580]             version = "1.8"), class = "FutureResult")
[17:47:09.580]     }, finally = {
[17:47:09.580]         if (!identical(...future.workdir, getwd())) 
[17:47:09.580]             setwd(...future.workdir)
[17:47:09.580]         {
[17:47:09.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.580]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.580]             }
[17:47:09.580]             base::options(...future.oldOptions)
[17:47:09.580]             if (.Platform$OS.type == "windows") {
[17:47:09.580]                 old_names <- names(...future.oldEnvVars)
[17:47:09.580]                 envs <- base::Sys.getenv()
[17:47:09.580]                 names <- names(envs)
[17:47:09.580]                 common <- intersect(names, old_names)
[17:47:09.580]                 added <- setdiff(names, old_names)
[17:47:09.580]                 removed <- setdiff(old_names, names)
[17:47:09.580]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.580]                   envs[common]]
[17:47:09.580]                 NAMES <- toupper(changed)
[17:47:09.580]                 args <- list()
[17:47:09.580]                 for (kk in seq_along(NAMES)) {
[17:47:09.580]                   name <- changed[[kk]]
[17:47:09.580]                   NAME <- NAMES[[kk]]
[17:47:09.580]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.580]                     next
[17:47:09.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.580]                 }
[17:47:09.580]                 NAMES <- toupper(added)
[17:47:09.580]                 for (kk in seq_along(NAMES)) {
[17:47:09.580]                   name <- added[[kk]]
[17:47:09.580]                   NAME <- NAMES[[kk]]
[17:47:09.580]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.580]                     next
[17:47:09.580]                   args[[name]] <- ""
[17:47:09.580]                 }
[17:47:09.580]                 NAMES <- toupper(removed)
[17:47:09.580]                 for (kk in seq_along(NAMES)) {
[17:47:09.580]                   name <- removed[[kk]]
[17:47:09.580]                   NAME <- NAMES[[kk]]
[17:47:09.580]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.580]                     next
[17:47:09.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.580]                 }
[17:47:09.580]                 if (length(args) > 0) 
[17:47:09.580]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.580]             }
[17:47:09.580]             else {
[17:47:09.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.580]             }
[17:47:09.580]             {
[17:47:09.580]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.580]                   0L) {
[17:47:09.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.580]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.580]                   base::options(opts)
[17:47:09.580]                 }
[17:47:09.580]                 {
[17:47:09.580]                   {
[17:47:09.580]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.580]                     NULL
[17:47:09.580]                   }
[17:47:09.580]                   options(future.plan = NULL)
[17:47:09.580]                   if (is.na(NA_character_)) 
[17:47:09.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.580]                     .init = FALSE)
[17:47:09.580]                 }
[17:47:09.580]             }
[17:47:09.580]         }
[17:47:09.580]     })
[17:47:09.580]     if (TRUE) {
[17:47:09.580]         base::sink(type = "output", split = FALSE)
[17:47:09.580]         if (TRUE) {
[17:47:09.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.580]         }
[17:47:09.580]         else {
[17:47:09.580]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.580]         }
[17:47:09.580]         base::close(...future.stdout)
[17:47:09.580]         ...future.stdout <- NULL
[17:47:09.580]     }
[17:47:09.580]     ...future.result$conditions <- ...future.conditions
[17:47:09.580]     ...future.result$finished <- base::Sys.time()
[17:47:09.580]     ...future.result
[17:47:09.580] }
[17:47:09.583] MultisessionFuture started
[17:47:09.583] - Launch lazy future ... done
[17:47:09.583] run() for ‘MultisessionFuture’ ... done
[17:47:09.625] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.625] - Validating connection of MultisessionFuture
[17:47:09.626] - received message: FutureResult
[17:47:09.626] - Received FutureResult
[17:47:09.626] - Erased future from FutureRegistry
[17:47:09.626] result() for ClusterFuture ...
[17:47:09.626] - result already collected: FutureResult
[17:47:09.626] result() for ClusterFuture ... done
[17:47:09.626] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.626] Future #1
[17:47:09.627] result() for ClusterFuture ...
[17:47:09.627] - result already collected: FutureResult
[17:47:09.627] result() for ClusterFuture ... done
[17:47:09.627] result() for ClusterFuture ...
[17:47:09.627] - result already collected: FutureResult
[17:47:09.627] result() for ClusterFuture ... done
[17:47:09.627] A MultisessionFuture was resolved
[17:47:09.627]  length: 0 (resolved future 1)
[17:47:09.627] resolve() on list ... DONE
[17:47:09.627] - globals: [1] ‘a’
[17:47:09.628] Resolving futures part of globals (recursively) ... DONE
[17:47:09.628] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[17:47:09.629] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[17:47:09.629] - globals: [1] ‘a’
[17:47:09.629] - packages: [1] ‘future’
[17:47:09.629] getGlobalsAndPackages() ... DONE
[17:47:09.629] run() for ‘Future’ ...
[17:47:09.629] - state: ‘created’
[17:47:09.630] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.643] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.644] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.644]   - Field: ‘node’
[17:47:09.644]   - Field: ‘label’
[17:47:09.644]   - Field: ‘local’
[17:47:09.644]   - Field: ‘owner’
[17:47:09.644]   - Field: ‘envir’
[17:47:09.644]   - Field: ‘workers’
[17:47:09.644]   - Field: ‘packages’
[17:47:09.644]   - Field: ‘gc’
[17:47:09.644]   - Field: ‘conditions’
[17:47:09.644]   - Field: ‘persistent’
[17:47:09.645]   - Field: ‘expr’
[17:47:09.645]   - Field: ‘uuid’
[17:47:09.645]   - Field: ‘seed’
[17:47:09.645]   - Field: ‘version’
[17:47:09.645]   - Field: ‘result’
[17:47:09.645]   - Field: ‘asynchronous’
[17:47:09.645]   - Field: ‘calls’
[17:47:09.645]   - Field: ‘globals’
[17:47:09.645]   - Field: ‘stdout’
[17:47:09.645]   - Field: ‘earlySignal’
[17:47:09.645]   - Field: ‘lazy’
[17:47:09.645]   - Field: ‘state’
[17:47:09.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.646] - Launch lazy future ...
[17:47:09.646] Packages needed by the future expression (n = 1): ‘future’
[17:47:09.646] Packages needed by future strategies (n = 0): <none>
[17:47:09.647] {
[17:47:09.647]     {
[17:47:09.647]         {
[17:47:09.647]             ...future.startTime <- base::Sys.time()
[17:47:09.647]             {
[17:47:09.647]                 {
[17:47:09.647]                   {
[17:47:09.647]                     {
[17:47:09.647]                       {
[17:47:09.647]                         base::local({
[17:47:09.647]                           has_future <- base::requireNamespace("future", 
[17:47:09.647]                             quietly = TRUE)
[17:47:09.647]                           if (has_future) {
[17:47:09.647]                             ns <- base::getNamespace("future")
[17:47:09.647]                             version <- ns[[".package"]][["version"]]
[17:47:09.647]                             if (is.null(version)) 
[17:47:09.647]                               version <- utils::packageVersion("future")
[17:47:09.647]                           }
[17:47:09.647]                           else {
[17:47:09.647]                             version <- NULL
[17:47:09.647]                           }
[17:47:09.647]                           if (!has_future || version < "1.8.0") {
[17:47:09.647]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.647]                               "", base::R.version$version.string), 
[17:47:09.647]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:09.647]                                 base::R.version$platform, 8 * 
[17:47:09.647]                                   base::.Machine$sizeof.pointer), 
[17:47:09.647]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.647]                                 "release", "version")], collapse = " "), 
[17:47:09.647]                               hostname = base::Sys.info()[["nodename"]])
[17:47:09.647]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.647]                               info)
[17:47:09.647]                             info <- base::paste(info, collapse = "; ")
[17:47:09.647]                             if (!has_future) {
[17:47:09.647]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.647]                                 info)
[17:47:09.647]                             }
[17:47:09.647]                             else {
[17:47:09.647]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.647]                                 info, version)
[17:47:09.647]                             }
[17:47:09.647]                             base::stop(msg)
[17:47:09.647]                           }
[17:47:09.647]                         })
[17:47:09.647]                       }
[17:47:09.647]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.647]                       base::options(mc.cores = 1L)
[17:47:09.647]                     }
[17:47:09.647]                     base::local({
[17:47:09.647]                       for (pkg in "future") {
[17:47:09.647]                         base::loadNamespace(pkg)
[17:47:09.647]                         base::library(pkg, character.only = TRUE)
[17:47:09.647]                       }
[17:47:09.647]                     })
[17:47:09.647]                   }
[17:47:09.647]                   ...future.strategy.old <- future::plan("list")
[17:47:09.647]                   options(future.plan = NULL)
[17:47:09.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.647]                 }
[17:47:09.647]                 ...future.workdir <- getwd()
[17:47:09.647]             }
[17:47:09.647]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.647]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.647]         }
[17:47:09.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.647]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.647]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.647]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.647]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.647]             base::names(...future.oldOptions))
[17:47:09.647]     }
[17:47:09.647]     if (FALSE) {
[17:47:09.647]     }
[17:47:09.647]     else {
[17:47:09.647]         if (TRUE) {
[17:47:09.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.647]                 open = "w")
[17:47:09.647]         }
[17:47:09.647]         else {
[17:47:09.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.647]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.647]         }
[17:47:09.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.647]             base::sink(type = "output", split = FALSE)
[17:47:09.647]             base::close(...future.stdout)
[17:47:09.647]         }, add = TRUE)
[17:47:09.647]     }
[17:47:09.647]     ...future.frame <- base::sys.nframe()
[17:47:09.647]     ...future.conditions <- base::list()
[17:47:09.647]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.647]     if (FALSE) {
[17:47:09.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.647]     }
[17:47:09.647]     ...future.result <- base::tryCatch({
[17:47:09.647]         base::withCallingHandlers({
[17:47:09.647]             ...future.value <- base::withVisible(base::local({
[17:47:09.647]                 ...future.makeSendCondition <- base::local({
[17:47:09.647]                   sendCondition <- NULL
[17:47:09.647]                   function(frame = 1L) {
[17:47:09.647]                     if (is.function(sendCondition)) 
[17:47:09.647]                       return(sendCondition)
[17:47:09.647]                     ns <- getNamespace("parallel")
[17:47:09.647]                     if (exists("sendData", mode = "function", 
[17:47:09.647]                       envir = ns)) {
[17:47:09.647]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.647]                         envir = ns)
[17:47:09.647]                       envir <- sys.frame(frame)
[17:47:09.647]                       master <- NULL
[17:47:09.647]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.647]                         !identical(envir, emptyenv())) {
[17:47:09.647]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.647]                           inherits = FALSE)) {
[17:47:09.647]                           master <- get("master", mode = "list", 
[17:47:09.647]                             envir = envir, inherits = FALSE)
[17:47:09.647]                           if (inherits(master, c("SOCKnode", 
[17:47:09.647]                             "SOCK0node"))) {
[17:47:09.647]                             sendCondition <<- function(cond) {
[17:47:09.647]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.647]                                 success = TRUE)
[17:47:09.647]                               parallel_sendData(master, data)
[17:47:09.647]                             }
[17:47:09.647]                             return(sendCondition)
[17:47:09.647]                           }
[17:47:09.647]                         }
[17:47:09.647]                         frame <- frame + 1L
[17:47:09.647]                         envir <- sys.frame(frame)
[17:47:09.647]                       }
[17:47:09.647]                     }
[17:47:09.647]                     sendCondition <<- function(cond) NULL
[17:47:09.647]                   }
[17:47:09.647]                 })
[17:47:09.647]                 withCallingHandlers({
[17:47:09.647]                   value(a) + 1
[17:47:09.647]                 }, immediateCondition = function(cond) {
[17:47:09.647]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.647]                   sendCondition(cond)
[17:47:09.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.647]                   {
[17:47:09.647]                     inherits <- base::inherits
[17:47:09.647]                     invokeRestart <- base::invokeRestart
[17:47:09.647]                     is.null <- base::is.null
[17:47:09.647]                     muffled <- FALSE
[17:47:09.647]                     if (inherits(cond, "message")) {
[17:47:09.647]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.647]                       if (muffled) 
[17:47:09.647]                         invokeRestart("muffleMessage")
[17:47:09.647]                     }
[17:47:09.647]                     else if (inherits(cond, "warning")) {
[17:47:09.647]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.647]                       if (muffled) 
[17:47:09.647]                         invokeRestart("muffleWarning")
[17:47:09.647]                     }
[17:47:09.647]                     else if (inherits(cond, "condition")) {
[17:47:09.647]                       if (!is.null(pattern)) {
[17:47:09.647]                         computeRestarts <- base::computeRestarts
[17:47:09.647]                         grepl <- base::grepl
[17:47:09.647]                         restarts <- computeRestarts(cond)
[17:47:09.647]                         for (restart in restarts) {
[17:47:09.647]                           name <- restart$name
[17:47:09.647]                           if (is.null(name)) 
[17:47:09.647]                             next
[17:47:09.647]                           if (!grepl(pattern, name)) 
[17:47:09.647]                             next
[17:47:09.647]                           invokeRestart(restart)
[17:47:09.647]                           muffled <- TRUE
[17:47:09.647]                           break
[17:47:09.647]                         }
[17:47:09.647]                       }
[17:47:09.647]                     }
[17:47:09.647]                     invisible(muffled)
[17:47:09.647]                   }
[17:47:09.647]                   muffleCondition(cond)
[17:47:09.647]                 })
[17:47:09.647]             }))
[17:47:09.647]             future::FutureResult(value = ...future.value$value, 
[17:47:09.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.647]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.647]                     ...future.globalenv.names))
[17:47:09.647]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.647]         }, condition = base::local({
[17:47:09.647]             c <- base::c
[17:47:09.647]             inherits <- base::inherits
[17:47:09.647]             invokeRestart <- base::invokeRestart
[17:47:09.647]             length <- base::length
[17:47:09.647]             list <- base::list
[17:47:09.647]             seq.int <- base::seq.int
[17:47:09.647]             signalCondition <- base::signalCondition
[17:47:09.647]             sys.calls <- base::sys.calls
[17:47:09.647]             `[[` <- base::`[[`
[17:47:09.647]             `+` <- base::`+`
[17:47:09.647]             `<<-` <- base::`<<-`
[17:47:09.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.647]                   3L)]
[17:47:09.647]             }
[17:47:09.647]             function(cond) {
[17:47:09.647]                 is_error <- inherits(cond, "error")
[17:47:09.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.647]                   NULL)
[17:47:09.647]                 if (is_error) {
[17:47:09.647]                   sessionInformation <- function() {
[17:47:09.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.647]                       search = base::search(), system = base::Sys.info())
[17:47:09.647]                   }
[17:47:09.647]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.647]                     cond$call), session = sessionInformation(), 
[17:47:09.647]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.647]                   signalCondition(cond)
[17:47:09.647]                 }
[17:47:09.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.647]                 "immediateCondition"))) {
[17:47:09.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.647]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.647]                   if (TRUE && !signal) {
[17:47:09.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.647]                     {
[17:47:09.647]                       inherits <- base::inherits
[17:47:09.647]                       invokeRestart <- base::invokeRestart
[17:47:09.647]                       is.null <- base::is.null
[17:47:09.647]                       muffled <- FALSE
[17:47:09.647]                       if (inherits(cond, "message")) {
[17:47:09.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.647]                         if (muffled) 
[17:47:09.647]                           invokeRestart("muffleMessage")
[17:47:09.647]                       }
[17:47:09.647]                       else if (inherits(cond, "warning")) {
[17:47:09.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.647]                         if (muffled) 
[17:47:09.647]                           invokeRestart("muffleWarning")
[17:47:09.647]                       }
[17:47:09.647]                       else if (inherits(cond, "condition")) {
[17:47:09.647]                         if (!is.null(pattern)) {
[17:47:09.647]                           computeRestarts <- base::computeRestarts
[17:47:09.647]                           grepl <- base::grepl
[17:47:09.647]                           restarts <- computeRestarts(cond)
[17:47:09.647]                           for (restart in restarts) {
[17:47:09.647]                             name <- restart$name
[17:47:09.647]                             if (is.null(name)) 
[17:47:09.647]                               next
[17:47:09.647]                             if (!grepl(pattern, name)) 
[17:47:09.647]                               next
[17:47:09.647]                             invokeRestart(restart)
[17:47:09.647]                             muffled <- TRUE
[17:47:09.647]                             break
[17:47:09.647]                           }
[17:47:09.647]                         }
[17:47:09.647]                       }
[17:47:09.647]                       invisible(muffled)
[17:47:09.647]                     }
[17:47:09.647]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.647]                   }
[17:47:09.647]                 }
[17:47:09.647]                 else {
[17:47:09.647]                   if (TRUE) {
[17:47:09.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.647]                     {
[17:47:09.647]                       inherits <- base::inherits
[17:47:09.647]                       invokeRestart <- base::invokeRestart
[17:47:09.647]                       is.null <- base::is.null
[17:47:09.647]                       muffled <- FALSE
[17:47:09.647]                       if (inherits(cond, "message")) {
[17:47:09.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.647]                         if (muffled) 
[17:47:09.647]                           invokeRestart("muffleMessage")
[17:47:09.647]                       }
[17:47:09.647]                       else if (inherits(cond, "warning")) {
[17:47:09.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.647]                         if (muffled) 
[17:47:09.647]                           invokeRestart("muffleWarning")
[17:47:09.647]                       }
[17:47:09.647]                       else if (inherits(cond, "condition")) {
[17:47:09.647]                         if (!is.null(pattern)) {
[17:47:09.647]                           computeRestarts <- base::computeRestarts
[17:47:09.647]                           grepl <- base::grepl
[17:47:09.647]                           restarts <- computeRestarts(cond)
[17:47:09.647]                           for (restart in restarts) {
[17:47:09.647]                             name <- restart$name
[17:47:09.647]                             if (is.null(name)) 
[17:47:09.647]                               next
[17:47:09.647]                             if (!grepl(pattern, name)) 
[17:47:09.647]                               next
[17:47:09.647]                             invokeRestart(restart)
[17:47:09.647]                             muffled <- TRUE
[17:47:09.647]                             break
[17:47:09.647]                           }
[17:47:09.647]                         }
[17:47:09.647]                       }
[17:47:09.647]                       invisible(muffled)
[17:47:09.647]                     }
[17:47:09.647]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.647]                   }
[17:47:09.647]                 }
[17:47:09.647]             }
[17:47:09.647]         }))
[17:47:09.647]     }, error = function(ex) {
[17:47:09.647]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.647]                 ...future.rng), started = ...future.startTime, 
[17:47:09.647]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.647]             version = "1.8"), class = "FutureResult")
[17:47:09.647]     }, finally = {
[17:47:09.647]         if (!identical(...future.workdir, getwd())) 
[17:47:09.647]             setwd(...future.workdir)
[17:47:09.647]         {
[17:47:09.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.647]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.647]             }
[17:47:09.647]             base::options(...future.oldOptions)
[17:47:09.647]             if (.Platform$OS.type == "windows") {
[17:47:09.647]                 old_names <- names(...future.oldEnvVars)
[17:47:09.647]                 envs <- base::Sys.getenv()
[17:47:09.647]                 names <- names(envs)
[17:47:09.647]                 common <- intersect(names, old_names)
[17:47:09.647]                 added <- setdiff(names, old_names)
[17:47:09.647]                 removed <- setdiff(old_names, names)
[17:47:09.647]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.647]                   envs[common]]
[17:47:09.647]                 NAMES <- toupper(changed)
[17:47:09.647]                 args <- list()
[17:47:09.647]                 for (kk in seq_along(NAMES)) {
[17:47:09.647]                   name <- changed[[kk]]
[17:47:09.647]                   NAME <- NAMES[[kk]]
[17:47:09.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.647]                     next
[17:47:09.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.647]                 }
[17:47:09.647]                 NAMES <- toupper(added)
[17:47:09.647]                 for (kk in seq_along(NAMES)) {
[17:47:09.647]                   name <- added[[kk]]
[17:47:09.647]                   NAME <- NAMES[[kk]]
[17:47:09.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.647]                     next
[17:47:09.647]                   args[[name]] <- ""
[17:47:09.647]                 }
[17:47:09.647]                 NAMES <- toupper(removed)
[17:47:09.647]                 for (kk in seq_along(NAMES)) {
[17:47:09.647]                   name <- removed[[kk]]
[17:47:09.647]                   NAME <- NAMES[[kk]]
[17:47:09.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.647]                     next
[17:47:09.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.647]                 }
[17:47:09.647]                 if (length(args) > 0) 
[17:47:09.647]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.647]             }
[17:47:09.647]             else {
[17:47:09.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.647]             }
[17:47:09.647]             {
[17:47:09.647]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.647]                   0L) {
[17:47:09.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.647]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.647]                   base::options(opts)
[17:47:09.647]                 }
[17:47:09.647]                 {
[17:47:09.647]                   {
[17:47:09.647]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.647]                     NULL
[17:47:09.647]                   }
[17:47:09.647]                   options(future.plan = NULL)
[17:47:09.647]                   if (is.na(NA_character_)) 
[17:47:09.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.647]                     .init = FALSE)
[17:47:09.647]                 }
[17:47:09.647]             }
[17:47:09.647]         }
[17:47:09.647]     })
[17:47:09.647]     if (TRUE) {
[17:47:09.647]         base::sink(type = "output", split = FALSE)
[17:47:09.647]         if (TRUE) {
[17:47:09.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.647]         }
[17:47:09.647]         else {
[17:47:09.647]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.647]         }
[17:47:09.647]         base::close(...future.stdout)
[17:47:09.647]         ...future.stdout <- NULL
[17:47:09.647]     }
[17:47:09.647]     ...future.result$conditions <- ...future.conditions
[17:47:09.647]     ...future.result$finished <- base::Sys.time()
[17:47:09.647]     ...future.result
[17:47:09.647] }
[17:47:09.649] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[17:47:09.650] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[17:47:09.700] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[17:47:09.700] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[17:47:09.700] MultisessionFuture started
[17:47:09.701] - Launch lazy future ... done
[17:47:09.701] run() for ‘MultisessionFuture’ ... done
[17:47:09.701] result() for ClusterFuture ...
[17:47:09.701] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.701] - Validating connection of MultisessionFuture
[17:47:09.745] - received message: FutureResult
[17:47:09.746] - Received FutureResult
[17:47:09.746] - Erased future from FutureRegistry
[17:47:09.746] result() for ClusterFuture ...
[17:47:09.746] - result already collected: FutureResult
[17:47:09.746] result() for ClusterFuture ... done
[17:47:09.746] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.746] result() for ClusterFuture ... done
[17:47:09.746] result() for ClusterFuture ...
[17:47:09.746] - result already collected: FutureResult
[17:47:09.746] result() for ClusterFuture ... done
value(b) = 2
[17:47:09.747] result() for ClusterFuture ...
[17:47:09.747] - result already collected: FutureResult
[17:47:09.747] result() for ClusterFuture ... done
[17:47:09.747] result() for ClusterFuture ...
[17:47:09.747] - result already collected: FutureResult
[17:47:09.747] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.747] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.747] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.748] 
[17:47:09.748] Searching for globals ... DONE
[17:47:09.748] - globals: [0] <none>
[17:47:09.748] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.749] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.749] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.750] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:09.750] Searching for globals ... DONE
[17:47:09.750] Resolving globals: TRUE
[17:47:09.750] Resolving any globals that are futures ...
[17:47:09.750] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:09.750] Resolving any globals that are futures ... DONE
[17:47:09.751] Resolving futures part of globals (recursively) ...
[17:47:09.751] resolve() on list ...
[17:47:09.751]  recursive: 99
[17:47:09.751]  length: 1
[17:47:09.751]  elements: ‘a’
[17:47:09.751] run() for ‘Future’ ...
[17:47:09.751] - state: ‘created’
[17:47:09.752] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.766] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.766]   - Field: ‘node’
[17:47:09.766]   - Field: ‘label’
[17:47:09.766]   - Field: ‘local’
[17:47:09.767]   - Field: ‘owner’
[17:47:09.767]   - Field: ‘envir’
[17:47:09.767]   - Field: ‘workers’
[17:47:09.767]   - Field: ‘packages’
[17:47:09.767]   - Field: ‘gc’
[17:47:09.767]   - Field: ‘conditions’
[17:47:09.767]   - Field: ‘persistent’
[17:47:09.767]   - Field: ‘expr’
[17:47:09.768]   - Field: ‘uuid’
[17:47:09.768]   - Field: ‘seed’
[17:47:09.768]   - Field: ‘version’
[17:47:09.768]   - Field: ‘result’
[17:47:09.770]   - Field: ‘asynchronous’
[17:47:09.770]   - Field: ‘calls’
[17:47:09.770]   - Field: ‘globals’
[17:47:09.770]   - Field: ‘stdout’
[17:47:09.770]   - Field: ‘earlySignal’
[17:47:09.770]   - Field: ‘lazy’
[17:47:09.770]   - Field: ‘state’
[17:47:09.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.771] - Launch lazy future ...
[17:47:09.771] Packages needed by the future expression (n = 0): <none>
[17:47:09.771] Packages needed by future strategies (n = 0): <none>
[17:47:09.771] {
[17:47:09.771]     {
[17:47:09.771]         {
[17:47:09.771]             ...future.startTime <- base::Sys.time()
[17:47:09.771]             {
[17:47:09.771]                 {
[17:47:09.771]                   {
[17:47:09.771]                     {
[17:47:09.771]                       base::local({
[17:47:09.771]                         has_future <- base::requireNamespace("future", 
[17:47:09.771]                           quietly = TRUE)
[17:47:09.771]                         if (has_future) {
[17:47:09.771]                           ns <- base::getNamespace("future")
[17:47:09.771]                           version <- ns[[".package"]][["version"]]
[17:47:09.771]                           if (is.null(version)) 
[17:47:09.771]                             version <- utils::packageVersion("future")
[17:47:09.771]                         }
[17:47:09.771]                         else {
[17:47:09.771]                           version <- NULL
[17:47:09.771]                         }
[17:47:09.771]                         if (!has_future || version < "1.8.0") {
[17:47:09.771]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.771]                             "", base::R.version$version.string), 
[17:47:09.771]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:09.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.771]                               "release", "version")], collapse = " "), 
[17:47:09.771]                             hostname = base::Sys.info()[["nodename"]])
[17:47:09.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.771]                             info)
[17:47:09.771]                           info <- base::paste(info, collapse = "; ")
[17:47:09.771]                           if (!has_future) {
[17:47:09.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.771]                               info)
[17:47:09.771]                           }
[17:47:09.771]                           else {
[17:47:09.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.771]                               info, version)
[17:47:09.771]                           }
[17:47:09.771]                           base::stop(msg)
[17:47:09.771]                         }
[17:47:09.771]                       })
[17:47:09.771]                     }
[17:47:09.771]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.771]                     base::options(mc.cores = 1L)
[17:47:09.771]                   }
[17:47:09.771]                   ...future.strategy.old <- future::plan("list")
[17:47:09.771]                   options(future.plan = NULL)
[17:47:09.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.771]                 }
[17:47:09.771]                 ...future.workdir <- getwd()
[17:47:09.771]             }
[17:47:09.771]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.771]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.771]         }
[17:47:09.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.771]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.771]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.771]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.771]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.771]             base::names(...future.oldOptions))
[17:47:09.771]     }
[17:47:09.771]     if (FALSE) {
[17:47:09.771]     }
[17:47:09.771]     else {
[17:47:09.771]         if (TRUE) {
[17:47:09.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.771]                 open = "w")
[17:47:09.771]         }
[17:47:09.771]         else {
[17:47:09.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.771]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.771]         }
[17:47:09.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.771]             base::sink(type = "output", split = FALSE)
[17:47:09.771]             base::close(...future.stdout)
[17:47:09.771]         }, add = TRUE)
[17:47:09.771]     }
[17:47:09.771]     ...future.frame <- base::sys.nframe()
[17:47:09.771]     ...future.conditions <- base::list()
[17:47:09.771]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.771]     if (FALSE) {
[17:47:09.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.771]     }
[17:47:09.771]     ...future.result <- base::tryCatch({
[17:47:09.771]         base::withCallingHandlers({
[17:47:09.771]             ...future.value <- base::withVisible(base::local({
[17:47:09.771]                 ...future.makeSendCondition <- base::local({
[17:47:09.771]                   sendCondition <- NULL
[17:47:09.771]                   function(frame = 1L) {
[17:47:09.771]                     if (is.function(sendCondition)) 
[17:47:09.771]                       return(sendCondition)
[17:47:09.771]                     ns <- getNamespace("parallel")
[17:47:09.771]                     if (exists("sendData", mode = "function", 
[17:47:09.771]                       envir = ns)) {
[17:47:09.771]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.771]                         envir = ns)
[17:47:09.771]                       envir <- sys.frame(frame)
[17:47:09.771]                       master <- NULL
[17:47:09.771]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.771]                         !identical(envir, emptyenv())) {
[17:47:09.771]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.771]                           inherits = FALSE)) {
[17:47:09.771]                           master <- get("master", mode = "list", 
[17:47:09.771]                             envir = envir, inherits = FALSE)
[17:47:09.771]                           if (inherits(master, c("SOCKnode", 
[17:47:09.771]                             "SOCK0node"))) {
[17:47:09.771]                             sendCondition <<- function(cond) {
[17:47:09.771]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.771]                                 success = TRUE)
[17:47:09.771]                               parallel_sendData(master, data)
[17:47:09.771]                             }
[17:47:09.771]                             return(sendCondition)
[17:47:09.771]                           }
[17:47:09.771]                         }
[17:47:09.771]                         frame <- frame + 1L
[17:47:09.771]                         envir <- sys.frame(frame)
[17:47:09.771]                       }
[17:47:09.771]                     }
[17:47:09.771]                     sendCondition <<- function(cond) NULL
[17:47:09.771]                   }
[17:47:09.771]                 })
[17:47:09.771]                 withCallingHandlers({
[17:47:09.771]                   1
[17:47:09.771]                 }, immediateCondition = function(cond) {
[17:47:09.771]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.771]                   sendCondition(cond)
[17:47:09.771]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.771]                   {
[17:47:09.771]                     inherits <- base::inherits
[17:47:09.771]                     invokeRestart <- base::invokeRestart
[17:47:09.771]                     is.null <- base::is.null
[17:47:09.771]                     muffled <- FALSE
[17:47:09.771]                     if (inherits(cond, "message")) {
[17:47:09.771]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.771]                       if (muffled) 
[17:47:09.771]                         invokeRestart("muffleMessage")
[17:47:09.771]                     }
[17:47:09.771]                     else if (inherits(cond, "warning")) {
[17:47:09.771]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.771]                       if (muffled) 
[17:47:09.771]                         invokeRestart("muffleWarning")
[17:47:09.771]                     }
[17:47:09.771]                     else if (inherits(cond, "condition")) {
[17:47:09.771]                       if (!is.null(pattern)) {
[17:47:09.771]                         computeRestarts <- base::computeRestarts
[17:47:09.771]                         grepl <- base::grepl
[17:47:09.771]                         restarts <- computeRestarts(cond)
[17:47:09.771]                         for (restart in restarts) {
[17:47:09.771]                           name <- restart$name
[17:47:09.771]                           if (is.null(name)) 
[17:47:09.771]                             next
[17:47:09.771]                           if (!grepl(pattern, name)) 
[17:47:09.771]                             next
[17:47:09.771]                           invokeRestart(restart)
[17:47:09.771]                           muffled <- TRUE
[17:47:09.771]                           break
[17:47:09.771]                         }
[17:47:09.771]                       }
[17:47:09.771]                     }
[17:47:09.771]                     invisible(muffled)
[17:47:09.771]                   }
[17:47:09.771]                   muffleCondition(cond)
[17:47:09.771]                 })
[17:47:09.771]             }))
[17:47:09.771]             future::FutureResult(value = ...future.value$value, 
[17:47:09.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.771]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.771]                     ...future.globalenv.names))
[17:47:09.771]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.771]         }, condition = base::local({
[17:47:09.771]             c <- base::c
[17:47:09.771]             inherits <- base::inherits
[17:47:09.771]             invokeRestart <- base::invokeRestart
[17:47:09.771]             length <- base::length
[17:47:09.771]             list <- base::list
[17:47:09.771]             seq.int <- base::seq.int
[17:47:09.771]             signalCondition <- base::signalCondition
[17:47:09.771]             sys.calls <- base::sys.calls
[17:47:09.771]             `[[` <- base::`[[`
[17:47:09.771]             `+` <- base::`+`
[17:47:09.771]             `<<-` <- base::`<<-`
[17:47:09.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.771]                   3L)]
[17:47:09.771]             }
[17:47:09.771]             function(cond) {
[17:47:09.771]                 is_error <- inherits(cond, "error")
[17:47:09.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.771]                   NULL)
[17:47:09.771]                 if (is_error) {
[17:47:09.771]                   sessionInformation <- function() {
[17:47:09.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.771]                       search = base::search(), system = base::Sys.info())
[17:47:09.771]                   }
[17:47:09.771]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.771]                     cond$call), session = sessionInformation(), 
[17:47:09.771]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.771]                   signalCondition(cond)
[17:47:09.771]                 }
[17:47:09.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.771]                 "immediateCondition"))) {
[17:47:09.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.771]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.771]                   if (TRUE && !signal) {
[17:47:09.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.771]                     {
[17:47:09.771]                       inherits <- base::inherits
[17:47:09.771]                       invokeRestart <- base::invokeRestart
[17:47:09.771]                       is.null <- base::is.null
[17:47:09.771]                       muffled <- FALSE
[17:47:09.771]                       if (inherits(cond, "message")) {
[17:47:09.771]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.771]                         if (muffled) 
[17:47:09.771]                           invokeRestart("muffleMessage")
[17:47:09.771]                       }
[17:47:09.771]                       else if (inherits(cond, "warning")) {
[17:47:09.771]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.771]                         if (muffled) 
[17:47:09.771]                           invokeRestart("muffleWarning")
[17:47:09.771]                       }
[17:47:09.771]                       else if (inherits(cond, "condition")) {
[17:47:09.771]                         if (!is.null(pattern)) {
[17:47:09.771]                           computeRestarts <- base::computeRestarts
[17:47:09.771]                           grepl <- base::grepl
[17:47:09.771]                           restarts <- computeRestarts(cond)
[17:47:09.771]                           for (restart in restarts) {
[17:47:09.771]                             name <- restart$name
[17:47:09.771]                             if (is.null(name)) 
[17:47:09.771]                               next
[17:47:09.771]                             if (!grepl(pattern, name)) 
[17:47:09.771]                               next
[17:47:09.771]                             invokeRestart(restart)
[17:47:09.771]                             muffled <- TRUE
[17:47:09.771]                             break
[17:47:09.771]                           }
[17:47:09.771]                         }
[17:47:09.771]                       }
[17:47:09.771]                       invisible(muffled)
[17:47:09.771]                     }
[17:47:09.771]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.771]                   }
[17:47:09.771]                 }
[17:47:09.771]                 else {
[17:47:09.771]                   if (TRUE) {
[17:47:09.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.771]                     {
[17:47:09.771]                       inherits <- base::inherits
[17:47:09.771]                       invokeRestart <- base::invokeRestart
[17:47:09.771]                       is.null <- base::is.null
[17:47:09.771]                       muffled <- FALSE
[17:47:09.771]                       if (inherits(cond, "message")) {
[17:47:09.771]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.771]                         if (muffled) 
[17:47:09.771]                           invokeRestart("muffleMessage")
[17:47:09.771]                       }
[17:47:09.771]                       else if (inherits(cond, "warning")) {
[17:47:09.771]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.771]                         if (muffled) 
[17:47:09.771]                           invokeRestart("muffleWarning")
[17:47:09.771]                       }
[17:47:09.771]                       else if (inherits(cond, "condition")) {
[17:47:09.771]                         if (!is.null(pattern)) {
[17:47:09.771]                           computeRestarts <- base::computeRestarts
[17:47:09.771]                           grepl <- base::grepl
[17:47:09.771]                           restarts <- computeRestarts(cond)
[17:47:09.771]                           for (restart in restarts) {
[17:47:09.771]                             name <- restart$name
[17:47:09.771]                             if (is.null(name)) 
[17:47:09.771]                               next
[17:47:09.771]                             if (!grepl(pattern, name)) 
[17:47:09.771]                               next
[17:47:09.771]                             invokeRestart(restart)
[17:47:09.771]                             muffled <- TRUE
[17:47:09.771]                             break
[17:47:09.771]                           }
[17:47:09.771]                         }
[17:47:09.771]                       }
[17:47:09.771]                       invisible(muffled)
[17:47:09.771]                     }
[17:47:09.771]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.771]                   }
[17:47:09.771]                 }
[17:47:09.771]             }
[17:47:09.771]         }))
[17:47:09.771]     }, error = function(ex) {
[17:47:09.771]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.771]                 ...future.rng), started = ...future.startTime, 
[17:47:09.771]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.771]             version = "1.8"), class = "FutureResult")
[17:47:09.771]     }, finally = {
[17:47:09.771]         if (!identical(...future.workdir, getwd())) 
[17:47:09.771]             setwd(...future.workdir)
[17:47:09.771]         {
[17:47:09.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.771]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.771]             }
[17:47:09.771]             base::options(...future.oldOptions)
[17:47:09.771]             if (.Platform$OS.type == "windows") {
[17:47:09.771]                 old_names <- names(...future.oldEnvVars)
[17:47:09.771]                 envs <- base::Sys.getenv()
[17:47:09.771]                 names <- names(envs)
[17:47:09.771]                 common <- intersect(names, old_names)
[17:47:09.771]                 added <- setdiff(names, old_names)
[17:47:09.771]                 removed <- setdiff(old_names, names)
[17:47:09.771]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.771]                   envs[common]]
[17:47:09.771]                 NAMES <- toupper(changed)
[17:47:09.771]                 args <- list()
[17:47:09.771]                 for (kk in seq_along(NAMES)) {
[17:47:09.771]                   name <- changed[[kk]]
[17:47:09.771]                   NAME <- NAMES[[kk]]
[17:47:09.771]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.771]                     next
[17:47:09.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.771]                 }
[17:47:09.771]                 NAMES <- toupper(added)
[17:47:09.771]                 for (kk in seq_along(NAMES)) {
[17:47:09.771]                   name <- added[[kk]]
[17:47:09.771]                   NAME <- NAMES[[kk]]
[17:47:09.771]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.771]                     next
[17:47:09.771]                   args[[name]] <- ""
[17:47:09.771]                 }
[17:47:09.771]                 NAMES <- toupper(removed)
[17:47:09.771]                 for (kk in seq_along(NAMES)) {
[17:47:09.771]                   name <- removed[[kk]]
[17:47:09.771]                   NAME <- NAMES[[kk]]
[17:47:09.771]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.771]                     next
[17:47:09.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.771]                 }
[17:47:09.771]                 if (length(args) > 0) 
[17:47:09.771]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.771]             }
[17:47:09.771]             else {
[17:47:09.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.771]             }
[17:47:09.771]             {
[17:47:09.771]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.771]                   0L) {
[17:47:09.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.771]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.771]                   base::options(opts)
[17:47:09.771]                 }
[17:47:09.771]                 {
[17:47:09.771]                   {
[17:47:09.771]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.771]                     NULL
[17:47:09.771]                   }
[17:47:09.771]                   options(future.plan = NULL)
[17:47:09.771]                   if (is.na(NA_character_)) 
[17:47:09.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.771]                     .init = FALSE)
[17:47:09.771]                 }
[17:47:09.771]             }
[17:47:09.771]         }
[17:47:09.771]     })
[17:47:09.771]     if (TRUE) {
[17:47:09.771]         base::sink(type = "output", split = FALSE)
[17:47:09.771]         if (TRUE) {
[17:47:09.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.771]         }
[17:47:09.771]         else {
[17:47:09.771]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.771]         }
[17:47:09.771]         base::close(...future.stdout)
[17:47:09.771]         ...future.stdout <- NULL
[17:47:09.771]     }
[17:47:09.771]     ...future.result$conditions <- ...future.conditions
[17:47:09.771]     ...future.result$finished <- base::Sys.time()
[17:47:09.771]     ...future.result
[17:47:09.771] }
[17:47:09.774] MultisessionFuture started
[17:47:09.774] - Launch lazy future ... done
[17:47:09.775] run() for ‘MultisessionFuture’ ... done
[17:47:09.818] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.818] - Validating connection of MultisessionFuture
[17:47:09.819] - received message: FutureResult
[17:47:09.819] - Received FutureResult
[17:47:09.819] - Erased future from FutureRegistry
[17:47:09.819] result() for ClusterFuture ...
[17:47:09.819] - result already collected: FutureResult
[17:47:09.819] result() for ClusterFuture ... done
[17:47:09.820] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.820] Future #1
[17:47:09.820] result() for ClusterFuture ...
[17:47:09.820] - result already collected: FutureResult
[17:47:09.820] result() for ClusterFuture ... done
[17:47:09.820] result() for ClusterFuture ...
[17:47:09.820] - result already collected: FutureResult
[17:47:09.821] result() for ClusterFuture ... done
[17:47:09.821] A MultisessionFuture was resolved
[17:47:09.821]  length: 0 (resolved future 1)
[17:47:09.821] resolve() on list ... DONE
[17:47:09.821] - globals: [1] ‘a’
[17:47:09.821] Resolving futures part of globals (recursively) ... DONE
[17:47:09.822] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[17:47:09.823] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[17:47:09.823] - globals: [1] ‘a’
[17:47:09.823] - packages: [1] ‘future’
[17:47:09.823] getGlobalsAndPackages() ... DONE
[17:47:09.823] run() for ‘Future’ ...
[17:47:09.824] - state: ‘created’
[17:47:09.824] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.837] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.838]   - Field: ‘node’
[17:47:09.838]   - Field: ‘label’
[17:47:09.838]   - Field: ‘local’
[17:47:09.838]   - Field: ‘owner’
[17:47:09.838]   - Field: ‘envir’
[17:47:09.838]   - Field: ‘workers’
[17:47:09.838]   - Field: ‘packages’
[17:47:09.838]   - Field: ‘gc’
[17:47:09.838]   - Field: ‘conditions’
[17:47:09.839]   - Field: ‘persistent’
[17:47:09.839]   - Field: ‘expr’
[17:47:09.839]   - Field: ‘uuid’
[17:47:09.839]   - Field: ‘seed’
[17:47:09.839]   - Field: ‘version’
[17:47:09.839]   - Field: ‘result’
[17:47:09.839]   - Field: ‘asynchronous’
[17:47:09.839]   - Field: ‘calls’
[17:47:09.839]   - Field: ‘globals’
[17:47:09.840]   - Field: ‘stdout’
[17:47:09.840]   - Field: ‘earlySignal’
[17:47:09.840]   - Field: ‘lazy’
[17:47:09.840]   - Field: ‘state’
[17:47:09.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.840] - Launch lazy future ...
[17:47:09.840] Packages needed by the future expression (n = 1): ‘future’
[17:47:09.840] Packages needed by future strategies (n = 0): <none>
[17:47:09.841] {
[17:47:09.841]     {
[17:47:09.841]         {
[17:47:09.841]             ...future.startTime <- base::Sys.time()
[17:47:09.841]             {
[17:47:09.841]                 {
[17:47:09.841]                   {
[17:47:09.841]                     {
[17:47:09.841]                       {
[17:47:09.841]                         base::local({
[17:47:09.841]                           has_future <- base::requireNamespace("future", 
[17:47:09.841]                             quietly = TRUE)
[17:47:09.841]                           if (has_future) {
[17:47:09.841]                             ns <- base::getNamespace("future")
[17:47:09.841]                             version <- ns[[".package"]][["version"]]
[17:47:09.841]                             if (is.null(version)) 
[17:47:09.841]                               version <- utils::packageVersion("future")
[17:47:09.841]                           }
[17:47:09.841]                           else {
[17:47:09.841]                             version <- NULL
[17:47:09.841]                           }
[17:47:09.841]                           if (!has_future || version < "1.8.0") {
[17:47:09.841]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.841]                               "", base::R.version$version.string), 
[17:47:09.841]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:09.841]                                 base::R.version$platform, 8 * 
[17:47:09.841]                                   base::.Machine$sizeof.pointer), 
[17:47:09.841]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.841]                                 "release", "version")], collapse = " "), 
[17:47:09.841]                               hostname = base::Sys.info()[["nodename"]])
[17:47:09.841]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.841]                               info)
[17:47:09.841]                             info <- base::paste(info, collapse = "; ")
[17:47:09.841]                             if (!has_future) {
[17:47:09.841]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.841]                                 info)
[17:47:09.841]                             }
[17:47:09.841]                             else {
[17:47:09.841]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.841]                                 info, version)
[17:47:09.841]                             }
[17:47:09.841]                             base::stop(msg)
[17:47:09.841]                           }
[17:47:09.841]                         })
[17:47:09.841]                       }
[17:47:09.841]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.841]                       base::options(mc.cores = 1L)
[17:47:09.841]                     }
[17:47:09.841]                     base::local({
[17:47:09.841]                       for (pkg in "future") {
[17:47:09.841]                         base::loadNamespace(pkg)
[17:47:09.841]                         base::library(pkg, character.only = TRUE)
[17:47:09.841]                       }
[17:47:09.841]                     })
[17:47:09.841]                   }
[17:47:09.841]                   ...future.strategy.old <- future::plan("list")
[17:47:09.841]                   options(future.plan = NULL)
[17:47:09.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.841]                 }
[17:47:09.841]                 ...future.workdir <- getwd()
[17:47:09.841]             }
[17:47:09.841]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.841]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.841]         }
[17:47:09.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.841]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.841]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.841]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.841]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.841]             base::names(...future.oldOptions))
[17:47:09.841]     }
[17:47:09.841]     if (FALSE) {
[17:47:09.841]     }
[17:47:09.841]     else {
[17:47:09.841]         if (TRUE) {
[17:47:09.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.841]                 open = "w")
[17:47:09.841]         }
[17:47:09.841]         else {
[17:47:09.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.841]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.841]         }
[17:47:09.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.841]             base::sink(type = "output", split = FALSE)
[17:47:09.841]             base::close(...future.stdout)
[17:47:09.841]         }, add = TRUE)
[17:47:09.841]     }
[17:47:09.841]     ...future.frame <- base::sys.nframe()
[17:47:09.841]     ...future.conditions <- base::list()
[17:47:09.841]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.841]     if (FALSE) {
[17:47:09.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.841]     }
[17:47:09.841]     ...future.result <- base::tryCatch({
[17:47:09.841]         base::withCallingHandlers({
[17:47:09.841]             ...future.value <- base::withVisible(base::local({
[17:47:09.841]                 ...future.makeSendCondition <- base::local({
[17:47:09.841]                   sendCondition <- NULL
[17:47:09.841]                   function(frame = 1L) {
[17:47:09.841]                     if (is.function(sendCondition)) 
[17:47:09.841]                       return(sendCondition)
[17:47:09.841]                     ns <- getNamespace("parallel")
[17:47:09.841]                     if (exists("sendData", mode = "function", 
[17:47:09.841]                       envir = ns)) {
[17:47:09.841]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.841]                         envir = ns)
[17:47:09.841]                       envir <- sys.frame(frame)
[17:47:09.841]                       master <- NULL
[17:47:09.841]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.841]                         !identical(envir, emptyenv())) {
[17:47:09.841]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.841]                           inherits = FALSE)) {
[17:47:09.841]                           master <- get("master", mode = "list", 
[17:47:09.841]                             envir = envir, inherits = FALSE)
[17:47:09.841]                           if (inherits(master, c("SOCKnode", 
[17:47:09.841]                             "SOCK0node"))) {
[17:47:09.841]                             sendCondition <<- function(cond) {
[17:47:09.841]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.841]                                 success = TRUE)
[17:47:09.841]                               parallel_sendData(master, data)
[17:47:09.841]                             }
[17:47:09.841]                             return(sendCondition)
[17:47:09.841]                           }
[17:47:09.841]                         }
[17:47:09.841]                         frame <- frame + 1L
[17:47:09.841]                         envir <- sys.frame(frame)
[17:47:09.841]                       }
[17:47:09.841]                     }
[17:47:09.841]                     sendCondition <<- function(cond) NULL
[17:47:09.841]                   }
[17:47:09.841]                 })
[17:47:09.841]                 withCallingHandlers({
[17:47:09.841]                   value(a) + 1
[17:47:09.841]                 }, immediateCondition = function(cond) {
[17:47:09.841]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.841]                   sendCondition(cond)
[17:47:09.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.841]                   {
[17:47:09.841]                     inherits <- base::inherits
[17:47:09.841]                     invokeRestart <- base::invokeRestart
[17:47:09.841]                     is.null <- base::is.null
[17:47:09.841]                     muffled <- FALSE
[17:47:09.841]                     if (inherits(cond, "message")) {
[17:47:09.841]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.841]                       if (muffled) 
[17:47:09.841]                         invokeRestart("muffleMessage")
[17:47:09.841]                     }
[17:47:09.841]                     else if (inherits(cond, "warning")) {
[17:47:09.841]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.841]                       if (muffled) 
[17:47:09.841]                         invokeRestart("muffleWarning")
[17:47:09.841]                     }
[17:47:09.841]                     else if (inherits(cond, "condition")) {
[17:47:09.841]                       if (!is.null(pattern)) {
[17:47:09.841]                         computeRestarts <- base::computeRestarts
[17:47:09.841]                         grepl <- base::grepl
[17:47:09.841]                         restarts <- computeRestarts(cond)
[17:47:09.841]                         for (restart in restarts) {
[17:47:09.841]                           name <- restart$name
[17:47:09.841]                           if (is.null(name)) 
[17:47:09.841]                             next
[17:47:09.841]                           if (!grepl(pattern, name)) 
[17:47:09.841]                             next
[17:47:09.841]                           invokeRestart(restart)
[17:47:09.841]                           muffled <- TRUE
[17:47:09.841]                           break
[17:47:09.841]                         }
[17:47:09.841]                       }
[17:47:09.841]                     }
[17:47:09.841]                     invisible(muffled)
[17:47:09.841]                   }
[17:47:09.841]                   muffleCondition(cond)
[17:47:09.841]                 })
[17:47:09.841]             }))
[17:47:09.841]             future::FutureResult(value = ...future.value$value, 
[17:47:09.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.841]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.841]                     ...future.globalenv.names))
[17:47:09.841]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.841]         }, condition = base::local({
[17:47:09.841]             c <- base::c
[17:47:09.841]             inherits <- base::inherits
[17:47:09.841]             invokeRestart <- base::invokeRestart
[17:47:09.841]             length <- base::length
[17:47:09.841]             list <- base::list
[17:47:09.841]             seq.int <- base::seq.int
[17:47:09.841]             signalCondition <- base::signalCondition
[17:47:09.841]             sys.calls <- base::sys.calls
[17:47:09.841]             `[[` <- base::`[[`
[17:47:09.841]             `+` <- base::`+`
[17:47:09.841]             `<<-` <- base::`<<-`
[17:47:09.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.841]                   3L)]
[17:47:09.841]             }
[17:47:09.841]             function(cond) {
[17:47:09.841]                 is_error <- inherits(cond, "error")
[17:47:09.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.841]                   NULL)
[17:47:09.841]                 if (is_error) {
[17:47:09.841]                   sessionInformation <- function() {
[17:47:09.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.841]                       search = base::search(), system = base::Sys.info())
[17:47:09.841]                   }
[17:47:09.841]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.841]                     cond$call), session = sessionInformation(), 
[17:47:09.841]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.841]                   signalCondition(cond)
[17:47:09.841]                 }
[17:47:09.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.841]                 "immediateCondition"))) {
[17:47:09.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.841]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.841]                   if (TRUE && !signal) {
[17:47:09.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.841]                     {
[17:47:09.841]                       inherits <- base::inherits
[17:47:09.841]                       invokeRestart <- base::invokeRestart
[17:47:09.841]                       is.null <- base::is.null
[17:47:09.841]                       muffled <- FALSE
[17:47:09.841]                       if (inherits(cond, "message")) {
[17:47:09.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.841]                         if (muffled) 
[17:47:09.841]                           invokeRestart("muffleMessage")
[17:47:09.841]                       }
[17:47:09.841]                       else if (inherits(cond, "warning")) {
[17:47:09.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.841]                         if (muffled) 
[17:47:09.841]                           invokeRestart("muffleWarning")
[17:47:09.841]                       }
[17:47:09.841]                       else if (inherits(cond, "condition")) {
[17:47:09.841]                         if (!is.null(pattern)) {
[17:47:09.841]                           computeRestarts <- base::computeRestarts
[17:47:09.841]                           grepl <- base::grepl
[17:47:09.841]                           restarts <- computeRestarts(cond)
[17:47:09.841]                           for (restart in restarts) {
[17:47:09.841]                             name <- restart$name
[17:47:09.841]                             if (is.null(name)) 
[17:47:09.841]                               next
[17:47:09.841]                             if (!grepl(pattern, name)) 
[17:47:09.841]                               next
[17:47:09.841]                             invokeRestart(restart)
[17:47:09.841]                             muffled <- TRUE
[17:47:09.841]                             break
[17:47:09.841]                           }
[17:47:09.841]                         }
[17:47:09.841]                       }
[17:47:09.841]                       invisible(muffled)
[17:47:09.841]                     }
[17:47:09.841]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.841]                   }
[17:47:09.841]                 }
[17:47:09.841]                 else {
[17:47:09.841]                   if (TRUE) {
[17:47:09.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.841]                     {
[17:47:09.841]                       inherits <- base::inherits
[17:47:09.841]                       invokeRestart <- base::invokeRestart
[17:47:09.841]                       is.null <- base::is.null
[17:47:09.841]                       muffled <- FALSE
[17:47:09.841]                       if (inherits(cond, "message")) {
[17:47:09.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.841]                         if (muffled) 
[17:47:09.841]                           invokeRestart("muffleMessage")
[17:47:09.841]                       }
[17:47:09.841]                       else if (inherits(cond, "warning")) {
[17:47:09.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.841]                         if (muffled) 
[17:47:09.841]                           invokeRestart("muffleWarning")
[17:47:09.841]                       }
[17:47:09.841]                       else if (inherits(cond, "condition")) {
[17:47:09.841]                         if (!is.null(pattern)) {
[17:47:09.841]                           computeRestarts <- base::computeRestarts
[17:47:09.841]                           grepl <- base::grepl
[17:47:09.841]                           restarts <- computeRestarts(cond)
[17:47:09.841]                           for (restart in restarts) {
[17:47:09.841]                             name <- restart$name
[17:47:09.841]                             if (is.null(name)) 
[17:47:09.841]                               next
[17:47:09.841]                             if (!grepl(pattern, name)) 
[17:47:09.841]                               next
[17:47:09.841]                             invokeRestart(restart)
[17:47:09.841]                             muffled <- TRUE
[17:47:09.841]                             break
[17:47:09.841]                           }
[17:47:09.841]                         }
[17:47:09.841]                       }
[17:47:09.841]                       invisible(muffled)
[17:47:09.841]                     }
[17:47:09.841]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.841]                   }
[17:47:09.841]                 }
[17:47:09.841]             }
[17:47:09.841]         }))
[17:47:09.841]     }, error = function(ex) {
[17:47:09.841]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.841]                 ...future.rng), started = ...future.startTime, 
[17:47:09.841]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.841]             version = "1.8"), class = "FutureResult")
[17:47:09.841]     }, finally = {
[17:47:09.841]         if (!identical(...future.workdir, getwd())) 
[17:47:09.841]             setwd(...future.workdir)
[17:47:09.841]         {
[17:47:09.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.841]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.841]             }
[17:47:09.841]             base::options(...future.oldOptions)
[17:47:09.841]             if (.Platform$OS.type == "windows") {
[17:47:09.841]                 old_names <- names(...future.oldEnvVars)
[17:47:09.841]                 envs <- base::Sys.getenv()
[17:47:09.841]                 names <- names(envs)
[17:47:09.841]                 common <- intersect(names, old_names)
[17:47:09.841]                 added <- setdiff(names, old_names)
[17:47:09.841]                 removed <- setdiff(old_names, names)
[17:47:09.841]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.841]                   envs[common]]
[17:47:09.841]                 NAMES <- toupper(changed)
[17:47:09.841]                 args <- list()
[17:47:09.841]                 for (kk in seq_along(NAMES)) {
[17:47:09.841]                   name <- changed[[kk]]
[17:47:09.841]                   NAME <- NAMES[[kk]]
[17:47:09.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.841]                     next
[17:47:09.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.841]                 }
[17:47:09.841]                 NAMES <- toupper(added)
[17:47:09.841]                 for (kk in seq_along(NAMES)) {
[17:47:09.841]                   name <- added[[kk]]
[17:47:09.841]                   NAME <- NAMES[[kk]]
[17:47:09.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.841]                     next
[17:47:09.841]                   args[[name]] <- ""
[17:47:09.841]                 }
[17:47:09.841]                 NAMES <- toupper(removed)
[17:47:09.841]                 for (kk in seq_along(NAMES)) {
[17:47:09.841]                   name <- removed[[kk]]
[17:47:09.841]                   NAME <- NAMES[[kk]]
[17:47:09.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.841]                     next
[17:47:09.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.841]                 }
[17:47:09.841]                 if (length(args) > 0) 
[17:47:09.841]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.841]             }
[17:47:09.841]             else {
[17:47:09.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.841]             }
[17:47:09.841]             {
[17:47:09.841]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.841]                   0L) {
[17:47:09.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.841]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.841]                   base::options(opts)
[17:47:09.841]                 }
[17:47:09.841]                 {
[17:47:09.841]                   {
[17:47:09.841]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.841]                     NULL
[17:47:09.841]                   }
[17:47:09.841]                   options(future.plan = NULL)
[17:47:09.841]                   if (is.na(NA_character_)) 
[17:47:09.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.841]                     .init = FALSE)
[17:47:09.841]                 }
[17:47:09.841]             }
[17:47:09.841]         }
[17:47:09.841]     })
[17:47:09.841]     if (TRUE) {
[17:47:09.841]         base::sink(type = "output", split = FALSE)
[17:47:09.841]         if (TRUE) {
[17:47:09.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.841]         }
[17:47:09.841]         else {
[17:47:09.841]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.841]         }
[17:47:09.841]         base::close(...future.stdout)
[17:47:09.841]         ...future.stdout <- NULL
[17:47:09.841]     }
[17:47:09.841]     ...future.result$conditions <- ...future.conditions
[17:47:09.841]     ...future.result$finished <- base::Sys.time()
[17:47:09.841]     ...future.result
[17:47:09.841] }
[17:47:09.843] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[17:47:09.844] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[17:47:09.896] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[17:47:09.896] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[17:47:09.897] MultisessionFuture started
[17:47:09.897] - Launch lazy future ... done
[17:47:09.897] run() for ‘MultisessionFuture’ ... done
[17:47:09.897] result() for ClusterFuture ...
[17:47:09.897] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.897] - Validating connection of MultisessionFuture
[17:47:09.941] - received message: FutureResult
[17:47:09.942] - Received FutureResult
[17:47:09.942] - Erased future from FutureRegistry
[17:47:09.942] result() for ClusterFuture ...
[17:47:09.942] - result already collected: FutureResult
[17:47:09.942] result() for ClusterFuture ... done
[17:47:09.942] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:09.942] result() for ClusterFuture ... done
[17:47:09.942] result() for ClusterFuture ...
[17:47:09.942] - result already collected: FutureResult
[17:47:09.942] result() for ClusterFuture ... done
value(b) = 2
[17:47:09.943] result() for ClusterFuture ...
[17:47:09.943] - result already collected: FutureResult
[17:47:09.943] result() for ClusterFuture ... done
[17:47:09.943] result() for ClusterFuture ...
[17:47:09.943] - result already collected: FutureResult
[17:47:09.943] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.943] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.944] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:47:09.944] - globals found: [2] ‘{’, ‘pkg’
[17:47:09.945] Searching for globals ... DONE
[17:47:09.945] Resolving globals: TRUE
[17:47:09.945] Resolving any globals that are futures ...
[17:47:09.945] - globals: [2] ‘{’, ‘pkg’
[17:47:09.945] Resolving any globals that are futures ... DONE
[17:47:09.945] Resolving futures part of globals (recursively) ...
[17:47:09.945] resolve() on list ...
[17:47:09.946]  recursive: 99
[17:47:09.946]  length: 1
[17:47:09.946]  elements: ‘pkg’
[17:47:09.946]  length: 0 (resolved future 1)
[17:47:09.946] resolve() on list ... DONE
[17:47:09.946] - globals: [1] ‘pkg’
[17:47:09.946] Resolving futures part of globals (recursively) ... DONE
[17:47:09.946] The total size of the 1 globals is 112 bytes (112 bytes)
[17:47:09.947] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:47:09.947] - globals: [1] ‘pkg’
[17:47:09.947] 
[17:47:09.947] getGlobalsAndPackages() ... DONE
[17:47:09.947] Packages needed by the future expression (n = 0): <none>
[17:47:09.947] Packages needed by future strategies (n = 0): <none>
[17:47:09.948] {
[17:47:09.948]     {
[17:47:09.948]         {
[17:47:09.948]             ...future.startTime <- base::Sys.time()
[17:47:09.948]             {
[17:47:09.948]                 {
[17:47:09.948]                   {
[17:47:09.948]                     base::local({
[17:47:09.948]                       has_future <- base::requireNamespace("future", 
[17:47:09.948]                         quietly = TRUE)
[17:47:09.948]                       if (has_future) {
[17:47:09.948]                         ns <- base::getNamespace("future")
[17:47:09.948]                         version <- ns[[".package"]][["version"]]
[17:47:09.948]                         if (is.null(version)) 
[17:47:09.948]                           version <- utils::packageVersion("future")
[17:47:09.948]                       }
[17:47:09.948]                       else {
[17:47:09.948]                         version <- NULL
[17:47:09.948]                       }
[17:47:09.948]                       if (!has_future || version < "1.8.0") {
[17:47:09.948]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.948]                           "", base::R.version$version.string), 
[17:47:09.948]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:09.948]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.948]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.948]                             "release", "version")], collapse = " "), 
[17:47:09.948]                           hostname = base::Sys.info()[["nodename"]])
[17:47:09.948]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.948]                           info)
[17:47:09.948]                         info <- base::paste(info, collapse = "; ")
[17:47:09.948]                         if (!has_future) {
[17:47:09.948]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.948]                             info)
[17:47:09.948]                         }
[17:47:09.948]                         else {
[17:47:09.948]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.948]                             info, version)
[17:47:09.948]                         }
[17:47:09.948]                         base::stop(msg)
[17:47:09.948]                       }
[17:47:09.948]                     })
[17:47:09.948]                   }
[17:47:09.948]                   ...future.strategy.old <- future::plan("list")
[17:47:09.948]                   options(future.plan = NULL)
[17:47:09.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.948]                 }
[17:47:09.948]                 ...future.workdir <- getwd()
[17:47:09.948]             }
[17:47:09.948]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.948]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.948]         }
[17:47:09.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.948]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:47:09.948]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.948]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.948]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.948]             base::names(...future.oldOptions))
[17:47:09.948]     }
[17:47:09.948]     if (FALSE) {
[17:47:09.948]     }
[17:47:09.948]     else {
[17:47:09.948]         if (TRUE) {
[17:47:09.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.948]                 open = "w")
[17:47:09.948]         }
[17:47:09.948]         else {
[17:47:09.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.948]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.948]         }
[17:47:09.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.948]             base::sink(type = "output", split = FALSE)
[17:47:09.948]             base::close(...future.stdout)
[17:47:09.948]         }, add = TRUE)
[17:47:09.948]     }
[17:47:09.948]     ...future.frame <- base::sys.nframe()
[17:47:09.948]     ...future.conditions <- base::list()
[17:47:09.948]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.948]     if (FALSE) {
[17:47:09.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.948]     }
[17:47:09.948]     ...future.result <- base::tryCatch({
[17:47:09.948]         base::withCallingHandlers({
[17:47:09.948]             ...future.value <- base::withVisible(base::local({
[17:47:09.948]                 pkg
[17:47:09.948]             }))
[17:47:09.948]             future::FutureResult(value = ...future.value$value, 
[17:47:09.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.948]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.948]                     ...future.globalenv.names))
[17:47:09.948]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.948]         }, condition = base::local({
[17:47:09.948]             c <- base::c
[17:47:09.948]             inherits <- base::inherits
[17:47:09.948]             invokeRestart <- base::invokeRestart
[17:47:09.948]             length <- base::length
[17:47:09.948]             list <- base::list
[17:47:09.948]             seq.int <- base::seq.int
[17:47:09.948]             signalCondition <- base::signalCondition
[17:47:09.948]             sys.calls <- base::sys.calls
[17:47:09.948]             `[[` <- base::`[[`
[17:47:09.948]             `+` <- base::`+`
[17:47:09.948]             `<<-` <- base::`<<-`
[17:47:09.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.948]                   3L)]
[17:47:09.948]             }
[17:47:09.948]             function(cond) {
[17:47:09.948]                 is_error <- inherits(cond, "error")
[17:47:09.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.948]                   NULL)
[17:47:09.948]                 if (is_error) {
[17:47:09.948]                   sessionInformation <- function() {
[17:47:09.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.948]                       search = base::search(), system = base::Sys.info())
[17:47:09.948]                   }
[17:47:09.948]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.948]                     cond$call), session = sessionInformation(), 
[17:47:09.948]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.948]                   signalCondition(cond)
[17:47:09.948]                 }
[17:47:09.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.948]                 "immediateCondition"))) {
[17:47:09.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.948]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.948]                   if (TRUE && !signal) {
[17:47:09.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.948]                     {
[17:47:09.948]                       inherits <- base::inherits
[17:47:09.948]                       invokeRestart <- base::invokeRestart
[17:47:09.948]                       is.null <- base::is.null
[17:47:09.948]                       muffled <- FALSE
[17:47:09.948]                       if (inherits(cond, "message")) {
[17:47:09.948]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.948]                         if (muffled) 
[17:47:09.948]                           invokeRestart("muffleMessage")
[17:47:09.948]                       }
[17:47:09.948]                       else if (inherits(cond, "warning")) {
[17:47:09.948]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.948]                         if (muffled) 
[17:47:09.948]                           invokeRestart("muffleWarning")
[17:47:09.948]                       }
[17:47:09.948]                       else if (inherits(cond, "condition")) {
[17:47:09.948]                         if (!is.null(pattern)) {
[17:47:09.948]                           computeRestarts <- base::computeRestarts
[17:47:09.948]                           grepl <- base::grepl
[17:47:09.948]                           restarts <- computeRestarts(cond)
[17:47:09.948]                           for (restart in restarts) {
[17:47:09.948]                             name <- restart$name
[17:47:09.948]                             if (is.null(name)) 
[17:47:09.948]                               next
[17:47:09.948]                             if (!grepl(pattern, name)) 
[17:47:09.948]                               next
[17:47:09.948]                             invokeRestart(restart)
[17:47:09.948]                             muffled <- TRUE
[17:47:09.948]                             break
[17:47:09.948]                           }
[17:47:09.948]                         }
[17:47:09.948]                       }
[17:47:09.948]                       invisible(muffled)
[17:47:09.948]                     }
[17:47:09.948]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.948]                   }
[17:47:09.948]                 }
[17:47:09.948]                 else {
[17:47:09.948]                   if (TRUE) {
[17:47:09.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.948]                     {
[17:47:09.948]                       inherits <- base::inherits
[17:47:09.948]                       invokeRestart <- base::invokeRestart
[17:47:09.948]                       is.null <- base::is.null
[17:47:09.948]                       muffled <- FALSE
[17:47:09.948]                       if (inherits(cond, "message")) {
[17:47:09.948]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.948]                         if (muffled) 
[17:47:09.948]                           invokeRestart("muffleMessage")
[17:47:09.948]                       }
[17:47:09.948]                       else if (inherits(cond, "warning")) {
[17:47:09.948]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.948]                         if (muffled) 
[17:47:09.948]                           invokeRestart("muffleWarning")
[17:47:09.948]                       }
[17:47:09.948]                       else if (inherits(cond, "condition")) {
[17:47:09.948]                         if (!is.null(pattern)) {
[17:47:09.948]                           computeRestarts <- base::computeRestarts
[17:47:09.948]                           grepl <- base::grepl
[17:47:09.948]                           restarts <- computeRestarts(cond)
[17:47:09.948]                           for (restart in restarts) {
[17:47:09.948]                             name <- restart$name
[17:47:09.948]                             if (is.null(name)) 
[17:47:09.948]                               next
[17:47:09.948]                             if (!grepl(pattern, name)) 
[17:47:09.948]                               next
[17:47:09.948]                             invokeRestart(restart)
[17:47:09.948]                             muffled <- TRUE
[17:47:09.948]                             break
[17:47:09.948]                           }
[17:47:09.948]                         }
[17:47:09.948]                       }
[17:47:09.948]                       invisible(muffled)
[17:47:09.948]                     }
[17:47:09.948]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.948]                   }
[17:47:09.948]                 }
[17:47:09.948]             }
[17:47:09.948]         }))
[17:47:09.948]     }, error = function(ex) {
[17:47:09.948]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.948]                 ...future.rng), started = ...future.startTime, 
[17:47:09.948]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.948]             version = "1.8"), class = "FutureResult")
[17:47:09.948]     }, finally = {
[17:47:09.948]         if (!identical(...future.workdir, getwd())) 
[17:47:09.948]             setwd(...future.workdir)
[17:47:09.948]         {
[17:47:09.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.948]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.948]             }
[17:47:09.948]             base::options(...future.oldOptions)
[17:47:09.948]             if (.Platform$OS.type == "windows") {
[17:47:09.948]                 old_names <- names(...future.oldEnvVars)
[17:47:09.948]                 envs <- base::Sys.getenv()
[17:47:09.948]                 names <- names(envs)
[17:47:09.948]                 common <- intersect(names, old_names)
[17:47:09.948]                 added <- setdiff(names, old_names)
[17:47:09.948]                 removed <- setdiff(old_names, names)
[17:47:09.948]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.948]                   envs[common]]
[17:47:09.948]                 NAMES <- toupper(changed)
[17:47:09.948]                 args <- list()
[17:47:09.948]                 for (kk in seq_along(NAMES)) {
[17:47:09.948]                   name <- changed[[kk]]
[17:47:09.948]                   NAME <- NAMES[[kk]]
[17:47:09.948]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.948]                     next
[17:47:09.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.948]                 }
[17:47:09.948]                 NAMES <- toupper(added)
[17:47:09.948]                 for (kk in seq_along(NAMES)) {
[17:47:09.948]                   name <- added[[kk]]
[17:47:09.948]                   NAME <- NAMES[[kk]]
[17:47:09.948]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.948]                     next
[17:47:09.948]                   args[[name]] <- ""
[17:47:09.948]                 }
[17:47:09.948]                 NAMES <- toupper(removed)
[17:47:09.948]                 for (kk in seq_along(NAMES)) {
[17:47:09.948]                   name <- removed[[kk]]
[17:47:09.948]                   NAME <- NAMES[[kk]]
[17:47:09.948]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.948]                     next
[17:47:09.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.948]                 }
[17:47:09.948]                 if (length(args) > 0) 
[17:47:09.948]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.948]             }
[17:47:09.948]             else {
[17:47:09.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.948]             }
[17:47:09.948]             {
[17:47:09.948]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.948]                   0L) {
[17:47:09.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.948]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.948]                   base::options(opts)
[17:47:09.948]                 }
[17:47:09.948]                 {
[17:47:09.948]                   {
[17:47:09.948]                     NULL
[17:47:09.948]                     RNGkind("Mersenne-Twister")
[17:47:09.948]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:09.948]                       inherits = FALSE)
[17:47:09.948]                   }
[17:47:09.948]                   options(future.plan = NULL)
[17:47:09.948]                   if (is.na(NA_character_)) 
[17:47:09.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.948]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.948]                     .init = FALSE)
[17:47:09.948]                 }
[17:47:09.948]             }
[17:47:09.948]         }
[17:47:09.948]     })
[17:47:09.948]     if (TRUE) {
[17:47:09.948]         base::sink(type = "output", split = FALSE)
[17:47:09.948]         if (TRUE) {
[17:47:09.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.948]         }
[17:47:09.948]         else {
[17:47:09.948]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.948]         }
[17:47:09.948]         base::close(...future.stdout)
[17:47:09.948]         ...future.stdout <- NULL
[17:47:09.948]     }
[17:47:09.948]     ...future.result$conditions <- ...future.conditions
[17:47:09.948]     ...future.result$finished <- base::Sys.time()
[17:47:09.948]     ...future.result
[17:47:09.948] }
[17:47:09.949] assign_globals() ...
[17:47:09.949] List of 1
[17:47:09.949]  $ pkg: chr "foo"
[17:47:09.949]  - attr(*, "where")=List of 1
[17:47:09.949]   ..$ pkg:<environment: R_EmptyEnv> 
[17:47:09.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:09.949]  - attr(*, "resolved")= logi TRUE
[17:47:09.949]  - attr(*, "total_size")= num 112
[17:47:09.952] - copied ‘pkg’ to environment
[17:47:09.952] assign_globals() ... done
[17:47:09.952] plan(): Setting new future strategy stack:
[17:47:09.952] List of future strategies:
[17:47:09.952] 1. sequential:
[17:47:09.952]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:09.952]    - tweaked: FALSE
[17:47:09.952]    - call: NULL
[17:47:09.952] plan(): nbrOfWorkers() = 1
[17:47:09.953] plan(): Setting new future strategy stack:
[17:47:09.953] List of future strategies:
[17:47:09.953] 1. multisession:
[17:47:09.953]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:09.953]    - tweaked: FALSE
[17:47:09.953]    - call: plan(strategy)
[17:47:09.957] plan(): nbrOfWorkers() = 2
[17:47:09.957] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:09.958] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:09.958] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:09.960] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:09.960] Searching for globals ... DONE
[17:47:09.960] Resolving globals: TRUE
[17:47:09.960] Resolving any globals that are futures ...
[17:47:09.960] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:09.960] Resolving any globals that are futures ... DONE
[17:47:09.961] Resolving futures part of globals (recursively) ...
[17:47:09.961] resolve() on list ...
[17:47:09.961]  recursive: 99
[17:47:09.961]  length: 1
[17:47:09.961]  elements: ‘a’
[17:47:09.961]  length: 0 (resolved future 1)
[17:47:09.961] resolve() on list ... DONE
[17:47:09.961] - globals: [1] ‘a’
[17:47:09.961] Resolving futures part of globals (recursively) ... DONE
[17:47:09.962] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:09.962] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:47:09.962] - globals: [1] ‘a’
[17:47:09.962] 
[17:47:09.962] getGlobalsAndPackages() ... DONE
[17:47:09.962] run() for ‘Future’ ...
[17:47:09.963] - state: ‘created’
[17:47:09.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:09.976] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:09.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:09.976]   - Field: ‘node’
[17:47:09.976]   - Field: ‘label’
[17:47:09.976]   - Field: ‘local’
[17:47:09.976]   - Field: ‘owner’
[17:47:09.977]   - Field: ‘envir’
[17:47:09.977]   - Field: ‘workers’
[17:47:09.977]   - Field: ‘packages’
[17:47:09.977]   - Field: ‘gc’
[17:47:09.977]   - Field: ‘conditions’
[17:47:09.977]   - Field: ‘persistent’
[17:47:09.977]   - Field: ‘expr’
[17:47:09.977]   - Field: ‘uuid’
[17:47:09.977]   - Field: ‘seed’
[17:47:09.977]   - Field: ‘version’
[17:47:09.977]   - Field: ‘result’
[17:47:09.978]   - Field: ‘asynchronous’
[17:47:09.978]   - Field: ‘calls’
[17:47:09.978]   - Field: ‘globals’
[17:47:09.978]   - Field: ‘stdout’
[17:47:09.978]   - Field: ‘earlySignal’
[17:47:09.978]   - Field: ‘lazy’
[17:47:09.978]   - Field: ‘state’
[17:47:09.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:09.978] - Launch lazy future ...
[17:47:09.978] Packages needed by the future expression (n = 0): <none>
[17:47:09.979] Packages needed by future strategies (n = 0): <none>
[17:47:09.979] {
[17:47:09.979]     {
[17:47:09.979]         {
[17:47:09.979]             ...future.startTime <- base::Sys.time()
[17:47:09.979]             {
[17:47:09.979]                 {
[17:47:09.979]                   {
[17:47:09.979]                     {
[17:47:09.979]                       base::local({
[17:47:09.979]                         has_future <- base::requireNamespace("future", 
[17:47:09.979]                           quietly = TRUE)
[17:47:09.979]                         if (has_future) {
[17:47:09.979]                           ns <- base::getNamespace("future")
[17:47:09.979]                           version <- ns[[".package"]][["version"]]
[17:47:09.979]                           if (is.null(version)) 
[17:47:09.979]                             version <- utils::packageVersion("future")
[17:47:09.979]                         }
[17:47:09.979]                         else {
[17:47:09.979]                           version <- NULL
[17:47:09.979]                         }
[17:47:09.979]                         if (!has_future || version < "1.8.0") {
[17:47:09.979]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:09.979]                             "", base::R.version$version.string), 
[17:47:09.979]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:09.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:09.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:09.979]                               "release", "version")], collapse = " "), 
[17:47:09.979]                             hostname = base::Sys.info()[["nodename"]])
[17:47:09.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:09.979]                             info)
[17:47:09.979]                           info <- base::paste(info, collapse = "; ")
[17:47:09.979]                           if (!has_future) {
[17:47:09.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:09.979]                               info)
[17:47:09.979]                           }
[17:47:09.979]                           else {
[17:47:09.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:09.979]                               info, version)
[17:47:09.979]                           }
[17:47:09.979]                           base::stop(msg)
[17:47:09.979]                         }
[17:47:09.979]                       })
[17:47:09.979]                     }
[17:47:09.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:09.979]                     base::options(mc.cores = 1L)
[17:47:09.979]                   }
[17:47:09.979]                   ...future.strategy.old <- future::plan("list")
[17:47:09.979]                   options(future.plan = NULL)
[17:47:09.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:09.979]                 }
[17:47:09.979]                 ...future.workdir <- getwd()
[17:47:09.979]             }
[17:47:09.979]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:09.979]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:09.979]         }
[17:47:09.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:09.979]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:09.979]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:09.979]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:09.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:09.979]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:09.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:09.979]             base::names(...future.oldOptions))
[17:47:09.979]     }
[17:47:09.979]     if (FALSE) {
[17:47:09.979]     }
[17:47:09.979]     else {
[17:47:09.979]         if (TRUE) {
[17:47:09.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:09.979]                 open = "w")
[17:47:09.979]         }
[17:47:09.979]         else {
[17:47:09.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:09.979]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:09.979]         }
[17:47:09.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:09.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:09.979]             base::sink(type = "output", split = FALSE)
[17:47:09.979]             base::close(...future.stdout)
[17:47:09.979]         }, add = TRUE)
[17:47:09.979]     }
[17:47:09.979]     ...future.frame <- base::sys.nframe()
[17:47:09.979]     ...future.conditions <- base::list()
[17:47:09.979]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:09.979]     if (FALSE) {
[17:47:09.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:09.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:09.979]     }
[17:47:09.979]     ...future.result <- base::tryCatch({
[17:47:09.979]         base::withCallingHandlers({
[17:47:09.979]             ...future.value <- base::withVisible(base::local({
[17:47:09.979]                 ...future.makeSendCondition <- base::local({
[17:47:09.979]                   sendCondition <- NULL
[17:47:09.979]                   function(frame = 1L) {
[17:47:09.979]                     if (is.function(sendCondition)) 
[17:47:09.979]                       return(sendCondition)
[17:47:09.979]                     ns <- getNamespace("parallel")
[17:47:09.979]                     if (exists("sendData", mode = "function", 
[17:47:09.979]                       envir = ns)) {
[17:47:09.979]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:09.979]                         envir = ns)
[17:47:09.979]                       envir <- sys.frame(frame)
[17:47:09.979]                       master <- NULL
[17:47:09.979]                       while (!identical(envir, .GlobalEnv) && 
[17:47:09.979]                         !identical(envir, emptyenv())) {
[17:47:09.979]                         if (exists("master", mode = "list", envir = envir, 
[17:47:09.979]                           inherits = FALSE)) {
[17:47:09.979]                           master <- get("master", mode = "list", 
[17:47:09.979]                             envir = envir, inherits = FALSE)
[17:47:09.979]                           if (inherits(master, c("SOCKnode", 
[17:47:09.979]                             "SOCK0node"))) {
[17:47:09.979]                             sendCondition <<- function(cond) {
[17:47:09.979]                               data <- list(type = "VALUE", value = cond, 
[17:47:09.979]                                 success = TRUE)
[17:47:09.979]                               parallel_sendData(master, data)
[17:47:09.979]                             }
[17:47:09.979]                             return(sendCondition)
[17:47:09.979]                           }
[17:47:09.979]                         }
[17:47:09.979]                         frame <- frame + 1L
[17:47:09.979]                         envir <- sys.frame(frame)
[17:47:09.979]                       }
[17:47:09.979]                     }
[17:47:09.979]                     sendCondition <<- function(cond) NULL
[17:47:09.979]                   }
[17:47:09.979]                 })
[17:47:09.979]                 withCallingHandlers({
[17:47:09.979]                   {
[17:47:09.979]                     b <- a
[17:47:09.979]                     a <- 2
[17:47:09.979]                     a * b
[17:47:09.979]                   }
[17:47:09.979]                 }, immediateCondition = function(cond) {
[17:47:09.979]                   sendCondition <- ...future.makeSendCondition()
[17:47:09.979]                   sendCondition(cond)
[17:47:09.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.979]                   {
[17:47:09.979]                     inherits <- base::inherits
[17:47:09.979]                     invokeRestart <- base::invokeRestart
[17:47:09.979]                     is.null <- base::is.null
[17:47:09.979]                     muffled <- FALSE
[17:47:09.979]                     if (inherits(cond, "message")) {
[17:47:09.979]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:09.979]                       if (muffled) 
[17:47:09.979]                         invokeRestart("muffleMessage")
[17:47:09.979]                     }
[17:47:09.979]                     else if (inherits(cond, "warning")) {
[17:47:09.979]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:09.979]                       if (muffled) 
[17:47:09.979]                         invokeRestart("muffleWarning")
[17:47:09.979]                     }
[17:47:09.979]                     else if (inherits(cond, "condition")) {
[17:47:09.979]                       if (!is.null(pattern)) {
[17:47:09.979]                         computeRestarts <- base::computeRestarts
[17:47:09.979]                         grepl <- base::grepl
[17:47:09.979]                         restarts <- computeRestarts(cond)
[17:47:09.979]                         for (restart in restarts) {
[17:47:09.979]                           name <- restart$name
[17:47:09.979]                           if (is.null(name)) 
[17:47:09.979]                             next
[17:47:09.979]                           if (!grepl(pattern, name)) 
[17:47:09.979]                             next
[17:47:09.979]                           invokeRestart(restart)
[17:47:09.979]                           muffled <- TRUE
[17:47:09.979]                           break
[17:47:09.979]                         }
[17:47:09.979]                       }
[17:47:09.979]                     }
[17:47:09.979]                     invisible(muffled)
[17:47:09.979]                   }
[17:47:09.979]                   muffleCondition(cond)
[17:47:09.979]                 })
[17:47:09.979]             }))
[17:47:09.979]             future::FutureResult(value = ...future.value$value, 
[17:47:09.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.979]                   ...future.rng), globalenv = if (FALSE) 
[17:47:09.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:09.979]                     ...future.globalenv.names))
[17:47:09.979]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:09.979]         }, condition = base::local({
[17:47:09.979]             c <- base::c
[17:47:09.979]             inherits <- base::inherits
[17:47:09.979]             invokeRestart <- base::invokeRestart
[17:47:09.979]             length <- base::length
[17:47:09.979]             list <- base::list
[17:47:09.979]             seq.int <- base::seq.int
[17:47:09.979]             signalCondition <- base::signalCondition
[17:47:09.979]             sys.calls <- base::sys.calls
[17:47:09.979]             `[[` <- base::`[[`
[17:47:09.979]             `+` <- base::`+`
[17:47:09.979]             `<<-` <- base::`<<-`
[17:47:09.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:09.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:09.979]                   3L)]
[17:47:09.979]             }
[17:47:09.979]             function(cond) {
[17:47:09.979]                 is_error <- inherits(cond, "error")
[17:47:09.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:09.979]                   NULL)
[17:47:09.979]                 if (is_error) {
[17:47:09.979]                   sessionInformation <- function() {
[17:47:09.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:09.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:09.979]                       search = base::search(), system = base::Sys.info())
[17:47:09.979]                   }
[17:47:09.979]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:09.979]                     cond$call), session = sessionInformation(), 
[17:47:09.979]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:09.979]                   signalCondition(cond)
[17:47:09.979]                 }
[17:47:09.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:09.979]                 "immediateCondition"))) {
[17:47:09.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:09.979]                   ...future.conditions[[length(...future.conditions) + 
[17:47:09.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:09.979]                   if (TRUE && !signal) {
[17:47:09.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.979]                     {
[17:47:09.979]                       inherits <- base::inherits
[17:47:09.979]                       invokeRestart <- base::invokeRestart
[17:47:09.979]                       is.null <- base::is.null
[17:47:09.979]                       muffled <- FALSE
[17:47:09.979]                       if (inherits(cond, "message")) {
[17:47:09.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.979]                         if (muffled) 
[17:47:09.979]                           invokeRestart("muffleMessage")
[17:47:09.979]                       }
[17:47:09.979]                       else if (inherits(cond, "warning")) {
[17:47:09.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.979]                         if (muffled) 
[17:47:09.979]                           invokeRestart("muffleWarning")
[17:47:09.979]                       }
[17:47:09.979]                       else if (inherits(cond, "condition")) {
[17:47:09.979]                         if (!is.null(pattern)) {
[17:47:09.979]                           computeRestarts <- base::computeRestarts
[17:47:09.979]                           grepl <- base::grepl
[17:47:09.979]                           restarts <- computeRestarts(cond)
[17:47:09.979]                           for (restart in restarts) {
[17:47:09.979]                             name <- restart$name
[17:47:09.979]                             if (is.null(name)) 
[17:47:09.979]                               next
[17:47:09.979]                             if (!grepl(pattern, name)) 
[17:47:09.979]                               next
[17:47:09.979]                             invokeRestart(restart)
[17:47:09.979]                             muffled <- TRUE
[17:47:09.979]                             break
[17:47:09.979]                           }
[17:47:09.979]                         }
[17:47:09.979]                       }
[17:47:09.979]                       invisible(muffled)
[17:47:09.979]                     }
[17:47:09.979]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.979]                   }
[17:47:09.979]                 }
[17:47:09.979]                 else {
[17:47:09.979]                   if (TRUE) {
[17:47:09.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:09.979]                     {
[17:47:09.979]                       inherits <- base::inherits
[17:47:09.979]                       invokeRestart <- base::invokeRestart
[17:47:09.979]                       is.null <- base::is.null
[17:47:09.979]                       muffled <- FALSE
[17:47:09.979]                       if (inherits(cond, "message")) {
[17:47:09.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:09.979]                         if (muffled) 
[17:47:09.979]                           invokeRestart("muffleMessage")
[17:47:09.979]                       }
[17:47:09.979]                       else if (inherits(cond, "warning")) {
[17:47:09.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:09.979]                         if (muffled) 
[17:47:09.979]                           invokeRestart("muffleWarning")
[17:47:09.979]                       }
[17:47:09.979]                       else if (inherits(cond, "condition")) {
[17:47:09.979]                         if (!is.null(pattern)) {
[17:47:09.979]                           computeRestarts <- base::computeRestarts
[17:47:09.979]                           grepl <- base::grepl
[17:47:09.979]                           restarts <- computeRestarts(cond)
[17:47:09.979]                           for (restart in restarts) {
[17:47:09.979]                             name <- restart$name
[17:47:09.979]                             if (is.null(name)) 
[17:47:09.979]                               next
[17:47:09.979]                             if (!grepl(pattern, name)) 
[17:47:09.979]                               next
[17:47:09.979]                             invokeRestart(restart)
[17:47:09.979]                             muffled <- TRUE
[17:47:09.979]                             break
[17:47:09.979]                           }
[17:47:09.979]                         }
[17:47:09.979]                       }
[17:47:09.979]                       invisible(muffled)
[17:47:09.979]                     }
[17:47:09.979]                     muffleCondition(cond, pattern = "^muffle")
[17:47:09.979]                   }
[17:47:09.979]                 }
[17:47:09.979]             }
[17:47:09.979]         }))
[17:47:09.979]     }, error = function(ex) {
[17:47:09.979]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:09.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:09.979]                 ...future.rng), started = ...future.startTime, 
[17:47:09.979]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:09.979]             version = "1.8"), class = "FutureResult")
[17:47:09.979]     }, finally = {
[17:47:09.979]         if (!identical(...future.workdir, getwd())) 
[17:47:09.979]             setwd(...future.workdir)
[17:47:09.979]         {
[17:47:09.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:09.979]                 ...future.oldOptions$nwarnings <- NULL
[17:47:09.979]             }
[17:47:09.979]             base::options(...future.oldOptions)
[17:47:09.979]             if (.Platform$OS.type == "windows") {
[17:47:09.979]                 old_names <- names(...future.oldEnvVars)
[17:47:09.979]                 envs <- base::Sys.getenv()
[17:47:09.979]                 names <- names(envs)
[17:47:09.979]                 common <- intersect(names, old_names)
[17:47:09.979]                 added <- setdiff(names, old_names)
[17:47:09.979]                 removed <- setdiff(old_names, names)
[17:47:09.979]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:09.979]                   envs[common]]
[17:47:09.979]                 NAMES <- toupper(changed)
[17:47:09.979]                 args <- list()
[17:47:09.979]                 for (kk in seq_along(NAMES)) {
[17:47:09.979]                   name <- changed[[kk]]
[17:47:09.979]                   NAME <- NAMES[[kk]]
[17:47:09.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.979]                     next
[17:47:09.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.979]                 }
[17:47:09.979]                 NAMES <- toupper(added)
[17:47:09.979]                 for (kk in seq_along(NAMES)) {
[17:47:09.979]                   name <- added[[kk]]
[17:47:09.979]                   NAME <- NAMES[[kk]]
[17:47:09.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.979]                     next
[17:47:09.979]                   args[[name]] <- ""
[17:47:09.979]                 }
[17:47:09.979]                 NAMES <- toupper(removed)
[17:47:09.979]                 for (kk in seq_along(NAMES)) {
[17:47:09.979]                   name <- removed[[kk]]
[17:47:09.979]                   NAME <- NAMES[[kk]]
[17:47:09.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:09.979]                     next
[17:47:09.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:09.979]                 }
[17:47:09.979]                 if (length(args) > 0) 
[17:47:09.979]                   base::do.call(base::Sys.setenv, args = args)
[17:47:09.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:09.979]             }
[17:47:09.979]             else {
[17:47:09.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:09.979]             }
[17:47:09.979]             {
[17:47:09.979]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:09.979]                   0L) {
[17:47:09.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:09.979]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:09.979]                   base::options(opts)
[17:47:09.979]                 }
[17:47:09.979]                 {
[17:47:09.979]                   {
[17:47:09.979]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:09.979]                     NULL
[17:47:09.979]                   }
[17:47:09.979]                   options(future.plan = NULL)
[17:47:09.979]                   if (is.na(NA_character_)) 
[17:47:09.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:09.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:09.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:09.979]                     .init = FALSE)
[17:47:09.979]                 }
[17:47:09.979]             }
[17:47:09.979]         }
[17:47:09.979]     })
[17:47:09.979]     if (TRUE) {
[17:47:09.979]         base::sink(type = "output", split = FALSE)
[17:47:09.979]         if (TRUE) {
[17:47:09.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:09.979]         }
[17:47:09.979]         else {
[17:47:09.979]             ...future.result["stdout"] <- base::list(NULL)
[17:47:09.979]         }
[17:47:09.979]         base::close(...future.stdout)
[17:47:09.979]         ...future.stdout <- NULL
[17:47:09.979]     }
[17:47:09.979]     ...future.result$conditions <- ...future.conditions
[17:47:09.979]     ...future.result$finished <- base::Sys.time()
[17:47:09.979]     ...future.result
[17:47:09.979] }
[17:47:09.981] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:47:09.982] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:47:09.982] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:47:09.982] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:47:09.982] MultisessionFuture started
[17:47:09.983] - Launch lazy future ... done
[17:47:09.983] run() for ‘MultisessionFuture’ ... done
[17:47:09.983] result() for ClusterFuture ...
[17:47:09.983] receiveMessageFromWorker() for ClusterFuture ...
[17:47:09.983] - Validating connection of MultisessionFuture
[17:47:10.025] - received message: FutureResult
[17:47:10.025] - Received FutureResult
[17:47:10.025] - Erased future from FutureRegistry
[17:47:10.026] result() for ClusterFuture ...
[17:47:10.026] - result already collected: FutureResult
[17:47:10.026] result() for ClusterFuture ... done
[17:47:10.026] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.026] result() for ClusterFuture ... done
[17:47:10.026] result() for ClusterFuture ...
[17:47:10.026] - result already collected: FutureResult
[17:47:10.026] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.027] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.027] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.029] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:10.029] Searching for globals ... DONE
[17:47:10.029] Resolving globals: TRUE
[17:47:10.029] Resolving any globals that are futures ...
[17:47:10.029] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:47:10.029] Resolving any globals that are futures ... DONE
[17:47:10.029] Resolving futures part of globals (recursively) ...
[17:47:10.030] resolve() on list ...
[17:47:10.030]  recursive: 99
[17:47:10.030]  length: 1
[17:47:10.030]  elements: ‘a’
[17:47:10.030]  length: 0 (resolved future 1)
[17:47:10.030] resolve() on list ... DONE
[17:47:10.030] - globals: [1] ‘a’
[17:47:10.030] Resolving futures part of globals (recursively) ... DONE
[17:47:10.030] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:10.031] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:47:10.031] - globals: [1] ‘a’
[17:47:10.031] 
[17:47:10.031] getGlobalsAndPackages() ... DONE
[17:47:10.031] run() for ‘Future’ ...
[17:47:10.032] - state: ‘created’
[17:47:10.032] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.045] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.046]   - Field: ‘node’
[17:47:10.046]   - Field: ‘label’
[17:47:10.046]   - Field: ‘local’
[17:47:10.046]   - Field: ‘owner’
[17:47:10.046]   - Field: ‘envir’
[17:47:10.046]   - Field: ‘workers’
[17:47:10.046]   - Field: ‘packages’
[17:47:10.046]   - Field: ‘gc’
[17:47:10.046]   - Field: ‘conditions’
[17:47:10.047]   - Field: ‘persistent’
[17:47:10.047]   - Field: ‘expr’
[17:47:10.047]   - Field: ‘uuid’
[17:47:10.047]   - Field: ‘seed’
[17:47:10.047]   - Field: ‘version’
[17:47:10.047]   - Field: ‘result’
[17:47:10.047]   - Field: ‘asynchronous’
[17:47:10.047]   - Field: ‘calls’
[17:47:10.047]   - Field: ‘globals’
[17:47:10.047]   - Field: ‘stdout’
[17:47:10.048]   - Field: ‘earlySignal’
[17:47:10.048]   - Field: ‘lazy’
[17:47:10.048]   - Field: ‘state’
[17:47:10.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.048] - Launch lazy future ...
[17:47:10.048] Packages needed by the future expression (n = 0): <none>
[17:47:10.048] Packages needed by future strategies (n = 0): <none>
[17:47:10.049] {
[17:47:10.049]     {
[17:47:10.049]         {
[17:47:10.049]             ...future.startTime <- base::Sys.time()
[17:47:10.049]             {
[17:47:10.049]                 {
[17:47:10.049]                   {
[17:47:10.049]                     {
[17:47:10.049]                       base::local({
[17:47:10.049]                         has_future <- base::requireNamespace("future", 
[17:47:10.049]                           quietly = TRUE)
[17:47:10.049]                         if (has_future) {
[17:47:10.049]                           ns <- base::getNamespace("future")
[17:47:10.049]                           version <- ns[[".package"]][["version"]]
[17:47:10.049]                           if (is.null(version)) 
[17:47:10.049]                             version <- utils::packageVersion("future")
[17:47:10.049]                         }
[17:47:10.049]                         else {
[17:47:10.049]                           version <- NULL
[17:47:10.049]                         }
[17:47:10.049]                         if (!has_future || version < "1.8.0") {
[17:47:10.049]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.049]                             "", base::R.version$version.string), 
[17:47:10.049]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.049]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.049]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.049]                               "release", "version")], collapse = " "), 
[17:47:10.049]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.049]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.049]                             info)
[17:47:10.049]                           info <- base::paste(info, collapse = "; ")
[17:47:10.049]                           if (!has_future) {
[17:47:10.049]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.049]                               info)
[17:47:10.049]                           }
[17:47:10.049]                           else {
[17:47:10.049]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.049]                               info, version)
[17:47:10.049]                           }
[17:47:10.049]                           base::stop(msg)
[17:47:10.049]                         }
[17:47:10.049]                       })
[17:47:10.049]                     }
[17:47:10.049]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.049]                     base::options(mc.cores = 1L)
[17:47:10.049]                   }
[17:47:10.049]                   ...future.strategy.old <- future::plan("list")
[17:47:10.049]                   options(future.plan = NULL)
[17:47:10.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.049]                 }
[17:47:10.049]                 ...future.workdir <- getwd()
[17:47:10.049]             }
[17:47:10.049]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.049]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.049]         }
[17:47:10.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.049]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.049]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.049]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.049]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.049]             base::names(...future.oldOptions))
[17:47:10.049]     }
[17:47:10.049]     if (FALSE) {
[17:47:10.049]     }
[17:47:10.049]     else {
[17:47:10.049]         if (TRUE) {
[17:47:10.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.049]                 open = "w")
[17:47:10.049]         }
[17:47:10.049]         else {
[17:47:10.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.049]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.049]         }
[17:47:10.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.049]             base::sink(type = "output", split = FALSE)
[17:47:10.049]             base::close(...future.stdout)
[17:47:10.049]         }, add = TRUE)
[17:47:10.049]     }
[17:47:10.049]     ...future.frame <- base::sys.nframe()
[17:47:10.049]     ...future.conditions <- base::list()
[17:47:10.049]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.049]     if (FALSE) {
[17:47:10.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.049]     }
[17:47:10.049]     ...future.result <- base::tryCatch({
[17:47:10.049]         base::withCallingHandlers({
[17:47:10.049]             ...future.value <- base::withVisible(base::local({
[17:47:10.049]                 ...future.makeSendCondition <- base::local({
[17:47:10.049]                   sendCondition <- NULL
[17:47:10.049]                   function(frame = 1L) {
[17:47:10.049]                     if (is.function(sendCondition)) 
[17:47:10.049]                       return(sendCondition)
[17:47:10.049]                     ns <- getNamespace("parallel")
[17:47:10.049]                     if (exists("sendData", mode = "function", 
[17:47:10.049]                       envir = ns)) {
[17:47:10.049]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.049]                         envir = ns)
[17:47:10.049]                       envir <- sys.frame(frame)
[17:47:10.049]                       master <- NULL
[17:47:10.049]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.049]                         !identical(envir, emptyenv())) {
[17:47:10.049]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.049]                           inherits = FALSE)) {
[17:47:10.049]                           master <- get("master", mode = "list", 
[17:47:10.049]                             envir = envir, inherits = FALSE)
[17:47:10.049]                           if (inherits(master, c("SOCKnode", 
[17:47:10.049]                             "SOCK0node"))) {
[17:47:10.049]                             sendCondition <<- function(cond) {
[17:47:10.049]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.049]                                 success = TRUE)
[17:47:10.049]                               parallel_sendData(master, data)
[17:47:10.049]                             }
[17:47:10.049]                             return(sendCondition)
[17:47:10.049]                           }
[17:47:10.049]                         }
[17:47:10.049]                         frame <- frame + 1L
[17:47:10.049]                         envir <- sys.frame(frame)
[17:47:10.049]                       }
[17:47:10.049]                     }
[17:47:10.049]                     sendCondition <<- function(cond) NULL
[17:47:10.049]                   }
[17:47:10.049]                 })
[17:47:10.049]                 withCallingHandlers({
[17:47:10.049]                   {
[17:47:10.049]                     b <- a
[17:47:10.049]                     a <- 2
[17:47:10.049]                     a * b
[17:47:10.049]                   }
[17:47:10.049]                 }, immediateCondition = function(cond) {
[17:47:10.049]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.049]                   sendCondition(cond)
[17:47:10.049]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.049]                   {
[17:47:10.049]                     inherits <- base::inherits
[17:47:10.049]                     invokeRestart <- base::invokeRestart
[17:47:10.049]                     is.null <- base::is.null
[17:47:10.049]                     muffled <- FALSE
[17:47:10.049]                     if (inherits(cond, "message")) {
[17:47:10.049]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.049]                       if (muffled) 
[17:47:10.049]                         invokeRestart("muffleMessage")
[17:47:10.049]                     }
[17:47:10.049]                     else if (inherits(cond, "warning")) {
[17:47:10.049]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.049]                       if (muffled) 
[17:47:10.049]                         invokeRestart("muffleWarning")
[17:47:10.049]                     }
[17:47:10.049]                     else if (inherits(cond, "condition")) {
[17:47:10.049]                       if (!is.null(pattern)) {
[17:47:10.049]                         computeRestarts <- base::computeRestarts
[17:47:10.049]                         grepl <- base::grepl
[17:47:10.049]                         restarts <- computeRestarts(cond)
[17:47:10.049]                         for (restart in restarts) {
[17:47:10.049]                           name <- restart$name
[17:47:10.049]                           if (is.null(name)) 
[17:47:10.049]                             next
[17:47:10.049]                           if (!grepl(pattern, name)) 
[17:47:10.049]                             next
[17:47:10.049]                           invokeRestart(restart)
[17:47:10.049]                           muffled <- TRUE
[17:47:10.049]                           break
[17:47:10.049]                         }
[17:47:10.049]                       }
[17:47:10.049]                     }
[17:47:10.049]                     invisible(muffled)
[17:47:10.049]                   }
[17:47:10.049]                   muffleCondition(cond)
[17:47:10.049]                 })
[17:47:10.049]             }))
[17:47:10.049]             future::FutureResult(value = ...future.value$value, 
[17:47:10.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.049]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.049]                     ...future.globalenv.names))
[17:47:10.049]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.049]         }, condition = base::local({
[17:47:10.049]             c <- base::c
[17:47:10.049]             inherits <- base::inherits
[17:47:10.049]             invokeRestart <- base::invokeRestart
[17:47:10.049]             length <- base::length
[17:47:10.049]             list <- base::list
[17:47:10.049]             seq.int <- base::seq.int
[17:47:10.049]             signalCondition <- base::signalCondition
[17:47:10.049]             sys.calls <- base::sys.calls
[17:47:10.049]             `[[` <- base::`[[`
[17:47:10.049]             `+` <- base::`+`
[17:47:10.049]             `<<-` <- base::`<<-`
[17:47:10.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.049]                   3L)]
[17:47:10.049]             }
[17:47:10.049]             function(cond) {
[17:47:10.049]                 is_error <- inherits(cond, "error")
[17:47:10.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.049]                   NULL)
[17:47:10.049]                 if (is_error) {
[17:47:10.049]                   sessionInformation <- function() {
[17:47:10.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.049]                       search = base::search(), system = base::Sys.info())
[17:47:10.049]                   }
[17:47:10.049]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.049]                     cond$call), session = sessionInformation(), 
[17:47:10.049]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.049]                   signalCondition(cond)
[17:47:10.049]                 }
[17:47:10.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.049]                 "immediateCondition"))) {
[17:47:10.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.049]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.049]                   if (TRUE && !signal) {
[17:47:10.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.049]                     {
[17:47:10.049]                       inherits <- base::inherits
[17:47:10.049]                       invokeRestart <- base::invokeRestart
[17:47:10.049]                       is.null <- base::is.null
[17:47:10.049]                       muffled <- FALSE
[17:47:10.049]                       if (inherits(cond, "message")) {
[17:47:10.049]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.049]                         if (muffled) 
[17:47:10.049]                           invokeRestart("muffleMessage")
[17:47:10.049]                       }
[17:47:10.049]                       else if (inherits(cond, "warning")) {
[17:47:10.049]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.049]                         if (muffled) 
[17:47:10.049]                           invokeRestart("muffleWarning")
[17:47:10.049]                       }
[17:47:10.049]                       else if (inherits(cond, "condition")) {
[17:47:10.049]                         if (!is.null(pattern)) {
[17:47:10.049]                           computeRestarts <- base::computeRestarts
[17:47:10.049]                           grepl <- base::grepl
[17:47:10.049]                           restarts <- computeRestarts(cond)
[17:47:10.049]                           for (restart in restarts) {
[17:47:10.049]                             name <- restart$name
[17:47:10.049]                             if (is.null(name)) 
[17:47:10.049]                               next
[17:47:10.049]                             if (!grepl(pattern, name)) 
[17:47:10.049]                               next
[17:47:10.049]                             invokeRestart(restart)
[17:47:10.049]                             muffled <- TRUE
[17:47:10.049]                             break
[17:47:10.049]                           }
[17:47:10.049]                         }
[17:47:10.049]                       }
[17:47:10.049]                       invisible(muffled)
[17:47:10.049]                     }
[17:47:10.049]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.049]                   }
[17:47:10.049]                 }
[17:47:10.049]                 else {
[17:47:10.049]                   if (TRUE) {
[17:47:10.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.049]                     {
[17:47:10.049]                       inherits <- base::inherits
[17:47:10.049]                       invokeRestart <- base::invokeRestart
[17:47:10.049]                       is.null <- base::is.null
[17:47:10.049]                       muffled <- FALSE
[17:47:10.049]                       if (inherits(cond, "message")) {
[17:47:10.049]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.049]                         if (muffled) 
[17:47:10.049]                           invokeRestart("muffleMessage")
[17:47:10.049]                       }
[17:47:10.049]                       else if (inherits(cond, "warning")) {
[17:47:10.049]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.049]                         if (muffled) 
[17:47:10.049]                           invokeRestart("muffleWarning")
[17:47:10.049]                       }
[17:47:10.049]                       else if (inherits(cond, "condition")) {
[17:47:10.049]                         if (!is.null(pattern)) {
[17:47:10.049]                           computeRestarts <- base::computeRestarts
[17:47:10.049]                           grepl <- base::grepl
[17:47:10.049]                           restarts <- computeRestarts(cond)
[17:47:10.049]                           for (restart in restarts) {
[17:47:10.049]                             name <- restart$name
[17:47:10.049]                             if (is.null(name)) 
[17:47:10.049]                               next
[17:47:10.049]                             if (!grepl(pattern, name)) 
[17:47:10.049]                               next
[17:47:10.049]                             invokeRestart(restart)
[17:47:10.049]                             muffled <- TRUE
[17:47:10.049]                             break
[17:47:10.049]                           }
[17:47:10.049]                         }
[17:47:10.049]                       }
[17:47:10.049]                       invisible(muffled)
[17:47:10.049]                     }
[17:47:10.049]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.049]                   }
[17:47:10.049]                 }
[17:47:10.049]             }
[17:47:10.049]         }))
[17:47:10.049]     }, error = function(ex) {
[17:47:10.049]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.049]                 ...future.rng), started = ...future.startTime, 
[17:47:10.049]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.049]             version = "1.8"), class = "FutureResult")
[17:47:10.049]     }, finally = {
[17:47:10.049]         if (!identical(...future.workdir, getwd())) 
[17:47:10.049]             setwd(...future.workdir)
[17:47:10.049]         {
[17:47:10.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.049]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.049]             }
[17:47:10.049]             base::options(...future.oldOptions)
[17:47:10.049]             if (.Platform$OS.type == "windows") {
[17:47:10.049]                 old_names <- names(...future.oldEnvVars)
[17:47:10.049]                 envs <- base::Sys.getenv()
[17:47:10.049]                 names <- names(envs)
[17:47:10.049]                 common <- intersect(names, old_names)
[17:47:10.049]                 added <- setdiff(names, old_names)
[17:47:10.049]                 removed <- setdiff(old_names, names)
[17:47:10.049]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.049]                   envs[common]]
[17:47:10.049]                 NAMES <- toupper(changed)
[17:47:10.049]                 args <- list()
[17:47:10.049]                 for (kk in seq_along(NAMES)) {
[17:47:10.049]                   name <- changed[[kk]]
[17:47:10.049]                   NAME <- NAMES[[kk]]
[17:47:10.049]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.049]                     next
[17:47:10.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.049]                 }
[17:47:10.049]                 NAMES <- toupper(added)
[17:47:10.049]                 for (kk in seq_along(NAMES)) {
[17:47:10.049]                   name <- added[[kk]]
[17:47:10.049]                   NAME <- NAMES[[kk]]
[17:47:10.049]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.049]                     next
[17:47:10.049]                   args[[name]] <- ""
[17:47:10.049]                 }
[17:47:10.049]                 NAMES <- toupper(removed)
[17:47:10.049]                 for (kk in seq_along(NAMES)) {
[17:47:10.049]                   name <- removed[[kk]]
[17:47:10.049]                   NAME <- NAMES[[kk]]
[17:47:10.049]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.049]                     next
[17:47:10.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.049]                 }
[17:47:10.049]                 if (length(args) > 0) 
[17:47:10.049]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.049]             }
[17:47:10.049]             else {
[17:47:10.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.049]             }
[17:47:10.049]             {
[17:47:10.049]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.049]                   0L) {
[17:47:10.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.049]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.049]                   base::options(opts)
[17:47:10.049]                 }
[17:47:10.049]                 {
[17:47:10.049]                   {
[17:47:10.049]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.049]                     NULL
[17:47:10.049]                   }
[17:47:10.049]                   options(future.plan = NULL)
[17:47:10.049]                   if (is.na(NA_character_)) 
[17:47:10.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.049]                     .init = FALSE)
[17:47:10.049]                 }
[17:47:10.049]             }
[17:47:10.049]         }
[17:47:10.049]     })
[17:47:10.049]     if (TRUE) {
[17:47:10.049]         base::sink(type = "output", split = FALSE)
[17:47:10.049]         if (TRUE) {
[17:47:10.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.049]         }
[17:47:10.049]         else {
[17:47:10.049]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.049]         }
[17:47:10.049]         base::close(...future.stdout)
[17:47:10.049]         ...future.stdout <- NULL
[17:47:10.049]     }
[17:47:10.049]     ...future.result$conditions <- ...future.conditions
[17:47:10.049]     ...future.result$finished <- base::Sys.time()
[17:47:10.049]     ...future.result
[17:47:10.049] }
[17:47:10.051] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:47:10.051] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:47:10.052] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:47:10.052] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:47:10.052] MultisessionFuture started
[17:47:10.052] - Launch lazy future ... done
[17:47:10.052] run() for ‘MultisessionFuture’ ... done
[17:47:10.053] result() for ClusterFuture ...
[17:47:10.053] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.053] - Validating connection of MultisessionFuture
[17:47:10.097] - received message: FutureResult
[17:47:10.098] - Received FutureResult
[17:47:10.098] - Erased future from FutureRegistry
[17:47:10.098] result() for ClusterFuture ...
[17:47:10.098] - result already collected: FutureResult
[17:47:10.098] result() for ClusterFuture ... done
[17:47:10.098] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.098] result() for ClusterFuture ... done
[17:47:10.098] result() for ClusterFuture ...
[17:47:10.098] - result already collected: FutureResult
[17:47:10.098] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.099] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.099] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.101] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.101] Searching for globals ... DONE
[17:47:10.101] Resolving globals: TRUE
[17:47:10.102] Resolving any globals that are futures ...
[17:47:10.102] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.102] Resolving any globals that are futures ... DONE
[17:47:10.102] Resolving futures part of globals (recursively) ...
[17:47:10.102] resolve() on list ...
[17:47:10.102]  recursive: 99
[17:47:10.103]  length: 2
[17:47:10.103]  elements: ‘a’, ‘ii’
[17:47:10.103]  length: 1 (resolved future 1)
[17:47:10.103]  length: 0 (resolved future 2)
[17:47:10.103] resolve() on list ... DONE
[17:47:10.103] - globals: [2] ‘a’, ‘ii’
[17:47:10.103] Resolving futures part of globals (recursively) ... DONE
[17:47:10.103] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:10.104] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:10.104] - globals: [2] ‘a’, ‘ii’
[17:47:10.104] 
[17:47:10.104] getGlobalsAndPackages() ... DONE
[17:47:10.104] run() for ‘Future’ ...
[17:47:10.104] - state: ‘created’
[17:47:10.105] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.118] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.118] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.119]   - Field: ‘node’
[17:47:10.119]   - Field: ‘label’
[17:47:10.119]   - Field: ‘local’
[17:47:10.119]   - Field: ‘owner’
[17:47:10.119]   - Field: ‘envir’
[17:47:10.119]   - Field: ‘workers’
[17:47:10.119]   - Field: ‘packages’
[17:47:10.119]   - Field: ‘gc’
[17:47:10.119]   - Field: ‘conditions’
[17:47:10.119]   - Field: ‘persistent’
[17:47:10.120]   - Field: ‘expr’
[17:47:10.120]   - Field: ‘uuid’
[17:47:10.120]   - Field: ‘seed’
[17:47:10.120]   - Field: ‘version’
[17:47:10.120]   - Field: ‘result’
[17:47:10.120]   - Field: ‘asynchronous’
[17:47:10.122]   - Field: ‘calls’
[17:47:10.122]   - Field: ‘globals’
[17:47:10.122]   - Field: ‘stdout’
[17:47:10.122]   - Field: ‘earlySignal’
[17:47:10.123]   - Field: ‘lazy’
[17:47:10.123]   - Field: ‘state’
[17:47:10.123] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.123] - Launch lazy future ...
[17:47:10.123] Packages needed by the future expression (n = 0): <none>
[17:47:10.123] Packages needed by future strategies (n = 0): <none>
[17:47:10.124] {
[17:47:10.124]     {
[17:47:10.124]         {
[17:47:10.124]             ...future.startTime <- base::Sys.time()
[17:47:10.124]             {
[17:47:10.124]                 {
[17:47:10.124]                   {
[17:47:10.124]                     {
[17:47:10.124]                       base::local({
[17:47:10.124]                         has_future <- base::requireNamespace("future", 
[17:47:10.124]                           quietly = TRUE)
[17:47:10.124]                         if (has_future) {
[17:47:10.124]                           ns <- base::getNamespace("future")
[17:47:10.124]                           version <- ns[[".package"]][["version"]]
[17:47:10.124]                           if (is.null(version)) 
[17:47:10.124]                             version <- utils::packageVersion("future")
[17:47:10.124]                         }
[17:47:10.124]                         else {
[17:47:10.124]                           version <- NULL
[17:47:10.124]                         }
[17:47:10.124]                         if (!has_future || version < "1.8.0") {
[17:47:10.124]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.124]                             "", base::R.version$version.string), 
[17:47:10.124]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.124]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.124]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.124]                               "release", "version")], collapse = " "), 
[17:47:10.124]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.124]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.124]                             info)
[17:47:10.124]                           info <- base::paste(info, collapse = "; ")
[17:47:10.124]                           if (!has_future) {
[17:47:10.124]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.124]                               info)
[17:47:10.124]                           }
[17:47:10.124]                           else {
[17:47:10.124]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.124]                               info, version)
[17:47:10.124]                           }
[17:47:10.124]                           base::stop(msg)
[17:47:10.124]                         }
[17:47:10.124]                       })
[17:47:10.124]                     }
[17:47:10.124]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.124]                     base::options(mc.cores = 1L)
[17:47:10.124]                   }
[17:47:10.124]                   ...future.strategy.old <- future::plan("list")
[17:47:10.124]                   options(future.plan = NULL)
[17:47:10.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.124]                 }
[17:47:10.124]                 ...future.workdir <- getwd()
[17:47:10.124]             }
[17:47:10.124]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.124]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.124]         }
[17:47:10.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.124]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.124]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.124]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.124]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.124]             base::names(...future.oldOptions))
[17:47:10.124]     }
[17:47:10.124]     if (FALSE) {
[17:47:10.124]     }
[17:47:10.124]     else {
[17:47:10.124]         if (TRUE) {
[17:47:10.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.124]                 open = "w")
[17:47:10.124]         }
[17:47:10.124]         else {
[17:47:10.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.124]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.124]         }
[17:47:10.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.124]             base::sink(type = "output", split = FALSE)
[17:47:10.124]             base::close(...future.stdout)
[17:47:10.124]         }, add = TRUE)
[17:47:10.124]     }
[17:47:10.124]     ...future.frame <- base::sys.nframe()
[17:47:10.124]     ...future.conditions <- base::list()
[17:47:10.124]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.124]     if (FALSE) {
[17:47:10.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.124]     }
[17:47:10.124]     ...future.result <- base::tryCatch({
[17:47:10.124]         base::withCallingHandlers({
[17:47:10.124]             ...future.value <- base::withVisible(base::local({
[17:47:10.124]                 ...future.makeSendCondition <- base::local({
[17:47:10.124]                   sendCondition <- NULL
[17:47:10.124]                   function(frame = 1L) {
[17:47:10.124]                     if (is.function(sendCondition)) 
[17:47:10.124]                       return(sendCondition)
[17:47:10.124]                     ns <- getNamespace("parallel")
[17:47:10.124]                     if (exists("sendData", mode = "function", 
[17:47:10.124]                       envir = ns)) {
[17:47:10.124]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.124]                         envir = ns)
[17:47:10.124]                       envir <- sys.frame(frame)
[17:47:10.124]                       master <- NULL
[17:47:10.124]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.124]                         !identical(envir, emptyenv())) {
[17:47:10.124]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.124]                           inherits = FALSE)) {
[17:47:10.124]                           master <- get("master", mode = "list", 
[17:47:10.124]                             envir = envir, inherits = FALSE)
[17:47:10.124]                           if (inherits(master, c("SOCKnode", 
[17:47:10.124]                             "SOCK0node"))) {
[17:47:10.124]                             sendCondition <<- function(cond) {
[17:47:10.124]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.124]                                 success = TRUE)
[17:47:10.124]                               parallel_sendData(master, data)
[17:47:10.124]                             }
[17:47:10.124]                             return(sendCondition)
[17:47:10.124]                           }
[17:47:10.124]                         }
[17:47:10.124]                         frame <- frame + 1L
[17:47:10.124]                         envir <- sys.frame(frame)
[17:47:10.124]                       }
[17:47:10.124]                     }
[17:47:10.124]                     sendCondition <<- function(cond) NULL
[17:47:10.124]                   }
[17:47:10.124]                 })
[17:47:10.124]                 withCallingHandlers({
[17:47:10.124]                   {
[17:47:10.124]                     b <- a * ii
[17:47:10.124]                     a <- 0
[17:47:10.124]                     b
[17:47:10.124]                   }
[17:47:10.124]                 }, immediateCondition = function(cond) {
[17:47:10.124]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.124]                   sendCondition(cond)
[17:47:10.124]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.124]                   {
[17:47:10.124]                     inherits <- base::inherits
[17:47:10.124]                     invokeRestart <- base::invokeRestart
[17:47:10.124]                     is.null <- base::is.null
[17:47:10.124]                     muffled <- FALSE
[17:47:10.124]                     if (inherits(cond, "message")) {
[17:47:10.124]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.124]                       if (muffled) 
[17:47:10.124]                         invokeRestart("muffleMessage")
[17:47:10.124]                     }
[17:47:10.124]                     else if (inherits(cond, "warning")) {
[17:47:10.124]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.124]                       if (muffled) 
[17:47:10.124]                         invokeRestart("muffleWarning")
[17:47:10.124]                     }
[17:47:10.124]                     else if (inherits(cond, "condition")) {
[17:47:10.124]                       if (!is.null(pattern)) {
[17:47:10.124]                         computeRestarts <- base::computeRestarts
[17:47:10.124]                         grepl <- base::grepl
[17:47:10.124]                         restarts <- computeRestarts(cond)
[17:47:10.124]                         for (restart in restarts) {
[17:47:10.124]                           name <- restart$name
[17:47:10.124]                           if (is.null(name)) 
[17:47:10.124]                             next
[17:47:10.124]                           if (!grepl(pattern, name)) 
[17:47:10.124]                             next
[17:47:10.124]                           invokeRestart(restart)
[17:47:10.124]                           muffled <- TRUE
[17:47:10.124]                           break
[17:47:10.124]                         }
[17:47:10.124]                       }
[17:47:10.124]                     }
[17:47:10.124]                     invisible(muffled)
[17:47:10.124]                   }
[17:47:10.124]                   muffleCondition(cond)
[17:47:10.124]                 })
[17:47:10.124]             }))
[17:47:10.124]             future::FutureResult(value = ...future.value$value, 
[17:47:10.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.124]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.124]                     ...future.globalenv.names))
[17:47:10.124]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.124]         }, condition = base::local({
[17:47:10.124]             c <- base::c
[17:47:10.124]             inherits <- base::inherits
[17:47:10.124]             invokeRestart <- base::invokeRestart
[17:47:10.124]             length <- base::length
[17:47:10.124]             list <- base::list
[17:47:10.124]             seq.int <- base::seq.int
[17:47:10.124]             signalCondition <- base::signalCondition
[17:47:10.124]             sys.calls <- base::sys.calls
[17:47:10.124]             `[[` <- base::`[[`
[17:47:10.124]             `+` <- base::`+`
[17:47:10.124]             `<<-` <- base::`<<-`
[17:47:10.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.124]                   3L)]
[17:47:10.124]             }
[17:47:10.124]             function(cond) {
[17:47:10.124]                 is_error <- inherits(cond, "error")
[17:47:10.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.124]                   NULL)
[17:47:10.124]                 if (is_error) {
[17:47:10.124]                   sessionInformation <- function() {
[17:47:10.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.124]                       search = base::search(), system = base::Sys.info())
[17:47:10.124]                   }
[17:47:10.124]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.124]                     cond$call), session = sessionInformation(), 
[17:47:10.124]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.124]                   signalCondition(cond)
[17:47:10.124]                 }
[17:47:10.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.124]                 "immediateCondition"))) {
[17:47:10.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.124]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.124]                   if (TRUE && !signal) {
[17:47:10.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.124]                     {
[17:47:10.124]                       inherits <- base::inherits
[17:47:10.124]                       invokeRestart <- base::invokeRestart
[17:47:10.124]                       is.null <- base::is.null
[17:47:10.124]                       muffled <- FALSE
[17:47:10.124]                       if (inherits(cond, "message")) {
[17:47:10.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.124]                         if (muffled) 
[17:47:10.124]                           invokeRestart("muffleMessage")
[17:47:10.124]                       }
[17:47:10.124]                       else if (inherits(cond, "warning")) {
[17:47:10.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.124]                         if (muffled) 
[17:47:10.124]                           invokeRestart("muffleWarning")
[17:47:10.124]                       }
[17:47:10.124]                       else if (inherits(cond, "condition")) {
[17:47:10.124]                         if (!is.null(pattern)) {
[17:47:10.124]                           computeRestarts <- base::computeRestarts
[17:47:10.124]                           grepl <- base::grepl
[17:47:10.124]                           restarts <- computeRestarts(cond)
[17:47:10.124]                           for (restart in restarts) {
[17:47:10.124]                             name <- restart$name
[17:47:10.124]                             if (is.null(name)) 
[17:47:10.124]                               next
[17:47:10.124]                             if (!grepl(pattern, name)) 
[17:47:10.124]                               next
[17:47:10.124]                             invokeRestart(restart)
[17:47:10.124]                             muffled <- TRUE
[17:47:10.124]                             break
[17:47:10.124]                           }
[17:47:10.124]                         }
[17:47:10.124]                       }
[17:47:10.124]                       invisible(muffled)
[17:47:10.124]                     }
[17:47:10.124]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.124]                   }
[17:47:10.124]                 }
[17:47:10.124]                 else {
[17:47:10.124]                   if (TRUE) {
[17:47:10.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.124]                     {
[17:47:10.124]                       inherits <- base::inherits
[17:47:10.124]                       invokeRestart <- base::invokeRestart
[17:47:10.124]                       is.null <- base::is.null
[17:47:10.124]                       muffled <- FALSE
[17:47:10.124]                       if (inherits(cond, "message")) {
[17:47:10.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.124]                         if (muffled) 
[17:47:10.124]                           invokeRestart("muffleMessage")
[17:47:10.124]                       }
[17:47:10.124]                       else if (inherits(cond, "warning")) {
[17:47:10.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.124]                         if (muffled) 
[17:47:10.124]                           invokeRestart("muffleWarning")
[17:47:10.124]                       }
[17:47:10.124]                       else if (inherits(cond, "condition")) {
[17:47:10.124]                         if (!is.null(pattern)) {
[17:47:10.124]                           computeRestarts <- base::computeRestarts
[17:47:10.124]                           grepl <- base::grepl
[17:47:10.124]                           restarts <- computeRestarts(cond)
[17:47:10.124]                           for (restart in restarts) {
[17:47:10.124]                             name <- restart$name
[17:47:10.124]                             if (is.null(name)) 
[17:47:10.124]                               next
[17:47:10.124]                             if (!grepl(pattern, name)) 
[17:47:10.124]                               next
[17:47:10.124]                             invokeRestart(restart)
[17:47:10.124]                             muffled <- TRUE
[17:47:10.124]                             break
[17:47:10.124]                           }
[17:47:10.124]                         }
[17:47:10.124]                       }
[17:47:10.124]                       invisible(muffled)
[17:47:10.124]                     }
[17:47:10.124]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.124]                   }
[17:47:10.124]                 }
[17:47:10.124]             }
[17:47:10.124]         }))
[17:47:10.124]     }, error = function(ex) {
[17:47:10.124]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.124]                 ...future.rng), started = ...future.startTime, 
[17:47:10.124]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.124]             version = "1.8"), class = "FutureResult")
[17:47:10.124]     }, finally = {
[17:47:10.124]         if (!identical(...future.workdir, getwd())) 
[17:47:10.124]             setwd(...future.workdir)
[17:47:10.124]         {
[17:47:10.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.124]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.124]             }
[17:47:10.124]             base::options(...future.oldOptions)
[17:47:10.124]             if (.Platform$OS.type == "windows") {
[17:47:10.124]                 old_names <- names(...future.oldEnvVars)
[17:47:10.124]                 envs <- base::Sys.getenv()
[17:47:10.124]                 names <- names(envs)
[17:47:10.124]                 common <- intersect(names, old_names)
[17:47:10.124]                 added <- setdiff(names, old_names)
[17:47:10.124]                 removed <- setdiff(old_names, names)
[17:47:10.124]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.124]                   envs[common]]
[17:47:10.124]                 NAMES <- toupper(changed)
[17:47:10.124]                 args <- list()
[17:47:10.124]                 for (kk in seq_along(NAMES)) {
[17:47:10.124]                   name <- changed[[kk]]
[17:47:10.124]                   NAME <- NAMES[[kk]]
[17:47:10.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.124]                     next
[17:47:10.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.124]                 }
[17:47:10.124]                 NAMES <- toupper(added)
[17:47:10.124]                 for (kk in seq_along(NAMES)) {
[17:47:10.124]                   name <- added[[kk]]
[17:47:10.124]                   NAME <- NAMES[[kk]]
[17:47:10.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.124]                     next
[17:47:10.124]                   args[[name]] <- ""
[17:47:10.124]                 }
[17:47:10.124]                 NAMES <- toupper(removed)
[17:47:10.124]                 for (kk in seq_along(NAMES)) {
[17:47:10.124]                   name <- removed[[kk]]
[17:47:10.124]                   NAME <- NAMES[[kk]]
[17:47:10.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.124]                     next
[17:47:10.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.124]                 }
[17:47:10.124]                 if (length(args) > 0) 
[17:47:10.124]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.124]             }
[17:47:10.124]             else {
[17:47:10.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.124]             }
[17:47:10.124]             {
[17:47:10.124]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.124]                   0L) {
[17:47:10.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.124]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.124]                   base::options(opts)
[17:47:10.124]                 }
[17:47:10.124]                 {
[17:47:10.124]                   {
[17:47:10.124]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.124]                     NULL
[17:47:10.124]                   }
[17:47:10.124]                   options(future.plan = NULL)
[17:47:10.124]                   if (is.na(NA_character_)) 
[17:47:10.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.124]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.124]                     .init = FALSE)
[17:47:10.124]                 }
[17:47:10.124]             }
[17:47:10.124]         }
[17:47:10.124]     })
[17:47:10.124]     if (TRUE) {
[17:47:10.124]         base::sink(type = "output", split = FALSE)
[17:47:10.124]         if (TRUE) {
[17:47:10.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.124]         }
[17:47:10.124]         else {
[17:47:10.124]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.124]         }
[17:47:10.124]         base::close(...future.stdout)
[17:47:10.124]         ...future.stdout <- NULL
[17:47:10.124]     }
[17:47:10.124]     ...future.result$conditions <- ...future.conditions
[17:47:10.124]     ...future.result$finished <- base::Sys.time()
[17:47:10.124]     ...future.result
[17:47:10.124] }
[17:47:10.126] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[17:47:10.126] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:47:10.127] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:47:10.127] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:47:10.127] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:47:10.127] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[17:47:10.128] MultisessionFuture started
[17:47:10.128] - Launch lazy future ... done
[17:47:10.128] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.128] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.129] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.130] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.130] Searching for globals ... DONE
[17:47:10.131] Resolving globals: TRUE
[17:47:10.131] Resolving any globals that are futures ...
[17:47:10.131] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.131] Resolving any globals that are futures ... DONE
[17:47:10.131] Resolving futures part of globals (recursively) ...
[17:47:10.131] resolve() on list ...
[17:47:10.131]  recursive: 99
[17:47:10.132]  length: 2
[17:47:10.132]  elements: ‘a’, ‘ii’
[17:47:10.132]  length: 1 (resolved future 1)
[17:47:10.132]  length: 0 (resolved future 2)
[17:47:10.132] resolve() on list ... DONE
[17:47:10.132] - globals: [2] ‘a’, ‘ii’
[17:47:10.132] Resolving futures part of globals (recursively) ... DONE
[17:47:10.132] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:10.133] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:10.133] - globals: [2] ‘a’, ‘ii’
[17:47:10.133] 
[17:47:10.133] getGlobalsAndPackages() ... DONE
[17:47:10.133] run() for ‘Future’ ...
[17:47:10.133] - state: ‘created’
[17:47:10.133] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.147] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.147]   - Field: ‘node’
[17:47:10.147]   - Field: ‘label’
[17:47:10.148]   - Field: ‘local’
[17:47:10.148]   - Field: ‘owner’
[17:47:10.148]   - Field: ‘envir’
[17:47:10.148]   - Field: ‘workers’
[17:47:10.148]   - Field: ‘packages’
[17:47:10.148]   - Field: ‘gc’
[17:47:10.148]   - Field: ‘conditions’
[17:47:10.148]   - Field: ‘persistent’
[17:47:10.148]   - Field: ‘expr’
[17:47:10.148]   - Field: ‘uuid’
[17:47:10.148]   - Field: ‘seed’
[17:47:10.149]   - Field: ‘version’
[17:47:10.149]   - Field: ‘result’
[17:47:10.149]   - Field: ‘asynchronous’
[17:47:10.149]   - Field: ‘calls’
[17:47:10.149]   - Field: ‘globals’
[17:47:10.149]   - Field: ‘stdout’
[17:47:10.149]   - Field: ‘earlySignal’
[17:47:10.149]   - Field: ‘lazy’
[17:47:10.149]   - Field: ‘state’
[17:47:10.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.149] - Launch lazy future ...
[17:47:10.150] Packages needed by the future expression (n = 0): <none>
[17:47:10.150] Packages needed by future strategies (n = 0): <none>
[17:47:10.150] {
[17:47:10.150]     {
[17:47:10.150]         {
[17:47:10.150]             ...future.startTime <- base::Sys.time()
[17:47:10.150]             {
[17:47:10.150]                 {
[17:47:10.150]                   {
[17:47:10.150]                     {
[17:47:10.150]                       base::local({
[17:47:10.150]                         has_future <- base::requireNamespace("future", 
[17:47:10.150]                           quietly = TRUE)
[17:47:10.150]                         if (has_future) {
[17:47:10.150]                           ns <- base::getNamespace("future")
[17:47:10.150]                           version <- ns[[".package"]][["version"]]
[17:47:10.150]                           if (is.null(version)) 
[17:47:10.150]                             version <- utils::packageVersion("future")
[17:47:10.150]                         }
[17:47:10.150]                         else {
[17:47:10.150]                           version <- NULL
[17:47:10.150]                         }
[17:47:10.150]                         if (!has_future || version < "1.8.0") {
[17:47:10.150]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.150]                             "", base::R.version$version.string), 
[17:47:10.150]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.150]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.150]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.150]                               "release", "version")], collapse = " "), 
[17:47:10.150]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.150]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.150]                             info)
[17:47:10.150]                           info <- base::paste(info, collapse = "; ")
[17:47:10.150]                           if (!has_future) {
[17:47:10.150]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.150]                               info)
[17:47:10.150]                           }
[17:47:10.150]                           else {
[17:47:10.150]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.150]                               info, version)
[17:47:10.150]                           }
[17:47:10.150]                           base::stop(msg)
[17:47:10.150]                         }
[17:47:10.150]                       })
[17:47:10.150]                     }
[17:47:10.150]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.150]                     base::options(mc.cores = 1L)
[17:47:10.150]                   }
[17:47:10.150]                   ...future.strategy.old <- future::plan("list")
[17:47:10.150]                   options(future.plan = NULL)
[17:47:10.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.150]                 }
[17:47:10.150]                 ...future.workdir <- getwd()
[17:47:10.150]             }
[17:47:10.150]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.150]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.150]         }
[17:47:10.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.150]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.150]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.150]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.150]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.150]             base::names(...future.oldOptions))
[17:47:10.150]     }
[17:47:10.150]     if (FALSE) {
[17:47:10.150]     }
[17:47:10.150]     else {
[17:47:10.150]         if (TRUE) {
[17:47:10.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.150]                 open = "w")
[17:47:10.150]         }
[17:47:10.150]         else {
[17:47:10.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.150]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.150]         }
[17:47:10.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.150]             base::sink(type = "output", split = FALSE)
[17:47:10.150]             base::close(...future.stdout)
[17:47:10.150]         }, add = TRUE)
[17:47:10.150]     }
[17:47:10.150]     ...future.frame <- base::sys.nframe()
[17:47:10.150]     ...future.conditions <- base::list()
[17:47:10.150]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.150]     if (FALSE) {
[17:47:10.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.150]     }
[17:47:10.150]     ...future.result <- base::tryCatch({
[17:47:10.150]         base::withCallingHandlers({
[17:47:10.150]             ...future.value <- base::withVisible(base::local({
[17:47:10.150]                 ...future.makeSendCondition <- base::local({
[17:47:10.150]                   sendCondition <- NULL
[17:47:10.150]                   function(frame = 1L) {
[17:47:10.150]                     if (is.function(sendCondition)) 
[17:47:10.150]                       return(sendCondition)
[17:47:10.150]                     ns <- getNamespace("parallel")
[17:47:10.150]                     if (exists("sendData", mode = "function", 
[17:47:10.150]                       envir = ns)) {
[17:47:10.150]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.150]                         envir = ns)
[17:47:10.150]                       envir <- sys.frame(frame)
[17:47:10.150]                       master <- NULL
[17:47:10.150]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.150]                         !identical(envir, emptyenv())) {
[17:47:10.150]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.150]                           inherits = FALSE)) {
[17:47:10.150]                           master <- get("master", mode = "list", 
[17:47:10.150]                             envir = envir, inherits = FALSE)
[17:47:10.150]                           if (inherits(master, c("SOCKnode", 
[17:47:10.150]                             "SOCK0node"))) {
[17:47:10.150]                             sendCondition <<- function(cond) {
[17:47:10.150]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.150]                                 success = TRUE)
[17:47:10.150]                               parallel_sendData(master, data)
[17:47:10.150]                             }
[17:47:10.150]                             return(sendCondition)
[17:47:10.150]                           }
[17:47:10.150]                         }
[17:47:10.150]                         frame <- frame + 1L
[17:47:10.150]                         envir <- sys.frame(frame)
[17:47:10.150]                       }
[17:47:10.150]                     }
[17:47:10.150]                     sendCondition <<- function(cond) NULL
[17:47:10.150]                   }
[17:47:10.150]                 })
[17:47:10.150]                 withCallingHandlers({
[17:47:10.150]                   {
[17:47:10.150]                     b <- a * ii
[17:47:10.150]                     a <- 0
[17:47:10.150]                     b
[17:47:10.150]                   }
[17:47:10.150]                 }, immediateCondition = function(cond) {
[17:47:10.150]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.150]                   sendCondition(cond)
[17:47:10.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.150]                   {
[17:47:10.150]                     inherits <- base::inherits
[17:47:10.150]                     invokeRestart <- base::invokeRestart
[17:47:10.150]                     is.null <- base::is.null
[17:47:10.150]                     muffled <- FALSE
[17:47:10.150]                     if (inherits(cond, "message")) {
[17:47:10.150]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.150]                       if (muffled) 
[17:47:10.150]                         invokeRestart("muffleMessage")
[17:47:10.150]                     }
[17:47:10.150]                     else if (inherits(cond, "warning")) {
[17:47:10.150]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.150]                       if (muffled) 
[17:47:10.150]                         invokeRestart("muffleWarning")
[17:47:10.150]                     }
[17:47:10.150]                     else if (inherits(cond, "condition")) {
[17:47:10.150]                       if (!is.null(pattern)) {
[17:47:10.150]                         computeRestarts <- base::computeRestarts
[17:47:10.150]                         grepl <- base::grepl
[17:47:10.150]                         restarts <- computeRestarts(cond)
[17:47:10.150]                         for (restart in restarts) {
[17:47:10.150]                           name <- restart$name
[17:47:10.150]                           if (is.null(name)) 
[17:47:10.150]                             next
[17:47:10.150]                           if (!grepl(pattern, name)) 
[17:47:10.150]                             next
[17:47:10.150]                           invokeRestart(restart)
[17:47:10.150]                           muffled <- TRUE
[17:47:10.150]                           break
[17:47:10.150]                         }
[17:47:10.150]                       }
[17:47:10.150]                     }
[17:47:10.150]                     invisible(muffled)
[17:47:10.150]                   }
[17:47:10.150]                   muffleCondition(cond)
[17:47:10.150]                 })
[17:47:10.150]             }))
[17:47:10.150]             future::FutureResult(value = ...future.value$value, 
[17:47:10.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.150]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.150]                     ...future.globalenv.names))
[17:47:10.150]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.150]         }, condition = base::local({
[17:47:10.150]             c <- base::c
[17:47:10.150]             inherits <- base::inherits
[17:47:10.150]             invokeRestart <- base::invokeRestart
[17:47:10.150]             length <- base::length
[17:47:10.150]             list <- base::list
[17:47:10.150]             seq.int <- base::seq.int
[17:47:10.150]             signalCondition <- base::signalCondition
[17:47:10.150]             sys.calls <- base::sys.calls
[17:47:10.150]             `[[` <- base::`[[`
[17:47:10.150]             `+` <- base::`+`
[17:47:10.150]             `<<-` <- base::`<<-`
[17:47:10.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.150]                   3L)]
[17:47:10.150]             }
[17:47:10.150]             function(cond) {
[17:47:10.150]                 is_error <- inherits(cond, "error")
[17:47:10.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.150]                   NULL)
[17:47:10.150]                 if (is_error) {
[17:47:10.150]                   sessionInformation <- function() {
[17:47:10.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.150]                       search = base::search(), system = base::Sys.info())
[17:47:10.150]                   }
[17:47:10.150]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.150]                     cond$call), session = sessionInformation(), 
[17:47:10.150]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.150]                   signalCondition(cond)
[17:47:10.150]                 }
[17:47:10.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.150]                 "immediateCondition"))) {
[17:47:10.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.150]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.150]                   if (TRUE && !signal) {
[17:47:10.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.150]                     {
[17:47:10.150]                       inherits <- base::inherits
[17:47:10.150]                       invokeRestart <- base::invokeRestart
[17:47:10.150]                       is.null <- base::is.null
[17:47:10.150]                       muffled <- FALSE
[17:47:10.150]                       if (inherits(cond, "message")) {
[17:47:10.150]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.150]                         if (muffled) 
[17:47:10.150]                           invokeRestart("muffleMessage")
[17:47:10.150]                       }
[17:47:10.150]                       else if (inherits(cond, "warning")) {
[17:47:10.150]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.150]                         if (muffled) 
[17:47:10.150]                           invokeRestart("muffleWarning")
[17:47:10.150]                       }
[17:47:10.150]                       else if (inherits(cond, "condition")) {
[17:47:10.150]                         if (!is.null(pattern)) {
[17:47:10.150]                           computeRestarts <- base::computeRestarts
[17:47:10.150]                           grepl <- base::grepl
[17:47:10.150]                           restarts <- computeRestarts(cond)
[17:47:10.150]                           for (restart in restarts) {
[17:47:10.150]                             name <- restart$name
[17:47:10.150]                             if (is.null(name)) 
[17:47:10.150]                               next
[17:47:10.150]                             if (!grepl(pattern, name)) 
[17:47:10.150]                               next
[17:47:10.150]                             invokeRestart(restart)
[17:47:10.150]                             muffled <- TRUE
[17:47:10.150]                             break
[17:47:10.150]                           }
[17:47:10.150]                         }
[17:47:10.150]                       }
[17:47:10.150]                       invisible(muffled)
[17:47:10.150]                     }
[17:47:10.150]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.150]                   }
[17:47:10.150]                 }
[17:47:10.150]                 else {
[17:47:10.150]                   if (TRUE) {
[17:47:10.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.150]                     {
[17:47:10.150]                       inherits <- base::inherits
[17:47:10.150]                       invokeRestart <- base::invokeRestart
[17:47:10.150]                       is.null <- base::is.null
[17:47:10.150]                       muffled <- FALSE
[17:47:10.150]                       if (inherits(cond, "message")) {
[17:47:10.150]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.150]                         if (muffled) 
[17:47:10.150]                           invokeRestart("muffleMessage")
[17:47:10.150]                       }
[17:47:10.150]                       else if (inherits(cond, "warning")) {
[17:47:10.150]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.150]                         if (muffled) 
[17:47:10.150]                           invokeRestart("muffleWarning")
[17:47:10.150]                       }
[17:47:10.150]                       else if (inherits(cond, "condition")) {
[17:47:10.150]                         if (!is.null(pattern)) {
[17:47:10.150]                           computeRestarts <- base::computeRestarts
[17:47:10.150]                           grepl <- base::grepl
[17:47:10.150]                           restarts <- computeRestarts(cond)
[17:47:10.150]                           for (restart in restarts) {
[17:47:10.150]                             name <- restart$name
[17:47:10.150]                             if (is.null(name)) 
[17:47:10.150]                               next
[17:47:10.150]                             if (!grepl(pattern, name)) 
[17:47:10.150]                               next
[17:47:10.150]                             invokeRestart(restart)
[17:47:10.150]                             muffled <- TRUE
[17:47:10.150]                             break
[17:47:10.150]                           }
[17:47:10.150]                         }
[17:47:10.150]                       }
[17:47:10.150]                       invisible(muffled)
[17:47:10.150]                     }
[17:47:10.150]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.150]                   }
[17:47:10.150]                 }
[17:47:10.150]             }
[17:47:10.150]         }))
[17:47:10.150]     }, error = function(ex) {
[17:47:10.150]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.150]                 ...future.rng), started = ...future.startTime, 
[17:47:10.150]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.150]             version = "1.8"), class = "FutureResult")
[17:47:10.150]     }, finally = {
[17:47:10.150]         if (!identical(...future.workdir, getwd())) 
[17:47:10.150]             setwd(...future.workdir)
[17:47:10.150]         {
[17:47:10.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.150]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.150]             }
[17:47:10.150]             base::options(...future.oldOptions)
[17:47:10.150]             if (.Platform$OS.type == "windows") {
[17:47:10.150]                 old_names <- names(...future.oldEnvVars)
[17:47:10.150]                 envs <- base::Sys.getenv()
[17:47:10.150]                 names <- names(envs)
[17:47:10.150]                 common <- intersect(names, old_names)
[17:47:10.150]                 added <- setdiff(names, old_names)
[17:47:10.150]                 removed <- setdiff(old_names, names)
[17:47:10.150]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.150]                   envs[common]]
[17:47:10.150]                 NAMES <- toupper(changed)
[17:47:10.150]                 args <- list()
[17:47:10.150]                 for (kk in seq_along(NAMES)) {
[17:47:10.150]                   name <- changed[[kk]]
[17:47:10.150]                   NAME <- NAMES[[kk]]
[17:47:10.150]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.150]                     next
[17:47:10.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.150]                 }
[17:47:10.150]                 NAMES <- toupper(added)
[17:47:10.150]                 for (kk in seq_along(NAMES)) {
[17:47:10.150]                   name <- added[[kk]]
[17:47:10.150]                   NAME <- NAMES[[kk]]
[17:47:10.150]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.150]                     next
[17:47:10.150]                   args[[name]] <- ""
[17:47:10.150]                 }
[17:47:10.150]                 NAMES <- toupper(removed)
[17:47:10.150]                 for (kk in seq_along(NAMES)) {
[17:47:10.150]                   name <- removed[[kk]]
[17:47:10.150]                   NAME <- NAMES[[kk]]
[17:47:10.150]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.150]                     next
[17:47:10.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.150]                 }
[17:47:10.150]                 if (length(args) > 0) 
[17:47:10.150]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.150]             }
[17:47:10.150]             else {
[17:47:10.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.150]             }
[17:47:10.150]             {
[17:47:10.150]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.150]                   0L) {
[17:47:10.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.150]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.150]                   base::options(opts)
[17:47:10.150]                 }
[17:47:10.150]                 {
[17:47:10.150]                   {
[17:47:10.150]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.150]                     NULL
[17:47:10.150]                   }
[17:47:10.150]                   options(future.plan = NULL)
[17:47:10.150]                   if (is.na(NA_character_)) 
[17:47:10.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.150]                     .init = FALSE)
[17:47:10.150]                 }
[17:47:10.150]             }
[17:47:10.150]         }
[17:47:10.150]     })
[17:47:10.150]     if (TRUE) {
[17:47:10.150]         base::sink(type = "output", split = FALSE)
[17:47:10.150]         if (TRUE) {
[17:47:10.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.150]         }
[17:47:10.150]         else {
[17:47:10.150]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.150]         }
[17:47:10.150]         base::close(...future.stdout)
[17:47:10.150]         ...future.stdout <- NULL
[17:47:10.150]     }
[17:47:10.150]     ...future.result$conditions <- ...future.conditions
[17:47:10.150]     ...future.result$finished <- base::Sys.time()
[17:47:10.150]     ...future.result
[17:47:10.150] }
[17:47:10.152] Poll #1 (0): usedNodes() = 2, workers = 2
[17:47:10.163] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.163] - Validating connection of MultisessionFuture
[17:47:10.164] - received message: FutureResult
[17:47:10.164] - Received FutureResult
[17:47:10.164] - Erased future from FutureRegistry
[17:47:10.164] result() for ClusterFuture ...
[17:47:10.164] - result already collected: FutureResult
[17:47:10.164] result() for ClusterFuture ... done
[17:47:10.164] signalConditions() ...
[17:47:10.164]  - include = ‘immediateCondition’
[17:47:10.164]  - exclude = 
[17:47:10.164]  - resignal = FALSE
[17:47:10.164]  - Number of conditions: 1
[17:47:10.165] signalConditions() ... done
[17:47:10.165] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.165] result() for ClusterFuture ...
[17:47:10.165] - result already collected: FutureResult
[17:47:10.165] result() for ClusterFuture ... done
[17:47:10.165] result() for ClusterFuture ...
[17:47:10.165] - result already collected: FutureResult
[17:47:10.165] result() for ClusterFuture ... done
[17:47:10.165] signalConditions() ...
[17:47:10.165]  - include = ‘immediateCondition’
[17:47:10.165]  - exclude = 
[17:47:10.165]  - resignal = FALSE
[17:47:10.166]  - Number of conditions: 1
[17:47:10.166] signalConditions() ... done
[17:47:10.166] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:47:10.166] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:47:10.167] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:47:10.167] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:47:10.167] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:47:10.167] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:47:10.168] MultisessionFuture started
[17:47:10.168] - Launch lazy future ... done
[17:47:10.168] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.169] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.169] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.171] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.171] Searching for globals ... DONE
[17:47:10.171] Resolving globals: TRUE
[17:47:10.171] Resolving any globals that are futures ...
[17:47:10.171] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.171] Resolving any globals that are futures ... DONE
[17:47:10.171] Resolving futures part of globals (recursively) ...
[17:47:10.172] resolve() on list ...
[17:47:10.172]  recursive: 99
[17:47:10.172]  length: 2
[17:47:10.172]  elements: ‘a’, ‘ii’
[17:47:10.172]  length: 1 (resolved future 1)
[17:47:10.172]  length: 0 (resolved future 2)
[17:47:10.172] resolve() on list ... DONE
[17:47:10.172] - globals: [2] ‘a’, ‘ii’
[17:47:10.172] Resolving futures part of globals (recursively) ... DONE
[17:47:10.173] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:10.173] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:10.173] - globals: [2] ‘a’, ‘ii’
[17:47:10.173] 
[17:47:10.173] getGlobalsAndPackages() ... DONE
[17:47:10.174] run() for ‘Future’ ...
[17:47:10.174] - state: ‘created’
[17:47:10.174] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.187]   - Field: ‘node’
[17:47:10.188]   - Field: ‘label’
[17:47:10.188]   - Field: ‘local’
[17:47:10.188]   - Field: ‘owner’
[17:47:10.188]   - Field: ‘envir’
[17:47:10.188]   - Field: ‘workers’
[17:47:10.188]   - Field: ‘packages’
[17:47:10.188]   - Field: ‘gc’
[17:47:10.188]   - Field: ‘conditions’
[17:47:10.188]   - Field: ‘persistent’
[17:47:10.188]   - Field: ‘expr’
[17:47:10.188]   - Field: ‘uuid’
[17:47:10.189]   - Field: ‘seed’
[17:47:10.189]   - Field: ‘version’
[17:47:10.189]   - Field: ‘result’
[17:47:10.189]   - Field: ‘asynchronous’
[17:47:10.189]   - Field: ‘calls’
[17:47:10.189]   - Field: ‘globals’
[17:47:10.189]   - Field: ‘stdout’
[17:47:10.189]   - Field: ‘earlySignal’
[17:47:10.189]   - Field: ‘lazy’
[17:47:10.189]   - Field: ‘state’
[17:47:10.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.190] - Launch lazy future ...
[17:47:10.190] Packages needed by the future expression (n = 0): <none>
[17:47:10.190] Packages needed by future strategies (n = 0): <none>
[17:47:10.190] {
[17:47:10.190]     {
[17:47:10.190]         {
[17:47:10.190]             ...future.startTime <- base::Sys.time()
[17:47:10.190]             {
[17:47:10.190]                 {
[17:47:10.190]                   {
[17:47:10.190]                     {
[17:47:10.190]                       base::local({
[17:47:10.190]                         has_future <- base::requireNamespace("future", 
[17:47:10.190]                           quietly = TRUE)
[17:47:10.190]                         if (has_future) {
[17:47:10.190]                           ns <- base::getNamespace("future")
[17:47:10.190]                           version <- ns[[".package"]][["version"]]
[17:47:10.190]                           if (is.null(version)) 
[17:47:10.190]                             version <- utils::packageVersion("future")
[17:47:10.190]                         }
[17:47:10.190]                         else {
[17:47:10.190]                           version <- NULL
[17:47:10.190]                         }
[17:47:10.190]                         if (!has_future || version < "1.8.0") {
[17:47:10.190]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.190]                             "", base::R.version$version.string), 
[17:47:10.190]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.190]                               "release", "version")], collapse = " "), 
[17:47:10.190]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.190]                             info)
[17:47:10.190]                           info <- base::paste(info, collapse = "; ")
[17:47:10.190]                           if (!has_future) {
[17:47:10.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.190]                               info)
[17:47:10.190]                           }
[17:47:10.190]                           else {
[17:47:10.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.190]                               info, version)
[17:47:10.190]                           }
[17:47:10.190]                           base::stop(msg)
[17:47:10.190]                         }
[17:47:10.190]                       })
[17:47:10.190]                     }
[17:47:10.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.190]                     base::options(mc.cores = 1L)
[17:47:10.190]                   }
[17:47:10.190]                   ...future.strategy.old <- future::plan("list")
[17:47:10.190]                   options(future.plan = NULL)
[17:47:10.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.190]                 }
[17:47:10.190]                 ...future.workdir <- getwd()
[17:47:10.190]             }
[17:47:10.190]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.190]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.190]         }
[17:47:10.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.190]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.190]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.190]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.190]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.190]             base::names(...future.oldOptions))
[17:47:10.190]     }
[17:47:10.190]     if (FALSE) {
[17:47:10.190]     }
[17:47:10.190]     else {
[17:47:10.190]         if (TRUE) {
[17:47:10.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.190]                 open = "w")
[17:47:10.190]         }
[17:47:10.190]         else {
[17:47:10.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.190]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.190]         }
[17:47:10.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.190]             base::sink(type = "output", split = FALSE)
[17:47:10.190]             base::close(...future.stdout)
[17:47:10.190]         }, add = TRUE)
[17:47:10.190]     }
[17:47:10.190]     ...future.frame <- base::sys.nframe()
[17:47:10.190]     ...future.conditions <- base::list()
[17:47:10.190]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.190]     if (FALSE) {
[17:47:10.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.190]     }
[17:47:10.190]     ...future.result <- base::tryCatch({
[17:47:10.190]         base::withCallingHandlers({
[17:47:10.190]             ...future.value <- base::withVisible(base::local({
[17:47:10.190]                 ...future.makeSendCondition <- base::local({
[17:47:10.190]                   sendCondition <- NULL
[17:47:10.190]                   function(frame = 1L) {
[17:47:10.190]                     if (is.function(sendCondition)) 
[17:47:10.190]                       return(sendCondition)
[17:47:10.190]                     ns <- getNamespace("parallel")
[17:47:10.190]                     if (exists("sendData", mode = "function", 
[17:47:10.190]                       envir = ns)) {
[17:47:10.190]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.190]                         envir = ns)
[17:47:10.190]                       envir <- sys.frame(frame)
[17:47:10.190]                       master <- NULL
[17:47:10.190]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.190]                         !identical(envir, emptyenv())) {
[17:47:10.190]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.190]                           inherits = FALSE)) {
[17:47:10.190]                           master <- get("master", mode = "list", 
[17:47:10.190]                             envir = envir, inherits = FALSE)
[17:47:10.190]                           if (inherits(master, c("SOCKnode", 
[17:47:10.190]                             "SOCK0node"))) {
[17:47:10.190]                             sendCondition <<- function(cond) {
[17:47:10.190]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.190]                                 success = TRUE)
[17:47:10.190]                               parallel_sendData(master, data)
[17:47:10.190]                             }
[17:47:10.190]                             return(sendCondition)
[17:47:10.190]                           }
[17:47:10.190]                         }
[17:47:10.190]                         frame <- frame + 1L
[17:47:10.190]                         envir <- sys.frame(frame)
[17:47:10.190]                       }
[17:47:10.190]                     }
[17:47:10.190]                     sendCondition <<- function(cond) NULL
[17:47:10.190]                   }
[17:47:10.190]                 })
[17:47:10.190]                 withCallingHandlers({
[17:47:10.190]                   {
[17:47:10.190]                     b <- a * ii
[17:47:10.190]                     a <- 0
[17:47:10.190]                     b
[17:47:10.190]                   }
[17:47:10.190]                 }, immediateCondition = function(cond) {
[17:47:10.190]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.190]                   sendCondition(cond)
[17:47:10.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.190]                   {
[17:47:10.190]                     inherits <- base::inherits
[17:47:10.190]                     invokeRestart <- base::invokeRestart
[17:47:10.190]                     is.null <- base::is.null
[17:47:10.190]                     muffled <- FALSE
[17:47:10.190]                     if (inherits(cond, "message")) {
[17:47:10.190]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.190]                       if (muffled) 
[17:47:10.190]                         invokeRestart("muffleMessage")
[17:47:10.190]                     }
[17:47:10.190]                     else if (inherits(cond, "warning")) {
[17:47:10.190]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.190]                       if (muffled) 
[17:47:10.190]                         invokeRestart("muffleWarning")
[17:47:10.190]                     }
[17:47:10.190]                     else if (inherits(cond, "condition")) {
[17:47:10.190]                       if (!is.null(pattern)) {
[17:47:10.190]                         computeRestarts <- base::computeRestarts
[17:47:10.190]                         grepl <- base::grepl
[17:47:10.190]                         restarts <- computeRestarts(cond)
[17:47:10.190]                         for (restart in restarts) {
[17:47:10.190]                           name <- restart$name
[17:47:10.190]                           if (is.null(name)) 
[17:47:10.190]                             next
[17:47:10.190]                           if (!grepl(pattern, name)) 
[17:47:10.190]                             next
[17:47:10.190]                           invokeRestart(restart)
[17:47:10.190]                           muffled <- TRUE
[17:47:10.190]                           break
[17:47:10.190]                         }
[17:47:10.190]                       }
[17:47:10.190]                     }
[17:47:10.190]                     invisible(muffled)
[17:47:10.190]                   }
[17:47:10.190]                   muffleCondition(cond)
[17:47:10.190]                 })
[17:47:10.190]             }))
[17:47:10.190]             future::FutureResult(value = ...future.value$value, 
[17:47:10.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.190]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.190]                     ...future.globalenv.names))
[17:47:10.190]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.190]         }, condition = base::local({
[17:47:10.190]             c <- base::c
[17:47:10.190]             inherits <- base::inherits
[17:47:10.190]             invokeRestart <- base::invokeRestart
[17:47:10.190]             length <- base::length
[17:47:10.190]             list <- base::list
[17:47:10.190]             seq.int <- base::seq.int
[17:47:10.190]             signalCondition <- base::signalCondition
[17:47:10.190]             sys.calls <- base::sys.calls
[17:47:10.190]             `[[` <- base::`[[`
[17:47:10.190]             `+` <- base::`+`
[17:47:10.190]             `<<-` <- base::`<<-`
[17:47:10.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.190]                   3L)]
[17:47:10.190]             }
[17:47:10.190]             function(cond) {
[17:47:10.190]                 is_error <- inherits(cond, "error")
[17:47:10.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.190]                   NULL)
[17:47:10.190]                 if (is_error) {
[17:47:10.190]                   sessionInformation <- function() {
[17:47:10.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.190]                       search = base::search(), system = base::Sys.info())
[17:47:10.190]                   }
[17:47:10.190]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.190]                     cond$call), session = sessionInformation(), 
[17:47:10.190]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.190]                   signalCondition(cond)
[17:47:10.190]                 }
[17:47:10.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.190]                 "immediateCondition"))) {
[17:47:10.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.190]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.190]                   if (TRUE && !signal) {
[17:47:10.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.190]                     {
[17:47:10.190]                       inherits <- base::inherits
[17:47:10.190]                       invokeRestart <- base::invokeRestart
[17:47:10.190]                       is.null <- base::is.null
[17:47:10.190]                       muffled <- FALSE
[17:47:10.190]                       if (inherits(cond, "message")) {
[17:47:10.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.190]                         if (muffled) 
[17:47:10.190]                           invokeRestart("muffleMessage")
[17:47:10.190]                       }
[17:47:10.190]                       else if (inherits(cond, "warning")) {
[17:47:10.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.190]                         if (muffled) 
[17:47:10.190]                           invokeRestart("muffleWarning")
[17:47:10.190]                       }
[17:47:10.190]                       else if (inherits(cond, "condition")) {
[17:47:10.190]                         if (!is.null(pattern)) {
[17:47:10.190]                           computeRestarts <- base::computeRestarts
[17:47:10.190]                           grepl <- base::grepl
[17:47:10.190]                           restarts <- computeRestarts(cond)
[17:47:10.190]                           for (restart in restarts) {
[17:47:10.190]                             name <- restart$name
[17:47:10.190]                             if (is.null(name)) 
[17:47:10.190]                               next
[17:47:10.190]                             if (!grepl(pattern, name)) 
[17:47:10.190]                               next
[17:47:10.190]                             invokeRestart(restart)
[17:47:10.190]                             muffled <- TRUE
[17:47:10.190]                             break
[17:47:10.190]                           }
[17:47:10.190]                         }
[17:47:10.190]                       }
[17:47:10.190]                       invisible(muffled)
[17:47:10.190]                     }
[17:47:10.190]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.190]                   }
[17:47:10.190]                 }
[17:47:10.190]                 else {
[17:47:10.190]                   if (TRUE) {
[17:47:10.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.190]                     {
[17:47:10.190]                       inherits <- base::inherits
[17:47:10.190]                       invokeRestart <- base::invokeRestart
[17:47:10.190]                       is.null <- base::is.null
[17:47:10.190]                       muffled <- FALSE
[17:47:10.190]                       if (inherits(cond, "message")) {
[17:47:10.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.190]                         if (muffled) 
[17:47:10.190]                           invokeRestart("muffleMessage")
[17:47:10.190]                       }
[17:47:10.190]                       else if (inherits(cond, "warning")) {
[17:47:10.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.190]                         if (muffled) 
[17:47:10.190]                           invokeRestart("muffleWarning")
[17:47:10.190]                       }
[17:47:10.190]                       else if (inherits(cond, "condition")) {
[17:47:10.190]                         if (!is.null(pattern)) {
[17:47:10.190]                           computeRestarts <- base::computeRestarts
[17:47:10.190]                           grepl <- base::grepl
[17:47:10.190]                           restarts <- computeRestarts(cond)
[17:47:10.190]                           for (restart in restarts) {
[17:47:10.190]                             name <- restart$name
[17:47:10.190]                             if (is.null(name)) 
[17:47:10.190]                               next
[17:47:10.190]                             if (!grepl(pattern, name)) 
[17:47:10.190]                               next
[17:47:10.190]                             invokeRestart(restart)
[17:47:10.190]                             muffled <- TRUE
[17:47:10.190]                             break
[17:47:10.190]                           }
[17:47:10.190]                         }
[17:47:10.190]                       }
[17:47:10.190]                       invisible(muffled)
[17:47:10.190]                     }
[17:47:10.190]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.190]                   }
[17:47:10.190]                 }
[17:47:10.190]             }
[17:47:10.190]         }))
[17:47:10.190]     }, error = function(ex) {
[17:47:10.190]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.190]                 ...future.rng), started = ...future.startTime, 
[17:47:10.190]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.190]             version = "1.8"), class = "FutureResult")
[17:47:10.190]     }, finally = {
[17:47:10.190]         if (!identical(...future.workdir, getwd())) 
[17:47:10.190]             setwd(...future.workdir)
[17:47:10.190]         {
[17:47:10.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.190]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.190]             }
[17:47:10.190]             base::options(...future.oldOptions)
[17:47:10.190]             if (.Platform$OS.type == "windows") {
[17:47:10.190]                 old_names <- names(...future.oldEnvVars)
[17:47:10.190]                 envs <- base::Sys.getenv()
[17:47:10.190]                 names <- names(envs)
[17:47:10.190]                 common <- intersect(names, old_names)
[17:47:10.190]                 added <- setdiff(names, old_names)
[17:47:10.190]                 removed <- setdiff(old_names, names)
[17:47:10.190]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.190]                   envs[common]]
[17:47:10.190]                 NAMES <- toupper(changed)
[17:47:10.190]                 args <- list()
[17:47:10.190]                 for (kk in seq_along(NAMES)) {
[17:47:10.190]                   name <- changed[[kk]]
[17:47:10.190]                   NAME <- NAMES[[kk]]
[17:47:10.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.190]                     next
[17:47:10.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.190]                 }
[17:47:10.190]                 NAMES <- toupper(added)
[17:47:10.190]                 for (kk in seq_along(NAMES)) {
[17:47:10.190]                   name <- added[[kk]]
[17:47:10.190]                   NAME <- NAMES[[kk]]
[17:47:10.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.190]                     next
[17:47:10.190]                   args[[name]] <- ""
[17:47:10.190]                 }
[17:47:10.190]                 NAMES <- toupper(removed)
[17:47:10.190]                 for (kk in seq_along(NAMES)) {
[17:47:10.190]                   name <- removed[[kk]]
[17:47:10.190]                   NAME <- NAMES[[kk]]
[17:47:10.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.190]                     next
[17:47:10.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.190]                 }
[17:47:10.190]                 if (length(args) > 0) 
[17:47:10.190]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.190]             }
[17:47:10.190]             else {
[17:47:10.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.190]             }
[17:47:10.190]             {
[17:47:10.190]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.190]                   0L) {
[17:47:10.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.190]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.190]                   base::options(opts)
[17:47:10.190]                 }
[17:47:10.190]                 {
[17:47:10.190]                   {
[17:47:10.190]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.190]                     NULL
[17:47:10.190]                   }
[17:47:10.190]                   options(future.plan = NULL)
[17:47:10.190]                   if (is.na(NA_character_)) 
[17:47:10.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.190]                     .init = FALSE)
[17:47:10.190]                 }
[17:47:10.190]             }
[17:47:10.190]         }
[17:47:10.190]     })
[17:47:10.190]     if (TRUE) {
[17:47:10.190]         base::sink(type = "output", split = FALSE)
[17:47:10.190]         if (TRUE) {
[17:47:10.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.190]         }
[17:47:10.190]         else {
[17:47:10.190]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.190]         }
[17:47:10.190]         base::close(...future.stdout)
[17:47:10.190]         ...future.stdout <- NULL
[17:47:10.190]     }
[17:47:10.190]     ...future.result$conditions <- ...future.conditions
[17:47:10.190]     ...future.result$finished <- base::Sys.time()
[17:47:10.190]     ...future.result
[17:47:10.190] }
[17:47:10.192] Poll #1 (0): usedNodes() = 2, workers = 2
[17:47:10.203] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.203] - Validating connection of MultisessionFuture
[17:47:10.203] - received message: FutureResult
[17:47:10.203] - Received FutureResult
[17:47:10.204] - Erased future from FutureRegistry
[17:47:10.204] result() for ClusterFuture ...
[17:47:10.204] - result already collected: FutureResult
[17:47:10.204] result() for ClusterFuture ... done
[17:47:10.204] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.204] result() for ClusterFuture ...
[17:47:10.204] - result already collected: FutureResult
[17:47:10.204] result() for ClusterFuture ... done
[17:47:10.204] result() for ClusterFuture ...
[17:47:10.204] - result already collected: FutureResult
[17:47:10.204] result() for ClusterFuture ... done
[17:47:10.205] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[17:47:10.205] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:47:10.206] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:47:10.206] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:47:10.206] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:47:10.206] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[17:47:10.206] MultisessionFuture started
[17:47:10.207] - Launch lazy future ... done
[17:47:10.207] run() for ‘MultisessionFuture’ ... done
[17:47:10.207] result() for ClusterFuture ...
[17:47:10.207] - result already collected: FutureResult
[17:47:10.207] result() for ClusterFuture ... done
[17:47:10.207] result() for ClusterFuture ...
[17:47:10.207] - result already collected: FutureResult
[17:47:10.207] result() for ClusterFuture ... done
[17:47:10.207] result() for ClusterFuture ...
[17:47:10.208] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.208] - Validating connection of MultisessionFuture
[17:47:10.208] - received message: FutureResult
[17:47:10.208] - Received FutureResult
[17:47:10.208] - Erased future from FutureRegistry
[17:47:10.208] result() for ClusterFuture ...
[17:47:10.208] - result already collected: FutureResult
[17:47:10.208] result() for ClusterFuture ... done
[17:47:10.208] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.208] result() for ClusterFuture ... done
[17:47:10.209] result() for ClusterFuture ...
[17:47:10.209] - result already collected: FutureResult
[17:47:10.209] result() for ClusterFuture ... done
[17:47:10.209] result() for ClusterFuture ...
[17:47:10.209] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.209] - Validating connection of MultisessionFuture
[17:47:10.249] - received message: FutureResult
[17:47:10.249] - Received FutureResult
[17:47:10.249] - Erased future from FutureRegistry
[17:47:10.249] result() for ClusterFuture ...
[17:47:10.249] - result already collected: FutureResult
[17:47:10.250] result() for ClusterFuture ... done
[17:47:10.250] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.250] result() for ClusterFuture ... done
[17:47:10.250] result() for ClusterFuture ...
[17:47:10.250] - result already collected: FutureResult
[17:47:10.250] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.251] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.251] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.253] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.253] Searching for globals ... DONE
[17:47:10.253] Resolving globals: TRUE
[17:47:10.253] Resolving any globals that are futures ...
[17:47:10.253] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.253] Resolving any globals that are futures ... DONE
[17:47:10.254] Resolving futures part of globals (recursively) ...
[17:47:10.254] resolve() on list ...
[17:47:10.254]  recursive: 99
[17:47:10.254]  length: 2
[17:47:10.254]  elements: ‘a’, ‘ii’
[17:47:10.254]  length: 1 (resolved future 1)
[17:47:10.254]  length: 0 (resolved future 2)
[17:47:10.255] resolve() on list ... DONE
[17:47:10.255] - globals: [2] ‘a’, ‘ii’
[17:47:10.255] Resolving futures part of globals (recursively) ... DONE
[17:47:10.255] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:10.255] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:10.255] - globals: [2] ‘a’, ‘ii’
[17:47:10.255] 
[17:47:10.256] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.256] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.256] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.258] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.258] Searching for globals ... DONE
[17:47:10.258] Resolving globals: TRUE
[17:47:10.258] Resolving any globals that are futures ...
[17:47:10.258] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.259] Resolving any globals that are futures ... DONE
[17:47:10.259] Resolving futures part of globals (recursively) ...
[17:47:10.259] resolve() on list ...
[17:47:10.259]  recursive: 99
[17:47:10.259]  length: 2
[17:47:10.259]  elements: ‘a’, ‘ii’
[17:47:10.260]  length: 1 (resolved future 1)
[17:47:10.260]  length: 0 (resolved future 2)
[17:47:10.260] resolve() on list ... DONE
[17:47:10.260] - globals: [2] ‘a’, ‘ii’
[17:47:10.260] Resolving futures part of globals (recursively) ... DONE
[17:47:10.260] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:10.260] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:10.261] - globals: [2] ‘a’, ‘ii’
[17:47:10.261] 
[17:47:10.261] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.261] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.261] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.263] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.263] Searching for globals ... DONE
[17:47:10.263] Resolving globals: TRUE
[17:47:10.263] Resolving any globals that are futures ...
[17:47:10.264] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:47:10.264] Resolving any globals that are futures ... DONE
[17:47:10.264] Resolving futures part of globals (recursively) ...
[17:47:10.264] resolve() on list ...
[17:47:10.264]  recursive: 99
[17:47:10.264]  length: 2
[17:47:10.264]  elements: ‘a’, ‘ii’
[17:47:10.265]  length: 1 (resolved future 1)
[17:47:10.265]  length: 0 (resolved future 2)
[17:47:10.265] resolve() on list ... DONE
[17:47:10.265] - globals: [2] ‘a’, ‘ii’
[17:47:10.265] Resolving futures part of globals (recursively) ... DONE
[17:47:10.265] The total size of the 2 globals is 112 bytes (112 bytes)
[17:47:10.265] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:47:10.266] - globals: [2] ‘a’, ‘ii’
[17:47:10.266] 
[17:47:10.266] getGlobalsAndPackages() ... DONE
[17:47:10.266] run() for ‘Future’ ...
[17:47:10.266] - state: ‘created’
[17:47:10.266] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.280] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.280]   - Field: ‘node’
[17:47:10.280]   - Field: ‘label’
[17:47:10.280]   - Field: ‘local’
[17:47:10.280]   - Field: ‘owner’
[17:47:10.281]   - Field: ‘envir’
[17:47:10.281]   - Field: ‘workers’
[17:47:10.281]   - Field: ‘packages’
[17:47:10.281]   - Field: ‘gc’
[17:47:10.281]   - Field: ‘conditions’
[17:47:10.281]   - Field: ‘persistent’
[17:47:10.281]   - Field: ‘expr’
[17:47:10.281]   - Field: ‘uuid’
[17:47:10.281]   - Field: ‘seed’
[17:47:10.281]   - Field: ‘version’
[17:47:10.281]   - Field: ‘result’
[17:47:10.282]   - Field: ‘asynchronous’
[17:47:10.282]   - Field: ‘calls’
[17:47:10.282]   - Field: ‘globals’
[17:47:10.282]   - Field: ‘stdout’
[17:47:10.282]   - Field: ‘earlySignal’
[17:47:10.282]   - Field: ‘lazy’
[17:47:10.282]   - Field: ‘state’
[17:47:10.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.282] - Launch lazy future ...
[17:47:10.282] Packages needed by the future expression (n = 0): <none>
[17:47:10.283] Packages needed by future strategies (n = 0): <none>
[17:47:10.283] {
[17:47:10.283]     {
[17:47:10.283]         {
[17:47:10.283]             ...future.startTime <- base::Sys.time()
[17:47:10.283]             {
[17:47:10.283]                 {
[17:47:10.283]                   {
[17:47:10.283]                     {
[17:47:10.283]                       base::local({
[17:47:10.283]                         has_future <- base::requireNamespace("future", 
[17:47:10.283]                           quietly = TRUE)
[17:47:10.283]                         if (has_future) {
[17:47:10.283]                           ns <- base::getNamespace("future")
[17:47:10.283]                           version <- ns[[".package"]][["version"]]
[17:47:10.283]                           if (is.null(version)) 
[17:47:10.283]                             version <- utils::packageVersion("future")
[17:47:10.283]                         }
[17:47:10.283]                         else {
[17:47:10.283]                           version <- NULL
[17:47:10.283]                         }
[17:47:10.283]                         if (!has_future || version < "1.8.0") {
[17:47:10.283]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.283]                             "", base::R.version$version.string), 
[17:47:10.283]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.283]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.283]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.283]                               "release", "version")], collapse = " "), 
[17:47:10.283]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.283]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.283]                             info)
[17:47:10.283]                           info <- base::paste(info, collapse = "; ")
[17:47:10.283]                           if (!has_future) {
[17:47:10.283]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.283]                               info)
[17:47:10.283]                           }
[17:47:10.283]                           else {
[17:47:10.283]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.283]                               info, version)
[17:47:10.283]                           }
[17:47:10.283]                           base::stop(msg)
[17:47:10.283]                         }
[17:47:10.283]                       })
[17:47:10.283]                     }
[17:47:10.283]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.283]                     base::options(mc.cores = 1L)
[17:47:10.283]                   }
[17:47:10.283]                   ...future.strategy.old <- future::plan("list")
[17:47:10.283]                   options(future.plan = NULL)
[17:47:10.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.283]                 }
[17:47:10.283]                 ...future.workdir <- getwd()
[17:47:10.283]             }
[17:47:10.283]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.283]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.283]         }
[17:47:10.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.283]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.283]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.283]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.283]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.283]             base::names(...future.oldOptions))
[17:47:10.283]     }
[17:47:10.283]     if (FALSE) {
[17:47:10.283]     }
[17:47:10.283]     else {
[17:47:10.283]         if (TRUE) {
[17:47:10.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.283]                 open = "w")
[17:47:10.283]         }
[17:47:10.283]         else {
[17:47:10.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.283]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.283]         }
[17:47:10.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.283]             base::sink(type = "output", split = FALSE)
[17:47:10.283]             base::close(...future.stdout)
[17:47:10.283]         }, add = TRUE)
[17:47:10.283]     }
[17:47:10.283]     ...future.frame <- base::sys.nframe()
[17:47:10.283]     ...future.conditions <- base::list()
[17:47:10.283]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.283]     if (FALSE) {
[17:47:10.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.283]     }
[17:47:10.283]     ...future.result <- base::tryCatch({
[17:47:10.283]         base::withCallingHandlers({
[17:47:10.283]             ...future.value <- base::withVisible(base::local({
[17:47:10.283]                 ...future.makeSendCondition <- base::local({
[17:47:10.283]                   sendCondition <- NULL
[17:47:10.283]                   function(frame = 1L) {
[17:47:10.283]                     if (is.function(sendCondition)) 
[17:47:10.283]                       return(sendCondition)
[17:47:10.283]                     ns <- getNamespace("parallel")
[17:47:10.283]                     if (exists("sendData", mode = "function", 
[17:47:10.283]                       envir = ns)) {
[17:47:10.283]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.283]                         envir = ns)
[17:47:10.283]                       envir <- sys.frame(frame)
[17:47:10.283]                       master <- NULL
[17:47:10.283]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.283]                         !identical(envir, emptyenv())) {
[17:47:10.283]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.283]                           inherits = FALSE)) {
[17:47:10.283]                           master <- get("master", mode = "list", 
[17:47:10.283]                             envir = envir, inherits = FALSE)
[17:47:10.283]                           if (inherits(master, c("SOCKnode", 
[17:47:10.283]                             "SOCK0node"))) {
[17:47:10.283]                             sendCondition <<- function(cond) {
[17:47:10.283]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.283]                                 success = TRUE)
[17:47:10.283]                               parallel_sendData(master, data)
[17:47:10.283]                             }
[17:47:10.283]                             return(sendCondition)
[17:47:10.283]                           }
[17:47:10.283]                         }
[17:47:10.283]                         frame <- frame + 1L
[17:47:10.283]                         envir <- sys.frame(frame)
[17:47:10.283]                       }
[17:47:10.283]                     }
[17:47:10.283]                     sendCondition <<- function(cond) NULL
[17:47:10.283]                   }
[17:47:10.283]                 })
[17:47:10.283]                 withCallingHandlers({
[17:47:10.283]                   {
[17:47:10.283]                     b <- a * ii
[17:47:10.283]                     a <- 0
[17:47:10.283]                     b
[17:47:10.283]                   }
[17:47:10.283]                 }, immediateCondition = function(cond) {
[17:47:10.283]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.283]                   sendCondition(cond)
[17:47:10.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.283]                   {
[17:47:10.283]                     inherits <- base::inherits
[17:47:10.283]                     invokeRestart <- base::invokeRestart
[17:47:10.283]                     is.null <- base::is.null
[17:47:10.283]                     muffled <- FALSE
[17:47:10.283]                     if (inherits(cond, "message")) {
[17:47:10.283]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.283]                       if (muffled) 
[17:47:10.283]                         invokeRestart("muffleMessage")
[17:47:10.283]                     }
[17:47:10.283]                     else if (inherits(cond, "warning")) {
[17:47:10.283]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.283]                       if (muffled) 
[17:47:10.283]                         invokeRestart("muffleWarning")
[17:47:10.283]                     }
[17:47:10.283]                     else if (inherits(cond, "condition")) {
[17:47:10.283]                       if (!is.null(pattern)) {
[17:47:10.283]                         computeRestarts <- base::computeRestarts
[17:47:10.283]                         grepl <- base::grepl
[17:47:10.283]                         restarts <- computeRestarts(cond)
[17:47:10.283]                         for (restart in restarts) {
[17:47:10.283]                           name <- restart$name
[17:47:10.283]                           if (is.null(name)) 
[17:47:10.283]                             next
[17:47:10.283]                           if (!grepl(pattern, name)) 
[17:47:10.283]                             next
[17:47:10.283]                           invokeRestart(restart)
[17:47:10.283]                           muffled <- TRUE
[17:47:10.283]                           break
[17:47:10.283]                         }
[17:47:10.283]                       }
[17:47:10.283]                     }
[17:47:10.283]                     invisible(muffled)
[17:47:10.283]                   }
[17:47:10.283]                   muffleCondition(cond)
[17:47:10.283]                 })
[17:47:10.283]             }))
[17:47:10.283]             future::FutureResult(value = ...future.value$value, 
[17:47:10.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.283]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.283]                     ...future.globalenv.names))
[17:47:10.283]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.283]         }, condition = base::local({
[17:47:10.283]             c <- base::c
[17:47:10.283]             inherits <- base::inherits
[17:47:10.283]             invokeRestart <- base::invokeRestart
[17:47:10.283]             length <- base::length
[17:47:10.283]             list <- base::list
[17:47:10.283]             seq.int <- base::seq.int
[17:47:10.283]             signalCondition <- base::signalCondition
[17:47:10.283]             sys.calls <- base::sys.calls
[17:47:10.283]             `[[` <- base::`[[`
[17:47:10.283]             `+` <- base::`+`
[17:47:10.283]             `<<-` <- base::`<<-`
[17:47:10.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.283]                   3L)]
[17:47:10.283]             }
[17:47:10.283]             function(cond) {
[17:47:10.283]                 is_error <- inherits(cond, "error")
[17:47:10.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.283]                   NULL)
[17:47:10.283]                 if (is_error) {
[17:47:10.283]                   sessionInformation <- function() {
[17:47:10.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.283]                       search = base::search(), system = base::Sys.info())
[17:47:10.283]                   }
[17:47:10.283]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.283]                     cond$call), session = sessionInformation(), 
[17:47:10.283]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.283]                   signalCondition(cond)
[17:47:10.283]                 }
[17:47:10.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.283]                 "immediateCondition"))) {
[17:47:10.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.283]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.283]                   if (TRUE && !signal) {
[17:47:10.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.283]                     {
[17:47:10.283]                       inherits <- base::inherits
[17:47:10.283]                       invokeRestart <- base::invokeRestart
[17:47:10.283]                       is.null <- base::is.null
[17:47:10.283]                       muffled <- FALSE
[17:47:10.283]                       if (inherits(cond, "message")) {
[17:47:10.283]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.283]                         if (muffled) 
[17:47:10.283]                           invokeRestart("muffleMessage")
[17:47:10.283]                       }
[17:47:10.283]                       else if (inherits(cond, "warning")) {
[17:47:10.283]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.283]                         if (muffled) 
[17:47:10.283]                           invokeRestart("muffleWarning")
[17:47:10.283]                       }
[17:47:10.283]                       else if (inherits(cond, "condition")) {
[17:47:10.283]                         if (!is.null(pattern)) {
[17:47:10.283]                           computeRestarts <- base::computeRestarts
[17:47:10.283]                           grepl <- base::grepl
[17:47:10.283]                           restarts <- computeRestarts(cond)
[17:47:10.283]                           for (restart in restarts) {
[17:47:10.283]                             name <- restart$name
[17:47:10.283]                             if (is.null(name)) 
[17:47:10.283]                               next
[17:47:10.283]                             if (!grepl(pattern, name)) 
[17:47:10.283]                               next
[17:47:10.283]                             invokeRestart(restart)
[17:47:10.283]                             muffled <- TRUE
[17:47:10.283]                             break
[17:47:10.283]                           }
[17:47:10.283]                         }
[17:47:10.283]                       }
[17:47:10.283]                       invisible(muffled)
[17:47:10.283]                     }
[17:47:10.283]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.283]                   }
[17:47:10.283]                 }
[17:47:10.283]                 else {
[17:47:10.283]                   if (TRUE) {
[17:47:10.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.283]                     {
[17:47:10.283]                       inherits <- base::inherits
[17:47:10.283]                       invokeRestart <- base::invokeRestart
[17:47:10.283]                       is.null <- base::is.null
[17:47:10.283]                       muffled <- FALSE
[17:47:10.283]                       if (inherits(cond, "message")) {
[17:47:10.283]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.283]                         if (muffled) 
[17:47:10.283]                           invokeRestart("muffleMessage")
[17:47:10.283]                       }
[17:47:10.283]                       else if (inherits(cond, "warning")) {
[17:47:10.283]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.283]                         if (muffled) 
[17:47:10.283]                           invokeRestart("muffleWarning")
[17:47:10.283]                       }
[17:47:10.283]                       else if (inherits(cond, "condition")) {
[17:47:10.283]                         if (!is.null(pattern)) {
[17:47:10.283]                           computeRestarts <- base::computeRestarts
[17:47:10.283]                           grepl <- base::grepl
[17:47:10.283]                           restarts <- computeRestarts(cond)
[17:47:10.283]                           for (restart in restarts) {
[17:47:10.283]                             name <- restart$name
[17:47:10.283]                             if (is.null(name)) 
[17:47:10.283]                               next
[17:47:10.283]                             if (!grepl(pattern, name)) 
[17:47:10.283]                               next
[17:47:10.283]                             invokeRestart(restart)
[17:47:10.283]                             muffled <- TRUE
[17:47:10.283]                             break
[17:47:10.283]                           }
[17:47:10.283]                         }
[17:47:10.283]                       }
[17:47:10.283]                       invisible(muffled)
[17:47:10.283]                     }
[17:47:10.283]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.283]                   }
[17:47:10.283]                 }
[17:47:10.283]             }
[17:47:10.283]         }))
[17:47:10.283]     }, error = function(ex) {
[17:47:10.283]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.283]                 ...future.rng), started = ...future.startTime, 
[17:47:10.283]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.283]             version = "1.8"), class = "FutureResult")
[17:47:10.283]     }, finally = {
[17:47:10.283]         if (!identical(...future.workdir, getwd())) 
[17:47:10.283]             setwd(...future.workdir)
[17:47:10.283]         {
[17:47:10.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.283]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.283]             }
[17:47:10.283]             base::options(...future.oldOptions)
[17:47:10.283]             if (.Platform$OS.type == "windows") {
[17:47:10.283]                 old_names <- names(...future.oldEnvVars)
[17:47:10.283]                 envs <- base::Sys.getenv()
[17:47:10.283]                 names <- names(envs)
[17:47:10.283]                 common <- intersect(names, old_names)
[17:47:10.283]                 added <- setdiff(names, old_names)
[17:47:10.283]                 removed <- setdiff(old_names, names)
[17:47:10.283]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.283]                   envs[common]]
[17:47:10.283]                 NAMES <- toupper(changed)
[17:47:10.283]                 args <- list()
[17:47:10.283]                 for (kk in seq_along(NAMES)) {
[17:47:10.283]                   name <- changed[[kk]]
[17:47:10.283]                   NAME <- NAMES[[kk]]
[17:47:10.283]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.283]                     next
[17:47:10.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.283]                 }
[17:47:10.283]                 NAMES <- toupper(added)
[17:47:10.283]                 for (kk in seq_along(NAMES)) {
[17:47:10.283]                   name <- added[[kk]]
[17:47:10.283]                   NAME <- NAMES[[kk]]
[17:47:10.283]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.283]                     next
[17:47:10.283]                   args[[name]] <- ""
[17:47:10.283]                 }
[17:47:10.283]                 NAMES <- toupper(removed)
[17:47:10.283]                 for (kk in seq_along(NAMES)) {
[17:47:10.283]                   name <- removed[[kk]]
[17:47:10.283]                   NAME <- NAMES[[kk]]
[17:47:10.283]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.283]                     next
[17:47:10.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.283]                 }
[17:47:10.283]                 if (length(args) > 0) 
[17:47:10.283]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.283]             }
[17:47:10.283]             else {
[17:47:10.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.283]             }
[17:47:10.283]             {
[17:47:10.283]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.283]                   0L) {
[17:47:10.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.283]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.283]                   base::options(opts)
[17:47:10.283]                 }
[17:47:10.283]                 {
[17:47:10.283]                   {
[17:47:10.283]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.283]                     NULL
[17:47:10.283]                   }
[17:47:10.283]                   options(future.plan = NULL)
[17:47:10.283]                   if (is.na(NA_character_)) 
[17:47:10.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.283]                     .init = FALSE)
[17:47:10.283]                 }
[17:47:10.283]             }
[17:47:10.283]         }
[17:47:10.283]     })
[17:47:10.283]     if (TRUE) {
[17:47:10.283]         base::sink(type = "output", split = FALSE)
[17:47:10.283]         if (TRUE) {
[17:47:10.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.283]         }
[17:47:10.283]         else {
[17:47:10.283]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.283]         }
[17:47:10.283]         base::close(...future.stdout)
[17:47:10.283]         ...future.stdout <- NULL
[17:47:10.283]     }
[17:47:10.283]     ...future.result$conditions <- ...future.conditions
[17:47:10.283]     ...future.result$finished <- base::Sys.time()
[17:47:10.283]     ...future.result
[17:47:10.283] }
[17:47:10.286] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:47:10.286] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:47:10.286] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:47:10.286] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:47:10.287] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:47:10.287] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:47:10.287] MultisessionFuture started
[17:47:10.287] - Launch lazy future ... done
[17:47:10.287] run() for ‘MultisessionFuture’ ... done
[17:47:10.287] result() for ClusterFuture ...
[17:47:10.288] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.288] - Validating connection of MultisessionFuture
[17:47:10.289] - received message: FutureResult
[17:47:10.289] - Received FutureResult
[17:47:10.289] - Erased future from FutureRegistry
[17:47:10.289] result() for ClusterFuture ...
[17:47:10.289] - result already collected: FutureResult
[17:47:10.289] result() for ClusterFuture ... done
[17:47:10.289] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.289] result() for ClusterFuture ... done
[17:47:10.289] result() for ClusterFuture ...
[17:47:10.290] - result already collected: FutureResult
[17:47:10.290] result() for ClusterFuture ... done
[17:47:10.290] run() for ‘Future’ ...
[17:47:10.290] - state: ‘created’
[17:47:10.290] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.306] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.306]   - Field: ‘node’
[17:47:10.306]   - Field: ‘label’
[17:47:10.306]   - Field: ‘local’
[17:47:10.306]   - Field: ‘owner’
[17:47:10.306]   - Field: ‘envir’
[17:47:10.306]   - Field: ‘workers’
[17:47:10.307]   - Field: ‘packages’
[17:47:10.307]   - Field: ‘gc’
[17:47:10.307]   - Field: ‘conditions’
[17:47:10.307]   - Field: ‘persistent’
[17:47:10.307]   - Field: ‘expr’
[17:47:10.307]   - Field: ‘uuid’
[17:47:10.307]   - Field: ‘seed’
[17:47:10.307]   - Field: ‘version’
[17:47:10.307]   - Field: ‘result’
[17:47:10.307]   - Field: ‘asynchronous’
[17:47:10.307]   - Field: ‘calls’
[17:47:10.308]   - Field: ‘globals’
[17:47:10.308]   - Field: ‘stdout’
[17:47:10.308]   - Field: ‘earlySignal’
[17:47:10.308]   - Field: ‘lazy’
[17:47:10.308]   - Field: ‘state’
[17:47:10.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.308] - Launch lazy future ...
[17:47:10.308] Packages needed by the future expression (n = 0): <none>
[17:47:10.308] Packages needed by future strategies (n = 0): <none>
[17:47:10.309] {
[17:47:10.309]     {
[17:47:10.309]         {
[17:47:10.309]             ...future.startTime <- base::Sys.time()
[17:47:10.309]             {
[17:47:10.309]                 {
[17:47:10.309]                   {
[17:47:10.309]                     {
[17:47:10.309]                       base::local({
[17:47:10.309]                         has_future <- base::requireNamespace("future", 
[17:47:10.309]                           quietly = TRUE)
[17:47:10.309]                         if (has_future) {
[17:47:10.309]                           ns <- base::getNamespace("future")
[17:47:10.309]                           version <- ns[[".package"]][["version"]]
[17:47:10.309]                           if (is.null(version)) 
[17:47:10.309]                             version <- utils::packageVersion("future")
[17:47:10.309]                         }
[17:47:10.309]                         else {
[17:47:10.309]                           version <- NULL
[17:47:10.309]                         }
[17:47:10.309]                         if (!has_future || version < "1.8.0") {
[17:47:10.309]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.309]                             "", base::R.version$version.string), 
[17:47:10.309]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.309]                               "release", "version")], collapse = " "), 
[17:47:10.309]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.309]                             info)
[17:47:10.309]                           info <- base::paste(info, collapse = "; ")
[17:47:10.309]                           if (!has_future) {
[17:47:10.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.309]                               info)
[17:47:10.309]                           }
[17:47:10.309]                           else {
[17:47:10.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.309]                               info, version)
[17:47:10.309]                           }
[17:47:10.309]                           base::stop(msg)
[17:47:10.309]                         }
[17:47:10.309]                       })
[17:47:10.309]                     }
[17:47:10.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.309]                     base::options(mc.cores = 1L)
[17:47:10.309]                   }
[17:47:10.309]                   ...future.strategy.old <- future::plan("list")
[17:47:10.309]                   options(future.plan = NULL)
[17:47:10.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.309]                 }
[17:47:10.309]                 ...future.workdir <- getwd()
[17:47:10.309]             }
[17:47:10.309]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.309]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.309]         }
[17:47:10.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.309]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.309]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.309]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.309]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.309]             base::names(...future.oldOptions))
[17:47:10.309]     }
[17:47:10.309]     if (FALSE) {
[17:47:10.309]     }
[17:47:10.309]     else {
[17:47:10.309]         if (TRUE) {
[17:47:10.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.309]                 open = "w")
[17:47:10.309]         }
[17:47:10.309]         else {
[17:47:10.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.309]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.309]         }
[17:47:10.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.309]             base::sink(type = "output", split = FALSE)
[17:47:10.309]             base::close(...future.stdout)
[17:47:10.309]         }, add = TRUE)
[17:47:10.309]     }
[17:47:10.309]     ...future.frame <- base::sys.nframe()
[17:47:10.309]     ...future.conditions <- base::list()
[17:47:10.309]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.309]     if (FALSE) {
[17:47:10.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.309]     }
[17:47:10.309]     ...future.result <- base::tryCatch({
[17:47:10.309]         base::withCallingHandlers({
[17:47:10.309]             ...future.value <- base::withVisible(base::local({
[17:47:10.309]                 ...future.makeSendCondition <- base::local({
[17:47:10.309]                   sendCondition <- NULL
[17:47:10.309]                   function(frame = 1L) {
[17:47:10.309]                     if (is.function(sendCondition)) 
[17:47:10.309]                       return(sendCondition)
[17:47:10.309]                     ns <- getNamespace("parallel")
[17:47:10.309]                     if (exists("sendData", mode = "function", 
[17:47:10.309]                       envir = ns)) {
[17:47:10.309]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.309]                         envir = ns)
[17:47:10.309]                       envir <- sys.frame(frame)
[17:47:10.309]                       master <- NULL
[17:47:10.309]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.309]                         !identical(envir, emptyenv())) {
[17:47:10.309]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.309]                           inherits = FALSE)) {
[17:47:10.309]                           master <- get("master", mode = "list", 
[17:47:10.309]                             envir = envir, inherits = FALSE)
[17:47:10.309]                           if (inherits(master, c("SOCKnode", 
[17:47:10.309]                             "SOCK0node"))) {
[17:47:10.309]                             sendCondition <<- function(cond) {
[17:47:10.309]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.309]                                 success = TRUE)
[17:47:10.309]                               parallel_sendData(master, data)
[17:47:10.309]                             }
[17:47:10.309]                             return(sendCondition)
[17:47:10.309]                           }
[17:47:10.309]                         }
[17:47:10.309]                         frame <- frame + 1L
[17:47:10.309]                         envir <- sys.frame(frame)
[17:47:10.309]                       }
[17:47:10.309]                     }
[17:47:10.309]                     sendCondition <<- function(cond) NULL
[17:47:10.309]                   }
[17:47:10.309]                 })
[17:47:10.309]                 withCallingHandlers({
[17:47:10.309]                   {
[17:47:10.309]                     b <- a * ii
[17:47:10.309]                     a <- 0
[17:47:10.309]                     b
[17:47:10.309]                   }
[17:47:10.309]                 }, immediateCondition = function(cond) {
[17:47:10.309]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.309]                   sendCondition(cond)
[17:47:10.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.309]                   {
[17:47:10.309]                     inherits <- base::inherits
[17:47:10.309]                     invokeRestart <- base::invokeRestart
[17:47:10.309]                     is.null <- base::is.null
[17:47:10.309]                     muffled <- FALSE
[17:47:10.309]                     if (inherits(cond, "message")) {
[17:47:10.309]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.309]                       if (muffled) 
[17:47:10.309]                         invokeRestart("muffleMessage")
[17:47:10.309]                     }
[17:47:10.309]                     else if (inherits(cond, "warning")) {
[17:47:10.309]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.309]                       if (muffled) 
[17:47:10.309]                         invokeRestart("muffleWarning")
[17:47:10.309]                     }
[17:47:10.309]                     else if (inherits(cond, "condition")) {
[17:47:10.309]                       if (!is.null(pattern)) {
[17:47:10.309]                         computeRestarts <- base::computeRestarts
[17:47:10.309]                         grepl <- base::grepl
[17:47:10.309]                         restarts <- computeRestarts(cond)
[17:47:10.309]                         for (restart in restarts) {
[17:47:10.309]                           name <- restart$name
[17:47:10.309]                           if (is.null(name)) 
[17:47:10.309]                             next
[17:47:10.309]                           if (!grepl(pattern, name)) 
[17:47:10.309]                             next
[17:47:10.309]                           invokeRestart(restart)
[17:47:10.309]                           muffled <- TRUE
[17:47:10.309]                           break
[17:47:10.309]                         }
[17:47:10.309]                       }
[17:47:10.309]                     }
[17:47:10.309]                     invisible(muffled)
[17:47:10.309]                   }
[17:47:10.309]                   muffleCondition(cond)
[17:47:10.309]                 })
[17:47:10.309]             }))
[17:47:10.309]             future::FutureResult(value = ...future.value$value, 
[17:47:10.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.309]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.309]                     ...future.globalenv.names))
[17:47:10.309]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.309]         }, condition = base::local({
[17:47:10.309]             c <- base::c
[17:47:10.309]             inherits <- base::inherits
[17:47:10.309]             invokeRestart <- base::invokeRestart
[17:47:10.309]             length <- base::length
[17:47:10.309]             list <- base::list
[17:47:10.309]             seq.int <- base::seq.int
[17:47:10.309]             signalCondition <- base::signalCondition
[17:47:10.309]             sys.calls <- base::sys.calls
[17:47:10.309]             `[[` <- base::`[[`
[17:47:10.309]             `+` <- base::`+`
[17:47:10.309]             `<<-` <- base::`<<-`
[17:47:10.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.309]                   3L)]
[17:47:10.309]             }
[17:47:10.309]             function(cond) {
[17:47:10.309]                 is_error <- inherits(cond, "error")
[17:47:10.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.309]                   NULL)
[17:47:10.309]                 if (is_error) {
[17:47:10.309]                   sessionInformation <- function() {
[17:47:10.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.309]                       search = base::search(), system = base::Sys.info())
[17:47:10.309]                   }
[17:47:10.309]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.309]                     cond$call), session = sessionInformation(), 
[17:47:10.309]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.309]                   signalCondition(cond)
[17:47:10.309]                 }
[17:47:10.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.309]                 "immediateCondition"))) {
[17:47:10.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.309]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.309]                   if (TRUE && !signal) {
[17:47:10.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.309]                     {
[17:47:10.309]                       inherits <- base::inherits
[17:47:10.309]                       invokeRestart <- base::invokeRestart
[17:47:10.309]                       is.null <- base::is.null
[17:47:10.309]                       muffled <- FALSE
[17:47:10.309]                       if (inherits(cond, "message")) {
[17:47:10.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.309]                         if (muffled) 
[17:47:10.309]                           invokeRestart("muffleMessage")
[17:47:10.309]                       }
[17:47:10.309]                       else if (inherits(cond, "warning")) {
[17:47:10.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.309]                         if (muffled) 
[17:47:10.309]                           invokeRestart("muffleWarning")
[17:47:10.309]                       }
[17:47:10.309]                       else if (inherits(cond, "condition")) {
[17:47:10.309]                         if (!is.null(pattern)) {
[17:47:10.309]                           computeRestarts <- base::computeRestarts
[17:47:10.309]                           grepl <- base::grepl
[17:47:10.309]                           restarts <- computeRestarts(cond)
[17:47:10.309]                           for (restart in restarts) {
[17:47:10.309]                             name <- restart$name
[17:47:10.309]                             if (is.null(name)) 
[17:47:10.309]                               next
[17:47:10.309]                             if (!grepl(pattern, name)) 
[17:47:10.309]                               next
[17:47:10.309]                             invokeRestart(restart)
[17:47:10.309]                             muffled <- TRUE
[17:47:10.309]                             break
[17:47:10.309]                           }
[17:47:10.309]                         }
[17:47:10.309]                       }
[17:47:10.309]                       invisible(muffled)
[17:47:10.309]                     }
[17:47:10.309]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.309]                   }
[17:47:10.309]                 }
[17:47:10.309]                 else {
[17:47:10.309]                   if (TRUE) {
[17:47:10.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.309]                     {
[17:47:10.309]                       inherits <- base::inherits
[17:47:10.309]                       invokeRestart <- base::invokeRestart
[17:47:10.309]                       is.null <- base::is.null
[17:47:10.309]                       muffled <- FALSE
[17:47:10.309]                       if (inherits(cond, "message")) {
[17:47:10.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.309]                         if (muffled) 
[17:47:10.309]                           invokeRestart("muffleMessage")
[17:47:10.309]                       }
[17:47:10.309]                       else if (inherits(cond, "warning")) {
[17:47:10.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.309]                         if (muffled) 
[17:47:10.309]                           invokeRestart("muffleWarning")
[17:47:10.309]                       }
[17:47:10.309]                       else if (inherits(cond, "condition")) {
[17:47:10.309]                         if (!is.null(pattern)) {
[17:47:10.309]                           computeRestarts <- base::computeRestarts
[17:47:10.309]                           grepl <- base::grepl
[17:47:10.309]                           restarts <- computeRestarts(cond)
[17:47:10.309]                           for (restart in restarts) {
[17:47:10.309]                             name <- restart$name
[17:47:10.309]                             if (is.null(name)) 
[17:47:10.309]                               next
[17:47:10.309]                             if (!grepl(pattern, name)) 
[17:47:10.309]                               next
[17:47:10.309]                             invokeRestart(restart)
[17:47:10.309]                             muffled <- TRUE
[17:47:10.309]                             break
[17:47:10.309]                           }
[17:47:10.309]                         }
[17:47:10.309]                       }
[17:47:10.309]                       invisible(muffled)
[17:47:10.309]                     }
[17:47:10.309]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.309]                   }
[17:47:10.309]                 }
[17:47:10.309]             }
[17:47:10.309]         }))
[17:47:10.309]     }, error = function(ex) {
[17:47:10.309]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.309]                 ...future.rng), started = ...future.startTime, 
[17:47:10.309]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.309]             version = "1.8"), class = "FutureResult")
[17:47:10.309]     }, finally = {
[17:47:10.309]         if (!identical(...future.workdir, getwd())) 
[17:47:10.309]             setwd(...future.workdir)
[17:47:10.309]         {
[17:47:10.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.309]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.309]             }
[17:47:10.309]             base::options(...future.oldOptions)
[17:47:10.309]             if (.Platform$OS.type == "windows") {
[17:47:10.309]                 old_names <- names(...future.oldEnvVars)
[17:47:10.309]                 envs <- base::Sys.getenv()
[17:47:10.309]                 names <- names(envs)
[17:47:10.309]                 common <- intersect(names, old_names)
[17:47:10.309]                 added <- setdiff(names, old_names)
[17:47:10.309]                 removed <- setdiff(old_names, names)
[17:47:10.309]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.309]                   envs[common]]
[17:47:10.309]                 NAMES <- toupper(changed)
[17:47:10.309]                 args <- list()
[17:47:10.309]                 for (kk in seq_along(NAMES)) {
[17:47:10.309]                   name <- changed[[kk]]
[17:47:10.309]                   NAME <- NAMES[[kk]]
[17:47:10.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.309]                     next
[17:47:10.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.309]                 }
[17:47:10.309]                 NAMES <- toupper(added)
[17:47:10.309]                 for (kk in seq_along(NAMES)) {
[17:47:10.309]                   name <- added[[kk]]
[17:47:10.309]                   NAME <- NAMES[[kk]]
[17:47:10.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.309]                     next
[17:47:10.309]                   args[[name]] <- ""
[17:47:10.309]                 }
[17:47:10.309]                 NAMES <- toupper(removed)
[17:47:10.309]                 for (kk in seq_along(NAMES)) {
[17:47:10.309]                   name <- removed[[kk]]
[17:47:10.309]                   NAME <- NAMES[[kk]]
[17:47:10.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.309]                     next
[17:47:10.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.309]                 }
[17:47:10.309]                 if (length(args) > 0) 
[17:47:10.309]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.309]             }
[17:47:10.309]             else {
[17:47:10.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.309]             }
[17:47:10.309]             {
[17:47:10.309]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.309]                   0L) {
[17:47:10.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.309]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.309]                   base::options(opts)
[17:47:10.309]                 }
[17:47:10.309]                 {
[17:47:10.309]                   {
[17:47:10.309]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.309]                     NULL
[17:47:10.309]                   }
[17:47:10.309]                   options(future.plan = NULL)
[17:47:10.309]                   if (is.na(NA_character_)) 
[17:47:10.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.309]                     .init = FALSE)
[17:47:10.309]                 }
[17:47:10.309]             }
[17:47:10.309]         }
[17:47:10.309]     })
[17:47:10.309]     if (TRUE) {
[17:47:10.309]         base::sink(type = "output", split = FALSE)
[17:47:10.309]         if (TRUE) {
[17:47:10.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.309]         }
[17:47:10.309]         else {
[17:47:10.309]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.309]         }
[17:47:10.309]         base::close(...future.stdout)
[17:47:10.309]         ...future.stdout <- NULL
[17:47:10.309]     }
[17:47:10.309]     ...future.result$conditions <- ...future.conditions
[17:47:10.309]     ...future.result$finished <- base::Sys.time()
[17:47:10.309]     ...future.result
[17:47:10.309] }
[17:47:10.311] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:47:10.311] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:47:10.312] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:47:10.312] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:47:10.312] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:47:10.312] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:47:10.313] MultisessionFuture started
[17:47:10.313] - Launch lazy future ... done
[17:47:10.313] run() for ‘MultisessionFuture’ ... done
[17:47:10.313] result() for ClusterFuture ...
[17:47:10.313] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.313] - Validating connection of MultisessionFuture
[17:47:10.314] - received message: FutureResult
[17:47:10.314] - Received FutureResult
[17:47:10.314] - Erased future from FutureRegistry
[17:47:10.314] result() for ClusterFuture ...
[17:47:10.315] - result already collected: FutureResult
[17:47:10.315] result() for ClusterFuture ... done
[17:47:10.315] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.315] result() for ClusterFuture ... done
[17:47:10.315] result() for ClusterFuture ...
[17:47:10.315] - result already collected: FutureResult
[17:47:10.315] result() for ClusterFuture ... done
[17:47:10.315] run() for ‘Future’ ...
[17:47:10.315] - state: ‘created’
[17:47:10.315] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.329] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.329]   - Field: ‘node’
[17:47:10.329]   - Field: ‘label’
[17:47:10.329]   - Field: ‘local’
[17:47:10.329]   - Field: ‘owner’
[17:47:10.329]   - Field: ‘envir’
[17:47:10.330]   - Field: ‘workers’
[17:47:10.330]   - Field: ‘packages’
[17:47:10.330]   - Field: ‘gc’
[17:47:10.330]   - Field: ‘conditions’
[17:47:10.330]   - Field: ‘persistent’
[17:47:10.330]   - Field: ‘expr’
[17:47:10.330]   - Field: ‘uuid’
[17:47:10.330]   - Field: ‘seed’
[17:47:10.330]   - Field: ‘version’
[17:47:10.330]   - Field: ‘result’
[17:47:10.330]   - Field: ‘asynchronous’
[17:47:10.330]   - Field: ‘calls’
[17:47:10.331]   - Field: ‘globals’
[17:47:10.331]   - Field: ‘stdout’
[17:47:10.331]   - Field: ‘earlySignal’
[17:47:10.331]   - Field: ‘lazy’
[17:47:10.331]   - Field: ‘state’
[17:47:10.331] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.331] - Launch lazy future ...
[17:47:10.331] Packages needed by the future expression (n = 0): <none>
[17:47:10.331] Packages needed by future strategies (n = 0): <none>
[17:47:10.332] {
[17:47:10.332]     {
[17:47:10.332]         {
[17:47:10.332]             ...future.startTime <- base::Sys.time()
[17:47:10.332]             {
[17:47:10.332]                 {
[17:47:10.332]                   {
[17:47:10.332]                     {
[17:47:10.332]                       base::local({
[17:47:10.332]                         has_future <- base::requireNamespace("future", 
[17:47:10.332]                           quietly = TRUE)
[17:47:10.332]                         if (has_future) {
[17:47:10.332]                           ns <- base::getNamespace("future")
[17:47:10.332]                           version <- ns[[".package"]][["version"]]
[17:47:10.332]                           if (is.null(version)) 
[17:47:10.332]                             version <- utils::packageVersion("future")
[17:47:10.332]                         }
[17:47:10.332]                         else {
[17:47:10.332]                           version <- NULL
[17:47:10.332]                         }
[17:47:10.332]                         if (!has_future || version < "1.8.0") {
[17:47:10.332]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.332]                             "", base::R.version$version.string), 
[17:47:10.332]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.332]                               "release", "version")], collapse = " "), 
[17:47:10.332]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.332]                             info)
[17:47:10.332]                           info <- base::paste(info, collapse = "; ")
[17:47:10.332]                           if (!has_future) {
[17:47:10.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.332]                               info)
[17:47:10.332]                           }
[17:47:10.332]                           else {
[17:47:10.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.332]                               info, version)
[17:47:10.332]                           }
[17:47:10.332]                           base::stop(msg)
[17:47:10.332]                         }
[17:47:10.332]                       })
[17:47:10.332]                     }
[17:47:10.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.332]                     base::options(mc.cores = 1L)
[17:47:10.332]                   }
[17:47:10.332]                   ...future.strategy.old <- future::plan("list")
[17:47:10.332]                   options(future.plan = NULL)
[17:47:10.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.332]                 }
[17:47:10.332]                 ...future.workdir <- getwd()
[17:47:10.332]             }
[17:47:10.332]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.332]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.332]         }
[17:47:10.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.332]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.332]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.332]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.332]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.332]             base::names(...future.oldOptions))
[17:47:10.332]     }
[17:47:10.332]     if (FALSE) {
[17:47:10.332]     }
[17:47:10.332]     else {
[17:47:10.332]         if (TRUE) {
[17:47:10.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.332]                 open = "w")
[17:47:10.332]         }
[17:47:10.332]         else {
[17:47:10.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.332]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.332]         }
[17:47:10.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.332]             base::sink(type = "output", split = FALSE)
[17:47:10.332]             base::close(...future.stdout)
[17:47:10.332]         }, add = TRUE)
[17:47:10.332]     }
[17:47:10.332]     ...future.frame <- base::sys.nframe()
[17:47:10.332]     ...future.conditions <- base::list()
[17:47:10.332]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.332]     if (FALSE) {
[17:47:10.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.332]     }
[17:47:10.332]     ...future.result <- base::tryCatch({
[17:47:10.332]         base::withCallingHandlers({
[17:47:10.332]             ...future.value <- base::withVisible(base::local({
[17:47:10.332]                 ...future.makeSendCondition <- base::local({
[17:47:10.332]                   sendCondition <- NULL
[17:47:10.332]                   function(frame = 1L) {
[17:47:10.332]                     if (is.function(sendCondition)) 
[17:47:10.332]                       return(sendCondition)
[17:47:10.332]                     ns <- getNamespace("parallel")
[17:47:10.332]                     if (exists("sendData", mode = "function", 
[17:47:10.332]                       envir = ns)) {
[17:47:10.332]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.332]                         envir = ns)
[17:47:10.332]                       envir <- sys.frame(frame)
[17:47:10.332]                       master <- NULL
[17:47:10.332]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.332]                         !identical(envir, emptyenv())) {
[17:47:10.332]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.332]                           inherits = FALSE)) {
[17:47:10.332]                           master <- get("master", mode = "list", 
[17:47:10.332]                             envir = envir, inherits = FALSE)
[17:47:10.332]                           if (inherits(master, c("SOCKnode", 
[17:47:10.332]                             "SOCK0node"))) {
[17:47:10.332]                             sendCondition <<- function(cond) {
[17:47:10.332]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.332]                                 success = TRUE)
[17:47:10.332]                               parallel_sendData(master, data)
[17:47:10.332]                             }
[17:47:10.332]                             return(sendCondition)
[17:47:10.332]                           }
[17:47:10.332]                         }
[17:47:10.332]                         frame <- frame + 1L
[17:47:10.332]                         envir <- sys.frame(frame)
[17:47:10.332]                       }
[17:47:10.332]                     }
[17:47:10.332]                     sendCondition <<- function(cond) NULL
[17:47:10.332]                   }
[17:47:10.332]                 })
[17:47:10.332]                 withCallingHandlers({
[17:47:10.332]                   {
[17:47:10.332]                     b <- a * ii
[17:47:10.332]                     a <- 0
[17:47:10.332]                     b
[17:47:10.332]                   }
[17:47:10.332]                 }, immediateCondition = function(cond) {
[17:47:10.332]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.332]                   sendCondition(cond)
[17:47:10.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.332]                   {
[17:47:10.332]                     inherits <- base::inherits
[17:47:10.332]                     invokeRestart <- base::invokeRestart
[17:47:10.332]                     is.null <- base::is.null
[17:47:10.332]                     muffled <- FALSE
[17:47:10.332]                     if (inherits(cond, "message")) {
[17:47:10.332]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.332]                       if (muffled) 
[17:47:10.332]                         invokeRestart("muffleMessage")
[17:47:10.332]                     }
[17:47:10.332]                     else if (inherits(cond, "warning")) {
[17:47:10.332]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.332]                       if (muffled) 
[17:47:10.332]                         invokeRestart("muffleWarning")
[17:47:10.332]                     }
[17:47:10.332]                     else if (inherits(cond, "condition")) {
[17:47:10.332]                       if (!is.null(pattern)) {
[17:47:10.332]                         computeRestarts <- base::computeRestarts
[17:47:10.332]                         grepl <- base::grepl
[17:47:10.332]                         restarts <- computeRestarts(cond)
[17:47:10.332]                         for (restart in restarts) {
[17:47:10.332]                           name <- restart$name
[17:47:10.332]                           if (is.null(name)) 
[17:47:10.332]                             next
[17:47:10.332]                           if (!grepl(pattern, name)) 
[17:47:10.332]                             next
[17:47:10.332]                           invokeRestart(restart)
[17:47:10.332]                           muffled <- TRUE
[17:47:10.332]                           break
[17:47:10.332]                         }
[17:47:10.332]                       }
[17:47:10.332]                     }
[17:47:10.332]                     invisible(muffled)
[17:47:10.332]                   }
[17:47:10.332]                   muffleCondition(cond)
[17:47:10.332]                 })
[17:47:10.332]             }))
[17:47:10.332]             future::FutureResult(value = ...future.value$value, 
[17:47:10.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.332]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.332]                     ...future.globalenv.names))
[17:47:10.332]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.332]         }, condition = base::local({
[17:47:10.332]             c <- base::c
[17:47:10.332]             inherits <- base::inherits
[17:47:10.332]             invokeRestart <- base::invokeRestart
[17:47:10.332]             length <- base::length
[17:47:10.332]             list <- base::list
[17:47:10.332]             seq.int <- base::seq.int
[17:47:10.332]             signalCondition <- base::signalCondition
[17:47:10.332]             sys.calls <- base::sys.calls
[17:47:10.332]             `[[` <- base::`[[`
[17:47:10.332]             `+` <- base::`+`
[17:47:10.332]             `<<-` <- base::`<<-`
[17:47:10.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.332]                   3L)]
[17:47:10.332]             }
[17:47:10.332]             function(cond) {
[17:47:10.332]                 is_error <- inherits(cond, "error")
[17:47:10.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.332]                   NULL)
[17:47:10.332]                 if (is_error) {
[17:47:10.332]                   sessionInformation <- function() {
[17:47:10.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.332]                       search = base::search(), system = base::Sys.info())
[17:47:10.332]                   }
[17:47:10.332]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.332]                     cond$call), session = sessionInformation(), 
[17:47:10.332]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.332]                   signalCondition(cond)
[17:47:10.332]                 }
[17:47:10.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.332]                 "immediateCondition"))) {
[17:47:10.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.332]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.332]                   if (TRUE && !signal) {
[17:47:10.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.332]                     {
[17:47:10.332]                       inherits <- base::inherits
[17:47:10.332]                       invokeRestart <- base::invokeRestart
[17:47:10.332]                       is.null <- base::is.null
[17:47:10.332]                       muffled <- FALSE
[17:47:10.332]                       if (inherits(cond, "message")) {
[17:47:10.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.332]                         if (muffled) 
[17:47:10.332]                           invokeRestart("muffleMessage")
[17:47:10.332]                       }
[17:47:10.332]                       else if (inherits(cond, "warning")) {
[17:47:10.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.332]                         if (muffled) 
[17:47:10.332]                           invokeRestart("muffleWarning")
[17:47:10.332]                       }
[17:47:10.332]                       else if (inherits(cond, "condition")) {
[17:47:10.332]                         if (!is.null(pattern)) {
[17:47:10.332]                           computeRestarts <- base::computeRestarts
[17:47:10.332]                           grepl <- base::grepl
[17:47:10.332]                           restarts <- computeRestarts(cond)
[17:47:10.332]                           for (restart in restarts) {
[17:47:10.332]                             name <- restart$name
[17:47:10.332]                             if (is.null(name)) 
[17:47:10.332]                               next
[17:47:10.332]                             if (!grepl(pattern, name)) 
[17:47:10.332]                               next
[17:47:10.332]                             invokeRestart(restart)
[17:47:10.332]                             muffled <- TRUE
[17:47:10.332]                             break
[17:47:10.332]                           }
[17:47:10.332]                         }
[17:47:10.332]                       }
[17:47:10.332]                       invisible(muffled)
[17:47:10.332]                     }
[17:47:10.332]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.332]                   }
[17:47:10.332]                 }
[17:47:10.332]                 else {
[17:47:10.332]                   if (TRUE) {
[17:47:10.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.332]                     {
[17:47:10.332]                       inherits <- base::inherits
[17:47:10.332]                       invokeRestart <- base::invokeRestart
[17:47:10.332]                       is.null <- base::is.null
[17:47:10.332]                       muffled <- FALSE
[17:47:10.332]                       if (inherits(cond, "message")) {
[17:47:10.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.332]                         if (muffled) 
[17:47:10.332]                           invokeRestart("muffleMessage")
[17:47:10.332]                       }
[17:47:10.332]                       else if (inherits(cond, "warning")) {
[17:47:10.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.332]                         if (muffled) 
[17:47:10.332]                           invokeRestart("muffleWarning")
[17:47:10.332]                       }
[17:47:10.332]                       else if (inherits(cond, "condition")) {
[17:47:10.332]                         if (!is.null(pattern)) {
[17:47:10.332]                           computeRestarts <- base::computeRestarts
[17:47:10.332]                           grepl <- base::grepl
[17:47:10.332]                           restarts <- computeRestarts(cond)
[17:47:10.332]                           for (restart in restarts) {
[17:47:10.332]                             name <- restart$name
[17:47:10.332]                             if (is.null(name)) 
[17:47:10.332]                               next
[17:47:10.332]                             if (!grepl(pattern, name)) 
[17:47:10.332]                               next
[17:47:10.332]                             invokeRestart(restart)
[17:47:10.332]                             muffled <- TRUE
[17:47:10.332]                             break
[17:47:10.332]                           }
[17:47:10.332]                         }
[17:47:10.332]                       }
[17:47:10.332]                       invisible(muffled)
[17:47:10.332]                     }
[17:47:10.332]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.332]                   }
[17:47:10.332]                 }
[17:47:10.332]             }
[17:47:10.332]         }))
[17:47:10.332]     }, error = function(ex) {
[17:47:10.332]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.332]                 ...future.rng), started = ...future.startTime, 
[17:47:10.332]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.332]             version = "1.8"), class = "FutureResult")
[17:47:10.332]     }, finally = {
[17:47:10.332]         if (!identical(...future.workdir, getwd())) 
[17:47:10.332]             setwd(...future.workdir)
[17:47:10.332]         {
[17:47:10.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.332]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.332]             }
[17:47:10.332]             base::options(...future.oldOptions)
[17:47:10.332]             if (.Platform$OS.type == "windows") {
[17:47:10.332]                 old_names <- names(...future.oldEnvVars)
[17:47:10.332]                 envs <- base::Sys.getenv()
[17:47:10.332]                 names <- names(envs)
[17:47:10.332]                 common <- intersect(names, old_names)
[17:47:10.332]                 added <- setdiff(names, old_names)
[17:47:10.332]                 removed <- setdiff(old_names, names)
[17:47:10.332]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.332]                   envs[common]]
[17:47:10.332]                 NAMES <- toupper(changed)
[17:47:10.332]                 args <- list()
[17:47:10.332]                 for (kk in seq_along(NAMES)) {
[17:47:10.332]                   name <- changed[[kk]]
[17:47:10.332]                   NAME <- NAMES[[kk]]
[17:47:10.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.332]                     next
[17:47:10.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.332]                 }
[17:47:10.332]                 NAMES <- toupper(added)
[17:47:10.332]                 for (kk in seq_along(NAMES)) {
[17:47:10.332]                   name <- added[[kk]]
[17:47:10.332]                   NAME <- NAMES[[kk]]
[17:47:10.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.332]                     next
[17:47:10.332]                   args[[name]] <- ""
[17:47:10.332]                 }
[17:47:10.332]                 NAMES <- toupper(removed)
[17:47:10.332]                 for (kk in seq_along(NAMES)) {
[17:47:10.332]                   name <- removed[[kk]]
[17:47:10.332]                   NAME <- NAMES[[kk]]
[17:47:10.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.332]                     next
[17:47:10.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.332]                 }
[17:47:10.332]                 if (length(args) > 0) 
[17:47:10.332]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.332]             }
[17:47:10.332]             else {
[17:47:10.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.332]             }
[17:47:10.332]             {
[17:47:10.332]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.332]                   0L) {
[17:47:10.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.332]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.332]                   base::options(opts)
[17:47:10.332]                 }
[17:47:10.332]                 {
[17:47:10.332]                   {
[17:47:10.332]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.332]                     NULL
[17:47:10.332]                   }
[17:47:10.332]                   options(future.plan = NULL)
[17:47:10.332]                   if (is.na(NA_character_)) 
[17:47:10.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.332]                     .init = FALSE)
[17:47:10.332]                 }
[17:47:10.332]             }
[17:47:10.332]         }
[17:47:10.332]     })
[17:47:10.332]     if (TRUE) {
[17:47:10.332]         base::sink(type = "output", split = FALSE)
[17:47:10.332]         if (TRUE) {
[17:47:10.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.332]         }
[17:47:10.332]         else {
[17:47:10.332]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.332]         }
[17:47:10.332]         base::close(...future.stdout)
[17:47:10.332]         ...future.stdout <- NULL
[17:47:10.332]     }
[17:47:10.332]     ...future.result$conditions <- ...future.conditions
[17:47:10.332]     ...future.result$finished <- base::Sys.time()
[17:47:10.332]     ...future.result
[17:47:10.332] }
[17:47:10.334] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:47:10.334] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:47:10.335] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:47:10.335] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:47:10.335] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:47:10.335] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:47:10.336] MultisessionFuture started
[17:47:10.336] - Launch lazy future ... done
[17:47:10.336] run() for ‘MultisessionFuture’ ... done
[17:47:10.336] result() for ClusterFuture ...
[17:47:10.336] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.336] - Validating connection of MultisessionFuture
[17:47:10.337] - received message: FutureResult
[17:47:10.337] - Received FutureResult
[17:47:10.337] - Erased future from FutureRegistry
[17:47:10.337] result() for ClusterFuture ...
[17:47:10.337] - result already collected: FutureResult
[17:47:10.338] result() for ClusterFuture ... done
[17:47:10.338] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.338] result() for ClusterFuture ... done
[17:47:10.338] result() for ClusterFuture ...
[17:47:10.338] - result already collected: FutureResult
[17:47:10.338] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.338] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.338] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.339] 
[17:47:10.339] Searching for globals ... DONE
[17:47:10.339] - globals: [0] <none>
[17:47:10.339] getGlobalsAndPackages() ... DONE
[17:47:10.339] run() for ‘Future’ ...
[17:47:10.340] - state: ‘created’
[17:47:10.340] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.354] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.354]   - Field: ‘node’
[17:47:10.354]   - Field: ‘label’
[17:47:10.354]   - Field: ‘local’
[17:47:10.354]   - Field: ‘owner’
[17:47:10.354]   - Field: ‘envir’
[17:47:10.354]   - Field: ‘workers’
[17:47:10.355]   - Field: ‘packages’
[17:47:10.355]   - Field: ‘gc’
[17:47:10.355]   - Field: ‘conditions’
[17:47:10.355]   - Field: ‘persistent’
[17:47:10.355]   - Field: ‘expr’
[17:47:10.355]   - Field: ‘uuid’
[17:47:10.355]   - Field: ‘seed’
[17:47:10.355]   - Field: ‘version’
[17:47:10.355]   - Field: ‘result’
[17:47:10.355]   - Field: ‘asynchronous’
[17:47:10.356]   - Field: ‘calls’
[17:47:10.356]   - Field: ‘globals’
[17:47:10.356]   - Field: ‘stdout’
[17:47:10.356]   - Field: ‘earlySignal’
[17:47:10.356]   - Field: ‘lazy’
[17:47:10.356]   - Field: ‘state’
[17:47:10.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.356] - Launch lazy future ...
[17:47:10.356] Packages needed by the future expression (n = 0): <none>
[17:47:10.357] Packages needed by future strategies (n = 0): <none>
[17:47:10.357] {
[17:47:10.357]     {
[17:47:10.357]         {
[17:47:10.357]             ...future.startTime <- base::Sys.time()
[17:47:10.357]             {
[17:47:10.357]                 {
[17:47:10.357]                   {
[17:47:10.357]                     {
[17:47:10.357]                       base::local({
[17:47:10.357]                         has_future <- base::requireNamespace("future", 
[17:47:10.357]                           quietly = TRUE)
[17:47:10.357]                         if (has_future) {
[17:47:10.357]                           ns <- base::getNamespace("future")
[17:47:10.357]                           version <- ns[[".package"]][["version"]]
[17:47:10.357]                           if (is.null(version)) 
[17:47:10.357]                             version <- utils::packageVersion("future")
[17:47:10.357]                         }
[17:47:10.357]                         else {
[17:47:10.357]                           version <- NULL
[17:47:10.357]                         }
[17:47:10.357]                         if (!has_future || version < "1.8.0") {
[17:47:10.357]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.357]                             "", base::R.version$version.string), 
[17:47:10.357]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.357]                               "release", "version")], collapse = " "), 
[17:47:10.357]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.357]                             info)
[17:47:10.357]                           info <- base::paste(info, collapse = "; ")
[17:47:10.357]                           if (!has_future) {
[17:47:10.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.357]                               info)
[17:47:10.357]                           }
[17:47:10.357]                           else {
[17:47:10.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.357]                               info, version)
[17:47:10.357]                           }
[17:47:10.357]                           base::stop(msg)
[17:47:10.357]                         }
[17:47:10.357]                       })
[17:47:10.357]                     }
[17:47:10.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.357]                     base::options(mc.cores = 1L)
[17:47:10.357]                   }
[17:47:10.357]                   ...future.strategy.old <- future::plan("list")
[17:47:10.357]                   options(future.plan = NULL)
[17:47:10.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.357]                 }
[17:47:10.357]                 ...future.workdir <- getwd()
[17:47:10.357]             }
[17:47:10.357]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.357]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.357]         }
[17:47:10.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.357]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.357]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.357]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.357]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.357]             base::names(...future.oldOptions))
[17:47:10.357]     }
[17:47:10.357]     if (FALSE) {
[17:47:10.357]     }
[17:47:10.357]     else {
[17:47:10.357]         if (TRUE) {
[17:47:10.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.357]                 open = "w")
[17:47:10.357]         }
[17:47:10.357]         else {
[17:47:10.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.357]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.357]         }
[17:47:10.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.357]             base::sink(type = "output", split = FALSE)
[17:47:10.357]             base::close(...future.stdout)
[17:47:10.357]         }, add = TRUE)
[17:47:10.357]     }
[17:47:10.357]     ...future.frame <- base::sys.nframe()
[17:47:10.357]     ...future.conditions <- base::list()
[17:47:10.357]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.357]     if (FALSE) {
[17:47:10.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.357]     }
[17:47:10.357]     ...future.result <- base::tryCatch({
[17:47:10.357]         base::withCallingHandlers({
[17:47:10.357]             ...future.value <- base::withVisible(base::local({
[17:47:10.357]                 ...future.makeSendCondition <- base::local({
[17:47:10.357]                   sendCondition <- NULL
[17:47:10.357]                   function(frame = 1L) {
[17:47:10.357]                     if (is.function(sendCondition)) 
[17:47:10.357]                       return(sendCondition)
[17:47:10.357]                     ns <- getNamespace("parallel")
[17:47:10.357]                     if (exists("sendData", mode = "function", 
[17:47:10.357]                       envir = ns)) {
[17:47:10.357]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.357]                         envir = ns)
[17:47:10.357]                       envir <- sys.frame(frame)
[17:47:10.357]                       master <- NULL
[17:47:10.357]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.357]                         !identical(envir, emptyenv())) {
[17:47:10.357]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.357]                           inherits = FALSE)) {
[17:47:10.357]                           master <- get("master", mode = "list", 
[17:47:10.357]                             envir = envir, inherits = FALSE)
[17:47:10.357]                           if (inherits(master, c("SOCKnode", 
[17:47:10.357]                             "SOCK0node"))) {
[17:47:10.357]                             sendCondition <<- function(cond) {
[17:47:10.357]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.357]                                 success = TRUE)
[17:47:10.357]                               parallel_sendData(master, data)
[17:47:10.357]                             }
[17:47:10.357]                             return(sendCondition)
[17:47:10.357]                           }
[17:47:10.357]                         }
[17:47:10.357]                         frame <- frame + 1L
[17:47:10.357]                         envir <- sys.frame(frame)
[17:47:10.357]                       }
[17:47:10.357]                     }
[17:47:10.357]                     sendCondition <<- function(cond) NULL
[17:47:10.357]                   }
[17:47:10.357]                 })
[17:47:10.357]                 withCallingHandlers({
[17:47:10.357]                   1
[17:47:10.357]                 }, immediateCondition = function(cond) {
[17:47:10.357]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.357]                   sendCondition(cond)
[17:47:10.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.357]                   {
[17:47:10.357]                     inherits <- base::inherits
[17:47:10.357]                     invokeRestart <- base::invokeRestart
[17:47:10.357]                     is.null <- base::is.null
[17:47:10.357]                     muffled <- FALSE
[17:47:10.357]                     if (inherits(cond, "message")) {
[17:47:10.357]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.357]                       if (muffled) 
[17:47:10.357]                         invokeRestart("muffleMessage")
[17:47:10.357]                     }
[17:47:10.357]                     else if (inherits(cond, "warning")) {
[17:47:10.357]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.357]                       if (muffled) 
[17:47:10.357]                         invokeRestart("muffleWarning")
[17:47:10.357]                     }
[17:47:10.357]                     else if (inherits(cond, "condition")) {
[17:47:10.357]                       if (!is.null(pattern)) {
[17:47:10.357]                         computeRestarts <- base::computeRestarts
[17:47:10.357]                         grepl <- base::grepl
[17:47:10.357]                         restarts <- computeRestarts(cond)
[17:47:10.357]                         for (restart in restarts) {
[17:47:10.357]                           name <- restart$name
[17:47:10.357]                           if (is.null(name)) 
[17:47:10.357]                             next
[17:47:10.357]                           if (!grepl(pattern, name)) 
[17:47:10.357]                             next
[17:47:10.357]                           invokeRestart(restart)
[17:47:10.357]                           muffled <- TRUE
[17:47:10.357]                           break
[17:47:10.357]                         }
[17:47:10.357]                       }
[17:47:10.357]                     }
[17:47:10.357]                     invisible(muffled)
[17:47:10.357]                   }
[17:47:10.357]                   muffleCondition(cond)
[17:47:10.357]                 })
[17:47:10.357]             }))
[17:47:10.357]             future::FutureResult(value = ...future.value$value, 
[17:47:10.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.357]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.357]                     ...future.globalenv.names))
[17:47:10.357]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.357]         }, condition = base::local({
[17:47:10.357]             c <- base::c
[17:47:10.357]             inherits <- base::inherits
[17:47:10.357]             invokeRestart <- base::invokeRestart
[17:47:10.357]             length <- base::length
[17:47:10.357]             list <- base::list
[17:47:10.357]             seq.int <- base::seq.int
[17:47:10.357]             signalCondition <- base::signalCondition
[17:47:10.357]             sys.calls <- base::sys.calls
[17:47:10.357]             `[[` <- base::`[[`
[17:47:10.357]             `+` <- base::`+`
[17:47:10.357]             `<<-` <- base::`<<-`
[17:47:10.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.357]                   3L)]
[17:47:10.357]             }
[17:47:10.357]             function(cond) {
[17:47:10.357]                 is_error <- inherits(cond, "error")
[17:47:10.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.357]                   NULL)
[17:47:10.357]                 if (is_error) {
[17:47:10.357]                   sessionInformation <- function() {
[17:47:10.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.357]                       search = base::search(), system = base::Sys.info())
[17:47:10.357]                   }
[17:47:10.357]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.357]                     cond$call), session = sessionInformation(), 
[17:47:10.357]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.357]                   signalCondition(cond)
[17:47:10.357]                 }
[17:47:10.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.357]                 "immediateCondition"))) {
[17:47:10.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.357]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.357]                   if (TRUE && !signal) {
[17:47:10.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.357]                     {
[17:47:10.357]                       inherits <- base::inherits
[17:47:10.357]                       invokeRestart <- base::invokeRestart
[17:47:10.357]                       is.null <- base::is.null
[17:47:10.357]                       muffled <- FALSE
[17:47:10.357]                       if (inherits(cond, "message")) {
[17:47:10.357]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.357]                         if (muffled) 
[17:47:10.357]                           invokeRestart("muffleMessage")
[17:47:10.357]                       }
[17:47:10.357]                       else if (inherits(cond, "warning")) {
[17:47:10.357]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.357]                         if (muffled) 
[17:47:10.357]                           invokeRestart("muffleWarning")
[17:47:10.357]                       }
[17:47:10.357]                       else if (inherits(cond, "condition")) {
[17:47:10.357]                         if (!is.null(pattern)) {
[17:47:10.357]                           computeRestarts <- base::computeRestarts
[17:47:10.357]                           grepl <- base::grepl
[17:47:10.357]                           restarts <- computeRestarts(cond)
[17:47:10.357]                           for (restart in restarts) {
[17:47:10.357]                             name <- restart$name
[17:47:10.357]                             if (is.null(name)) 
[17:47:10.357]                               next
[17:47:10.357]                             if (!grepl(pattern, name)) 
[17:47:10.357]                               next
[17:47:10.357]                             invokeRestart(restart)
[17:47:10.357]                             muffled <- TRUE
[17:47:10.357]                             break
[17:47:10.357]                           }
[17:47:10.357]                         }
[17:47:10.357]                       }
[17:47:10.357]                       invisible(muffled)
[17:47:10.357]                     }
[17:47:10.357]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.357]                   }
[17:47:10.357]                 }
[17:47:10.357]                 else {
[17:47:10.357]                   if (TRUE) {
[17:47:10.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.357]                     {
[17:47:10.357]                       inherits <- base::inherits
[17:47:10.357]                       invokeRestart <- base::invokeRestart
[17:47:10.357]                       is.null <- base::is.null
[17:47:10.357]                       muffled <- FALSE
[17:47:10.357]                       if (inherits(cond, "message")) {
[17:47:10.357]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.357]                         if (muffled) 
[17:47:10.357]                           invokeRestart("muffleMessage")
[17:47:10.357]                       }
[17:47:10.357]                       else if (inherits(cond, "warning")) {
[17:47:10.357]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.357]                         if (muffled) 
[17:47:10.357]                           invokeRestart("muffleWarning")
[17:47:10.357]                       }
[17:47:10.357]                       else if (inherits(cond, "condition")) {
[17:47:10.357]                         if (!is.null(pattern)) {
[17:47:10.357]                           computeRestarts <- base::computeRestarts
[17:47:10.357]                           grepl <- base::grepl
[17:47:10.357]                           restarts <- computeRestarts(cond)
[17:47:10.357]                           for (restart in restarts) {
[17:47:10.357]                             name <- restart$name
[17:47:10.357]                             if (is.null(name)) 
[17:47:10.357]                               next
[17:47:10.357]                             if (!grepl(pattern, name)) 
[17:47:10.357]                               next
[17:47:10.357]                             invokeRestart(restart)
[17:47:10.357]                             muffled <- TRUE
[17:47:10.357]                             break
[17:47:10.357]                           }
[17:47:10.357]                         }
[17:47:10.357]                       }
[17:47:10.357]                       invisible(muffled)
[17:47:10.357]                     }
[17:47:10.357]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.357]                   }
[17:47:10.357]                 }
[17:47:10.357]             }
[17:47:10.357]         }))
[17:47:10.357]     }, error = function(ex) {
[17:47:10.357]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.357]                 ...future.rng), started = ...future.startTime, 
[17:47:10.357]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.357]             version = "1.8"), class = "FutureResult")
[17:47:10.357]     }, finally = {
[17:47:10.357]         if (!identical(...future.workdir, getwd())) 
[17:47:10.357]             setwd(...future.workdir)
[17:47:10.357]         {
[17:47:10.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.357]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.357]             }
[17:47:10.357]             base::options(...future.oldOptions)
[17:47:10.357]             if (.Platform$OS.type == "windows") {
[17:47:10.357]                 old_names <- names(...future.oldEnvVars)
[17:47:10.357]                 envs <- base::Sys.getenv()
[17:47:10.357]                 names <- names(envs)
[17:47:10.357]                 common <- intersect(names, old_names)
[17:47:10.357]                 added <- setdiff(names, old_names)
[17:47:10.357]                 removed <- setdiff(old_names, names)
[17:47:10.357]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.357]                   envs[common]]
[17:47:10.357]                 NAMES <- toupper(changed)
[17:47:10.357]                 args <- list()
[17:47:10.357]                 for (kk in seq_along(NAMES)) {
[17:47:10.357]                   name <- changed[[kk]]
[17:47:10.357]                   NAME <- NAMES[[kk]]
[17:47:10.357]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.357]                     next
[17:47:10.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.357]                 }
[17:47:10.357]                 NAMES <- toupper(added)
[17:47:10.357]                 for (kk in seq_along(NAMES)) {
[17:47:10.357]                   name <- added[[kk]]
[17:47:10.357]                   NAME <- NAMES[[kk]]
[17:47:10.357]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.357]                     next
[17:47:10.357]                   args[[name]] <- ""
[17:47:10.357]                 }
[17:47:10.357]                 NAMES <- toupper(removed)
[17:47:10.357]                 for (kk in seq_along(NAMES)) {
[17:47:10.357]                   name <- removed[[kk]]
[17:47:10.357]                   NAME <- NAMES[[kk]]
[17:47:10.357]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.357]                     next
[17:47:10.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.357]                 }
[17:47:10.357]                 if (length(args) > 0) 
[17:47:10.357]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.357]             }
[17:47:10.357]             else {
[17:47:10.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.357]             }
[17:47:10.357]             {
[17:47:10.357]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.357]                   0L) {
[17:47:10.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.357]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.357]                   base::options(opts)
[17:47:10.357]                 }
[17:47:10.357]                 {
[17:47:10.357]                   {
[17:47:10.357]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.357]                     NULL
[17:47:10.357]                   }
[17:47:10.357]                   options(future.plan = NULL)
[17:47:10.357]                   if (is.na(NA_character_)) 
[17:47:10.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.357]                     .init = FALSE)
[17:47:10.357]                 }
[17:47:10.357]             }
[17:47:10.357]         }
[17:47:10.357]     })
[17:47:10.357]     if (TRUE) {
[17:47:10.357]         base::sink(type = "output", split = FALSE)
[17:47:10.357]         if (TRUE) {
[17:47:10.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.357]         }
[17:47:10.357]         else {
[17:47:10.357]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.357]         }
[17:47:10.357]         base::close(...future.stdout)
[17:47:10.357]         ...future.stdout <- NULL
[17:47:10.357]     }
[17:47:10.357]     ...future.result$conditions <- ...future.conditions
[17:47:10.357]     ...future.result$finished <- base::Sys.time()
[17:47:10.357]     ...future.result
[17:47:10.357] }
[17:47:10.360] MultisessionFuture started
[17:47:10.360] - Launch lazy future ... done
[17:47:10.360] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.360] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.360] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.361] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:10.361] Searching for globals ... DONE
[17:47:10.361] Resolving globals: TRUE
[17:47:10.361] Resolving any globals that are futures ...
[17:47:10.361] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:10.362] Resolving any globals that are futures ... DONE
[17:47:10.362] Resolving futures part of globals (recursively) ...
[17:47:10.362] resolve() on list ...
[17:47:10.362]  recursive: 99
[17:47:10.362]  length: 1
[17:47:10.362]  elements: ‘a’
[17:47:10.363] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.363] - Validating connection of MultisessionFuture
[17:47:10.363] - received message: FutureResult
[17:47:10.363] - Received FutureResult
[17:47:10.363] - Erased future from FutureRegistry
[17:47:10.363] result() for ClusterFuture ...
[17:47:10.364] - result already collected: FutureResult
[17:47:10.364] result() for ClusterFuture ... done
[17:47:10.364] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.364] Future #1
[17:47:10.364] result() for ClusterFuture ...
[17:47:10.364] - result already collected: FutureResult
[17:47:10.364] result() for ClusterFuture ... done
[17:47:10.364] result() for ClusterFuture ...
[17:47:10.364] - result already collected: FutureResult
[17:47:10.364] result() for ClusterFuture ... done
[17:47:10.364] A MultisessionFuture was resolved
[17:47:10.365]  length: 0 (resolved future 1)
[17:47:10.365] resolve() on list ... DONE
[17:47:10.365] - globals: [1] ‘a’
[17:47:10.365] Resolving futures part of globals (recursively) ... DONE
[17:47:10.367] The total size of the 1 globals is 1.57 MiB (1647200 bytes)
[17:47:10.367] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:47:10.367] - globals: [1] ‘a’
[17:47:10.367] - packages: [1] ‘future’
[17:47:10.367] getGlobalsAndPackages() ... DONE
[17:47:10.368] run() for ‘Future’ ...
[17:47:10.368] - state: ‘created’
[17:47:10.368] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.381] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.381]   - Field: ‘node’
[17:47:10.381]   - Field: ‘label’
[17:47:10.381]   - Field: ‘local’
[17:47:10.382]   - Field: ‘owner’
[17:47:10.382]   - Field: ‘envir’
[17:47:10.382]   - Field: ‘workers’
[17:47:10.382]   - Field: ‘packages’
[17:47:10.382]   - Field: ‘gc’
[17:47:10.382]   - Field: ‘conditions’
[17:47:10.382]   - Field: ‘persistent’
[17:47:10.382]   - Field: ‘expr’
[17:47:10.382]   - Field: ‘uuid’
[17:47:10.382]   - Field: ‘seed’
[17:47:10.382]   - Field: ‘version’
[17:47:10.383]   - Field: ‘result’
[17:47:10.383]   - Field: ‘asynchronous’
[17:47:10.383]   - Field: ‘calls’
[17:47:10.383]   - Field: ‘globals’
[17:47:10.383]   - Field: ‘stdout’
[17:47:10.383]   - Field: ‘earlySignal’
[17:47:10.383]   - Field: ‘lazy’
[17:47:10.383]   - Field: ‘state’
[17:47:10.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.383] - Launch lazy future ...
[17:47:10.384] Packages needed by the future expression (n = 1): ‘future’
[17:47:10.384] Packages needed by future strategies (n = 0): <none>
[17:47:10.384] {
[17:47:10.384]     {
[17:47:10.384]         {
[17:47:10.384]             ...future.startTime <- base::Sys.time()
[17:47:10.384]             {
[17:47:10.384]                 {
[17:47:10.384]                   {
[17:47:10.384]                     {
[17:47:10.384]                       {
[17:47:10.384]                         base::local({
[17:47:10.384]                           has_future <- base::requireNamespace("future", 
[17:47:10.384]                             quietly = TRUE)
[17:47:10.384]                           if (has_future) {
[17:47:10.384]                             ns <- base::getNamespace("future")
[17:47:10.384]                             version <- ns[[".package"]][["version"]]
[17:47:10.384]                             if (is.null(version)) 
[17:47:10.384]                               version <- utils::packageVersion("future")
[17:47:10.384]                           }
[17:47:10.384]                           else {
[17:47:10.384]                             version <- NULL
[17:47:10.384]                           }
[17:47:10.384]                           if (!has_future || version < "1.8.0") {
[17:47:10.384]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.384]                               "", base::R.version$version.string), 
[17:47:10.384]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:10.384]                                 base::R.version$platform, 8 * 
[17:47:10.384]                                   base::.Machine$sizeof.pointer), 
[17:47:10.384]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.384]                                 "release", "version")], collapse = " "), 
[17:47:10.384]                               hostname = base::Sys.info()[["nodename"]])
[17:47:10.384]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.384]                               info)
[17:47:10.384]                             info <- base::paste(info, collapse = "; ")
[17:47:10.384]                             if (!has_future) {
[17:47:10.384]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.384]                                 info)
[17:47:10.384]                             }
[17:47:10.384]                             else {
[17:47:10.384]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.384]                                 info, version)
[17:47:10.384]                             }
[17:47:10.384]                             base::stop(msg)
[17:47:10.384]                           }
[17:47:10.384]                         })
[17:47:10.384]                       }
[17:47:10.384]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.384]                       base::options(mc.cores = 1L)
[17:47:10.384]                     }
[17:47:10.384]                     base::local({
[17:47:10.384]                       for (pkg in "future") {
[17:47:10.384]                         base::loadNamespace(pkg)
[17:47:10.384]                         base::library(pkg, character.only = TRUE)
[17:47:10.384]                       }
[17:47:10.384]                     })
[17:47:10.384]                   }
[17:47:10.384]                   ...future.strategy.old <- future::plan("list")
[17:47:10.384]                   options(future.plan = NULL)
[17:47:10.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.384]                 }
[17:47:10.384]                 ...future.workdir <- getwd()
[17:47:10.384]             }
[17:47:10.384]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.384]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.384]         }
[17:47:10.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.384]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.384]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.384]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.384]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.384]             base::names(...future.oldOptions))
[17:47:10.384]     }
[17:47:10.384]     if (FALSE) {
[17:47:10.384]     }
[17:47:10.384]     else {
[17:47:10.384]         if (TRUE) {
[17:47:10.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.384]                 open = "w")
[17:47:10.384]         }
[17:47:10.384]         else {
[17:47:10.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.384]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.384]         }
[17:47:10.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.384]             base::sink(type = "output", split = FALSE)
[17:47:10.384]             base::close(...future.stdout)
[17:47:10.384]         }, add = TRUE)
[17:47:10.384]     }
[17:47:10.384]     ...future.frame <- base::sys.nframe()
[17:47:10.384]     ...future.conditions <- base::list()
[17:47:10.384]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.384]     if (FALSE) {
[17:47:10.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.384]     }
[17:47:10.384]     ...future.result <- base::tryCatch({
[17:47:10.384]         base::withCallingHandlers({
[17:47:10.384]             ...future.value <- base::withVisible(base::local({
[17:47:10.384]                 ...future.makeSendCondition <- base::local({
[17:47:10.384]                   sendCondition <- NULL
[17:47:10.384]                   function(frame = 1L) {
[17:47:10.384]                     if (is.function(sendCondition)) 
[17:47:10.384]                       return(sendCondition)
[17:47:10.384]                     ns <- getNamespace("parallel")
[17:47:10.384]                     if (exists("sendData", mode = "function", 
[17:47:10.384]                       envir = ns)) {
[17:47:10.384]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.384]                         envir = ns)
[17:47:10.384]                       envir <- sys.frame(frame)
[17:47:10.384]                       master <- NULL
[17:47:10.384]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.384]                         !identical(envir, emptyenv())) {
[17:47:10.384]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.384]                           inherits = FALSE)) {
[17:47:10.384]                           master <- get("master", mode = "list", 
[17:47:10.384]                             envir = envir, inherits = FALSE)
[17:47:10.384]                           if (inherits(master, c("SOCKnode", 
[17:47:10.384]                             "SOCK0node"))) {
[17:47:10.384]                             sendCondition <<- function(cond) {
[17:47:10.384]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.384]                                 success = TRUE)
[17:47:10.384]                               parallel_sendData(master, data)
[17:47:10.384]                             }
[17:47:10.384]                             return(sendCondition)
[17:47:10.384]                           }
[17:47:10.384]                         }
[17:47:10.384]                         frame <- frame + 1L
[17:47:10.384]                         envir <- sys.frame(frame)
[17:47:10.384]                       }
[17:47:10.384]                     }
[17:47:10.384]                     sendCondition <<- function(cond) NULL
[17:47:10.384]                   }
[17:47:10.384]                 })
[17:47:10.384]                 withCallingHandlers({
[17:47:10.384]                   value(a) + 1
[17:47:10.384]                 }, immediateCondition = function(cond) {
[17:47:10.384]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.384]                   sendCondition(cond)
[17:47:10.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.384]                   {
[17:47:10.384]                     inherits <- base::inherits
[17:47:10.384]                     invokeRestart <- base::invokeRestart
[17:47:10.384]                     is.null <- base::is.null
[17:47:10.384]                     muffled <- FALSE
[17:47:10.384]                     if (inherits(cond, "message")) {
[17:47:10.384]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.384]                       if (muffled) 
[17:47:10.384]                         invokeRestart("muffleMessage")
[17:47:10.384]                     }
[17:47:10.384]                     else if (inherits(cond, "warning")) {
[17:47:10.384]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.384]                       if (muffled) 
[17:47:10.384]                         invokeRestart("muffleWarning")
[17:47:10.384]                     }
[17:47:10.384]                     else if (inherits(cond, "condition")) {
[17:47:10.384]                       if (!is.null(pattern)) {
[17:47:10.384]                         computeRestarts <- base::computeRestarts
[17:47:10.384]                         grepl <- base::grepl
[17:47:10.384]                         restarts <- computeRestarts(cond)
[17:47:10.384]                         for (restart in restarts) {
[17:47:10.384]                           name <- restart$name
[17:47:10.384]                           if (is.null(name)) 
[17:47:10.384]                             next
[17:47:10.384]                           if (!grepl(pattern, name)) 
[17:47:10.384]                             next
[17:47:10.384]                           invokeRestart(restart)
[17:47:10.384]                           muffled <- TRUE
[17:47:10.384]                           break
[17:47:10.384]                         }
[17:47:10.384]                       }
[17:47:10.384]                     }
[17:47:10.384]                     invisible(muffled)
[17:47:10.384]                   }
[17:47:10.384]                   muffleCondition(cond)
[17:47:10.384]                 })
[17:47:10.384]             }))
[17:47:10.384]             future::FutureResult(value = ...future.value$value, 
[17:47:10.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.384]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.384]                     ...future.globalenv.names))
[17:47:10.384]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.384]         }, condition = base::local({
[17:47:10.384]             c <- base::c
[17:47:10.384]             inherits <- base::inherits
[17:47:10.384]             invokeRestart <- base::invokeRestart
[17:47:10.384]             length <- base::length
[17:47:10.384]             list <- base::list
[17:47:10.384]             seq.int <- base::seq.int
[17:47:10.384]             signalCondition <- base::signalCondition
[17:47:10.384]             sys.calls <- base::sys.calls
[17:47:10.384]             `[[` <- base::`[[`
[17:47:10.384]             `+` <- base::`+`
[17:47:10.384]             `<<-` <- base::`<<-`
[17:47:10.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.384]                   3L)]
[17:47:10.384]             }
[17:47:10.384]             function(cond) {
[17:47:10.384]                 is_error <- inherits(cond, "error")
[17:47:10.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.384]                   NULL)
[17:47:10.384]                 if (is_error) {
[17:47:10.384]                   sessionInformation <- function() {
[17:47:10.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.384]                       search = base::search(), system = base::Sys.info())
[17:47:10.384]                   }
[17:47:10.384]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.384]                     cond$call), session = sessionInformation(), 
[17:47:10.384]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.384]                   signalCondition(cond)
[17:47:10.384]                 }
[17:47:10.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.384]                 "immediateCondition"))) {
[17:47:10.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.384]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.384]                   if (TRUE && !signal) {
[17:47:10.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.384]                     {
[17:47:10.384]                       inherits <- base::inherits
[17:47:10.384]                       invokeRestart <- base::invokeRestart
[17:47:10.384]                       is.null <- base::is.null
[17:47:10.384]                       muffled <- FALSE
[17:47:10.384]                       if (inherits(cond, "message")) {
[17:47:10.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.384]                         if (muffled) 
[17:47:10.384]                           invokeRestart("muffleMessage")
[17:47:10.384]                       }
[17:47:10.384]                       else if (inherits(cond, "warning")) {
[17:47:10.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.384]                         if (muffled) 
[17:47:10.384]                           invokeRestart("muffleWarning")
[17:47:10.384]                       }
[17:47:10.384]                       else if (inherits(cond, "condition")) {
[17:47:10.384]                         if (!is.null(pattern)) {
[17:47:10.384]                           computeRestarts <- base::computeRestarts
[17:47:10.384]                           grepl <- base::grepl
[17:47:10.384]                           restarts <- computeRestarts(cond)
[17:47:10.384]                           for (restart in restarts) {
[17:47:10.384]                             name <- restart$name
[17:47:10.384]                             if (is.null(name)) 
[17:47:10.384]                               next
[17:47:10.384]                             if (!grepl(pattern, name)) 
[17:47:10.384]                               next
[17:47:10.384]                             invokeRestart(restart)
[17:47:10.384]                             muffled <- TRUE
[17:47:10.384]                             break
[17:47:10.384]                           }
[17:47:10.384]                         }
[17:47:10.384]                       }
[17:47:10.384]                       invisible(muffled)
[17:47:10.384]                     }
[17:47:10.384]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.384]                   }
[17:47:10.384]                 }
[17:47:10.384]                 else {
[17:47:10.384]                   if (TRUE) {
[17:47:10.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.384]                     {
[17:47:10.384]                       inherits <- base::inherits
[17:47:10.384]                       invokeRestart <- base::invokeRestart
[17:47:10.384]                       is.null <- base::is.null
[17:47:10.384]                       muffled <- FALSE
[17:47:10.384]                       if (inherits(cond, "message")) {
[17:47:10.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.384]                         if (muffled) 
[17:47:10.384]                           invokeRestart("muffleMessage")
[17:47:10.384]                       }
[17:47:10.384]                       else if (inherits(cond, "warning")) {
[17:47:10.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.384]                         if (muffled) 
[17:47:10.384]                           invokeRestart("muffleWarning")
[17:47:10.384]                       }
[17:47:10.384]                       else if (inherits(cond, "condition")) {
[17:47:10.384]                         if (!is.null(pattern)) {
[17:47:10.384]                           computeRestarts <- base::computeRestarts
[17:47:10.384]                           grepl <- base::grepl
[17:47:10.384]                           restarts <- computeRestarts(cond)
[17:47:10.384]                           for (restart in restarts) {
[17:47:10.384]                             name <- restart$name
[17:47:10.384]                             if (is.null(name)) 
[17:47:10.384]                               next
[17:47:10.384]                             if (!grepl(pattern, name)) 
[17:47:10.384]                               next
[17:47:10.384]                             invokeRestart(restart)
[17:47:10.384]                             muffled <- TRUE
[17:47:10.384]                             break
[17:47:10.384]                           }
[17:47:10.384]                         }
[17:47:10.384]                       }
[17:47:10.384]                       invisible(muffled)
[17:47:10.384]                     }
[17:47:10.384]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.384]                   }
[17:47:10.384]                 }
[17:47:10.384]             }
[17:47:10.384]         }))
[17:47:10.384]     }, error = function(ex) {
[17:47:10.384]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.384]                 ...future.rng), started = ...future.startTime, 
[17:47:10.384]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.384]             version = "1.8"), class = "FutureResult")
[17:47:10.384]     }, finally = {
[17:47:10.384]         if (!identical(...future.workdir, getwd())) 
[17:47:10.384]             setwd(...future.workdir)
[17:47:10.384]         {
[17:47:10.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.384]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.384]             }
[17:47:10.384]             base::options(...future.oldOptions)
[17:47:10.384]             if (.Platform$OS.type == "windows") {
[17:47:10.384]                 old_names <- names(...future.oldEnvVars)
[17:47:10.384]                 envs <- base::Sys.getenv()
[17:47:10.384]                 names <- names(envs)
[17:47:10.384]                 common <- intersect(names, old_names)
[17:47:10.384]                 added <- setdiff(names, old_names)
[17:47:10.384]                 removed <- setdiff(old_names, names)
[17:47:10.384]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.384]                   envs[common]]
[17:47:10.384]                 NAMES <- toupper(changed)
[17:47:10.384]                 args <- list()
[17:47:10.384]                 for (kk in seq_along(NAMES)) {
[17:47:10.384]                   name <- changed[[kk]]
[17:47:10.384]                   NAME <- NAMES[[kk]]
[17:47:10.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.384]                     next
[17:47:10.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.384]                 }
[17:47:10.384]                 NAMES <- toupper(added)
[17:47:10.384]                 for (kk in seq_along(NAMES)) {
[17:47:10.384]                   name <- added[[kk]]
[17:47:10.384]                   NAME <- NAMES[[kk]]
[17:47:10.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.384]                     next
[17:47:10.384]                   args[[name]] <- ""
[17:47:10.384]                 }
[17:47:10.384]                 NAMES <- toupper(removed)
[17:47:10.384]                 for (kk in seq_along(NAMES)) {
[17:47:10.384]                   name <- removed[[kk]]
[17:47:10.384]                   NAME <- NAMES[[kk]]
[17:47:10.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.384]                     next
[17:47:10.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.384]                 }
[17:47:10.384]                 if (length(args) > 0) 
[17:47:10.384]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.384]             }
[17:47:10.384]             else {
[17:47:10.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.384]             }
[17:47:10.384]             {
[17:47:10.384]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.384]                   0L) {
[17:47:10.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.384]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.384]                   base::options(opts)
[17:47:10.384]                 }
[17:47:10.384]                 {
[17:47:10.384]                   {
[17:47:10.384]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.384]                     NULL
[17:47:10.384]                   }
[17:47:10.384]                   options(future.plan = NULL)
[17:47:10.384]                   if (is.na(NA_character_)) 
[17:47:10.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.384]                     .init = FALSE)
[17:47:10.384]                 }
[17:47:10.384]             }
[17:47:10.384]         }
[17:47:10.384]     })
[17:47:10.384]     if (TRUE) {
[17:47:10.384]         base::sink(type = "output", split = FALSE)
[17:47:10.384]         if (TRUE) {
[17:47:10.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.384]         }
[17:47:10.384]         else {
[17:47:10.384]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.384]         }
[17:47:10.384]         base::close(...future.stdout)
[17:47:10.384]         ...future.stdout <- NULL
[17:47:10.384]     }
[17:47:10.384]     ...future.result$conditions <- ...future.conditions
[17:47:10.384]     ...future.result$finished <- base::Sys.time()
[17:47:10.384]     ...future.result
[17:47:10.384] }
[17:47:10.387] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:47:10.389] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:47:10.440] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:47:10.440] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:47:10.440] MultisessionFuture started
[17:47:10.440] - Launch lazy future ... done
[17:47:10.441] run() for ‘MultisessionFuture’ ... done
[17:47:10.441] result() for ClusterFuture ...
[17:47:10.441] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.441] - Validating connection of MultisessionFuture
[17:47:10.489] - received message: FutureResult
[17:47:10.489] - Received FutureResult
[17:47:10.489] - Erased future from FutureRegistry
[17:47:10.489] result() for ClusterFuture ...
[17:47:10.489] - result already collected: FutureResult
[17:47:10.489] result() for ClusterFuture ... done
[17:47:10.489] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.489] result() for ClusterFuture ... done
[17:47:10.490] result() for ClusterFuture ...
[17:47:10.490] - result already collected: FutureResult
[17:47:10.490] result() for ClusterFuture ... done
value(b) = 2
[17:47:10.490] result() for ClusterFuture ...
[17:47:10.490] - result already collected: FutureResult
[17:47:10.490] result() for ClusterFuture ... done
[17:47:10.490] result() for ClusterFuture ...
[17:47:10.490] - result already collected: FutureResult
[17:47:10.490] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.491] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.491] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.491] 
[17:47:10.491] Searching for globals ... DONE
[17:47:10.492] - globals: [0] <none>
[17:47:10.492] getGlobalsAndPackages() ... DONE
[17:47:10.492] run() for ‘Future’ ...
[17:47:10.492] - state: ‘created’
[17:47:10.492] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.506] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.506] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.506]   - Field: ‘node’
[17:47:10.506]   - Field: ‘label’
[17:47:10.506]   - Field: ‘local’
[17:47:10.506]   - Field: ‘owner’
[17:47:10.506]   - Field: ‘envir’
[17:47:10.506]   - Field: ‘workers’
[17:47:10.507]   - Field: ‘packages’
[17:47:10.507]   - Field: ‘gc’
[17:47:10.507]   - Field: ‘conditions’
[17:47:10.507]   - Field: ‘persistent’
[17:47:10.507]   - Field: ‘expr’
[17:47:10.507]   - Field: ‘uuid’
[17:47:10.507]   - Field: ‘seed’
[17:47:10.507]   - Field: ‘version’
[17:47:10.507]   - Field: ‘result’
[17:47:10.507]   - Field: ‘asynchronous’
[17:47:10.508]   - Field: ‘calls’
[17:47:10.508]   - Field: ‘globals’
[17:47:10.508]   - Field: ‘stdout’
[17:47:10.508]   - Field: ‘earlySignal’
[17:47:10.508]   - Field: ‘lazy’
[17:47:10.508]   - Field: ‘state’
[17:47:10.508] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.508] - Launch lazy future ...
[17:47:10.508] Packages needed by the future expression (n = 0): <none>
[17:47:10.509] Packages needed by future strategies (n = 0): <none>
[17:47:10.509] {
[17:47:10.509]     {
[17:47:10.509]         {
[17:47:10.509]             ...future.startTime <- base::Sys.time()
[17:47:10.509]             {
[17:47:10.509]                 {
[17:47:10.509]                   {
[17:47:10.509]                     {
[17:47:10.509]                       base::local({
[17:47:10.509]                         has_future <- base::requireNamespace("future", 
[17:47:10.509]                           quietly = TRUE)
[17:47:10.509]                         if (has_future) {
[17:47:10.509]                           ns <- base::getNamespace("future")
[17:47:10.509]                           version <- ns[[".package"]][["version"]]
[17:47:10.509]                           if (is.null(version)) 
[17:47:10.509]                             version <- utils::packageVersion("future")
[17:47:10.509]                         }
[17:47:10.509]                         else {
[17:47:10.509]                           version <- NULL
[17:47:10.509]                         }
[17:47:10.509]                         if (!has_future || version < "1.8.0") {
[17:47:10.509]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.509]                             "", base::R.version$version.string), 
[17:47:10.509]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.509]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.509]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.509]                               "release", "version")], collapse = " "), 
[17:47:10.509]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.509]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.509]                             info)
[17:47:10.509]                           info <- base::paste(info, collapse = "; ")
[17:47:10.509]                           if (!has_future) {
[17:47:10.509]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.509]                               info)
[17:47:10.509]                           }
[17:47:10.509]                           else {
[17:47:10.509]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.509]                               info, version)
[17:47:10.509]                           }
[17:47:10.509]                           base::stop(msg)
[17:47:10.509]                         }
[17:47:10.509]                       })
[17:47:10.509]                     }
[17:47:10.509]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.509]                     base::options(mc.cores = 1L)
[17:47:10.509]                   }
[17:47:10.509]                   ...future.strategy.old <- future::plan("list")
[17:47:10.509]                   options(future.plan = NULL)
[17:47:10.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.509]                 }
[17:47:10.509]                 ...future.workdir <- getwd()
[17:47:10.509]             }
[17:47:10.509]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.509]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.509]         }
[17:47:10.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.509]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.509]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.509]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.509]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.509]             base::names(...future.oldOptions))
[17:47:10.509]     }
[17:47:10.509]     if (FALSE) {
[17:47:10.509]     }
[17:47:10.509]     else {
[17:47:10.509]         if (TRUE) {
[17:47:10.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.509]                 open = "w")
[17:47:10.509]         }
[17:47:10.509]         else {
[17:47:10.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.509]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.509]         }
[17:47:10.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.509]             base::sink(type = "output", split = FALSE)
[17:47:10.509]             base::close(...future.stdout)
[17:47:10.509]         }, add = TRUE)
[17:47:10.509]     }
[17:47:10.509]     ...future.frame <- base::sys.nframe()
[17:47:10.509]     ...future.conditions <- base::list()
[17:47:10.509]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.509]     if (FALSE) {
[17:47:10.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.509]     }
[17:47:10.509]     ...future.result <- base::tryCatch({
[17:47:10.509]         base::withCallingHandlers({
[17:47:10.509]             ...future.value <- base::withVisible(base::local({
[17:47:10.509]                 ...future.makeSendCondition <- base::local({
[17:47:10.509]                   sendCondition <- NULL
[17:47:10.509]                   function(frame = 1L) {
[17:47:10.509]                     if (is.function(sendCondition)) 
[17:47:10.509]                       return(sendCondition)
[17:47:10.509]                     ns <- getNamespace("parallel")
[17:47:10.509]                     if (exists("sendData", mode = "function", 
[17:47:10.509]                       envir = ns)) {
[17:47:10.509]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.509]                         envir = ns)
[17:47:10.509]                       envir <- sys.frame(frame)
[17:47:10.509]                       master <- NULL
[17:47:10.509]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.509]                         !identical(envir, emptyenv())) {
[17:47:10.509]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.509]                           inherits = FALSE)) {
[17:47:10.509]                           master <- get("master", mode = "list", 
[17:47:10.509]                             envir = envir, inherits = FALSE)
[17:47:10.509]                           if (inherits(master, c("SOCKnode", 
[17:47:10.509]                             "SOCK0node"))) {
[17:47:10.509]                             sendCondition <<- function(cond) {
[17:47:10.509]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.509]                                 success = TRUE)
[17:47:10.509]                               parallel_sendData(master, data)
[17:47:10.509]                             }
[17:47:10.509]                             return(sendCondition)
[17:47:10.509]                           }
[17:47:10.509]                         }
[17:47:10.509]                         frame <- frame + 1L
[17:47:10.509]                         envir <- sys.frame(frame)
[17:47:10.509]                       }
[17:47:10.509]                     }
[17:47:10.509]                     sendCondition <<- function(cond) NULL
[17:47:10.509]                   }
[17:47:10.509]                 })
[17:47:10.509]                 withCallingHandlers({
[17:47:10.509]                   1
[17:47:10.509]                 }, immediateCondition = function(cond) {
[17:47:10.509]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.509]                   sendCondition(cond)
[17:47:10.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.509]                   {
[17:47:10.509]                     inherits <- base::inherits
[17:47:10.509]                     invokeRestart <- base::invokeRestart
[17:47:10.509]                     is.null <- base::is.null
[17:47:10.509]                     muffled <- FALSE
[17:47:10.509]                     if (inherits(cond, "message")) {
[17:47:10.509]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.509]                       if (muffled) 
[17:47:10.509]                         invokeRestart("muffleMessage")
[17:47:10.509]                     }
[17:47:10.509]                     else if (inherits(cond, "warning")) {
[17:47:10.509]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.509]                       if (muffled) 
[17:47:10.509]                         invokeRestart("muffleWarning")
[17:47:10.509]                     }
[17:47:10.509]                     else if (inherits(cond, "condition")) {
[17:47:10.509]                       if (!is.null(pattern)) {
[17:47:10.509]                         computeRestarts <- base::computeRestarts
[17:47:10.509]                         grepl <- base::grepl
[17:47:10.509]                         restarts <- computeRestarts(cond)
[17:47:10.509]                         for (restart in restarts) {
[17:47:10.509]                           name <- restart$name
[17:47:10.509]                           if (is.null(name)) 
[17:47:10.509]                             next
[17:47:10.509]                           if (!grepl(pattern, name)) 
[17:47:10.509]                             next
[17:47:10.509]                           invokeRestart(restart)
[17:47:10.509]                           muffled <- TRUE
[17:47:10.509]                           break
[17:47:10.509]                         }
[17:47:10.509]                       }
[17:47:10.509]                     }
[17:47:10.509]                     invisible(muffled)
[17:47:10.509]                   }
[17:47:10.509]                   muffleCondition(cond)
[17:47:10.509]                 })
[17:47:10.509]             }))
[17:47:10.509]             future::FutureResult(value = ...future.value$value, 
[17:47:10.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.509]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.509]                     ...future.globalenv.names))
[17:47:10.509]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.509]         }, condition = base::local({
[17:47:10.509]             c <- base::c
[17:47:10.509]             inherits <- base::inherits
[17:47:10.509]             invokeRestart <- base::invokeRestart
[17:47:10.509]             length <- base::length
[17:47:10.509]             list <- base::list
[17:47:10.509]             seq.int <- base::seq.int
[17:47:10.509]             signalCondition <- base::signalCondition
[17:47:10.509]             sys.calls <- base::sys.calls
[17:47:10.509]             `[[` <- base::`[[`
[17:47:10.509]             `+` <- base::`+`
[17:47:10.509]             `<<-` <- base::`<<-`
[17:47:10.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.509]                   3L)]
[17:47:10.509]             }
[17:47:10.509]             function(cond) {
[17:47:10.509]                 is_error <- inherits(cond, "error")
[17:47:10.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.509]                   NULL)
[17:47:10.509]                 if (is_error) {
[17:47:10.509]                   sessionInformation <- function() {
[17:47:10.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.509]                       search = base::search(), system = base::Sys.info())
[17:47:10.509]                   }
[17:47:10.509]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.509]                     cond$call), session = sessionInformation(), 
[17:47:10.509]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.509]                   signalCondition(cond)
[17:47:10.509]                 }
[17:47:10.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.509]                 "immediateCondition"))) {
[17:47:10.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.509]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.509]                   if (TRUE && !signal) {
[17:47:10.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.509]                     {
[17:47:10.509]                       inherits <- base::inherits
[17:47:10.509]                       invokeRestart <- base::invokeRestart
[17:47:10.509]                       is.null <- base::is.null
[17:47:10.509]                       muffled <- FALSE
[17:47:10.509]                       if (inherits(cond, "message")) {
[17:47:10.509]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.509]                         if (muffled) 
[17:47:10.509]                           invokeRestart("muffleMessage")
[17:47:10.509]                       }
[17:47:10.509]                       else if (inherits(cond, "warning")) {
[17:47:10.509]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.509]                         if (muffled) 
[17:47:10.509]                           invokeRestart("muffleWarning")
[17:47:10.509]                       }
[17:47:10.509]                       else if (inherits(cond, "condition")) {
[17:47:10.509]                         if (!is.null(pattern)) {
[17:47:10.509]                           computeRestarts <- base::computeRestarts
[17:47:10.509]                           grepl <- base::grepl
[17:47:10.509]                           restarts <- computeRestarts(cond)
[17:47:10.509]                           for (restart in restarts) {
[17:47:10.509]                             name <- restart$name
[17:47:10.509]                             if (is.null(name)) 
[17:47:10.509]                               next
[17:47:10.509]                             if (!grepl(pattern, name)) 
[17:47:10.509]                               next
[17:47:10.509]                             invokeRestart(restart)
[17:47:10.509]                             muffled <- TRUE
[17:47:10.509]                             break
[17:47:10.509]                           }
[17:47:10.509]                         }
[17:47:10.509]                       }
[17:47:10.509]                       invisible(muffled)
[17:47:10.509]                     }
[17:47:10.509]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.509]                   }
[17:47:10.509]                 }
[17:47:10.509]                 else {
[17:47:10.509]                   if (TRUE) {
[17:47:10.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.509]                     {
[17:47:10.509]                       inherits <- base::inherits
[17:47:10.509]                       invokeRestart <- base::invokeRestart
[17:47:10.509]                       is.null <- base::is.null
[17:47:10.509]                       muffled <- FALSE
[17:47:10.509]                       if (inherits(cond, "message")) {
[17:47:10.509]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.509]                         if (muffled) 
[17:47:10.509]                           invokeRestart("muffleMessage")
[17:47:10.509]                       }
[17:47:10.509]                       else if (inherits(cond, "warning")) {
[17:47:10.509]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.509]                         if (muffled) 
[17:47:10.509]                           invokeRestart("muffleWarning")
[17:47:10.509]                       }
[17:47:10.509]                       else if (inherits(cond, "condition")) {
[17:47:10.509]                         if (!is.null(pattern)) {
[17:47:10.509]                           computeRestarts <- base::computeRestarts
[17:47:10.509]                           grepl <- base::grepl
[17:47:10.509]                           restarts <- computeRestarts(cond)
[17:47:10.509]                           for (restart in restarts) {
[17:47:10.509]                             name <- restart$name
[17:47:10.509]                             if (is.null(name)) 
[17:47:10.509]                               next
[17:47:10.509]                             if (!grepl(pattern, name)) 
[17:47:10.509]                               next
[17:47:10.509]                             invokeRestart(restart)
[17:47:10.509]                             muffled <- TRUE
[17:47:10.509]                             break
[17:47:10.509]                           }
[17:47:10.509]                         }
[17:47:10.509]                       }
[17:47:10.509]                       invisible(muffled)
[17:47:10.509]                     }
[17:47:10.509]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.509]                   }
[17:47:10.509]                 }
[17:47:10.509]             }
[17:47:10.509]         }))
[17:47:10.509]     }, error = function(ex) {
[17:47:10.509]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.509]                 ...future.rng), started = ...future.startTime, 
[17:47:10.509]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.509]             version = "1.8"), class = "FutureResult")
[17:47:10.509]     }, finally = {
[17:47:10.509]         if (!identical(...future.workdir, getwd())) 
[17:47:10.509]             setwd(...future.workdir)
[17:47:10.509]         {
[17:47:10.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.509]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.509]             }
[17:47:10.509]             base::options(...future.oldOptions)
[17:47:10.509]             if (.Platform$OS.type == "windows") {
[17:47:10.509]                 old_names <- names(...future.oldEnvVars)
[17:47:10.509]                 envs <- base::Sys.getenv()
[17:47:10.509]                 names <- names(envs)
[17:47:10.509]                 common <- intersect(names, old_names)
[17:47:10.509]                 added <- setdiff(names, old_names)
[17:47:10.509]                 removed <- setdiff(old_names, names)
[17:47:10.509]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.509]                   envs[common]]
[17:47:10.509]                 NAMES <- toupper(changed)
[17:47:10.509]                 args <- list()
[17:47:10.509]                 for (kk in seq_along(NAMES)) {
[17:47:10.509]                   name <- changed[[kk]]
[17:47:10.509]                   NAME <- NAMES[[kk]]
[17:47:10.509]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.509]                     next
[17:47:10.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.509]                 }
[17:47:10.509]                 NAMES <- toupper(added)
[17:47:10.509]                 for (kk in seq_along(NAMES)) {
[17:47:10.509]                   name <- added[[kk]]
[17:47:10.509]                   NAME <- NAMES[[kk]]
[17:47:10.509]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.509]                     next
[17:47:10.509]                   args[[name]] <- ""
[17:47:10.509]                 }
[17:47:10.509]                 NAMES <- toupper(removed)
[17:47:10.509]                 for (kk in seq_along(NAMES)) {
[17:47:10.509]                   name <- removed[[kk]]
[17:47:10.509]                   NAME <- NAMES[[kk]]
[17:47:10.509]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.509]                     next
[17:47:10.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.509]                 }
[17:47:10.509]                 if (length(args) > 0) 
[17:47:10.509]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.509]             }
[17:47:10.509]             else {
[17:47:10.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.509]             }
[17:47:10.509]             {
[17:47:10.509]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.509]                   0L) {
[17:47:10.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.509]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.509]                   base::options(opts)
[17:47:10.509]                 }
[17:47:10.509]                 {
[17:47:10.509]                   {
[17:47:10.509]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.509]                     NULL
[17:47:10.509]                   }
[17:47:10.509]                   options(future.plan = NULL)
[17:47:10.509]                   if (is.na(NA_character_)) 
[17:47:10.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.509]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.509]                     .init = FALSE)
[17:47:10.509]                 }
[17:47:10.509]             }
[17:47:10.509]         }
[17:47:10.509]     })
[17:47:10.509]     if (TRUE) {
[17:47:10.509]         base::sink(type = "output", split = FALSE)
[17:47:10.509]         if (TRUE) {
[17:47:10.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.509]         }
[17:47:10.509]         else {
[17:47:10.509]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.509]         }
[17:47:10.509]         base::close(...future.stdout)
[17:47:10.509]         ...future.stdout <- NULL
[17:47:10.509]     }
[17:47:10.509]     ...future.result$conditions <- ...future.conditions
[17:47:10.509]     ...future.result$finished <- base::Sys.time()
[17:47:10.509]     ...future.result
[17:47:10.509] }
[17:47:10.512] MultisessionFuture started
[17:47:10.512] - Launch lazy future ... done
[17:47:10.512] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.512] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.513] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.513] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:10.514] Searching for globals ... DONE
[17:47:10.514] Resolving globals: TRUE
[17:47:10.514] Resolving any globals that are futures ...
[17:47:10.514] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:10.514] Resolving any globals that are futures ... DONE
[17:47:10.514] Resolving futures part of globals (recursively) ...
[17:47:10.514] resolve() on list ...
[17:47:10.515]  recursive: 99
[17:47:10.515]  length: 1
[17:47:10.515]  elements: ‘a’
[17:47:10.557] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.557] - Validating connection of MultisessionFuture
[17:47:10.557] - received message: FutureResult
[17:47:10.557] - Received FutureResult
[17:47:10.558] - Erased future from FutureRegistry
[17:47:10.558] result() for ClusterFuture ...
[17:47:10.558] - result already collected: FutureResult
[17:47:10.558] result() for ClusterFuture ... done
[17:47:10.558] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.558] Future #1
[17:47:10.558] result() for ClusterFuture ...
[17:47:10.558] - result already collected: FutureResult
[17:47:10.558] result() for ClusterFuture ... done
[17:47:10.558] result() for ClusterFuture ...
[17:47:10.558] - result already collected: FutureResult
[17:47:10.559] result() for ClusterFuture ... done
[17:47:10.559] A MultisessionFuture was resolved
[17:47:10.559]  length: 0 (resolved future 1)
[17:47:10.559] resolve() on list ... DONE
[17:47:10.559] - globals: [1] ‘a’
[17:47:10.559] Resolving futures part of globals (recursively) ... DONE
[17:47:10.561] The total size of the 1 globals is 1.57 MiB (1647200 bytes)
[17:47:10.561] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:47:10.562] - globals: [1] ‘a’
[17:47:10.562] - packages: [1] ‘future’
[17:47:10.562] getGlobalsAndPackages() ... DONE
[17:47:10.562] run() for ‘Future’ ...
[17:47:10.562] - state: ‘created’
[17:47:10.562] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.576] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.577]   - Field: ‘node’
[17:47:10.577]   - Field: ‘label’
[17:47:10.577]   - Field: ‘local’
[17:47:10.577]   - Field: ‘owner’
[17:47:10.577]   - Field: ‘envir’
[17:47:10.577]   - Field: ‘workers’
[17:47:10.577]   - Field: ‘packages’
[17:47:10.577]   - Field: ‘gc’
[17:47:10.577]   - Field: ‘conditions’
[17:47:10.580]   - Field: ‘persistent’
[17:47:10.580]   - Field: ‘expr’
[17:47:10.580]   - Field: ‘uuid’
[17:47:10.580]   - Field: ‘seed’
[17:47:10.580]   - Field: ‘version’
[17:47:10.580]   - Field: ‘result’
[17:47:10.580]   - Field: ‘asynchronous’
[17:47:10.580]   - Field: ‘calls’
[17:47:10.580]   - Field: ‘globals’
[17:47:10.581]   - Field: ‘stdout’
[17:47:10.581]   - Field: ‘earlySignal’
[17:47:10.581]   - Field: ‘lazy’
[17:47:10.581]   - Field: ‘state’
[17:47:10.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.581] - Launch lazy future ...
[17:47:10.581] Packages needed by the future expression (n = 1): ‘future’
[17:47:10.581] Packages needed by future strategies (n = 0): <none>
[17:47:10.582] {
[17:47:10.582]     {
[17:47:10.582]         {
[17:47:10.582]             ...future.startTime <- base::Sys.time()
[17:47:10.582]             {
[17:47:10.582]                 {
[17:47:10.582]                   {
[17:47:10.582]                     {
[17:47:10.582]                       {
[17:47:10.582]                         base::local({
[17:47:10.582]                           has_future <- base::requireNamespace("future", 
[17:47:10.582]                             quietly = TRUE)
[17:47:10.582]                           if (has_future) {
[17:47:10.582]                             ns <- base::getNamespace("future")
[17:47:10.582]                             version <- ns[[".package"]][["version"]]
[17:47:10.582]                             if (is.null(version)) 
[17:47:10.582]                               version <- utils::packageVersion("future")
[17:47:10.582]                           }
[17:47:10.582]                           else {
[17:47:10.582]                             version <- NULL
[17:47:10.582]                           }
[17:47:10.582]                           if (!has_future || version < "1.8.0") {
[17:47:10.582]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.582]                               "", base::R.version$version.string), 
[17:47:10.582]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:10.582]                                 base::R.version$platform, 8 * 
[17:47:10.582]                                   base::.Machine$sizeof.pointer), 
[17:47:10.582]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.582]                                 "release", "version")], collapse = " "), 
[17:47:10.582]                               hostname = base::Sys.info()[["nodename"]])
[17:47:10.582]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.582]                               info)
[17:47:10.582]                             info <- base::paste(info, collapse = "; ")
[17:47:10.582]                             if (!has_future) {
[17:47:10.582]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.582]                                 info)
[17:47:10.582]                             }
[17:47:10.582]                             else {
[17:47:10.582]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.582]                                 info, version)
[17:47:10.582]                             }
[17:47:10.582]                             base::stop(msg)
[17:47:10.582]                           }
[17:47:10.582]                         })
[17:47:10.582]                       }
[17:47:10.582]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.582]                       base::options(mc.cores = 1L)
[17:47:10.582]                     }
[17:47:10.582]                     base::local({
[17:47:10.582]                       for (pkg in "future") {
[17:47:10.582]                         base::loadNamespace(pkg)
[17:47:10.582]                         base::library(pkg, character.only = TRUE)
[17:47:10.582]                       }
[17:47:10.582]                     })
[17:47:10.582]                   }
[17:47:10.582]                   ...future.strategy.old <- future::plan("list")
[17:47:10.582]                   options(future.plan = NULL)
[17:47:10.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.582]                 }
[17:47:10.582]                 ...future.workdir <- getwd()
[17:47:10.582]             }
[17:47:10.582]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.582]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.582]         }
[17:47:10.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.582]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.582]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.582]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.582]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.582]             base::names(...future.oldOptions))
[17:47:10.582]     }
[17:47:10.582]     if (FALSE) {
[17:47:10.582]     }
[17:47:10.582]     else {
[17:47:10.582]         if (TRUE) {
[17:47:10.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.582]                 open = "w")
[17:47:10.582]         }
[17:47:10.582]         else {
[17:47:10.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.582]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.582]         }
[17:47:10.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.582]             base::sink(type = "output", split = FALSE)
[17:47:10.582]             base::close(...future.stdout)
[17:47:10.582]         }, add = TRUE)
[17:47:10.582]     }
[17:47:10.582]     ...future.frame <- base::sys.nframe()
[17:47:10.582]     ...future.conditions <- base::list()
[17:47:10.582]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.582]     if (FALSE) {
[17:47:10.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.582]     }
[17:47:10.582]     ...future.result <- base::tryCatch({
[17:47:10.582]         base::withCallingHandlers({
[17:47:10.582]             ...future.value <- base::withVisible(base::local({
[17:47:10.582]                 ...future.makeSendCondition <- base::local({
[17:47:10.582]                   sendCondition <- NULL
[17:47:10.582]                   function(frame = 1L) {
[17:47:10.582]                     if (is.function(sendCondition)) 
[17:47:10.582]                       return(sendCondition)
[17:47:10.582]                     ns <- getNamespace("parallel")
[17:47:10.582]                     if (exists("sendData", mode = "function", 
[17:47:10.582]                       envir = ns)) {
[17:47:10.582]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.582]                         envir = ns)
[17:47:10.582]                       envir <- sys.frame(frame)
[17:47:10.582]                       master <- NULL
[17:47:10.582]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.582]                         !identical(envir, emptyenv())) {
[17:47:10.582]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.582]                           inherits = FALSE)) {
[17:47:10.582]                           master <- get("master", mode = "list", 
[17:47:10.582]                             envir = envir, inherits = FALSE)
[17:47:10.582]                           if (inherits(master, c("SOCKnode", 
[17:47:10.582]                             "SOCK0node"))) {
[17:47:10.582]                             sendCondition <<- function(cond) {
[17:47:10.582]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.582]                                 success = TRUE)
[17:47:10.582]                               parallel_sendData(master, data)
[17:47:10.582]                             }
[17:47:10.582]                             return(sendCondition)
[17:47:10.582]                           }
[17:47:10.582]                         }
[17:47:10.582]                         frame <- frame + 1L
[17:47:10.582]                         envir <- sys.frame(frame)
[17:47:10.582]                       }
[17:47:10.582]                     }
[17:47:10.582]                     sendCondition <<- function(cond) NULL
[17:47:10.582]                   }
[17:47:10.582]                 })
[17:47:10.582]                 withCallingHandlers({
[17:47:10.582]                   value(a) + 1
[17:47:10.582]                 }, immediateCondition = function(cond) {
[17:47:10.582]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.582]                   sendCondition(cond)
[17:47:10.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.582]                   {
[17:47:10.582]                     inherits <- base::inherits
[17:47:10.582]                     invokeRestart <- base::invokeRestart
[17:47:10.582]                     is.null <- base::is.null
[17:47:10.582]                     muffled <- FALSE
[17:47:10.582]                     if (inherits(cond, "message")) {
[17:47:10.582]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.582]                       if (muffled) 
[17:47:10.582]                         invokeRestart("muffleMessage")
[17:47:10.582]                     }
[17:47:10.582]                     else if (inherits(cond, "warning")) {
[17:47:10.582]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.582]                       if (muffled) 
[17:47:10.582]                         invokeRestart("muffleWarning")
[17:47:10.582]                     }
[17:47:10.582]                     else if (inherits(cond, "condition")) {
[17:47:10.582]                       if (!is.null(pattern)) {
[17:47:10.582]                         computeRestarts <- base::computeRestarts
[17:47:10.582]                         grepl <- base::grepl
[17:47:10.582]                         restarts <- computeRestarts(cond)
[17:47:10.582]                         for (restart in restarts) {
[17:47:10.582]                           name <- restart$name
[17:47:10.582]                           if (is.null(name)) 
[17:47:10.582]                             next
[17:47:10.582]                           if (!grepl(pattern, name)) 
[17:47:10.582]                             next
[17:47:10.582]                           invokeRestart(restart)
[17:47:10.582]                           muffled <- TRUE
[17:47:10.582]                           break
[17:47:10.582]                         }
[17:47:10.582]                       }
[17:47:10.582]                     }
[17:47:10.582]                     invisible(muffled)
[17:47:10.582]                   }
[17:47:10.582]                   muffleCondition(cond)
[17:47:10.582]                 })
[17:47:10.582]             }))
[17:47:10.582]             future::FutureResult(value = ...future.value$value, 
[17:47:10.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.582]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.582]                     ...future.globalenv.names))
[17:47:10.582]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.582]         }, condition = base::local({
[17:47:10.582]             c <- base::c
[17:47:10.582]             inherits <- base::inherits
[17:47:10.582]             invokeRestart <- base::invokeRestart
[17:47:10.582]             length <- base::length
[17:47:10.582]             list <- base::list
[17:47:10.582]             seq.int <- base::seq.int
[17:47:10.582]             signalCondition <- base::signalCondition
[17:47:10.582]             sys.calls <- base::sys.calls
[17:47:10.582]             `[[` <- base::`[[`
[17:47:10.582]             `+` <- base::`+`
[17:47:10.582]             `<<-` <- base::`<<-`
[17:47:10.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.582]                   3L)]
[17:47:10.582]             }
[17:47:10.582]             function(cond) {
[17:47:10.582]                 is_error <- inherits(cond, "error")
[17:47:10.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.582]                   NULL)
[17:47:10.582]                 if (is_error) {
[17:47:10.582]                   sessionInformation <- function() {
[17:47:10.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.582]                       search = base::search(), system = base::Sys.info())
[17:47:10.582]                   }
[17:47:10.582]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.582]                     cond$call), session = sessionInformation(), 
[17:47:10.582]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.582]                   signalCondition(cond)
[17:47:10.582]                 }
[17:47:10.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.582]                 "immediateCondition"))) {
[17:47:10.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.582]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.582]                   if (TRUE && !signal) {
[17:47:10.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.582]                     {
[17:47:10.582]                       inherits <- base::inherits
[17:47:10.582]                       invokeRestart <- base::invokeRestart
[17:47:10.582]                       is.null <- base::is.null
[17:47:10.582]                       muffled <- FALSE
[17:47:10.582]                       if (inherits(cond, "message")) {
[17:47:10.582]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.582]                         if (muffled) 
[17:47:10.582]                           invokeRestart("muffleMessage")
[17:47:10.582]                       }
[17:47:10.582]                       else if (inherits(cond, "warning")) {
[17:47:10.582]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.582]                         if (muffled) 
[17:47:10.582]                           invokeRestart("muffleWarning")
[17:47:10.582]                       }
[17:47:10.582]                       else if (inherits(cond, "condition")) {
[17:47:10.582]                         if (!is.null(pattern)) {
[17:47:10.582]                           computeRestarts <- base::computeRestarts
[17:47:10.582]                           grepl <- base::grepl
[17:47:10.582]                           restarts <- computeRestarts(cond)
[17:47:10.582]                           for (restart in restarts) {
[17:47:10.582]                             name <- restart$name
[17:47:10.582]                             if (is.null(name)) 
[17:47:10.582]                               next
[17:47:10.582]                             if (!grepl(pattern, name)) 
[17:47:10.582]                               next
[17:47:10.582]                             invokeRestart(restart)
[17:47:10.582]                             muffled <- TRUE
[17:47:10.582]                             break
[17:47:10.582]                           }
[17:47:10.582]                         }
[17:47:10.582]                       }
[17:47:10.582]                       invisible(muffled)
[17:47:10.582]                     }
[17:47:10.582]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.582]                   }
[17:47:10.582]                 }
[17:47:10.582]                 else {
[17:47:10.582]                   if (TRUE) {
[17:47:10.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.582]                     {
[17:47:10.582]                       inherits <- base::inherits
[17:47:10.582]                       invokeRestart <- base::invokeRestart
[17:47:10.582]                       is.null <- base::is.null
[17:47:10.582]                       muffled <- FALSE
[17:47:10.582]                       if (inherits(cond, "message")) {
[17:47:10.582]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.582]                         if (muffled) 
[17:47:10.582]                           invokeRestart("muffleMessage")
[17:47:10.582]                       }
[17:47:10.582]                       else if (inherits(cond, "warning")) {
[17:47:10.582]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.582]                         if (muffled) 
[17:47:10.582]                           invokeRestart("muffleWarning")
[17:47:10.582]                       }
[17:47:10.582]                       else if (inherits(cond, "condition")) {
[17:47:10.582]                         if (!is.null(pattern)) {
[17:47:10.582]                           computeRestarts <- base::computeRestarts
[17:47:10.582]                           grepl <- base::grepl
[17:47:10.582]                           restarts <- computeRestarts(cond)
[17:47:10.582]                           for (restart in restarts) {
[17:47:10.582]                             name <- restart$name
[17:47:10.582]                             if (is.null(name)) 
[17:47:10.582]                               next
[17:47:10.582]                             if (!grepl(pattern, name)) 
[17:47:10.582]                               next
[17:47:10.582]                             invokeRestart(restart)
[17:47:10.582]                             muffled <- TRUE
[17:47:10.582]                             break
[17:47:10.582]                           }
[17:47:10.582]                         }
[17:47:10.582]                       }
[17:47:10.582]                       invisible(muffled)
[17:47:10.582]                     }
[17:47:10.582]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.582]                   }
[17:47:10.582]                 }
[17:47:10.582]             }
[17:47:10.582]         }))
[17:47:10.582]     }, error = function(ex) {
[17:47:10.582]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.582]                 ...future.rng), started = ...future.startTime, 
[17:47:10.582]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.582]             version = "1.8"), class = "FutureResult")
[17:47:10.582]     }, finally = {
[17:47:10.582]         if (!identical(...future.workdir, getwd())) 
[17:47:10.582]             setwd(...future.workdir)
[17:47:10.582]         {
[17:47:10.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.582]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.582]             }
[17:47:10.582]             base::options(...future.oldOptions)
[17:47:10.582]             if (.Platform$OS.type == "windows") {
[17:47:10.582]                 old_names <- names(...future.oldEnvVars)
[17:47:10.582]                 envs <- base::Sys.getenv()
[17:47:10.582]                 names <- names(envs)
[17:47:10.582]                 common <- intersect(names, old_names)
[17:47:10.582]                 added <- setdiff(names, old_names)
[17:47:10.582]                 removed <- setdiff(old_names, names)
[17:47:10.582]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.582]                   envs[common]]
[17:47:10.582]                 NAMES <- toupper(changed)
[17:47:10.582]                 args <- list()
[17:47:10.582]                 for (kk in seq_along(NAMES)) {
[17:47:10.582]                   name <- changed[[kk]]
[17:47:10.582]                   NAME <- NAMES[[kk]]
[17:47:10.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.582]                     next
[17:47:10.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.582]                 }
[17:47:10.582]                 NAMES <- toupper(added)
[17:47:10.582]                 for (kk in seq_along(NAMES)) {
[17:47:10.582]                   name <- added[[kk]]
[17:47:10.582]                   NAME <- NAMES[[kk]]
[17:47:10.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.582]                     next
[17:47:10.582]                   args[[name]] <- ""
[17:47:10.582]                 }
[17:47:10.582]                 NAMES <- toupper(removed)
[17:47:10.582]                 for (kk in seq_along(NAMES)) {
[17:47:10.582]                   name <- removed[[kk]]
[17:47:10.582]                   NAME <- NAMES[[kk]]
[17:47:10.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.582]                     next
[17:47:10.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.582]                 }
[17:47:10.582]                 if (length(args) > 0) 
[17:47:10.582]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.582]             }
[17:47:10.582]             else {
[17:47:10.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.582]             }
[17:47:10.582]             {
[17:47:10.582]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.582]                   0L) {
[17:47:10.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.582]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.582]                   base::options(opts)
[17:47:10.582]                 }
[17:47:10.582]                 {
[17:47:10.582]                   {
[17:47:10.582]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.582]                     NULL
[17:47:10.582]                   }
[17:47:10.582]                   options(future.plan = NULL)
[17:47:10.582]                   if (is.na(NA_character_)) 
[17:47:10.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.582]                     .init = FALSE)
[17:47:10.582]                 }
[17:47:10.582]             }
[17:47:10.582]         }
[17:47:10.582]     })
[17:47:10.582]     if (TRUE) {
[17:47:10.582]         base::sink(type = "output", split = FALSE)
[17:47:10.582]         if (TRUE) {
[17:47:10.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.582]         }
[17:47:10.582]         else {
[17:47:10.582]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.582]         }
[17:47:10.582]         base::close(...future.stdout)
[17:47:10.582]         ...future.stdout <- NULL
[17:47:10.582]     }
[17:47:10.582]     ...future.result$conditions <- ...future.conditions
[17:47:10.582]     ...future.result$finished <- base::Sys.time()
[17:47:10.582]     ...future.result
[17:47:10.582] }
[17:47:10.584] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:47:10.586] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:47:10.640] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:47:10.640] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:47:10.640] MultisessionFuture started
[17:47:10.640] - Launch lazy future ... done
[17:47:10.641] run() for ‘MultisessionFuture’ ... done
[17:47:10.641] result() for ClusterFuture ...
[17:47:10.641] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.641] - Validating connection of MultisessionFuture
[17:47:10.685] - received message: FutureResult
[17:47:10.686] - Received FutureResult
[17:47:10.686] - Erased future from FutureRegistry
[17:47:10.686] result() for ClusterFuture ...
[17:47:10.686] - result already collected: FutureResult
[17:47:10.686] result() for ClusterFuture ... done
[17:47:10.686] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.686] result() for ClusterFuture ... done
[17:47:10.686] result() for ClusterFuture ...
[17:47:10.686] - result already collected: FutureResult
[17:47:10.686] result() for ClusterFuture ... done
value(b) = 2
[17:47:10.687] result() for ClusterFuture ...
[17:47:10.687] - result already collected: FutureResult
[17:47:10.687] result() for ClusterFuture ... done
[17:47:10.687] result() for ClusterFuture ...
[17:47:10.687] - result already collected: FutureResult
[17:47:10.687] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.687] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.688] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.688] 
[17:47:10.688] Searching for globals ... DONE
[17:47:10.688] - globals: [0] <none>
[17:47:10.688] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.689] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.689] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.689] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:10.690] Searching for globals ... DONE
[17:47:10.690] Resolving globals: TRUE
[17:47:10.690] Resolving any globals that are futures ...
[17:47:10.690] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:10.690] Resolving any globals that are futures ... DONE
[17:47:10.690] Resolving futures part of globals (recursively) ...
[17:47:10.690] resolve() on list ...
[17:47:10.691]  recursive: 99
[17:47:10.691]  length: 1
[17:47:10.691]  elements: ‘a’
[17:47:10.691] run() for ‘Future’ ...
[17:47:10.691] - state: ‘created’
[17:47:10.691] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.705] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.706]   - Field: ‘node’
[17:47:10.706]   - Field: ‘label’
[17:47:10.706]   - Field: ‘local’
[17:47:10.706]   - Field: ‘owner’
[17:47:10.706]   - Field: ‘envir’
[17:47:10.706]   - Field: ‘workers’
[17:47:10.706]   - Field: ‘packages’
[17:47:10.706]   - Field: ‘gc’
[17:47:10.706]   - Field: ‘conditions’
[17:47:10.706]   - Field: ‘persistent’
[17:47:10.706]   - Field: ‘expr’
[17:47:10.707]   - Field: ‘uuid’
[17:47:10.707]   - Field: ‘seed’
[17:47:10.707]   - Field: ‘version’
[17:47:10.707]   - Field: ‘result’
[17:47:10.707]   - Field: ‘asynchronous’
[17:47:10.707]   - Field: ‘calls’
[17:47:10.707]   - Field: ‘globals’
[17:47:10.707]   - Field: ‘stdout’
[17:47:10.707]   - Field: ‘earlySignal’
[17:47:10.707]   - Field: ‘lazy’
[17:47:10.707]   - Field: ‘state’
[17:47:10.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.708] - Launch lazy future ...
[17:47:10.708] Packages needed by the future expression (n = 0): <none>
[17:47:10.708] Packages needed by future strategies (n = 0): <none>
[17:47:10.708] {
[17:47:10.708]     {
[17:47:10.708]         {
[17:47:10.708]             ...future.startTime <- base::Sys.time()
[17:47:10.708]             {
[17:47:10.708]                 {
[17:47:10.708]                   {
[17:47:10.708]                     {
[17:47:10.708]                       base::local({
[17:47:10.708]                         has_future <- base::requireNamespace("future", 
[17:47:10.708]                           quietly = TRUE)
[17:47:10.708]                         if (has_future) {
[17:47:10.708]                           ns <- base::getNamespace("future")
[17:47:10.708]                           version <- ns[[".package"]][["version"]]
[17:47:10.708]                           if (is.null(version)) 
[17:47:10.708]                             version <- utils::packageVersion("future")
[17:47:10.708]                         }
[17:47:10.708]                         else {
[17:47:10.708]                           version <- NULL
[17:47:10.708]                         }
[17:47:10.708]                         if (!has_future || version < "1.8.0") {
[17:47:10.708]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.708]                             "", base::R.version$version.string), 
[17:47:10.708]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.708]                               "release", "version")], collapse = " "), 
[17:47:10.708]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.708]                             info)
[17:47:10.708]                           info <- base::paste(info, collapse = "; ")
[17:47:10.708]                           if (!has_future) {
[17:47:10.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.708]                               info)
[17:47:10.708]                           }
[17:47:10.708]                           else {
[17:47:10.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.708]                               info, version)
[17:47:10.708]                           }
[17:47:10.708]                           base::stop(msg)
[17:47:10.708]                         }
[17:47:10.708]                       })
[17:47:10.708]                     }
[17:47:10.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.708]                     base::options(mc.cores = 1L)
[17:47:10.708]                   }
[17:47:10.708]                   ...future.strategy.old <- future::plan("list")
[17:47:10.708]                   options(future.plan = NULL)
[17:47:10.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.708]                 }
[17:47:10.708]                 ...future.workdir <- getwd()
[17:47:10.708]             }
[17:47:10.708]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.708]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.708]         }
[17:47:10.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.708]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.708]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.708]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.708]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.708]             base::names(...future.oldOptions))
[17:47:10.708]     }
[17:47:10.708]     if (FALSE) {
[17:47:10.708]     }
[17:47:10.708]     else {
[17:47:10.708]         if (TRUE) {
[17:47:10.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.708]                 open = "w")
[17:47:10.708]         }
[17:47:10.708]         else {
[17:47:10.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.708]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.708]         }
[17:47:10.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.708]             base::sink(type = "output", split = FALSE)
[17:47:10.708]             base::close(...future.stdout)
[17:47:10.708]         }, add = TRUE)
[17:47:10.708]     }
[17:47:10.708]     ...future.frame <- base::sys.nframe()
[17:47:10.708]     ...future.conditions <- base::list()
[17:47:10.708]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.708]     if (FALSE) {
[17:47:10.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.708]     }
[17:47:10.708]     ...future.result <- base::tryCatch({
[17:47:10.708]         base::withCallingHandlers({
[17:47:10.708]             ...future.value <- base::withVisible(base::local({
[17:47:10.708]                 ...future.makeSendCondition <- base::local({
[17:47:10.708]                   sendCondition <- NULL
[17:47:10.708]                   function(frame = 1L) {
[17:47:10.708]                     if (is.function(sendCondition)) 
[17:47:10.708]                       return(sendCondition)
[17:47:10.708]                     ns <- getNamespace("parallel")
[17:47:10.708]                     if (exists("sendData", mode = "function", 
[17:47:10.708]                       envir = ns)) {
[17:47:10.708]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.708]                         envir = ns)
[17:47:10.708]                       envir <- sys.frame(frame)
[17:47:10.708]                       master <- NULL
[17:47:10.708]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.708]                         !identical(envir, emptyenv())) {
[17:47:10.708]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.708]                           inherits = FALSE)) {
[17:47:10.708]                           master <- get("master", mode = "list", 
[17:47:10.708]                             envir = envir, inherits = FALSE)
[17:47:10.708]                           if (inherits(master, c("SOCKnode", 
[17:47:10.708]                             "SOCK0node"))) {
[17:47:10.708]                             sendCondition <<- function(cond) {
[17:47:10.708]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.708]                                 success = TRUE)
[17:47:10.708]                               parallel_sendData(master, data)
[17:47:10.708]                             }
[17:47:10.708]                             return(sendCondition)
[17:47:10.708]                           }
[17:47:10.708]                         }
[17:47:10.708]                         frame <- frame + 1L
[17:47:10.708]                         envir <- sys.frame(frame)
[17:47:10.708]                       }
[17:47:10.708]                     }
[17:47:10.708]                     sendCondition <<- function(cond) NULL
[17:47:10.708]                   }
[17:47:10.708]                 })
[17:47:10.708]                 withCallingHandlers({
[17:47:10.708]                   1
[17:47:10.708]                 }, immediateCondition = function(cond) {
[17:47:10.708]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.708]                   sendCondition(cond)
[17:47:10.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.708]                   {
[17:47:10.708]                     inherits <- base::inherits
[17:47:10.708]                     invokeRestart <- base::invokeRestart
[17:47:10.708]                     is.null <- base::is.null
[17:47:10.708]                     muffled <- FALSE
[17:47:10.708]                     if (inherits(cond, "message")) {
[17:47:10.708]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.708]                       if (muffled) 
[17:47:10.708]                         invokeRestart("muffleMessage")
[17:47:10.708]                     }
[17:47:10.708]                     else if (inherits(cond, "warning")) {
[17:47:10.708]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.708]                       if (muffled) 
[17:47:10.708]                         invokeRestart("muffleWarning")
[17:47:10.708]                     }
[17:47:10.708]                     else if (inherits(cond, "condition")) {
[17:47:10.708]                       if (!is.null(pattern)) {
[17:47:10.708]                         computeRestarts <- base::computeRestarts
[17:47:10.708]                         grepl <- base::grepl
[17:47:10.708]                         restarts <- computeRestarts(cond)
[17:47:10.708]                         for (restart in restarts) {
[17:47:10.708]                           name <- restart$name
[17:47:10.708]                           if (is.null(name)) 
[17:47:10.708]                             next
[17:47:10.708]                           if (!grepl(pattern, name)) 
[17:47:10.708]                             next
[17:47:10.708]                           invokeRestart(restart)
[17:47:10.708]                           muffled <- TRUE
[17:47:10.708]                           break
[17:47:10.708]                         }
[17:47:10.708]                       }
[17:47:10.708]                     }
[17:47:10.708]                     invisible(muffled)
[17:47:10.708]                   }
[17:47:10.708]                   muffleCondition(cond)
[17:47:10.708]                 })
[17:47:10.708]             }))
[17:47:10.708]             future::FutureResult(value = ...future.value$value, 
[17:47:10.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.708]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.708]                     ...future.globalenv.names))
[17:47:10.708]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.708]         }, condition = base::local({
[17:47:10.708]             c <- base::c
[17:47:10.708]             inherits <- base::inherits
[17:47:10.708]             invokeRestart <- base::invokeRestart
[17:47:10.708]             length <- base::length
[17:47:10.708]             list <- base::list
[17:47:10.708]             seq.int <- base::seq.int
[17:47:10.708]             signalCondition <- base::signalCondition
[17:47:10.708]             sys.calls <- base::sys.calls
[17:47:10.708]             `[[` <- base::`[[`
[17:47:10.708]             `+` <- base::`+`
[17:47:10.708]             `<<-` <- base::`<<-`
[17:47:10.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.708]                   3L)]
[17:47:10.708]             }
[17:47:10.708]             function(cond) {
[17:47:10.708]                 is_error <- inherits(cond, "error")
[17:47:10.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.708]                   NULL)
[17:47:10.708]                 if (is_error) {
[17:47:10.708]                   sessionInformation <- function() {
[17:47:10.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.708]                       search = base::search(), system = base::Sys.info())
[17:47:10.708]                   }
[17:47:10.708]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.708]                     cond$call), session = sessionInformation(), 
[17:47:10.708]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.708]                   signalCondition(cond)
[17:47:10.708]                 }
[17:47:10.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.708]                 "immediateCondition"))) {
[17:47:10.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.708]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.708]                   if (TRUE && !signal) {
[17:47:10.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.708]                     {
[17:47:10.708]                       inherits <- base::inherits
[17:47:10.708]                       invokeRestart <- base::invokeRestart
[17:47:10.708]                       is.null <- base::is.null
[17:47:10.708]                       muffled <- FALSE
[17:47:10.708]                       if (inherits(cond, "message")) {
[17:47:10.708]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.708]                         if (muffled) 
[17:47:10.708]                           invokeRestart("muffleMessage")
[17:47:10.708]                       }
[17:47:10.708]                       else if (inherits(cond, "warning")) {
[17:47:10.708]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.708]                         if (muffled) 
[17:47:10.708]                           invokeRestart("muffleWarning")
[17:47:10.708]                       }
[17:47:10.708]                       else if (inherits(cond, "condition")) {
[17:47:10.708]                         if (!is.null(pattern)) {
[17:47:10.708]                           computeRestarts <- base::computeRestarts
[17:47:10.708]                           grepl <- base::grepl
[17:47:10.708]                           restarts <- computeRestarts(cond)
[17:47:10.708]                           for (restart in restarts) {
[17:47:10.708]                             name <- restart$name
[17:47:10.708]                             if (is.null(name)) 
[17:47:10.708]                               next
[17:47:10.708]                             if (!grepl(pattern, name)) 
[17:47:10.708]                               next
[17:47:10.708]                             invokeRestart(restart)
[17:47:10.708]                             muffled <- TRUE
[17:47:10.708]                             break
[17:47:10.708]                           }
[17:47:10.708]                         }
[17:47:10.708]                       }
[17:47:10.708]                       invisible(muffled)
[17:47:10.708]                     }
[17:47:10.708]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.708]                   }
[17:47:10.708]                 }
[17:47:10.708]                 else {
[17:47:10.708]                   if (TRUE) {
[17:47:10.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.708]                     {
[17:47:10.708]                       inherits <- base::inherits
[17:47:10.708]                       invokeRestart <- base::invokeRestart
[17:47:10.708]                       is.null <- base::is.null
[17:47:10.708]                       muffled <- FALSE
[17:47:10.708]                       if (inherits(cond, "message")) {
[17:47:10.708]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.708]                         if (muffled) 
[17:47:10.708]                           invokeRestart("muffleMessage")
[17:47:10.708]                       }
[17:47:10.708]                       else if (inherits(cond, "warning")) {
[17:47:10.708]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.708]                         if (muffled) 
[17:47:10.708]                           invokeRestart("muffleWarning")
[17:47:10.708]                       }
[17:47:10.708]                       else if (inherits(cond, "condition")) {
[17:47:10.708]                         if (!is.null(pattern)) {
[17:47:10.708]                           computeRestarts <- base::computeRestarts
[17:47:10.708]                           grepl <- base::grepl
[17:47:10.708]                           restarts <- computeRestarts(cond)
[17:47:10.708]                           for (restart in restarts) {
[17:47:10.708]                             name <- restart$name
[17:47:10.708]                             if (is.null(name)) 
[17:47:10.708]                               next
[17:47:10.708]                             if (!grepl(pattern, name)) 
[17:47:10.708]                               next
[17:47:10.708]                             invokeRestart(restart)
[17:47:10.708]                             muffled <- TRUE
[17:47:10.708]                             break
[17:47:10.708]                           }
[17:47:10.708]                         }
[17:47:10.708]                       }
[17:47:10.708]                       invisible(muffled)
[17:47:10.708]                     }
[17:47:10.708]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.708]                   }
[17:47:10.708]                 }
[17:47:10.708]             }
[17:47:10.708]         }))
[17:47:10.708]     }, error = function(ex) {
[17:47:10.708]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.708]                 ...future.rng), started = ...future.startTime, 
[17:47:10.708]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.708]             version = "1.8"), class = "FutureResult")
[17:47:10.708]     }, finally = {
[17:47:10.708]         if (!identical(...future.workdir, getwd())) 
[17:47:10.708]             setwd(...future.workdir)
[17:47:10.708]         {
[17:47:10.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.708]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.708]             }
[17:47:10.708]             base::options(...future.oldOptions)
[17:47:10.708]             if (.Platform$OS.type == "windows") {
[17:47:10.708]                 old_names <- names(...future.oldEnvVars)
[17:47:10.708]                 envs <- base::Sys.getenv()
[17:47:10.708]                 names <- names(envs)
[17:47:10.708]                 common <- intersect(names, old_names)
[17:47:10.708]                 added <- setdiff(names, old_names)
[17:47:10.708]                 removed <- setdiff(old_names, names)
[17:47:10.708]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.708]                   envs[common]]
[17:47:10.708]                 NAMES <- toupper(changed)
[17:47:10.708]                 args <- list()
[17:47:10.708]                 for (kk in seq_along(NAMES)) {
[17:47:10.708]                   name <- changed[[kk]]
[17:47:10.708]                   NAME <- NAMES[[kk]]
[17:47:10.708]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.708]                     next
[17:47:10.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.708]                 }
[17:47:10.708]                 NAMES <- toupper(added)
[17:47:10.708]                 for (kk in seq_along(NAMES)) {
[17:47:10.708]                   name <- added[[kk]]
[17:47:10.708]                   NAME <- NAMES[[kk]]
[17:47:10.708]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.708]                     next
[17:47:10.708]                   args[[name]] <- ""
[17:47:10.708]                 }
[17:47:10.708]                 NAMES <- toupper(removed)
[17:47:10.708]                 for (kk in seq_along(NAMES)) {
[17:47:10.708]                   name <- removed[[kk]]
[17:47:10.708]                   NAME <- NAMES[[kk]]
[17:47:10.708]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.708]                     next
[17:47:10.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.708]                 }
[17:47:10.708]                 if (length(args) > 0) 
[17:47:10.708]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.708]             }
[17:47:10.708]             else {
[17:47:10.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.708]             }
[17:47:10.708]             {
[17:47:10.708]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.708]                   0L) {
[17:47:10.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.708]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.708]                   base::options(opts)
[17:47:10.708]                 }
[17:47:10.708]                 {
[17:47:10.708]                   {
[17:47:10.708]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.708]                     NULL
[17:47:10.708]                   }
[17:47:10.708]                   options(future.plan = NULL)
[17:47:10.708]                   if (is.na(NA_character_)) 
[17:47:10.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.708]                     .init = FALSE)
[17:47:10.708]                 }
[17:47:10.708]             }
[17:47:10.708]         }
[17:47:10.708]     })
[17:47:10.708]     if (TRUE) {
[17:47:10.708]         base::sink(type = "output", split = FALSE)
[17:47:10.708]         if (TRUE) {
[17:47:10.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.708]         }
[17:47:10.708]         else {
[17:47:10.708]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.708]         }
[17:47:10.708]         base::close(...future.stdout)
[17:47:10.708]         ...future.stdout <- NULL
[17:47:10.708]     }
[17:47:10.708]     ...future.result$conditions <- ...future.conditions
[17:47:10.708]     ...future.result$finished <- base::Sys.time()
[17:47:10.708]     ...future.result
[17:47:10.708] }
[17:47:10.711] MultisessionFuture started
[17:47:10.711] - Launch lazy future ... done
[17:47:10.711] run() for ‘MultisessionFuture’ ... done
[17:47:10.753] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.753] - Validating connection of MultisessionFuture
[17:47:10.753] - received message: FutureResult
[17:47:10.753] - Received FutureResult
[17:47:10.754] - Erased future from FutureRegistry
[17:47:10.754] result() for ClusterFuture ...
[17:47:10.754] - result already collected: FutureResult
[17:47:10.754] result() for ClusterFuture ... done
[17:47:10.754] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.754] Future #1
[17:47:10.754] result() for ClusterFuture ...
[17:47:10.754] - result already collected: FutureResult
[17:47:10.754] result() for ClusterFuture ... done
[17:47:10.754] result() for ClusterFuture ...
[17:47:10.754] - result already collected: FutureResult
[17:47:10.754] result() for ClusterFuture ... done
[17:47:10.755] A MultisessionFuture was resolved
[17:47:10.755]  length: 0 (resolved future 1)
[17:47:10.755] resolve() on list ... DONE
[17:47:10.755] - globals: [1] ‘a’
[17:47:10.755] Resolving futures part of globals (recursively) ... DONE
[17:47:10.757] The total size of the 1 globals is 1.57 MiB (1647368 bytes)
[17:47:10.757] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:47:10.757] - globals: [1] ‘a’
[17:47:10.758] - packages: [1] ‘future’
[17:47:10.758] getGlobalsAndPackages() ... DONE
[17:47:10.758] run() for ‘Future’ ...
[17:47:10.758] - state: ‘created’
[17:47:10.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.772] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.772]   - Field: ‘node’
[17:47:10.772]   - Field: ‘label’
[17:47:10.772]   - Field: ‘local’
[17:47:10.772]   - Field: ‘owner’
[17:47:10.772]   - Field: ‘envir’
[17:47:10.772]   - Field: ‘workers’
[17:47:10.772]   - Field: ‘packages’
[17:47:10.772]   - Field: ‘gc’
[17:47:10.773]   - Field: ‘conditions’
[17:47:10.773]   - Field: ‘persistent’
[17:47:10.773]   - Field: ‘expr’
[17:47:10.773]   - Field: ‘uuid’
[17:47:10.773]   - Field: ‘seed’
[17:47:10.773]   - Field: ‘version’
[17:47:10.773]   - Field: ‘result’
[17:47:10.773]   - Field: ‘asynchronous’
[17:47:10.773]   - Field: ‘calls’
[17:47:10.773]   - Field: ‘globals’
[17:47:10.773]   - Field: ‘stdout’
[17:47:10.774]   - Field: ‘earlySignal’
[17:47:10.774]   - Field: ‘lazy’
[17:47:10.774]   - Field: ‘state’
[17:47:10.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.774] - Launch lazy future ...
[17:47:10.774] Packages needed by the future expression (n = 1): ‘future’
[17:47:10.774] Packages needed by future strategies (n = 0): <none>
[17:47:10.775] {
[17:47:10.775]     {
[17:47:10.775]         {
[17:47:10.775]             ...future.startTime <- base::Sys.time()
[17:47:10.775]             {
[17:47:10.775]                 {
[17:47:10.775]                   {
[17:47:10.775]                     {
[17:47:10.775]                       {
[17:47:10.775]                         base::local({
[17:47:10.775]                           has_future <- base::requireNamespace("future", 
[17:47:10.775]                             quietly = TRUE)
[17:47:10.775]                           if (has_future) {
[17:47:10.775]                             ns <- base::getNamespace("future")
[17:47:10.775]                             version <- ns[[".package"]][["version"]]
[17:47:10.775]                             if (is.null(version)) 
[17:47:10.775]                               version <- utils::packageVersion("future")
[17:47:10.775]                           }
[17:47:10.775]                           else {
[17:47:10.775]                             version <- NULL
[17:47:10.775]                           }
[17:47:10.775]                           if (!has_future || version < "1.8.0") {
[17:47:10.775]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.775]                               "", base::R.version$version.string), 
[17:47:10.775]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:10.775]                                 base::R.version$platform, 8 * 
[17:47:10.775]                                   base::.Machine$sizeof.pointer), 
[17:47:10.775]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.775]                                 "release", "version")], collapse = " "), 
[17:47:10.775]                               hostname = base::Sys.info()[["nodename"]])
[17:47:10.775]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.775]                               info)
[17:47:10.775]                             info <- base::paste(info, collapse = "; ")
[17:47:10.775]                             if (!has_future) {
[17:47:10.775]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.775]                                 info)
[17:47:10.775]                             }
[17:47:10.775]                             else {
[17:47:10.775]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.775]                                 info, version)
[17:47:10.775]                             }
[17:47:10.775]                             base::stop(msg)
[17:47:10.775]                           }
[17:47:10.775]                         })
[17:47:10.775]                       }
[17:47:10.775]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.775]                       base::options(mc.cores = 1L)
[17:47:10.775]                     }
[17:47:10.775]                     base::local({
[17:47:10.775]                       for (pkg in "future") {
[17:47:10.775]                         base::loadNamespace(pkg)
[17:47:10.775]                         base::library(pkg, character.only = TRUE)
[17:47:10.775]                       }
[17:47:10.775]                     })
[17:47:10.775]                   }
[17:47:10.775]                   ...future.strategy.old <- future::plan("list")
[17:47:10.775]                   options(future.plan = NULL)
[17:47:10.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.775]                 }
[17:47:10.775]                 ...future.workdir <- getwd()
[17:47:10.775]             }
[17:47:10.775]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.775]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.775]         }
[17:47:10.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.775]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.775]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.775]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.775]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.775]             base::names(...future.oldOptions))
[17:47:10.775]     }
[17:47:10.775]     if (FALSE) {
[17:47:10.775]     }
[17:47:10.775]     else {
[17:47:10.775]         if (TRUE) {
[17:47:10.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.775]                 open = "w")
[17:47:10.775]         }
[17:47:10.775]         else {
[17:47:10.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.775]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.775]         }
[17:47:10.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.775]             base::sink(type = "output", split = FALSE)
[17:47:10.775]             base::close(...future.stdout)
[17:47:10.775]         }, add = TRUE)
[17:47:10.775]     }
[17:47:10.775]     ...future.frame <- base::sys.nframe()
[17:47:10.775]     ...future.conditions <- base::list()
[17:47:10.775]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.775]     if (FALSE) {
[17:47:10.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.775]     }
[17:47:10.775]     ...future.result <- base::tryCatch({
[17:47:10.775]         base::withCallingHandlers({
[17:47:10.775]             ...future.value <- base::withVisible(base::local({
[17:47:10.775]                 ...future.makeSendCondition <- base::local({
[17:47:10.775]                   sendCondition <- NULL
[17:47:10.775]                   function(frame = 1L) {
[17:47:10.775]                     if (is.function(sendCondition)) 
[17:47:10.775]                       return(sendCondition)
[17:47:10.775]                     ns <- getNamespace("parallel")
[17:47:10.775]                     if (exists("sendData", mode = "function", 
[17:47:10.775]                       envir = ns)) {
[17:47:10.775]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.775]                         envir = ns)
[17:47:10.775]                       envir <- sys.frame(frame)
[17:47:10.775]                       master <- NULL
[17:47:10.775]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.775]                         !identical(envir, emptyenv())) {
[17:47:10.775]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.775]                           inherits = FALSE)) {
[17:47:10.775]                           master <- get("master", mode = "list", 
[17:47:10.775]                             envir = envir, inherits = FALSE)
[17:47:10.775]                           if (inherits(master, c("SOCKnode", 
[17:47:10.775]                             "SOCK0node"))) {
[17:47:10.775]                             sendCondition <<- function(cond) {
[17:47:10.775]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.775]                                 success = TRUE)
[17:47:10.775]                               parallel_sendData(master, data)
[17:47:10.775]                             }
[17:47:10.775]                             return(sendCondition)
[17:47:10.775]                           }
[17:47:10.775]                         }
[17:47:10.775]                         frame <- frame + 1L
[17:47:10.775]                         envir <- sys.frame(frame)
[17:47:10.775]                       }
[17:47:10.775]                     }
[17:47:10.775]                     sendCondition <<- function(cond) NULL
[17:47:10.775]                   }
[17:47:10.775]                 })
[17:47:10.775]                 withCallingHandlers({
[17:47:10.775]                   value(a) + 1
[17:47:10.775]                 }, immediateCondition = function(cond) {
[17:47:10.775]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.775]                   sendCondition(cond)
[17:47:10.775]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.775]                   {
[17:47:10.775]                     inherits <- base::inherits
[17:47:10.775]                     invokeRestart <- base::invokeRestart
[17:47:10.775]                     is.null <- base::is.null
[17:47:10.775]                     muffled <- FALSE
[17:47:10.775]                     if (inherits(cond, "message")) {
[17:47:10.775]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.775]                       if (muffled) 
[17:47:10.775]                         invokeRestart("muffleMessage")
[17:47:10.775]                     }
[17:47:10.775]                     else if (inherits(cond, "warning")) {
[17:47:10.775]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.775]                       if (muffled) 
[17:47:10.775]                         invokeRestart("muffleWarning")
[17:47:10.775]                     }
[17:47:10.775]                     else if (inherits(cond, "condition")) {
[17:47:10.775]                       if (!is.null(pattern)) {
[17:47:10.775]                         computeRestarts <- base::computeRestarts
[17:47:10.775]                         grepl <- base::grepl
[17:47:10.775]                         restarts <- computeRestarts(cond)
[17:47:10.775]                         for (restart in restarts) {
[17:47:10.775]                           name <- restart$name
[17:47:10.775]                           if (is.null(name)) 
[17:47:10.775]                             next
[17:47:10.775]                           if (!grepl(pattern, name)) 
[17:47:10.775]                             next
[17:47:10.775]                           invokeRestart(restart)
[17:47:10.775]                           muffled <- TRUE
[17:47:10.775]                           break
[17:47:10.775]                         }
[17:47:10.775]                       }
[17:47:10.775]                     }
[17:47:10.775]                     invisible(muffled)
[17:47:10.775]                   }
[17:47:10.775]                   muffleCondition(cond)
[17:47:10.775]                 })
[17:47:10.775]             }))
[17:47:10.775]             future::FutureResult(value = ...future.value$value, 
[17:47:10.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.775]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.775]                     ...future.globalenv.names))
[17:47:10.775]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.775]         }, condition = base::local({
[17:47:10.775]             c <- base::c
[17:47:10.775]             inherits <- base::inherits
[17:47:10.775]             invokeRestart <- base::invokeRestart
[17:47:10.775]             length <- base::length
[17:47:10.775]             list <- base::list
[17:47:10.775]             seq.int <- base::seq.int
[17:47:10.775]             signalCondition <- base::signalCondition
[17:47:10.775]             sys.calls <- base::sys.calls
[17:47:10.775]             `[[` <- base::`[[`
[17:47:10.775]             `+` <- base::`+`
[17:47:10.775]             `<<-` <- base::`<<-`
[17:47:10.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.775]                   3L)]
[17:47:10.775]             }
[17:47:10.775]             function(cond) {
[17:47:10.775]                 is_error <- inherits(cond, "error")
[17:47:10.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.775]                   NULL)
[17:47:10.775]                 if (is_error) {
[17:47:10.775]                   sessionInformation <- function() {
[17:47:10.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.775]                       search = base::search(), system = base::Sys.info())
[17:47:10.775]                   }
[17:47:10.775]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.775]                     cond$call), session = sessionInformation(), 
[17:47:10.775]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.775]                   signalCondition(cond)
[17:47:10.775]                 }
[17:47:10.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.775]                 "immediateCondition"))) {
[17:47:10.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.775]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.775]                   if (TRUE && !signal) {
[17:47:10.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.775]                     {
[17:47:10.775]                       inherits <- base::inherits
[17:47:10.775]                       invokeRestart <- base::invokeRestart
[17:47:10.775]                       is.null <- base::is.null
[17:47:10.775]                       muffled <- FALSE
[17:47:10.775]                       if (inherits(cond, "message")) {
[17:47:10.775]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.775]                         if (muffled) 
[17:47:10.775]                           invokeRestart("muffleMessage")
[17:47:10.775]                       }
[17:47:10.775]                       else if (inherits(cond, "warning")) {
[17:47:10.775]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.775]                         if (muffled) 
[17:47:10.775]                           invokeRestart("muffleWarning")
[17:47:10.775]                       }
[17:47:10.775]                       else if (inherits(cond, "condition")) {
[17:47:10.775]                         if (!is.null(pattern)) {
[17:47:10.775]                           computeRestarts <- base::computeRestarts
[17:47:10.775]                           grepl <- base::grepl
[17:47:10.775]                           restarts <- computeRestarts(cond)
[17:47:10.775]                           for (restart in restarts) {
[17:47:10.775]                             name <- restart$name
[17:47:10.775]                             if (is.null(name)) 
[17:47:10.775]                               next
[17:47:10.775]                             if (!grepl(pattern, name)) 
[17:47:10.775]                               next
[17:47:10.775]                             invokeRestart(restart)
[17:47:10.775]                             muffled <- TRUE
[17:47:10.775]                             break
[17:47:10.775]                           }
[17:47:10.775]                         }
[17:47:10.775]                       }
[17:47:10.775]                       invisible(muffled)
[17:47:10.775]                     }
[17:47:10.775]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.775]                   }
[17:47:10.775]                 }
[17:47:10.775]                 else {
[17:47:10.775]                   if (TRUE) {
[17:47:10.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.775]                     {
[17:47:10.775]                       inherits <- base::inherits
[17:47:10.775]                       invokeRestart <- base::invokeRestart
[17:47:10.775]                       is.null <- base::is.null
[17:47:10.775]                       muffled <- FALSE
[17:47:10.775]                       if (inherits(cond, "message")) {
[17:47:10.775]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.775]                         if (muffled) 
[17:47:10.775]                           invokeRestart("muffleMessage")
[17:47:10.775]                       }
[17:47:10.775]                       else if (inherits(cond, "warning")) {
[17:47:10.775]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.775]                         if (muffled) 
[17:47:10.775]                           invokeRestart("muffleWarning")
[17:47:10.775]                       }
[17:47:10.775]                       else if (inherits(cond, "condition")) {
[17:47:10.775]                         if (!is.null(pattern)) {
[17:47:10.775]                           computeRestarts <- base::computeRestarts
[17:47:10.775]                           grepl <- base::grepl
[17:47:10.775]                           restarts <- computeRestarts(cond)
[17:47:10.775]                           for (restart in restarts) {
[17:47:10.775]                             name <- restart$name
[17:47:10.775]                             if (is.null(name)) 
[17:47:10.775]                               next
[17:47:10.775]                             if (!grepl(pattern, name)) 
[17:47:10.775]                               next
[17:47:10.775]                             invokeRestart(restart)
[17:47:10.775]                             muffled <- TRUE
[17:47:10.775]                             break
[17:47:10.775]                           }
[17:47:10.775]                         }
[17:47:10.775]                       }
[17:47:10.775]                       invisible(muffled)
[17:47:10.775]                     }
[17:47:10.775]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.775]                   }
[17:47:10.775]                 }
[17:47:10.775]             }
[17:47:10.775]         }))
[17:47:10.775]     }, error = function(ex) {
[17:47:10.775]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.775]                 ...future.rng), started = ...future.startTime, 
[17:47:10.775]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.775]             version = "1.8"), class = "FutureResult")
[17:47:10.775]     }, finally = {
[17:47:10.775]         if (!identical(...future.workdir, getwd())) 
[17:47:10.775]             setwd(...future.workdir)
[17:47:10.775]         {
[17:47:10.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.775]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.775]             }
[17:47:10.775]             base::options(...future.oldOptions)
[17:47:10.775]             if (.Platform$OS.type == "windows") {
[17:47:10.775]                 old_names <- names(...future.oldEnvVars)
[17:47:10.775]                 envs <- base::Sys.getenv()
[17:47:10.775]                 names <- names(envs)
[17:47:10.775]                 common <- intersect(names, old_names)
[17:47:10.775]                 added <- setdiff(names, old_names)
[17:47:10.775]                 removed <- setdiff(old_names, names)
[17:47:10.775]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.775]                   envs[common]]
[17:47:10.775]                 NAMES <- toupper(changed)
[17:47:10.775]                 args <- list()
[17:47:10.775]                 for (kk in seq_along(NAMES)) {
[17:47:10.775]                   name <- changed[[kk]]
[17:47:10.775]                   NAME <- NAMES[[kk]]
[17:47:10.775]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.775]                     next
[17:47:10.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.775]                 }
[17:47:10.775]                 NAMES <- toupper(added)
[17:47:10.775]                 for (kk in seq_along(NAMES)) {
[17:47:10.775]                   name <- added[[kk]]
[17:47:10.775]                   NAME <- NAMES[[kk]]
[17:47:10.775]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.775]                     next
[17:47:10.775]                   args[[name]] <- ""
[17:47:10.775]                 }
[17:47:10.775]                 NAMES <- toupper(removed)
[17:47:10.775]                 for (kk in seq_along(NAMES)) {
[17:47:10.775]                   name <- removed[[kk]]
[17:47:10.775]                   NAME <- NAMES[[kk]]
[17:47:10.775]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.775]                     next
[17:47:10.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.775]                 }
[17:47:10.775]                 if (length(args) > 0) 
[17:47:10.775]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.775]             }
[17:47:10.775]             else {
[17:47:10.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.775]             }
[17:47:10.775]             {
[17:47:10.775]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.775]                   0L) {
[17:47:10.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.775]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.775]                   base::options(opts)
[17:47:10.775]                 }
[17:47:10.775]                 {
[17:47:10.775]                   {
[17:47:10.775]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.775]                     NULL
[17:47:10.775]                   }
[17:47:10.775]                   options(future.plan = NULL)
[17:47:10.775]                   if (is.na(NA_character_)) 
[17:47:10.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.775]                     .init = FALSE)
[17:47:10.775]                 }
[17:47:10.775]             }
[17:47:10.775]         }
[17:47:10.775]     })
[17:47:10.775]     if (TRUE) {
[17:47:10.775]         base::sink(type = "output", split = FALSE)
[17:47:10.775]         if (TRUE) {
[17:47:10.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.775]         }
[17:47:10.775]         else {
[17:47:10.775]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.775]         }
[17:47:10.775]         base::close(...future.stdout)
[17:47:10.775]         ...future.stdout <- NULL
[17:47:10.775]     }
[17:47:10.775]     ...future.result$conditions <- ...future.conditions
[17:47:10.775]     ...future.result$finished <- base::Sys.time()
[17:47:10.775]     ...future.result
[17:47:10.775] }
[17:47:10.777] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:47:10.779] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:47:10.832] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:47:10.832] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:47:10.832] MultisessionFuture started
[17:47:10.832] - Launch lazy future ... done
[17:47:10.833] run() for ‘MultisessionFuture’ ... done
[17:47:10.833] result() for ClusterFuture ...
[17:47:10.833] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.833] - Validating connection of MultisessionFuture
[17:47:10.877] - received message: FutureResult
[17:47:10.878] - Received FutureResult
[17:47:10.878] - Erased future from FutureRegistry
[17:47:10.878] result() for ClusterFuture ...
[17:47:10.878] - result already collected: FutureResult
[17:47:10.878] result() for ClusterFuture ... done
[17:47:10.878] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.878] result() for ClusterFuture ... done
[17:47:10.878] result() for ClusterFuture ...
[17:47:10.879] - result already collected: FutureResult
[17:47:10.879] result() for ClusterFuture ... done
value(b) = 2
[17:47:10.879] result() for ClusterFuture ...
[17:47:10.879] - result already collected: FutureResult
[17:47:10.879] result() for ClusterFuture ... done
[17:47:10.879] result() for ClusterFuture ...
[17:47:10.879] - result already collected: FutureResult
[17:47:10.879] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.880] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.880] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.880] 
[17:47:10.880] Searching for globals ... DONE
[17:47:10.880] - globals: [0] <none>
[17:47:10.880] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:10.881] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:10.881] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:10.882] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:47:10.882] Searching for globals ... DONE
[17:47:10.882] Resolving globals: TRUE
[17:47:10.882] Resolving any globals that are futures ...
[17:47:10.882] - globals: [3] ‘+’, ‘value’, ‘a’
[17:47:10.882] Resolving any globals that are futures ... DONE
[17:47:10.882] Resolving futures part of globals (recursively) ...
[17:47:10.883] resolve() on list ...
[17:47:10.883]  recursive: 99
[17:47:10.883]  length: 1
[17:47:10.883]  elements: ‘a’
[17:47:10.883] run() for ‘Future’ ...
[17:47:10.883] - state: ‘created’
[17:47:10.883] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.897] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.898]   - Field: ‘node’
[17:47:10.898]   - Field: ‘label’
[17:47:10.898]   - Field: ‘local’
[17:47:10.898]   - Field: ‘owner’
[17:47:10.898]   - Field: ‘envir’
[17:47:10.898]   - Field: ‘workers’
[17:47:10.898]   - Field: ‘packages’
[17:47:10.898]   - Field: ‘gc’
[17:47:10.898]   - Field: ‘conditions’
[17:47:10.898]   - Field: ‘persistent’
[17:47:10.898]   - Field: ‘expr’
[17:47:10.899]   - Field: ‘uuid’
[17:47:10.899]   - Field: ‘seed’
[17:47:10.899]   - Field: ‘version’
[17:47:10.899]   - Field: ‘result’
[17:47:10.899]   - Field: ‘asynchronous’
[17:47:10.899]   - Field: ‘calls’
[17:47:10.899]   - Field: ‘globals’
[17:47:10.899]   - Field: ‘stdout’
[17:47:10.899]   - Field: ‘earlySignal’
[17:47:10.899]   - Field: ‘lazy’
[17:47:10.900]   - Field: ‘state’
[17:47:10.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.900] - Launch lazy future ...
[17:47:10.900] Packages needed by the future expression (n = 0): <none>
[17:47:10.900] Packages needed by future strategies (n = 0): <none>
[17:47:10.901] {
[17:47:10.901]     {
[17:47:10.901]         {
[17:47:10.901]             ...future.startTime <- base::Sys.time()
[17:47:10.901]             {
[17:47:10.901]                 {
[17:47:10.901]                   {
[17:47:10.901]                     {
[17:47:10.901]                       base::local({
[17:47:10.901]                         has_future <- base::requireNamespace("future", 
[17:47:10.901]                           quietly = TRUE)
[17:47:10.901]                         if (has_future) {
[17:47:10.901]                           ns <- base::getNamespace("future")
[17:47:10.901]                           version <- ns[[".package"]][["version"]]
[17:47:10.901]                           if (is.null(version)) 
[17:47:10.901]                             version <- utils::packageVersion("future")
[17:47:10.901]                         }
[17:47:10.901]                         else {
[17:47:10.901]                           version <- NULL
[17:47:10.901]                         }
[17:47:10.901]                         if (!has_future || version < "1.8.0") {
[17:47:10.901]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.901]                             "", base::R.version$version.string), 
[17:47:10.901]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:10.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:10.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.901]                               "release", "version")], collapse = " "), 
[17:47:10.901]                             hostname = base::Sys.info()[["nodename"]])
[17:47:10.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.901]                             info)
[17:47:10.901]                           info <- base::paste(info, collapse = "; ")
[17:47:10.901]                           if (!has_future) {
[17:47:10.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.901]                               info)
[17:47:10.901]                           }
[17:47:10.901]                           else {
[17:47:10.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.901]                               info, version)
[17:47:10.901]                           }
[17:47:10.901]                           base::stop(msg)
[17:47:10.901]                         }
[17:47:10.901]                       })
[17:47:10.901]                     }
[17:47:10.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.901]                     base::options(mc.cores = 1L)
[17:47:10.901]                   }
[17:47:10.901]                   ...future.strategy.old <- future::plan("list")
[17:47:10.901]                   options(future.plan = NULL)
[17:47:10.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.901]                 }
[17:47:10.901]                 ...future.workdir <- getwd()
[17:47:10.901]             }
[17:47:10.901]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.901]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.901]         }
[17:47:10.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.901]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.901]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.901]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.901]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.901]             base::names(...future.oldOptions))
[17:47:10.901]     }
[17:47:10.901]     if (FALSE) {
[17:47:10.901]     }
[17:47:10.901]     else {
[17:47:10.901]         if (TRUE) {
[17:47:10.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.901]                 open = "w")
[17:47:10.901]         }
[17:47:10.901]         else {
[17:47:10.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.901]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.901]         }
[17:47:10.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.901]             base::sink(type = "output", split = FALSE)
[17:47:10.901]             base::close(...future.stdout)
[17:47:10.901]         }, add = TRUE)
[17:47:10.901]     }
[17:47:10.901]     ...future.frame <- base::sys.nframe()
[17:47:10.901]     ...future.conditions <- base::list()
[17:47:10.901]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.901]     if (FALSE) {
[17:47:10.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.901]     }
[17:47:10.901]     ...future.result <- base::tryCatch({
[17:47:10.901]         base::withCallingHandlers({
[17:47:10.901]             ...future.value <- base::withVisible(base::local({
[17:47:10.901]                 ...future.makeSendCondition <- base::local({
[17:47:10.901]                   sendCondition <- NULL
[17:47:10.901]                   function(frame = 1L) {
[17:47:10.901]                     if (is.function(sendCondition)) 
[17:47:10.901]                       return(sendCondition)
[17:47:10.901]                     ns <- getNamespace("parallel")
[17:47:10.901]                     if (exists("sendData", mode = "function", 
[17:47:10.901]                       envir = ns)) {
[17:47:10.901]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.901]                         envir = ns)
[17:47:10.901]                       envir <- sys.frame(frame)
[17:47:10.901]                       master <- NULL
[17:47:10.901]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.901]                         !identical(envir, emptyenv())) {
[17:47:10.901]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.901]                           inherits = FALSE)) {
[17:47:10.901]                           master <- get("master", mode = "list", 
[17:47:10.901]                             envir = envir, inherits = FALSE)
[17:47:10.901]                           if (inherits(master, c("SOCKnode", 
[17:47:10.901]                             "SOCK0node"))) {
[17:47:10.901]                             sendCondition <<- function(cond) {
[17:47:10.901]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.901]                                 success = TRUE)
[17:47:10.901]                               parallel_sendData(master, data)
[17:47:10.901]                             }
[17:47:10.901]                             return(sendCondition)
[17:47:10.901]                           }
[17:47:10.901]                         }
[17:47:10.901]                         frame <- frame + 1L
[17:47:10.901]                         envir <- sys.frame(frame)
[17:47:10.901]                       }
[17:47:10.901]                     }
[17:47:10.901]                     sendCondition <<- function(cond) NULL
[17:47:10.901]                   }
[17:47:10.901]                 })
[17:47:10.901]                 withCallingHandlers({
[17:47:10.901]                   1
[17:47:10.901]                 }, immediateCondition = function(cond) {
[17:47:10.901]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.901]                   sendCondition(cond)
[17:47:10.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.901]                   {
[17:47:10.901]                     inherits <- base::inherits
[17:47:10.901]                     invokeRestart <- base::invokeRestart
[17:47:10.901]                     is.null <- base::is.null
[17:47:10.901]                     muffled <- FALSE
[17:47:10.901]                     if (inherits(cond, "message")) {
[17:47:10.901]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.901]                       if (muffled) 
[17:47:10.901]                         invokeRestart("muffleMessage")
[17:47:10.901]                     }
[17:47:10.901]                     else if (inherits(cond, "warning")) {
[17:47:10.901]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.901]                       if (muffled) 
[17:47:10.901]                         invokeRestart("muffleWarning")
[17:47:10.901]                     }
[17:47:10.901]                     else if (inherits(cond, "condition")) {
[17:47:10.901]                       if (!is.null(pattern)) {
[17:47:10.901]                         computeRestarts <- base::computeRestarts
[17:47:10.901]                         grepl <- base::grepl
[17:47:10.901]                         restarts <- computeRestarts(cond)
[17:47:10.901]                         for (restart in restarts) {
[17:47:10.901]                           name <- restart$name
[17:47:10.901]                           if (is.null(name)) 
[17:47:10.901]                             next
[17:47:10.901]                           if (!grepl(pattern, name)) 
[17:47:10.901]                             next
[17:47:10.901]                           invokeRestart(restart)
[17:47:10.901]                           muffled <- TRUE
[17:47:10.901]                           break
[17:47:10.901]                         }
[17:47:10.901]                       }
[17:47:10.901]                     }
[17:47:10.901]                     invisible(muffled)
[17:47:10.901]                   }
[17:47:10.901]                   muffleCondition(cond)
[17:47:10.901]                 })
[17:47:10.901]             }))
[17:47:10.901]             future::FutureResult(value = ...future.value$value, 
[17:47:10.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.901]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.901]                     ...future.globalenv.names))
[17:47:10.901]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.901]         }, condition = base::local({
[17:47:10.901]             c <- base::c
[17:47:10.901]             inherits <- base::inherits
[17:47:10.901]             invokeRestart <- base::invokeRestart
[17:47:10.901]             length <- base::length
[17:47:10.901]             list <- base::list
[17:47:10.901]             seq.int <- base::seq.int
[17:47:10.901]             signalCondition <- base::signalCondition
[17:47:10.901]             sys.calls <- base::sys.calls
[17:47:10.901]             `[[` <- base::`[[`
[17:47:10.901]             `+` <- base::`+`
[17:47:10.901]             `<<-` <- base::`<<-`
[17:47:10.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.901]                   3L)]
[17:47:10.901]             }
[17:47:10.901]             function(cond) {
[17:47:10.901]                 is_error <- inherits(cond, "error")
[17:47:10.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.901]                   NULL)
[17:47:10.901]                 if (is_error) {
[17:47:10.901]                   sessionInformation <- function() {
[17:47:10.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.901]                       search = base::search(), system = base::Sys.info())
[17:47:10.901]                   }
[17:47:10.901]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.901]                     cond$call), session = sessionInformation(), 
[17:47:10.901]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.901]                   signalCondition(cond)
[17:47:10.901]                 }
[17:47:10.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.901]                 "immediateCondition"))) {
[17:47:10.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.901]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.901]                   if (TRUE && !signal) {
[17:47:10.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.901]                     {
[17:47:10.901]                       inherits <- base::inherits
[17:47:10.901]                       invokeRestart <- base::invokeRestart
[17:47:10.901]                       is.null <- base::is.null
[17:47:10.901]                       muffled <- FALSE
[17:47:10.901]                       if (inherits(cond, "message")) {
[17:47:10.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.901]                         if (muffled) 
[17:47:10.901]                           invokeRestart("muffleMessage")
[17:47:10.901]                       }
[17:47:10.901]                       else if (inherits(cond, "warning")) {
[17:47:10.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.901]                         if (muffled) 
[17:47:10.901]                           invokeRestart("muffleWarning")
[17:47:10.901]                       }
[17:47:10.901]                       else if (inherits(cond, "condition")) {
[17:47:10.901]                         if (!is.null(pattern)) {
[17:47:10.901]                           computeRestarts <- base::computeRestarts
[17:47:10.901]                           grepl <- base::grepl
[17:47:10.901]                           restarts <- computeRestarts(cond)
[17:47:10.901]                           for (restart in restarts) {
[17:47:10.901]                             name <- restart$name
[17:47:10.901]                             if (is.null(name)) 
[17:47:10.901]                               next
[17:47:10.901]                             if (!grepl(pattern, name)) 
[17:47:10.901]                               next
[17:47:10.901]                             invokeRestart(restart)
[17:47:10.901]                             muffled <- TRUE
[17:47:10.901]                             break
[17:47:10.901]                           }
[17:47:10.901]                         }
[17:47:10.901]                       }
[17:47:10.901]                       invisible(muffled)
[17:47:10.901]                     }
[17:47:10.901]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.901]                   }
[17:47:10.901]                 }
[17:47:10.901]                 else {
[17:47:10.901]                   if (TRUE) {
[17:47:10.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.901]                     {
[17:47:10.901]                       inherits <- base::inherits
[17:47:10.901]                       invokeRestart <- base::invokeRestart
[17:47:10.901]                       is.null <- base::is.null
[17:47:10.901]                       muffled <- FALSE
[17:47:10.901]                       if (inherits(cond, "message")) {
[17:47:10.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.901]                         if (muffled) 
[17:47:10.901]                           invokeRestart("muffleMessage")
[17:47:10.901]                       }
[17:47:10.901]                       else if (inherits(cond, "warning")) {
[17:47:10.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.901]                         if (muffled) 
[17:47:10.901]                           invokeRestart("muffleWarning")
[17:47:10.901]                       }
[17:47:10.901]                       else if (inherits(cond, "condition")) {
[17:47:10.901]                         if (!is.null(pattern)) {
[17:47:10.901]                           computeRestarts <- base::computeRestarts
[17:47:10.901]                           grepl <- base::grepl
[17:47:10.901]                           restarts <- computeRestarts(cond)
[17:47:10.901]                           for (restart in restarts) {
[17:47:10.901]                             name <- restart$name
[17:47:10.901]                             if (is.null(name)) 
[17:47:10.901]                               next
[17:47:10.901]                             if (!grepl(pattern, name)) 
[17:47:10.901]                               next
[17:47:10.901]                             invokeRestart(restart)
[17:47:10.901]                             muffled <- TRUE
[17:47:10.901]                             break
[17:47:10.901]                           }
[17:47:10.901]                         }
[17:47:10.901]                       }
[17:47:10.901]                       invisible(muffled)
[17:47:10.901]                     }
[17:47:10.901]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.901]                   }
[17:47:10.901]                 }
[17:47:10.901]             }
[17:47:10.901]         }))
[17:47:10.901]     }, error = function(ex) {
[17:47:10.901]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.901]                 ...future.rng), started = ...future.startTime, 
[17:47:10.901]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.901]             version = "1.8"), class = "FutureResult")
[17:47:10.901]     }, finally = {
[17:47:10.901]         if (!identical(...future.workdir, getwd())) 
[17:47:10.901]             setwd(...future.workdir)
[17:47:10.901]         {
[17:47:10.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.901]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.901]             }
[17:47:10.901]             base::options(...future.oldOptions)
[17:47:10.901]             if (.Platform$OS.type == "windows") {
[17:47:10.901]                 old_names <- names(...future.oldEnvVars)
[17:47:10.901]                 envs <- base::Sys.getenv()
[17:47:10.901]                 names <- names(envs)
[17:47:10.901]                 common <- intersect(names, old_names)
[17:47:10.901]                 added <- setdiff(names, old_names)
[17:47:10.901]                 removed <- setdiff(old_names, names)
[17:47:10.901]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.901]                   envs[common]]
[17:47:10.901]                 NAMES <- toupper(changed)
[17:47:10.901]                 args <- list()
[17:47:10.901]                 for (kk in seq_along(NAMES)) {
[17:47:10.901]                   name <- changed[[kk]]
[17:47:10.901]                   NAME <- NAMES[[kk]]
[17:47:10.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.901]                     next
[17:47:10.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.901]                 }
[17:47:10.901]                 NAMES <- toupper(added)
[17:47:10.901]                 for (kk in seq_along(NAMES)) {
[17:47:10.901]                   name <- added[[kk]]
[17:47:10.901]                   NAME <- NAMES[[kk]]
[17:47:10.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.901]                     next
[17:47:10.901]                   args[[name]] <- ""
[17:47:10.901]                 }
[17:47:10.901]                 NAMES <- toupper(removed)
[17:47:10.901]                 for (kk in seq_along(NAMES)) {
[17:47:10.901]                   name <- removed[[kk]]
[17:47:10.901]                   NAME <- NAMES[[kk]]
[17:47:10.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.901]                     next
[17:47:10.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.901]                 }
[17:47:10.901]                 if (length(args) > 0) 
[17:47:10.901]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.901]             }
[17:47:10.901]             else {
[17:47:10.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.901]             }
[17:47:10.901]             {
[17:47:10.901]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.901]                   0L) {
[17:47:10.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.901]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.901]                   base::options(opts)
[17:47:10.901]                 }
[17:47:10.901]                 {
[17:47:10.901]                   {
[17:47:10.901]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.901]                     NULL
[17:47:10.901]                   }
[17:47:10.901]                   options(future.plan = NULL)
[17:47:10.901]                   if (is.na(NA_character_)) 
[17:47:10.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.901]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.901]                     .init = FALSE)
[17:47:10.901]                 }
[17:47:10.901]             }
[17:47:10.901]         }
[17:47:10.901]     })
[17:47:10.901]     if (TRUE) {
[17:47:10.901]         base::sink(type = "output", split = FALSE)
[17:47:10.901]         if (TRUE) {
[17:47:10.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.901]         }
[17:47:10.901]         else {
[17:47:10.901]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.901]         }
[17:47:10.901]         base::close(...future.stdout)
[17:47:10.901]         ...future.stdout <- NULL
[17:47:10.901]     }
[17:47:10.901]     ...future.result$conditions <- ...future.conditions
[17:47:10.901]     ...future.result$finished <- base::Sys.time()
[17:47:10.901]     ...future.result
[17:47:10.901] }
[17:47:10.903] MultisessionFuture started
[17:47:10.904] - Launch lazy future ... done
[17:47:10.904] run() for ‘MultisessionFuture’ ... done
[17:47:10.945] receiveMessageFromWorker() for ClusterFuture ...
[17:47:10.946] - Validating connection of MultisessionFuture
[17:47:10.946] - received message: FutureResult
[17:47:10.946] - Received FutureResult
[17:47:10.946] - Erased future from FutureRegistry
[17:47:10.946] result() for ClusterFuture ...
[17:47:10.946] - result already collected: FutureResult
[17:47:10.946] result() for ClusterFuture ... done
[17:47:10.946] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:10.946] Future #1
[17:47:10.946] result() for ClusterFuture ...
[17:47:10.947] - result already collected: FutureResult
[17:47:10.947] result() for ClusterFuture ... done
[17:47:10.947] result() for ClusterFuture ...
[17:47:10.947] - result already collected: FutureResult
[17:47:10.947] result() for ClusterFuture ... done
[17:47:10.947] A MultisessionFuture was resolved
[17:47:10.947]  length: 0 (resolved future 1)
[17:47:10.947] resolve() on list ... DONE
[17:47:10.947] - globals: [1] ‘a’
[17:47:10.947] Resolving futures part of globals (recursively) ... DONE
[17:47:10.949] The total size of the 1 globals is 1.57 MiB (1647368 bytes)
[17:47:10.950] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:47:10.950] - globals: [1] ‘a’
[17:47:10.950] - packages: [1] ‘future’
[17:47:10.950] getGlobalsAndPackages() ... DONE
[17:47:10.950] run() for ‘Future’ ...
[17:47:10.950] - state: ‘created’
[17:47:10.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:10.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:10.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:10.964]   - Field: ‘node’
[17:47:10.965]   - Field: ‘label’
[17:47:10.965]   - Field: ‘local’
[17:47:10.965]   - Field: ‘owner’
[17:47:10.965]   - Field: ‘envir’
[17:47:10.965]   - Field: ‘workers’
[17:47:10.965]   - Field: ‘packages’
[17:47:10.965]   - Field: ‘gc’
[17:47:10.965]   - Field: ‘conditions’
[17:47:10.965]   - Field: ‘persistent’
[17:47:10.965]   - Field: ‘expr’
[17:47:10.965]   - Field: ‘uuid’
[17:47:10.966]   - Field: ‘seed’
[17:47:10.966]   - Field: ‘version’
[17:47:10.966]   - Field: ‘result’
[17:47:10.966]   - Field: ‘asynchronous’
[17:47:10.966]   - Field: ‘calls’
[17:47:10.966]   - Field: ‘globals’
[17:47:10.966]   - Field: ‘stdout’
[17:47:10.966]   - Field: ‘earlySignal’
[17:47:10.966]   - Field: ‘lazy’
[17:47:10.966]   - Field: ‘state’
[17:47:10.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:10.967] - Launch lazy future ...
[17:47:10.967] Packages needed by the future expression (n = 1): ‘future’
[17:47:10.967] Packages needed by future strategies (n = 0): <none>
[17:47:10.967] {
[17:47:10.967]     {
[17:47:10.967]         {
[17:47:10.967]             ...future.startTime <- base::Sys.time()
[17:47:10.967]             {
[17:47:10.967]                 {
[17:47:10.967]                   {
[17:47:10.967]                     {
[17:47:10.967]                       {
[17:47:10.967]                         base::local({
[17:47:10.967]                           has_future <- base::requireNamespace("future", 
[17:47:10.967]                             quietly = TRUE)
[17:47:10.967]                           if (has_future) {
[17:47:10.967]                             ns <- base::getNamespace("future")
[17:47:10.967]                             version <- ns[[".package"]][["version"]]
[17:47:10.967]                             if (is.null(version)) 
[17:47:10.967]                               version <- utils::packageVersion("future")
[17:47:10.967]                           }
[17:47:10.967]                           else {
[17:47:10.967]                             version <- NULL
[17:47:10.967]                           }
[17:47:10.967]                           if (!has_future || version < "1.8.0") {
[17:47:10.967]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:10.967]                               "", base::R.version$version.string), 
[17:47:10.967]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:10.967]                                 base::R.version$platform, 8 * 
[17:47:10.967]                                   base::.Machine$sizeof.pointer), 
[17:47:10.967]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:10.967]                                 "release", "version")], collapse = " "), 
[17:47:10.967]                               hostname = base::Sys.info()[["nodename"]])
[17:47:10.967]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:10.967]                               info)
[17:47:10.967]                             info <- base::paste(info, collapse = "; ")
[17:47:10.967]                             if (!has_future) {
[17:47:10.967]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:10.967]                                 info)
[17:47:10.967]                             }
[17:47:10.967]                             else {
[17:47:10.967]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:10.967]                                 info, version)
[17:47:10.967]                             }
[17:47:10.967]                             base::stop(msg)
[17:47:10.967]                           }
[17:47:10.967]                         })
[17:47:10.967]                       }
[17:47:10.967]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:10.967]                       base::options(mc.cores = 1L)
[17:47:10.967]                     }
[17:47:10.967]                     base::local({
[17:47:10.967]                       for (pkg in "future") {
[17:47:10.967]                         base::loadNamespace(pkg)
[17:47:10.967]                         base::library(pkg, character.only = TRUE)
[17:47:10.967]                       }
[17:47:10.967]                     })
[17:47:10.967]                   }
[17:47:10.967]                   ...future.strategy.old <- future::plan("list")
[17:47:10.967]                   options(future.plan = NULL)
[17:47:10.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:10.967]                 }
[17:47:10.967]                 ...future.workdir <- getwd()
[17:47:10.967]             }
[17:47:10.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:10.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:10.967]         }
[17:47:10.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:10.967]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:10.967]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:10.967]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:10.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:10.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:10.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:10.967]             base::names(...future.oldOptions))
[17:47:10.967]     }
[17:47:10.967]     if (FALSE) {
[17:47:10.967]     }
[17:47:10.967]     else {
[17:47:10.967]         if (TRUE) {
[17:47:10.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:10.967]                 open = "w")
[17:47:10.967]         }
[17:47:10.967]         else {
[17:47:10.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:10.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:10.967]         }
[17:47:10.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:10.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:10.967]             base::sink(type = "output", split = FALSE)
[17:47:10.967]             base::close(...future.stdout)
[17:47:10.967]         }, add = TRUE)
[17:47:10.967]     }
[17:47:10.967]     ...future.frame <- base::sys.nframe()
[17:47:10.967]     ...future.conditions <- base::list()
[17:47:10.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:10.967]     if (FALSE) {
[17:47:10.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:10.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:10.967]     }
[17:47:10.967]     ...future.result <- base::tryCatch({
[17:47:10.967]         base::withCallingHandlers({
[17:47:10.967]             ...future.value <- base::withVisible(base::local({
[17:47:10.967]                 ...future.makeSendCondition <- base::local({
[17:47:10.967]                   sendCondition <- NULL
[17:47:10.967]                   function(frame = 1L) {
[17:47:10.967]                     if (is.function(sendCondition)) 
[17:47:10.967]                       return(sendCondition)
[17:47:10.967]                     ns <- getNamespace("parallel")
[17:47:10.967]                     if (exists("sendData", mode = "function", 
[17:47:10.967]                       envir = ns)) {
[17:47:10.967]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:10.967]                         envir = ns)
[17:47:10.967]                       envir <- sys.frame(frame)
[17:47:10.967]                       master <- NULL
[17:47:10.967]                       while (!identical(envir, .GlobalEnv) && 
[17:47:10.967]                         !identical(envir, emptyenv())) {
[17:47:10.967]                         if (exists("master", mode = "list", envir = envir, 
[17:47:10.967]                           inherits = FALSE)) {
[17:47:10.967]                           master <- get("master", mode = "list", 
[17:47:10.967]                             envir = envir, inherits = FALSE)
[17:47:10.967]                           if (inherits(master, c("SOCKnode", 
[17:47:10.967]                             "SOCK0node"))) {
[17:47:10.967]                             sendCondition <<- function(cond) {
[17:47:10.967]                               data <- list(type = "VALUE", value = cond, 
[17:47:10.967]                                 success = TRUE)
[17:47:10.967]                               parallel_sendData(master, data)
[17:47:10.967]                             }
[17:47:10.967]                             return(sendCondition)
[17:47:10.967]                           }
[17:47:10.967]                         }
[17:47:10.967]                         frame <- frame + 1L
[17:47:10.967]                         envir <- sys.frame(frame)
[17:47:10.967]                       }
[17:47:10.967]                     }
[17:47:10.967]                     sendCondition <<- function(cond) NULL
[17:47:10.967]                   }
[17:47:10.967]                 })
[17:47:10.967]                 withCallingHandlers({
[17:47:10.967]                   value(a) + 1
[17:47:10.967]                 }, immediateCondition = function(cond) {
[17:47:10.967]                   sendCondition <- ...future.makeSendCondition()
[17:47:10.967]                   sendCondition(cond)
[17:47:10.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.967]                   {
[17:47:10.967]                     inherits <- base::inherits
[17:47:10.967]                     invokeRestart <- base::invokeRestart
[17:47:10.967]                     is.null <- base::is.null
[17:47:10.967]                     muffled <- FALSE
[17:47:10.967]                     if (inherits(cond, "message")) {
[17:47:10.967]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:10.967]                       if (muffled) 
[17:47:10.967]                         invokeRestart("muffleMessage")
[17:47:10.967]                     }
[17:47:10.967]                     else if (inherits(cond, "warning")) {
[17:47:10.967]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:10.967]                       if (muffled) 
[17:47:10.967]                         invokeRestart("muffleWarning")
[17:47:10.967]                     }
[17:47:10.967]                     else if (inherits(cond, "condition")) {
[17:47:10.967]                       if (!is.null(pattern)) {
[17:47:10.967]                         computeRestarts <- base::computeRestarts
[17:47:10.967]                         grepl <- base::grepl
[17:47:10.967]                         restarts <- computeRestarts(cond)
[17:47:10.967]                         for (restart in restarts) {
[17:47:10.967]                           name <- restart$name
[17:47:10.967]                           if (is.null(name)) 
[17:47:10.967]                             next
[17:47:10.967]                           if (!grepl(pattern, name)) 
[17:47:10.967]                             next
[17:47:10.967]                           invokeRestart(restart)
[17:47:10.967]                           muffled <- TRUE
[17:47:10.967]                           break
[17:47:10.967]                         }
[17:47:10.967]                       }
[17:47:10.967]                     }
[17:47:10.967]                     invisible(muffled)
[17:47:10.967]                   }
[17:47:10.967]                   muffleCondition(cond)
[17:47:10.967]                 })
[17:47:10.967]             }))
[17:47:10.967]             future::FutureResult(value = ...future.value$value, 
[17:47:10.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.967]                   ...future.rng), globalenv = if (FALSE) 
[17:47:10.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:10.967]                     ...future.globalenv.names))
[17:47:10.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:10.967]         }, condition = base::local({
[17:47:10.967]             c <- base::c
[17:47:10.967]             inherits <- base::inherits
[17:47:10.967]             invokeRestart <- base::invokeRestart
[17:47:10.967]             length <- base::length
[17:47:10.967]             list <- base::list
[17:47:10.967]             seq.int <- base::seq.int
[17:47:10.967]             signalCondition <- base::signalCondition
[17:47:10.967]             sys.calls <- base::sys.calls
[17:47:10.967]             `[[` <- base::`[[`
[17:47:10.967]             `+` <- base::`+`
[17:47:10.967]             `<<-` <- base::`<<-`
[17:47:10.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:10.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:10.967]                   3L)]
[17:47:10.967]             }
[17:47:10.967]             function(cond) {
[17:47:10.967]                 is_error <- inherits(cond, "error")
[17:47:10.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:10.967]                   NULL)
[17:47:10.967]                 if (is_error) {
[17:47:10.967]                   sessionInformation <- function() {
[17:47:10.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:10.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:10.967]                       search = base::search(), system = base::Sys.info())
[17:47:10.967]                   }
[17:47:10.967]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:10.967]                     cond$call), session = sessionInformation(), 
[17:47:10.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:10.967]                   signalCondition(cond)
[17:47:10.967]                 }
[17:47:10.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:10.967]                 "immediateCondition"))) {
[17:47:10.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:10.967]                   ...future.conditions[[length(...future.conditions) + 
[17:47:10.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:10.967]                   if (TRUE && !signal) {
[17:47:10.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.967]                     {
[17:47:10.967]                       inherits <- base::inherits
[17:47:10.967]                       invokeRestart <- base::invokeRestart
[17:47:10.967]                       is.null <- base::is.null
[17:47:10.967]                       muffled <- FALSE
[17:47:10.967]                       if (inherits(cond, "message")) {
[17:47:10.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.967]                         if (muffled) 
[17:47:10.967]                           invokeRestart("muffleMessage")
[17:47:10.967]                       }
[17:47:10.967]                       else if (inherits(cond, "warning")) {
[17:47:10.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.967]                         if (muffled) 
[17:47:10.967]                           invokeRestart("muffleWarning")
[17:47:10.967]                       }
[17:47:10.967]                       else if (inherits(cond, "condition")) {
[17:47:10.967]                         if (!is.null(pattern)) {
[17:47:10.967]                           computeRestarts <- base::computeRestarts
[17:47:10.967]                           grepl <- base::grepl
[17:47:10.967]                           restarts <- computeRestarts(cond)
[17:47:10.967]                           for (restart in restarts) {
[17:47:10.967]                             name <- restart$name
[17:47:10.967]                             if (is.null(name)) 
[17:47:10.967]                               next
[17:47:10.967]                             if (!grepl(pattern, name)) 
[17:47:10.967]                               next
[17:47:10.967]                             invokeRestart(restart)
[17:47:10.967]                             muffled <- TRUE
[17:47:10.967]                             break
[17:47:10.967]                           }
[17:47:10.967]                         }
[17:47:10.967]                       }
[17:47:10.967]                       invisible(muffled)
[17:47:10.967]                     }
[17:47:10.967]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.967]                   }
[17:47:10.967]                 }
[17:47:10.967]                 else {
[17:47:10.967]                   if (TRUE) {
[17:47:10.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:10.967]                     {
[17:47:10.967]                       inherits <- base::inherits
[17:47:10.967]                       invokeRestart <- base::invokeRestart
[17:47:10.967]                       is.null <- base::is.null
[17:47:10.967]                       muffled <- FALSE
[17:47:10.967]                       if (inherits(cond, "message")) {
[17:47:10.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:10.967]                         if (muffled) 
[17:47:10.967]                           invokeRestart("muffleMessage")
[17:47:10.967]                       }
[17:47:10.967]                       else if (inherits(cond, "warning")) {
[17:47:10.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:10.967]                         if (muffled) 
[17:47:10.967]                           invokeRestart("muffleWarning")
[17:47:10.967]                       }
[17:47:10.967]                       else if (inherits(cond, "condition")) {
[17:47:10.967]                         if (!is.null(pattern)) {
[17:47:10.967]                           computeRestarts <- base::computeRestarts
[17:47:10.967]                           grepl <- base::grepl
[17:47:10.967]                           restarts <- computeRestarts(cond)
[17:47:10.967]                           for (restart in restarts) {
[17:47:10.967]                             name <- restart$name
[17:47:10.967]                             if (is.null(name)) 
[17:47:10.967]                               next
[17:47:10.967]                             if (!grepl(pattern, name)) 
[17:47:10.967]                               next
[17:47:10.967]                             invokeRestart(restart)
[17:47:10.967]                             muffled <- TRUE
[17:47:10.967]                             break
[17:47:10.967]                           }
[17:47:10.967]                         }
[17:47:10.967]                       }
[17:47:10.967]                       invisible(muffled)
[17:47:10.967]                     }
[17:47:10.967]                     muffleCondition(cond, pattern = "^muffle")
[17:47:10.967]                   }
[17:47:10.967]                 }
[17:47:10.967]             }
[17:47:10.967]         }))
[17:47:10.967]     }, error = function(ex) {
[17:47:10.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:10.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:10.967]                 ...future.rng), started = ...future.startTime, 
[17:47:10.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:10.967]             version = "1.8"), class = "FutureResult")
[17:47:10.967]     }, finally = {
[17:47:10.967]         if (!identical(...future.workdir, getwd())) 
[17:47:10.967]             setwd(...future.workdir)
[17:47:10.967]         {
[17:47:10.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:10.967]                 ...future.oldOptions$nwarnings <- NULL
[17:47:10.967]             }
[17:47:10.967]             base::options(...future.oldOptions)
[17:47:10.967]             if (.Platform$OS.type == "windows") {
[17:47:10.967]                 old_names <- names(...future.oldEnvVars)
[17:47:10.967]                 envs <- base::Sys.getenv()
[17:47:10.967]                 names <- names(envs)
[17:47:10.967]                 common <- intersect(names, old_names)
[17:47:10.967]                 added <- setdiff(names, old_names)
[17:47:10.967]                 removed <- setdiff(old_names, names)
[17:47:10.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:10.967]                   envs[common]]
[17:47:10.967]                 NAMES <- toupper(changed)
[17:47:10.967]                 args <- list()
[17:47:10.967]                 for (kk in seq_along(NAMES)) {
[17:47:10.967]                   name <- changed[[kk]]
[17:47:10.967]                   NAME <- NAMES[[kk]]
[17:47:10.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.967]                     next
[17:47:10.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.967]                 }
[17:47:10.967]                 NAMES <- toupper(added)
[17:47:10.967]                 for (kk in seq_along(NAMES)) {
[17:47:10.967]                   name <- added[[kk]]
[17:47:10.967]                   NAME <- NAMES[[kk]]
[17:47:10.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.967]                     next
[17:47:10.967]                   args[[name]] <- ""
[17:47:10.967]                 }
[17:47:10.967]                 NAMES <- toupper(removed)
[17:47:10.967]                 for (kk in seq_along(NAMES)) {
[17:47:10.967]                   name <- removed[[kk]]
[17:47:10.967]                   NAME <- NAMES[[kk]]
[17:47:10.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:10.967]                     next
[17:47:10.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:10.967]                 }
[17:47:10.967]                 if (length(args) > 0) 
[17:47:10.967]                   base::do.call(base::Sys.setenv, args = args)
[17:47:10.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:10.967]             }
[17:47:10.967]             else {
[17:47:10.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:10.967]             }
[17:47:10.967]             {
[17:47:10.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:10.967]                   0L) {
[17:47:10.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:10.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:10.967]                   base::options(opts)
[17:47:10.967]                 }
[17:47:10.967]                 {
[17:47:10.967]                   {
[17:47:10.967]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:10.967]                     NULL
[17:47:10.967]                   }
[17:47:10.967]                   options(future.plan = NULL)
[17:47:10.967]                   if (is.na(NA_character_)) 
[17:47:10.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:10.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:10.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:10.967]                     .init = FALSE)
[17:47:10.967]                 }
[17:47:10.967]             }
[17:47:10.967]         }
[17:47:10.967]     })
[17:47:10.967]     if (TRUE) {
[17:47:10.967]         base::sink(type = "output", split = FALSE)
[17:47:10.967]         if (TRUE) {
[17:47:10.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:10.967]         }
[17:47:10.967]         else {
[17:47:10.967]             ...future.result["stdout"] <- base::list(NULL)
[17:47:10.967]         }
[17:47:10.967]         base::close(...future.stdout)
[17:47:10.967]         ...future.stdout <- NULL
[17:47:10.967]     }
[17:47:10.967]     ...future.result$conditions <- ...future.conditions
[17:47:10.967]     ...future.result$finished <- base::Sys.time()
[17:47:10.967]     ...future.result
[17:47:10.967] }
[17:47:10.970] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:47:10.972] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:47:11.024] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:47:11.024] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:47:11.024] MultisessionFuture started
[17:47:11.025] - Launch lazy future ... done
[17:47:11.025] run() for ‘MultisessionFuture’ ... done
[17:47:11.025] result() for ClusterFuture ...
[17:47:11.025] receiveMessageFromWorker() for ClusterFuture ...
[17:47:11.025] - Validating connection of MultisessionFuture
[17:47:11.070] - received message: FutureResult
[17:47:11.070] - Received FutureResult
[17:47:11.070] - Erased future from FutureRegistry
[17:47:11.070] result() for ClusterFuture ...
[17:47:11.070] - result already collected: FutureResult
[17:47:11.070] result() for ClusterFuture ... done
[17:47:11.070] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:11.070] result() for ClusterFuture ... done
[17:47:11.071] result() for ClusterFuture ...
[17:47:11.071] - result already collected: FutureResult
[17:47:11.071] result() for ClusterFuture ... done
value(b) = 2
[17:47:11.071] result() for ClusterFuture ...
[17:47:11.071] - result already collected: FutureResult
[17:47:11.071] result() for ClusterFuture ... done
[17:47:11.071] result() for ClusterFuture ...
[17:47:11.071] - result already collected: FutureResult
[17:47:11.071] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:11.072] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:11.072] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:11.073] - globals found: [2] ‘{’, ‘pkg’
[17:47:11.073] Searching for globals ... DONE
[17:47:11.073] Resolving globals: TRUE
[17:47:11.073] Resolving any globals that are futures ...
[17:47:11.073] - globals: [2] ‘{’, ‘pkg’
[17:47:11.073] Resolving any globals that are futures ... DONE
[17:47:11.074] Resolving futures part of globals (recursively) ...
[17:47:11.074] resolve() on list ...
[17:47:11.074]  recursive: 99
[17:47:11.074]  length: 1
[17:47:11.074]  elements: ‘pkg’
[17:47:11.074]  length: 0 (resolved future 1)
[17:47:11.074] resolve() on list ... DONE
[17:47:11.074] - globals: [1] ‘pkg’
[17:47:11.074] Resolving futures part of globals (recursively) ... DONE
[17:47:11.075] The total size of the 1 globals is 112 bytes (112 bytes)
[17:47:11.075] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:47:11.075] - globals: [1] ‘pkg’
[17:47:11.075] 
[17:47:11.075] getGlobalsAndPackages() ... DONE
[17:47:11.076] Packages needed by the future expression (n = 0): <none>
[17:47:11.076] Packages needed by future strategies (n = 0): <none>
[17:47:11.076] {
[17:47:11.076]     {
[17:47:11.076]         {
[17:47:11.076]             ...future.startTime <- base::Sys.time()
[17:47:11.076]             {
[17:47:11.076]                 {
[17:47:11.076]                   {
[17:47:11.076]                     base::local({
[17:47:11.076]                       has_future <- base::requireNamespace("future", 
[17:47:11.076]                         quietly = TRUE)
[17:47:11.076]                       if (has_future) {
[17:47:11.076]                         ns <- base::getNamespace("future")
[17:47:11.076]                         version <- ns[[".package"]][["version"]]
[17:47:11.076]                         if (is.null(version)) 
[17:47:11.076]                           version <- utils::packageVersion("future")
[17:47:11.076]                       }
[17:47:11.076]                       else {
[17:47:11.076]                         version <- NULL
[17:47:11.076]                       }
[17:47:11.076]                       if (!has_future || version < "1.8.0") {
[17:47:11.076]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:11.076]                           "", base::R.version$version.string), 
[17:47:11.076]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:11.076]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:11.076]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:11.076]                             "release", "version")], collapse = " "), 
[17:47:11.076]                           hostname = base::Sys.info()[["nodename"]])
[17:47:11.076]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:11.076]                           info)
[17:47:11.076]                         info <- base::paste(info, collapse = "; ")
[17:47:11.076]                         if (!has_future) {
[17:47:11.076]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:11.076]                             info)
[17:47:11.076]                         }
[17:47:11.076]                         else {
[17:47:11.076]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:11.076]                             info, version)
[17:47:11.076]                         }
[17:47:11.076]                         base::stop(msg)
[17:47:11.076]                       }
[17:47:11.076]                     })
[17:47:11.076]                   }
[17:47:11.076]                   ...future.strategy.old <- future::plan("list")
[17:47:11.076]                   options(future.plan = NULL)
[17:47:11.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:11.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:11.076]                 }
[17:47:11.076]                 ...future.workdir <- getwd()
[17:47:11.076]             }
[17:47:11.076]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:11.076]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:11.076]         }
[17:47:11.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:11.076]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:11.076]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:11.076]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:11.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:11.076]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:11.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:11.076]             base::names(...future.oldOptions))
[17:47:11.076]     }
[17:47:11.076]     if (FALSE) {
[17:47:11.076]     }
[17:47:11.076]     else {
[17:47:11.076]         if (TRUE) {
[17:47:11.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:11.076]                 open = "w")
[17:47:11.076]         }
[17:47:11.076]         else {
[17:47:11.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:11.076]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:11.076]         }
[17:47:11.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:11.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:11.076]             base::sink(type = "output", split = FALSE)
[17:47:11.076]             base::close(...future.stdout)
[17:47:11.076]         }, add = TRUE)
[17:47:11.076]     }
[17:47:11.076]     ...future.frame <- base::sys.nframe()
[17:47:11.076]     ...future.conditions <- base::list()
[17:47:11.076]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:11.076]     if (FALSE) {
[17:47:11.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:11.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:11.076]     }
[17:47:11.076]     ...future.result <- base::tryCatch({
[17:47:11.076]         base::withCallingHandlers({
[17:47:11.076]             ...future.value <- base::withVisible(base::local({
[17:47:11.076]                 pkg
[17:47:11.076]             }))
[17:47:11.076]             future::FutureResult(value = ...future.value$value, 
[17:47:11.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:11.076]                   ...future.rng), globalenv = if (FALSE) 
[17:47:11.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:11.076]                     ...future.globalenv.names))
[17:47:11.076]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:11.076]         }, condition = base::local({
[17:47:11.076]             c <- base::c
[17:47:11.076]             inherits <- base::inherits
[17:47:11.076]             invokeRestart <- base::invokeRestart
[17:47:11.076]             length <- base::length
[17:47:11.076]             list <- base::list
[17:47:11.076]             seq.int <- base::seq.int
[17:47:11.076]             signalCondition <- base::signalCondition
[17:47:11.076]             sys.calls <- base::sys.calls
[17:47:11.076]             `[[` <- base::`[[`
[17:47:11.076]             `+` <- base::`+`
[17:47:11.076]             `<<-` <- base::`<<-`
[17:47:11.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:11.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:11.076]                   3L)]
[17:47:11.076]             }
[17:47:11.076]             function(cond) {
[17:47:11.076]                 is_error <- inherits(cond, "error")
[17:47:11.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:11.076]                   NULL)
[17:47:11.076]                 if (is_error) {
[17:47:11.076]                   sessionInformation <- function() {
[17:47:11.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:11.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:11.076]                       search = base::search(), system = base::Sys.info())
[17:47:11.076]                   }
[17:47:11.076]                   ...future.conditions[[length(...future.conditions) + 
[17:47:11.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:11.076]                     cond$call), session = sessionInformation(), 
[17:47:11.076]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:11.076]                   signalCondition(cond)
[17:47:11.076]                 }
[17:47:11.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:11.076]                 "immediateCondition"))) {
[17:47:11.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:11.076]                   ...future.conditions[[length(...future.conditions) + 
[17:47:11.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:11.076]                   if (TRUE && !signal) {
[17:47:11.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.076]                     {
[17:47:11.076]                       inherits <- base::inherits
[17:47:11.076]                       invokeRestart <- base::invokeRestart
[17:47:11.076]                       is.null <- base::is.null
[17:47:11.076]                       muffled <- FALSE
[17:47:11.076]                       if (inherits(cond, "message")) {
[17:47:11.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:11.076]                         if (muffled) 
[17:47:11.076]                           invokeRestart("muffleMessage")
[17:47:11.076]                       }
[17:47:11.076]                       else if (inherits(cond, "warning")) {
[17:47:11.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:11.076]                         if (muffled) 
[17:47:11.076]                           invokeRestart("muffleWarning")
[17:47:11.076]                       }
[17:47:11.076]                       else if (inherits(cond, "condition")) {
[17:47:11.076]                         if (!is.null(pattern)) {
[17:47:11.076]                           computeRestarts <- base::computeRestarts
[17:47:11.076]                           grepl <- base::grepl
[17:47:11.076]                           restarts <- computeRestarts(cond)
[17:47:11.076]                           for (restart in restarts) {
[17:47:11.076]                             name <- restart$name
[17:47:11.076]                             if (is.null(name)) 
[17:47:11.076]                               next
[17:47:11.076]                             if (!grepl(pattern, name)) 
[17:47:11.076]                               next
[17:47:11.076]                             invokeRestart(restart)
[17:47:11.076]                             muffled <- TRUE
[17:47:11.076]                             break
[17:47:11.076]                           }
[17:47:11.076]                         }
[17:47:11.076]                       }
[17:47:11.076]                       invisible(muffled)
[17:47:11.076]                     }
[17:47:11.076]                     muffleCondition(cond, pattern = "^muffle")
[17:47:11.076]                   }
[17:47:11.076]                 }
[17:47:11.076]                 else {
[17:47:11.076]                   if (TRUE) {
[17:47:11.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.076]                     {
[17:47:11.076]                       inherits <- base::inherits
[17:47:11.076]                       invokeRestart <- base::invokeRestart
[17:47:11.076]                       is.null <- base::is.null
[17:47:11.076]                       muffled <- FALSE
[17:47:11.076]                       if (inherits(cond, "message")) {
[17:47:11.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:11.076]                         if (muffled) 
[17:47:11.076]                           invokeRestart("muffleMessage")
[17:47:11.076]                       }
[17:47:11.076]                       else if (inherits(cond, "warning")) {
[17:47:11.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:11.076]                         if (muffled) 
[17:47:11.076]                           invokeRestart("muffleWarning")
[17:47:11.076]                       }
[17:47:11.076]                       else if (inherits(cond, "condition")) {
[17:47:11.076]                         if (!is.null(pattern)) {
[17:47:11.076]                           computeRestarts <- base::computeRestarts
[17:47:11.076]                           grepl <- base::grepl
[17:47:11.076]                           restarts <- computeRestarts(cond)
[17:47:11.076]                           for (restart in restarts) {
[17:47:11.076]                             name <- restart$name
[17:47:11.076]                             if (is.null(name)) 
[17:47:11.076]                               next
[17:47:11.076]                             if (!grepl(pattern, name)) 
[17:47:11.076]                               next
[17:47:11.076]                             invokeRestart(restart)
[17:47:11.076]                             muffled <- TRUE
[17:47:11.076]                             break
[17:47:11.076]                           }
[17:47:11.076]                         }
[17:47:11.076]                       }
[17:47:11.076]                       invisible(muffled)
[17:47:11.076]                     }
[17:47:11.076]                     muffleCondition(cond, pattern = "^muffle")
[17:47:11.076]                   }
[17:47:11.076]                 }
[17:47:11.076]             }
[17:47:11.076]         }))
[17:47:11.076]     }, error = function(ex) {
[17:47:11.076]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:11.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:11.076]                 ...future.rng), started = ...future.startTime, 
[17:47:11.076]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:11.076]             version = "1.8"), class = "FutureResult")
[17:47:11.076]     }, finally = {
[17:47:11.076]         if (!identical(...future.workdir, getwd())) 
[17:47:11.076]             setwd(...future.workdir)
[17:47:11.076]         {
[17:47:11.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:11.076]                 ...future.oldOptions$nwarnings <- NULL
[17:47:11.076]             }
[17:47:11.076]             base::options(...future.oldOptions)
[17:47:11.076]             if (.Platform$OS.type == "windows") {
[17:47:11.076]                 old_names <- names(...future.oldEnvVars)
[17:47:11.076]                 envs <- base::Sys.getenv()
[17:47:11.076]                 names <- names(envs)
[17:47:11.076]                 common <- intersect(names, old_names)
[17:47:11.076]                 added <- setdiff(names, old_names)
[17:47:11.076]                 removed <- setdiff(old_names, names)
[17:47:11.076]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:11.076]                   envs[common]]
[17:47:11.076]                 NAMES <- toupper(changed)
[17:47:11.076]                 args <- list()
[17:47:11.076]                 for (kk in seq_along(NAMES)) {
[17:47:11.076]                   name <- changed[[kk]]
[17:47:11.076]                   NAME <- NAMES[[kk]]
[17:47:11.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.076]                     next
[17:47:11.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:11.076]                 }
[17:47:11.076]                 NAMES <- toupper(added)
[17:47:11.076]                 for (kk in seq_along(NAMES)) {
[17:47:11.076]                   name <- added[[kk]]
[17:47:11.076]                   NAME <- NAMES[[kk]]
[17:47:11.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.076]                     next
[17:47:11.076]                   args[[name]] <- ""
[17:47:11.076]                 }
[17:47:11.076]                 NAMES <- toupper(removed)
[17:47:11.076]                 for (kk in seq_along(NAMES)) {
[17:47:11.076]                   name <- removed[[kk]]
[17:47:11.076]                   NAME <- NAMES[[kk]]
[17:47:11.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.076]                     next
[17:47:11.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:11.076]                 }
[17:47:11.076]                 if (length(args) > 0) 
[17:47:11.076]                   base::do.call(base::Sys.setenv, args = args)
[17:47:11.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:11.076]             }
[17:47:11.076]             else {
[17:47:11.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:11.076]             }
[17:47:11.076]             {
[17:47:11.076]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:11.076]                   0L) {
[17:47:11.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:11.076]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:11.076]                   base::options(opts)
[17:47:11.076]                 }
[17:47:11.076]                 {
[17:47:11.076]                   {
[17:47:11.076]                     NULL
[17:47:11.076]                     RNGkind("Mersenne-Twister")
[17:47:11.076]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:11.076]                       inherits = FALSE)
[17:47:11.076]                   }
[17:47:11.076]                   options(future.plan = NULL)
[17:47:11.076]                   if (is.na(NA_character_)) 
[17:47:11.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:11.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:11.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:11.076]                     .init = FALSE)
[17:47:11.076]                 }
[17:47:11.076]             }
[17:47:11.076]         }
[17:47:11.076]     })
[17:47:11.076]     if (TRUE) {
[17:47:11.076]         base::sink(type = "output", split = FALSE)
[17:47:11.076]         if (TRUE) {
[17:47:11.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:11.076]         }
[17:47:11.076]         else {
[17:47:11.076]             ...future.result["stdout"] <- base::list(NULL)
[17:47:11.076]         }
[17:47:11.076]         base::close(...future.stdout)
[17:47:11.076]         ...future.stdout <- NULL
[17:47:11.076]     }
[17:47:11.076]     ...future.result$conditions <- ...future.conditions
[17:47:11.076]     ...future.result$finished <- base::Sys.time()
[17:47:11.076]     ...future.result
[17:47:11.076] }
[17:47:11.078] assign_globals() ...
[17:47:11.078] List of 1
[17:47:11.078]  $ pkg: chr "foo"
[17:47:11.078]  - attr(*, "where")=List of 1
[17:47:11.078]   ..$ pkg:<environment: R_EmptyEnv> 
[17:47:11.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:11.078]  - attr(*, "resolved")= logi TRUE
[17:47:11.078]  - attr(*, "total_size")= num 112
[17:47:11.080] - copied ‘pkg’ to environment
[17:47:11.080] assign_globals() ... done
[17:47:11.080] plan(): Setting new future strategy stack:
[17:47:11.080] List of future strategies:
[17:47:11.080] 1. sequential:
[17:47:11.080]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:11.080]    - tweaked: FALSE
[17:47:11.080]    - call: NULL
[17:47:11.081] plan(): nbrOfWorkers() = 1
[17:47:11.082] plan(): Setting new future strategy stack:
[17:47:11.082] List of future strategies:
[17:47:11.082] 1. multisession:
[17:47:11.082]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:11.082]    - tweaked: FALSE
[17:47:11.082]    - call: plan(strategy)
[17:47:11.085] plan(): nbrOfWorkers() = 2
[17:47:11.086] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:11.086] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:11.086] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:11.088] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:47:11.089] Searching for globals ... DONE
[17:47:11.089] Resolving globals: TRUE
[17:47:11.089] Resolving any globals that are futures ...
[17:47:11.089] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:47:11.089] Resolving any globals that are futures ... DONE
[17:47:11.089] 
[17:47:11.089] 
[17:47:11.089] getGlobalsAndPackages() ... DONE
[17:47:11.090] run() for ‘Future’ ...
[17:47:11.090] - state: ‘created’
[17:47:11.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:11.105] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:11.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:11.105]   - Field: ‘node’
[17:47:11.105]   - Field: ‘label’
[17:47:11.105]   - Field: ‘local’
[17:47:11.105]   - Field: ‘owner’
[17:47:11.105]   - Field: ‘envir’
[17:47:11.105]   - Field: ‘workers’
[17:47:11.106]   - Field: ‘packages’
[17:47:11.106]   - Field: ‘gc’
[17:47:11.106]   - Field: ‘conditions’
[17:47:11.106]   - Field: ‘persistent’
[17:47:11.106]   - Field: ‘expr’
[17:47:11.106]   - Field: ‘uuid’
[17:47:11.106]   - Field: ‘seed’
[17:47:11.106]   - Field: ‘version’
[17:47:11.106]   - Field: ‘result’
[17:47:11.106]   - Field: ‘asynchronous’
[17:47:11.106]   - Field: ‘calls’
[17:47:11.107]   - Field: ‘globals’
[17:47:11.107]   - Field: ‘stdout’
[17:47:11.107]   - Field: ‘earlySignal’
[17:47:11.107]   - Field: ‘lazy’
[17:47:11.107]   - Field: ‘state’
[17:47:11.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:11.107] - Launch lazy future ...
[17:47:11.107] Packages needed by the future expression (n = 0): <none>
[17:47:11.108] Packages needed by future strategies (n = 0): <none>
[17:47:11.108] {
[17:47:11.108]     {
[17:47:11.108]         {
[17:47:11.108]             ...future.startTime <- base::Sys.time()
[17:47:11.108]             {
[17:47:11.108]                 {
[17:47:11.108]                   {
[17:47:11.108]                     {
[17:47:11.108]                       base::local({
[17:47:11.108]                         has_future <- base::requireNamespace("future", 
[17:47:11.108]                           quietly = TRUE)
[17:47:11.108]                         if (has_future) {
[17:47:11.108]                           ns <- base::getNamespace("future")
[17:47:11.108]                           version <- ns[[".package"]][["version"]]
[17:47:11.108]                           if (is.null(version)) 
[17:47:11.108]                             version <- utils::packageVersion("future")
[17:47:11.108]                         }
[17:47:11.108]                         else {
[17:47:11.108]                           version <- NULL
[17:47:11.108]                         }
[17:47:11.108]                         if (!has_future || version < "1.8.0") {
[17:47:11.108]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:11.108]                             "", base::R.version$version.string), 
[17:47:11.108]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:11.108]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:11.108]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:11.108]                               "release", "version")], collapse = " "), 
[17:47:11.108]                             hostname = base::Sys.info()[["nodename"]])
[17:47:11.108]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:11.108]                             info)
[17:47:11.108]                           info <- base::paste(info, collapse = "; ")
[17:47:11.108]                           if (!has_future) {
[17:47:11.108]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:11.108]                               info)
[17:47:11.108]                           }
[17:47:11.108]                           else {
[17:47:11.108]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:11.108]                               info, version)
[17:47:11.108]                           }
[17:47:11.108]                           base::stop(msg)
[17:47:11.108]                         }
[17:47:11.108]                       })
[17:47:11.108]                     }
[17:47:11.108]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:11.108]                     base::options(mc.cores = 1L)
[17:47:11.108]                   }
[17:47:11.108]                   ...future.strategy.old <- future::plan("list")
[17:47:11.108]                   options(future.plan = NULL)
[17:47:11.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:11.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:11.108]                 }
[17:47:11.108]                 ...future.workdir <- getwd()
[17:47:11.108]             }
[17:47:11.108]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:11.108]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:11.108]         }
[17:47:11.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:11.108]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:11.108]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:11.108]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:11.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:11.108]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:11.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:11.108]             base::names(...future.oldOptions))
[17:47:11.108]     }
[17:47:11.108]     if (FALSE) {
[17:47:11.108]     }
[17:47:11.108]     else {
[17:47:11.108]         if (TRUE) {
[17:47:11.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:11.108]                 open = "w")
[17:47:11.108]         }
[17:47:11.108]         else {
[17:47:11.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:11.108]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:11.108]         }
[17:47:11.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:11.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:11.108]             base::sink(type = "output", split = FALSE)
[17:47:11.108]             base::close(...future.stdout)
[17:47:11.108]         }, add = TRUE)
[17:47:11.108]     }
[17:47:11.108]     ...future.frame <- base::sys.nframe()
[17:47:11.108]     ...future.conditions <- base::list()
[17:47:11.108]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:11.108]     if (FALSE) {
[17:47:11.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:11.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:11.108]     }
[17:47:11.108]     ...future.result <- base::tryCatch({
[17:47:11.108]         base::withCallingHandlers({
[17:47:11.108]             ...future.value <- base::withVisible(base::local({
[17:47:11.108]                 ...future.makeSendCondition <- base::local({
[17:47:11.108]                   sendCondition <- NULL
[17:47:11.108]                   function(frame = 1L) {
[17:47:11.108]                     if (is.function(sendCondition)) 
[17:47:11.108]                       return(sendCondition)
[17:47:11.108]                     ns <- getNamespace("parallel")
[17:47:11.108]                     if (exists("sendData", mode = "function", 
[17:47:11.108]                       envir = ns)) {
[17:47:11.108]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:11.108]                         envir = ns)
[17:47:11.108]                       envir <- sys.frame(frame)
[17:47:11.108]                       master <- NULL
[17:47:11.108]                       while (!identical(envir, .GlobalEnv) && 
[17:47:11.108]                         !identical(envir, emptyenv())) {
[17:47:11.108]                         if (exists("master", mode = "list", envir = envir, 
[17:47:11.108]                           inherits = FALSE)) {
[17:47:11.108]                           master <- get("master", mode = "list", 
[17:47:11.108]                             envir = envir, inherits = FALSE)
[17:47:11.108]                           if (inherits(master, c("SOCKnode", 
[17:47:11.108]                             "SOCK0node"))) {
[17:47:11.108]                             sendCondition <<- function(cond) {
[17:47:11.108]                               data <- list(type = "VALUE", value = cond, 
[17:47:11.108]                                 success = TRUE)
[17:47:11.108]                               parallel_sendData(master, data)
[17:47:11.108]                             }
[17:47:11.108]                             return(sendCondition)
[17:47:11.108]                           }
[17:47:11.108]                         }
[17:47:11.108]                         frame <- frame + 1L
[17:47:11.108]                         envir <- sys.frame(frame)
[17:47:11.108]                       }
[17:47:11.108]                     }
[17:47:11.108]                     sendCondition <<- function(cond) NULL
[17:47:11.108]                   }
[17:47:11.108]                 })
[17:47:11.108]                 withCallingHandlers({
[17:47:11.108]                   {
[17:47:11.108]                     x <- 0
[17:47:11.108]                     x <- x + 1
[17:47:11.108]                     x
[17:47:11.108]                   }
[17:47:11.108]                 }, immediateCondition = function(cond) {
[17:47:11.108]                   sendCondition <- ...future.makeSendCondition()
[17:47:11.108]                   sendCondition(cond)
[17:47:11.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.108]                   {
[17:47:11.108]                     inherits <- base::inherits
[17:47:11.108]                     invokeRestart <- base::invokeRestart
[17:47:11.108]                     is.null <- base::is.null
[17:47:11.108]                     muffled <- FALSE
[17:47:11.108]                     if (inherits(cond, "message")) {
[17:47:11.108]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:11.108]                       if (muffled) 
[17:47:11.108]                         invokeRestart("muffleMessage")
[17:47:11.108]                     }
[17:47:11.108]                     else if (inherits(cond, "warning")) {
[17:47:11.108]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:11.108]                       if (muffled) 
[17:47:11.108]                         invokeRestart("muffleWarning")
[17:47:11.108]                     }
[17:47:11.108]                     else if (inherits(cond, "condition")) {
[17:47:11.108]                       if (!is.null(pattern)) {
[17:47:11.108]                         computeRestarts <- base::computeRestarts
[17:47:11.108]                         grepl <- base::grepl
[17:47:11.108]                         restarts <- computeRestarts(cond)
[17:47:11.108]                         for (restart in restarts) {
[17:47:11.108]                           name <- restart$name
[17:47:11.108]                           if (is.null(name)) 
[17:47:11.108]                             next
[17:47:11.108]                           if (!grepl(pattern, name)) 
[17:47:11.108]                             next
[17:47:11.108]                           invokeRestart(restart)
[17:47:11.108]                           muffled <- TRUE
[17:47:11.108]                           break
[17:47:11.108]                         }
[17:47:11.108]                       }
[17:47:11.108]                     }
[17:47:11.108]                     invisible(muffled)
[17:47:11.108]                   }
[17:47:11.108]                   muffleCondition(cond)
[17:47:11.108]                 })
[17:47:11.108]             }))
[17:47:11.108]             future::FutureResult(value = ...future.value$value, 
[17:47:11.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:11.108]                   ...future.rng), globalenv = if (FALSE) 
[17:47:11.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:11.108]                     ...future.globalenv.names))
[17:47:11.108]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:11.108]         }, condition = base::local({
[17:47:11.108]             c <- base::c
[17:47:11.108]             inherits <- base::inherits
[17:47:11.108]             invokeRestart <- base::invokeRestart
[17:47:11.108]             length <- base::length
[17:47:11.108]             list <- base::list
[17:47:11.108]             seq.int <- base::seq.int
[17:47:11.108]             signalCondition <- base::signalCondition
[17:47:11.108]             sys.calls <- base::sys.calls
[17:47:11.108]             `[[` <- base::`[[`
[17:47:11.108]             `+` <- base::`+`
[17:47:11.108]             `<<-` <- base::`<<-`
[17:47:11.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:11.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:11.108]                   3L)]
[17:47:11.108]             }
[17:47:11.108]             function(cond) {
[17:47:11.108]                 is_error <- inherits(cond, "error")
[17:47:11.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:11.108]                   NULL)
[17:47:11.108]                 if (is_error) {
[17:47:11.108]                   sessionInformation <- function() {
[17:47:11.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:11.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:11.108]                       search = base::search(), system = base::Sys.info())
[17:47:11.108]                   }
[17:47:11.108]                   ...future.conditions[[length(...future.conditions) + 
[17:47:11.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:11.108]                     cond$call), session = sessionInformation(), 
[17:47:11.108]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:11.108]                   signalCondition(cond)
[17:47:11.108]                 }
[17:47:11.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:11.108]                 "immediateCondition"))) {
[17:47:11.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:11.108]                   ...future.conditions[[length(...future.conditions) + 
[17:47:11.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:11.108]                   if (TRUE && !signal) {
[17:47:11.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.108]                     {
[17:47:11.108]                       inherits <- base::inherits
[17:47:11.108]                       invokeRestart <- base::invokeRestart
[17:47:11.108]                       is.null <- base::is.null
[17:47:11.108]                       muffled <- FALSE
[17:47:11.108]                       if (inherits(cond, "message")) {
[17:47:11.108]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:11.108]                         if (muffled) 
[17:47:11.108]                           invokeRestart("muffleMessage")
[17:47:11.108]                       }
[17:47:11.108]                       else if (inherits(cond, "warning")) {
[17:47:11.108]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:11.108]                         if (muffled) 
[17:47:11.108]                           invokeRestart("muffleWarning")
[17:47:11.108]                       }
[17:47:11.108]                       else if (inherits(cond, "condition")) {
[17:47:11.108]                         if (!is.null(pattern)) {
[17:47:11.108]                           computeRestarts <- base::computeRestarts
[17:47:11.108]                           grepl <- base::grepl
[17:47:11.108]                           restarts <- computeRestarts(cond)
[17:47:11.108]                           for (restart in restarts) {
[17:47:11.108]                             name <- restart$name
[17:47:11.108]                             if (is.null(name)) 
[17:47:11.108]                               next
[17:47:11.108]                             if (!grepl(pattern, name)) 
[17:47:11.108]                               next
[17:47:11.108]                             invokeRestart(restart)
[17:47:11.108]                             muffled <- TRUE
[17:47:11.108]                             break
[17:47:11.108]                           }
[17:47:11.108]                         }
[17:47:11.108]                       }
[17:47:11.108]                       invisible(muffled)
[17:47:11.108]                     }
[17:47:11.108]                     muffleCondition(cond, pattern = "^muffle")
[17:47:11.108]                   }
[17:47:11.108]                 }
[17:47:11.108]                 else {
[17:47:11.108]                   if (TRUE) {
[17:47:11.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.108]                     {
[17:47:11.108]                       inherits <- base::inherits
[17:47:11.108]                       invokeRestart <- base::invokeRestart
[17:47:11.108]                       is.null <- base::is.null
[17:47:11.108]                       muffled <- FALSE
[17:47:11.108]                       if (inherits(cond, "message")) {
[17:47:11.108]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:11.108]                         if (muffled) 
[17:47:11.108]                           invokeRestart("muffleMessage")
[17:47:11.108]                       }
[17:47:11.108]                       else if (inherits(cond, "warning")) {
[17:47:11.108]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:11.108]                         if (muffled) 
[17:47:11.108]                           invokeRestart("muffleWarning")
[17:47:11.108]                       }
[17:47:11.108]                       else if (inherits(cond, "condition")) {
[17:47:11.108]                         if (!is.null(pattern)) {
[17:47:11.108]                           computeRestarts <- base::computeRestarts
[17:47:11.108]                           grepl <- base::grepl
[17:47:11.108]                           restarts <- computeRestarts(cond)
[17:47:11.108]                           for (restart in restarts) {
[17:47:11.108]                             name <- restart$name
[17:47:11.108]                             if (is.null(name)) 
[17:47:11.108]                               next
[17:47:11.108]                             if (!grepl(pattern, name)) 
[17:47:11.108]                               next
[17:47:11.108]                             invokeRestart(restart)
[17:47:11.108]                             muffled <- TRUE
[17:47:11.108]                             break
[17:47:11.108]                           }
[17:47:11.108]                         }
[17:47:11.108]                       }
[17:47:11.108]                       invisible(muffled)
[17:47:11.108]                     }
[17:47:11.108]                     muffleCondition(cond, pattern = "^muffle")
[17:47:11.108]                   }
[17:47:11.108]                 }
[17:47:11.108]             }
[17:47:11.108]         }))
[17:47:11.108]     }, error = function(ex) {
[17:47:11.108]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:11.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:11.108]                 ...future.rng), started = ...future.startTime, 
[17:47:11.108]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:11.108]             version = "1.8"), class = "FutureResult")
[17:47:11.108]     }, finally = {
[17:47:11.108]         if (!identical(...future.workdir, getwd())) 
[17:47:11.108]             setwd(...future.workdir)
[17:47:11.108]         {
[17:47:11.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:11.108]                 ...future.oldOptions$nwarnings <- NULL
[17:47:11.108]             }
[17:47:11.108]             base::options(...future.oldOptions)
[17:47:11.108]             if (.Platform$OS.type == "windows") {
[17:47:11.108]                 old_names <- names(...future.oldEnvVars)
[17:47:11.108]                 envs <- base::Sys.getenv()
[17:47:11.108]                 names <- names(envs)
[17:47:11.108]                 common <- intersect(names, old_names)
[17:47:11.108]                 added <- setdiff(names, old_names)
[17:47:11.108]                 removed <- setdiff(old_names, names)
[17:47:11.108]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:11.108]                   envs[common]]
[17:47:11.108]                 NAMES <- toupper(changed)
[17:47:11.108]                 args <- list()
[17:47:11.108]                 for (kk in seq_along(NAMES)) {
[17:47:11.108]                   name <- changed[[kk]]
[17:47:11.108]                   NAME <- NAMES[[kk]]
[17:47:11.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.108]                     next
[17:47:11.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:11.108]                 }
[17:47:11.108]                 NAMES <- toupper(added)
[17:47:11.108]                 for (kk in seq_along(NAMES)) {
[17:47:11.108]                   name <- added[[kk]]
[17:47:11.108]                   NAME <- NAMES[[kk]]
[17:47:11.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.108]                     next
[17:47:11.108]                   args[[name]] <- ""
[17:47:11.108]                 }
[17:47:11.108]                 NAMES <- toupper(removed)
[17:47:11.108]                 for (kk in seq_along(NAMES)) {
[17:47:11.108]                   name <- removed[[kk]]
[17:47:11.108]                   NAME <- NAMES[[kk]]
[17:47:11.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.108]                     next
[17:47:11.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:11.108]                 }
[17:47:11.108]                 if (length(args) > 0) 
[17:47:11.108]                   base::do.call(base::Sys.setenv, args = args)
[17:47:11.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:11.108]             }
[17:47:11.108]             else {
[17:47:11.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:11.108]             }
[17:47:11.108]             {
[17:47:11.108]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:11.108]                   0L) {
[17:47:11.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:11.108]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:11.108]                   base::options(opts)
[17:47:11.108]                 }
[17:47:11.108]                 {
[17:47:11.108]                   {
[17:47:11.108]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:11.108]                     NULL
[17:47:11.108]                   }
[17:47:11.108]                   options(future.plan = NULL)
[17:47:11.108]                   if (is.na(NA_character_)) 
[17:47:11.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:11.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:11.108]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:11.108]                     .init = FALSE)
[17:47:11.108]                 }
[17:47:11.108]             }
[17:47:11.108]         }
[17:47:11.108]     })
[17:47:11.108]     if (TRUE) {
[17:47:11.108]         base::sink(type = "output", split = FALSE)
[17:47:11.108]         if (TRUE) {
[17:47:11.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:11.108]         }
[17:47:11.108]         else {
[17:47:11.108]             ...future.result["stdout"] <- base::list(NULL)
[17:47:11.108]         }
[17:47:11.108]         base::close(...future.stdout)
[17:47:11.108]         ...future.stdout <- NULL
[17:47:11.108]     }
[17:47:11.108]     ...future.result$conditions <- ...future.conditions
[17:47:11.108]     ...future.result$finished <- base::Sys.time()
[17:47:11.108]     ...future.result
[17:47:11.108] }
[17:47:11.111] MultisessionFuture started
[17:47:11.111] - Launch lazy future ... done
[17:47:11.111] run() for ‘MultisessionFuture’ ... done
[17:47:11.111] result() for ClusterFuture ...
[17:47:11.111] receiveMessageFromWorker() for ClusterFuture ...
[17:47:11.112] - Validating connection of MultisessionFuture
[17:47:11.153] - received message: FutureResult
[17:47:11.153] - Received FutureResult
[17:47:11.153] - Erased future from FutureRegistry
[17:47:11.154] result() for ClusterFuture ...
[17:47:11.154] - result already collected: FutureResult
[17:47:11.154] result() for ClusterFuture ... done
[17:47:11.154] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:11.154] result() for ClusterFuture ... done
[17:47:11.154] result() for ClusterFuture ...
[17:47:11.154] - result already collected: FutureResult
[17:47:11.154] result() for ClusterFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:11.155] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:11.155] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:11.156] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:47:11.156] Searching for globals ... DONE
[17:47:11.156] Resolving globals: TRUE
[17:47:11.157] Resolving any globals that are futures ...
[17:47:11.157] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:47:11.157] Resolving any globals that are futures ... DONE
[17:47:11.157] Resolving futures part of globals (recursively) ...
[17:47:11.157] resolve() on list ...
[17:47:11.157]  recursive: 99
[17:47:11.157]  length: 1
[17:47:11.158]  elements: ‘x’
[17:47:11.158]  length: 0 (resolved future 1)
[17:47:11.158] resolve() on list ... DONE
[17:47:11.158] - globals: [1] ‘x’
[17:47:11.158] Resolving futures part of globals (recursively) ... DONE
[17:47:11.158] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:11.158] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:47:11.159] - globals: [1] ‘x’
[17:47:11.159] 
[17:47:11.159] getGlobalsAndPackages() ... DONE
[17:47:11.159] run() for ‘Future’ ...
[17:47:11.159] - state: ‘created’
[17:47:11.159] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:11.173] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:11.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:11.173]   - Field: ‘node’
[17:47:11.173]   - Field: ‘label’
[17:47:11.173]   - Field: ‘local’
[17:47:11.173]   - Field: ‘owner’
[17:47:11.173]   - Field: ‘envir’
[17:47:11.174]   - Field: ‘workers’
[17:47:11.174]   - Field: ‘packages’
[17:47:11.174]   - Field: ‘gc’
[17:47:11.174]   - Field: ‘conditions’
[17:47:11.174]   - Field: ‘persistent’
[17:47:11.174]   - Field: ‘expr’
[17:47:11.174]   - Field: ‘uuid’
[17:47:11.174]   - Field: ‘seed’
[17:47:11.174]   - Field: ‘version’
[17:47:11.174]   - Field: ‘result’
[17:47:11.174]   - Field: ‘asynchronous’
[17:47:11.174]   - Field: ‘calls’
[17:47:11.175]   - Field: ‘globals’
[17:47:11.175]   - Field: ‘stdout’
[17:47:11.175]   - Field: ‘earlySignal’
[17:47:11.175]   - Field: ‘lazy’
[17:47:11.175]   - Field: ‘state’
[17:47:11.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:11.175] - Launch lazy future ...
[17:47:11.175] Packages needed by the future expression (n = 0): <none>
[17:47:11.176] Packages needed by future strategies (n = 0): <none>
[17:47:11.176] {
[17:47:11.176]     {
[17:47:11.176]         {
[17:47:11.176]             ...future.startTime <- base::Sys.time()
[17:47:11.176]             {
[17:47:11.176]                 {
[17:47:11.176]                   {
[17:47:11.176]                     {
[17:47:11.176]                       base::local({
[17:47:11.176]                         has_future <- base::requireNamespace("future", 
[17:47:11.176]                           quietly = TRUE)
[17:47:11.176]                         if (has_future) {
[17:47:11.176]                           ns <- base::getNamespace("future")
[17:47:11.176]                           version <- ns[[".package"]][["version"]]
[17:47:11.176]                           if (is.null(version)) 
[17:47:11.176]                             version <- utils::packageVersion("future")
[17:47:11.176]                         }
[17:47:11.176]                         else {
[17:47:11.176]                           version <- NULL
[17:47:11.176]                         }
[17:47:11.176]                         if (!has_future || version < "1.8.0") {
[17:47:11.176]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:11.176]                             "", base::R.version$version.string), 
[17:47:11.176]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:11.176]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:11.176]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:11.176]                               "release", "version")], collapse = " "), 
[17:47:11.176]                             hostname = base::Sys.info()[["nodename"]])
[17:47:11.176]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:11.176]                             info)
[17:47:11.176]                           info <- base::paste(info, collapse = "; ")
[17:47:11.176]                           if (!has_future) {
[17:47:11.176]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:11.176]                               info)
[17:47:11.176]                           }
[17:47:11.176]                           else {
[17:47:11.176]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:11.176]                               info, version)
[17:47:11.176]                           }
[17:47:11.176]                           base::stop(msg)
[17:47:11.176]                         }
[17:47:11.176]                       })
[17:47:11.176]                     }
[17:47:11.176]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:11.176]                     base::options(mc.cores = 1L)
[17:47:11.176]                   }
[17:47:11.176]                   ...future.strategy.old <- future::plan("list")
[17:47:11.176]                   options(future.plan = NULL)
[17:47:11.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:11.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:11.176]                 }
[17:47:11.176]                 ...future.workdir <- getwd()
[17:47:11.176]             }
[17:47:11.176]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:11.176]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:11.176]         }
[17:47:11.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:11.176]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:11.176]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:11.176]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:11.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:11.176]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:11.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:11.176]             base::names(...future.oldOptions))
[17:47:11.176]     }
[17:47:11.176]     if (FALSE) {
[17:47:11.176]     }
[17:47:11.176]     else {
[17:47:11.176]         if (TRUE) {
[17:47:11.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:11.176]                 open = "w")
[17:47:11.176]         }
[17:47:11.176]         else {
[17:47:11.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:11.176]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:11.176]         }
[17:47:11.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:11.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:11.176]             base::sink(type = "output", split = FALSE)
[17:47:11.176]             base::close(...future.stdout)
[17:47:11.176]         }, add = TRUE)
[17:47:11.176]     }
[17:47:11.176]     ...future.frame <- base::sys.nframe()
[17:47:11.176]     ...future.conditions <- base::list()
[17:47:11.176]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:11.176]     if (FALSE) {
[17:47:11.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:11.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:11.176]     }
[17:47:11.176]     ...future.result <- base::tryCatch({
[17:47:11.176]         base::withCallingHandlers({
[17:47:11.176]             ...future.value <- base::withVisible(base::local({
[17:47:11.176]                 ...future.makeSendCondition <- base::local({
[17:47:11.176]                   sendCondition <- NULL
[17:47:11.176]                   function(frame = 1L) {
[17:47:11.176]                     if (is.function(sendCondition)) 
[17:47:11.176]                       return(sendCondition)
[17:47:11.176]                     ns <- getNamespace("parallel")
[17:47:11.176]                     if (exists("sendData", mode = "function", 
[17:47:11.176]                       envir = ns)) {
[17:47:11.176]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:11.176]                         envir = ns)
[17:47:11.176]                       envir <- sys.frame(frame)
[17:47:11.176]                       master <- NULL
[17:47:11.176]                       while (!identical(envir, .GlobalEnv) && 
[17:47:11.176]                         !identical(envir, emptyenv())) {
[17:47:11.176]                         if (exists("master", mode = "list", envir = envir, 
[17:47:11.176]                           inherits = FALSE)) {
[17:47:11.176]                           master <- get("master", mode = "list", 
[17:47:11.176]                             envir = envir, inherits = FALSE)
[17:47:11.176]                           if (inherits(master, c("SOCKnode", 
[17:47:11.176]                             "SOCK0node"))) {
[17:47:11.176]                             sendCondition <<- function(cond) {
[17:47:11.176]                               data <- list(type = "VALUE", value = cond, 
[17:47:11.176]                                 success = TRUE)
[17:47:11.176]                               parallel_sendData(master, data)
[17:47:11.176]                             }
[17:47:11.176]                             return(sendCondition)
[17:47:11.176]                           }
[17:47:11.176]                         }
[17:47:11.176]                         frame <- frame + 1L
[17:47:11.176]                         envir <- sys.frame(frame)
[17:47:11.176]                       }
[17:47:11.176]                     }
[17:47:11.176]                     sendCondition <<- function(cond) NULL
[17:47:11.176]                   }
[17:47:11.176]                 })
[17:47:11.176]                 withCallingHandlers({
[17:47:11.176]                   {
[17:47:11.176]                     x <- x + 1
[17:47:11.176]                     x
[17:47:11.176]                   }
[17:47:11.176]                 }, immediateCondition = function(cond) {
[17:47:11.176]                   sendCondition <- ...future.makeSendCondition()
[17:47:11.176]                   sendCondition(cond)
[17:47:11.176]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.176]                   {
[17:47:11.176]                     inherits <- base::inherits
[17:47:11.176]                     invokeRestart <- base::invokeRestart
[17:47:11.176]                     is.null <- base::is.null
[17:47:11.176]                     muffled <- FALSE
[17:47:11.176]                     if (inherits(cond, "message")) {
[17:47:11.176]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:11.176]                       if (muffled) 
[17:47:11.176]                         invokeRestart("muffleMessage")
[17:47:11.176]                     }
[17:47:11.176]                     else if (inherits(cond, "warning")) {
[17:47:11.176]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:11.176]                       if (muffled) 
[17:47:11.176]                         invokeRestart("muffleWarning")
[17:47:11.176]                     }
[17:47:11.176]                     else if (inherits(cond, "condition")) {
[17:47:11.176]                       if (!is.null(pattern)) {
[17:47:11.176]                         computeRestarts <- base::computeRestarts
[17:47:11.176]                         grepl <- base::grepl
[17:47:11.176]                         restarts <- computeRestarts(cond)
[17:47:11.176]                         for (restart in restarts) {
[17:47:11.176]                           name <- restart$name
[17:47:11.176]                           if (is.null(name)) 
[17:47:11.176]                             next
[17:47:11.176]                           if (!grepl(pattern, name)) 
[17:47:11.176]                             next
[17:47:11.176]                           invokeRestart(restart)
[17:47:11.176]                           muffled <- TRUE
[17:47:11.176]                           break
[17:47:11.176]                         }
[17:47:11.176]                       }
[17:47:11.176]                     }
[17:47:11.176]                     invisible(muffled)
[17:47:11.176]                   }
[17:47:11.176]                   muffleCondition(cond)
[17:47:11.176]                 })
[17:47:11.176]             }))
[17:47:11.176]             future::FutureResult(value = ...future.value$value, 
[17:47:11.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:11.176]                   ...future.rng), globalenv = if (FALSE) 
[17:47:11.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:11.176]                     ...future.globalenv.names))
[17:47:11.176]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:11.176]         }, condition = base::local({
[17:47:11.176]             c <- base::c
[17:47:11.176]             inherits <- base::inherits
[17:47:11.176]             invokeRestart <- base::invokeRestart
[17:47:11.176]             length <- base::length
[17:47:11.176]             list <- base::list
[17:47:11.176]             seq.int <- base::seq.int
[17:47:11.176]             signalCondition <- base::signalCondition
[17:47:11.176]             sys.calls <- base::sys.calls
[17:47:11.176]             `[[` <- base::`[[`
[17:47:11.176]             `+` <- base::`+`
[17:47:11.176]             `<<-` <- base::`<<-`
[17:47:11.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:11.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:11.176]                   3L)]
[17:47:11.176]             }
[17:47:11.176]             function(cond) {
[17:47:11.176]                 is_error <- inherits(cond, "error")
[17:47:11.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:11.176]                   NULL)
[17:47:11.176]                 if (is_error) {
[17:47:11.176]                   sessionInformation <- function() {
[17:47:11.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:11.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:11.176]                       search = base::search(), system = base::Sys.info())
[17:47:11.176]                   }
[17:47:11.176]                   ...future.conditions[[length(...future.conditions) + 
[17:47:11.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:11.176]                     cond$call), session = sessionInformation(), 
[17:47:11.176]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:11.176]                   signalCondition(cond)
[17:47:11.176]                 }
[17:47:11.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:11.176]                 "immediateCondition"))) {
[17:47:11.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:11.176]                   ...future.conditions[[length(...future.conditions) + 
[17:47:11.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:11.176]                   if (TRUE && !signal) {
[17:47:11.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.176]                     {
[17:47:11.176]                       inherits <- base::inherits
[17:47:11.176]                       invokeRestart <- base::invokeRestart
[17:47:11.176]                       is.null <- base::is.null
[17:47:11.176]                       muffled <- FALSE
[17:47:11.176]                       if (inherits(cond, "message")) {
[17:47:11.176]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:11.176]                         if (muffled) 
[17:47:11.176]                           invokeRestart("muffleMessage")
[17:47:11.176]                       }
[17:47:11.176]                       else if (inherits(cond, "warning")) {
[17:47:11.176]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:11.176]                         if (muffled) 
[17:47:11.176]                           invokeRestart("muffleWarning")
[17:47:11.176]                       }
[17:47:11.176]                       else if (inherits(cond, "condition")) {
[17:47:11.176]                         if (!is.null(pattern)) {
[17:47:11.176]                           computeRestarts <- base::computeRestarts
[17:47:11.176]                           grepl <- base::grepl
[17:47:11.176]                           restarts <- computeRestarts(cond)
[17:47:11.176]                           for (restart in restarts) {
[17:47:11.176]                             name <- restart$name
[17:47:11.176]                             if (is.null(name)) 
[17:47:11.176]                               next
[17:47:11.176]                             if (!grepl(pattern, name)) 
[17:47:11.176]                               next
[17:47:11.176]                             invokeRestart(restart)
[17:47:11.176]                             muffled <- TRUE
[17:47:11.176]                             break
[17:47:11.176]                           }
[17:47:11.176]                         }
[17:47:11.176]                       }
[17:47:11.176]                       invisible(muffled)
[17:47:11.176]                     }
[17:47:11.176]                     muffleCondition(cond, pattern = "^muffle")
[17:47:11.176]                   }
[17:47:11.176]                 }
[17:47:11.176]                 else {
[17:47:11.176]                   if (TRUE) {
[17:47:11.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.176]                     {
[17:47:11.176]                       inherits <- base::inherits
[17:47:11.176]                       invokeRestart <- base::invokeRestart
[17:47:11.176]                       is.null <- base::is.null
[17:47:11.176]                       muffled <- FALSE
[17:47:11.176]                       if (inherits(cond, "message")) {
[17:47:11.176]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:11.176]                         if (muffled) 
[17:47:11.176]                           invokeRestart("muffleMessage")
[17:47:11.176]                       }
[17:47:11.176]                       else if (inherits(cond, "warning")) {
[17:47:11.176]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:11.176]                         if (muffled) 
[17:47:11.176]                           invokeRestart("muffleWarning")
[17:47:11.176]                       }
[17:47:11.176]                       else if (inherits(cond, "condition")) {
[17:47:11.176]                         if (!is.null(pattern)) {
[17:47:11.176]                           computeRestarts <- base::computeRestarts
[17:47:11.176]                           grepl <- base::grepl
[17:47:11.176]                           restarts <- computeRestarts(cond)
[17:47:11.176]                           for (restart in restarts) {
[17:47:11.176]                             name <- restart$name
[17:47:11.176]                             if (is.null(name)) 
[17:47:11.176]                               next
[17:47:11.176]                             if (!grepl(pattern, name)) 
[17:47:11.176]                               next
[17:47:11.176]                             invokeRestart(restart)
[17:47:11.176]                             muffled <- TRUE
[17:47:11.176]                             break
[17:47:11.176]                           }
[17:47:11.176]                         }
[17:47:11.176]                       }
[17:47:11.176]                       invisible(muffled)
[17:47:11.176]                     }
[17:47:11.176]                     muffleCondition(cond, pattern = "^muffle")
[17:47:11.176]                   }
[17:47:11.176]                 }
[17:47:11.176]             }
[17:47:11.176]         }))
[17:47:11.176]     }, error = function(ex) {
[17:47:11.176]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:11.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:11.176]                 ...future.rng), started = ...future.startTime, 
[17:47:11.176]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:11.176]             version = "1.8"), class = "FutureResult")
[17:47:11.176]     }, finally = {
[17:47:11.176]         if (!identical(...future.workdir, getwd())) 
[17:47:11.176]             setwd(...future.workdir)
[17:47:11.176]         {
[17:47:11.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:11.176]                 ...future.oldOptions$nwarnings <- NULL
[17:47:11.176]             }
[17:47:11.176]             base::options(...future.oldOptions)
[17:47:11.176]             if (.Platform$OS.type == "windows") {
[17:47:11.176]                 old_names <- names(...future.oldEnvVars)
[17:47:11.176]                 envs <- base::Sys.getenv()
[17:47:11.176]                 names <- names(envs)
[17:47:11.176]                 common <- intersect(names, old_names)
[17:47:11.176]                 added <- setdiff(names, old_names)
[17:47:11.176]                 removed <- setdiff(old_names, names)
[17:47:11.176]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:11.176]                   envs[common]]
[17:47:11.176]                 NAMES <- toupper(changed)
[17:47:11.176]                 args <- list()
[17:47:11.176]                 for (kk in seq_along(NAMES)) {
[17:47:11.176]                   name <- changed[[kk]]
[17:47:11.176]                   NAME <- NAMES[[kk]]
[17:47:11.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.176]                     next
[17:47:11.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:11.176]                 }
[17:47:11.176]                 NAMES <- toupper(added)
[17:47:11.176]                 for (kk in seq_along(NAMES)) {
[17:47:11.176]                   name <- added[[kk]]
[17:47:11.176]                   NAME <- NAMES[[kk]]
[17:47:11.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.176]                     next
[17:47:11.176]                   args[[name]] <- ""
[17:47:11.176]                 }
[17:47:11.176]                 NAMES <- toupper(removed)
[17:47:11.176]                 for (kk in seq_along(NAMES)) {
[17:47:11.176]                   name <- removed[[kk]]
[17:47:11.176]                   NAME <- NAMES[[kk]]
[17:47:11.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.176]                     next
[17:47:11.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:11.176]                 }
[17:47:11.176]                 if (length(args) > 0) 
[17:47:11.176]                   base::do.call(base::Sys.setenv, args = args)
[17:47:11.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:11.176]             }
[17:47:11.176]             else {
[17:47:11.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:11.176]             }
[17:47:11.176]             {
[17:47:11.176]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:11.176]                   0L) {
[17:47:11.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:11.176]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:11.176]                   base::options(opts)
[17:47:11.176]                 }
[17:47:11.176]                 {
[17:47:11.176]                   {
[17:47:11.176]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:11.176]                     NULL
[17:47:11.176]                   }
[17:47:11.176]                   options(future.plan = NULL)
[17:47:11.176]                   if (is.na(NA_character_)) 
[17:47:11.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:11.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:11.176]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:11.176]                     .init = FALSE)
[17:47:11.176]                 }
[17:47:11.176]             }
[17:47:11.176]         }
[17:47:11.176]     })
[17:47:11.176]     if (TRUE) {
[17:47:11.176]         base::sink(type = "output", split = FALSE)
[17:47:11.176]         if (TRUE) {
[17:47:11.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:11.176]         }
[17:47:11.176]         else {
[17:47:11.176]             ...future.result["stdout"] <- base::list(NULL)
[17:47:11.176]         }
[17:47:11.176]         base::close(...future.stdout)
[17:47:11.176]         ...future.stdout <- NULL
[17:47:11.176]     }
[17:47:11.176]     ...future.result$conditions <- ...future.conditions
[17:47:11.176]     ...future.result$finished <- base::Sys.time()
[17:47:11.176]     ...future.result
[17:47:11.176] }
[17:47:11.178] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:47:11.179] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:47:11.179] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:47:11.179] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:47:11.180] MultisessionFuture started
[17:47:11.180] - Launch lazy future ... done
[17:47:11.180] run() for ‘MultisessionFuture’ ... done
[17:47:11.180] result() for ClusterFuture ...
[17:47:11.180] receiveMessageFromWorker() for ClusterFuture ...
[17:47:11.180] - Validating connection of MultisessionFuture
[17:47:11.221] - received message: FutureResult
[17:47:11.221] - Received FutureResult
[17:47:11.221] - Erased future from FutureRegistry
[17:47:11.222] result() for ClusterFuture ...
[17:47:11.222] - result already collected: FutureResult
[17:47:11.222] result() for ClusterFuture ... done
[17:47:11.222] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:11.222] result() for ClusterFuture ... done
[17:47:11.222] result() for ClusterFuture ...
[17:47:11.222] - result already collected: FutureResult
[17:47:11.222] result() for ClusterFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:47:11.223] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:47:11.223] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:47:11.225] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:47:11.225] Searching for globals ... DONE
[17:47:11.225] Resolving globals: TRUE
[17:47:11.225] Resolving any globals that are futures ...
[17:47:11.225] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:47:11.225] Resolving any globals that are futures ... DONE
[17:47:11.225] Resolving futures part of globals (recursively) ...
[17:47:11.226] resolve() on list ...
[17:47:11.226]  recursive: 99
[17:47:11.226]  length: 1
[17:47:11.226]  elements: ‘x’
[17:47:11.226]  length: 0 (resolved future 1)
[17:47:11.226] resolve() on list ... DONE
[17:47:11.226] - globals: [1] ‘x’
[17:47:11.226] Resolving futures part of globals (recursively) ... DONE
[17:47:11.226] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:47:11.227] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:47:11.227] - globals: [1] ‘x’
[17:47:11.227] 
[17:47:11.227] getGlobalsAndPackages() ... DONE
[17:47:11.227] run() for ‘Future’ ...
[17:47:11.227] - state: ‘created’
[17:47:11.228] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:11.241] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:11.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:11.242]   - Field: ‘node’
[17:47:11.242]   - Field: ‘label’
[17:47:11.242]   - Field: ‘local’
[17:47:11.242]   - Field: ‘owner’
[17:47:11.242]   - Field: ‘envir’
[17:47:11.242]   - Field: ‘workers’
[17:47:11.242]   - Field: ‘packages’
[17:47:11.242]   - Field: ‘gc’
[17:47:11.242]   - Field: ‘conditions’
[17:47:11.242]   - Field: ‘persistent’
[17:47:11.242]   - Field: ‘expr’
[17:47:11.243]   - Field: ‘uuid’
[17:47:11.243]   - Field: ‘seed’
[17:47:11.243]   - Field: ‘version’
[17:47:11.243]   - Field: ‘result’
[17:47:11.243]   - Field: ‘asynchronous’
[17:47:11.243]   - Field: ‘calls’
[17:47:11.243]   - Field: ‘globals’
[17:47:11.243]   - Field: ‘stdout’
[17:47:11.243]   - Field: ‘earlySignal’
[17:47:11.243]   - Field: ‘lazy’
[17:47:11.243]   - Field: ‘state’
[17:47:11.244] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:11.244] - Launch lazy future ...
[17:47:11.244] Packages needed by the future expression (n = 0): <none>
[17:47:11.244] Packages needed by future strategies (n = 0): <none>
[17:47:11.244] {
[17:47:11.244]     {
[17:47:11.244]         {
[17:47:11.244]             ...future.startTime <- base::Sys.time()
[17:47:11.244]             {
[17:47:11.244]                 {
[17:47:11.244]                   {
[17:47:11.244]                     {
[17:47:11.244]                       base::local({
[17:47:11.244]                         has_future <- base::requireNamespace("future", 
[17:47:11.244]                           quietly = TRUE)
[17:47:11.244]                         if (has_future) {
[17:47:11.244]                           ns <- base::getNamespace("future")
[17:47:11.244]                           version <- ns[[".package"]][["version"]]
[17:47:11.244]                           if (is.null(version)) 
[17:47:11.244]                             version <- utils::packageVersion("future")
[17:47:11.244]                         }
[17:47:11.244]                         else {
[17:47:11.244]                           version <- NULL
[17:47:11.244]                         }
[17:47:11.244]                         if (!has_future || version < "1.8.0") {
[17:47:11.244]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:11.244]                             "", base::R.version$version.string), 
[17:47:11.244]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:11.244]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:11.244]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:11.244]                               "release", "version")], collapse = " "), 
[17:47:11.244]                             hostname = base::Sys.info()[["nodename"]])
[17:47:11.244]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:11.244]                             info)
[17:47:11.244]                           info <- base::paste(info, collapse = "; ")
[17:47:11.244]                           if (!has_future) {
[17:47:11.244]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:11.244]                               info)
[17:47:11.244]                           }
[17:47:11.244]                           else {
[17:47:11.244]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:11.244]                               info, version)
[17:47:11.244]                           }
[17:47:11.244]                           base::stop(msg)
[17:47:11.244]                         }
[17:47:11.244]                       })
[17:47:11.244]                     }
[17:47:11.244]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:11.244]                     base::options(mc.cores = 1L)
[17:47:11.244]                   }
[17:47:11.244]                   ...future.strategy.old <- future::plan("list")
[17:47:11.244]                   options(future.plan = NULL)
[17:47:11.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:11.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:11.244]                 }
[17:47:11.244]                 ...future.workdir <- getwd()
[17:47:11.244]             }
[17:47:11.244]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:11.244]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:11.244]         }
[17:47:11.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:47:11.244]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:47:11.244]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:47:11.244]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:47:11.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:11.244]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:11.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:11.244]             base::names(...future.oldOptions))
[17:47:11.244]     }
[17:47:11.244]     if (FALSE) {
[17:47:11.244]     }
[17:47:11.244]     else {
[17:47:11.244]         if (TRUE) {
[17:47:11.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:11.244]                 open = "w")
[17:47:11.244]         }
[17:47:11.244]         else {
[17:47:11.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:11.244]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:11.244]         }
[17:47:11.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:11.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:11.244]             base::sink(type = "output", split = FALSE)
[17:47:11.244]             base::close(...future.stdout)
[17:47:11.244]         }, add = TRUE)
[17:47:11.244]     }
[17:47:11.244]     ...future.frame <- base::sys.nframe()
[17:47:11.244]     ...future.conditions <- base::list()
[17:47:11.244]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:11.244]     if (FALSE) {
[17:47:11.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:11.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:11.244]     }
[17:47:11.244]     ...future.result <- base::tryCatch({
[17:47:11.244]         base::withCallingHandlers({
[17:47:11.244]             ...future.value <- base::withVisible(base::local({
[17:47:11.244]                 ...future.makeSendCondition <- base::local({
[17:47:11.244]                   sendCondition <- NULL
[17:47:11.244]                   function(frame = 1L) {
[17:47:11.244]                     if (is.function(sendCondition)) 
[17:47:11.244]                       return(sendCondition)
[17:47:11.244]                     ns <- getNamespace("parallel")
[17:47:11.244]                     if (exists("sendData", mode = "function", 
[17:47:11.244]                       envir = ns)) {
[17:47:11.244]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:11.244]                         envir = ns)
[17:47:11.244]                       envir <- sys.frame(frame)
[17:47:11.244]                       master <- NULL
[17:47:11.244]                       while (!identical(envir, .GlobalEnv) && 
[17:47:11.244]                         !identical(envir, emptyenv())) {
[17:47:11.244]                         if (exists("master", mode = "list", envir = envir, 
[17:47:11.244]                           inherits = FALSE)) {
[17:47:11.244]                           master <- get("master", mode = "list", 
[17:47:11.244]                             envir = envir, inherits = FALSE)
[17:47:11.244]                           if (inherits(master, c("SOCKnode", 
[17:47:11.244]                             "SOCK0node"))) {
[17:47:11.244]                             sendCondition <<- function(cond) {
[17:47:11.244]                               data <- list(type = "VALUE", value = cond, 
[17:47:11.244]                                 success = TRUE)
[17:47:11.244]                               parallel_sendData(master, data)
[17:47:11.244]                             }
[17:47:11.244]                             return(sendCondition)
[17:47:11.244]                           }
[17:47:11.244]                         }
[17:47:11.244]                         frame <- frame + 1L
[17:47:11.244]                         envir <- sys.frame(frame)
[17:47:11.244]                       }
[17:47:11.244]                     }
[17:47:11.244]                     sendCondition <<- function(cond) NULL
[17:47:11.244]                   }
[17:47:11.244]                 })
[17:47:11.244]                 withCallingHandlers({
[17:47:11.244]                   {
[17:47:11.244]                     x <- x()
[17:47:11.244]                     x
[17:47:11.244]                   }
[17:47:11.244]                 }, immediateCondition = function(cond) {
[17:47:11.244]                   sendCondition <- ...future.makeSendCondition()
[17:47:11.244]                   sendCondition(cond)
[17:47:11.244]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.244]                   {
[17:47:11.244]                     inherits <- base::inherits
[17:47:11.244]                     invokeRestart <- base::invokeRestart
[17:47:11.244]                     is.null <- base::is.null
[17:47:11.244]                     muffled <- FALSE
[17:47:11.244]                     if (inherits(cond, "message")) {
[17:47:11.244]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:11.244]                       if (muffled) 
[17:47:11.244]                         invokeRestart("muffleMessage")
[17:47:11.244]                     }
[17:47:11.244]                     else if (inherits(cond, "warning")) {
[17:47:11.244]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:11.244]                       if (muffled) 
[17:47:11.244]                         invokeRestart("muffleWarning")
[17:47:11.244]                     }
[17:47:11.244]                     else if (inherits(cond, "condition")) {
[17:47:11.244]                       if (!is.null(pattern)) {
[17:47:11.244]                         computeRestarts <- base::computeRestarts
[17:47:11.244]                         grepl <- base::grepl
[17:47:11.244]                         restarts <- computeRestarts(cond)
[17:47:11.244]                         for (restart in restarts) {
[17:47:11.244]                           name <- restart$name
[17:47:11.244]                           if (is.null(name)) 
[17:47:11.244]                             next
[17:47:11.244]                           if (!grepl(pattern, name)) 
[17:47:11.244]                             next
[17:47:11.244]                           invokeRestart(restart)
[17:47:11.244]                           muffled <- TRUE
[17:47:11.244]                           break
[17:47:11.244]                         }
[17:47:11.244]                       }
[17:47:11.244]                     }
[17:47:11.244]                     invisible(muffled)
[17:47:11.244]                   }
[17:47:11.244]                   muffleCondition(cond)
[17:47:11.244]                 })
[17:47:11.244]             }))
[17:47:11.244]             future::FutureResult(value = ...future.value$value, 
[17:47:11.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:11.244]                   ...future.rng), globalenv = if (FALSE) 
[17:47:11.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:11.244]                     ...future.globalenv.names))
[17:47:11.244]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:11.244]         }, condition = base::local({
[17:47:11.244]             c <- base::c
[17:47:11.244]             inherits <- base::inherits
[17:47:11.244]             invokeRestart <- base::invokeRestart
[17:47:11.244]             length <- base::length
[17:47:11.244]             list <- base::list
[17:47:11.244]             seq.int <- base::seq.int
[17:47:11.244]             signalCondition <- base::signalCondition
[17:47:11.244]             sys.calls <- base::sys.calls
[17:47:11.244]             `[[` <- base::`[[`
[17:47:11.244]             `+` <- base::`+`
[17:47:11.244]             `<<-` <- base::`<<-`
[17:47:11.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:11.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:11.244]                   3L)]
[17:47:11.244]             }
[17:47:11.244]             function(cond) {
[17:47:11.244]                 is_error <- inherits(cond, "error")
[17:47:11.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:11.244]                   NULL)
[17:47:11.244]                 if (is_error) {
[17:47:11.244]                   sessionInformation <- function() {
[17:47:11.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:11.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:11.244]                       search = base::search(), system = base::Sys.info())
[17:47:11.244]                   }
[17:47:11.244]                   ...future.conditions[[length(...future.conditions) + 
[17:47:11.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:11.244]                     cond$call), session = sessionInformation(), 
[17:47:11.244]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:11.244]                   signalCondition(cond)
[17:47:11.244]                 }
[17:47:11.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:11.244]                 "immediateCondition"))) {
[17:47:11.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:11.244]                   ...future.conditions[[length(...future.conditions) + 
[17:47:11.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:11.244]                   if (TRUE && !signal) {
[17:47:11.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.244]                     {
[17:47:11.244]                       inherits <- base::inherits
[17:47:11.244]                       invokeRestart <- base::invokeRestart
[17:47:11.244]                       is.null <- base::is.null
[17:47:11.244]                       muffled <- FALSE
[17:47:11.244]                       if (inherits(cond, "message")) {
[17:47:11.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:11.244]                         if (muffled) 
[17:47:11.244]                           invokeRestart("muffleMessage")
[17:47:11.244]                       }
[17:47:11.244]                       else if (inherits(cond, "warning")) {
[17:47:11.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:11.244]                         if (muffled) 
[17:47:11.244]                           invokeRestart("muffleWarning")
[17:47:11.244]                       }
[17:47:11.244]                       else if (inherits(cond, "condition")) {
[17:47:11.244]                         if (!is.null(pattern)) {
[17:47:11.244]                           computeRestarts <- base::computeRestarts
[17:47:11.244]                           grepl <- base::grepl
[17:47:11.244]                           restarts <- computeRestarts(cond)
[17:47:11.244]                           for (restart in restarts) {
[17:47:11.244]                             name <- restart$name
[17:47:11.244]                             if (is.null(name)) 
[17:47:11.244]                               next
[17:47:11.244]                             if (!grepl(pattern, name)) 
[17:47:11.244]                               next
[17:47:11.244]                             invokeRestart(restart)
[17:47:11.244]                             muffled <- TRUE
[17:47:11.244]                             break
[17:47:11.244]                           }
[17:47:11.244]                         }
[17:47:11.244]                       }
[17:47:11.244]                       invisible(muffled)
[17:47:11.244]                     }
[17:47:11.244]                     muffleCondition(cond, pattern = "^muffle")
[17:47:11.244]                   }
[17:47:11.244]                 }
[17:47:11.244]                 else {
[17:47:11.244]                   if (TRUE) {
[17:47:11.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:11.244]                     {
[17:47:11.244]                       inherits <- base::inherits
[17:47:11.244]                       invokeRestart <- base::invokeRestart
[17:47:11.244]                       is.null <- base::is.null
[17:47:11.244]                       muffled <- FALSE
[17:47:11.244]                       if (inherits(cond, "message")) {
[17:47:11.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:11.244]                         if (muffled) 
[17:47:11.244]                           invokeRestart("muffleMessage")
[17:47:11.244]                       }
[17:47:11.244]                       else if (inherits(cond, "warning")) {
[17:47:11.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:11.244]                         if (muffled) 
[17:47:11.244]                           invokeRestart("muffleWarning")
[17:47:11.244]                       }
[17:47:11.244]                       else if (inherits(cond, "condition")) {
[17:47:11.244]                         if (!is.null(pattern)) {
[17:47:11.244]                           computeRestarts <- base::computeRestarts
[17:47:11.244]                           grepl <- base::grepl
[17:47:11.244]                           restarts <- computeRestarts(cond)
[17:47:11.244]                           for (restart in restarts) {
[17:47:11.244]                             name <- restart$name
[17:47:11.244]                             if (is.null(name)) 
[17:47:11.244]                               next
[17:47:11.244]                             if (!grepl(pattern, name)) 
[17:47:11.244]                               next
[17:47:11.244]                             invokeRestart(restart)
[17:47:11.244]                             muffled <- TRUE
[17:47:11.244]                             break
[17:47:11.244]                           }
[17:47:11.244]                         }
[17:47:11.244]                       }
[17:47:11.244]                       invisible(muffled)
[17:47:11.244]                     }
[17:47:11.244]                     muffleCondition(cond, pattern = "^muffle")
[17:47:11.244]                   }
[17:47:11.244]                 }
[17:47:11.244]             }
[17:47:11.244]         }))
[17:47:11.244]     }, error = function(ex) {
[17:47:11.244]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:11.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:11.244]                 ...future.rng), started = ...future.startTime, 
[17:47:11.244]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:11.244]             version = "1.8"), class = "FutureResult")
[17:47:11.244]     }, finally = {
[17:47:11.244]         if (!identical(...future.workdir, getwd())) 
[17:47:11.244]             setwd(...future.workdir)
[17:47:11.244]         {
[17:47:11.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:11.244]                 ...future.oldOptions$nwarnings <- NULL
[17:47:11.244]             }
[17:47:11.244]             base::options(...future.oldOptions)
[17:47:11.244]             if (.Platform$OS.type == "windows") {
[17:47:11.244]                 old_names <- names(...future.oldEnvVars)
[17:47:11.244]                 envs <- base::Sys.getenv()
[17:47:11.244]                 names <- names(envs)
[17:47:11.244]                 common <- intersect(names, old_names)
[17:47:11.244]                 added <- setdiff(names, old_names)
[17:47:11.244]                 removed <- setdiff(old_names, names)
[17:47:11.244]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:11.244]                   envs[common]]
[17:47:11.244]                 NAMES <- toupper(changed)
[17:47:11.244]                 args <- list()
[17:47:11.244]                 for (kk in seq_along(NAMES)) {
[17:47:11.244]                   name <- changed[[kk]]
[17:47:11.244]                   NAME <- NAMES[[kk]]
[17:47:11.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.244]                     next
[17:47:11.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:11.244]                 }
[17:47:11.244]                 NAMES <- toupper(added)
[17:47:11.244]                 for (kk in seq_along(NAMES)) {
[17:47:11.244]                   name <- added[[kk]]
[17:47:11.244]                   NAME <- NAMES[[kk]]
[17:47:11.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.244]                     next
[17:47:11.244]                   args[[name]] <- ""
[17:47:11.244]                 }
[17:47:11.244]                 NAMES <- toupper(removed)
[17:47:11.244]                 for (kk in seq_along(NAMES)) {
[17:47:11.244]                   name <- removed[[kk]]
[17:47:11.244]                   NAME <- NAMES[[kk]]
[17:47:11.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:11.244]                     next
[17:47:11.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:11.244]                 }
[17:47:11.244]                 if (length(args) > 0) 
[17:47:11.244]                   base::do.call(base::Sys.setenv, args = args)
[17:47:11.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:11.244]             }
[17:47:11.244]             else {
[17:47:11.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:11.244]             }
[17:47:11.244]             {
[17:47:11.244]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:11.244]                   0L) {
[17:47:11.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:11.244]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:11.244]                   base::options(opts)
[17:47:11.244]                 }
[17:47:11.244]                 {
[17:47:11.244]                   {
[17:47:11.244]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:11.244]                     NULL
[17:47:11.244]                   }
[17:47:11.244]                   options(future.plan = NULL)
[17:47:11.244]                   if (is.na(NA_character_)) 
[17:47:11.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:11.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:11.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:11.244]                     .init = FALSE)
[17:47:11.244]                 }
[17:47:11.244]             }
[17:47:11.244]         }
[17:47:11.244]     })
[17:47:11.244]     if (TRUE) {
[17:47:11.244]         base::sink(type = "output", split = FALSE)
[17:47:11.244]         if (TRUE) {
[17:47:11.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:11.244]         }
[17:47:11.244]         else {
[17:47:11.244]             ...future.result["stdout"] <- base::list(NULL)
[17:47:11.244]         }
[17:47:11.244]         base::close(...future.stdout)
[17:47:11.244]         ...future.stdout <- NULL
[17:47:11.244]     }
[17:47:11.244]     ...future.result$conditions <- ...future.conditions
[17:47:11.244]     ...future.result$finished <- base::Sys.time()
[17:47:11.244]     ...future.result
[17:47:11.244] }
[17:47:11.247] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[17:47:11.247] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[17:47:11.248] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[17:47:11.248] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[17:47:11.248] MultisessionFuture started
[17:47:11.248] - Launch lazy future ... done
[17:47:11.248] run() for ‘MultisessionFuture’ ... done
[17:47:11.249] result() for ClusterFuture ...
[17:47:11.249] receiveMessageFromWorker() for ClusterFuture ...
[17:47:11.249] - Validating connection of MultisessionFuture
[17:47:11.293] - received message: FutureResult
[17:47:11.293] - Received FutureResult
[17:47:11.293] - Erased future from FutureRegistry
[17:47:11.294] result() for ClusterFuture ...
[17:47:11.294] - result already collected: FutureResult
[17:47:11.294] result() for ClusterFuture ... done
[17:47:11.294] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:11.294] result() for ClusterFuture ... done
[17:47:11.294] result() for ClusterFuture ...
[17:47:11.294] - result already collected: FutureResult
[17:47:11.294] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[17:47:11.295] plan(): Setting new future strategy stack:
[17:47:11.295] List of future strategies:
[17:47:11.295] 1. FutureStrategy:
[17:47:11.295]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:11.295]    - tweaked: FALSE
[17:47:11.295]    - call: future::plan(oplan)
[17:47:11.296] plan(): nbrOfWorkers() = 1
> 
