
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[18:04:13.863] plan(): Setting new future strategy stack:
[18:04:13.864] List of future strategies:
[18:04:13.864] 1. sequential:
[18:04:13.864]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:13.864]    - tweaked: FALSE
[18:04:13.864]    - call: future::plan("sequential")
[18:04:13.888] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[18:04:14.003] plan(): Setting new future strategy stack:
[18:04:14.003] List of future strategies:
[18:04:14.003] 1. sequential:
[18:04:14.003]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.003]    - tweaked: FALSE
[18:04:14.003]    - call: plan(strategy)
[18:04:14.026] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[18:04:14.028] getGlobalsAndPackages() ...
[18:04:14.028] Searching for globals...
[18:04:14.034] 
[18:04:14.034] Searching for globals ... DONE
[18:04:14.034] - globals: [0] <none>
[18:04:14.034] getGlobalsAndPackages() ... DONE
[18:04:14.036] run() for ‘Future’ ...
[18:04:14.036] - state: ‘created’
[18:04:14.036] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.037] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.037] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.037]   - Field: ‘label’
[18:04:14.037]   - Field: ‘local’
[18:04:14.038]   - Field: ‘owner’
[18:04:14.038]   - Field: ‘envir’
[18:04:14.038]   - Field: ‘packages’
[18:04:14.038]   - Field: ‘gc’
[18:04:14.038]   - Field: ‘conditions’
[18:04:14.039]   - Field: ‘expr’
[18:04:14.039]   - Field: ‘uuid’
[18:04:14.039]   - Field: ‘seed’
[18:04:14.039]   - Field: ‘version’
[18:04:14.039]   - Field: ‘result’
[18:04:14.040]   - Field: ‘asynchronous’
[18:04:14.040]   - Field: ‘calls’
[18:04:14.040]   - Field: ‘globals’
[18:04:14.040]   - Field: ‘stdout’
[18:04:14.040]   - Field: ‘earlySignal’
[18:04:14.041]   - Field: ‘lazy’
[18:04:14.041]   - Field: ‘state’
[18:04:14.041] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.041] - Launch lazy future ...
[18:04:14.043] Packages needed by the future expression (n = 0): <none>
[18:04:14.043] Packages needed by future strategies (n = 0): <none>
[18:04:14.044] {
[18:04:14.044]     {
[18:04:14.044]         {
[18:04:14.044]             ...future.startTime <- base::Sys.time()
[18:04:14.044]             {
[18:04:14.044]                 {
[18:04:14.044]                   {
[18:04:14.044]                     base::local({
[18:04:14.044]                       has_future <- base::requireNamespace("future", 
[18:04:14.044]                         quietly = TRUE)
[18:04:14.044]                       if (has_future) {
[18:04:14.044]                         ns <- base::getNamespace("future")
[18:04:14.044]                         version <- ns[[".package"]][["version"]]
[18:04:14.044]                         if (is.null(version)) 
[18:04:14.044]                           version <- utils::packageVersion("future")
[18:04:14.044]                       }
[18:04:14.044]                       else {
[18:04:14.044]                         version <- NULL
[18:04:14.044]                       }
[18:04:14.044]                       if (!has_future || version < "1.8.0") {
[18:04:14.044]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.044]                           "", base::R.version$version.string), 
[18:04:14.044]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.044]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.044]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.044]                             "release", "version")], collapse = " "), 
[18:04:14.044]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.044]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.044]                           info)
[18:04:14.044]                         info <- base::paste(info, collapse = "; ")
[18:04:14.044]                         if (!has_future) {
[18:04:14.044]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.044]                             info)
[18:04:14.044]                         }
[18:04:14.044]                         else {
[18:04:14.044]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.044]                             info, version)
[18:04:14.044]                         }
[18:04:14.044]                         base::stop(msg)
[18:04:14.044]                       }
[18:04:14.044]                     })
[18:04:14.044]                   }
[18:04:14.044]                   ...future.strategy.old <- future::plan("list")
[18:04:14.044]                   options(future.plan = NULL)
[18:04:14.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.044]                 }
[18:04:14.044]                 ...future.workdir <- getwd()
[18:04:14.044]             }
[18:04:14.044]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.044]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.044]         }
[18:04:14.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.044]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.044]             base::names(...future.oldOptions))
[18:04:14.044]     }
[18:04:14.044]     if (FALSE) {
[18:04:14.044]     }
[18:04:14.044]     else {
[18:04:14.044]         if (TRUE) {
[18:04:14.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.044]                 open = "w")
[18:04:14.044]         }
[18:04:14.044]         else {
[18:04:14.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.044]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.044]         }
[18:04:14.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.044]             base::sink(type = "output", split = FALSE)
[18:04:14.044]             base::close(...future.stdout)
[18:04:14.044]         }, add = TRUE)
[18:04:14.044]     }
[18:04:14.044]     ...future.frame <- base::sys.nframe()
[18:04:14.044]     ...future.conditions <- base::list()
[18:04:14.044]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.044]     if (FALSE) {
[18:04:14.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.044]     }
[18:04:14.044]     ...future.result <- base::tryCatch({
[18:04:14.044]         base::withCallingHandlers({
[18:04:14.044]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.044]             future::FutureResult(value = ...future.value$value, 
[18:04:14.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.044]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.044]                     ...future.globalenv.names))
[18:04:14.044]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.044]         }, condition = base::local({
[18:04:14.044]             c <- base::c
[18:04:14.044]             inherits <- base::inherits
[18:04:14.044]             invokeRestart <- base::invokeRestart
[18:04:14.044]             length <- base::length
[18:04:14.044]             list <- base::list
[18:04:14.044]             seq.int <- base::seq.int
[18:04:14.044]             signalCondition <- base::signalCondition
[18:04:14.044]             sys.calls <- base::sys.calls
[18:04:14.044]             `[[` <- base::`[[`
[18:04:14.044]             `+` <- base::`+`
[18:04:14.044]             `<<-` <- base::`<<-`
[18:04:14.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.044]                   3L)]
[18:04:14.044]             }
[18:04:14.044]             function(cond) {
[18:04:14.044]                 is_error <- inherits(cond, "error")
[18:04:14.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.044]                   NULL)
[18:04:14.044]                 if (is_error) {
[18:04:14.044]                   sessionInformation <- function() {
[18:04:14.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.044]                       search = base::search(), system = base::Sys.info())
[18:04:14.044]                   }
[18:04:14.044]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.044]                     cond$call), session = sessionInformation(), 
[18:04:14.044]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.044]                   signalCondition(cond)
[18:04:14.044]                 }
[18:04:14.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.044]                 "immediateCondition"))) {
[18:04:14.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.044]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.044]                   if (TRUE && !signal) {
[18:04:14.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.044]                     {
[18:04:14.044]                       inherits <- base::inherits
[18:04:14.044]                       invokeRestart <- base::invokeRestart
[18:04:14.044]                       is.null <- base::is.null
[18:04:14.044]                       muffled <- FALSE
[18:04:14.044]                       if (inherits(cond, "message")) {
[18:04:14.044]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.044]                         if (muffled) 
[18:04:14.044]                           invokeRestart("muffleMessage")
[18:04:14.044]                       }
[18:04:14.044]                       else if (inherits(cond, "warning")) {
[18:04:14.044]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.044]                         if (muffled) 
[18:04:14.044]                           invokeRestart("muffleWarning")
[18:04:14.044]                       }
[18:04:14.044]                       else if (inherits(cond, "condition")) {
[18:04:14.044]                         if (!is.null(pattern)) {
[18:04:14.044]                           computeRestarts <- base::computeRestarts
[18:04:14.044]                           grepl <- base::grepl
[18:04:14.044]                           restarts <- computeRestarts(cond)
[18:04:14.044]                           for (restart in restarts) {
[18:04:14.044]                             name <- restart$name
[18:04:14.044]                             if (is.null(name)) 
[18:04:14.044]                               next
[18:04:14.044]                             if (!grepl(pattern, name)) 
[18:04:14.044]                               next
[18:04:14.044]                             invokeRestart(restart)
[18:04:14.044]                             muffled <- TRUE
[18:04:14.044]                             break
[18:04:14.044]                           }
[18:04:14.044]                         }
[18:04:14.044]                       }
[18:04:14.044]                       invisible(muffled)
[18:04:14.044]                     }
[18:04:14.044]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.044]                   }
[18:04:14.044]                 }
[18:04:14.044]                 else {
[18:04:14.044]                   if (TRUE) {
[18:04:14.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.044]                     {
[18:04:14.044]                       inherits <- base::inherits
[18:04:14.044]                       invokeRestart <- base::invokeRestart
[18:04:14.044]                       is.null <- base::is.null
[18:04:14.044]                       muffled <- FALSE
[18:04:14.044]                       if (inherits(cond, "message")) {
[18:04:14.044]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.044]                         if (muffled) 
[18:04:14.044]                           invokeRestart("muffleMessage")
[18:04:14.044]                       }
[18:04:14.044]                       else if (inherits(cond, "warning")) {
[18:04:14.044]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.044]                         if (muffled) 
[18:04:14.044]                           invokeRestart("muffleWarning")
[18:04:14.044]                       }
[18:04:14.044]                       else if (inherits(cond, "condition")) {
[18:04:14.044]                         if (!is.null(pattern)) {
[18:04:14.044]                           computeRestarts <- base::computeRestarts
[18:04:14.044]                           grepl <- base::grepl
[18:04:14.044]                           restarts <- computeRestarts(cond)
[18:04:14.044]                           for (restart in restarts) {
[18:04:14.044]                             name <- restart$name
[18:04:14.044]                             if (is.null(name)) 
[18:04:14.044]                               next
[18:04:14.044]                             if (!grepl(pattern, name)) 
[18:04:14.044]                               next
[18:04:14.044]                             invokeRestart(restart)
[18:04:14.044]                             muffled <- TRUE
[18:04:14.044]                             break
[18:04:14.044]                           }
[18:04:14.044]                         }
[18:04:14.044]                       }
[18:04:14.044]                       invisible(muffled)
[18:04:14.044]                     }
[18:04:14.044]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.044]                   }
[18:04:14.044]                 }
[18:04:14.044]             }
[18:04:14.044]         }))
[18:04:14.044]     }, error = function(ex) {
[18:04:14.044]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.044]                 ...future.rng), started = ...future.startTime, 
[18:04:14.044]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.044]             version = "1.8"), class = "FutureResult")
[18:04:14.044]     }, finally = {
[18:04:14.044]         if (!identical(...future.workdir, getwd())) 
[18:04:14.044]             setwd(...future.workdir)
[18:04:14.044]         {
[18:04:14.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.044]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.044]             }
[18:04:14.044]             base::options(...future.oldOptions)
[18:04:14.044]             if (.Platform$OS.type == "windows") {
[18:04:14.044]                 old_names <- names(...future.oldEnvVars)
[18:04:14.044]                 envs <- base::Sys.getenv()
[18:04:14.044]                 names <- names(envs)
[18:04:14.044]                 common <- intersect(names, old_names)
[18:04:14.044]                 added <- setdiff(names, old_names)
[18:04:14.044]                 removed <- setdiff(old_names, names)
[18:04:14.044]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.044]                   envs[common]]
[18:04:14.044]                 NAMES <- toupper(changed)
[18:04:14.044]                 args <- list()
[18:04:14.044]                 for (kk in seq_along(NAMES)) {
[18:04:14.044]                   name <- changed[[kk]]
[18:04:14.044]                   NAME <- NAMES[[kk]]
[18:04:14.044]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.044]                     next
[18:04:14.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.044]                 }
[18:04:14.044]                 NAMES <- toupper(added)
[18:04:14.044]                 for (kk in seq_along(NAMES)) {
[18:04:14.044]                   name <- added[[kk]]
[18:04:14.044]                   NAME <- NAMES[[kk]]
[18:04:14.044]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.044]                     next
[18:04:14.044]                   args[[name]] <- ""
[18:04:14.044]                 }
[18:04:14.044]                 NAMES <- toupper(removed)
[18:04:14.044]                 for (kk in seq_along(NAMES)) {
[18:04:14.044]                   name <- removed[[kk]]
[18:04:14.044]                   NAME <- NAMES[[kk]]
[18:04:14.044]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.044]                     next
[18:04:14.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.044]                 }
[18:04:14.044]                 if (length(args) > 0) 
[18:04:14.044]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.044]             }
[18:04:14.044]             else {
[18:04:14.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.044]             }
[18:04:14.044]             {
[18:04:14.044]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.044]                   0L) {
[18:04:14.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.044]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.044]                   base::options(opts)
[18:04:14.044]                 }
[18:04:14.044]                 {
[18:04:14.044]                   {
[18:04:14.044]                     NULL
[18:04:14.044]                     RNGkind("Mersenne-Twister")
[18:04:14.044]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.044]                       inherits = FALSE)
[18:04:14.044]                   }
[18:04:14.044]                   options(future.plan = NULL)
[18:04:14.044]                   if (is.na(NA_character_)) 
[18:04:14.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.044]                     .init = FALSE)
[18:04:14.044]                 }
[18:04:14.044]             }
[18:04:14.044]         }
[18:04:14.044]     })
[18:04:14.044]     if (TRUE) {
[18:04:14.044]         base::sink(type = "output", split = FALSE)
[18:04:14.044]         if (TRUE) {
[18:04:14.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.044]         }
[18:04:14.044]         else {
[18:04:14.044]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.044]         }
[18:04:14.044]         base::close(...future.stdout)
[18:04:14.044]         ...future.stdout <- NULL
[18:04:14.044]     }
[18:04:14.044]     ...future.result$conditions <- ...future.conditions
[18:04:14.044]     ...future.result$finished <- base::Sys.time()
[18:04:14.044]     ...future.result
[18:04:14.044] }
[18:04:14.048] plan(): Setting new future strategy stack:
[18:04:14.048] List of future strategies:
[18:04:14.048] 1. sequential:
[18:04:14.048]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.048]    - tweaked: FALSE
[18:04:14.048]    - call: NULL
[18:04:14.049] plan(): nbrOfWorkers() = 1
[18:04:14.051] plan(): Setting new future strategy stack:
[18:04:14.051] List of future strategies:
[18:04:14.051] 1. sequential:
[18:04:14.051]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.051]    - tweaked: FALSE
[18:04:14.051]    - call: plan(strategy)
[18:04:14.052] plan(): nbrOfWorkers() = 1
[18:04:14.052] SequentialFuture started (and completed)
[18:04:14.053] - Launch lazy future ... done
[18:04:14.053] run() for ‘SequentialFuture’ ... done
[18:04:14.054] getGlobalsAndPackages() ...
[18:04:14.054] Searching for globals...
[18:04:14.055] 
[18:04:14.055] Searching for globals ... DONE
[18:04:14.055] - globals: [0] <none>
[18:04:14.055] getGlobalsAndPackages() ... DONE
[18:04:14.056] run() for ‘Future’ ...
[18:04:14.056] - state: ‘created’
[18:04:14.056] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.057] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.057] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.057]   - Field: ‘label’
[18:04:14.057]   - Field: ‘local’
[18:04:14.057]   - Field: ‘owner’
[18:04:14.058]   - Field: ‘envir’
[18:04:14.058]   - Field: ‘packages’
[18:04:14.058]   - Field: ‘gc’
[18:04:14.058]   - Field: ‘conditions’
[18:04:14.058]   - Field: ‘expr’
[18:04:14.059]   - Field: ‘uuid’
[18:04:14.059]   - Field: ‘seed’
[18:04:14.059]   - Field: ‘version’
[18:04:14.059]   - Field: ‘result’
[18:04:14.059]   - Field: ‘asynchronous’
[18:04:14.059]   - Field: ‘calls’
[18:04:14.060]   - Field: ‘globals’
[18:04:14.060]   - Field: ‘stdout’
[18:04:14.060]   - Field: ‘earlySignal’
[18:04:14.060]   - Field: ‘lazy’
[18:04:14.060]   - Field: ‘state’
[18:04:14.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.061] - Launch lazy future ...
[18:04:14.061] Packages needed by the future expression (n = 0): <none>
[18:04:14.061] Packages needed by future strategies (n = 0): <none>
[18:04:14.062] {
[18:04:14.062]     {
[18:04:14.062]         {
[18:04:14.062]             ...future.startTime <- base::Sys.time()
[18:04:14.062]             {
[18:04:14.062]                 {
[18:04:14.062]                   {
[18:04:14.062]                     base::local({
[18:04:14.062]                       has_future <- base::requireNamespace("future", 
[18:04:14.062]                         quietly = TRUE)
[18:04:14.062]                       if (has_future) {
[18:04:14.062]                         ns <- base::getNamespace("future")
[18:04:14.062]                         version <- ns[[".package"]][["version"]]
[18:04:14.062]                         if (is.null(version)) 
[18:04:14.062]                           version <- utils::packageVersion("future")
[18:04:14.062]                       }
[18:04:14.062]                       else {
[18:04:14.062]                         version <- NULL
[18:04:14.062]                       }
[18:04:14.062]                       if (!has_future || version < "1.8.0") {
[18:04:14.062]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.062]                           "", base::R.version$version.string), 
[18:04:14.062]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.062]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.062]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.062]                             "release", "version")], collapse = " "), 
[18:04:14.062]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.062]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.062]                           info)
[18:04:14.062]                         info <- base::paste(info, collapse = "; ")
[18:04:14.062]                         if (!has_future) {
[18:04:14.062]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.062]                             info)
[18:04:14.062]                         }
[18:04:14.062]                         else {
[18:04:14.062]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.062]                             info, version)
[18:04:14.062]                         }
[18:04:14.062]                         base::stop(msg)
[18:04:14.062]                       }
[18:04:14.062]                     })
[18:04:14.062]                   }
[18:04:14.062]                   ...future.strategy.old <- future::plan("list")
[18:04:14.062]                   options(future.plan = NULL)
[18:04:14.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.062]                 }
[18:04:14.062]                 ...future.workdir <- getwd()
[18:04:14.062]             }
[18:04:14.062]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.062]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.062]         }
[18:04:14.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.062]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.062]             base::names(...future.oldOptions))
[18:04:14.062]     }
[18:04:14.062]     if (FALSE) {
[18:04:14.062]     }
[18:04:14.062]     else {
[18:04:14.062]         if (TRUE) {
[18:04:14.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.062]                 open = "w")
[18:04:14.062]         }
[18:04:14.062]         else {
[18:04:14.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.062]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.062]         }
[18:04:14.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.062]             base::sink(type = "output", split = FALSE)
[18:04:14.062]             base::close(...future.stdout)
[18:04:14.062]         }, add = TRUE)
[18:04:14.062]     }
[18:04:14.062]     ...future.frame <- base::sys.nframe()
[18:04:14.062]     ...future.conditions <- base::list()
[18:04:14.062]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.062]     if (FALSE) {
[18:04:14.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.062]     }
[18:04:14.062]     ...future.result <- base::tryCatch({
[18:04:14.062]         base::withCallingHandlers({
[18:04:14.062]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.062]             future::FutureResult(value = ...future.value$value, 
[18:04:14.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.062]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.062]                     ...future.globalenv.names))
[18:04:14.062]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.062]         }, condition = base::local({
[18:04:14.062]             c <- base::c
[18:04:14.062]             inherits <- base::inherits
[18:04:14.062]             invokeRestart <- base::invokeRestart
[18:04:14.062]             length <- base::length
[18:04:14.062]             list <- base::list
[18:04:14.062]             seq.int <- base::seq.int
[18:04:14.062]             signalCondition <- base::signalCondition
[18:04:14.062]             sys.calls <- base::sys.calls
[18:04:14.062]             `[[` <- base::`[[`
[18:04:14.062]             `+` <- base::`+`
[18:04:14.062]             `<<-` <- base::`<<-`
[18:04:14.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.062]                   3L)]
[18:04:14.062]             }
[18:04:14.062]             function(cond) {
[18:04:14.062]                 is_error <- inherits(cond, "error")
[18:04:14.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.062]                   NULL)
[18:04:14.062]                 if (is_error) {
[18:04:14.062]                   sessionInformation <- function() {
[18:04:14.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.062]                       search = base::search(), system = base::Sys.info())
[18:04:14.062]                   }
[18:04:14.062]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.062]                     cond$call), session = sessionInformation(), 
[18:04:14.062]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.062]                   signalCondition(cond)
[18:04:14.062]                 }
[18:04:14.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.062]                 "immediateCondition"))) {
[18:04:14.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.062]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.062]                   if (TRUE && !signal) {
[18:04:14.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.062]                     {
[18:04:14.062]                       inherits <- base::inherits
[18:04:14.062]                       invokeRestart <- base::invokeRestart
[18:04:14.062]                       is.null <- base::is.null
[18:04:14.062]                       muffled <- FALSE
[18:04:14.062]                       if (inherits(cond, "message")) {
[18:04:14.062]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.062]                         if (muffled) 
[18:04:14.062]                           invokeRestart("muffleMessage")
[18:04:14.062]                       }
[18:04:14.062]                       else if (inherits(cond, "warning")) {
[18:04:14.062]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.062]                         if (muffled) 
[18:04:14.062]                           invokeRestart("muffleWarning")
[18:04:14.062]                       }
[18:04:14.062]                       else if (inherits(cond, "condition")) {
[18:04:14.062]                         if (!is.null(pattern)) {
[18:04:14.062]                           computeRestarts <- base::computeRestarts
[18:04:14.062]                           grepl <- base::grepl
[18:04:14.062]                           restarts <- computeRestarts(cond)
[18:04:14.062]                           for (restart in restarts) {
[18:04:14.062]                             name <- restart$name
[18:04:14.062]                             if (is.null(name)) 
[18:04:14.062]                               next
[18:04:14.062]                             if (!grepl(pattern, name)) 
[18:04:14.062]                               next
[18:04:14.062]                             invokeRestart(restart)
[18:04:14.062]                             muffled <- TRUE
[18:04:14.062]                             break
[18:04:14.062]                           }
[18:04:14.062]                         }
[18:04:14.062]                       }
[18:04:14.062]                       invisible(muffled)
[18:04:14.062]                     }
[18:04:14.062]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.062]                   }
[18:04:14.062]                 }
[18:04:14.062]                 else {
[18:04:14.062]                   if (TRUE) {
[18:04:14.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.062]                     {
[18:04:14.062]                       inherits <- base::inherits
[18:04:14.062]                       invokeRestart <- base::invokeRestart
[18:04:14.062]                       is.null <- base::is.null
[18:04:14.062]                       muffled <- FALSE
[18:04:14.062]                       if (inherits(cond, "message")) {
[18:04:14.062]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.062]                         if (muffled) 
[18:04:14.062]                           invokeRestart("muffleMessage")
[18:04:14.062]                       }
[18:04:14.062]                       else if (inherits(cond, "warning")) {
[18:04:14.062]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.062]                         if (muffled) 
[18:04:14.062]                           invokeRestart("muffleWarning")
[18:04:14.062]                       }
[18:04:14.062]                       else if (inherits(cond, "condition")) {
[18:04:14.062]                         if (!is.null(pattern)) {
[18:04:14.062]                           computeRestarts <- base::computeRestarts
[18:04:14.062]                           grepl <- base::grepl
[18:04:14.062]                           restarts <- computeRestarts(cond)
[18:04:14.062]                           for (restart in restarts) {
[18:04:14.062]                             name <- restart$name
[18:04:14.062]                             if (is.null(name)) 
[18:04:14.062]                               next
[18:04:14.062]                             if (!grepl(pattern, name)) 
[18:04:14.062]                               next
[18:04:14.062]                             invokeRestart(restart)
[18:04:14.062]                             muffled <- TRUE
[18:04:14.062]                             break
[18:04:14.062]                           }
[18:04:14.062]                         }
[18:04:14.062]                       }
[18:04:14.062]                       invisible(muffled)
[18:04:14.062]                     }
[18:04:14.062]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.062]                   }
[18:04:14.062]                 }
[18:04:14.062]             }
[18:04:14.062]         }))
[18:04:14.062]     }, error = function(ex) {
[18:04:14.062]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.062]                 ...future.rng), started = ...future.startTime, 
[18:04:14.062]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.062]             version = "1.8"), class = "FutureResult")
[18:04:14.062]     }, finally = {
[18:04:14.062]         if (!identical(...future.workdir, getwd())) 
[18:04:14.062]             setwd(...future.workdir)
[18:04:14.062]         {
[18:04:14.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.062]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.062]             }
[18:04:14.062]             base::options(...future.oldOptions)
[18:04:14.062]             if (.Platform$OS.type == "windows") {
[18:04:14.062]                 old_names <- names(...future.oldEnvVars)
[18:04:14.062]                 envs <- base::Sys.getenv()
[18:04:14.062]                 names <- names(envs)
[18:04:14.062]                 common <- intersect(names, old_names)
[18:04:14.062]                 added <- setdiff(names, old_names)
[18:04:14.062]                 removed <- setdiff(old_names, names)
[18:04:14.062]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.062]                   envs[common]]
[18:04:14.062]                 NAMES <- toupper(changed)
[18:04:14.062]                 args <- list()
[18:04:14.062]                 for (kk in seq_along(NAMES)) {
[18:04:14.062]                   name <- changed[[kk]]
[18:04:14.062]                   NAME <- NAMES[[kk]]
[18:04:14.062]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.062]                     next
[18:04:14.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.062]                 }
[18:04:14.062]                 NAMES <- toupper(added)
[18:04:14.062]                 for (kk in seq_along(NAMES)) {
[18:04:14.062]                   name <- added[[kk]]
[18:04:14.062]                   NAME <- NAMES[[kk]]
[18:04:14.062]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.062]                     next
[18:04:14.062]                   args[[name]] <- ""
[18:04:14.062]                 }
[18:04:14.062]                 NAMES <- toupper(removed)
[18:04:14.062]                 for (kk in seq_along(NAMES)) {
[18:04:14.062]                   name <- removed[[kk]]
[18:04:14.062]                   NAME <- NAMES[[kk]]
[18:04:14.062]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.062]                     next
[18:04:14.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.062]                 }
[18:04:14.062]                 if (length(args) > 0) 
[18:04:14.062]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.062]             }
[18:04:14.062]             else {
[18:04:14.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.062]             }
[18:04:14.062]             {
[18:04:14.062]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.062]                   0L) {
[18:04:14.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.062]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.062]                   base::options(opts)
[18:04:14.062]                 }
[18:04:14.062]                 {
[18:04:14.062]                   {
[18:04:14.062]                     NULL
[18:04:14.062]                     RNGkind("Mersenne-Twister")
[18:04:14.062]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.062]                       inherits = FALSE)
[18:04:14.062]                   }
[18:04:14.062]                   options(future.plan = NULL)
[18:04:14.062]                   if (is.na(NA_character_)) 
[18:04:14.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.062]                     .init = FALSE)
[18:04:14.062]                 }
[18:04:14.062]             }
[18:04:14.062]         }
[18:04:14.062]     })
[18:04:14.062]     if (TRUE) {
[18:04:14.062]         base::sink(type = "output", split = FALSE)
[18:04:14.062]         if (TRUE) {
[18:04:14.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.062]         }
[18:04:14.062]         else {
[18:04:14.062]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.062]         }
[18:04:14.062]         base::close(...future.stdout)
[18:04:14.062]         ...future.stdout <- NULL
[18:04:14.062]     }
[18:04:14.062]     ...future.result$conditions <- ...future.conditions
[18:04:14.062]     ...future.result$finished <- base::Sys.time()
[18:04:14.062]     ...future.result
[18:04:14.062] }
[18:04:14.066] plan(): Setting new future strategy stack:
[18:04:14.066] List of future strategies:
[18:04:14.066] 1. sequential:
[18:04:14.066]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.066]    - tweaked: FALSE
[18:04:14.066]    - call: NULL
[18:04:14.067] plan(): nbrOfWorkers() = 1
[18:04:14.068] plan(): Setting new future strategy stack:
[18:04:14.068] List of future strategies:
[18:04:14.068] 1. sequential:
[18:04:14.068]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.068]    - tweaked: FALSE
[18:04:14.068]    - call: plan(strategy)
[18:04:14.069] plan(): nbrOfWorkers() = 1
[18:04:14.070] SequentialFuture started (and completed)
[18:04:14.070] - Launch lazy future ... done
[18:04:14.070] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c29c360c8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c299ee8e8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c29c360c8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c299ee8e8> 
 $  : NULL
 $  : NULL
 $  : num 6
[18:04:14.081] resolved() for ‘SequentialFuture’ ...
[18:04:14.081] - state: ‘finished’
[18:04:14.081] - run: TRUE
[18:04:14.082] - result: ‘FutureResult’
[18:04:14.082] resolved() for ‘SequentialFuture’ ... done
[18:04:14.082] resolved() for ‘SequentialFuture’ ...
[18:04:14.082] - state: ‘finished’
[18:04:14.082] - run: TRUE
[18:04:14.083] - result: ‘FutureResult’
[18:04:14.083] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:14.085] resolve() on list ...
[18:04:14.085]  recursive: 0
[18:04:14.085]  length: 6
[18:04:14.086]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:14.086] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.086] - nx: 6
[18:04:14.086] - relay: TRUE
[18:04:14.086] - stdout: TRUE
[18:04:14.087] - signal: TRUE
[18:04:14.087] - resignal: FALSE
[18:04:14.087] - force: TRUE
[18:04:14.087] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.087] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.088]  - until=2
[18:04:14.088]  - relaying element #2
[18:04:14.088] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.088] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.088] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.088]  length: 5 (resolved future 1)
[18:04:14.089] resolved() for ‘SequentialFuture’ ...
[18:04:14.089] - state: ‘finished’
[18:04:14.089] - run: TRUE
[18:04:14.089] - result: ‘FutureResult’
[18:04:14.089] resolved() for ‘SequentialFuture’ ... done
[18:04:14.090] Future #2
[18:04:14.090] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.091] - nx: 6
[18:04:14.091] - relay: TRUE
[18:04:14.091] - stdout: TRUE
[18:04:14.091] - signal: TRUE
[18:04:14.091] - resignal: FALSE
[18:04:14.091] - force: TRUE
[18:04:14.092] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.092] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.092]  - until=2
[18:04:14.092]  - relaying element #2
[18:04:14.093] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.093] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.093] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.093]  length: 4 (resolved future 2)
[18:04:14.094] resolved() for ‘SequentialFuture’ ...
[18:04:14.094] - state: ‘finished’
[18:04:14.094] - run: TRUE
[18:04:14.094] - result: ‘FutureResult’
[18:04:14.094] resolved() for ‘SequentialFuture’ ... done
[18:04:14.095] Future #3
[18:04:14.095] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.095] - nx: 6
[18:04:14.095] - relay: TRUE
[18:04:14.095] - stdout: TRUE
[18:04:14.096] - signal: TRUE
[18:04:14.096] - resignal: FALSE
[18:04:14.096] - force: TRUE
[18:04:14.096] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.096] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.096]  - until=3
[18:04:14.097]  - relaying element #3
[18:04:14.097] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.097] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.097] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.098]  length: 3 (resolved future 3)
[18:04:14.098] signalConditionsASAP(NULL, pos=4) ...
[18:04:14.098] - nx: 6
[18:04:14.098] - relay: TRUE
[18:04:14.098] - stdout: TRUE
[18:04:14.098] - signal: TRUE
[18:04:14.099] - resignal: FALSE
[18:04:14.099] - force: TRUE
[18:04:14.099] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.099] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.099]  - until=5
[18:04:14.100]  - relaying element #5
[18:04:14.100] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.100] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.100] signalConditionsASAP(NULL, pos=4) ... done
[18:04:14.100]  length: 2 (resolved future 4)
[18:04:14.101] signalConditionsASAP(NULL, pos=5) ...
[18:04:14.101] - nx: 6
[18:04:14.101] - relay: TRUE
[18:04:14.101] - stdout: TRUE
[18:04:14.101] - signal: TRUE
[18:04:14.101] - resignal: FALSE
[18:04:14.102] - force: TRUE
[18:04:14.102] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.102] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.102]  - until=6
[18:04:14.102]  - relaying element #6
[18:04:14.102] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.103] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.103] signalConditionsASAP(NULL, pos=5) ... done
[18:04:14.103]  length: 1 (resolved future 5)
[18:04:14.103] signalConditionsASAP(numeric, pos=6) ...
[18:04:14.103] - nx: 6
[18:04:14.104] - relay: TRUE
[18:04:14.107] - stdout: TRUE
[18:04:14.107] - signal: TRUE
[18:04:14.108] - resignal: FALSE
[18:04:14.108] - force: TRUE
[18:04:14.108] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.108] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.108]  - until=6
[18:04:14.108] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.109] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.109] signalConditionsASAP(numeric, pos=6) ... done
[18:04:14.109]  length: 0 (resolved future 6)
[18:04:14.109] Relaying remaining futures
[18:04:14.109] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.110] - nx: 6
[18:04:14.110] - relay: TRUE
[18:04:14.110] - stdout: TRUE
[18:04:14.110] - signal: TRUE
[18:04:14.110] - resignal: FALSE
[18:04:14.110] - force: TRUE
[18:04:14.111] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.111] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:14.111] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.111] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.111] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.112] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[18:04:14.116] getGlobalsAndPackages() ...
[18:04:14.116] Searching for globals...
[18:04:14.117] 
[18:04:14.117] Searching for globals ... DONE
[18:04:14.117] - globals: [0] <none>
[18:04:14.117] getGlobalsAndPackages() ... DONE
[18:04:14.118] run() for ‘Future’ ...
[18:04:14.118] - state: ‘created’
[18:04:14.118] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.119] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.119] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.119]   - Field: ‘label’
[18:04:14.119]   - Field: ‘local’
[18:04:14.120]   - Field: ‘owner’
[18:04:14.120]   - Field: ‘envir’
[18:04:14.120]   - Field: ‘packages’
[18:04:14.120]   - Field: ‘gc’
[18:04:14.120]   - Field: ‘conditions’
[18:04:14.121]   - Field: ‘expr’
[18:04:14.121]   - Field: ‘uuid’
[18:04:14.121]   - Field: ‘seed’
[18:04:14.121]   - Field: ‘version’
[18:04:14.121]   - Field: ‘result’
[18:04:14.122]   - Field: ‘asynchronous’
[18:04:14.122]   - Field: ‘calls’
[18:04:14.122]   - Field: ‘globals’
[18:04:14.122]   - Field: ‘stdout’
[18:04:14.122]   - Field: ‘earlySignal’
[18:04:14.123]   - Field: ‘lazy’
[18:04:14.123]   - Field: ‘state’
[18:04:14.123] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.123] - Launch lazy future ...
[18:04:14.124] Packages needed by the future expression (n = 0): <none>
[18:04:14.124] Packages needed by future strategies (n = 0): <none>
[18:04:14.125] {
[18:04:14.125]     {
[18:04:14.125]         {
[18:04:14.125]             ...future.startTime <- base::Sys.time()
[18:04:14.125]             {
[18:04:14.125]                 {
[18:04:14.125]                   {
[18:04:14.125]                     base::local({
[18:04:14.125]                       has_future <- base::requireNamespace("future", 
[18:04:14.125]                         quietly = TRUE)
[18:04:14.125]                       if (has_future) {
[18:04:14.125]                         ns <- base::getNamespace("future")
[18:04:14.125]                         version <- ns[[".package"]][["version"]]
[18:04:14.125]                         if (is.null(version)) 
[18:04:14.125]                           version <- utils::packageVersion("future")
[18:04:14.125]                       }
[18:04:14.125]                       else {
[18:04:14.125]                         version <- NULL
[18:04:14.125]                       }
[18:04:14.125]                       if (!has_future || version < "1.8.0") {
[18:04:14.125]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.125]                           "", base::R.version$version.string), 
[18:04:14.125]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.125]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.125]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.125]                             "release", "version")], collapse = " "), 
[18:04:14.125]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.125]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.125]                           info)
[18:04:14.125]                         info <- base::paste(info, collapse = "; ")
[18:04:14.125]                         if (!has_future) {
[18:04:14.125]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.125]                             info)
[18:04:14.125]                         }
[18:04:14.125]                         else {
[18:04:14.125]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.125]                             info, version)
[18:04:14.125]                         }
[18:04:14.125]                         base::stop(msg)
[18:04:14.125]                       }
[18:04:14.125]                     })
[18:04:14.125]                   }
[18:04:14.125]                   ...future.strategy.old <- future::plan("list")
[18:04:14.125]                   options(future.plan = NULL)
[18:04:14.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.125]                 }
[18:04:14.125]                 ...future.workdir <- getwd()
[18:04:14.125]             }
[18:04:14.125]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.125]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.125]         }
[18:04:14.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.125]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.125]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.125]             base::names(...future.oldOptions))
[18:04:14.125]     }
[18:04:14.125]     if (FALSE) {
[18:04:14.125]     }
[18:04:14.125]     else {
[18:04:14.125]         if (TRUE) {
[18:04:14.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.125]                 open = "w")
[18:04:14.125]         }
[18:04:14.125]         else {
[18:04:14.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.125]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.125]         }
[18:04:14.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.125]             base::sink(type = "output", split = FALSE)
[18:04:14.125]             base::close(...future.stdout)
[18:04:14.125]         }, add = TRUE)
[18:04:14.125]     }
[18:04:14.125]     ...future.frame <- base::sys.nframe()
[18:04:14.125]     ...future.conditions <- base::list()
[18:04:14.125]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.125]     if (FALSE) {
[18:04:14.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.125]     }
[18:04:14.125]     ...future.result <- base::tryCatch({
[18:04:14.125]         base::withCallingHandlers({
[18:04:14.125]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.125]             future::FutureResult(value = ...future.value$value, 
[18:04:14.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.125]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.125]                     ...future.globalenv.names))
[18:04:14.125]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.125]         }, condition = base::local({
[18:04:14.125]             c <- base::c
[18:04:14.125]             inherits <- base::inherits
[18:04:14.125]             invokeRestart <- base::invokeRestart
[18:04:14.125]             length <- base::length
[18:04:14.125]             list <- base::list
[18:04:14.125]             seq.int <- base::seq.int
[18:04:14.125]             signalCondition <- base::signalCondition
[18:04:14.125]             sys.calls <- base::sys.calls
[18:04:14.125]             `[[` <- base::`[[`
[18:04:14.125]             `+` <- base::`+`
[18:04:14.125]             `<<-` <- base::`<<-`
[18:04:14.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.125]                   3L)]
[18:04:14.125]             }
[18:04:14.125]             function(cond) {
[18:04:14.125]                 is_error <- inherits(cond, "error")
[18:04:14.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.125]                   NULL)
[18:04:14.125]                 if (is_error) {
[18:04:14.125]                   sessionInformation <- function() {
[18:04:14.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.125]                       search = base::search(), system = base::Sys.info())
[18:04:14.125]                   }
[18:04:14.125]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.125]                     cond$call), session = sessionInformation(), 
[18:04:14.125]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.125]                   signalCondition(cond)
[18:04:14.125]                 }
[18:04:14.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.125]                 "immediateCondition"))) {
[18:04:14.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.125]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.125]                   if (TRUE && !signal) {
[18:04:14.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.125]                     {
[18:04:14.125]                       inherits <- base::inherits
[18:04:14.125]                       invokeRestart <- base::invokeRestart
[18:04:14.125]                       is.null <- base::is.null
[18:04:14.125]                       muffled <- FALSE
[18:04:14.125]                       if (inherits(cond, "message")) {
[18:04:14.125]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.125]                         if (muffled) 
[18:04:14.125]                           invokeRestart("muffleMessage")
[18:04:14.125]                       }
[18:04:14.125]                       else if (inherits(cond, "warning")) {
[18:04:14.125]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.125]                         if (muffled) 
[18:04:14.125]                           invokeRestart("muffleWarning")
[18:04:14.125]                       }
[18:04:14.125]                       else if (inherits(cond, "condition")) {
[18:04:14.125]                         if (!is.null(pattern)) {
[18:04:14.125]                           computeRestarts <- base::computeRestarts
[18:04:14.125]                           grepl <- base::grepl
[18:04:14.125]                           restarts <- computeRestarts(cond)
[18:04:14.125]                           for (restart in restarts) {
[18:04:14.125]                             name <- restart$name
[18:04:14.125]                             if (is.null(name)) 
[18:04:14.125]                               next
[18:04:14.125]                             if (!grepl(pattern, name)) 
[18:04:14.125]                               next
[18:04:14.125]                             invokeRestart(restart)
[18:04:14.125]                             muffled <- TRUE
[18:04:14.125]                             break
[18:04:14.125]                           }
[18:04:14.125]                         }
[18:04:14.125]                       }
[18:04:14.125]                       invisible(muffled)
[18:04:14.125]                     }
[18:04:14.125]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.125]                   }
[18:04:14.125]                 }
[18:04:14.125]                 else {
[18:04:14.125]                   if (TRUE) {
[18:04:14.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.125]                     {
[18:04:14.125]                       inherits <- base::inherits
[18:04:14.125]                       invokeRestart <- base::invokeRestart
[18:04:14.125]                       is.null <- base::is.null
[18:04:14.125]                       muffled <- FALSE
[18:04:14.125]                       if (inherits(cond, "message")) {
[18:04:14.125]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.125]                         if (muffled) 
[18:04:14.125]                           invokeRestart("muffleMessage")
[18:04:14.125]                       }
[18:04:14.125]                       else if (inherits(cond, "warning")) {
[18:04:14.125]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.125]                         if (muffled) 
[18:04:14.125]                           invokeRestart("muffleWarning")
[18:04:14.125]                       }
[18:04:14.125]                       else if (inherits(cond, "condition")) {
[18:04:14.125]                         if (!is.null(pattern)) {
[18:04:14.125]                           computeRestarts <- base::computeRestarts
[18:04:14.125]                           grepl <- base::grepl
[18:04:14.125]                           restarts <- computeRestarts(cond)
[18:04:14.125]                           for (restart in restarts) {
[18:04:14.125]                             name <- restart$name
[18:04:14.125]                             if (is.null(name)) 
[18:04:14.125]                               next
[18:04:14.125]                             if (!grepl(pattern, name)) 
[18:04:14.125]                               next
[18:04:14.125]                             invokeRestart(restart)
[18:04:14.125]                             muffled <- TRUE
[18:04:14.125]                             break
[18:04:14.125]                           }
[18:04:14.125]                         }
[18:04:14.125]                       }
[18:04:14.125]                       invisible(muffled)
[18:04:14.125]                     }
[18:04:14.125]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.125]                   }
[18:04:14.125]                 }
[18:04:14.125]             }
[18:04:14.125]         }))
[18:04:14.125]     }, error = function(ex) {
[18:04:14.125]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.125]                 ...future.rng), started = ...future.startTime, 
[18:04:14.125]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.125]             version = "1.8"), class = "FutureResult")
[18:04:14.125]     }, finally = {
[18:04:14.125]         if (!identical(...future.workdir, getwd())) 
[18:04:14.125]             setwd(...future.workdir)
[18:04:14.125]         {
[18:04:14.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.125]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.125]             }
[18:04:14.125]             base::options(...future.oldOptions)
[18:04:14.125]             if (.Platform$OS.type == "windows") {
[18:04:14.125]                 old_names <- names(...future.oldEnvVars)
[18:04:14.125]                 envs <- base::Sys.getenv()
[18:04:14.125]                 names <- names(envs)
[18:04:14.125]                 common <- intersect(names, old_names)
[18:04:14.125]                 added <- setdiff(names, old_names)
[18:04:14.125]                 removed <- setdiff(old_names, names)
[18:04:14.125]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.125]                   envs[common]]
[18:04:14.125]                 NAMES <- toupper(changed)
[18:04:14.125]                 args <- list()
[18:04:14.125]                 for (kk in seq_along(NAMES)) {
[18:04:14.125]                   name <- changed[[kk]]
[18:04:14.125]                   NAME <- NAMES[[kk]]
[18:04:14.125]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.125]                     next
[18:04:14.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.125]                 }
[18:04:14.125]                 NAMES <- toupper(added)
[18:04:14.125]                 for (kk in seq_along(NAMES)) {
[18:04:14.125]                   name <- added[[kk]]
[18:04:14.125]                   NAME <- NAMES[[kk]]
[18:04:14.125]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.125]                     next
[18:04:14.125]                   args[[name]] <- ""
[18:04:14.125]                 }
[18:04:14.125]                 NAMES <- toupper(removed)
[18:04:14.125]                 for (kk in seq_along(NAMES)) {
[18:04:14.125]                   name <- removed[[kk]]
[18:04:14.125]                   NAME <- NAMES[[kk]]
[18:04:14.125]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.125]                     next
[18:04:14.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.125]                 }
[18:04:14.125]                 if (length(args) > 0) 
[18:04:14.125]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.125]             }
[18:04:14.125]             else {
[18:04:14.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.125]             }
[18:04:14.125]             {
[18:04:14.125]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.125]                   0L) {
[18:04:14.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.125]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.125]                   base::options(opts)
[18:04:14.125]                 }
[18:04:14.125]                 {
[18:04:14.125]                   {
[18:04:14.125]                     NULL
[18:04:14.125]                     RNGkind("Mersenne-Twister")
[18:04:14.125]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.125]                       inherits = FALSE)
[18:04:14.125]                   }
[18:04:14.125]                   options(future.plan = NULL)
[18:04:14.125]                   if (is.na(NA_character_)) 
[18:04:14.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.125]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.125]                     .init = FALSE)
[18:04:14.125]                 }
[18:04:14.125]             }
[18:04:14.125]         }
[18:04:14.125]     })
[18:04:14.125]     if (TRUE) {
[18:04:14.125]         base::sink(type = "output", split = FALSE)
[18:04:14.125]         if (TRUE) {
[18:04:14.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.125]         }
[18:04:14.125]         else {
[18:04:14.125]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.125]         }
[18:04:14.125]         base::close(...future.stdout)
[18:04:14.125]         ...future.stdout <- NULL
[18:04:14.125]     }
[18:04:14.125]     ...future.result$conditions <- ...future.conditions
[18:04:14.125]     ...future.result$finished <- base::Sys.time()
[18:04:14.125]     ...future.result
[18:04:14.125] }
[18:04:14.128] plan(): Setting new future strategy stack:
[18:04:14.128] List of future strategies:
[18:04:14.128] 1. sequential:
[18:04:14.128]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.128]    - tweaked: FALSE
[18:04:14.128]    - call: NULL
[18:04:14.129] plan(): nbrOfWorkers() = 1
[18:04:14.131] plan(): Setting new future strategy stack:
[18:04:14.131] List of future strategies:
[18:04:14.131] 1. sequential:
[18:04:14.131]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.131]    - tweaked: FALSE
[18:04:14.131]    - call: plan(strategy)
[18:04:14.132] plan(): nbrOfWorkers() = 1
[18:04:14.132] SequentialFuture started (and completed)
[18:04:14.132] - Launch lazy future ... done
[18:04:14.132] run() for ‘SequentialFuture’ ... done
[18:04:14.133] getGlobalsAndPackages() ...
[18:04:14.133] Searching for globals...
[18:04:14.134] 
[18:04:14.134] Searching for globals ... DONE
[18:04:14.134] - globals: [0] <none>
[18:04:14.134] getGlobalsAndPackages() ... DONE
[18:04:14.135] run() for ‘Future’ ...
[18:04:14.135] - state: ‘created’
[18:04:14.135] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.136] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.136]   - Field: ‘label’
[18:04:14.136]   - Field: ‘local’
[18:04:14.136]   - Field: ‘owner’
[18:04:14.137]   - Field: ‘envir’
[18:04:14.137]   - Field: ‘packages’
[18:04:14.137]   - Field: ‘gc’
[18:04:14.137]   - Field: ‘conditions’
[18:04:14.137]   - Field: ‘expr’
[18:04:14.138]   - Field: ‘uuid’
[18:04:14.138]   - Field: ‘seed’
[18:04:14.138]   - Field: ‘version’
[18:04:14.138]   - Field: ‘result’
[18:04:14.138]   - Field: ‘asynchronous’
[18:04:14.139]   - Field: ‘calls’
[18:04:14.139]   - Field: ‘globals’
[18:04:14.139]   - Field: ‘stdout’
[18:04:14.139]   - Field: ‘earlySignal’
[18:04:14.139]   - Field: ‘lazy’
[18:04:14.139]   - Field: ‘state’
[18:04:14.140] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.140] - Launch lazy future ...
[18:04:14.140] Packages needed by the future expression (n = 0): <none>
[18:04:14.140] Packages needed by future strategies (n = 0): <none>
[18:04:14.141] {
[18:04:14.141]     {
[18:04:14.141]         {
[18:04:14.141]             ...future.startTime <- base::Sys.time()
[18:04:14.141]             {
[18:04:14.141]                 {
[18:04:14.141]                   {
[18:04:14.141]                     base::local({
[18:04:14.141]                       has_future <- base::requireNamespace("future", 
[18:04:14.141]                         quietly = TRUE)
[18:04:14.141]                       if (has_future) {
[18:04:14.141]                         ns <- base::getNamespace("future")
[18:04:14.141]                         version <- ns[[".package"]][["version"]]
[18:04:14.141]                         if (is.null(version)) 
[18:04:14.141]                           version <- utils::packageVersion("future")
[18:04:14.141]                       }
[18:04:14.141]                       else {
[18:04:14.141]                         version <- NULL
[18:04:14.141]                       }
[18:04:14.141]                       if (!has_future || version < "1.8.0") {
[18:04:14.141]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.141]                           "", base::R.version$version.string), 
[18:04:14.141]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.141]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.141]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.141]                             "release", "version")], collapse = " "), 
[18:04:14.141]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.141]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.141]                           info)
[18:04:14.141]                         info <- base::paste(info, collapse = "; ")
[18:04:14.141]                         if (!has_future) {
[18:04:14.141]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.141]                             info)
[18:04:14.141]                         }
[18:04:14.141]                         else {
[18:04:14.141]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.141]                             info, version)
[18:04:14.141]                         }
[18:04:14.141]                         base::stop(msg)
[18:04:14.141]                       }
[18:04:14.141]                     })
[18:04:14.141]                   }
[18:04:14.141]                   ...future.strategy.old <- future::plan("list")
[18:04:14.141]                   options(future.plan = NULL)
[18:04:14.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.141]                 }
[18:04:14.141]                 ...future.workdir <- getwd()
[18:04:14.141]             }
[18:04:14.141]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.141]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.141]         }
[18:04:14.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.141]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.141]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.141]             base::names(...future.oldOptions))
[18:04:14.141]     }
[18:04:14.141]     if (FALSE) {
[18:04:14.141]     }
[18:04:14.141]     else {
[18:04:14.141]         if (TRUE) {
[18:04:14.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.141]                 open = "w")
[18:04:14.141]         }
[18:04:14.141]         else {
[18:04:14.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.141]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.141]         }
[18:04:14.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.141]             base::sink(type = "output", split = FALSE)
[18:04:14.141]             base::close(...future.stdout)
[18:04:14.141]         }, add = TRUE)
[18:04:14.141]     }
[18:04:14.141]     ...future.frame <- base::sys.nframe()
[18:04:14.141]     ...future.conditions <- base::list()
[18:04:14.141]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.141]     if (FALSE) {
[18:04:14.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.141]     }
[18:04:14.141]     ...future.result <- base::tryCatch({
[18:04:14.141]         base::withCallingHandlers({
[18:04:14.141]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.141]             future::FutureResult(value = ...future.value$value, 
[18:04:14.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.141]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.141]                     ...future.globalenv.names))
[18:04:14.141]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.141]         }, condition = base::local({
[18:04:14.141]             c <- base::c
[18:04:14.141]             inherits <- base::inherits
[18:04:14.141]             invokeRestart <- base::invokeRestart
[18:04:14.141]             length <- base::length
[18:04:14.141]             list <- base::list
[18:04:14.141]             seq.int <- base::seq.int
[18:04:14.141]             signalCondition <- base::signalCondition
[18:04:14.141]             sys.calls <- base::sys.calls
[18:04:14.141]             `[[` <- base::`[[`
[18:04:14.141]             `+` <- base::`+`
[18:04:14.141]             `<<-` <- base::`<<-`
[18:04:14.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.141]                   3L)]
[18:04:14.141]             }
[18:04:14.141]             function(cond) {
[18:04:14.141]                 is_error <- inherits(cond, "error")
[18:04:14.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.141]                   NULL)
[18:04:14.141]                 if (is_error) {
[18:04:14.141]                   sessionInformation <- function() {
[18:04:14.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.141]                       search = base::search(), system = base::Sys.info())
[18:04:14.141]                   }
[18:04:14.141]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.141]                     cond$call), session = sessionInformation(), 
[18:04:14.141]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.141]                   signalCondition(cond)
[18:04:14.141]                 }
[18:04:14.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.141]                 "immediateCondition"))) {
[18:04:14.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.141]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.141]                   if (TRUE && !signal) {
[18:04:14.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.141]                     {
[18:04:14.141]                       inherits <- base::inherits
[18:04:14.141]                       invokeRestart <- base::invokeRestart
[18:04:14.141]                       is.null <- base::is.null
[18:04:14.141]                       muffled <- FALSE
[18:04:14.141]                       if (inherits(cond, "message")) {
[18:04:14.141]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.141]                         if (muffled) 
[18:04:14.141]                           invokeRestart("muffleMessage")
[18:04:14.141]                       }
[18:04:14.141]                       else if (inherits(cond, "warning")) {
[18:04:14.141]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.141]                         if (muffled) 
[18:04:14.141]                           invokeRestart("muffleWarning")
[18:04:14.141]                       }
[18:04:14.141]                       else if (inherits(cond, "condition")) {
[18:04:14.141]                         if (!is.null(pattern)) {
[18:04:14.141]                           computeRestarts <- base::computeRestarts
[18:04:14.141]                           grepl <- base::grepl
[18:04:14.141]                           restarts <- computeRestarts(cond)
[18:04:14.141]                           for (restart in restarts) {
[18:04:14.141]                             name <- restart$name
[18:04:14.141]                             if (is.null(name)) 
[18:04:14.141]                               next
[18:04:14.141]                             if (!grepl(pattern, name)) 
[18:04:14.141]                               next
[18:04:14.141]                             invokeRestart(restart)
[18:04:14.141]                             muffled <- TRUE
[18:04:14.141]                             break
[18:04:14.141]                           }
[18:04:14.141]                         }
[18:04:14.141]                       }
[18:04:14.141]                       invisible(muffled)
[18:04:14.141]                     }
[18:04:14.141]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.141]                   }
[18:04:14.141]                 }
[18:04:14.141]                 else {
[18:04:14.141]                   if (TRUE) {
[18:04:14.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.141]                     {
[18:04:14.141]                       inherits <- base::inherits
[18:04:14.141]                       invokeRestart <- base::invokeRestart
[18:04:14.141]                       is.null <- base::is.null
[18:04:14.141]                       muffled <- FALSE
[18:04:14.141]                       if (inherits(cond, "message")) {
[18:04:14.141]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.141]                         if (muffled) 
[18:04:14.141]                           invokeRestart("muffleMessage")
[18:04:14.141]                       }
[18:04:14.141]                       else if (inherits(cond, "warning")) {
[18:04:14.141]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.141]                         if (muffled) 
[18:04:14.141]                           invokeRestart("muffleWarning")
[18:04:14.141]                       }
[18:04:14.141]                       else if (inherits(cond, "condition")) {
[18:04:14.141]                         if (!is.null(pattern)) {
[18:04:14.141]                           computeRestarts <- base::computeRestarts
[18:04:14.141]                           grepl <- base::grepl
[18:04:14.141]                           restarts <- computeRestarts(cond)
[18:04:14.141]                           for (restart in restarts) {
[18:04:14.141]                             name <- restart$name
[18:04:14.141]                             if (is.null(name)) 
[18:04:14.141]                               next
[18:04:14.141]                             if (!grepl(pattern, name)) 
[18:04:14.141]                               next
[18:04:14.141]                             invokeRestart(restart)
[18:04:14.141]                             muffled <- TRUE
[18:04:14.141]                             break
[18:04:14.141]                           }
[18:04:14.141]                         }
[18:04:14.141]                       }
[18:04:14.141]                       invisible(muffled)
[18:04:14.141]                     }
[18:04:14.141]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.141]                   }
[18:04:14.141]                 }
[18:04:14.141]             }
[18:04:14.141]         }))
[18:04:14.141]     }, error = function(ex) {
[18:04:14.141]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.141]                 ...future.rng), started = ...future.startTime, 
[18:04:14.141]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.141]             version = "1.8"), class = "FutureResult")
[18:04:14.141]     }, finally = {
[18:04:14.141]         if (!identical(...future.workdir, getwd())) 
[18:04:14.141]             setwd(...future.workdir)
[18:04:14.141]         {
[18:04:14.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.141]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.141]             }
[18:04:14.141]             base::options(...future.oldOptions)
[18:04:14.141]             if (.Platform$OS.type == "windows") {
[18:04:14.141]                 old_names <- names(...future.oldEnvVars)
[18:04:14.141]                 envs <- base::Sys.getenv()
[18:04:14.141]                 names <- names(envs)
[18:04:14.141]                 common <- intersect(names, old_names)
[18:04:14.141]                 added <- setdiff(names, old_names)
[18:04:14.141]                 removed <- setdiff(old_names, names)
[18:04:14.141]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.141]                   envs[common]]
[18:04:14.141]                 NAMES <- toupper(changed)
[18:04:14.141]                 args <- list()
[18:04:14.141]                 for (kk in seq_along(NAMES)) {
[18:04:14.141]                   name <- changed[[kk]]
[18:04:14.141]                   NAME <- NAMES[[kk]]
[18:04:14.141]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.141]                     next
[18:04:14.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.141]                 }
[18:04:14.141]                 NAMES <- toupper(added)
[18:04:14.141]                 for (kk in seq_along(NAMES)) {
[18:04:14.141]                   name <- added[[kk]]
[18:04:14.141]                   NAME <- NAMES[[kk]]
[18:04:14.141]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.141]                     next
[18:04:14.141]                   args[[name]] <- ""
[18:04:14.141]                 }
[18:04:14.141]                 NAMES <- toupper(removed)
[18:04:14.141]                 for (kk in seq_along(NAMES)) {
[18:04:14.141]                   name <- removed[[kk]]
[18:04:14.141]                   NAME <- NAMES[[kk]]
[18:04:14.141]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.141]                     next
[18:04:14.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.141]                 }
[18:04:14.141]                 if (length(args) > 0) 
[18:04:14.141]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.141]             }
[18:04:14.141]             else {
[18:04:14.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.141]             }
[18:04:14.141]             {
[18:04:14.141]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.141]                   0L) {
[18:04:14.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.141]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.141]                   base::options(opts)
[18:04:14.141]                 }
[18:04:14.141]                 {
[18:04:14.141]                   {
[18:04:14.141]                     NULL
[18:04:14.141]                     RNGkind("Mersenne-Twister")
[18:04:14.141]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.141]                       inherits = FALSE)
[18:04:14.141]                   }
[18:04:14.141]                   options(future.plan = NULL)
[18:04:14.141]                   if (is.na(NA_character_)) 
[18:04:14.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.141]                     .init = FALSE)
[18:04:14.141]                 }
[18:04:14.141]             }
[18:04:14.141]         }
[18:04:14.141]     })
[18:04:14.141]     if (TRUE) {
[18:04:14.141]         base::sink(type = "output", split = FALSE)
[18:04:14.141]         if (TRUE) {
[18:04:14.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.141]         }
[18:04:14.141]         else {
[18:04:14.141]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.141]         }
[18:04:14.141]         base::close(...future.stdout)
[18:04:14.141]         ...future.stdout <- NULL
[18:04:14.141]     }
[18:04:14.141]     ...future.result$conditions <- ...future.conditions
[18:04:14.141]     ...future.result$finished <- base::Sys.time()
[18:04:14.141]     ...future.result
[18:04:14.141] }
[18:04:14.145] plan(): Setting new future strategy stack:
[18:04:14.145] List of future strategies:
[18:04:14.145] 1. sequential:
[18:04:14.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.145]    - tweaked: FALSE
[18:04:14.145]    - call: NULL
[18:04:14.146] plan(): nbrOfWorkers() = 1
[18:04:14.147] plan(): Setting new future strategy stack:
[18:04:14.147] List of future strategies:
[18:04:14.147] 1. sequential:
[18:04:14.147]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.147]    - tweaked: FALSE
[18:04:14.147]    - call: plan(strategy)
[18:04:14.148] plan(): nbrOfWorkers() = 1
[18:04:14.149] SequentialFuture started (and completed)
[18:04:14.149] - Launch lazy future ... done
[18:04:14.149] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c28d3a3c0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2acdb318> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c28d3a3c0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2acdb318> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[18:04:14.158] resolved() for ‘SequentialFuture’ ...
[18:04:14.159] - state: ‘finished’
[18:04:14.159] - run: TRUE
[18:04:14.159] - result: ‘FutureResult’
[18:04:14.159] resolved() for ‘SequentialFuture’ ... done
[18:04:14.160] resolved() for ‘SequentialFuture’ ...
[18:04:14.160] - state: ‘finished’
[18:04:14.160] - run: TRUE
[18:04:14.160] - result: ‘FutureResult’
[18:04:14.160] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:14.164] resolve() on list ...
[18:04:14.164]  recursive: 0
[18:04:14.164]  length: 6
[18:04:14.164]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:14.165] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.165] - nx: 6
[18:04:14.165] - relay: TRUE
[18:04:14.165] - stdout: TRUE
[18:04:14.165] - signal: TRUE
[18:04:14.166] - resignal: FALSE
[18:04:14.166] - force: TRUE
[18:04:14.166] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.166] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.166]  - until=2
[18:04:14.166]  - relaying element #2
[18:04:14.167] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.167] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.167] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.167]  length: 5 (resolved future 1)
[18:04:14.167] resolved() for ‘SequentialFuture’ ...
[18:04:14.168] - state: ‘finished’
[18:04:14.168] - run: TRUE
[18:04:14.168] - result: ‘FutureResult’
[18:04:14.168] resolved() for ‘SequentialFuture’ ... done
[18:04:14.168] Future #2
[18:04:14.169] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.169] - nx: 6
[18:04:14.171] - relay: TRUE
[18:04:14.172] - stdout: TRUE
[18:04:14.172] - signal: TRUE
[18:04:14.172] - resignal: FALSE
[18:04:14.172] - force: TRUE
[18:04:14.172] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.173] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.173]  - until=2
[18:04:14.173]  - relaying element #2
[18:04:14.173] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.174] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.174] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.174]  length: 4 (resolved future 2)
[18:04:14.174] resolved() for ‘SequentialFuture’ ...
[18:04:14.174] - state: ‘finished’
[18:04:14.175] - run: TRUE
[18:04:14.175] - result: ‘FutureResult’
[18:04:14.175] resolved() for ‘SequentialFuture’ ... done
[18:04:14.175] Future #3
[18:04:14.175] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.176] - nx: 6
[18:04:14.176] - relay: TRUE
[18:04:14.176] - stdout: TRUE
[18:04:14.176] - signal: TRUE
[18:04:14.176] - resignal: FALSE
[18:04:14.176] - force: TRUE
[18:04:14.177] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.177] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.177]  - until=3
[18:04:14.177]  - relaying element #3
[18:04:14.178] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.178] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.178] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.178]  length: 3 (resolved future 3)
[18:04:14.178] signalConditionsASAP(NULL, pos=4) ...
[18:04:14.179] - nx: 6
[18:04:14.179] - relay: TRUE
[18:04:14.179] - stdout: TRUE
[18:04:14.179] - signal: TRUE
[18:04:14.179] - resignal: FALSE
[18:04:14.179] - force: TRUE
[18:04:14.180] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.180] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.180]  - until=5
[18:04:14.180]  - relaying element #5
[18:04:14.180] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.180] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.181] signalConditionsASAP(NULL, pos=4) ... done
[18:04:14.181]  length: 2 (resolved future 4)
[18:04:14.181] signalConditionsASAP(NULL, pos=5) ...
[18:04:14.181] - nx: 6
[18:04:14.181] - relay: TRUE
[18:04:14.182] - stdout: TRUE
[18:04:14.182] - signal: TRUE
[18:04:14.182] - resignal: FALSE
[18:04:14.182] - force: TRUE
[18:04:14.182] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.183] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.183]  - until=6
[18:04:14.183]  - relaying element #6
[18:04:14.183] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.183] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.184] signalConditionsASAP(NULL, pos=5) ... done
[18:04:14.184]  length: 1 (resolved future 5)
[18:04:14.184] signalConditionsASAP(numeric, pos=6) ...
[18:04:14.184] - nx: 6
[18:04:14.184] - relay: TRUE
[18:04:14.185] - stdout: TRUE
[18:04:14.185] - signal: TRUE
[18:04:14.185] - resignal: FALSE
[18:04:14.185] - force: TRUE
[18:04:14.185] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.185] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.186]  - until=6
[18:04:14.186] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.186] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.186] signalConditionsASAP(numeric, pos=6) ... done
[18:04:14.186]  length: 0 (resolved future 6)
[18:04:14.187] Relaying remaining futures
[18:04:14.187] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.188] - nx: 6
[18:04:14.188] - relay: TRUE
[18:04:14.188] - stdout: TRUE
[18:04:14.188] - signal: TRUE
[18:04:14.188] - resignal: FALSE
[18:04:14.188] - force: TRUE
[18:04:14.189] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.189] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:14.189] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.189] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.190] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.190] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[18:04:14.197] getGlobalsAndPackages() ...
[18:04:14.197] Searching for globals...
[18:04:14.198] 
[18:04:14.198] Searching for globals ... DONE
[18:04:14.198] - globals: [0] <none>
[18:04:14.198] getGlobalsAndPackages() ... DONE
[18:04:14.199] run() for ‘Future’ ...
[18:04:14.199] - state: ‘created’
[18:04:14.200] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.200] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.200] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.201]   - Field: ‘label’
[18:04:14.201]   - Field: ‘local’
[18:04:14.201]   - Field: ‘owner’
[18:04:14.201]   - Field: ‘envir’
[18:04:14.201]   - Field: ‘packages’
[18:04:14.202]   - Field: ‘gc’
[18:04:14.202]   - Field: ‘conditions’
[18:04:14.202]   - Field: ‘expr’
[18:04:14.202]   - Field: ‘uuid’
[18:04:14.202]   - Field: ‘seed’
[18:04:14.203]   - Field: ‘version’
[18:04:14.203]   - Field: ‘result’
[18:04:14.203]   - Field: ‘asynchronous’
[18:04:14.203]   - Field: ‘calls’
[18:04:14.203]   - Field: ‘globals’
[18:04:14.204]   - Field: ‘stdout’
[18:04:14.204]   - Field: ‘earlySignal’
[18:04:14.204]   - Field: ‘lazy’
[18:04:14.204]   - Field: ‘state’
[18:04:14.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.205] - Launch lazy future ...
[18:04:14.205] Packages needed by the future expression (n = 0): <none>
[18:04:14.205] Packages needed by future strategies (n = 0): <none>
[18:04:14.206] {
[18:04:14.206]     {
[18:04:14.206]         {
[18:04:14.206]             ...future.startTime <- base::Sys.time()
[18:04:14.206]             {
[18:04:14.206]                 {
[18:04:14.206]                   {
[18:04:14.206]                     base::local({
[18:04:14.206]                       has_future <- base::requireNamespace("future", 
[18:04:14.206]                         quietly = TRUE)
[18:04:14.206]                       if (has_future) {
[18:04:14.206]                         ns <- base::getNamespace("future")
[18:04:14.206]                         version <- ns[[".package"]][["version"]]
[18:04:14.206]                         if (is.null(version)) 
[18:04:14.206]                           version <- utils::packageVersion("future")
[18:04:14.206]                       }
[18:04:14.206]                       else {
[18:04:14.206]                         version <- NULL
[18:04:14.206]                       }
[18:04:14.206]                       if (!has_future || version < "1.8.0") {
[18:04:14.206]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.206]                           "", base::R.version$version.string), 
[18:04:14.206]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.206]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.206]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.206]                             "release", "version")], collapse = " "), 
[18:04:14.206]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.206]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.206]                           info)
[18:04:14.206]                         info <- base::paste(info, collapse = "; ")
[18:04:14.206]                         if (!has_future) {
[18:04:14.206]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.206]                             info)
[18:04:14.206]                         }
[18:04:14.206]                         else {
[18:04:14.206]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.206]                             info, version)
[18:04:14.206]                         }
[18:04:14.206]                         base::stop(msg)
[18:04:14.206]                       }
[18:04:14.206]                     })
[18:04:14.206]                   }
[18:04:14.206]                   ...future.strategy.old <- future::plan("list")
[18:04:14.206]                   options(future.plan = NULL)
[18:04:14.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.206]                 }
[18:04:14.206]                 ...future.workdir <- getwd()
[18:04:14.206]             }
[18:04:14.206]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.206]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.206]         }
[18:04:14.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.206]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.206]             base::names(...future.oldOptions))
[18:04:14.206]     }
[18:04:14.206]     if (FALSE) {
[18:04:14.206]     }
[18:04:14.206]     else {
[18:04:14.206]         if (TRUE) {
[18:04:14.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.206]                 open = "w")
[18:04:14.206]         }
[18:04:14.206]         else {
[18:04:14.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.206]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.206]         }
[18:04:14.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.206]             base::sink(type = "output", split = FALSE)
[18:04:14.206]             base::close(...future.stdout)
[18:04:14.206]         }, add = TRUE)
[18:04:14.206]     }
[18:04:14.206]     ...future.frame <- base::sys.nframe()
[18:04:14.206]     ...future.conditions <- base::list()
[18:04:14.206]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.206]     if (FALSE) {
[18:04:14.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.206]     }
[18:04:14.206]     ...future.result <- base::tryCatch({
[18:04:14.206]         base::withCallingHandlers({
[18:04:14.206]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.206]             future::FutureResult(value = ...future.value$value, 
[18:04:14.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.206]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.206]                     ...future.globalenv.names))
[18:04:14.206]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.206]         }, condition = base::local({
[18:04:14.206]             c <- base::c
[18:04:14.206]             inherits <- base::inherits
[18:04:14.206]             invokeRestart <- base::invokeRestart
[18:04:14.206]             length <- base::length
[18:04:14.206]             list <- base::list
[18:04:14.206]             seq.int <- base::seq.int
[18:04:14.206]             signalCondition <- base::signalCondition
[18:04:14.206]             sys.calls <- base::sys.calls
[18:04:14.206]             `[[` <- base::`[[`
[18:04:14.206]             `+` <- base::`+`
[18:04:14.206]             `<<-` <- base::`<<-`
[18:04:14.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.206]                   3L)]
[18:04:14.206]             }
[18:04:14.206]             function(cond) {
[18:04:14.206]                 is_error <- inherits(cond, "error")
[18:04:14.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.206]                   NULL)
[18:04:14.206]                 if (is_error) {
[18:04:14.206]                   sessionInformation <- function() {
[18:04:14.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.206]                       search = base::search(), system = base::Sys.info())
[18:04:14.206]                   }
[18:04:14.206]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.206]                     cond$call), session = sessionInformation(), 
[18:04:14.206]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.206]                   signalCondition(cond)
[18:04:14.206]                 }
[18:04:14.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.206]                 "immediateCondition"))) {
[18:04:14.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.206]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.206]                   if (TRUE && !signal) {
[18:04:14.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.206]                     {
[18:04:14.206]                       inherits <- base::inherits
[18:04:14.206]                       invokeRestart <- base::invokeRestart
[18:04:14.206]                       is.null <- base::is.null
[18:04:14.206]                       muffled <- FALSE
[18:04:14.206]                       if (inherits(cond, "message")) {
[18:04:14.206]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.206]                         if (muffled) 
[18:04:14.206]                           invokeRestart("muffleMessage")
[18:04:14.206]                       }
[18:04:14.206]                       else if (inherits(cond, "warning")) {
[18:04:14.206]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.206]                         if (muffled) 
[18:04:14.206]                           invokeRestart("muffleWarning")
[18:04:14.206]                       }
[18:04:14.206]                       else if (inherits(cond, "condition")) {
[18:04:14.206]                         if (!is.null(pattern)) {
[18:04:14.206]                           computeRestarts <- base::computeRestarts
[18:04:14.206]                           grepl <- base::grepl
[18:04:14.206]                           restarts <- computeRestarts(cond)
[18:04:14.206]                           for (restart in restarts) {
[18:04:14.206]                             name <- restart$name
[18:04:14.206]                             if (is.null(name)) 
[18:04:14.206]                               next
[18:04:14.206]                             if (!grepl(pattern, name)) 
[18:04:14.206]                               next
[18:04:14.206]                             invokeRestart(restart)
[18:04:14.206]                             muffled <- TRUE
[18:04:14.206]                             break
[18:04:14.206]                           }
[18:04:14.206]                         }
[18:04:14.206]                       }
[18:04:14.206]                       invisible(muffled)
[18:04:14.206]                     }
[18:04:14.206]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.206]                   }
[18:04:14.206]                 }
[18:04:14.206]                 else {
[18:04:14.206]                   if (TRUE) {
[18:04:14.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.206]                     {
[18:04:14.206]                       inherits <- base::inherits
[18:04:14.206]                       invokeRestart <- base::invokeRestart
[18:04:14.206]                       is.null <- base::is.null
[18:04:14.206]                       muffled <- FALSE
[18:04:14.206]                       if (inherits(cond, "message")) {
[18:04:14.206]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.206]                         if (muffled) 
[18:04:14.206]                           invokeRestart("muffleMessage")
[18:04:14.206]                       }
[18:04:14.206]                       else if (inherits(cond, "warning")) {
[18:04:14.206]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.206]                         if (muffled) 
[18:04:14.206]                           invokeRestart("muffleWarning")
[18:04:14.206]                       }
[18:04:14.206]                       else if (inherits(cond, "condition")) {
[18:04:14.206]                         if (!is.null(pattern)) {
[18:04:14.206]                           computeRestarts <- base::computeRestarts
[18:04:14.206]                           grepl <- base::grepl
[18:04:14.206]                           restarts <- computeRestarts(cond)
[18:04:14.206]                           for (restart in restarts) {
[18:04:14.206]                             name <- restart$name
[18:04:14.206]                             if (is.null(name)) 
[18:04:14.206]                               next
[18:04:14.206]                             if (!grepl(pattern, name)) 
[18:04:14.206]                               next
[18:04:14.206]                             invokeRestart(restart)
[18:04:14.206]                             muffled <- TRUE
[18:04:14.206]                             break
[18:04:14.206]                           }
[18:04:14.206]                         }
[18:04:14.206]                       }
[18:04:14.206]                       invisible(muffled)
[18:04:14.206]                     }
[18:04:14.206]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.206]                   }
[18:04:14.206]                 }
[18:04:14.206]             }
[18:04:14.206]         }))
[18:04:14.206]     }, error = function(ex) {
[18:04:14.206]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.206]                 ...future.rng), started = ...future.startTime, 
[18:04:14.206]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.206]             version = "1.8"), class = "FutureResult")
[18:04:14.206]     }, finally = {
[18:04:14.206]         if (!identical(...future.workdir, getwd())) 
[18:04:14.206]             setwd(...future.workdir)
[18:04:14.206]         {
[18:04:14.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.206]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.206]             }
[18:04:14.206]             base::options(...future.oldOptions)
[18:04:14.206]             if (.Platform$OS.type == "windows") {
[18:04:14.206]                 old_names <- names(...future.oldEnvVars)
[18:04:14.206]                 envs <- base::Sys.getenv()
[18:04:14.206]                 names <- names(envs)
[18:04:14.206]                 common <- intersect(names, old_names)
[18:04:14.206]                 added <- setdiff(names, old_names)
[18:04:14.206]                 removed <- setdiff(old_names, names)
[18:04:14.206]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.206]                   envs[common]]
[18:04:14.206]                 NAMES <- toupper(changed)
[18:04:14.206]                 args <- list()
[18:04:14.206]                 for (kk in seq_along(NAMES)) {
[18:04:14.206]                   name <- changed[[kk]]
[18:04:14.206]                   NAME <- NAMES[[kk]]
[18:04:14.206]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.206]                     next
[18:04:14.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.206]                 }
[18:04:14.206]                 NAMES <- toupper(added)
[18:04:14.206]                 for (kk in seq_along(NAMES)) {
[18:04:14.206]                   name <- added[[kk]]
[18:04:14.206]                   NAME <- NAMES[[kk]]
[18:04:14.206]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.206]                     next
[18:04:14.206]                   args[[name]] <- ""
[18:04:14.206]                 }
[18:04:14.206]                 NAMES <- toupper(removed)
[18:04:14.206]                 for (kk in seq_along(NAMES)) {
[18:04:14.206]                   name <- removed[[kk]]
[18:04:14.206]                   NAME <- NAMES[[kk]]
[18:04:14.206]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.206]                     next
[18:04:14.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.206]                 }
[18:04:14.206]                 if (length(args) > 0) 
[18:04:14.206]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.206]             }
[18:04:14.206]             else {
[18:04:14.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.206]             }
[18:04:14.206]             {
[18:04:14.206]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.206]                   0L) {
[18:04:14.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.206]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.206]                   base::options(opts)
[18:04:14.206]                 }
[18:04:14.206]                 {
[18:04:14.206]                   {
[18:04:14.206]                     NULL
[18:04:14.206]                     RNGkind("Mersenne-Twister")
[18:04:14.206]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.206]                       inherits = FALSE)
[18:04:14.206]                   }
[18:04:14.206]                   options(future.plan = NULL)
[18:04:14.206]                   if (is.na(NA_character_)) 
[18:04:14.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.206]                     .init = FALSE)
[18:04:14.206]                 }
[18:04:14.206]             }
[18:04:14.206]         }
[18:04:14.206]     })
[18:04:14.206]     if (TRUE) {
[18:04:14.206]         base::sink(type = "output", split = FALSE)
[18:04:14.206]         if (TRUE) {
[18:04:14.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.206]         }
[18:04:14.206]         else {
[18:04:14.206]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.206]         }
[18:04:14.206]         base::close(...future.stdout)
[18:04:14.206]         ...future.stdout <- NULL
[18:04:14.206]     }
[18:04:14.206]     ...future.result$conditions <- ...future.conditions
[18:04:14.206]     ...future.result$finished <- base::Sys.time()
[18:04:14.206]     ...future.result
[18:04:14.206] }
[18:04:14.210] plan(): Setting new future strategy stack:
[18:04:14.210] List of future strategies:
[18:04:14.210] 1. sequential:
[18:04:14.210]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.210]    - tweaked: FALSE
[18:04:14.210]    - call: NULL
[18:04:14.211] plan(): nbrOfWorkers() = 1
[18:04:14.213] plan(): Setting new future strategy stack:
[18:04:14.213] List of future strategies:
[18:04:14.213] 1. sequential:
[18:04:14.213]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.213]    - tweaked: FALSE
[18:04:14.213]    - call: plan(strategy)
[18:04:14.214] plan(): nbrOfWorkers() = 1
[18:04:14.214] SequentialFuture started (and completed)
[18:04:14.215] - Launch lazy future ... done
[18:04:14.215] run() for ‘SequentialFuture’ ... done
[18:04:14.215] getGlobalsAndPackages() ...
[18:04:14.215] Searching for globals...
[18:04:14.216] 
[18:04:14.216] Searching for globals ... DONE
[18:04:14.217] - globals: [0] <none>
[18:04:14.217] getGlobalsAndPackages() ... DONE
[18:04:14.217] run() for ‘Future’ ...
[18:04:14.218] - state: ‘created’
[18:04:14.218] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.218] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.219] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.219]   - Field: ‘label’
[18:04:14.219]   - Field: ‘local’
[18:04:14.219]   - Field: ‘owner’
[18:04:14.219]   - Field: ‘envir’
[18:04:14.220]   - Field: ‘packages’
[18:04:14.220]   - Field: ‘gc’
[18:04:14.220]   - Field: ‘conditions’
[18:04:14.220]   - Field: ‘expr’
[18:04:14.220]   - Field: ‘uuid’
[18:04:14.221]   - Field: ‘seed’
[18:04:14.221]   - Field: ‘version’
[18:04:14.221]   - Field: ‘result’
[18:04:14.221]   - Field: ‘asynchronous’
[18:04:14.221]   - Field: ‘calls’
[18:04:14.222]   - Field: ‘globals’
[18:04:14.222]   - Field: ‘stdout’
[18:04:14.222]   - Field: ‘earlySignal’
[18:04:14.222]   - Field: ‘lazy’
[18:04:14.222]   - Field: ‘state’
[18:04:14.223] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.223] - Launch lazy future ...
[18:04:14.223] Packages needed by the future expression (n = 0): <none>
[18:04:14.223] Packages needed by future strategies (n = 0): <none>
[18:04:14.224] {
[18:04:14.224]     {
[18:04:14.224]         {
[18:04:14.224]             ...future.startTime <- base::Sys.time()
[18:04:14.224]             {
[18:04:14.224]                 {
[18:04:14.224]                   {
[18:04:14.224]                     base::local({
[18:04:14.224]                       has_future <- base::requireNamespace("future", 
[18:04:14.224]                         quietly = TRUE)
[18:04:14.224]                       if (has_future) {
[18:04:14.224]                         ns <- base::getNamespace("future")
[18:04:14.224]                         version <- ns[[".package"]][["version"]]
[18:04:14.224]                         if (is.null(version)) 
[18:04:14.224]                           version <- utils::packageVersion("future")
[18:04:14.224]                       }
[18:04:14.224]                       else {
[18:04:14.224]                         version <- NULL
[18:04:14.224]                       }
[18:04:14.224]                       if (!has_future || version < "1.8.0") {
[18:04:14.224]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.224]                           "", base::R.version$version.string), 
[18:04:14.224]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.224]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.224]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.224]                             "release", "version")], collapse = " "), 
[18:04:14.224]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.224]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.224]                           info)
[18:04:14.224]                         info <- base::paste(info, collapse = "; ")
[18:04:14.224]                         if (!has_future) {
[18:04:14.224]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.224]                             info)
[18:04:14.224]                         }
[18:04:14.224]                         else {
[18:04:14.224]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.224]                             info, version)
[18:04:14.224]                         }
[18:04:14.224]                         base::stop(msg)
[18:04:14.224]                       }
[18:04:14.224]                     })
[18:04:14.224]                   }
[18:04:14.224]                   ...future.strategy.old <- future::plan("list")
[18:04:14.224]                   options(future.plan = NULL)
[18:04:14.224]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.224]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.224]                 }
[18:04:14.224]                 ...future.workdir <- getwd()
[18:04:14.224]             }
[18:04:14.224]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.224]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.224]         }
[18:04:14.224]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.224]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.224]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.224]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.224]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.224]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.224]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.224]             base::names(...future.oldOptions))
[18:04:14.224]     }
[18:04:14.224]     if (FALSE) {
[18:04:14.224]     }
[18:04:14.224]     else {
[18:04:14.224]         if (TRUE) {
[18:04:14.224]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.224]                 open = "w")
[18:04:14.224]         }
[18:04:14.224]         else {
[18:04:14.224]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.224]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.224]         }
[18:04:14.224]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.224]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.224]             base::sink(type = "output", split = FALSE)
[18:04:14.224]             base::close(...future.stdout)
[18:04:14.224]         }, add = TRUE)
[18:04:14.224]     }
[18:04:14.224]     ...future.frame <- base::sys.nframe()
[18:04:14.224]     ...future.conditions <- base::list()
[18:04:14.224]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.224]     if (FALSE) {
[18:04:14.224]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.224]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.224]     }
[18:04:14.224]     ...future.result <- base::tryCatch({
[18:04:14.224]         base::withCallingHandlers({
[18:04:14.224]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.224]             future::FutureResult(value = ...future.value$value, 
[18:04:14.224]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.224]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.224]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.224]                     ...future.globalenv.names))
[18:04:14.224]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.224]         }, condition = base::local({
[18:04:14.224]             c <- base::c
[18:04:14.224]             inherits <- base::inherits
[18:04:14.224]             invokeRestart <- base::invokeRestart
[18:04:14.224]             length <- base::length
[18:04:14.224]             list <- base::list
[18:04:14.224]             seq.int <- base::seq.int
[18:04:14.224]             signalCondition <- base::signalCondition
[18:04:14.224]             sys.calls <- base::sys.calls
[18:04:14.224]             `[[` <- base::`[[`
[18:04:14.224]             `+` <- base::`+`
[18:04:14.224]             `<<-` <- base::`<<-`
[18:04:14.224]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.224]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.224]                   3L)]
[18:04:14.224]             }
[18:04:14.224]             function(cond) {
[18:04:14.224]                 is_error <- inherits(cond, "error")
[18:04:14.224]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.224]                   NULL)
[18:04:14.224]                 if (is_error) {
[18:04:14.224]                   sessionInformation <- function() {
[18:04:14.224]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.224]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.224]                       search = base::search(), system = base::Sys.info())
[18:04:14.224]                   }
[18:04:14.224]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.224]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.224]                     cond$call), session = sessionInformation(), 
[18:04:14.224]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.224]                   signalCondition(cond)
[18:04:14.224]                 }
[18:04:14.224]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.224]                 "immediateCondition"))) {
[18:04:14.224]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.224]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.224]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.224]                   if (TRUE && !signal) {
[18:04:14.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.224]                     {
[18:04:14.224]                       inherits <- base::inherits
[18:04:14.224]                       invokeRestart <- base::invokeRestart
[18:04:14.224]                       is.null <- base::is.null
[18:04:14.224]                       muffled <- FALSE
[18:04:14.224]                       if (inherits(cond, "message")) {
[18:04:14.224]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.224]                         if (muffled) 
[18:04:14.224]                           invokeRestart("muffleMessage")
[18:04:14.224]                       }
[18:04:14.224]                       else if (inherits(cond, "warning")) {
[18:04:14.224]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.224]                         if (muffled) 
[18:04:14.224]                           invokeRestart("muffleWarning")
[18:04:14.224]                       }
[18:04:14.224]                       else if (inherits(cond, "condition")) {
[18:04:14.224]                         if (!is.null(pattern)) {
[18:04:14.224]                           computeRestarts <- base::computeRestarts
[18:04:14.224]                           grepl <- base::grepl
[18:04:14.224]                           restarts <- computeRestarts(cond)
[18:04:14.224]                           for (restart in restarts) {
[18:04:14.224]                             name <- restart$name
[18:04:14.224]                             if (is.null(name)) 
[18:04:14.224]                               next
[18:04:14.224]                             if (!grepl(pattern, name)) 
[18:04:14.224]                               next
[18:04:14.224]                             invokeRestart(restart)
[18:04:14.224]                             muffled <- TRUE
[18:04:14.224]                             break
[18:04:14.224]                           }
[18:04:14.224]                         }
[18:04:14.224]                       }
[18:04:14.224]                       invisible(muffled)
[18:04:14.224]                     }
[18:04:14.224]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.224]                   }
[18:04:14.224]                 }
[18:04:14.224]                 else {
[18:04:14.224]                   if (TRUE) {
[18:04:14.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.224]                     {
[18:04:14.224]                       inherits <- base::inherits
[18:04:14.224]                       invokeRestart <- base::invokeRestart
[18:04:14.224]                       is.null <- base::is.null
[18:04:14.224]                       muffled <- FALSE
[18:04:14.224]                       if (inherits(cond, "message")) {
[18:04:14.224]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.224]                         if (muffled) 
[18:04:14.224]                           invokeRestart("muffleMessage")
[18:04:14.224]                       }
[18:04:14.224]                       else if (inherits(cond, "warning")) {
[18:04:14.224]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.224]                         if (muffled) 
[18:04:14.224]                           invokeRestart("muffleWarning")
[18:04:14.224]                       }
[18:04:14.224]                       else if (inherits(cond, "condition")) {
[18:04:14.224]                         if (!is.null(pattern)) {
[18:04:14.224]                           computeRestarts <- base::computeRestarts
[18:04:14.224]                           grepl <- base::grepl
[18:04:14.224]                           restarts <- computeRestarts(cond)
[18:04:14.224]                           for (restart in restarts) {
[18:04:14.224]                             name <- restart$name
[18:04:14.224]                             if (is.null(name)) 
[18:04:14.224]                               next
[18:04:14.224]                             if (!grepl(pattern, name)) 
[18:04:14.224]                               next
[18:04:14.224]                             invokeRestart(restart)
[18:04:14.224]                             muffled <- TRUE
[18:04:14.224]                             break
[18:04:14.224]                           }
[18:04:14.224]                         }
[18:04:14.224]                       }
[18:04:14.224]                       invisible(muffled)
[18:04:14.224]                     }
[18:04:14.224]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.224]                   }
[18:04:14.224]                 }
[18:04:14.224]             }
[18:04:14.224]         }))
[18:04:14.224]     }, error = function(ex) {
[18:04:14.224]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.224]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.224]                 ...future.rng), started = ...future.startTime, 
[18:04:14.224]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.224]             version = "1.8"), class = "FutureResult")
[18:04:14.224]     }, finally = {
[18:04:14.224]         if (!identical(...future.workdir, getwd())) 
[18:04:14.224]             setwd(...future.workdir)
[18:04:14.224]         {
[18:04:14.224]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.224]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.224]             }
[18:04:14.224]             base::options(...future.oldOptions)
[18:04:14.224]             if (.Platform$OS.type == "windows") {
[18:04:14.224]                 old_names <- names(...future.oldEnvVars)
[18:04:14.224]                 envs <- base::Sys.getenv()
[18:04:14.224]                 names <- names(envs)
[18:04:14.224]                 common <- intersect(names, old_names)
[18:04:14.224]                 added <- setdiff(names, old_names)
[18:04:14.224]                 removed <- setdiff(old_names, names)
[18:04:14.224]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.224]                   envs[common]]
[18:04:14.224]                 NAMES <- toupper(changed)
[18:04:14.224]                 args <- list()
[18:04:14.224]                 for (kk in seq_along(NAMES)) {
[18:04:14.224]                   name <- changed[[kk]]
[18:04:14.224]                   NAME <- NAMES[[kk]]
[18:04:14.224]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.224]                     next
[18:04:14.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.224]                 }
[18:04:14.224]                 NAMES <- toupper(added)
[18:04:14.224]                 for (kk in seq_along(NAMES)) {
[18:04:14.224]                   name <- added[[kk]]
[18:04:14.224]                   NAME <- NAMES[[kk]]
[18:04:14.224]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.224]                     next
[18:04:14.224]                   args[[name]] <- ""
[18:04:14.224]                 }
[18:04:14.224]                 NAMES <- toupper(removed)
[18:04:14.224]                 for (kk in seq_along(NAMES)) {
[18:04:14.224]                   name <- removed[[kk]]
[18:04:14.224]                   NAME <- NAMES[[kk]]
[18:04:14.224]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.224]                     next
[18:04:14.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.224]                 }
[18:04:14.224]                 if (length(args) > 0) 
[18:04:14.224]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.224]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.224]             }
[18:04:14.224]             else {
[18:04:14.224]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.224]             }
[18:04:14.224]             {
[18:04:14.224]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.224]                   0L) {
[18:04:14.224]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.224]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.224]                   base::options(opts)
[18:04:14.224]                 }
[18:04:14.224]                 {
[18:04:14.224]                   {
[18:04:14.224]                     NULL
[18:04:14.224]                     RNGkind("Mersenne-Twister")
[18:04:14.224]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.224]                       inherits = FALSE)
[18:04:14.224]                   }
[18:04:14.224]                   options(future.plan = NULL)
[18:04:14.224]                   if (is.na(NA_character_)) 
[18:04:14.224]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.224]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.224]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.224]                     .init = FALSE)
[18:04:14.224]                 }
[18:04:14.224]             }
[18:04:14.224]         }
[18:04:14.224]     })
[18:04:14.224]     if (TRUE) {
[18:04:14.224]         base::sink(type = "output", split = FALSE)
[18:04:14.224]         if (TRUE) {
[18:04:14.224]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.224]         }
[18:04:14.224]         else {
[18:04:14.224]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.224]         }
[18:04:14.224]         base::close(...future.stdout)
[18:04:14.224]         ...future.stdout <- NULL
[18:04:14.224]     }
[18:04:14.224]     ...future.result$conditions <- ...future.conditions
[18:04:14.224]     ...future.result$finished <- base::Sys.time()
[18:04:14.224]     ...future.result
[18:04:14.224] }
[18:04:14.228] plan(): Setting new future strategy stack:
[18:04:14.228] List of future strategies:
[18:04:14.228] 1. sequential:
[18:04:14.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.228]    - tweaked: FALSE
[18:04:14.228]    - call: NULL
[18:04:14.229] plan(): nbrOfWorkers() = 1
[18:04:14.231] plan(): Setting new future strategy stack:
[18:04:14.231] List of future strategies:
[18:04:14.231] 1. sequential:
[18:04:14.231]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.231]    - tweaked: FALSE
[18:04:14.231]    - call: plan(strategy)
[18:04:14.232] plan(): nbrOfWorkers() = 1
[18:04:14.233] SequentialFuture started (and completed)
[18:04:14.233] - Launch lazy future ... done
[18:04:14.233] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2aecb630> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b335550> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2aecb630> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b335550> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[18:04:14.246] resolved() for ‘SequentialFuture’ ...
[18:04:14.247] - state: ‘finished’
[18:04:14.247] - run: TRUE
[18:04:14.247] - result: ‘FutureResult’
[18:04:14.247] resolved() for ‘SequentialFuture’ ... done
[18:04:14.248] resolved() for ‘SequentialFuture’ ...
[18:04:14.248] - state: ‘finished’
[18:04:14.248] - run: TRUE
[18:04:14.248] - result: ‘FutureResult’
[18:04:14.248] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:14.252] resolve() on list ...
[18:04:14.252]  recursive: 0
[18:04:14.252]  length: 6
[18:04:14.252]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:14.253] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.253] - nx: 6
[18:04:14.253] - relay: TRUE
[18:04:14.253] - stdout: TRUE
[18:04:14.253] - signal: TRUE
[18:04:14.254] - resignal: FALSE
[18:04:14.254] - force: TRUE
[18:04:14.254] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.254] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.254]  - until=2
[18:04:14.255]  - relaying element #2
[18:04:14.255] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.255] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.255] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.255]  length: 5 (resolved future 1)
[18:04:14.256] resolved() for ‘SequentialFuture’ ...
[18:04:14.256] - state: ‘finished’
[18:04:14.256] - run: TRUE
[18:04:14.256] - result: ‘FutureResult’
[18:04:14.256] resolved() for ‘SequentialFuture’ ... done
[18:04:14.257] Future #2
[18:04:14.257] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.257] - nx: 6
[18:04:14.257] - relay: TRUE
[18:04:14.258] - stdout: TRUE
[18:04:14.258] - signal: TRUE
[18:04:14.258] - resignal: FALSE
[18:04:14.258] - force: TRUE
[18:04:14.258] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.258] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.259]  - until=2
[18:04:14.259]  - relaying element #2
[18:04:14.259] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.259] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.260] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.260]  length: 4 (resolved future 2)
[18:04:14.260] resolved() for ‘SequentialFuture’ ...
[18:04:14.260] - state: ‘finished’
[18:04:14.261] - run: TRUE
[18:04:14.261] - result: ‘FutureResult’
[18:04:14.261] resolved() for ‘SequentialFuture’ ... done
[18:04:14.261] Future #3
[18:04:14.261] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.262] - nx: 6
[18:04:14.262] - relay: TRUE
[18:04:14.262] - stdout: TRUE
[18:04:14.262] - signal: TRUE
[18:04:14.262] - resignal: FALSE
[18:04:14.263] - force: TRUE
[18:04:14.263] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.263] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.263]  - until=3
[18:04:14.263]  - relaying element #3
[18:04:14.264] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.264] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.264] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.264]  length: 3 (resolved future 3)
[18:04:14.265] signalConditionsASAP(NULL, pos=4) ...
[18:04:14.265] - nx: 6
[18:04:14.265] - relay: TRUE
[18:04:14.265] - stdout: TRUE
[18:04:14.265] - signal: TRUE
[18:04:14.265] - resignal: FALSE
[18:04:14.266] - force: TRUE
[18:04:14.266] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.266] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.266]  - until=5
[18:04:14.266]  - relaying element #5
[18:04:14.267] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.267] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.267] signalConditionsASAP(NULL, pos=4) ... done
[18:04:14.267]  length: 2 (resolved future 4)
[18:04:14.267] signalConditionsASAP(NULL, pos=5) ...
[18:04:14.268] - nx: 6
[18:04:14.268] - relay: TRUE
[18:04:14.268] - stdout: TRUE
[18:04:14.268] - signal: TRUE
[18:04:14.268] - resignal: FALSE
[18:04:14.268] - force: TRUE
[18:04:14.269] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.269] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.269]  - until=6
[18:04:14.269]  - relaying element #6
[18:04:14.269] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.270] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.270] signalConditionsASAP(NULL, pos=5) ... done
[18:04:14.270]  length: 1 (resolved future 5)
[18:04:14.270] signalConditionsASAP(numeric, pos=6) ...
[18:04:14.270] - nx: 6
[18:04:14.271] - relay: TRUE
[18:04:14.271] - stdout: TRUE
[18:04:14.271] - signal: TRUE
[18:04:14.271] - resignal: FALSE
[18:04:14.271] - force: TRUE
[18:04:14.271] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.272] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.272]  - until=6
[18:04:14.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.272] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.272] signalConditionsASAP(numeric, pos=6) ... done
[18:04:14.273]  length: 0 (resolved future 6)
[18:04:14.273] Relaying remaining futures
[18:04:14.273] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.273] - nx: 6
[18:04:14.273] - relay: TRUE
[18:04:14.274] - stdout: TRUE
[18:04:14.274] - signal: TRUE
[18:04:14.274] - resignal: FALSE
[18:04:14.274] - force: TRUE
[18:04:14.274] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.274] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:14.275] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.275] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.275] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.275] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[18:04:14.282] getGlobalsAndPackages() ...
[18:04:14.283] Searching for globals...
[18:04:14.283] 
[18:04:14.283] Searching for globals ... DONE
[18:04:14.284] - globals: [0] <none>
[18:04:14.284] getGlobalsAndPackages() ... DONE
[18:04:14.284] run() for ‘Future’ ...
[18:04:14.285] - state: ‘created’
[18:04:14.285] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.285] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.286]   - Field: ‘label’
[18:04:14.286]   - Field: ‘local’
[18:04:14.286]   - Field: ‘owner’
[18:04:14.287]   - Field: ‘envir’
[18:04:14.287]   - Field: ‘packages’
[18:04:14.287]   - Field: ‘gc’
[18:04:14.287]   - Field: ‘conditions’
[18:04:14.287]   - Field: ‘expr’
[18:04:14.288]   - Field: ‘uuid’
[18:04:14.288]   - Field: ‘seed’
[18:04:14.288]   - Field: ‘version’
[18:04:14.288]   - Field: ‘result’
[18:04:14.288]   - Field: ‘asynchronous’
[18:04:14.289]   - Field: ‘calls’
[18:04:14.289]   - Field: ‘globals’
[18:04:14.289]   - Field: ‘stdout’
[18:04:14.289]   - Field: ‘earlySignal’
[18:04:14.289]   - Field: ‘lazy’
[18:04:14.290]   - Field: ‘state’
[18:04:14.290] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.290] - Launch lazy future ...
[18:04:14.290] Packages needed by the future expression (n = 0): <none>
[18:04:14.291] Packages needed by future strategies (n = 0): <none>
[18:04:14.292] {
[18:04:14.292]     {
[18:04:14.292]         {
[18:04:14.292]             ...future.startTime <- base::Sys.time()
[18:04:14.292]             {
[18:04:14.292]                 {
[18:04:14.292]                   {
[18:04:14.292]                     base::local({
[18:04:14.292]                       has_future <- base::requireNamespace("future", 
[18:04:14.292]                         quietly = TRUE)
[18:04:14.292]                       if (has_future) {
[18:04:14.292]                         ns <- base::getNamespace("future")
[18:04:14.292]                         version <- ns[[".package"]][["version"]]
[18:04:14.292]                         if (is.null(version)) 
[18:04:14.292]                           version <- utils::packageVersion("future")
[18:04:14.292]                       }
[18:04:14.292]                       else {
[18:04:14.292]                         version <- NULL
[18:04:14.292]                       }
[18:04:14.292]                       if (!has_future || version < "1.8.0") {
[18:04:14.292]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.292]                           "", base::R.version$version.string), 
[18:04:14.292]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.292]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.292]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.292]                             "release", "version")], collapse = " "), 
[18:04:14.292]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.292]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.292]                           info)
[18:04:14.292]                         info <- base::paste(info, collapse = "; ")
[18:04:14.292]                         if (!has_future) {
[18:04:14.292]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.292]                             info)
[18:04:14.292]                         }
[18:04:14.292]                         else {
[18:04:14.292]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.292]                             info, version)
[18:04:14.292]                         }
[18:04:14.292]                         base::stop(msg)
[18:04:14.292]                       }
[18:04:14.292]                     })
[18:04:14.292]                   }
[18:04:14.292]                   ...future.strategy.old <- future::plan("list")
[18:04:14.292]                   options(future.plan = NULL)
[18:04:14.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.292]                 }
[18:04:14.292]                 ...future.workdir <- getwd()
[18:04:14.292]             }
[18:04:14.292]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.292]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.292]         }
[18:04:14.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.292]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.292]             base::names(...future.oldOptions))
[18:04:14.292]     }
[18:04:14.292]     if (FALSE) {
[18:04:14.292]     }
[18:04:14.292]     else {
[18:04:14.292]         if (TRUE) {
[18:04:14.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.292]                 open = "w")
[18:04:14.292]         }
[18:04:14.292]         else {
[18:04:14.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.292]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.292]         }
[18:04:14.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.292]             base::sink(type = "output", split = FALSE)
[18:04:14.292]             base::close(...future.stdout)
[18:04:14.292]         }, add = TRUE)
[18:04:14.292]     }
[18:04:14.292]     ...future.frame <- base::sys.nframe()
[18:04:14.292]     ...future.conditions <- base::list()
[18:04:14.292]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.292]     if (FALSE) {
[18:04:14.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.292]     }
[18:04:14.292]     ...future.result <- base::tryCatch({
[18:04:14.292]         base::withCallingHandlers({
[18:04:14.292]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.292]             future::FutureResult(value = ...future.value$value, 
[18:04:14.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.292]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.292]                     ...future.globalenv.names))
[18:04:14.292]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.292]         }, condition = base::local({
[18:04:14.292]             c <- base::c
[18:04:14.292]             inherits <- base::inherits
[18:04:14.292]             invokeRestart <- base::invokeRestart
[18:04:14.292]             length <- base::length
[18:04:14.292]             list <- base::list
[18:04:14.292]             seq.int <- base::seq.int
[18:04:14.292]             signalCondition <- base::signalCondition
[18:04:14.292]             sys.calls <- base::sys.calls
[18:04:14.292]             `[[` <- base::`[[`
[18:04:14.292]             `+` <- base::`+`
[18:04:14.292]             `<<-` <- base::`<<-`
[18:04:14.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.292]                   3L)]
[18:04:14.292]             }
[18:04:14.292]             function(cond) {
[18:04:14.292]                 is_error <- inherits(cond, "error")
[18:04:14.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.292]                   NULL)
[18:04:14.292]                 if (is_error) {
[18:04:14.292]                   sessionInformation <- function() {
[18:04:14.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.292]                       search = base::search(), system = base::Sys.info())
[18:04:14.292]                   }
[18:04:14.292]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.292]                     cond$call), session = sessionInformation(), 
[18:04:14.292]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.292]                   signalCondition(cond)
[18:04:14.292]                 }
[18:04:14.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.292]                 "immediateCondition"))) {
[18:04:14.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.292]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.292]                   if (TRUE && !signal) {
[18:04:14.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.292]                     {
[18:04:14.292]                       inherits <- base::inherits
[18:04:14.292]                       invokeRestart <- base::invokeRestart
[18:04:14.292]                       is.null <- base::is.null
[18:04:14.292]                       muffled <- FALSE
[18:04:14.292]                       if (inherits(cond, "message")) {
[18:04:14.292]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.292]                         if (muffled) 
[18:04:14.292]                           invokeRestart("muffleMessage")
[18:04:14.292]                       }
[18:04:14.292]                       else if (inherits(cond, "warning")) {
[18:04:14.292]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.292]                         if (muffled) 
[18:04:14.292]                           invokeRestart("muffleWarning")
[18:04:14.292]                       }
[18:04:14.292]                       else if (inherits(cond, "condition")) {
[18:04:14.292]                         if (!is.null(pattern)) {
[18:04:14.292]                           computeRestarts <- base::computeRestarts
[18:04:14.292]                           grepl <- base::grepl
[18:04:14.292]                           restarts <- computeRestarts(cond)
[18:04:14.292]                           for (restart in restarts) {
[18:04:14.292]                             name <- restart$name
[18:04:14.292]                             if (is.null(name)) 
[18:04:14.292]                               next
[18:04:14.292]                             if (!grepl(pattern, name)) 
[18:04:14.292]                               next
[18:04:14.292]                             invokeRestart(restart)
[18:04:14.292]                             muffled <- TRUE
[18:04:14.292]                             break
[18:04:14.292]                           }
[18:04:14.292]                         }
[18:04:14.292]                       }
[18:04:14.292]                       invisible(muffled)
[18:04:14.292]                     }
[18:04:14.292]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.292]                   }
[18:04:14.292]                 }
[18:04:14.292]                 else {
[18:04:14.292]                   if (TRUE) {
[18:04:14.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.292]                     {
[18:04:14.292]                       inherits <- base::inherits
[18:04:14.292]                       invokeRestart <- base::invokeRestart
[18:04:14.292]                       is.null <- base::is.null
[18:04:14.292]                       muffled <- FALSE
[18:04:14.292]                       if (inherits(cond, "message")) {
[18:04:14.292]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.292]                         if (muffled) 
[18:04:14.292]                           invokeRestart("muffleMessage")
[18:04:14.292]                       }
[18:04:14.292]                       else if (inherits(cond, "warning")) {
[18:04:14.292]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.292]                         if (muffled) 
[18:04:14.292]                           invokeRestart("muffleWarning")
[18:04:14.292]                       }
[18:04:14.292]                       else if (inherits(cond, "condition")) {
[18:04:14.292]                         if (!is.null(pattern)) {
[18:04:14.292]                           computeRestarts <- base::computeRestarts
[18:04:14.292]                           grepl <- base::grepl
[18:04:14.292]                           restarts <- computeRestarts(cond)
[18:04:14.292]                           for (restart in restarts) {
[18:04:14.292]                             name <- restart$name
[18:04:14.292]                             if (is.null(name)) 
[18:04:14.292]                               next
[18:04:14.292]                             if (!grepl(pattern, name)) 
[18:04:14.292]                               next
[18:04:14.292]                             invokeRestart(restart)
[18:04:14.292]                             muffled <- TRUE
[18:04:14.292]                             break
[18:04:14.292]                           }
[18:04:14.292]                         }
[18:04:14.292]                       }
[18:04:14.292]                       invisible(muffled)
[18:04:14.292]                     }
[18:04:14.292]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.292]                   }
[18:04:14.292]                 }
[18:04:14.292]             }
[18:04:14.292]         }))
[18:04:14.292]     }, error = function(ex) {
[18:04:14.292]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.292]                 ...future.rng), started = ...future.startTime, 
[18:04:14.292]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.292]             version = "1.8"), class = "FutureResult")
[18:04:14.292]     }, finally = {
[18:04:14.292]         if (!identical(...future.workdir, getwd())) 
[18:04:14.292]             setwd(...future.workdir)
[18:04:14.292]         {
[18:04:14.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.292]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.292]             }
[18:04:14.292]             base::options(...future.oldOptions)
[18:04:14.292]             if (.Platform$OS.type == "windows") {
[18:04:14.292]                 old_names <- names(...future.oldEnvVars)
[18:04:14.292]                 envs <- base::Sys.getenv()
[18:04:14.292]                 names <- names(envs)
[18:04:14.292]                 common <- intersect(names, old_names)
[18:04:14.292]                 added <- setdiff(names, old_names)
[18:04:14.292]                 removed <- setdiff(old_names, names)
[18:04:14.292]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.292]                   envs[common]]
[18:04:14.292]                 NAMES <- toupper(changed)
[18:04:14.292]                 args <- list()
[18:04:14.292]                 for (kk in seq_along(NAMES)) {
[18:04:14.292]                   name <- changed[[kk]]
[18:04:14.292]                   NAME <- NAMES[[kk]]
[18:04:14.292]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.292]                     next
[18:04:14.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.292]                 }
[18:04:14.292]                 NAMES <- toupper(added)
[18:04:14.292]                 for (kk in seq_along(NAMES)) {
[18:04:14.292]                   name <- added[[kk]]
[18:04:14.292]                   NAME <- NAMES[[kk]]
[18:04:14.292]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.292]                     next
[18:04:14.292]                   args[[name]] <- ""
[18:04:14.292]                 }
[18:04:14.292]                 NAMES <- toupper(removed)
[18:04:14.292]                 for (kk in seq_along(NAMES)) {
[18:04:14.292]                   name <- removed[[kk]]
[18:04:14.292]                   NAME <- NAMES[[kk]]
[18:04:14.292]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.292]                     next
[18:04:14.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.292]                 }
[18:04:14.292]                 if (length(args) > 0) 
[18:04:14.292]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.292]             }
[18:04:14.292]             else {
[18:04:14.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.292]             }
[18:04:14.292]             {
[18:04:14.292]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.292]                   0L) {
[18:04:14.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.292]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.292]                   base::options(opts)
[18:04:14.292]                 }
[18:04:14.292]                 {
[18:04:14.292]                   {
[18:04:14.292]                     NULL
[18:04:14.292]                     RNGkind("Mersenne-Twister")
[18:04:14.292]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.292]                       inherits = FALSE)
[18:04:14.292]                   }
[18:04:14.292]                   options(future.plan = NULL)
[18:04:14.292]                   if (is.na(NA_character_)) 
[18:04:14.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.292]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.292]                     .init = FALSE)
[18:04:14.292]                 }
[18:04:14.292]             }
[18:04:14.292]         }
[18:04:14.292]     })
[18:04:14.292]     if (TRUE) {
[18:04:14.292]         base::sink(type = "output", split = FALSE)
[18:04:14.292]         if (TRUE) {
[18:04:14.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.292]         }
[18:04:14.292]         else {
[18:04:14.292]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.292]         }
[18:04:14.292]         base::close(...future.stdout)
[18:04:14.292]         ...future.stdout <- NULL
[18:04:14.292]     }
[18:04:14.292]     ...future.result$conditions <- ...future.conditions
[18:04:14.292]     ...future.result$finished <- base::Sys.time()
[18:04:14.292]     ...future.result
[18:04:14.292] }
[18:04:14.295] plan(): Setting new future strategy stack:
[18:04:14.295] List of future strategies:
[18:04:14.295] 1. sequential:
[18:04:14.295]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.295]    - tweaked: FALSE
[18:04:14.295]    - call: NULL
[18:04:14.296] plan(): nbrOfWorkers() = 1
[18:04:14.298] plan(): Setting new future strategy stack:
[18:04:14.298] List of future strategies:
[18:04:14.298] 1. sequential:
[18:04:14.298]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.298]    - tweaked: FALSE
[18:04:14.298]    - call: plan(strategy)
[18:04:14.299] plan(): nbrOfWorkers() = 1
[18:04:14.300] SequentialFuture started (and completed)
[18:04:14.300] - Launch lazy future ... done
[18:04:14.300] run() for ‘SequentialFuture’ ... done
[18:04:14.301] getGlobalsAndPackages() ...
[18:04:14.301] Searching for globals...
[18:04:14.301] 
[18:04:14.302] Searching for globals ... DONE
[18:04:14.302] - globals: [0] <none>
[18:04:14.304] getGlobalsAndPackages() ... DONE
[18:04:14.305] run() for ‘Future’ ...
[18:04:14.305] - state: ‘created’
[18:04:14.306] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.306] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.307]   - Field: ‘label’
[18:04:14.307]   - Field: ‘local’
[18:04:14.307]   - Field: ‘owner’
[18:04:14.307]   - Field: ‘envir’
[18:04:14.308]   - Field: ‘packages’
[18:04:14.308]   - Field: ‘gc’
[18:04:14.308]   - Field: ‘conditions’
[18:04:14.308]   - Field: ‘expr’
[18:04:14.308]   - Field: ‘uuid’
[18:04:14.309]   - Field: ‘seed’
[18:04:14.309]   - Field: ‘version’
[18:04:14.309]   - Field: ‘result’
[18:04:14.309]   - Field: ‘asynchronous’
[18:04:14.309]   - Field: ‘calls’
[18:04:14.310]   - Field: ‘globals’
[18:04:14.310]   - Field: ‘stdout’
[18:04:14.310]   - Field: ‘earlySignal’
[18:04:14.310]   - Field: ‘lazy’
[18:04:14.310]   - Field: ‘state’
[18:04:14.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.311] - Launch lazy future ...
[18:04:14.311] Packages needed by the future expression (n = 0): <none>
[18:04:14.311] Packages needed by future strategies (n = 0): <none>
[18:04:14.312] {
[18:04:14.312]     {
[18:04:14.312]         {
[18:04:14.312]             ...future.startTime <- base::Sys.time()
[18:04:14.312]             {
[18:04:14.312]                 {
[18:04:14.312]                   {
[18:04:14.312]                     base::local({
[18:04:14.312]                       has_future <- base::requireNamespace("future", 
[18:04:14.312]                         quietly = TRUE)
[18:04:14.312]                       if (has_future) {
[18:04:14.312]                         ns <- base::getNamespace("future")
[18:04:14.312]                         version <- ns[[".package"]][["version"]]
[18:04:14.312]                         if (is.null(version)) 
[18:04:14.312]                           version <- utils::packageVersion("future")
[18:04:14.312]                       }
[18:04:14.312]                       else {
[18:04:14.312]                         version <- NULL
[18:04:14.312]                       }
[18:04:14.312]                       if (!has_future || version < "1.8.0") {
[18:04:14.312]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.312]                           "", base::R.version$version.string), 
[18:04:14.312]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.312]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.312]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.312]                             "release", "version")], collapse = " "), 
[18:04:14.312]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.312]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.312]                           info)
[18:04:14.312]                         info <- base::paste(info, collapse = "; ")
[18:04:14.312]                         if (!has_future) {
[18:04:14.312]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.312]                             info)
[18:04:14.312]                         }
[18:04:14.312]                         else {
[18:04:14.312]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.312]                             info, version)
[18:04:14.312]                         }
[18:04:14.312]                         base::stop(msg)
[18:04:14.312]                       }
[18:04:14.312]                     })
[18:04:14.312]                   }
[18:04:14.312]                   ...future.strategy.old <- future::plan("list")
[18:04:14.312]                   options(future.plan = NULL)
[18:04:14.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.312]                 }
[18:04:14.312]                 ...future.workdir <- getwd()
[18:04:14.312]             }
[18:04:14.312]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.312]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.312]         }
[18:04:14.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.312]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.312]             base::names(...future.oldOptions))
[18:04:14.312]     }
[18:04:14.312]     if (FALSE) {
[18:04:14.312]     }
[18:04:14.312]     else {
[18:04:14.312]         if (TRUE) {
[18:04:14.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.312]                 open = "w")
[18:04:14.312]         }
[18:04:14.312]         else {
[18:04:14.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.312]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.312]         }
[18:04:14.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.312]             base::sink(type = "output", split = FALSE)
[18:04:14.312]             base::close(...future.stdout)
[18:04:14.312]         }, add = TRUE)
[18:04:14.312]     }
[18:04:14.312]     ...future.frame <- base::sys.nframe()
[18:04:14.312]     ...future.conditions <- base::list()
[18:04:14.312]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.312]     if (FALSE) {
[18:04:14.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.312]     }
[18:04:14.312]     ...future.result <- base::tryCatch({
[18:04:14.312]         base::withCallingHandlers({
[18:04:14.312]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.312]             future::FutureResult(value = ...future.value$value, 
[18:04:14.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.312]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.312]                     ...future.globalenv.names))
[18:04:14.312]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.312]         }, condition = base::local({
[18:04:14.312]             c <- base::c
[18:04:14.312]             inherits <- base::inherits
[18:04:14.312]             invokeRestart <- base::invokeRestart
[18:04:14.312]             length <- base::length
[18:04:14.312]             list <- base::list
[18:04:14.312]             seq.int <- base::seq.int
[18:04:14.312]             signalCondition <- base::signalCondition
[18:04:14.312]             sys.calls <- base::sys.calls
[18:04:14.312]             `[[` <- base::`[[`
[18:04:14.312]             `+` <- base::`+`
[18:04:14.312]             `<<-` <- base::`<<-`
[18:04:14.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.312]                   3L)]
[18:04:14.312]             }
[18:04:14.312]             function(cond) {
[18:04:14.312]                 is_error <- inherits(cond, "error")
[18:04:14.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.312]                   NULL)
[18:04:14.312]                 if (is_error) {
[18:04:14.312]                   sessionInformation <- function() {
[18:04:14.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.312]                       search = base::search(), system = base::Sys.info())
[18:04:14.312]                   }
[18:04:14.312]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.312]                     cond$call), session = sessionInformation(), 
[18:04:14.312]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.312]                   signalCondition(cond)
[18:04:14.312]                 }
[18:04:14.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.312]                 "immediateCondition"))) {
[18:04:14.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.312]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.312]                   if (TRUE && !signal) {
[18:04:14.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.312]                     {
[18:04:14.312]                       inherits <- base::inherits
[18:04:14.312]                       invokeRestart <- base::invokeRestart
[18:04:14.312]                       is.null <- base::is.null
[18:04:14.312]                       muffled <- FALSE
[18:04:14.312]                       if (inherits(cond, "message")) {
[18:04:14.312]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.312]                         if (muffled) 
[18:04:14.312]                           invokeRestart("muffleMessage")
[18:04:14.312]                       }
[18:04:14.312]                       else if (inherits(cond, "warning")) {
[18:04:14.312]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.312]                         if (muffled) 
[18:04:14.312]                           invokeRestart("muffleWarning")
[18:04:14.312]                       }
[18:04:14.312]                       else if (inherits(cond, "condition")) {
[18:04:14.312]                         if (!is.null(pattern)) {
[18:04:14.312]                           computeRestarts <- base::computeRestarts
[18:04:14.312]                           grepl <- base::grepl
[18:04:14.312]                           restarts <- computeRestarts(cond)
[18:04:14.312]                           for (restart in restarts) {
[18:04:14.312]                             name <- restart$name
[18:04:14.312]                             if (is.null(name)) 
[18:04:14.312]                               next
[18:04:14.312]                             if (!grepl(pattern, name)) 
[18:04:14.312]                               next
[18:04:14.312]                             invokeRestart(restart)
[18:04:14.312]                             muffled <- TRUE
[18:04:14.312]                             break
[18:04:14.312]                           }
[18:04:14.312]                         }
[18:04:14.312]                       }
[18:04:14.312]                       invisible(muffled)
[18:04:14.312]                     }
[18:04:14.312]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.312]                   }
[18:04:14.312]                 }
[18:04:14.312]                 else {
[18:04:14.312]                   if (TRUE) {
[18:04:14.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.312]                     {
[18:04:14.312]                       inherits <- base::inherits
[18:04:14.312]                       invokeRestart <- base::invokeRestart
[18:04:14.312]                       is.null <- base::is.null
[18:04:14.312]                       muffled <- FALSE
[18:04:14.312]                       if (inherits(cond, "message")) {
[18:04:14.312]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.312]                         if (muffled) 
[18:04:14.312]                           invokeRestart("muffleMessage")
[18:04:14.312]                       }
[18:04:14.312]                       else if (inherits(cond, "warning")) {
[18:04:14.312]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.312]                         if (muffled) 
[18:04:14.312]                           invokeRestart("muffleWarning")
[18:04:14.312]                       }
[18:04:14.312]                       else if (inherits(cond, "condition")) {
[18:04:14.312]                         if (!is.null(pattern)) {
[18:04:14.312]                           computeRestarts <- base::computeRestarts
[18:04:14.312]                           grepl <- base::grepl
[18:04:14.312]                           restarts <- computeRestarts(cond)
[18:04:14.312]                           for (restart in restarts) {
[18:04:14.312]                             name <- restart$name
[18:04:14.312]                             if (is.null(name)) 
[18:04:14.312]                               next
[18:04:14.312]                             if (!grepl(pattern, name)) 
[18:04:14.312]                               next
[18:04:14.312]                             invokeRestart(restart)
[18:04:14.312]                             muffled <- TRUE
[18:04:14.312]                             break
[18:04:14.312]                           }
[18:04:14.312]                         }
[18:04:14.312]                       }
[18:04:14.312]                       invisible(muffled)
[18:04:14.312]                     }
[18:04:14.312]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.312]                   }
[18:04:14.312]                 }
[18:04:14.312]             }
[18:04:14.312]         }))
[18:04:14.312]     }, error = function(ex) {
[18:04:14.312]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.312]                 ...future.rng), started = ...future.startTime, 
[18:04:14.312]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.312]             version = "1.8"), class = "FutureResult")
[18:04:14.312]     }, finally = {
[18:04:14.312]         if (!identical(...future.workdir, getwd())) 
[18:04:14.312]             setwd(...future.workdir)
[18:04:14.312]         {
[18:04:14.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.312]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.312]             }
[18:04:14.312]             base::options(...future.oldOptions)
[18:04:14.312]             if (.Platform$OS.type == "windows") {
[18:04:14.312]                 old_names <- names(...future.oldEnvVars)
[18:04:14.312]                 envs <- base::Sys.getenv()
[18:04:14.312]                 names <- names(envs)
[18:04:14.312]                 common <- intersect(names, old_names)
[18:04:14.312]                 added <- setdiff(names, old_names)
[18:04:14.312]                 removed <- setdiff(old_names, names)
[18:04:14.312]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.312]                   envs[common]]
[18:04:14.312]                 NAMES <- toupper(changed)
[18:04:14.312]                 args <- list()
[18:04:14.312]                 for (kk in seq_along(NAMES)) {
[18:04:14.312]                   name <- changed[[kk]]
[18:04:14.312]                   NAME <- NAMES[[kk]]
[18:04:14.312]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.312]                     next
[18:04:14.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.312]                 }
[18:04:14.312]                 NAMES <- toupper(added)
[18:04:14.312]                 for (kk in seq_along(NAMES)) {
[18:04:14.312]                   name <- added[[kk]]
[18:04:14.312]                   NAME <- NAMES[[kk]]
[18:04:14.312]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.312]                     next
[18:04:14.312]                   args[[name]] <- ""
[18:04:14.312]                 }
[18:04:14.312]                 NAMES <- toupper(removed)
[18:04:14.312]                 for (kk in seq_along(NAMES)) {
[18:04:14.312]                   name <- removed[[kk]]
[18:04:14.312]                   NAME <- NAMES[[kk]]
[18:04:14.312]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.312]                     next
[18:04:14.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.312]                 }
[18:04:14.312]                 if (length(args) > 0) 
[18:04:14.312]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.312]             }
[18:04:14.312]             else {
[18:04:14.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.312]             }
[18:04:14.312]             {
[18:04:14.312]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.312]                   0L) {
[18:04:14.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.312]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.312]                   base::options(opts)
[18:04:14.312]                 }
[18:04:14.312]                 {
[18:04:14.312]                   {
[18:04:14.312]                     NULL
[18:04:14.312]                     RNGkind("Mersenne-Twister")
[18:04:14.312]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.312]                       inherits = FALSE)
[18:04:14.312]                   }
[18:04:14.312]                   options(future.plan = NULL)
[18:04:14.312]                   if (is.na(NA_character_)) 
[18:04:14.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.312]                     .init = FALSE)
[18:04:14.312]                 }
[18:04:14.312]             }
[18:04:14.312]         }
[18:04:14.312]     })
[18:04:14.312]     if (TRUE) {
[18:04:14.312]         base::sink(type = "output", split = FALSE)
[18:04:14.312]         if (TRUE) {
[18:04:14.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.312]         }
[18:04:14.312]         else {
[18:04:14.312]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.312]         }
[18:04:14.312]         base::close(...future.stdout)
[18:04:14.312]         ...future.stdout <- NULL
[18:04:14.312]     }
[18:04:14.312]     ...future.result$conditions <- ...future.conditions
[18:04:14.312]     ...future.result$finished <- base::Sys.time()
[18:04:14.312]     ...future.result
[18:04:14.312] }
[18:04:14.316] plan(): Setting new future strategy stack:
[18:04:14.316] List of future strategies:
[18:04:14.316] 1. sequential:
[18:04:14.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.316]    - tweaked: FALSE
[18:04:14.316]    - call: NULL
[18:04:14.318] plan(): nbrOfWorkers() = 1
[18:04:14.319] plan(): Setting new future strategy stack:
[18:04:14.320] List of future strategies:
[18:04:14.320] 1. sequential:
[18:04:14.320]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.320]    - tweaked: FALSE
[18:04:14.320]    - call: plan(strategy)
[18:04:14.321] plan(): nbrOfWorkers() = 1
[18:04:14.321] SequentialFuture started (and completed)
[18:04:14.321] - Launch lazy future ... done
[18:04:14.322] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b41b4b8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2a56d3f8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b41b4b8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2a56d3f8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[18:04:14.333] resolved() for ‘SequentialFuture’ ...
[18:04:14.333] - state: ‘finished’
[18:04:14.333] - run: TRUE
[18:04:14.334] - result: ‘FutureResult’
[18:04:14.334] resolved() for ‘SequentialFuture’ ... done
[18:04:14.334] resolved() for ‘SequentialFuture’ ...
[18:04:14.334] - state: ‘finished’
[18:04:14.334] - run: TRUE
[18:04:14.335] - result: ‘FutureResult’
[18:04:14.335] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:14.339] resolve() on list ...
[18:04:14.339]  recursive: 0
[18:04:14.339]  length: 6
[18:04:14.339]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:14.340] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.340] - nx: 6
[18:04:14.342] - relay: TRUE
[18:04:14.342] - stdout: TRUE
[18:04:14.342] - signal: TRUE
[18:04:14.342] - resignal: FALSE
[18:04:14.342] - force: TRUE
[18:04:14.343] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.343] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.343]  - until=2
[18:04:14.343]  - relaying element #2
[18:04:14.343] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.344] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.344] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.344]  length: 5 (resolved future 1)
[18:04:14.345] resolved() for ‘SequentialFuture’ ...
[18:04:14.345] - state: ‘finished’
[18:04:14.345] - run: TRUE
[18:04:14.345] - result: ‘FutureResult’
[18:04:14.346] resolved() for ‘SequentialFuture’ ... done
[18:04:14.347] Future #2
[18:04:14.347] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.347] - nx: 6
[18:04:14.347] - relay: TRUE
[18:04:14.348] - stdout: TRUE
[18:04:14.348] - signal: TRUE
[18:04:14.348] - resignal: FALSE
[18:04:14.348] - force: TRUE
[18:04:14.348] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.348] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.349]  - until=2
[18:04:14.349]  - relaying element #2
[18:04:14.349] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.350] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.350] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.350]  length: 4 (resolved future 2)
[18:04:14.350] resolved() for ‘SequentialFuture’ ...
[18:04:14.351] - state: ‘finished’
[18:04:14.351] - run: TRUE
[18:04:14.351] - result: ‘FutureResult’
[18:04:14.351] resolved() for ‘SequentialFuture’ ... done
[18:04:14.351] Future #3
[18:04:14.352] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.352] - nx: 6
[18:04:14.352] - relay: TRUE
[18:04:14.353] - stdout: TRUE
[18:04:14.353] - signal: TRUE
[18:04:14.353] - resignal: FALSE
[18:04:14.353] - force: TRUE
[18:04:14.353] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.353] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.354]  - until=3
[18:04:14.354]  - relaying element #3
[18:04:14.354] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.355] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.355] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.355]  length: 3 (resolved future 3)
[18:04:14.355] signalConditionsASAP(NULL, pos=4) ...
[18:04:14.355] - nx: 6
[18:04:14.356] - relay: TRUE
[18:04:14.356] - stdout: TRUE
[18:04:14.356] - signal: TRUE
[18:04:14.356] - resignal: FALSE
[18:04:14.356] - force: TRUE
[18:04:14.356] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.357] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.357]  - until=5
[18:04:14.357]  - relaying element #5
[18:04:14.357] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.357] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.358] signalConditionsASAP(NULL, pos=4) ... done
[18:04:14.358]  length: 2 (resolved future 4)
[18:04:14.358] signalConditionsASAP(NULL, pos=5) ...
[18:04:14.358] - nx: 6
[18:04:14.358] - relay: TRUE
[18:04:14.359] - stdout: TRUE
[18:04:14.359] - signal: TRUE
[18:04:14.359] - resignal: FALSE
[18:04:14.359] - force: TRUE
[18:04:14.359] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.359] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.360]  - until=6
[18:04:14.360]  - relaying element #6
[18:04:14.360] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.360] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.360] signalConditionsASAP(NULL, pos=5) ... done
[18:04:14.361]  length: 1 (resolved future 5)
[18:04:14.361] signalConditionsASAP(numeric, pos=6) ...
[18:04:14.361] - nx: 6
[18:04:14.361] - relay: TRUE
[18:04:14.361] - stdout: TRUE
[18:04:14.362] - signal: TRUE
[18:04:14.362] - resignal: FALSE
[18:04:14.362] - force: TRUE
[18:04:14.362] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.362] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.363]  - until=6
[18:04:14.363] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.363] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.363] signalConditionsASAP(numeric, pos=6) ... done
[18:04:14.363]  length: 0 (resolved future 6)
[18:04:14.363] Relaying remaining futures
[18:04:14.364] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.364] - nx: 6
[18:04:14.364] - relay: TRUE
[18:04:14.364] - stdout: TRUE
[18:04:14.364] - signal: TRUE
[18:04:14.365] - resignal: FALSE
[18:04:14.365] - force: TRUE
[18:04:14.365] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.365] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:14.365] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.366] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.366] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.366] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[18:04:14.381] getGlobalsAndPackages() ...
[18:04:14.381] Searching for globals...
[18:04:14.382] 
[18:04:14.382] Searching for globals ... DONE
[18:04:14.382] - globals: [0] <none>
[18:04:14.382] getGlobalsAndPackages() ... DONE
[18:04:14.383] run() for ‘Future’ ...
[18:04:14.383] - state: ‘created’
[18:04:14.383] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.384] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.384]   - Field: ‘label’
[18:04:14.384]   - Field: ‘local’
[18:04:14.385]   - Field: ‘owner’
[18:04:14.385]   - Field: ‘envir’
[18:04:14.385]   - Field: ‘packages’
[18:04:14.385]   - Field: ‘gc’
[18:04:14.385]   - Field: ‘conditions’
[18:04:14.386]   - Field: ‘expr’
[18:04:14.386]   - Field: ‘uuid’
[18:04:14.386]   - Field: ‘seed’
[18:04:14.386]   - Field: ‘version’
[18:04:14.386]   - Field: ‘result’
[18:04:14.387]   - Field: ‘asynchronous’
[18:04:14.387]   - Field: ‘calls’
[18:04:14.387]   - Field: ‘globals’
[18:04:14.387]   - Field: ‘stdout’
[18:04:14.387]   - Field: ‘earlySignal’
[18:04:14.388]   - Field: ‘lazy’
[18:04:14.388]   - Field: ‘state’
[18:04:14.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.388] - Launch lazy future ...
[18:04:14.389] Packages needed by the future expression (n = 0): <none>
[18:04:14.389] Packages needed by future strategies (n = 0): <none>
[18:04:14.390] {
[18:04:14.390]     {
[18:04:14.390]         {
[18:04:14.390]             ...future.startTime <- base::Sys.time()
[18:04:14.390]             {
[18:04:14.390]                 {
[18:04:14.390]                   {
[18:04:14.390]                     base::local({
[18:04:14.390]                       has_future <- base::requireNamespace("future", 
[18:04:14.390]                         quietly = TRUE)
[18:04:14.390]                       if (has_future) {
[18:04:14.390]                         ns <- base::getNamespace("future")
[18:04:14.390]                         version <- ns[[".package"]][["version"]]
[18:04:14.390]                         if (is.null(version)) 
[18:04:14.390]                           version <- utils::packageVersion("future")
[18:04:14.390]                       }
[18:04:14.390]                       else {
[18:04:14.390]                         version <- NULL
[18:04:14.390]                       }
[18:04:14.390]                       if (!has_future || version < "1.8.0") {
[18:04:14.390]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.390]                           "", base::R.version$version.string), 
[18:04:14.390]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.390]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.390]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.390]                             "release", "version")], collapse = " "), 
[18:04:14.390]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.390]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.390]                           info)
[18:04:14.390]                         info <- base::paste(info, collapse = "; ")
[18:04:14.390]                         if (!has_future) {
[18:04:14.390]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.390]                             info)
[18:04:14.390]                         }
[18:04:14.390]                         else {
[18:04:14.390]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.390]                             info, version)
[18:04:14.390]                         }
[18:04:14.390]                         base::stop(msg)
[18:04:14.390]                       }
[18:04:14.390]                     })
[18:04:14.390]                   }
[18:04:14.390]                   ...future.strategy.old <- future::plan("list")
[18:04:14.390]                   options(future.plan = NULL)
[18:04:14.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.390]                 }
[18:04:14.390]                 ...future.workdir <- getwd()
[18:04:14.390]             }
[18:04:14.390]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.390]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.390]         }
[18:04:14.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.390]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.390]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.390]             base::names(...future.oldOptions))
[18:04:14.390]     }
[18:04:14.390]     if (FALSE) {
[18:04:14.390]     }
[18:04:14.390]     else {
[18:04:14.390]         if (TRUE) {
[18:04:14.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.390]                 open = "w")
[18:04:14.390]         }
[18:04:14.390]         else {
[18:04:14.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.390]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.390]         }
[18:04:14.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.390]             base::sink(type = "output", split = FALSE)
[18:04:14.390]             base::close(...future.stdout)
[18:04:14.390]         }, add = TRUE)
[18:04:14.390]     }
[18:04:14.390]     ...future.frame <- base::sys.nframe()
[18:04:14.390]     ...future.conditions <- base::list()
[18:04:14.390]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.390]     if (FALSE) {
[18:04:14.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.390]     }
[18:04:14.390]     ...future.result <- base::tryCatch({
[18:04:14.390]         base::withCallingHandlers({
[18:04:14.390]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.390]             future::FutureResult(value = ...future.value$value, 
[18:04:14.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.390]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.390]                     ...future.globalenv.names))
[18:04:14.390]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.390]         }, condition = base::local({
[18:04:14.390]             c <- base::c
[18:04:14.390]             inherits <- base::inherits
[18:04:14.390]             invokeRestart <- base::invokeRestart
[18:04:14.390]             length <- base::length
[18:04:14.390]             list <- base::list
[18:04:14.390]             seq.int <- base::seq.int
[18:04:14.390]             signalCondition <- base::signalCondition
[18:04:14.390]             sys.calls <- base::sys.calls
[18:04:14.390]             `[[` <- base::`[[`
[18:04:14.390]             `+` <- base::`+`
[18:04:14.390]             `<<-` <- base::`<<-`
[18:04:14.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.390]                   3L)]
[18:04:14.390]             }
[18:04:14.390]             function(cond) {
[18:04:14.390]                 is_error <- inherits(cond, "error")
[18:04:14.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.390]                   NULL)
[18:04:14.390]                 if (is_error) {
[18:04:14.390]                   sessionInformation <- function() {
[18:04:14.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.390]                       search = base::search(), system = base::Sys.info())
[18:04:14.390]                   }
[18:04:14.390]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.390]                     cond$call), session = sessionInformation(), 
[18:04:14.390]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.390]                   signalCondition(cond)
[18:04:14.390]                 }
[18:04:14.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.390]                 "immediateCondition"))) {
[18:04:14.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.390]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.390]                   if (TRUE && !signal) {
[18:04:14.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.390]                     {
[18:04:14.390]                       inherits <- base::inherits
[18:04:14.390]                       invokeRestart <- base::invokeRestart
[18:04:14.390]                       is.null <- base::is.null
[18:04:14.390]                       muffled <- FALSE
[18:04:14.390]                       if (inherits(cond, "message")) {
[18:04:14.390]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.390]                         if (muffled) 
[18:04:14.390]                           invokeRestart("muffleMessage")
[18:04:14.390]                       }
[18:04:14.390]                       else if (inherits(cond, "warning")) {
[18:04:14.390]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.390]                         if (muffled) 
[18:04:14.390]                           invokeRestart("muffleWarning")
[18:04:14.390]                       }
[18:04:14.390]                       else if (inherits(cond, "condition")) {
[18:04:14.390]                         if (!is.null(pattern)) {
[18:04:14.390]                           computeRestarts <- base::computeRestarts
[18:04:14.390]                           grepl <- base::grepl
[18:04:14.390]                           restarts <- computeRestarts(cond)
[18:04:14.390]                           for (restart in restarts) {
[18:04:14.390]                             name <- restart$name
[18:04:14.390]                             if (is.null(name)) 
[18:04:14.390]                               next
[18:04:14.390]                             if (!grepl(pattern, name)) 
[18:04:14.390]                               next
[18:04:14.390]                             invokeRestart(restart)
[18:04:14.390]                             muffled <- TRUE
[18:04:14.390]                             break
[18:04:14.390]                           }
[18:04:14.390]                         }
[18:04:14.390]                       }
[18:04:14.390]                       invisible(muffled)
[18:04:14.390]                     }
[18:04:14.390]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.390]                   }
[18:04:14.390]                 }
[18:04:14.390]                 else {
[18:04:14.390]                   if (TRUE) {
[18:04:14.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.390]                     {
[18:04:14.390]                       inherits <- base::inherits
[18:04:14.390]                       invokeRestart <- base::invokeRestart
[18:04:14.390]                       is.null <- base::is.null
[18:04:14.390]                       muffled <- FALSE
[18:04:14.390]                       if (inherits(cond, "message")) {
[18:04:14.390]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.390]                         if (muffled) 
[18:04:14.390]                           invokeRestart("muffleMessage")
[18:04:14.390]                       }
[18:04:14.390]                       else if (inherits(cond, "warning")) {
[18:04:14.390]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.390]                         if (muffled) 
[18:04:14.390]                           invokeRestart("muffleWarning")
[18:04:14.390]                       }
[18:04:14.390]                       else if (inherits(cond, "condition")) {
[18:04:14.390]                         if (!is.null(pattern)) {
[18:04:14.390]                           computeRestarts <- base::computeRestarts
[18:04:14.390]                           grepl <- base::grepl
[18:04:14.390]                           restarts <- computeRestarts(cond)
[18:04:14.390]                           for (restart in restarts) {
[18:04:14.390]                             name <- restart$name
[18:04:14.390]                             if (is.null(name)) 
[18:04:14.390]                               next
[18:04:14.390]                             if (!grepl(pattern, name)) 
[18:04:14.390]                               next
[18:04:14.390]                             invokeRestart(restart)
[18:04:14.390]                             muffled <- TRUE
[18:04:14.390]                             break
[18:04:14.390]                           }
[18:04:14.390]                         }
[18:04:14.390]                       }
[18:04:14.390]                       invisible(muffled)
[18:04:14.390]                     }
[18:04:14.390]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.390]                   }
[18:04:14.390]                 }
[18:04:14.390]             }
[18:04:14.390]         }))
[18:04:14.390]     }, error = function(ex) {
[18:04:14.390]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.390]                 ...future.rng), started = ...future.startTime, 
[18:04:14.390]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.390]             version = "1.8"), class = "FutureResult")
[18:04:14.390]     }, finally = {
[18:04:14.390]         if (!identical(...future.workdir, getwd())) 
[18:04:14.390]             setwd(...future.workdir)
[18:04:14.390]         {
[18:04:14.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.390]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.390]             }
[18:04:14.390]             base::options(...future.oldOptions)
[18:04:14.390]             if (.Platform$OS.type == "windows") {
[18:04:14.390]                 old_names <- names(...future.oldEnvVars)
[18:04:14.390]                 envs <- base::Sys.getenv()
[18:04:14.390]                 names <- names(envs)
[18:04:14.390]                 common <- intersect(names, old_names)
[18:04:14.390]                 added <- setdiff(names, old_names)
[18:04:14.390]                 removed <- setdiff(old_names, names)
[18:04:14.390]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.390]                   envs[common]]
[18:04:14.390]                 NAMES <- toupper(changed)
[18:04:14.390]                 args <- list()
[18:04:14.390]                 for (kk in seq_along(NAMES)) {
[18:04:14.390]                   name <- changed[[kk]]
[18:04:14.390]                   NAME <- NAMES[[kk]]
[18:04:14.390]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.390]                     next
[18:04:14.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.390]                 }
[18:04:14.390]                 NAMES <- toupper(added)
[18:04:14.390]                 for (kk in seq_along(NAMES)) {
[18:04:14.390]                   name <- added[[kk]]
[18:04:14.390]                   NAME <- NAMES[[kk]]
[18:04:14.390]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.390]                     next
[18:04:14.390]                   args[[name]] <- ""
[18:04:14.390]                 }
[18:04:14.390]                 NAMES <- toupper(removed)
[18:04:14.390]                 for (kk in seq_along(NAMES)) {
[18:04:14.390]                   name <- removed[[kk]]
[18:04:14.390]                   NAME <- NAMES[[kk]]
[18:04:14.390]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.390]                     next
[18:04:14.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.390]                 }
[18:04:14.390]                 if (length(args) > 0) 
[18:04:14.390]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.390]             }
[18:04:14.390]             else {
[18:04:14.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.390]             }
[18:04:14.390]             {
[18:04:14.390]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.390]                   0L) {
[18:04:14.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.390]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.390]                   base::options(opts)
[18:04:14.390]                 }
[18:04:14.390]                 {
[18:04:14.390]                   {
[18:04:14.390]                     NULL
[18:04:14.390]                     RNGkind("Mersenne-Twister")
[18:04:14.390]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.390]                       inherits = FALSE)
[18:04:14.390]                   }
[18:04:14.390]                   options(future.plan = NULL)
[18:04:14.390]                   if (is.na(NA_character_)) 
[18:04:14.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.390]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.390]                     .init = FALSE)
[18:04:14.390]                 }
[18:04:14.390]             }
[18:04:14.390]         }
[18:04:14.390]     })
[18:04:14.390]     if (TRUE) {
[18:04:14.390]         base::sink(type = "output", split = FALSE)
[18:04:14.390]         if (TRUE) {
[18:04:14.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.390]         }
[18:04:14.390]         else {
[18:04:14.390]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.390]         }
[18:04:14.390]         base::close(...future.stdout)
[18:04:14.390]         ...future.stdout <- NULL
[18:04:14.390]     }
[18:04:14.390]     ...future.result$conditions <- ...future.conditions
[18:04:14.390]     ...future.result$finished <- base::Sys.time()
[18:04:14.390]     ...future.result
[18:04:14.390] }
[18:04:14.394] plan(): Setting new future strategy stack:
[18:04:14.394] List of future strategies:
[18:04:14.394] 1. sequential:
[18:04:14.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.394]    - tweaked: FALSE
[18:04:14.394]    - call: NULL
[18:04:14.395] plan(): nbrOfWorkers() = 1
[18:04:14.397] plan(): Setting new future strategy stack:
[18:04:14.397] List of future strategies:
[18:04:14.397] 1. sequential:
[18:04:14.397]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.397]    - tweaked: FALSE
[18:04:14.397]    - call: plan(strategy)
[18:04:14.398] plan(): nbrOfWorkers() = 1
[18:04:14.398] SequentialFuture started (and completed)
[18:04:14.399] - Launch lazy future ... done
[18:04:14.399] run() for ‘SequentialFuture’ ... done
[18:04:14.399] getGlobalsAndPackages() ...
[18:04:14.399] Searching for globals...
[18:04:14.400] 
[18:04:14.400] Searching for globals ... DONE
[18:04:14.400] - globals: [0] <none>
[18:04:14.401] getGlobalsAndPackages() ... DONE
[18:04:14.401] run() for ‘Future’ ...
[18:04:14.401] - state: ‘created’
[18:04:14.402] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.402] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.403]   - Field: ‘label’
[18:04:14.403]   - Field: ‘local’
[18:04:14.403]   - Field: ‘owner’
[18:04:14.403]   - Field: ‘envir’
[18:04:14.404]   - Field: ‘packages’
[18:04:14.404]   - Field: ‘gc’
[18:04:14.404]   - Field: ‘conditions’
[18:04:14.404]   - Field: ‘expr’
[18:04:14.404]   - Field: ‘uuid’
[18:04:14.405]   - Field: ‘seed’
[18:04:14.405]   - Field: ‘version’
[18:04:14.405]   - Field: ‘result’
[18:04:14.405]   - Field: ‘asynchronous’
[18:04:14.405]   - Field: ‘calls’
[18:04:14.406]   - Field: ‘globals’
[18:04:14.406]   - Field: ‘stdout’
[18:04:14.406]   - Field: ‘earlySignal’
[18:04:14.406]   - Field: ‘lazy’
[18:04:14.406]   - Field: ‘state’
[18:04:14.407] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.407] - Launch lazy future ...
[18:04:14.407] Packages needed by the future expression (n = 0): <none>
[18:04:14.407] Packages needed by future strategies (n = 0): <none>
[18:04:14.408] {
[18:04:14.408]     {
[18:04:14.408]         {
[18:04:14.408]             ...future.startTime <- base::Sys.time()
[18:04:14.408]             {
[18:04:14.408]                 {
[18:04:14.408]                   {
[18:04:14.408]                     base::local({
[18:04:14.408]                       has_future <- base::requireNamespace("future", 
[18:04:14.408]                         quietly = TRUE)
[18:04:14.408]                       if (has_future) {
[18:04:14.408]                         ns <- base::getNamespace("future")
[18:04:14.408]                         version <- ns[[".package"]][["version"]]
[18:04:14.408]                         if (is.null(version)) 
[18:04:14.408]                           version <- utils::packageVersion("future")
[18:04:14.408]                       }
[18:04:14.408]                       else {
[18:04:14.408]                         version <- NULL
[18:04:14.408]                       }
[18:04:14.408]                       if (!has_future || version < "1.8.0") {
[18:04:14.408]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.408]                           "", base::R.version$version.string), 
[18:04:14.408]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.408]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.408]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.408]                             "release", "version")], collapse = " "), 
[18:04:14.408]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.408]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.408]                           info)
[18:04:14.408]                         info <- base::paste(info, collapse = "; ")
[18:04:14.408]                         if (!has_future) {
[18:04:14.408]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.408]                             info)
[18:04:14.408]                         }
[18:04:14.408]                         else {
[18:04:14.408]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.408]                             info, version)
[18:04:14.408]                         }
[18:04:14.408]                         base::stop(msg)
[18:04:14.408]                       }
[18:04:14.408]                     })
[18:04:14.408]                   }
[18:04:14.408]                   ...future.strategy.old <- future::plan("list")
[18:04:14.408]                   options(future.plan = NULL)
[18:04:14.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.408]                 }
[18:04:14.408]                 ...future.workdir <- getwd()
[18:04:14.408]             }
[18:04:14.408]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.408]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.408]         }
[18:04:14.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.408]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.408]             base::names(...future.oldOptions))
[18:04:14.408]     }
[18:04:14.408]     if (FALSE) {
[18:04:14.408]     }
[18:04:14.408]     else {
[18:04:14.408]         if (TRUE) {
[18:04:14.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.408]                 open = "w")
[18:04:14.408]         }
[18:04:14.408]         else {
[18:04:14.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.408]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.408]         }
[18:04:14.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.408]             base::sink(type = "output", split = FALSE)
[18:04:14.408]             base::close(...future.stdout)
[18:04:14.408]         }, add = TRUE)
[18:04:14.408]     }
[18:04:14.408]     ...future.frame <- base::sys.nframe()
[18:04:14.408]     ...future.conditions <- base::list()
[18:04:14.408]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.408]     if (FALSE) {
[18:04:14.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.408]     }
[18:04:14.408]     ...future.result <- base::tryCatch({
[18:04:14.408]         base::withCallingHandlers({
[18:04:14.408]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.408]             future::FutureResult(value = ...future.value$value, 
[18:04:14.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.408]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.408]                     ...future.globalenv.names))
[18:04:14.408]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.408]         }, condition = base::local({
[18:04:14.408]             c <- base::c
[18:04:14.408]             inherits <- base::inherits
[18:04:14.408]             invokeRestart <- base::invokeRestart
[18:04:14.408]             length <- base::length
[18:04:14.408]             list <- base::list
[18:04:14.408]             seq.int <- base::seq.int
[18:04:14.408]             signalCondition <- base::signalCondition
[18:04:14.408]             sys.calls <- base::sys.calls
[18:04:14.408]             `[[` <- base::`[[`
[18:04:14.408]             `+` <- base::`+`
[18:04:14.408]             `<<-` <- base::`<<-`
[18:04:14.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.408]                   3L)]
[18:04:14.408]             }
[18:04:14.408]             function(cond) {
[18:04:14.408]                 is_error <- inherits(cond, "error")
[18:04:14.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.408]                   NULL)
[18:04:14.408]                 if (is_error) {
[18:04:14.408]                   sessionInformation <- function() {
[18:04:14.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.408]                       search = base::search(), system = base::Sys.info())
[18:04:14.408]                   }
[18:04:14.408]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.408]                     cond$call), session = sessionInformation(), 
[18:04:14.408]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.408]                   signalCondition(cond)
[18:04:14.408]                 }
[18:04:14.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.408]                 "immediateCondition"))) {
[18:04:14.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.408]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.408]                   if (TRUE && !signal) {
[18:04:14.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.408]                     {
[18:04:14.408]                       inherits <- base::inherits
[18:04:14.408]                       invokeRestart <- base::invokeRestart
[18:04:14.408]                       is.null <- base::is.null
[18:04:14.408]                       muffled <- FALSE
[18:04:14.408]                       if (inherits(cond, "message")) {
[18:04:14.408]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.408]                         if (muffled) 
[18:04:14.408]                           invokeRestart("muffleMessage")
[18:04:14.408]                       }
[18:04:14.408]                       else if (inherits(cond, "warning")) {
[18:04:14.408]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.408]                         if (muffled) 
[18:04:14.408]                           invokeRestart("muffleWarning")
[18:04:14.408]                       }
[18:04:14.408]                       else if (inherits(cond, "condition")) {
[18:04:14.408]                         if (!is.null(pattern)) {
[18:04:14.408]                           computeRestarts <- base::computeRestarts
[18:04:14.408]                           grepl <- base::grepl
[18:04:14.408]                           restarts <- computeRestarts(cond)
[18:04:14.408]                           for (restart in restarts) {
[18:04:14.408]                             name <- restart$name
[18:04:14.408]                             if (is.null(name)) 
[18:04:14.408]                               next
[18:04:14.408]                             if (!grepl(pattern, name)) 
[18:04:14.408]                               next
[18:04:14.408]                             invokeRestart(restart)
[18:04:14.408]                             muffled <- TRUE
[18:04:14.408]                             break
[18:04:14.408]                           }
[18:04:14.408]                         }
[18:04:14.408]                       }
[18:04:14.408]                       invisible(muffled)
[18:04:14.408]                     }
[18:04:14.408]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.408]                   }
[18:04:14.408]                 }
[18:04:14.408]                 else {
[18:04:14.408]                   if (TRUE) {
[18:04:14.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.408]                     {
[18:04:14.408]                       inherits <- base::inherits
[18:04:14.408]                       invokeRestart <- base::invokeRestart
[18:04:14.408]                       is.null <- base::is.null
[18:04:14.408]                       muffled <- FALSE
[18:04:14.408]                       if (inherits(cond, "message")) {
[18:04:14.408]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.408]                         if (muffled) 
[18:04:14.408]                           invokeRestart("muffleMessage")
[18:04:14.408]                       }
[18:04:14.408]                       else if (inherits(cond, "warning")) {
[18:04:14.408]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.408]                         if (muffled) 
[18:04:14.408]                           invokeRestart("muffleWarning")
[18:04:14.408]                       }
[18:04:14.408]                       else if (inherits(cond, "condition")) {
[18:04:14.408]                         if (!is.null(pattern)) {
[18:04:14.408]                           computeRestarts <- base::computeRestarts
[18:04:14.408]                           grepl <- base::grepl
[18:04:14.408]                           restarts <- computeRestarts(cond)
[18:04:14.408]                           for (restart in restarts) {
[18:04:14.408]                             name <- restart$name
[18:04:14.408]                             if (is.null(name)) 
[18:04:14.408]                               next
[18:04:14.408]                             if (!grepl(pattern, name)) 
[18:04:14.408]                               next
[18:04:14.408]                             invokeRestart(restart)
[18:04:14.408]                             muffled <- TRUE
[18:04:14.408]                             break
[18:04:14.408]                           }
[18:04:14.408]                         }
[18:04:14.408]                       }
[18:04:14.408]                       invisible(muffled)
[18:04:14.408]                     }
[18:04:14.408]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.408]                   }
[18:04:14.408]                 }
[18:04:14.408]             }
[18:04:14.408]         }))
[18:04:14.408]     }, error = function(ex) {
[18:04:14.408]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.408]                 ...future.rng), started = ...future.startTime, 
[18:04:14.408]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.408]             version = "1.8"), class = "FutureResult")
[18:04:14.408]     }, finally = {
[18:04:14.408]         if (!identical(...future.workdir, getwd())) 
[18:04:14.408]             setwd(...future.workdir)
[18:04:14.408]         {
[18:04:14.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.408]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.408]             }
[18:04:14.408]             base::options(...future.oldOptions)
[18:04:14.408]             if (.Platform$OS.type == "windows") {
[18:04:14.408]                 old_names <- names(...future.oldEnvVars)
[18:04:14.408]                 envs <- base::Sys.getenv()
[18:04:14.408]                 names <- names(envs)
[18:04:14.408]                 common <- intersect(names, old_names)
[18:04:14.408]                 added <- setdiff(names, old_names)
[18:04:14.408]                 removed <- setdiff(old_names, names)
[18:04:14.408]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.408]                   envs[common]]
[18:04:14.408]                 NAMES <- toupper(changed)
[18:04:14.408]                 args <- list()
[18:04:14.408]                 for (kk in seq_along(NAMES)) {
[18:04:14.408]                   name <- changed[[kk]]
[18:04:14.408]                   NAME <- NAMES[[kk]]
[18:04:14.408]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.408]                     next
[18:04:14.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.408]                 }
[18:04:14.408]                 NAMES <- toupper(added)
[18:04:14.408]                 for (kk in seq_along(NAMES)) {
[18:04:14.408]                   name <- added[[kk]]
[18:04:14.408]                   NAME <- NAMES[[kk]]
[18:04:14.408]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.408]                     next
[18:04:14.408]                   args[[name]] <- ""
[18:04:14.408]                 }
[18:04:14.408]                 NAMES <- toupper(removed)
[18:04:14.408]                 for (kk in seq_along(NAMES)) {
[18:04:14.408]                   name <- removed[[kk]]
[18:04:14.408]                   NAME <- NAMES[[kk]]
[18:04:14.408]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.408]                     next
[18:04:14.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.408]                 }
[18:04:14.408]                 if (length(args) > 0) 
[18:04:14.408]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.408]             }
[18:04:14.408]             else {
[18:04:14.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.408]             }
[18:04:14.408]             {
[18:04:14.408]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.408]                   0L) {
[18:04:14.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.408]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.408]                   base::options(opts)
[18:04:14.408]                 }
[18:04:14.408]                 {
[18:04:14.408]                   {
[18:04:14.408]                     NULL
[18:04:14.408]                     RNGkind("Mersenne-Twister")
[18:04:14.408]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.408]                       inherits = FALSE)
[18:04:14.408]                   }
[18:04:14.408]                   options(future.plan = NULL)
[18:04:14.408]                   if (is.na(NA_character_)) 
[18:04:14.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.408]                     .init = FALSE)
[18:04:14.408]                 }
[18:04:14.408]             }
[18:04:14.408]         }
[18:04:14.408]     })
[18:04:14.408]     if (TRUE) {
[18:04:14.408]         base::sink(type = "output", split = FALSE)
[18:04:14.408]         if (TRUE) {
[18:04:14.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.408]         }
[18:04:14.408]         else {
[18:04:14.408]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.408]         }
[18:04:14.408]         base::close(...future.stdout)
[18:04:14.408]         ...future.stdout <- NULL
[18:04:14.408]     }
[18:04:14.408]     ...future.result$conditions <- ...future.conditions
[18:04:14.408]     ...future.result$finished <- base::Sys.time()
[18:04:14.408]     ...future.result
[18:04:14.408] }
[18:04:14.412] plan(): Setting new future strategy stack:
[18:04:14.412] List of future strategies:
[18:04:14.412] 1. sequential:
[18:04:14.412]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.412]    - tweaked: FALSE
[18:04:14.412]    - call: NULL
[18:04:14.413] plan(): nbrOfWorkers() = 1
[18:04:14.415] plan(): Setting new future strategy stack:
[18:04:14.415] List of future strategies:
[18:04:14.415] 1. sequential:
[18:04:14.415]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.415]    - tweaked: FALSE
[18:04:14.415]    - call: plan(strategy)
[18:04:14.416] plan(): nbrOfWorkers() = 1
[18:04:14.417] SequentialFuture started (and completed)
[18:04:14.417] - Launch lazy future ... done
[18:04:14.417] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c297145d0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2ab1b8c8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c297145d0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5e3c2ab1b8c8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[18:04:14.429] resolved() for ‘SequentialFuture’ ...
[18:04:14.429] - state: ‘finished’
[18:04:14.429] - run: TRUE
[18:04:14.430] - result: ‘FutureResult’
[18:04:14.430] resolved() for ‘SequentialFuture’ ... done
[18:04:14.430] resolved() for ‘SequentialFuture’ ...
[18:04:14.430] - state: ‘finished’
[18:04:14.430] - run: TRUE
[18:04:14.431] - result: ‘FutureResult’
[18:04:14.431] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:14.435] resolve() on list ...
[18:04:14.435]  recursive: 0
[18:04:14.436]  length: 6
[18:04:14.436]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:14.436] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.436] - nx: 6
[18:04:14.437] - relay: TRUE
[18:04:14.437] - stdout: TRUE
[18:04:14.437] - signal: TRUE
[18:04:14.437] - resignal: FALSE
[18:04:14.437] - force: TRUE
[18:04:14.437] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.438] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.438]  - until=2
[18:04:14.438]  - relaying element #2
[18:04:14.438] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.438] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.439] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.439]  length: 5 (resolved future 1)
[18:04:14.439] resolved() for ‘SequentialFuture’ ...
[18:04:14.439] - state: ‘finished’
[18:04:14.439] - run: TRUE
[18:04:14.440] - result: ‘FutureResult’
[18:04:14.440] resolved() for ‘SequentialFuture’ ... done
[18:04:14.440] Future #2
[18:04:14.440] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.441] - nx: 6
[18:04:14.441] - relay: TRUE
[18:04:14.441] - stdout: TRUE
[18:04:14.441] - signal: TRUE
[18:04:14.441] - resignal: FALSE
[18:04:14.441] - force: TRUE
[18:04:14.442] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.442] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:14.442]  - until=2
[18:04:14.442]  - relaying element #2
[18:04:14.443] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.443] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.443] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.446]  length: 4 (resolved future 2)
[18:04:14.446] resolved() for ‘SequentialFuture’ ...
[18:04:14.446] - state: ‘finished’
[18:04:14.447] - run: TRUE
[18:04:14.447] - result: ‘FutureResult’
[18:04:14.447] resolved() for ‘SequentialFuture’ ... done
[18:04:14.447] Future #3
[18:04:14.448] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.448] - nx: 6
[18:04:14.448] - relay: TRUE
[18:04:14.448] - stdout: TRUE
[18:04:14.448] - signal: TRUE
[18:04:14.449] - resignal: FALSE
[18:04:14.449] - force: TRUE
[18:04:14.449] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.449] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:14.449]  - until=3
[18:04:14.450]  - relaying element #3
[18:04:14.450] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.450] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.450] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.451]  length: 3 (resolved future 3)
[18:04:14.451] signalConditionsASAP(NULL, pos=4) ...
[18:04:14.451] - nx: 6
[18:04:14.451] - relay: TRUE
[18:04:14.451] - stdout: TRUE
[18:04:14.451] - signal: TRUE
[18:04:14.452] - resignal: FALSE
[18:04:14.452] - force: TRUE
[18:04:14.452] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.452] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.452]  - until=5
[18:04:14.453]  - relaying element #5
[18:04:14.453] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.453] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.453] signalConditionsASAP(NULL, pos=4) ... done
[18:04:14.453]  length: 2 (resolved future 4)
[18:04:14.454] signalConditionsASAP(NULL, pos=5) ...
[18:04:14.454] - nx: 6
[18:04:14.454] - relay: TRUE
[18:04:14.454] - stdout: TRUE
[18:04:14.454] - signal: TRUE
[18:04:14.455] - resignal: FALSE
[18:04:14.455] - force: TRUE
[18:04:14.455] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:14.455] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.455]  - until=6
[18:04:14.455]  - relaying element #6
[18:04:14.456] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.456] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.456] signalConditionsASAP(NULL, pos=5) ... done
[18:04:14.456]  length: 1 (resolved future 5)
[18:04:14.456] signalConditionsASAP(numeric, pos=6) ...
[18:04:14.457] - nx: 6
[18:04:14.457] - relay: TRUE
[18:04:14.457] - stdout: TRUE
[18:04:14.457] - signal: TRUE
[18:04:14.457] - resignal: FALSE
[18:04:14.457] - force: TRUE
[18:04:14.458] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:14.458] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.458]  - until=6
[18:04:14.458] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.458] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.459] signalConditionsASAP(numeric, pos=6) ... done
[18:04:14.459]  length: 0 (resolved future 6)
[18:04:14.459] Relaying remaining futures
[18:04:14.459] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.459] - nx: 6
[18:04:14.460] - relay: TRUE
[18:04:14.460] - stdout: TRUE
[18:04:14.460] - signal: TRUE
[18:04:14.460] - resignal: FALSE
[18:04:14.460] - force: TRUE
[18:04:14.460] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.461] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:14.461] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:14.461] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:14.461] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.462] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[18:04:14.482] plan(): Setting new future strategy stack:
[18:04:14.482] List of future strategies:
[18:04:14.482] 1. sequential:
[18:04:14.482]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.482]    - tweaked: FALSE
[18:04:14.482]    - call: plan(strategy)
[18:04:14.483] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[18:04:14.483] getGlobalsAndPackages() ...
[18:04:14.484] Searching for globals...
[18:04:14.484] 
[18:04:14.485] Searching for globals ... DONE
[18:04:14.485] - globals: [0] <none>
[18:04:14.485] getGlobalsAndPackages() ... DONE
[18:04:14.486] run() for ‘Future’ ...
[18:04:14.486] - state: ‘created’
[18:04:14.486] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.487] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.487] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.487]   - Field: ‘label’
[18:04:14.487]   - Field: ‘local’
[18:04:14.488]   - Field: ‘owner’
[18:04:14.488]   - Field: ‘envir’
[18:04:14.488]   - Field: ‘packages’
[18:04:14.488]   - Field: ‘gc’
[18:04:14.488]   - Field: ‘conditions’
[18:04:14.489]   - Field: ‘expr’
[18:04:14.489]   - Field: ‘uuid’
[18:04:14.489]   - Field: ‘seed’
[18:04:14.489]   - Field: ‘version’
[18:04:14.489]   - Field: ‘result’
[18:04:14.490]   - Field: ‘asynchronous’
[18:04:14.490]   - Field: ‘calls’
[18:04:14.490]   - Field: ‘globals’
[18:04:14.490]   - Field: ‘stdout’
[18:04:14.490]   - Field: ‘earlySignal’
[18:04:14.491]   - Field: ‘lazy’
[18:04:14.491]   - Field: ‘state’
[18:04:14.491] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.491] - Launch lazy future ...
[18:04:14.492] Packages needed by the future expression (n = 0): <none>
[18:04:14.492] Packages needed by future strategies (n = 0): <none>
[18:04:14.493] {
[18:04:14.493]     {
[18:04:14.493]         {
[18:04:14.493]             ...future.startTime <- base::Sys.time()
[18:04:14.493]             {
[18:04:14.493]                 {
[18:04:14.493]                   {
[18:04:14.493]                     base::local({
[18:04:14.493]                       has_future <- base::requireNamespace("future", 
[18:04:14.493]                         quietly = TRUE)
[18:04:14.493]                       if (has_future) {
[18:04:14.493]                         ns <- base::getNamespace("future")
[18:04:14.493]                         version <- ns[[".package"]][["version"]]
[18:04:14.493]                         if (is.null(version)) 
[18:04:14.493]                           version <- utils::packageVersion("future")
[18:04:14.493]                       }
[18:04:14.493]                       else {
[18:04:14.493]                         version <- NULL
[18:04:14.493]                       }
[18:04:14.493]                       if (!has_future || version < "1.8.0") {
[18:04:14.493]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.493]                           "", base::R.version$version.string), 
[18:04:14.493]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.493]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.493]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.493]                             "release", "version")], collapse = " "), 
[18:04:14.493]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.493]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.493]                           info)
[18:04:14.493]                         info <- base::paste(info, collapse = "; ")
[18:04:14.493]                         if (!has_future) {
[18:04:14.493]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.493]                             info)
[18:04:14.493]                         }
[18:04:14.493]                         else {
[18:04:14.493]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.493]                             info, version)
[18:04:14.493]                         }
[18:04:14.493]                         base::stop(msg)
[18:04:14.493]                       }
[18:04:14.493]                     })
[18:04:14.493]                   }
[18:04:14.493]                   ...future.strategy.old <- future::plan("list")
[18:04:14.493]                   options(future.plan = NULL)
[18:04:14.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.493]                 }
[18:04:14.493]                 ...future.workdir <- getwd()
[18:04:14.493]             }
[18:04:14.493]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.493]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.493]         }
[18:04:14.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.493]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.493]             base::names(...future.oldOptions))
[18:04:14.493]     }
[18:04:14.493]     if (FALSE) {
[18:04:14.493]     }
[18:04:14.493]     else {
[18:04:14.493]         if (TRUE) {
[18:04:14.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.493]                 open = "w")
[18:04:14.493]         }
[18:04:14.493]         else {
[18:04:14.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.493]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.493]         }
[18:04:14.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.493]             base::sink(type = "output", split = FALSE)
[18:04:14.493]             base::close(...future.stdout)
[18:04:14.493]         }, add = TRUE)
[18:04:14.493]     }
[18:04:14.493]     ...future.frame <- base::sys.nframe()
[18:04:14.493]     ...future.conditions <- base::list()
[18:04:14.493]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.493]     if (FALSE) {
[18:04:14.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.493]     }
[18:04:14.493]     ...future.result <- base::tryCatch({
[18:04:14.493]         base::withCallingHandlers({
[18:04:14.493]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.493]             future::FutureResult(value = ...future.value$value, 
[18:04:14.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.493]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.493]                     ...future.globalenv.names))
[18:04:14.493]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.493]         }, condition = base::local({
[18:04:14.493]             c <- base::c
[18:04:14.493]             inherits <- base::inherits
[18:04:14.493]             invokeRestart <- base::invokeRestart
[18:04:14.493]             length <- base::length
[18:04:14.493]             list <- base::list
[18:04:14.493]             seq.int <- base::seq.int
[18:04:14.493]             signalCondition <- base::signalCondition
[18:04:14.493]             sys.calls <- base::sys.calls
[18:04:14.493]             `[[` <- base::`[[`
[18:04:14.493]             `+` <- base::`+`
[18:04:14.493]             `<<-` <- base::`<<-`
[18:04:14.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.493]                   3L)]
[18:04:14.493]             }
[18:04:14.493]             function(cond) {
[18:04:14.493]                 is_error <- inherits(cond, "error")
[18:04:14.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.493]                   NULL)
[18:04:14.493]                 if (is_error) {
[18:04:14.493]                   sessionInformation <- function() {
[18:04:14.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.493]                       search = base::search(), system = base::Sys.info())
[18:04:14.493]                   }
[18:04:14.493]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.493]                     cond$call), session = sessionInformation(), 
[18:04:14.493]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.493]                   signalCondition(cond)
[18:04:14.493]                 }
[18:04:14.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.493]                 "immediateCondition"))) {
[18:04:14.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.493]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.493]                   if (TRUE && !signal) {
[18:04:14.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.493]                     {
[18:04:14.493]                       inherits <- base::inherits
[18:04:14.493]                       invokeRestart <- base::invokeRestart
[18:04:14.493]                       is.null <- base::is.null
[18:04:14.493]                       muffled <- FALSE
[18:04:14.493]                       if (inherits(cond, "message")) {
[18:04:14.493]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.493]                         if (muffled) 
[18:04:14.493]                           invokeRestart("muffleMessage")
[18:04:14.493]                       }
[18:04:14.493]                       else if (inherits(cond, "warning")) {
[18:04:14.493]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.493]                         if (muffled) 
[18:04:14.493]                           invokeRestart("muffleWarning")
[18:04:14.493]                       }
[18:04:14.493]                       else if (inherits(cond, "condition")) {
[18:04:14.493]                         if (!is.null(pattern)) {
[18:04:14.493]                           computeRestarts <- base::computeRestarts
[18:04:14.493]                           grepl <- base::grepl
[18:04:14.493]                           restarts <- computeRestarts(cond)
[18:04:14.493]                           for (restart in restarts) {
[18:04:14.493]                             name <- restart$name
[18:04:14.493]                             if (is.null(name)) 
[18:04:14.493]                               next
[18:04:14.493]                             if (!grepl(pattern, name)) 
[18:04:14.493]                               next
[18:04:14.493]                             invokeRestart(restart)
[18:04:14.493]                             muffled <- TRUE
[18:04:14.493]                             break
[18:04:14.493]                           }
[18:04:14.493]                         }
[18:04:14.493]                       }
[18:04:14.493]                       invisible(muffled)
[18:04:14.493]                     }
[18:04:14.493]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.493]                   }
[18:04:14.493]                 }
[18:04:14.493]                 else {
[18:04:14.493]                   if (TRUE) {
[18:04:14.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.493]                     {
[18:04:14.493]                       inherits <- base::inherits
[18:04:14.493]                       invokeRestart <- base::invokeRestart
[18:04:14.493]                       is.null <- base::is.null
[18:04:14.493]                       muffled <- FALSE
[18:04:14.493]                       if (inherits(cond, "message")) {
[18:04:14.493]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.493]                         if (muffled) 
[18:04:14.493]                           invokeRestart("muffleMessage")
[18:04:14.493]                       }
[18:04:14.493]                       else if (inherits(cond, "warning")) {
[18:04:14.493]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.493]                         if (muffled) 
[18:04:14.493]                           invokeRestart("muffleWarning")
[18:04:14.493]                       }
[18:04:14.493]                       else if (inherits(cond, "condition")) {
[18:04:14.493]                         if (!is.null(pattern)) {
[18:04:14.493]                           computeRestarts <- base::computeRestarts
[18:04:14.493]                           grepl <- base::grepl
[18:04:14.493]                           restarts <- computeRestarts(cond)
[18:04:14.493]                           for (restart in restarts) {
[18:04:14.493]                             name <- restart$name
[18:04:14.493]                             if (is.null(name)) 
[18:04:14.493]                               next
[18:04:14.493]                             if (!grepl(pattern, name)) 
[18:04:14.493]                               next
[18:04:14.493]                             invokeRestart(restart)
[18:04:14.493]                             muffled <- TRUE
[18:04:14.493]                             break
[18:04:14.493]                           }
[18:04:14.493]                         }
[18:04:14.493]                       }
[18:04:14.493]                       invisible(muffled)
[18:04:14.493]                     }
[18:04:14.493]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.493]                   }
[18:04:14.493]                 }
[18:04:14.493]             }
[18:04:14.493]         }))
[18:04:14.493]     }, error = function(ex) {
[18:04:14.493]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.493]                 ...future.rng), started = ...future.startTime, 
[18:04:14.493]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.493]             version = "1.8"), class = "FutureResult")
[18:04:14.493]     }, finally = {
[18:04:14.493]         if (!identical(...future.workdir, getwd())) 
[18:04:14.493]             setwd(...future.workdir)
[18:04:14.493]         {
[18:04:14.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.493]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.493]             }
[18:04:14.493]             base::options(...future.oldOptions)
[18:04:14.493]             if (.Platform$OS.type == "windows") {
[18:04:14.493]                 old_names <- names(...future.oldEnvVars)
[18:04:14.493]                 envs <- base::Sys.getenv()
[18:04:14.493]                 names <- names(envs)
[18:04:14.493]                 common <- intersect(names, old_names)
[18:04:14.493]                 added <- setdiff(names, old_names)
[18:04:14.493]                 removed <- setdiff(old_names, names)
[18:04:14.493]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.493]                   envs[common]]
[18:04:14.493]                 NAMES <- toupper(changed)
[18:04:14.493]                 args <- list()
[18:04:14.493]                 for (kk in seq_along(NAMES)) {
[18:04:14.493]                   name <- changed[[kk]]
[18:04:14.493]                   NAME <- NAMES[[kk]]
[18:04:14.493]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.493]                     next
[18:04:14.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.493]                 }
[18:04:14.493]                 NAMES <- toupper(added)
[18:04:14.493]                 for (kk in seq_along(NAMES)) {
[18:04:14.493]                   name <- added[[kk]]
[18:04:14.493]                   NAME <- NAMES[[kk]]
[18:04:14.493]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.493]                     next
[18:04:14.493]                   args[[name]] <- ""
[18:04:14.493]                 }
[18:04:14.493]                 NAMES <- toupper(removed)
[18:04:14.493]                 for (kk in seq_along(NAMES)) {
[18:04:14.493]                   name <- removed[[kk]]
[18:04:14.493]                   NAME <- NAMES[[kk]]
[18:04:14.493]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.493]                     next
[18:04:14.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.493]                 }
[18:04:14.493]                 if (length(args) > 0) 
[18:04:14.493]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.493]             }
[18:04:14.493]             else {
[18:04:14.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.493]             }
[18:04:14.493]             {
[18:04:14.493]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.493]                   0L) {
[18:04:14.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.493]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.493]                   base::options(opts)
[18:04:14.493]                 }
[18:04:14.493]                 {
[18:04:14.493]                   {
[18:04:14.493]                     NULL
[18:04:14.493]                     RNGkind("Mersenne-Twister")
[18:04:14.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.493]                       inherits = FALSE)
[18:04:14.493]                   }
[18:04:14.493]                   options(future.plan = NULL)
[18:04:14.493]                   if (is.na(NA_character_)) 
[18:04:14.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.493]                     .init = FALSE)
[18:04:14.493]                 }
[18:04:14.493]             }
[18:04:14.493]         }
[18:04:14.493]     })
[18:04:14.493]     if (TRUE) {
[18:04:14.493]         base::sink(type = "output", split = FALSE)
[18:04:14.493]         if (TRUE) {
[18:04:14.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.493]         }
[18:04:14.493]         else {
[18:04:14.493]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.493]         }
[18:04:14.493]         base::close(...future.stdout)
[18:04:14.493]         ...future.stdout <- NULL
[18:04:14.493]     }
[18:04:14.493]     ...future.result$conditions <- ...future.conditions
[18:04:14.493]     ...future.result$finished <- base::Sys.time()
[18:04:14.493]     ...future.result
[18:04:14.493] }
[18:04:14.496] plan(): Setting new future strategy stack:
[18:04:14.497] List of future strategies:
[18:04:14.497] 1. sequential:
[18:04:14.497]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.497]    - tweaked: FALSE
[18:04:14.497]    - call: NULL
[18:04:14.498] plan(): nbrOfWorkers() = 1
[18:04:14.499] plan(): Setting new future strategy stack:
[18:04:14.500] List of future strategies:
[18:04:14.500] 1. sequential:
[18:04:14.500]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.500]    - tweaked: FALSE
[18:04:14.500]    - call: plan(strategy)
[18:04:14.501] plan(): nbrOfWorkers() = 1
[18:04:14.501] SequentialFuture started (and completed)
[18:04:14.501] - Launch lazy future ... done
[18:04:14.502] run() for ‘SequentialFuture’ ... done
[18:04:14.502] getGlobalsAndPackages() ...
[18:04:14.502] Searching for globals...
[18:04:14.503] 
[18:04:14.503] Searching for globals ... DONE
[18:04:14.503] - globals: [0] <none>
[18:04:14.503] getGlobalsAndPackages() ... DONE
[18:04:14.504] run() for ‘Future’ ...
[18:04:14.504] - state: ‘created’
[18:04:14.504] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.505] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.505] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.508]   - Field: ‘label’
[18:04:14.508]   - Field: ‘local’
[18:04:14.508]   - Field: ‘owner’
[18:04:14.509]   - Field: ‘envir’
[18:04:14.509]   - Field: ‘packages’
[18:04:14.509]   - Field: ‘gc’
[18:04:14.509]   - Field: ‘conditions’
[18:04:14.510]   - Field: ‘expr’
[18:04:14.510]   - Field: ‘uuid’
[18:04:14.510]   - Field: ‘seed’
[18:04:14.510]   - Field: ‘version’
[18:04:14.510]   - Field: ‘result’
[18:04:14.511]   - Field: ‘asynchronous’
[18:04:14.511]   - Field: ‘calls’
[18:04:14.511]   - Field: ‘globals’
[18:04:14.511]   - Field: ‘stdout’
[18:04:14.511]   - Field: ‘earlySignal’
[18:04:14.512]   - Field: ‘lazy’
[18:04:14.512]   - Field: ‘state’
[18:04:14.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.512] - Launch lazy future ...
[18:04:14.513] Packages needed by the future expression (n = 0): <none>
[18:04:14.513] Packages needed by future strategies (n = 0): <none>
[18:04:14.514] {
[18:04:14.514]     {
[18:04:14.514]         {
[18:04:14.514]             ...future.startTime <- base::Sys.time()
[18:04:14.514]             {
[18:04:14.514]                 {
[18:04:14.514]                   {
[18:04:14.514]                     base::local({
[18:04:14.514]                       has_future <- base::requireNamespace("future", 
[18:04:14.514]                         quietly = TRUE)
[18:04:14.514]                       if (has_future) {
[18:04:14.514]                         ns <- base::getNamespace("future")
[18:04:14.514]                         version <- ns[[".package"]][["version"]]
[18:04:14.514]                         if (is.null(version)) 
[18:04:14.514]                           version <- utils::packageVersion("future")
[18:04:14.514]                       }
[18:04:14.514]                       else {
[18:04:14.514]                         version <- NULL
[18:04:14.514]                       }
[18:04:14.514]                       if (!has_future || version < "1.8.0") {
[18:04:14.514]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.514]                           "", base::R.version$version.string), 
[18:04:14.514]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.514]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.514]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.514]                             "release", "version")], collapse = " "), 
[18:04:14.514]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.514]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.514]                           info)
[18:04:14.514]                         info <- base::paste(info, collapse = "; ")
[18:04:14.514]                         if (!has_future) {
[18:04:14.514]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.514]                             info)
[18:04:14.514]                         }
[18:04:14.514]                         else {
[18:04:14.514]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.514]                             info, version)
[18:04:14.514]                         }
[18:04:14.514]                         base::stop(msg)
[18:04:14.514]                       }
[18:04:14.514]                     })
[18:04:14.514]                   }
[18:04:14.514]                   ...future.strategy.old <- future::plan("list")
[18:04:14.514]                   options(future.plan = NULL)
[18:04:14.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.514]                 }
[18:04:14.514]                 ...future.workdir <- getwd()
[18:04:14.514]             }
[18:04:14.514]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.514]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.514]         }
[18:04:14.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.514]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.514]             base::names(...future.oldOptions))
[18:04:14.514]     }
[18:04:14.514]     if (FALSE) {
[18:04:14.514]     }
[18:04:14.514]     else {
[18:04:14.514]         if (TRUE) {
[18:04:14.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.514]                 open = "w")
[18:04:14.514]         }
[18:04:14.514]         else {
[18:04:14.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.514]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.514]         }
[18:04:14.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.514]             base::sink(type = "output", split = FALSE)
[18:04:14.514]             base::close(...future.stdout)
[18:04:14.514]         }, add = TRUE)
[18:04:14.514]     }
[18:04:14.514]     ...future.frame <- base::sys.nframe()
[18:04:14.514]     ...future.conditions <- base::list()
[18:04:14.514]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.514]     if (FALSE) {
[18:04:14.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.514]     }
[18:04:14.514]     ...future.result <- base::tryCatch({
[18:04:14.514]         base::withCallingHandlers({
[18:04:14.514]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.514]             future::FutureResult(value = ...future.value$value, 
[18:04:14.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.514]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.514]                     ...future.globalenv.names))
[18:04:14.514]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.514]         }, condition = base::local({
[18:04:14.514]             c <- base::c
[18:04:14.514]             inherits <- base::inherits
[18:04:14.514]             invokeRestart <- base::invokeRestart
[18:04:14.514]             length <- base::length
[18:04:14.514]             list <- base::list
[18:04:14.514]             seq.int <- base::seq.int
[18:04:14.514]             signalCondition <- base::signalCondition
[18:04:14.514]             sys.calls <- base::sys.calls
[18:04:14.514]             `[[` <- base::`[[`
[18:04:14.514]             `+` <- base::`+`
[18:04:14.514]             `<<-` <- base::`<<-`
[18:04:14.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.514]                   3L)]
[18:04:14.514]             }
[18:04:14.514]             function(cond) {
[18:04:14.514]                 is_error <- inherits(cond, "error")
[18:04:14.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.514]                   NULL)
[18:04:14.514]                 if (is_error) {
[18:04:14.514]                   sessionInformation <- function() {
[18:04:14.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.514]                       search = base::search(), system = base::Sys.info())
[18:04:14.514]                   }
[18:04:14.514]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.514]                     cond$call), session = sessionInformation(), 
[18:04:14.514]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.514]                   signalCondition(cond)
[18:04:14.514]                 }
[18:04:14.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.514]                 "immediateCondition"))) {
[18:04:14.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.514]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.514]                   if (TRUE && !signal) {
[18:04:14.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.514]                     {
[18:04:14.514]                       inherits <- base::inherits
[18:04:14.514]                       invokeRestart <- base::invokeRestart
[18:04:14.514]                       is.null <- base::is.null
[18:04:14.514]                       muffled <- FALSE
[18:04:14.514]                       if (inherits(cond, "message")) {
[18:04:14.514]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.514]                         if (muffled) 
[18:04:14.514]                           invokeRestart("muffleMessage")
[18:04:14.514]                       }
[18:04:14.514]                       else if (inherits(cond, "warning")) {
[18:04:14.514]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.514]                         if (muffled) 
[18:04:14.514]                           invokeRestart("muffleWarning")
[18:04:14.514]                       }
[18:04:14.514]                       else if (inherits(cond, "condition")) {
[18:04:14.514]                         if (!is.null(pattern)) {
[18:04:14.514]                           computeRestarts <- base::computeRestarts
[18:04:14.514]                           grepl <- base::grepl
[18:04:14.514]                           restarts <- computeRestarts(cond)
[18:04:14.514]                           for (restart in restarts) {
[18:04:14.514]                             name <- restart$name
[18:04:14.514]                             if (is.null(name)) 
[18:04:14.514]                               next
[18:04:14.514]                             if (!grepl(pattern, name)) 
[18:04:14.514]                               next
[18:04:14.514]                             invokeRestart(restart)
[18:04:14.514]                             muffled <- TRUE
[18:04:14.514]                             break
[18:04:14.514]                           }
[18:04:14.514]                         }
[18:04:14.514]                       }
[18:04:14.514]                       invisible(muffled)
[18:04:14.514]                     }
[18:04:14.514]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.514]                   }
[18:04:14.514]                 }
[18:04:14.514]                 else {
[18:04:14.514]                   if (TRUE) {
[18:04:14.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.514]                     {
[18:04:14.514]                       inherits <- base::inherits
[18:04:14.514]                       invokeRestart <- base::invokeRestart
[18:04:14.514]                       is.null <- base::is.null
[18:04:14.514]                       muffled <- FALSE
[18:04:14.514]                       if (inherits(cond, "message")) {
[18:04:14.514]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.514]                         if (muffled) 
[18:04:14.514]                           invokeRestart("muffleMessage")
[18:04:14.514]                       }
[18:04:14.514]                       else if (inherits(cond, "warning")) {
[18:04:14.514]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.514]                         if (muffled) 
[18:04:14.514]                           invokeRestart("muffleWarning")
[18:04:14.514]                       }
[18:04:14.514]                       else if (inherits(cond, "condition")) {
[18:04:14.514]                         if (!is.null(pattern)) {
[18:04:14.514]                           computeRestarts <- base::computeRestarts
[18:04:14.514]                           grepl <- base::grepl
[18:04:14.514]                           restarts <- computeRestarts(cond)
[18:04:14.514]                           for (restart in restarts) {
[18:04:14.514]                             name <- restart$name
[18:04:14.514]                             if (is.null(name)) 
[18:04:14.514]                               next
[18:04:14.514]                             if (!grepl(pattern, name)) 
[18:04:14.514]                               next
[18:04:14.514]                             invokeRestart(restart)
[18:04:14.514]                             muffled <- TRUE
[18:04:14.514]                             break
[18:04:14.514]                           }
[18:04:14.514]                         }
[18:04:14.514]                       }
[18:04:14.514]                       invisible(muffled)
[18:04:14.514]                     }
[18:04:14.514]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.514]                   }
[18:04:14.514]                 }
[18:04:14.514]             }
[18:04:14.514]         }))
[18:04:14.514]     }, error = function(ex) {
[18:04:14.514]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.514]                 ...future.rng), started = ...future.startTime, 
[18:04:14.514]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.514]             version = "1.8"), class = "FutureResult")
[18:04:14.514]     }, finally = {
[18:04:14.514]         if (!identical(...future.workdir, getwd())) 
[18:04:14.514]             setwd(...future.workdir)
[18:04:14.514]         {
[18:04:14.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.514]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.514]             }
[18:04:14.514]             base::options(...future.oldOptions)
[18:04:14.514]             if (.Platform$OS.type == "windows") {
[18:04:14.514]                 old_names <- names(...future.oldEnvVars)
[18:04:14.514]                 envs <- base::Sys.getenv()
[18:04:14.514]                 names <- names(envs)
[18:04:14.514]                 common <- intersect(names, old_names)
[18:04:14.514]                 added <- setdiff(names, old_names)
[18:04:14.514]                 removed <- setdiff(old_names, names)
[18:04:14.514]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.514]                   envs[common]]
[18:04:14.514]                 NAMES <- toupper(changed)
[18:04:14.514]                 args <- list()
[18:04:14.514]                 for (kk in seq_along(NAMES)) {
[18:04:14.514]                   name <- changed[[kk]]
[18:04:14.514]                   NAME <- NAMES[[kk]]
[18:04:14.514]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.514]                     next
[18:04:14.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.514]                 }
[18:04:14.514]                 NAMES <- toupper(added)
[18:04:14.514]                 for (kk in seq_along(NAMES)) {
[18:04:14.514]                   name <- added[[kk]]
[18:04:14.514]                   NAME <- NAMES[[kk]]
[18:04:14.514]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.514]                     next
[18:04:14.514]                   args[[name]] <- ""
[18:04:14.514]                 }
[18:04:14.514]                 NAMES <- toupper(removed)
[18:04:14.514]                 for (kk in seq_along(NAMES)) {
[18:04:14.514]                   name <- removed[[kk]]
[18:04:14.514]                   NAME <- NAMES[[kk]]
[18:04:14.514]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.514]                     next
[18:04:14.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.514]                 }
[18:04:14.514]                 if (length(args) > 0) 
[18:04:14.514]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.514]             }
[18:04:14.514]             else {
[18:04:14.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.514]             }
[18:04:14.514]             {
[18:04:14.514]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.514]                   0L) {
[18:04:14.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.514]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.514]                   base::options(opts)
[18:04:14.514]                 }
[18:04:14.514]                 {
[18:04:14.514]                   {
[18:04:14.514]                     NULL
[18:04:14.514]                     RNGkind("Mersenne-Twister")
[18:04:14.514]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.514]                       inherits = FALSE)
[18:04:14.514]                   }
[18:04:14.514]                   options(future.plan = NULL)
[18:04:14.514]                   if (is.na(NA_character_)) 
[18:04:14.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.514]                     .init = FALSE)
[18:04:14.514]                 }
[18:04:14.514]             }
[18:04:14.514]         }
[18:04:14.514]     })
[18:04:14.514]     if (TRUE) {
[18:04:14.514]         base::sink(type = "output", split = FALSE)
[18:04:14.514]         if (TRUE) {
[18:04:14.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.514]         }
[18:04:14.514]         else {
[18:04:14.514]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.514]         }
[18:04:14.514]         base::close(...future.stdout)
[18:04:14.514]         ...future.stdout <- NULL
[18:04:14.514]     }
[18:04:14.514]     ...future.result$conditions <- ...future.conditions
[18:04:14.514]     ...future.result$finished <- base::Sys.time()
[18:04:14.514]     ...future.result
[18:04:14.514] }
[18:04:14.517] plan(): Setting new future strategy stack:
[18:04:14.518] List of future strategies:
[18:04:14.518] 1. sequential:
[18:04:14.518]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.518]    - tweaked: FALSE
[18:04:14.518]    - call: NULL
[18:04:14.519] plan(): nbrOfWorkers() = 1
[18:04:14.520] plan(): Setting new future strategy stack:
[18:04:14.521] List of future strategies:
[18:04:14.521] 1. sequential:
[18:04:14.521]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.521]    - tweaked: FALSE
[18:04:14.521]    - call: plan(strategy)
[18:04:14.522] plan(): nbrOfWorkers() = 1
[18:04:14.522] SequentialFuture started (and completed)
[18:04:14.522] - Launch lazy future ... done
[18:04:14.523] run() for ‘SequentialFuture’ ... done
[18:04:14.525] getGlobalsAndPackages() ...
[18:04:14.525] Searching for globals...
[18:04:14.528] - globals found: [1] ‘{’
[18:04:14.528] Searching for globals ... DONE
[18:04:14.528] Resolving globals: FALSE
[18:04:14.529] 
[18:04:14.530] 
[18:04:14.530] getGlobalsAndPackages() ... DONE
[18:04:14.530] run() for ‘Future’ ...
[18:04:14.531] - state: ‘created’
[18:04:14.531] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.532] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.532]   - Field: ‘label’
[18:04:14.532]   - Field: ‘local’
[18:04:14.532]   - Field: ‘owner’
[18:04:14.533]   - Field: ‘envir’
[18:04:14.533]   - Field: ‘packages’
[18:04:14.533]   - Field: ‘gc’
[18:04:14.533]   - Field: ‘conditions’
[18:04:14.533]   - Field: ‘expr’
[18:04:14.534]   - Field: ‘uuid’
[18:04:14.534]   - Field: ‘seed’
[18:04:14.534]   - Field: ‘version’
[18:04:14.534]   - Field: ‘result’
[18:04:14.534]   - Field: ‘asynchronous’
[18:04:14.535]   - Field: ‘calls’
[18:04:14.535]   - Field: ‘globals’
[18:04:14.535]   - Field: ‘stdout’
[18:04:14.535]   - Field: ‘earlySignal’
[18:04:14.536]   - Field: ‘lazy’
[18:04:14.536]   - Field: ‘state’
[18:04:14.536] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.536] - Launch lazy future ...
[18:04:14.537] Packages needed by the future expression (n = 0): <none>
[18:04:14.537] Packages needed by future strategies (n = 0): <none>
[18:04:14.538] {
[18:04:14.538]     {
[18:04:14.538]         {
[18:04:14.538]             ...future.startTime <- base::Sys.time()
[18:04:14.538]             {
[18:04:14.538]                 {
[18:04:14.538]                   {
[18:04:14.538]                     base::local({
[18:04:14.538]                       has_future <- base::requireNamespace("future", 
[18:04:14.538]                         quietly = TRUE)
[18:04:14.538]                       if (has_future) {
[18:04:14.538]                         ns <- base::getNamespace("future")
[18:04:14.538]                         version <- ns[[".package"]][["version"]]
[18:04:14.538]                         if (is.null(version)) 
[18:04:14.538]                           version <- utils::packageVersion("future")
[18:04:14.538]                       }
[18:04:14.538]                       else {
[18:04:14.538]                         version <- NULL
[18:04:14.538]                       }
[18:04:14.538]                       if (!has_future || version < "1.8.0") {
[18:04:14.538]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.538]                           "", base::R.version$version.string), 
[18:04:14.538]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.538]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.538]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.538]                             "release", "version")], collapse = " "), 
[18:04:14.538]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.538]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.538]                           info)
[18:04:14.538]                         info <- base::paste(info, collapse = "; ")
[18:04:14.538]                         if (!has_future) {
[18:04:14.538]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.538]                             info)
[18:04:14.538]                         }
[18:04:14.538]                         else {
[18:04:14.538]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.538]                             info, version)
[18:04:14.538]                         }
[18:04:14.538]                         base::stop(msg)
[18:04:14.538]                       }
[18:04:14.538]                     })
[18:04:14.538]                   }
[18:04:14.538]                   ...future.strategy.old <- future::plan("list")
[18:04:14.538]                   options(future.plan = NULL)
[18:04:14.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.538]                 }
[18:04:14.538]                 ...future.workdir <- getwd()
[18:04:14.538]             }
[18:04:14.538]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.538]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.538]         }
[18:04:14.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.538]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.538]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.538]             base::names(...future.oldOptions))
[18:04:14.538]     }
[18:04:14.538]     if (FALSE) {
[18:04:14.538]     }
[18:04:14.538]     else {
[18:04:14.538]         if (TRUE) {
[18:04:14.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.538]                 open = "w")
[18:04:14.538]         }
[18:04:14.538]         else {
[18:04:14.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.538]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.538]         }
[18:04:14.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.538]             base::sink(type = "output", split = FALSE)
[18:04:14.538]             base::close(...future.stdout)
[18:04:14.538]         }, add = TRUE)
[18:04:14.538]     }
[18:04:14.538]     ...future.frame <- base::sys.nframe()
[18:04:14.538]     ...future.conditions <- base::list()
[18:04:14.538]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.538]     if (FALSE) {
[18:04:14.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.538]     }
[18:04:14.538]     ...future.result <- base::tryCatch({
[18:04:14.538]         base::withCallingHandlers({
[18:04:14.538]             ...future.value <- base::withVisible(base::local({
[18:04:14.538]                 4
[18:04:14.538]             }))
[18:04:14.538]             future::FutureResult(value = ...future.value$value, 
[18:04:14.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.538]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.538]                     ...future.globalenv.names))
[18:04:14.538]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.538]         }, condition = base::local({
[18:04:14.538]             c <- base::c
[18:04:14.538]             inherits <- base::inherits
[18:04:14.538]             invokeRestart <- base::invokeRestart
[18:04:14.538]             length <- base::length
[18:04:14.538]             list <- base::list
[18:04:14.538]             seq.int <- base::seq.int
[18:04:14.538]             signalCondition <- base::signalCondition
[18:04:14.538]             sys.calls <- base::sys.calls
[18:04:14.538]             `[[` <- base::`[[`
[18:04:14.538]             `+` <- base::`+`
[18:04:14.538]             `<<-` <- base::`<<-`
[18:04:14.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.538]                   3L)]
[18:04:14.538]             }
[18:04:14.538]             function(cond) {
[18:04:14.538]                 is_error <- inherits(cond, "error")
[18:04:14.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.538]                   NULL)
[18:04:14.538]                 if (is_error) {
[18:04:14.538]                   sessionInformation <- function() {
[18:04:14.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.538]                       search = base::search(), system = base::Sys.info())
[18:04:14.538]                   }
[18:04:14.538]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.538]                     cond$call), session = sessionInformation(), 
[18:04:14.538]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.538]                   signalCondition(cond)
[18:04:14.538]                 }
[18:04:14.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.538]                 "immediateCondition"))) {
[18:04:14.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.538]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.538]                   if (TRUE && !signal) {
[18:04:14.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.538]                     {
[18:04:14.538]                       inherits <- base::inherits
[18:04:14.538]                       invokeRestart <- base::invokeRestart
[18:04:14.538]                       is.null <- base::is.null
[18:04:14.538]                       muffled <- FALSE
[18:04:14.538]                       if (inherits(cond, "message")) {
[18:04:14.538]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.538]                         if (muffled) 
[18:04:14.538]                           invokeRestart("muffleMessage")
[18:04:14.538]                       }
[18:04:14.538]                       else if (inherits(cond, "warning")) {
[18:04:14.538]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.538]                         if (muffled) 
[18:04:14.538]                           invokeRestart("muffleWarning")
[18:04:14.538]                       }
[18:04:14.538]                       else if (inherits(cond, "condition")) {
[18:04:14.538]                         if (!is.null(pattern)) {
[18:04:14.538]                           computeRestarts <- base::computeRestarts
[18:04:14.538]                           grepl <- base::grepl
[18:04:14.538]                           restarts <- computeRestarts(cond)
[18:04:14.538]                           for (restart in restarts) {
[18:04:14.538]                             name <- restart$name
[18:04:14.538]                             if (is.null(name)) 
[18:04:14.538]                               next
[18:04:14.538]                             if (!grepl(pattern, name)) 
[18:04:14.538]                               next
[18:04:14.538]                             invokeRestart(restart)
[18:04:14.538]                             muffled <- TRUE
[18:04:14.538]                             break
[18:04:14.538]                           }
[18:04:14.538]                         }
[18:04:14.538]                       }
[18:04:14.538]                       invisible(muffled)
[18:04:14.538]                     }
[18:04:14.538]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.538]                   }
[18:04:14.538]                 }
[18:04:14.538]                 else {
[18:04:14.538]                   if (TRUE) {
[18:04:14.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.538]                     {
[18:04:14.538]                       inherits <- base::inherits
[18:04:14.538]                       invokeRestart <- base::invokeRestart
[18:04:14.538]                       is.null <- base::is.null
[18:04:14.538]                       muffled <- FALSE
[18:04:14.538]                       if (inherits(cond, "message")) {
[18:04:14.538]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.538]                         if (muffled) 
[18:04:14.538]                           invokeRestart("muffleMessage")
[18:04:14.538]                       }
[18:04:14.538]                       else if (inherits(cond, "warning")) {
[18:04:14.538]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.538]                         if (muffled) 
[18:04:14.538]                           invokeRestart("muffleWarning")
[18:04:14.538]                       }
[18:04:14.538]                       else if (inherits(cond, "condition")) {
[18:04:14.538]                         if (!is.null(pattern)) {
[18:04:14.538]                           computeRestarts <- base::computeRestarts
[18:04:14.538]                           grepl <- base::grepl
[18:04:14.538]                           restarts <- computeRestarts(cond)
[18:04:14.538]                           for (restart in restarts) {
[18:04:14.538]                             name <- restart$name
[18:04:14.538]                             if (is.null(name)) 
[18:04:14.538]                               next
[18:04:14.538]                             if (!grepl(pattern, name)) 
[18:04:14.538]                               next
[18:04:14.538]                             invokeRestart(restart)
[18:04:14.538]                             muffled <- TRUE
[18:04:14.538]                             break
[18:04:14.538]                           }
[18:04:14.538]                         }
[18:04:14.538]                       }
[18:04:14.538]                       invisible(muffled)
[18:04:14.538]                     }
[18:04:14.538]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.538]                   }
[18:04:14.538]                 }
[18:04:14.538]             }
[18:04:14.538]         }))
[18:04:14.538]     }, error = function(ex) {
[18:04:14.538]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.538]                 ...future.rng), started = ...future.startTime, 
[18:04:14.538]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.538]             version = "1.8"), class = "FutureResult")
[18:04:14.538]     }, finally = {
[18:04:14.538]         if (!identical(...future.workdir, getwd())) 
[18:04:14.538]             setwd(...future.workdir)
[18:04:14.538]         {
[18:04:14.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.538]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.538]             }
[18:04:14.538]             base::options(...future.oldOptions)
[18:04:14.538]             if (.Platform$OS.type == "windows") {
[18:04:14.538]                 old_names <- names(...future.oldEnvVars)
[18:04:14.538]                 envs <- base::Sys.getenv()
[18:04:14.538]                 names <- names(envs)
[18:04:14.538]                 common <- intersect(names, old_names)
[18:04:14.538]                 added <- setdiff(names, old_names)
[18:04:14.538]                 removed <- setdiff(old_names, names)
[18:04:14.538]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.538]                   envs[common]]
[18:04:14.538]                 NAMES <- toupper(changed)
[18:04:14.538]                 args <- list()
[18:04:14.538]                 for (kk in seq_along(NAMES)) {
[18:04:14.538]                   name <- changed[[kk]]
[18:04:14.538]                   NAME <- NAMES[[kk]]
[18:04:14.538]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.538]                     next
[18:04:14.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.538]                 }
[18:04:14.538]                 NAMES <- toupper(added)
[18:04:14.538]                 for (kk in seq_along(NAMES)) {
[18:04:14.538]                   name <- added[[kk]]
[18:04:14.538]                   NAME <- NAMES[[kk]]
[18:04:14.538]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.538]                     next
[18:04:14.538]                   args[[name]] <- ""
[18:04:14.538]                 }
[18:04:14.538]                 NAMES <- toupper(removed)
[18:04:14.538]                 for (kk in seq_along(NAMES)) {
[18:04:14.538]                   name <- removed[[kk]]
[18:04:14.538]                   NAME <- NAMES[[kk]]
[18:04:14.538]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.538]                     next
[18:04:14.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.538]                 }
[18:04:14.538]                 if (length(args) > 0) 
[18:04:14.538]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.538]             }
[18:04:14.538]             else {
[18:04:14.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.538]             }
[18:04:14.538]             {
[18:04:14.538]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.538]                   0L) {
[18:04:14.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.538]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.538]                   base::options(opts)
[18:04:14.538]                 }
[18:04:14.538]                 {
[18:04:14.538]                   {
[18:04:14.538]                     NULL
[18:04:14.538]                     RNGkind("Mersenne-Twister")
[18:04:14.538]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.538]                       inherits = FALSE)
[18:04:14.538]                   }
[18:04:14.538]                   options(future.plan = NULL)
[18:04:14.538]                   if (is.na(NA_character_)) 
[18:04:14.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.538]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.538]                     .init = FALSE)
[18:04:14.538]                 }
[18:04:14.538]             }
[18:04:14.538]         }
[18:04:14.538]     })
[18:04:14.538]     if (TRUE) {
[18:04:14.538]         base::sink(type = "output", split = FALSE)
[18:04:14.538]         if (TRUE) {
[18:04:14.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.538]         }
[18:04:14.538]         else {
[18:04:14.538]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.538]         }
[18:04:14.538]         base::close(...future.stdout)
[18:04:14.538]         ...future.stdout <- NULL
[18:04:14.538]     }
[18:04:14.538]     ...future.result$conditions <- ...future.conditions
[18:04:14.538]     ...future.result$finished <- base::Sys.time()
[18:04:14.538]     ...future.result
[18:04:14.538] }
[18:04:14.541] plan(): Setting new future strategy stack:
[18:04:14.542] List of future strategies:
[18:04:14.542] 1. sequential:
[18:04:14.542]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.542]    - tweaked: FALSE
[18:04:14.542]    - call: NULL
[18:04:14.543] plan(): nbrOfWorkers() = 1
[18:04:14.544] plan(): Setting new future strategy stack:
[18:04:14.545] List of future strategies:
[18:04:14.545] 1. sequential:
[18:04:14.545]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.545]    - tweaked: FALSE
[18:04:14.545]    - call: plan(strategy)
[18:04:14.546] plan(): nbrOfWorkers() = 1
[18:04:14.546] SequentialFuture started (and completed)
[18:04:14.546] - Launch lazy future ... done
[18:04:14.546] run() for ‘SequentialFuture’ ... done
<environment: 0x5e3c2b2fc7e8> 
<environment: 0x5e3c2afd4550> 
[18:04:14.550] resolved() for ‘SequentialFuture’ ...
[18:04:14.550] - state: ‘finished’
[18:04:14.550] - run: TRUE
[18:04:14.550] - result: ‘FutureResult’
[18:04:14.551] resolved() for ‘SequentialFuture’ ... done
[18:04:14.551] resolved() for ‘SequentialFuture’ ...
[18:04:14.551] - state: ‘finished’
[18:04:14.551] - run: TRUE
[18:04:14.551] - result: ‘FutureResult’
[18:04:14.552] resolved() for ‘SequentialFuture’ ... done
[18:04:14.552] resolved() for ‘SequentialFuture’ ...
[18:04:14.552] - state: ‘finished’
[18:04:14.552] - run: TRUE
[18:04:14.552] - result: ‘FutureResult’
[18:04:14.553] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:14.556] resolve() on environment ...
[18:04:14.556]  recursive: 0
[18:04:14.557]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:14.557] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.558] - nx: 4
[18:04:14.558] - relay: TRUE
[18:04:14.558] - stdout: TRUE
[18:04:14.558] - signal: TRUE
[18:04:14.558] - resignal: FALSE
[18:04:14.558] - force: TRUE
[18:04:14.559] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.559] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.559]  - until=2
[18:04:14.559]  - relaying element #2
[18:04:14.559] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.560] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.560] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.560]  length: 3 (resolved future 1)
[18:04:14.560] resolved() for ‘SequentialFuture’ ...
[18:04:14.561] - state: ‘finished’
[18:04:14.561] - run: TRUE
[18:04:14.561] - result: ‘FutureResult’
[18:04:14.561] resolved() for ‘SequentialFuture’ ... done
[18:04:14.561] Future #2
[18:04:14.562] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.562] - nx: 4
[18:04:14.562] - relay: TRUE
[18:04:14.562] - stdout: TRUE
[18:04:14.562] - signal: TRUE
[18:04:14.563] - resignal: FALSE
[18:04:14.563] - force: TRUE
[18:04:14.563] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.563] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.563]  - until=2
[18:04:14.564]  - relaying element #2
[18:04:14.564] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.564] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.564] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.565]  length: 2 (resolved future 2)
[18:04:14.565] resolved() for ‘SequentialFuture’ ...
[18:04:14.565] - state: ‘finished’
[18:04:14.565] - run: TRUE
[18:04:14.565] - result: ‘FutureResult’
[18:04:14.566] resolved() for ‘SequentialFuture’ ... done
[18:04:14.566] Future #3
[18:04:14.566] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.566] - nx: 4
[18:04:14.567] - relay: TRUE
[18:04:14.567] - stdout: TRUE
[18:04:14.567] - signal: TRUE
[18:04:14.567] - resignal: FALSE
[18:04:14.567] - force: TRUE
[18:04:14.567] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.568] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.568]  - until=3
[18:04:14.568]  - relaying element #3
[18:04:14.568] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.569] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.569] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.569]  length: 1 (resolved future 3)
[18:04:14.569] resolved() for ‘SequentialFuture’ ...
[18:04:14.570] - state: ‘finished’
[18:04:14.570] - run: TRUE
[18:04:14.570] - result: ‘FutureResult’
[18:04:14.570] resolved() for ‘SequentialFuture’ ... done
[18:04:14.570] Future #4
[18:04:14.571] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:14.571] - nx: 4
[18:04:14.571] - relay: TRUE
[18:04:14.571] - stdout: TRUE
[18:04:14.571] - signal: TRUE
[18:04:14.572] - resignal: FALSE
[18:04:14.572] - force: TRUE
[18:04:14.572] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.572] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.572]  - until=4
[18:04:14.573]  - relaying element #4
[18:04:14.573] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.573] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.573] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:14.574]  length: 0 (resolved future 4)
[18:04:14.574] Relaying remaining futures
[18:04:14.574] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.574] - nx: 4
[18:04:14.574] - relay: TRUE
[18:04:14.574] - stdout: TRUE
[18:04:14.575] - signal: TRUE
[18:04:14.575] - resignal: FALSE
[18:04:14.578] - force: TRUE
[18:04:14.578] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.578] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:14.579] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.579] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.579] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.579] resolve() on environment ... DONE
<environment: 0x5e3c2b1ef188> 
Dimensions: c(1, 6)
[18:04:14.581] getGlobalsAndPackages() ...
[18:04:14.581] Searching for globals...
[18:04:14.582] 
[18:04:14.582] Searching for globals ... DONE
[18:04:14.582] - globals: [0] <none>
[18:04:14.582] getGlobalsAndPackages() ... DONE
[18:04:14.583] run() for ‘Future’ ...
[18:04:14.583] - state: ‘created’
[18:04:14.583] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.584] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.584] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.584]   - Field: ‘label’
[18:04:14.585]   - Field: ‘local’
[18:04:14.585]   - Field: ‘owner’
[18:04:14.585]   - Field: ‘envir’
[18:04:14.585]   - Field: ‘packages’
[18:04:14.585]   - Field: ‘gc’
[18:04:14.586]   - Field: ‘conditions’
[18:04:14.586]   - Field: ‘expr’
[18:04:14.586]   - Field: ‘uuid’
[18:04:14.586]   - Field: ‘seed’
[18:04:14.586]   - Field: ‘version’
[18:04:14.587]   - Field: ‘result’
[18:04:14.587]   - Field: ‘asynchronous’
[18:04:14.587]   - Field: ‘calls’
[18:04:14.587]   - Field: ‘globals’
[18:04:14.587]   - Field: ‘stdout’
[18:04:14.588]   - Field: ‘earlySignal’
[18:04:14.588]   - Field: ‘lazy’
[18:04:14.588]   - Field: ‘state’
[18:04:14.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.588] - Launch lazy future ...
[18:04:14.589] Packages needed by the future expression (n = 0): <none>
[18:04:14.589] Packages needed by future strategies (n = 0): <none>
[18:04:14.590] {
[18:04:14.590]     {
[18:04:14.590]         {
[18:04:14.590]             ...future.startTime <- base::Sys.time()
[18:04:14.590]             {
[18:04:14.590]                 {
[18:04:14.590]                   {
[18:04:14.590]                     base::local({
[18:04:14.590]                       has_future <- base::requireNamespace("future", 
[18:04:14.590]                         quietly = TRUE)
[18:04:14.590]                       if (has_future) {
[18:04:14.590]                         ns <- base::getNamespace("future")
[18:04:14.590]                         version <- ns[[".package"]][["version"]]
[18:04:14.590]                         if (is.null(version)) 
[18:04:14.590]                           version <- utils::packageVersion("future")
[18:04:14.590]                       }
[18:04:14.590]                       else {
[18:04:14.590]                         version <- NULL
[18:04:14.590]                       }
[18:04:14.590]                       if (!has_future || version < "1.8.0") {
[18:04:14.590]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.590]                           "", base::R.version$version.string), 
[18:04:14.590]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.590]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.590]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.590]                             "release", "version")], collapse = " "), 
[18:04:14.590]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.590]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.590]                           info)
[18:04:14.590]                         info <- base::paste(info, collapse = "; ")
[18:04:14.590]                         if (!has_future) {
[18:04:14.590]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.590]                             info)
[18:04:14.590]                         }
[18:04:14.590]                         else {
[18:04:14.590]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.590]                             info, version)
[18:04:14.590]                         }
[18:04:14.590]                         base::stop(msg)
[18:04:14.590]                       }
[18:04:14.590]                     })
[18:04:14.590]                   }
[18:04:14.590]                   ...future.strategy.old <- future::plan("list")
[18:04:14.590]                   options(future.plan = NULL)
[18:04:14.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.590]                 }
[18:04:14.590]                 ...future.workdir <- getwd()
[18:04:14.590]             }
[18:04:14.590]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.590]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.590]         }
[18:04:14.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.590]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.590]             base::names(...future.oldOptions))
[18:04:14.590]     }
[18:04:14.590]     if (FALSE) {
[18:04:14.590]     }
[18:04:14.590]     else {
[18:04:14.590]         if (TRUE) {
[18:04:14.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.590]                 open = "w")
[18:04:14.590]         }
[18:04:14.590]         else {
[18:04:14.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.590]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.590]         }
[18:04:14.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.590]             base::sink(type = "output", split = FALSE)
[18:04:14.590]             base::close(...future.stdout)
[18:04:14.590]         }, add = TRUE)
[18:04:14.590]     }
[18:04:14.590]     ...future.frame <- base::sys.nframe()
[18:04:14.590]     ...future.conditions <- base::list()
[18:04:14.590]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.590]     if (FALSE) {
[18:04:14.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.590]     }
[18:04:14.590]     ...future.result <- base::tryCatch({
[18:04:14.590]         base::withCallingHandlers({
[18:04:14.590]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.590]             future::FutureResult(value = ...future.value$value, 
[18:04:14.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.590]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.590]                     ...future.globalenv.names))
[18:04:14.590]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.590]         }, condition = base::local({
[18:04:14.590]             c <- base::c
[18:04:14.590]             inherits <- base::inherits
[18:04:14.590]             invokeRestart <- base::invokeRestart
[18:04:14.590]             length <- base::length
[18:04:14.590]             list <- base::list
[18:04:14.590]             seq.int <- base::seq.int
[18:04:14.590]             signalCondition <- base::signalCondition
[18:04:14.590]             sys.calls <- base::sys.calls
[18:04:14.590]             `[[` <- base::`[[`
[18:04:14.590]             `+` <- base::`+`
[18:04:14.590]             `<<-` <- base::`<<-`
[18:04:14.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.590]                   3L)]
[18:04:14.590]             }
[18:04:14.590]             function(cond) {
[18:04:14.590]                 is_error <- inherits(cond, "error")
[18:04:14.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.590]                   NULL)
[18:04:14.590]                 if (is_error) {
[18:04:14.590]                   sessionInformation <- function() {
[18:04:14.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.590]                       search = base::search(), system = base::Sys.info())
[18:04:14.590]                   }
[18:04:14.590]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.590]                     cond$call), session = sessionInformation(), 
[18:04:14.590]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.590]                   signalCondition(cond)
[18:04:14.590]                 }
[18:04:14.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.590]                 "immediateCondition"))) {
[18:04:14.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.590]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.590]                   if (TRUE && !signal) {
[18:04:14.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.590]                     {
[18:04:14.590]                       inherits <- base::inherits
[18:04:14.590]                       invokeRestart <- base::invokeRestart
[18:04:14.590]                       is.null <- base::is.null
[18:04:14.590]                       muffled <- FALSE
[18:04:14.590]                       if (inherits(cond, "message")) {
[18:04:14.590]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.590]                         if (muffled) 
[18:04:14.590]                           invokeRestart("muffleMessage")
[18:04:14.590]                       }
[18:04:14.590]                       else if (inherits(cond, "warning")) {
[18:04:14.590]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.590]                         if (muffled) 
[18:04:14.590]                           invokeRestart("muffleWarning")
[18:04:14.590]                       }
[18:04:14.590]                       else if (inherits(cond, "condition")) {
[18:04:14.590]                         if (!is.null(pattern)) {
[18:04:14.590]                           computeRestarts <- base::computeRestarts
[18:04:14.590]                           grepl <- base::grepl
[18:04:14.590]                           restarts <- computeRestarts(cond)
[18:04:14.590]                           for (restart in restarts) {
[18:04:14.590]                             name <- restart$name
[18:04:14.590]                             if (is.null(name)) 
[18:04:14.590]                               next
[18:04:14.590]                             if (!grepl(pattern, name)) 
[18:04:14.590]                               next
[18:04:14.590]                             invokeRestart(restart)
[18:04:14.590]                             muffled <- TRUE
[18:04:14.590]                             break
[18:04:14.590]                           }
[18:04:14.590]                         }
[18:04:14.590]                       }
[18:04:14.590]                       invisible(muffled)
[18:04:14.590]                     }
[18:04:14.590]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.590]                   }
[18:04:14.590]                 }
[18:04:14.590]                 else {
[18:04:14.590]                   if (TRUE) {
[18:04:14.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.590]                     {
[18:04:14.590]                       inherits <- base::inherits
[18:04:14.590]                       invokeRestart <- base::invokeRestart
[18:04:14.590]                       is.null <- base::is.null
[18:04:14.590]                       muffled <- FALSE
[18:04:14.590]                       if (inherits(cond, "message")) {
[18:04:14.590]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.590]                         if (muffled) 
[18:04:14.590]                           invokeRestart("muffleMessage")
[18:04:14.590]                       }
[18:04:14.590]                       else if (inherits(cond, "warning")) {
[18:04:14.590]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.590]                         if (muffled) 
[18:04:14.590]                           invokeRestart("muffleWarning")
[18:04:14.590]                       }
[18:04:14.590]                       else if (inherits(cond, "condition")) {
[18:04:14.590]                         if (!is.null(pattern)) {
[18:04:14.590]                           computeRestarts <- base::computeRestarts
[18:04:14.590]                           grepl <- base::grepl
[18:04:14.590]                           restarts <- computeRestarts(cond)
[18:04:14.590]                           for (restart in restarts) {
[18:04:14.590]                             name <- restart$name
[18:04:14.590]                             if (is.null(name)) 
[18:04:14.590]                               next
[18:04:14.590]                             if (!grepl(pattern, name)) 
[18:04:14.590]                               next
[18:04:14.590]                             invokeRestart(restart)
[18:04:14.590]                             muffled <- TRUE
[18:04:14.590]                             break
[18:04:14.590]                           }
[18:04:14.590]                         }
[18:04:14.590]                       }
[18:04:14.590]                       invisible(muffled)
[18:04:14.590]                     }
[18:04:14.590]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.590]                   }
[18:04:14.590]                 }
[18:04:14.590]             }
[18:04:14.590]         }))
[18:04:14.590]     }, error = function(ex) {
[18:04:14.590]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.590]                 ...future.rng), started = ...future.startTime, 
[18:04:14.590]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.590]             version = "1.8"), class = "FutureResult")
[18:04:14.590]     }, finally = {
[18:04:14.590]         if (!identical(...future.workdir, getwd())) 
[18:04:14.590]             setwd(...future.workdir)
[18:04:14.590]         {
[18:04:14.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.590]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.590]             }
[18:04:14.590]             base::options(...future.oldOptions)
[18:04:14.590]             if (.Platform$OS.type == "windows") {
[18:04:14.590]                 old_names <- names(...future.oldEnvVars)
[18:04:14.590]                 envs <- base::Sys.getenv()
[18:04:14.590]                 names <- names(envs)
[18:04:14.590]                 common <- intersect(names, old_names)
[18:04:14.590]                 added <- setdiff(names, old_names)
[18:04:14.590]                 removed <- setdiff(old_names, names)
[18:04:14.590]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.590]                   envs[common]]
[18:04:14.590]                 NAMES <- toupper(changed)
[18:04:14.590]                 args <- list()
[18:04:14.590]                 for (kk in seq_along(NAMES)) {
[18:04:14.590]                   name <- changed[[kk]]
[18:04:14.590]                   NAME <- NAMES[[kk]]
[18:04:14.590]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.590]                     next
[18:04:14.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.590]                 }
[18:04:14.590]                 NAMES <- toupper(added)
[18:04:14.590]                 for (kk in seq_along(NAMES)) {
[18:04:14.590]                   name <- added[[kk]]
[18:04:14.590]                   NAME <- NAMES[[kk]]
[18:04:14.590]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.590]                     next
[18:04:14.590]                   args[[name]] <- ""
[18:04:14.590]                 }
[18:04:14.590]                 NAMES <- toupper(removed)
[18:04:14.590]                 for (kk in seq_along(NAMES)) {
[18:04:14.590]                   name <- removed[[kk]]
[18:04:14.590]                   NAME <- NAMES[[kk]]
[18:04:14.590]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.590]                     next
[18:04:14.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.590]                 }
[18:04:14.590]                 if (length(args) > 0) 
[18:04:14.590]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.590]             }
[18:04:14.590]             else {
[18:04:14.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.590]             }
[18:04:14.590]             {
[18:04:14.590]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.590]                   0L) {
[18:04:14.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.590]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.590]                   base::options(opts)
[18:04:14.590]                 }
[18:04:14.590]                 {
[18:04:14.590]                   {
[18:04:14.590]                     NULL
[18:04:14.590]                     RNGkind("Mersenne-Twister")
[18:04:14.590]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.590]                       inherits = FALSE)
[18:04:14.590]                   }
[18:04:14.590]                   options(future.plan = NULL)
[18:04:14.590]                   if (is.na(NA_character_)) 
[18:04:14.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.590]                     .init = FALSE)
[18:04:14.590]                 }
[18:04:14.590]             }
[18:04:14.590]         }
[18:04:14.590]     })
[18:04:14.590]     if (TRUE) {
[18:04:14.590]         base::sink(type = "output", split = FALSE)
[18:04:14.590]         if (TRUE) {
[18:04:14.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.590]         }
[18:04:14.590]         else {
[18:04:14.590]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.590]         }
[18:04:14.590]         base::close(...future.stdout)
[18:04:14.590]         ...future.stdout <- NULL
[18:04:14.590]     }
[18:04:14.590]     ...future.result$conditions <- ...future.conditions
[18:04:14.590]     ...future.result$finished <- base::Sys.time()
[18:04:14.590]     ...future.result
[18:04:14.590] }
[18:04:14.594] plan(): Setting new future strategy stack:
[18:04:14.594] List of future strategies:
[18:04:14.594] 1. sequential:
[18:04:14.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.594]    - tweaked: FALSE
[18:04:14.594]    - call: NULL
[18:04:14.595] plan(): nbrOfWorkers() = 1
[18:04:14.596] plan(): Setting new future strategy stack:
[18:04:14.597] List of future strategies:
[18:04:14.597] 1. sequential:
[18:04:14.597]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.597]    - tweaked: FALSE
[18:04:14.597]    - call: plan(strategy)
[18:04:14.598] plan(): nbrOfWorkers() = 1
[18:04:14.598] SequentialFuture started (and completed)
[18:04:14.598] - Launch lazy future ... done
[18:04:14.599] run() for ‘SequentialFuture’ ... done
[18:04:14.599] getGlobalsAndPackages() ...
[18:04:14.599] Searching for globals...
[18:04:14.600] 
[18:04:14.600] Searching for globals ... DONE
[18:04:14.600] - globals: [0] <none>
[18:04:14.600] getGlobalsAndPackages() ... DONE
[18:04:14.601] run() for ‘Future’ ...
[18:04:14.601] - state: ‘created’
[18:04:14.601] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.602] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.602] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.603]   - Field: ‘label’
[18:04:14.603]   - Field: ‘local’
[18:04:14.603]   - Field: ‘owner’
[18:04:14.603]   - Field: ‘envir’
[18:04:14.603]   - Field: ‘packages’
[18:04:14.604]   - Field: ‘gc’
[18:04:14.604]   - Field: ‘conditions’
[18:04:14.604]   - Field: ‘expr’
[18:04:14.604]   - Field: ‘uuid’
[18:04:14.604]   - Field: ‘seed’
[18:04:14.605]   - Field: ‘version’
[18:04:14.605]   - Field: ‘result’
[18:04:14.605]   - Field: ‘asynchronous’
[18:04:14.605]   - Field: ‘calls’
[18:04:14.605]   - Field: ‘globals’
[18:04:14.606]   - Field: ‘stdout’
[18:04:14.606]   - Field: ‘earlySignal’
[18:04:14.606]   - Field: ‘lazy’
[18:04:14.606]   - Field: ‘state’
[18:04:14.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.607] - Launch lazy future ...
[18:04:14.607] Packages needed by the future expression (n = 0): <none>
[18:04:14.607] Packages needed by future strategies (n = 0): <none>
[18:04:14.608] {
[18:04:14.608]     {
[18:04:14.608]         {
[18:04:14.608]             ...future.startTime <- base::Sys.time()
[18:04:14.608]             {
[18:04:14.608]                 {
[18:04:14.608]                   {
[18:04:14.608]                     base::local({
[18:04:14.608]                       has_future <- base::requireNamespace("future", 
[18:04:14.608]                         quietly = TRUE)
[18:04:14.608]                       if (has_future) {
[18:04:14.608]                         ns <- base::getNamespace("future")
[18:04:14.608]                         version <- ns[[".package"]][["version"]]
[18:04:14.608]                         if (is.null(version)) 
[18:04:14.608]                           version <- utils::packageVersion("future")
[18:04:14.608]                       }
[18:04:14.608]                       else {
[18:04:14.608]                         version <- NULL
[18:04:14.608]                       }
[18:04:14.608]                       if (!has_future || version < "1.8.0") {
[18:04:14.608]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.608]                           "", base::R.version$version.string), 
[18:04:14.608]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.608]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.608]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.608]                             "release", "version")], collapse = " "), 
[18:04:14.608]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.608]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.608]                           info)
[18:04:14.608]                         info <- base::paste(info, collapse = "; ")
[18:04:14.608]                         if (!has_future) {
[18:04:14.608]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.608]                             info)
[18:04:14.608]                         }
[18:04:14.608]                         else {
[18:04:14.608]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.608]                             info, version)
[18:04:14.608]                         }
[18:04:14.608]                         base::stop(msg)
[18:04:14.608]                       }
[18:04:14.608]                     })
[18:04:14.608]                   }
[18:04:14.608]                   ...future.strategy.old <- future::plan("list")
[18:04:14.608]                   options(future.plan = NULL)
[18:04:14.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.608]                 }
[18:04:14.608]                 ...future.workdir <- getwd()
[18:04:14.608]             }
[18:04:14.608]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.608]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.608]         }
[18:04:14.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.608]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.608]             base::names(...future.oldOptions))
[18:04:14.608]     }
[18:04:14.608]     if (FALSE) {
[18:04:14.608]     }
[18:04:14.608]     else {
[18:04:14.608]         if (TRUE) {
[18:04:14.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.608]                 open = "w")
[18:04:14.608]         }
[18:04:14.608]         else {
[18:04:14.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.608]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.608]         }
[18:04:14.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.608]             base::sink(type = "output", split = FALSE)
[18:04:14.608]             base::close(...future.stdout)
[18:04:14.608]         }, add = TRUE)
[18:04:14.608]     }
[18:04:14.608]     ...future.frame <- base::sys.nframe()
[18:04:14.608]     ...future.conditions <- base::list()
[18:04:14.608]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.608]     if (FALSE) {
[18:04:14.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.608]     }
[18:04:14.608]     ...future.result <- base::tryCatch({
[18:04:14.608]         base::withCallingHandlers({
[18:04:14.608]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.608]             future::FutureResult(value = ...future.value$value, 
[18:04:14.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.608]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.608]                     ...future.globalenv.names))
[18:04:14.608]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.608]         }, condition = base::local({
[18:04:14.608]             c <- base::c
[18:04:14.608]             inherits <- base::inherits
[18:04:14.608]             invokeRestart <- base::invokeRestart
[18:04:14.608]             length <- base::length
[18:04:14.608]             list <- base::list
[18:04:14.608]             seq.int <- base::seq.int
[18:04:14.608]             signalCondition <- base::signalCondition
[18:04:14.608]             sys.calls <- base::sys.calls
[18:04:14.608]             `[[` <- base::`[[`
[18:04:14.608]             `+` <- base::`+`
[18:04:14.608]             `<<-` <- base::`<<-`
[18:04:14.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.608]                   3L)]
[18:04:14.608]             }
[18:04:14.608]             function(cond) {
[18:04:14.608]                 is_error <- inherits(cond, "error")
[18:04:14.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.608]                   NULL)
[18:04:14.608]                 if (is_error) {
[18:04:14.608]                   sessionInformation <- function() {
[18:04:14.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.608]                       search = base::search(), system = base::Sys.info())
[18:04:14.608]                   }
[18:04:14.608]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.608]                     cond$call), session = sessionInformation(), 
[18:04:14.608]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.608]                   signalCondition(cond)
[18:04:14.608]                 }
[18:04:14.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.608]                 "immediateCondition"))) {
[18:04:14.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.608]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.608]                   if (TRUE && !signal) {
[18:04:14.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.608]                     {
[18:04:14.608]                       inherits <- base::inherits
[18:04:14.608]                       invokeRestart <- base::invokeRestart
[18:04:14.608]                       is.null <- base::is.null
[18:04:14.608]                       muffled <- FALSE
[18:04:14.608]                       if (inherits(cond, "message")) {
[18:04:14.608]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.608]                         if (muffled) 
[18:04:14.608]                           invokeRestart("muffleMessage")
[18:04:14.608]                       }
[18:04:14.608]                       else if (inherits(cond, "warning")) {
[18:04:14.608]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.608]                         if (muffled) 
[18:04:14.608]                           invokeRestart("muffleWarning")
[18:04:14.608]                       }
[18:04:14.608]                       else if (inherits(cond, "condition")) {
[18:04:14.608]                         if (!is.null(pattern)) {
[18:04:14.608]                           computeRestarts <- base::computeRestarts
[18:04:14.608]                           grepl <- base::grepl
[18:04:14.608]                           restarts <- computeRestarts(cond)
[18:04:14.608]                           for (restart in restarts) {
[18:04:14.608]                             name <- restart$name
[18:04:14.608]                             if (is.null(name)) 
[18:04:14.608]                               next
[18:04:14.608]                             if (!grepl(pattern, name)) 
[18:04:14.608]                               next
[18:04:14.608]                             invokeRestart(restart)
[18:04:14.608]                             muffled <- TRUE
[18:04:14.608]                             break
[18:04:14.608]                           }
[18:04:14.608]                         }
[18:04:14.608]                       }
[18:04:14.608]                       invisible(muffled)
[18:04:14.608]                     }
[18:04:14.608]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.608]                   }
[18:04:14.608]                 }
[18:04:14.608]                 else {
[18:04:14.608]                   if (TRUE) {
[18:04:14.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.608]                     {
[18:04:14.608]                       inherits <- base::inherits
[18:04:14.608]                       invokeRestart <- base::invokeRestart
[18:04:14.608]                       is.null <- base::is.null
[18:04:14.608]                       muffled <- FALSE
[18:04:14.608]                       if (inherits(cond, "message")) {
[18:04:14.608]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.608]                         if (muffled) 
[18:04:14.608]                           invokeRestart("muffleMessage")
[18:04:14.608]                       }
[18:04:14.608]                       else if (inherits(cond, "warning")) {
[18:04:14.608]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.608]                         if (muffled) 
[18:04:14.608]                           invokeRestart("muffleWarning")
[18:04:14.608]                       }
[18:04:14.608]                       else if (inherits(cond, "condition")) {
[18:04:14.608]                         if (!is.null(pattern)) {
[18:04:14.608]                           computeRestarts <- base::computeRestarts
[18:04:14.608]                           grepl <- base::grepl
[18:04:14.608]                           restarts <- computeRestarts(cond)
[18:04:14.608]                           for (restart in restarts) {
[18:04:14.608]                             name <- restart$name
[18:04:14.608]                             if (is.null(name)) 
[18:04:14.608]                               next
[18:04:14.608]                             if (!grepl(pattern, name)) 
[18:04:14.608]                               next
[18:04:14.608]                             invokeRestart(restart)
[18:04:14.608]                             muffled <- TRUE
[18:04:14.608]                             break
[18:04:14.608]                           }
[18:04:14.608]                         }
[18:04:14.608]                       }
[18:04:14.608]                       invisible(muffled)
[18:04:14.608]                     }
[18:04:14.608]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.608]                   }
[18:04:14.608]                 }
[18:04:14.608]             }
[18:04:14.608]         }))
[18:04:14.608]     }, error = function(ex) {
[18:04:14.608]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.608]                 ...future.rng), started = ...future.startTime, 
[18:04:14.608]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.608]             version = "1.8"), class = "FutureResult")
[18:04:14.608]     }, finally = {
[18:04:14.608]         if (!identical(...future.workdir, getwd())) 
[18:04:14.608]             setwd(...future.workdir)
[18:04:14.608]         {
[18:04:14.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.608]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.608]             }
[18:04:14.608]             base::options(...future.oldOptions)
[18:04:14.608]             if (.Platform$OS.type == "windows") {
[18:04:14.608]                 old_names <- names(...future.oldEnvVars)
[18:04:14.608]                 envs <- base::Sys.getenv()
[18:04:14.608]                 names <- names(envs)
[18:04:14.608]                 common <- intersect(names, old_names)
[18:04:14.608]                 added <- setdiff(names, old_names)
[18:04:14.608]                 removed <- setdiff(old_names, names)
[18:04:14.608]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.608]                   envs[common]]
[18:04:14.608]                 NAMES <- toupper(changed)
[18:04:14.608]                 args <- list()
[18:04:14.608]                 for (kk in seq_along(NAMES)) {
[18:04:14.608]                   name <- changed[[kk]]
[18:04:14.608]                   NAME <- NAMES[[kk]]
[18:04:14.608]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.608]                     next
[18:04:14.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.608]                 }
[18:04:14.608]                 NAMES <- toupper(added)
[18:04:14.608]                 for (kk in seq_along(NAMES)) {
[18:04:14.608]                   name <- added[[kk]]
[18:04:14.608]                   NAME <- NAMES[[kk]]
[18:04:14.608]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.608]                     next
[18:04:14.608]                   args[[name]] <- ""
[18:04:14.608]                 }
[18:04:14.608]                 NAMES <- toupper(removed)
[18:04:14.608]                 for (kk in seq_along(NAMES)) {
[18:04:14.608]                   name <- removed[[kk]]
[18:04:14.608]                   NAME <- NAMES[[kk]]
[18:04:14.608]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.608]                     next
[18:04:14.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.608]                 }
[18:04:14.608]                 if (length(args) > 0) 
[18:04:14.608]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.608]             }
[18:04:14.608]             else {
[18:04:14.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.608]             }
[18:04:14.608]             {
[18:04:14.608]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.608]                   0L) {
[18:04:14.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.608]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.608]                   base::options(opts)
[18:04:14.608]                 }
[18:04:14.608]                 {
[18:04:14.608]                   {
[18:04:14.608]                     NULL
[18:04:14.608]                     RNGkind("Mersenne-Twister")
[18:04:14.608]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.608]                       inherits = FALSE)
[18:04:14.608]                   }
[18:04:14.608]                   options(future.plan = NULL)
[18:04:14.608]                   if (is.na(NA_character_)) 
[18:04:14.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.608]                     .init = FALSE)
[18:04:14.608]                 }
[18:04:14.608]             }
[18:04:14.608]         }
[18:04:14.608]     })
[18:04:14.608]     if (TRUE) {
[18:04:14.608]         base::sink(type = "output", split = FALSE)
[18:04:14.608]         if (TRUE) {
[18:04:14.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.608]         }
[18:04:14.608]         else {
[18:04:14.608]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.608]         }
[18:04:14.608]         base::close(...future.stdout)
[18:04:14.608]         ...future.stdout <- NULL
[18:04:14.608]     }
[18:04:14.608]     ...future.result$conditions <- ...future.conditions
[18:04:14.608]     ...future.result$finished <- base::Sys.time()
[18:04:14.608]     ...future.result
[18:04:14.608] }
[18:04:14.612] plan(): Setting new future strategy stack:
[18:04:14.612] List of future strategies:
[18:04:14.612] 1. sequential:
[18:04:14.612]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.612]    - tweaked: FALSE
[18:04:14.612]    - call: NULL
[18:04:14.613] plan(): nbrOfWorkers() = 1
[18:04:14.615] plan(): Setting new future strategy stack:
[18:04:14.615] List of future strategies:
[18:04:14.615] 1. sequential:
[18:04:14.615]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.615]    - tweaked: FALSE
[18:04:14.615]    - call: plan(strategy)
[18:04:14.616] plan(): nbrOfWorkers() = 1
[18:04:14.616] SequentialFuture started (and completed)
[18:04:14.617] - Launch lazy future ... done
[18:04:14.617] run() for ‘SequentialFuture’ ... done
[18:04:14.618] getGlobalsAndPackages() ...
[18:04:14.618] Searching for globals...
[18:04:14.619] - globals found: [1] ‘{’
[18:04:14.619] Searching for globals ... DONE
[18:04:14.620] Resolving globals: FALSE
[18:04:14.620] 
[18:04:14.620] 
[18:04:14.621] getGlobalsAndPackages() ... DONE
[18:04:14.621] run() for ‘Future’ ...
[18:04:14.621] - state: ‘created’
[18:04:14.622] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.622] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.622] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.623]   - Field: ‘label’
[18:04:14.623]   - Field: ‘local’
[18:04:14.623]   - Field: ‘owner’
[18:04:14.623]   - Field: ‘envir’
[18:04:14.624]   - Field: ‘packages’
[18:04:14.624]   - Field: ‘gc’
[18:04:14.624]   - Field: ‘conditions’
[18:04:14.624]   - Field: ‘expr’
[18:04:14.624]   - Field: ‘uuid’
[18:04:14.625]   - Field: ‘seed’
[18:04:14.625]   - Field: ‘version’
[18:04:14.625]   - Field: ‘result’
[18:04:14.625]   - Field: ‘asynchronous’
[18:04:14.625]   - Field: ‘calls’
[18:04:14.626]   - Field: ‘globals’
[18:04:14.626]   - Field: ‘stdout’
[18:04:14.626]   - Field: ‘earlySignal’
[18:04:14.626]   - Field: ‘lazy’
[18:04:14.626]   - Field: ‘state’
[18:04:14.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.627] - Launch lazy future ...
[18:04:14.627] Packages needed by the future expression (n = 0): <none>
[18:04:14.627] Packages needed by future strategies (n = 0): <none>
[18:04:14.628] {
[18:04:14.628]     {
[18:04:14.628]         {
[18:04:14.628]             ...future.startTime <- base::Sys.time()
[18:04:14.628]             {
[18:04:14.628]                 {
[18:04:14.628]                   {
[18:04:14.628]                     base::local({
[18:04:14.628]                       has_future <- base::requireNamespace("future", 
[18:04:14.628]                         quietly = TRUE)
[18:04:14.628]                       if (has_future) {
[18:04:14.628]                         ns <- base::getNamespace("future")
[18:04:14.628]                         version <- ns[[".package"]][["version"]]
[18:04:14.628]                         if (is.null(version)) 
[18:04:14.628]                           version <- utils::packageVersion("future")
[18:04:14.628]                       }
[18:04:14.628]                       else {
[18:04:14.628]                         version <- NULL
[18:04:14.628]                       }
[18:04:14.628]                       if (!has_future || version < "1.8.0") {
[18:04:14.628]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.628]                           "", base::R.version$version.string), 
[18:04:14.628]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.628]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.628]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.628]                             "release", "version")], collapse = " "), 
[18:04:14.628]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.628]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.628]                           info)
[18:04:14.628]                         info <- base::paste(info, collapse = "; ")
[18:04:14.628]                         if (!has_future) {
[18:04:14.628]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.628]                             info)
[18:04:14.628]                         }
[18:04:14.628]                         else {
[18:04:14.628]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.628]                             info, version)
[18:04:14.628]                         }
[18:04:14.628]                         base::stop(msg)
[18:04:14.628]                       }
[18:04:14.628]                     })
[18:04:14.628]                   }
[18:04:14.628]                   ...future.strategy.old <- future::plan("list")
[18:04:14.628]                   options(future.plan = NULL)
[18:04:14.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.628]                 }
[18:04:14.628]                 ...future.workdir <- getwd()
[18:04:14.628]             }
[18:04:14.628]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.628]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.628]         }
[18:04:14.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.628]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.628]             base::names(...future.oldOptions))
[18:04:14.628]     }
[18:04:14.628]     if (FALSE) {
[18:04:14.628]     }
[18:04:14.628]     else {
[18:04:14.628]         if (TRUE) {
[18:04:14.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.628]                 open = "w")
[18:04:14.628]         }
[18:04:14.628]         else {
[18:04:14.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.628]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.628]         }
[18:04:14.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.628]             base::sink(type = "output", split = FALSE)
[18:04:14.628]             base::close(...future.stdout)
[18:04:14.628]         }, add = TRUE)
[18:04:14.628]     }
[18:04:14.628]     ...future.frame <- base::sys.nframe()
[18:04:14.628]     ...future.conditions <- base::list()
[18:04:14.628]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.628]     if (FALSE) {
[18:04:14.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.628]     }
[18:04:14.628]     ...future.result <- base::tryCatch({
[18:04:14.628]         base::withCallingHandlers({
[18:04:14.628]             ...future.value <- base::withVisible(base::local({
[18:04:14.628]                 4
[18:04:14.628]             }))
[18:04:14.628]             future::FutureResult(value = ...future.value$value, 
[18:04:14.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.628]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.628]                     ...future.globalenv.names))
[18:04:14.628]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.628]         }, condition = base::local({
[18:04:14.628]             c <- base::c
[18:04:14.628]             inherits <- base::inherits
[18:04:14.628]             invokeRestart <- base::invokeRestart
[18:04:14.628]             length <- base::length
[18:04:14.628]             list <- base::list
[18:04:14.628]             seq.int <- base::seq.int
[18:04:14.628]             signalCondition <- base::signalCondition
[18:04:14.628]             sys.calls <- base::sys.calls
[18:04:14.628]             `[[` <- base::`[[`
[18:04:14.628]             `+` <- base::`+`
[18:04:14.628]             `<<-` <- base::`<<-`
[18:04:14.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.628]                   3L)]
[18:04:14.628]             }
[18:04:14.628]             function(cond) {
[18:04:14.628]                 is_error <- inherits(cond, "error")
[18:04:14.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.628]                   NULL)
[18:04:14.628]                 if (is_error) {
[18:04:14.628]                   sessionInformation <- function() {
[18:04:14.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.628]                       search = base::search(), system = base::Sys.info())
[18:04:14.628]                   }
[18:04:14.628]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.628]                     cond$call), session = sessionInformation(), 
[18:04:14.628]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.628]                   signalCondition(cond)
[18:04:14.628]                 }
[18:04:14.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.628]                 "immediateCondition"))) {
[18:04:14.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.628]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.628]                   if (TRUE && !signal) {
[18:04:14.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.628]                     {
[18:04:14.628]                       inherits <- base::inherits
[18:04:14.628]                       invokeRestart <- base::invokeRestart
[18:04:14.628]                       is.null <- base::is.null
[18:04:14.628]                       muffled <- FALSE
[18:04:14.628]                       if (inherits(cond, "message")) {
[18:04:14.628]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.628]                         if (muffled) 
[18:04:14.628]                           invokeRestart("muffleMessage")
[18:04:14.628]                       }
[18:04:14.628]                       else if (inherits(cond, "warning")) {
[18:04:14.628]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.628]                         if (muffled) 
[18:04:14.628]                           invokeRestart("muffleWarning")
[18:04:14.628]                       }
[18:04:14.628]                       else if (inherits(cond, "condition")) {
[18:04:14.628]                         if (!is.null(pattern)) {
[18:04:14.628]                           computeRestarts <- base::computeRestarts
[18:04:14.628]                           grepl <- base::grepl
[18:04:14.628]                           restarts <- computeRestarts(cond)
[18:04:14.628]                           for (restart in restarts) {
[18:04:14.628]                             name <- restart$name
[18:04:14.628]                             if (is.null(name)) 
[18:04:14.628]                               next
[18:04:14.628]                             if (!grepl(pattern, name)) 
[18:04:14.628]                               next
[18:04:14.628]                             invokeRestart(restart)
[18:04:14.628]                             muffled <- TRUE
[18:04:14.628]                             break
[18:04:14.628]                           }
[18:04:14.628]                         }
[18:04:14.628]                       }
[18:04:14.628]                       invisible(muffled)
[18:04:14.628]                     }
[18:04:14.628]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.628]                   }
[18:04:14.628]                 }
[18:04:14.628]                 else {
[18:04:14.628]                   if (TRUE) {
[18:04:14.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.628]                     {
[18:04:14.628]                       inherits <- base::inherits
[18:04:14.628]                       invokeRestart <- base::invokeRestart
[18:04:14.628]                       is.null <- base::is.null
[18:04:14.628]                       muffled <- FALSE
[18:04:14.628]                       if (inherits(cond, "message")) {
[18:04:14.628]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.628]                         if (muffled) 
[18:04:14.628]                           invokeRestart("muffleMessage")
[18:04:14.628]                       }
[18:04:14.628]                       else if (inherits(cond, "warning")) {
[18:04:14.628]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.628]                         if (muffled) 
[18:04:14.628]                           invokeRestart("muffleWarning")
[18:04:14.628]                       }
[18:04:14.628]                       else if (inherits(cond, "condition")) {
[18:04:14.628]                         if (!is.null(pattern)) {
[18:04:14.628]                           computeRestarts <- base::computeRestarts
[18:04:14.628]                           grepl <- base::grepl
[18:04:14.628]                           restarts <- computeRestarts(cond)
[18:04:14.628]                           for (restart in restarts) {
[18:04:14.628]                             name <- restart$name
[18:04:14.628]                             if (is.null(name)) 
[18:04:14.628]                               next
[18:04:14.628]                             if (!grepl(pattern, name)) 
[18:04:14.628]                               next
[18:04:14.628]                             invokeRestart(restart)
[18:04:14.628]                             muffled <- TRUE
[18:04:14.628]                             break
[18:04:14.628]                           }
[18:04:14.628]                         }
[18:04:14.628]                       }
[18:04:14.628]                       invisible(muffled)
[18:04:14.628]                     }
[18:04:14.628]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.628]                   }
[18:04:14.628]                 }
[18:04:14.628]             }
[18:04:14.628]         }))
[18:04:14.628]     }, error = function(ex) {
[18:04:14.628]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.628]                 ...future.rng), started = ...future.startTime, 
[18:04:14.628]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.628]             version = "1.8"), class = "FutureResult")
[18:04:14.628]     }, finally = {
[18:04:14.628]         if (!identical(...future.workdir, getwd())) 
[18:04:14.628]             setwd(...future.workdir)
[18:04:14.628]         {
[18:04:14.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.628]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.628]             }
[18:04:14.628]             base::options(...future.oldOptions)
[18:04:14.628]             if (.Platform$OS.type == "windows") {
[18:04:14.628]                 old_names <- names(...future.oldEnvVars)
[18:04:14.628]                 envs <- base::Sys.getenv()
[18:04:14.628]                 names <- names(envs)
[18:04:14.628]                 common <- intersect(names, old_names)
[18:04:14.628]                 added <- setdiff(names, old_names)
[18:04:14.628]                 removed <- setdiff(old_names, names)
[18:04:14.628]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.628]                   envs[common]]
[18:04:14.628]                 NAMES <- toupper(changed)
[18:04:14.628]                 args <- list()
[18:04:14.628]                 for (kk in seq_along(NAMES)) {
[18:04:14.628]                   name <- changed[[kk]]
[18:04:14.628]                   NAME <- NAMES[[kk]]
[18:04:14.628]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.628]                     next
[18:04:14.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.628]                 }
[18:04:14.628]                 NAMES <- toupper(added)
[18:04:14.628]                 for (kk in seq_along(NAMES)) {
[18:04:14.628]                   name <- added[[kk]]
[18:04:14.628]                   NAME <- NAMES[[kk]]
[18:04:14.628]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.628]                     next
[18:04:14.628]                   args[[name]] <- ""
[18:04:14.628]                 }
[18:04:14.628]                 NAMES <- toupper(removed)
[18:04:14.628]                 for (kk in seq_along(NAMES)) {
[18:04:14.628]                   name <- removed[[kk]]
[18:04:14.628]                   NAME <- NAMES[[kk]]
[18:04:14.628]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.628]                     next
[18:04:14.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.628]                 }
[18:04:14.628]                 if (length(args) > 0) 
[18:04:14.628]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.628]             }
[18:04:14.628]             else {
[18:04:14.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.628]             }
[18:04:14.628]             {
[18:04:14.628]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.628]                   0L) {
[18:04:14.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.628]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.628]                   base::options(opts)
[18:04:14.628]                 }
[18:04:14.628]                 {
[18:04:14.628]                   {
[18:04:14.628]                     NULL
[18:04:14.628]                     RNGkind("Mersenne-Twister")
[18:04:14.628]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.628]                       inherits = FALSE)
[18:04:14.628]                   }
[18:04:14.628]                   options(future.plan = NULL)
[18:04:14.628]                   if (is.na(NA_character_)) 
[18:04:14.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.628]                     .init = FALSE)
[18:04:14.628]                 }
[18:04:14.628]             }
[18:04:14.628]         }
[18:04:14.628]     })
[18:04:14.628]     if (TRUE) {
[18:04:14.628]         base::sink(type = "output", split = FALSE)
[18:04:14.628]         if (TRUE) {
[18:04:14.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.628]         }
[18:04:14.628]         else {
[18:04:14.628]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.628]         }
[18:04:14.628]         base::close(...future.stdout)
[18:04:14.628]         ...future.stdout <- NULL
[18:04:14.628]     }
[18:04:14.628]     ...future.result$conditions <- ...future.conditions
[18:04:14.628]     ...future.result$finished <- base::Sys.time()
[18:04:14.628]     ...future.result
[18:04:14.628] }
[18:04:14.632] plan(): Setting new future strategy stack:
[18:04:14.632] List of future strategies:
[18:04:14.632] 1. sequential:
[18:04:14.632]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.632]    - tweaked: FALSE
[18:04:14.632]    - call: NULL
[18:04:14.633] plan(): nbrOfWorkers() = 1
[18:04:14.635] plan(): Setting new future strategy stack:
[18:04:14.635] List of future strategies:
[18:04:14.635] 1. sequential:
[18:04:14.635]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.635]    - tweaked: FALSE
[18:04:14.635]    - call: plan(strategy)
[18:04:14.636] plan(): nbrOfWorkers() = 1
[18:04:14.637] SequentialFuture started (and completed)
[18:04:14.637] - Launch lazy future ... done
[18:04:14.637] run() for ‘SequentialFuture’ ... done
<environment: 0x5e3c29a454d0> 
<environment: 0x5e3c2b59b5c0> 
[18:04:14.640] resolved() for ‘SequentialFuture’ ...
[18:04:14.640] - state: ‘finished’
[18:04:14.640] - run: TRUE
[18:04:14.641] - result: ‘FutureResult’
[18:04:14.641] resolved() for ‘SequentialFuture’ ... done
[18:04:14.641] resolved() for ‘SequentialFuture’ ...
[18:04:14.641] - state: ‘finished’
[18:04:14.641] - run: TRUE
[18:04:14.642] - result: ‘FutureResult’
[18:04:14.642] resolved() for ‘SequentialFuture’ ... done
[18:04:14.642] resolved() for ‘SequentialFuture’ ...
[18:04:14.642] - state: ‘finished’
[18:04:14.643] - run: TRUE
[18:04:14.643] - result: ‘FutureResult’
[18:04:14.643] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:14.648] resolve() on environment ...
[18:04:14.648]  recursive: 0
[18:04:14.650]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:14.650] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.650] - nx: 4
[18:04:14.650] - relay: TRUE
[18:04:14.651] - stdout: TRUE
[18:04:14.651] - signal: TRUE
[18:04:14.651] - resignal: FALSE
[18:04:14.651] - force: TRUE
[18:04:14.651] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.651] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.652]  - until=2
[18:04:14.652]  - relaying element #2
[18:04:14.652] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.652] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.652] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.653]  length: 3 (resolved future 1)
[18:04:14.653] resolved() for ‘SequentialFuture’ ...
[18:04:14.653] - state: ‘finished’
[18:04:14.653] - run: TRUE
[18:04:14.653] - result: ‘FutureResult’
[18:04:14.654] resolved() for ‘SequentialFuture’ ... done
[18:04:14.654] Future #2
[18:04:14.654] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.654] - nx: 4
[18:04:14.655] - relay: TRUE
[18:04:14.655] - stdout: TRUE
[18:04:14.655] - signal: TRUE
[18:04:14.655] - resignal: FALSE
[18:04:14.655] - force: TRUE
[18:04:14.655] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.656] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.656]  - until=2
[18:04:14.656]  - relaying element #2
[18:04:14.656] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.657] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.657] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.657]  length: 2 (resolved future 2)
[18:04:14.657] resolved() for ‘SequentialFuture’ ...
[18:04:14.658] - state: ‘finished’
[18:04:14.658] - run: TRUE
[18:04:14.658] - result: ‘FutureResult’
[18:04:14.658] resolved() for ‘SequentialFuture’ ... done
[18:04:14.658] Future #3
[18:04:14.659] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.659] - nx: 4
[18:04:14.659] - relay: TRUE
[18:04:14.659] - stdout: TRUE
[18:04:14.659] - signal: TRUE
[18:04:14.660] - resignal: FALSE
[18:04:14.660] - force: TRUE
[18:04:14.660] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.660] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.660]  - until=3
[18:04:14.661]  - relaying element #3
[18:04:14.661] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.661] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.661] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.662]  length: 1 (resolved future 3)
[18:04:14.662] resolved() for ‘SequentialFuture’ ...
[18:04:14.662] - state: ‘finished’
[18:04:14.662] - run: TRUE
[18:04:14.662] - result: ‘FutureResult’
[18:04:14.663] resolved() for ‘SequentialFuture’ ... done
[18:04:14.663] Future #4
[18:04:14.663] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:14.663] - nx: 4
[18:04:14.664] - relay: TRUE
[18:04:14.664] - stdout: TRUE
[18:04:14.664] - signal: TRUE
[18:04:14.664] - resignal: FALSE
[18:04:14.664] - force: TRUE
[18:04:14.664] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.665] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.665]  - until=4
[18:04:14.665]  - relaying element #4
[18:04:14.665] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.666] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.666] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:14.666]  length: 0 (resolved future 4)
[18:04:14.666] Relaying remaining futures
[18:04:14.667] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.667] - nx: 4
[18:04:14.667] - relay: TRUE
[18:04:14.667] - stdout: TRUE
[18:04:14.667] - signal: TRUE
[18:04:14.667] - resignal: FALSE
[18:04:14.668] - force: TRUE
[18:04:14.668] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.668] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:14.668] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.668] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.669] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.669] resolve() on environment ... DONE
<environment: 0x5e3c2a592e50> 
Dimensions: c(2, 3)
[18:04:14.670] getGlobalsAndPackages() ...
[18:04:14.670] Searching for globals...
[18:04:14.671] 
[18:04:14.671] Searching for globals ... DONE
[18:04:14.671] - globals: [0] <none>
[18:04:14.672] getGlobalsAndPackages() ... DONE
[18:04:14.672] run() for ‘Future’ ...
[18:04:14.672] - state: ‘created’
[18:04:14.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.673] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.673] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.674]   - Field: ‘label’
[18:04:14.674]   - Field: ‘local’
[18:04:14.674]   - Field: ‘owner’
[18:04:14.674]   - Field: ‘envir’
[18:04:14.675]   - Field: ‘packages’
[18:04:14.675]   - Field: ‘gc’
[18:04:14.675]   - Field: ‘conditions’
[18:04:14.675]   - Field: ‘expr’
[18:04:14.675]   - Field: ‘uuid’
[18:04:14.676]   - Field: ‘seed’
[18:04:14.676]   - Field: ‘version’
[18:04:14.676]   - Field: ‘result’
[18:04:14.676]   - Field: ‘asynchronous’
[18:04:14.676]   - Field: ‘calls’
[18:04:14.677]   - Field: ‘globals’
[18:04:14.677]   - Field: ‘stdout’
[18:04:14.677]   - Field: ‘earlySignal’
[18:04:14.677]   - Field: ‘lazy’
[18:04:14.677]   - Field: ‘state’
[18:04:14.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.678] - Launch lazy future ...
[18:04:14.678] Packages needed by the future expression (n = 0): <none>
[18:04:14.678] Packages needed by future strategies (n = 0): <none>
[18:04:14.679] {
[18:04:14.679]     {
[18:04:14.679]         {
[18:04:14.679]             ...future.startTime <- base::Sys.time()
[18:04:14.679]             {
[18:04:14.679]                 {
[18:04:14.679]                   {
[18:04:14.679]                     base::local({
[18:04:14.679]                       has_future <- base::requireNamespace("future", 
[18:04:14.679]                         quietly = TRUE)
[18:04:14.679]                       if (has_future) {
[18:04:14.679]                         ns <- base::getNamespace("future")
[18:04:14.679]                         version <- ns[[".package"]][["version"]]
[18:04:14.679]                         if (is.null(version)) 
[18:04:14.679]                           version <- utils::packageVersion("future")
[18:04:14.679]                       }
[18:04:14.679]                       else {
[18:04:14.679]                         version <- NULL
[18:04:14.679]                       }
[18:04:14.679]                       if (!has_future || version < "1.8.0") {
[18:04:14.679]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.679]                           "", base::R.version$version.string), 
[18:04:14.679]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.679]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.679]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.679]                             "release", "version")], collapse = " "), 
[18:04:14.679]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.679]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.679]                           info)
[18:04:14.679]                         info <- base::paste(info, collapse = "; ")
[18:04:14.679]                         if (!has_future) {
[18:04:14.679]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.679]                             info)
[18:04:14.679]                         }
[18:04:14.679]                         else {
[18:04:14.679]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.679]                             info, version)
[18:04:14.679]                         }
[18:04:14.679]                         base::stop(msg)
[18:04:14.679]                       }
[18:04:14.679]                     })
[18:04:14.679]                   }
[18:04:14.679]                   ...future.strategy.old <- future::plan("list")
[18:04:14.679]                   options(future.plan = NULL)
[18:04:14.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.679]                 }
[18:04:14.679]                 ...future.workdir <- getwd()
[18:04:14.679]             }
[18:04:14.679]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.679]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.679]         }
[18:04:14.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.679]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.679]             base::names(...future.oldOptions))
[18:04:14.679]     }
[18:04:14.679]     if (FALSE) {
[18:04:14.679]     }
[18:04:14.679]     else {
[18:04:14.679]         if (TRUE) {
[18:04:14.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.679]                 open = "w")
[18:04:14.679]         }
[18:04:14.679]         else {
[18:04:14.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.679]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.679]         }
[18:04:14.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.679]             base::sink(type = "output", split = FALSE)
[18:04:14.679]             base::close(...future.stdout)
[18:04:14.679]         }, add = TRUE)
[18:04:14.679]     }
[18:04:14.679]     ...future.frame <- base::sys.nframe()
[18:04:14.679]     ...future.conditions <- base::list()
[18:04:14.679]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.679]     if (FALSE) {
[18:04:14.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.679]     }
[18:04:14.679]     ...future.result <- base::tryCatch({
[18:04:14.679]         base::withCallingHandlers({
[18:04:14.679]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.679]             future::FutureResult(value = ...future.value$value, 
[18:04:14.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.679]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.679]                     ...future.globalenv.names))
[18:04:14.679]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.679]         }, condition = base::local({
[18:04:14.679]             c <- base::c
[18:04:14.679]             inherits <- base::inherits
[18:04:14.679]             invokeRestart <- base::invokeRestart
[18:04:14.679]             length <- base::length
[18:04:14.679]             list <- base::list
[18:04:14.679]             seq.int <- base::seq.int
[18:04:14.679]             signalCondition <- base::signalCondition
[18:04:14.679]             sys.calls <- base::sys.calls
[18:04:14.679]             `[[` <- base::`[[`
[18:04:14.679]             `+` <- base::`+`
[18:04:14.679]             `<<-` <- base::`<<-`
[18:04:14.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.679]                   3L)]
[18:04:14.679]             }
[18:04:14.679]             function(cond) {
[18:04:14.679]                 is_error <- inherits(cond, "error")
[18:04:14.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.679]                   NULL)
[18:04:14.679]                 if (is_error) {
[18:04:14.679]                   sessionInformation <- function() {
[18:04:14.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.679]                       search = base::search(), system = base::Sys.info())
[18:04:14.679]                   }
[18:04:14.679]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.679]                     cond$call), session = sessionInformation(), 
[18:04:14.679]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.679]                   signalCondition(cond)
[18:04:14.679]                 }
[18:04:14.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.679]                 "immediateCondition"))) {
[18:04:14.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.679]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.679]                   if (TRUE && !signal) {
[18:04:14.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.679]                     {
[18:04:14.679]                       inherits <- base::inherits
[18:04:14.679]                       invokeRestart <- base::invokeRestart
[18:04:14.679]                       is.null <- base::is.null
[18:04:14.679]                       muffled <- FALSE
[18:04:14.679]                       if (inherits(cond, "message")) {
[18:04:14.679]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.679]                         if (muffled) 
[18:04:14.679]                           invokeRestart("muffleMessage")
[18:04:14.679]                       }
[18:04:14.679]                       else if (inherits(cond, "warning")) {
[18:04:14.679]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.679]                         if (muffled) 
[18:04:14.679]                           invokeRestart("muffleWarning")
[18:04:14.679]                       }
[18:04:14.679]                       else if (inherits(cond, "condition")) {
[18:04:14.679]                         if (!is.null(pattern)) {
[18:04:14.679]                           computeRestarts <- base::computeRestarts
[18:04:14.679]                           grepl <- base::grepl
[18:04:14.679]                           restarts <- computeRestarts(cond)
[18:04:14.679]                           for (restart in restarts) {
[18:04:14.679]                             name <- restart$name
[18:04:14.679]                             if (is.null(name)) 
[18:04:14.679]                               next
[18:04:14.679]                             if (!grepl(pattern, name)) 
[18:04:14.679]                               next
[18:04:14.679]                             invokeRestart(restart)
[18:04:14.679]                             muffled <- TRUE
[18:04:14.679]                             break
[18:04:14.679]                           }
[18:04:14.679]                         }
[18:04:14.679]                       }
[18:04:14.679]                       invisible(muffled)
[18:04:14.679]                     }
[18:04:14.679]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.679]                   }
[18:04:14.679]                 }
[18:04:14.679]                 else {
[18:04:14.679]                   if (TRUE) {
[18:04:14.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.679]                     {
[18:04:14.679]                       inherits <- base::inherits
[18:04:14.679]                       invokeRestart <- base::invokeRestart
[18:04:14.679]                       is.null <- base::is.null
[18:04:14.679]                       muffled <- FALSE
[18:04:14.679]                       if (inherits(cond, "message")) {
[18:04:14.679]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.679]                         if (muffled) 
[18:04:14.679]                           invokeRestart("muffleMessage")
[18:04:14.679]                       }
[18:04:14.679]                       else if (inherits(cond, "warning")) {
[18:04:14.679]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.679]                         if (muffled) 
[18:04:14.679]                           invokeRestart("muffleWarning")
[18:04:14.679]                       }
[18:04:14.679]                       else if (inherits(cond, "condition")) {
[18:04:14.679]                         if (!is.null(pattern)) {
[18:04:14.679]                           computeRestarts <- base::computeRestarts
[18:04:14.679]                           grepl <- base::grepl
[18:04:14.679]                           restarts <- computeRestarts(cond)
[18:04:14.679]                           for (restart in restarts) {
[18:04:14.679]                             name <- restart$name
[18:04:14.679]                             if (is.null(name)) 
[18:04:14.679]                               next
[18:04:14.679]                             if (!grepl(pattern, name)) 
[18:04:14.679]                               next
[18:04:14.679]                             invokeRestart(restart)
[18:04:14.679]                             muffled <- TRUE
[18:04:14.679]                             break
[18:04:14.679]                           }
[18:04:14.679]                         }
[18:04:14.679]                       }
[18:04:14.679]                       invisible(muffled)
[18:04:14.679]                     }
[18:04:14.679]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.679]                   }
[18:04:14.679]                 }
[18:04:14.679]             }
[18:04:14.679]         }))
[18:04:14.679]     }, error = function(ex) {
[18:04:14.679]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.679]                 ...future.rng), started = ...future.startTime, 
[18:04:14.679]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.679]             version = "1.8"), class = "FutureResult")
[18:04:14.679]     }, finally = {
[18:04:14.679]         if (!identical(...future.workdir, getwd())) 
[18:04:14.679]             setwd(...future.workdir)
[18:04:14.679]         {
[18:04:14.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.679]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.679]             }
[18:04:14.679]             base::options(...future.oldOptions)
[18:04:14.679]             if (.Platform$OS.type == "windows") {
[18:04:14.679]                 old_names <- names(...future.oldEnvVars)
[18:04:14.679]                 envs <- base::Sys.getenv()
[18:04:14.679]                 names <- names(envs)
[18:04:14.679]                 common <- intersect(names, old_names)
[18:04:14.679]                 added <- setdiff(names, old_names)
[18:04:14.679]                 removed <- setdiff(old_names, names)
[18:04:14.679]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.679]                   envs[common]]
[18:04:14.679]                 NAMES <- toupper(changed)
[18:04:14.679]                 args <- list()
[18:04:14.679]                 for (kk in seq_along(NAMES)) {
[18:04:14.679]                   name <- changed[[kk]]
[18:04:14.679]                   NAME <- NAMES[[kk]]
[18:04:14.679]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.679]                     next
[18:04:14.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.679]                 }
[18:04:14.679]                 NAMES <- toupper(added)
[18:04:14.679]                 for (kk in seq_along(NAMES)) {
[18:04:14.679]                   name <- added[[kk]]
[18:04:14.679]                   NAME <- NAMES[[kk]]
[18:04:14.679]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.679]                     next
[18:04:14.679]                   args[[name]] <- ""
[18:04:14.679]                 }
[18:04:14.679]                 NAMES <- toupper(removed)
[18:04:14.679]                 for (kk in seq_along(NAMES)) {
[18:04:14.679]                   name <- removed[[kk]]
[18:04:14.679]                   NAME <- NAMES[[kk]]
[18:04:14.679]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.679]                     next
[18:04:14.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.679]                 }
[18:04:14.679]                 if (length(args) > 0) 
[18:04:14.679]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.679]             }
[18:04:14.679]             else {
[18:04:14.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.679]             }
[18:04:14.679]             {
[18:04:14.679]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.679]                   0L) {
[18:04:14.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.679]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.679]                   base::options(opts)
[18:04:14.679]                 }
[18:04:14.679]                 {
[18:04:14.679]                   {
[18:04:14.679]                     NULL
[18:04:14.679]                     RNGkind("Mersenne-Twister")
[18:04:14.679]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.679]                       inherits = FALSE)
[18:04:14.679]                   }
[18:04:14.679]                   options(future.plan = NULL)
[18:04:14.679]                   if (is.na(NA_character_)) 
[18:04:14.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.679]                     .init = FALSE)
[18:04:14.679]                 }
[18:04:14.679]             }
[18:04:14.679]         }
[18:04:14.679]     })
[18:04:14.679]     if (TRUE) {
[18:04:14.679]         base::sink(type = "output", split = FALSE)
[18:04:14.679]         if (TRUE) {
[18:04:14.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.679]         }
[18:04:14.679]         else {
[18:04:14.679]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.679]         }
[18:04:14.679]         base::close(...future.stdout)
[18:04:14.679]         ...future.stdout <- NULL
[18:04:14.679]     }
[18:04:14.679]     ...future.result$conditions <- ...future.conditions
[18:04:14.679]     ...future.result$finished <- base::Sys.time()
[18:04:14.679]     ...future.result
[18:04:14.679] }
[18:04:14.683] plan(): Setting new future strategy stack:
[18:04:14.683] List of future strategies:
[18:04:14.683] 1. sequential:
[18:04:14.683]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.683]    - tweaked: FALSE
[18:04:14.683]    - call: NULL
[18:04:14.684] plan(): nbrOfWorkers() = 1
[18:04:14.686] plan(): Setting new future strategy stack:
[18:04:14.686] List of future strategies:
[18:04:14.686] 1. sequential:
[18:04:14.686]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.686]    - tweaked: FALSE
[18:04:14.686]    - call: plan(strategy)
[18:04:14.687] plan(): nbrOfWorkers() = 1
[18:04:14.687] SequentialFuture started (and completed)
[18:04:14.688] - Launch lazy future ... done
[18:04:14.688] run() for ‘SequentialFuture’ ... done
[18:04:14.688] getGlobalsAndPackages() ...
[18:04:14.688] Searching for globals...
[18:04:14.689] 
[18:04:14.689] Searching for globals ... DONE
[18:04:14.690] - globals: [0] <none>
[18:04:14.690] getGlobalsAndPackages() ... DONE
[18:04:14.690] run() for ‘Future’ ...
[18:04:14.691] - state: ‘created’
[18:04:14.691] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.691] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.692] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.692]   - Field: ‘label’
[18:04:14.692]   - Field: ‘local’
[18:04:14.692]   - Field: ‘owner’
[18:04:14.693]   - Field: ‘envir’
[18:04:14.693]   - Field: ‘packages’
[18:04:14.693]   - Field: ‘gc’
[18:04:14.693]   - Field: ‘conditions’
[18:04:14.693]   - Field: ‘expr’
[18:04:14.694]   - Field: ‘uuid’
[18:04:14.694]   - Field: ‘seed’
[18:04:14.694]   - Field: ‘version’
[18:04:14.694]   - Field: ‘result’
[18:04:14.694]   - Field: ‘asynchronous’
[18:04:14.695]   - Field: ‘calls’
[18:04:14.695]   - Field: ‘globals’
[18:04:14.695]   - Field: ‘stdout’
[18:04:14.695]   - Field: ‘earlySignal’
[18:04:14.695]   - Field: ‘lazy’
[18:04:14.695]   - Field: ‘state’
[18:04:14.696] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.696] - Launch lazy future ...
[18:04:14.696] Packages needed by the future expression (n = 0): <none>
[18:04:14.697] Packages needed by future strategies (n = 0): <none>
[18:04:14.698] {
[18:04:14.698]     {
[18:04:14.698]         {
[18:04:14.698]             ...future.startTime <- base::Sys.time()
[18:04:14.698]             {
[18:04:14.698]                 {
[18:04:14.698]                   {
[18:04:14.698]                     base::local({
[18:04:14.698]                       has_future <- base::requireNamespace("future", 
[18:04:14.698]                         quietly = TRUE)
[18:04:14.698]                       if (has_future) {
[18:04:14.698]                         ns <- base::getNamespace("future")
[18:04:14.698]                         version <- ns[[".package"]][["version"]]
[18:04:14.698]                         if (is.null(version)) 
[18:04:14.698]                           version <- utils::packageVersion("future")
[18:04:14.698]                       }
[18:04:14.698]                       else {
[18:04:14.698]                         version <- NULL
[18:04:14.698]                       }
[18:04:14.698]                       if (!has_future || version < "1.8.0") {
[18:04:14.698]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.698]                           "", base::R.version$version.string), 
[18:04:14.698]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.698]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.698]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.698]                             "release", "version")], collapse = " "), 
[18:04:14.698]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.698]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.698]                           info)
[18:04:14.698]                         info <- base::paste(info, collapse = "; ")
[18:04:14.698]                         if (!has_future) {
[18:04:14.698]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.698]                             info)
[18:04:14.698]                         }
[18:04:14.698]                         else {
[18:04:14.698]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.698]                             info, version)
[18:04:14.698]                         }
[18:04:14.698]                         base::stop(msg)
[18:04:14.698]                       }
[18:04:14.698]                     })
[18:04:14.698]                   }
[18:04:14.698]                   ...future.strategy.old <- future::plan("list")
[18:04:14.698]                   options(future.plan = NULL)
[18:04:14.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.698]                 }
[18:04:14.698]                 ...future.workdir <- getwd()
[18:04:14.698]             }
[18:04:14.698]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.698]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.698]         }
[18:04:14.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.698]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.698]             base::names(...future.oldOptions))
[18:04:14.698]     }
[18:04:14.698]     if (FALSE) {
[18:04:14.698]     }
[18:04:14.698]     else {
[18:04:14.698]         if (TRUE) {
[18:04:14.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.698]                 open = "w")
[18:04:14.698]         }
[18:04:14.698]         else {
[18:04:14.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.698]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.698]         }
[18:04:14.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.698]             base::sink(type = "output", split = FALSE)
[18:04:14.698]             base::close(...future.stdout)
[18:04:14.698]         }, add = TRUE)
[18:04:14.698]     }
[18:04:14.698]     ...future.frame <- base::sys.nframe()
[18:04:14.698]     ...future.conditions <- base::list()
[18:04:14.698]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.698]     if (FALSE) {
[18:04:14.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.698]     }
[18:04:14.698]     ...future.result <- base::tryCatch({
[18:04:14.698]         base::withCallingHandlers({
[18:04:14.698]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.698]             future::FutureResult(value = ...future.value$value, 
[18:04:14.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.698]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.698]                     ...future.globalenv.names))
[18:04:14.698]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.698]         }, condition = base::local({
[18:04:14.698]             c <- base::c
[18:04:14.698]             inherits <- base::inherits
[18:04:14.698]             invokeRestart <- base::invokeRestart
[18:04:14.698]             length <- base::length
[18:04:14.698]             list <- base::list
[18:04:14.698]             seq.int <- base::seq.int
[18:04:14.698]             signalCondition <- base::signalCondition
[18:04:14.698]             sys.calls <- base::sys.calls
[18:04:14.698]             `[[` <- base::`[[`
[18:04:14.698]             `+` <- base::`+`
[18:04:14.698]             `<<-` <- base::`<<-`
[18:04:14.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.698]                   3L)]
[18:04:14.698]             }
[18:04:14.698]             function(cond) {
[18:04:14.698]                 is_error <- inherits(cond, "error")
[18:04:14.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.698]                   NULL)
[18:04:14.698]                 if (is_error) {
[18:04:14.698]                   sessionInformation <- function() {
[18:04:14.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.698]                       search = base::search(), system = base::Sys.info())
[18:04:14.698]                   }
[18:04:14.698]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.698]                     cond$call), session = sessionInformation(), 
[18:04:14.698]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.698]                   signalCondition(cond)
[18:04:14.698]                 }
[18:04:14.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.698]                 "immediateCondition"))) {
[18:04:14.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.698]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.698]                   if (TRUE && !signal) {
[18:04:14.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.698]                     {
[18:04:14.698]                       inherits <- base::inherits
[18:04:14.698]                       invokeRestart <- base::invokeRestart
[18:04:14.698]                       is.null <- base::is.null
[18:04:14.698]                       muffled <- FALSE
[18:04:14.698]                       if (inherits(cond, "message")) {
[18:04:14.698]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.698]                         if (muffled) 
[18:04:14.698]                           invokeRestart("muffleMessage")
[18:04:14.698]                       }
[18:04:14.698]                       else if (inherits(cond, "warning")) {
[18:04:14.698]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.698]                         if (muffled) 
[18:04:14.698]                           invokeRestart("muffleWarning")
[18:04:14.698]                       }
[18:04:14.698]                       else if (inherits(cond, "condition")) {
[18:04:14.698]                         if (!is.null(pattern)) {
[18:04:14.698]                           computeRestarts <- base::computeRestarts
[18:04:14.698]                           grepl <- base::grepl
[18:04:14.698]                           restarts <- computeRestarts(cond)
[18:04:14.698]                           for (restart in restarts) {
[18:04:14.698]                             name <- restart$name
[18:04:14.698]                             if (is.null(name)) 
[18:04:14.698]                               next
[18:04:14.698]                             if (!grepl(pattern, name)) 
[18:04:14.698]                               next
[18:04:14.698]                             invokeRestart(restart)
[18:04:14.698]                             muffled <- TRUE
[18:04:14.698]                             break
[18:04:14.698]                           }
[18:04:14.698]                         }
[18:04:14.698]                       }
[18:04:14.698]                       invisible(muffled)
[18:04:14.698]                     }
[18:04:14.698]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.698]                   }
[18:04:14.698]                 }
[18:04:14.698]                 else {
[18:04:14.698]                   if (TRUE) {
[18:04:14.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.698]                     {
[18:04:14.698]                       inherits <- base::inherits
[18:04:14.698]                       invokeRestart <- base::invokeRestart
[18:04:14.698]                       is.null <- base::is.null
[18:04:14.698]                       muffled <- FALSE
[18:04:14.698]                       if (inherits(cond, "message")) {
[18:04:14.698]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.698]                         if (muffled) 
[18:04:14.698]                           invokeRestart("muffleMessage")
[18:04:14.698]                       }
[18:04:14.698]                       else if (inherits(cond, "warning")) {
[18:04:14.698]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.698]                         if (muffled) 
[18:04:14.698]                           invokeRestart("muffleWarning")
[18:04:14.698]                       }
[18:04:14.698]                       else if (inherits(cond, "condition")) {
[18:04:14.698]                         if (!is.null(pattern)) {
[18:04:14.698]                           computeRestarts <- base::computeRestarts
[18:04:14.698]                           grepl <- base::grepl
[18:04:14.698]                           restarts <- computeRestarts(cond)
[18:04:14.698]                           for (restart in restarts) {
[18:04:14.698]                             name <- restart$name
[18:04:14.698]                             if (is.null(name)) 
[18:04:14.698]                               next
[18:04:14.698]                             if (!grepl(pattern, name)) 
[18:04:14.698]                               next
[18:04:14.698]                             invokeRestart(restart)
[18:04:14.698]                             muffled <- TRUE
[18:04:14.698]                             break
[18:04:14.698]                           }
[18:04:14.698]                         }
[18:04:14.698]                       }
[18:04:14.698]                       invisible(muffled)
[18:04:14.698]                     }
[18:04:14.698]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.698]                   }
[18:04:14.698]                 }
[18:04:14.698]             }
[18:04:14.698]         }))
[18:04:14.698]     }, error = function(ex) {
[18:04:14.698]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.698]                 ...future.rng), started = ...future.startTime, 
[18:04:14.698]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.698]             version = "1.8"), class = "FutureResult")
[18:04:14.698]     }, finally = {
[18:04:14.698]         if (!identical(...future.workdir, getwd())) 
[18:04:14.698]             setwd(...future.workdir)
[18:04:14.698]         {
[18:04:14.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.698]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.698]             }
[18:04:14.698]             base::options(...future.oldOptions)
[18:04:14.698]             if (.Platform$OS.type == "windows") {
[18:04:14.698]                 old_names <- names(...future.oldEnvVars)
[18:04:14.698]                 envs <- base::Sys.getenv()
[18:04:14.698]                 names <- names(envs)
[18:04:14.698]                 common <- intersect(names, old_names)
[18:04:14.698]                 added <- setdiff(names, old_names)
[18:04:14.698]                 removed <- setdiff(old_names, names)
[18:04:14.698]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.698]                   envs[common]]
[18:04:14.698]                 NAMES <- toupper(changed)
[18:04:14.698]                 args <- list()
[18:04:14.698]                 for (kk in seq_along(NAMES)) {
[18:04:14.698]                   name <- changed[[kk]]
[18:04:14.698]                   NAME <- NAMES[[kk]]
[18:04:14.698]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.698]                     next
[18:04:14.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.698]                 }
[18:04:14.698]                 NAMES <- toupper(added)
[18:04:14.698]                 for (kk in seq_along(NAMES)) {
[18:04:14.698]                   name <- added[[kk]]
[18:04:14.698]                   NAME <- NAMES[[kk]]
[18:04:14.698]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.698]                     next
[18:04:14.698]                   args[[name]] <- ""
[18:04:14.698]                 }
[18:04:14.698]                 NAMES <- toupper(removed)
[18:04:14.698]                 for (kk in seq_along(NAMES)) {
[18:04:14.698]                   name <- removed[[kk]]
[18:04:14.698]                   NAME <- NAMES[[kk]]
[18:04:14.698]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.698]                     next
[18:04:14.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.698]                 }
[18:04:14.698]                 if (length(args) > 0) 
[18:04:14.698]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.698]             }
[18:04:14.698]             else {
[18:04:14.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.698]             }
[18:04:14.698]             {
[18:04:14.698]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.698]                   0L) {
[18:04:14.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.698]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.698]                   base::options(opts)
[18:04:14.698]                 }
[18:04:14.698]                 {
[18:04:14.698]                   {
[18:04:14.698]                     NULL
[18:04:14.698]                     RNGkind("Mersenne-Twister")
[18:04:14.698]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.698]                       inherits = FALSE)
[18:04:14.698]                   }
[18:04:14.698]                   options(future.plan = NULL)
[18:04:14.698]                   if (is.na(NA_character_)) 
[18:04:14.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.698]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.698]                     .init = FALSE)
[18:04:14.698]                 }
[18:04:14.698]             }
[18:04:14.698]         }
[18:04:14.698]     })
[18:04:14.698]     if (TRUE) {
[18:04:14.698]         base::sink(type = "output", split = FALSE)
[18:04:14.698]         if (TRUE) {
[18:04:14.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.698]         }
[18:04:14.698]         else {
[18:04:14.698]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.698]         }
[18:04:14.698]         base::close(...future.stdout)
[18:04:14.698]         ...future.stdout <- NULL
[18:04:14.698]     }
[18:04:14.698]     ...future.result$conditions <- ...future.conditions
[18:04:14.698]     ...future.result$finished <- base::Sys.time()
[18:04:14.698]     ...future.result
[18:04:14.698] }
[18:04:14.701] plan(): Setting new future strategy stack:
[18:04:14.701] List of future strategies:
[18:04:14.701] 1. sequential:
[18:04:14.701]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.701]    - tweaked: FALSE
[18:04:14.701]    - call: NULL
[18:04:14.702] plan(): nbrOfWorkers() = 1
[18:04:14.704] plan(): Setting new future strategy stack:
[18:04:14.704] List of future strategies:
[18:04:14.704] 1. sequential:
[18:04:14.704]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.704]    - tweaked: FALSE
[18:04:14.704]    - call: plan(strategy)
[18:04:14.705] plan(): nbrOfWorkers() = 1
[18:04:14.706] SequentialFuture started (and completed)
[18:04:14.706] - Launch lazy future ... done
[18:04:14.706] run() for ‘SequentialFuture’ ... done
[18:04:14.707] getGlobalsAndPackages() ...
[18:04:14.707] Searching for globals...
[18:04:14.708] - globals found: [1] ‘{’
[18:04:14.709] Searching for globals ... DONE
[18:04:14.709] Resolving globals: FALSE
[18:04:14.710] 
[18:04:14.712] 
[18:04:14.713] getGlobalsAndPackages() ... DONE
[18:04:14.713] run() for ‘Future’ ...
[18:04:14.714] - state: ‘created’
[18:04:14.714] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.714] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.715]   - Field: ‘label’
[18:04:14.715]   - Field: ‘local’
[18:04:14.715]   - Field: ‘owner’
[18:04:14.716]   - Field: ‘envir’
[18:04:14.716]   - Field: ‘packages’
[18:04:14.716]   - Field: ‘gc’
[18:04:14.716]   - Field: ‘conditions’
[18:04:14.716]   - Field: ‘expr’
[18:04:14.717]   - Field: ‘uuid’
[18:04:14.717]   - Field: ‘seed’
[18:04:14.717]   - Field: ‘version’
[18:04:14.717]   - Field: ‘result’
[18:04:14.717]   - Field: ‘asynchronous’
[18:04:14.718]   - Field: ‘calls’
[18:04:14.718]   - Field: ‘globals’
[18:04:14.718]   - Field: ‘stdout’
[18:04:14.718]   - Field: ‘earlySignal’
[18:04:14.718]   - Field: ‘lazy’
[18:04:14.719]   - Field: ‘state’
[18:04:14.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.719] - Launch lazy future ...
[18:04:14.719] Packages needed by the future expression (n = 0): <none>
[18:04:14.720] Packages needed by future strategies (n = 0): <none>
[18:04:14.721] {
[18:04:14.721]     {
[18:04:14.721]         {
[18:04:14.721]             ...future.startTime <- base::Sys.time()
[18:04:14.721]             {
[18:04:14.721]                 {
[18:04:14.721]                   {
[18:04:14.721]                     base::local({
[18:04:14.721]                       has_future <- base::requireNamespace("future", 
[18:04:14.721]                         quietly = TRUE)
[18:04:14.721]                       if (has_future) {
[18:04:14.721]                         ns <- base::getNamespace("future")
[18:04:14.721]                         version <- ns[[".package"]][["version"]]
[18:04:14.721]                         if (is.null(version)) 
[18:04:14.721]                           version <- utils::packageVersion("future")
[18:04:14.721]                       }
[18:04:14.721]                       else {
[18:04:14.721]                         version <- NULL
[18:04:14.721]                       }
[18:04:14.721]                       if (!has_future || version < "1.8.0") {
[18:04:14.721]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.721]                           "", base::R.version$version.string), 
[18:04:14.721]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.721]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.721]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.721]                             "release", "version")], collapse = " "), 
[18:04:14.721]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.721]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.721]                           info)
[18:04:14.721]                         info <- base::paste(info, collapse = "; ")
[18:04:14.721]                         if (!has_future) {
[18:04:14.721]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.721]                             info)
[18:04:14.721]                         }
[18:04:14.721]                         else {
[18:04:14.721]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.721]                             info, version)
[18:04:14.721]                         }
[18:04:14.721]                         base::stop(msg)
[18:04:14.721]                       }
[18:04:14.721]                     })
[18:04:14.721]                   }
[18:04:14.721]                   ...future.strategy.old <- future::plan("list")
[18:04:14.721]                   options(future.plan = NULL)
[18:04:14.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.721]                 }
[18:04:14.721]                 ...future.workdir <- getwd()
[18:04:14.721]             }
[18:04:14.721]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.721]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.721]         }
[18:04:14.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.721]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.721]             base::names(...future.oldOptions))
[18:04:14.721]     }
[18:04:14.721]     if (FALSE) {
[18:04:14.721]     }
[18:04:14.721]     else {
[18:04:14.721]         if (TRUE) {
[18:04:14.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.721]                 open = "w")
[18:04:14.721]         }
[18:04:14.721]         else {
[18:04:14.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.721]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.721]         }
[18:04:14.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.721]             base::sink(type = "output", split = FALSE)
[18:04:14.721]             base::close(...future.stdout)
[18:04:14.721]         }, add = TRUE)
[18:04:14.721]     }
[18:04:14.721]     ...future.frame <- base::sys.nframe()
[18:04:14.721]     ...future.conditions <- base::list()
[18:04:14.721]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.721]     if (FALSE) {
[18:04:14.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.721]     }
[18:04:14.721]     ...future.result <- base::tryCatch({
[18:04:14.721]         base::withCallingHandlers({
[18:04:14.721]             ...future.value <- base::withVisible(base::local({
[18:04:14.721]                 4
[18:04:14.721]             }))
[18:04:14.721]             future::FutureResult(value = ...future.value$value, 
[18:04:14.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.721]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.721]                     ...future.globalenv.names))
[18:04:14.721]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.721]         }, condition = base::local({
[18:04:14.721]             c <- base::c
[18:04:14.721]             inherits <- base::inherits
[18:04:14.721]             invokeRestart <- base::invokeRestart
[18:04:14.721]             length <- base::length
[18:04:14.721]             list <- base::list
[18:04:14.721]             seq.int <- base::seq.int
[18:04:14.721]             signalCondition <- base::signalCondition
[18:04:14.721]             sys.calls <- base::sys.calls
[18:04:14.721]             `[[` <- base::`[[`
[18:04:14.721]             `+` <- base::`+`
[18:04:14.721]             `<<-` <- base::`<<-`
[18:04:14.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.721]                   3L)]
[18:04:14.721]             }
[18:04:14.721]             function(cond) {
[18:04:14.721]                 is_error <- inherits(cond, "error")
[18:04:14.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.721]                   NULL)
[18:04:14.721]                 if (is_error) {
[18:04:14.721]                   sessionInformation <- function() {
[18:04:14.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.721]                       search = base::search(), system = base::Sys.info())
[18:04:14.721]                   }
[18:04:14.721]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.721]                     cond$call), session = sessionInformation(), 
[18:04:14.721]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.721]                   signalCondition(cond)
[18:04:14.721]                 }
[18:04:14.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.721]                 "immediateCondition"))) {
[18:04:14.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.721]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.721]                   if (TRUE && !signal) {
[18:04:14.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.721]                     {
[18:04:14.721]                       inherits <- base::inherits
[18:04:14.721]                       invokeRestart <- base::invokeRestart
[18:04:14.721]                       is.null <- base::is.null
[18:04:14.721]                       muffled <- FALSE
[18:04:14.721]                       if (inherits(cond, "message")) {
[18:04:14.721]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.721]                         if (muffled) 
[18:04:14.721]                           invokeRestart("muffleMessage")
[18:04:14.721]                       }
[18:04:14.721]                       else if (inherits(cond, "warning")) {
[18:04:14.721]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.721]                         if (muffled) 
[18:04:14.721]                           invokeRestart("muffleWarning")
[18:04:14.721]                       }
[18:04:14.721]                       else if (inherits(cond, "condition")) {
[18:04:14.721]                         if (!is.null(pattern)) {
[18:04:14.721]                           computeRestarts <- base::computeRestarts
[18:04:14.721]                           grepl <- base::grepl
[18:04:14.721]                           restarts <- computeRestarts(cond)
[18:04:14.721]                           for (restart in restarts) {
[18:04:14.721]                             name <- restart$name
[18:04:14.721]                             if (is.null(name)) 
[18:04:14.721]                               next
[18:04:14.721]                             if (!grepl(pattern, name)) 
[18:04:14.721]                               next
[18:04:14.721]                             invokeRestart(restart)
[18:04:14.721]                             muffled <- TRUE
[18:04:14.721]                             break
[18:04:14.721]                           }
[18:04:14.721]                         }
[18:04:14.721]                       }
[18:04:14.721]                       invisible(muffled)
[18:04:14.721]                     }
[18:04:14.721]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.721]                   }
[18:04:14.721]                 }
[18:04:14.721]                 else {
[18:04:14.721]                   if (TRUE) {
[18:04:14.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.721]                     {
[18:04:14.721]                       inherits <- base::inherits
[18:04:14.721]                       invokeRestart <- base::invokeRestart
[18:04:14.721]                       is.null <- base::is.null
[18:04:14.721]                       muffled <- FALSE
[18:04:14.721]                       if (inherits(cond, "message")) {
[18:04:14.721]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.721]                         if (muffled) 
[18:04:14.721]                           invokeRestart("muffleMessage")
[18:04:14.721]                       }
[18:04:14.721]                       else if (inherits(cond, "warning")) {
[18:04:14.721]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.721]                         if (muffled) 
[18:04:14.721]                           invokeRestart("muffleWarning")
[18:04:14.721]                       }
[18:04:14.721]                       else if (inherits(cond, "condition")) {
[18:04:14.721]                         if (!is.null(pattern)) {
[18:04:14.721]                           computeRestarts <- base::computeRestarts
[18:04:14.721]                           grepl <- base::grepl
[18:04:14.721]                           restarts <- computeRestarts(cond)
[18:04:14.721]                           for (restart in restarts) {
[18:04:14.721]                             name <- restart$name
[18:04:14.721]                             if (is.null(name)) 
[18:04:14.721]                               next
[18:04:14.721]                             if (!grepl(pattern, name)) 
[18:04:14.721]                               next
[18:04:14.721]                             invokeRestart(restart)
[18:04:14.721]                             muffled <- TRUE
[18:04:14.721]                             break
[18:04:14.721]                           }
[18:04:14.721]                         }
[18:04:14.721]                       }
[18:04:14.721]                       invisible(muffled)
[18:04:14.721]                     }
[18:04:14.721]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.721]                   }
[18:04:14.721]                 }
[18:04:14.721]             }
[18:04:14.721]         }))
[18:04:14.721]     }, error = function(ex) {
[18:04:14.721]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.721]                 ...future.rng), started = ...future.startTime, 
[18:04:14.721]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.721]             version = "1.8"), class = "FutureResult")
[18:04:14.721]     }, finally = {
[18:04:14.721]         if (!identical(...future.workdir, getwd())) 
[18:04:14.721]             setwd(...future.workdir)
[18:04:14.721]         {
[18:04:14.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.721]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.721]             }
[18:04:14.721]             base::options(...future.oldOptions)
[18:04:14.721]             if (.Platform$OS.type == "windows") {
[18:04:14.721]                 old_names <- names(...future.oldEnvVars)
[18:04:14.721]                 envs <- base::Sys.getenv()
[18:04:14.721]                 names <- names(envs)
[18:04:14.721]                 common <- intersect(names, old_names)
[18:04:14.721]                 added <- setdiff(names, old_names)
[18:04:14.721]                 removed <- setdiff(old_names, names)
[18:04:14.721]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.721]                   envs[common]]
[18:04:14.721]                 NAMES <- toupper(changed)
[18:04:14.721]                 args <- list()
[18:04:14.721]                 for (kk in seq_along(NAMES)) {
[18:04:14.721]                   name <- changed[[kk]]
[18:04:14.721]                   NAME <- NAMES[[kk]]
[18:04:14.721]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.721]                     next
[18:04:14.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.721]                 }
[18:04:14.721]                 NAMES <- toupper(added)
[18:04:14.721]                 for (kk in seq_along(NAMES)) {
[18:04:14.721]                   name <- added[[kk]]
[18:04:14.721]                   NAME <- NAMES[[kk]]
[18:04:14.721]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.721]                     next
[18:04:14.721]                   args[[name]] <- ""
[18:04:14.721]                 }
[18:04:14.721]                 NAMES <- toupper(removed)
[18:04:14.721]                 for (kk in seq_along(NAMES)) {
[18:04:14.721]                   name <- removed[[kk]]
[18:04:14.721]                   NAME <- NAMES[[kk]]
[18:04:14.721]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.721]                     next
[18:04:14.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.721]                 }
[18:04:14.721]                 if (length(args) > 0) 
[18:04:14.721]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.721]             }
[18:04:14.721]             else {
[18:04:14.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.721]             }
[18:04:14.721]             {
[18:04:14.721]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.721]                   0L) {
[18:04:14.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.721]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.721]                   base::options(opts)
[18:04:14.721]                 }
[18:04:14.721]                 {
[18:04:14.721]                   {
[18:04:14.721]                     NULL
[18:04:14.721]                     RNGkind("Mersenne-Twister")
[18:04:14.721]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.721]                       inherits = FALSE)
[18:04:14.721]                   }
[18:04:14.721]                   options(future.plan = NULL)
[18:04:14.721]                   if (is.na(NA_character_)) 
[18:04:14.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.721]                     .init = FALSE)
[18:04:14.721]                 }
[18:04:14.721]             }
[18:04:14.721]         }
[18:04:14.721]     })
[18:04:14.721]     if (TRUE) {
[18:04:14.721]         base::sink(type = "output", split = FALSE)
[18:04:14.721]         if (TRUE) {
[18:04:14.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.721]         }
[18:04:14.721]         else {
[18:04:14.721]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.721]         }
[18:04:14.721]         base::close(...future.stdout)
[18:04:14.721]         ...future.stdout <- NULL
[18:04:14.721]     }
[18:04:14.721]     ...future.result$conditions <- ...future.conditions
[18:04:14.721]     ...future.result$finished <- base::Sys.time()
[18:04:14.721]     ...future.result
[18:04:14.721] }
[18:04:14.724] plan(): Setting new future strategy stack:
[18:04:14.725] List of future strategies:
[18:04:14.725] 1. sequential:
[18:04:14.725]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.725]    - tweaked: FALSE
[18:04:14.725]    - call: NULL
[18:04:14.726] plan(): nbrOfWorkers() = 1
[18:04:14.727] plan(): Setting new future strategy stack:
[18:04:14.727] List of future strategies:
[18:04:14.727] 1. sequential:
[18:04:14.727]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.727]    - tweaked: FALSE
[18:04:14.727]    - call: plan(strategy)
[18:04:14.728] plan(): nbrOfWorkers() = 1
[18:04:14.729] SequentialFuture started (and completed)
[18:04:14.729] - Launch lazy future ... done
[18:04:14.729] run() for ‘SequentialFuture’ ... done
<environment: 0x5e3c2aca1390> 
<environment: 0x5e3c299f4488> 
[18:04:14.732] resolved() for ‘SequentialFuture’ ...
[18:04:14.732] - state: ‘finished’
[18:04:14.733] - run: TRUE
[18:04:14.733] - result: ‘FutureResult’
[18:04:14.733] resolved() for ‘SequentialFuture’ ... done
[18:04:14.733] resolved() for ‘SequentialFuture’ ...
[18:04:14.734] - state: ‘finished’
[18:04:14.734] - run: TRUE
[18:04:14.734] - result: ‘FutureResult’
[18:04:14.734] resolved() for ‘SequentialFuture’ ... done
[18:04:14.734] resolved() for ‘SequentialFuture’ ...
[18:04:14.735] - state: ‘finished’
[18:04:14.735] - run: TRUE
[18:04:14.735] - result: ‘FutureResult’
[18:04:14.735] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:14.738] resolve() on environment ...
[18:04:14.738]  recursive: 0
[18:04:14.739]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:14.740] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.740] - nx: 4
[18:04:14.740] - relay: TRUE
[18:04:14.740] - stdout: TRUE
[18:04:14.740] - signal: TRUE
[18:04:14.740] - resignal: FALSE
[18:04:14.741] - force: TRUE
[18:04:14.741] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.741] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.741]  - until=2
[18:04:14.741]  - relaying element #2
[18:04:14.742] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.742] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.742] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.742]  length: 3 (resolved future 1)
[18:04:14.742] resolved() for ‘SequentialFuture’ ...
[18:04:14.743] - state: ‘finished’
[18:04:14.743] - run: TRUE
[18:04:14.743] - result: ‘FutureResult’
[18:04:14.743] resolved() for ‘SequentialFuture’ ... done
[18:04:14.743] Future #2
[18:04:14.744] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.744] - nx: 4
[18:04:14.744] - relay: TRUE
[18:04:14.744] - stdout: TRUE
[18:04:14.744] - signal: TRUE
[18:04:14.745] - resignal: FALSE
[18:04:14.745] - force: TRUE
[18:04:14.745] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.745] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.745]  - until=2
[18:04:14.746]  - relaying element #2
[18:04:14.746] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.746] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.746] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.747]  length: 2 (resolved future 2)
[18:04:14.747] resolved() for ‘SequentialFuture’ ...
[18:04:14.747] - state: ‘finished’
[18:04:14.747] - run: TRUE
[18:04:14.748] - result: ‘FutureResult’
[18:04:14.748] resolved() for ‘SequentialFuture’ ... done
[18:04:14.748] Future #3
[18:04:14.748] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.749] - nx: 4
[18:04:14.749] - relay: TRUE
[18:04:14.749] - stdout: TRUE
[18:04:14.749] - signal: TRUE
[18:04:14.749] - resignal: FALSE
[18:04:14.749] - force: TRUE
[18:04:14.750] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.750] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.750]  - until=3
[18:04:14.750]  - relaying element #3
[18:04:14.751] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.751] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.751] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.751]  length: 1 (resolved future 3)
[18:04:14.751] resolved() for ‘SequentialFuture’ ...
[18:04:14.752] - state: ‘finished’
[18:04:14.752] - run: TRUE
[18:04:14.752] - result: ‘FutureResult’
[18:04:14.752] resolved() for ‘SequentialFuture’ ... done
[18:04:14.752] Future #4
[18:04:14.753] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:14.753] - nx: 4
[18:04:14.753] - relay: TRUE
[18:04:14.753] - stdout: TRUE
[18:04:14.753] - signal: TRUE
[18:04:14.754] - resignal: FALSE
[18:04:14.754] - force: TRUE
[18:04:14.754] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.754] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.754]  - until=4
[18:04:14.755]  - relaying element #4
[18:04:14.755] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.755] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.755] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:14.756]  length: 0 (resolved future 4)
[18:04:14.756] Relaying remaining futures
[18:04:14.756] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.756] - nx: 4
[18:04:14.756] - relay: TRUE
[18:04:14.757] - stdout: TRUE
[18:04:14.757] - signal: TRUE
[18:04:14.757] - resignal: FALSE
[18:04:14.757] - force: TRUE
[18:04:14.757] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.757] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:14.758] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.758] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.758] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.758] resolve() on environment ... DONE
<environment: 0x5e3c2ac261d8> 
Dimensions: c(2, 3, 1)
[18:04:14.760] getGlobalsAndPackages() ...
[18:04:14.760] Searching for globals...
[18:04:14.760] 
[18:04:14.761] Searching for globals ... DONE
[18:04:14.761] - globals: [0] <none>
[18:04:14.761] getGlobalsAndPackages() ... DONE
[18:04:14.762] run() for ‘Future’ ...
[18:04:14.762] - state: ‘created’
[18:04:14.762] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.763] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.763]   - Field: ‘label’
[18:04:14.763]   - Field: ‘local’
[18:04:14.764]   - Field: ‘owner’
[18:04:14.764]   - Field: ‘envir’
[18:04:14.764]   - Field: ‘packages’
[18:04:14.764]   - Field: ‘gc’
[18:04:14.764]   - Field: ‘conditions’
[18:04:14.765]   - Field: ‘expr’
[18:04:14.765]   - Field: ‘uuid’
[18:04:14.765]   - Field: ‘seed’
[18:04:14.765]   - Field: ‘version’
[18:04:14.765]   - Field: ‘result’
[18:04:14.766]   - Field: ‘asynchronous’
[18:04:14.766]   - Field: ‘calls’
[18:04:14.766]   - Field: ‘globals’
[18:04:14.766]   - Field: ‘stdout’
[18:04:14.766]   - Field: ‘earlySignal’
[18:04:14.767]   - Field: ‘lazy’
[18:04:14.767]   - Field: ‘state’
[18:04:14.767] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.767] - Launch lazy future ...
[18:04:14.768] Packages needed by the future expression (n = 0): <none>
[18:04:14.768] Packages needed by future strategies (n = 0): <none>
[18:04:14.769] {
[18:04:14.769]     {
[18:04:14.769]         {
[18:04:14.769]             ...future.startTime <- base::Sys.time()
[18:04:14.769]             {
[18:04:14.769]                 {
[18:04:14.769]                   {
[18:04:14.769]                     base::local({
[18:04:14.769]                       has_future <- base::requireNamespace("future", 
[18:04:14.769]                         quietly = TRUE)
[18:04:14.769]                       if (has_future) {
[18:04:14.769]                         ns <- base::getNamespace("future")
[18:04:14.769]                         version <- ns[[".package"]][["version"]]
[18:04:14.769]                         if (is.null(version)) 
[18:04:14.769]                           version <- utils::packageVersion("future")
[18:04:14.769]                       }
[18:04:14.769]                       else {
[18:04:14.769]                         version <- NULL
[18:04:14.769]                       }
[18:04:14.769]                       if (!has_future || version < "1.8.0") {
[18:04:14.769]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.769]                           "", base::R.version$version.string), 
[18:04:14.769]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.769]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.769]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.769]                             "release", "version")], collapse = " "), 
[18:04:14.769]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.769]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.769]                           info)
[18:04:14.769]                         info <- base::paste(info, collapse = "; ")
[18:04:14.769]                         if (!has_future) {
[18:04:14.769]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.769]                             info)
[18:04:14.769]                         }
[18:04:14.769]                         else {
[18:04:14.769]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.769]                             info, version)
[18:04:14.769]                         }
[18:04:14.769]                         base::stop(msg)
[18:04:14.769]                       }
[18:04:14.769]                     })
[18:04:14.769]                   }
[18:04:14.769]                   ...future.strategy.old <- future::plan("list")
[18:04:14.769]                   options(future.plan = NULL)
[18:04:14.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.769]                 }
[18:04:14.769]                 ...future.workdir <- getwd()
[18:04:14.769]             }
[18:04:14.769]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.769]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.769]         }
[18:04:14.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.769]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.769]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.769]             base::names(...future.oldOptions))
[18:04:14.769]     }
[18:04:14.769]     if (FALSE) {
[18:04:14.769]     }
[18:04:14.769]     else {
[18:04:14.769]         if (TRUE) {
[18:04:14.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.769]                 open = "w")
[18:04:14.769]         }
[18:04:14.769]         else {
[18:04:14.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.769]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.769]         }
[18:04:14.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.769]             base::sink(type = "output", split = FALSE)
[18:04:14.769]             base::close(...future.stdout)
[18:04:14.769]         }, add = TRUE)
[18:04:14.769]     }
[18:04:14.769]     ...future.frame <- base::sys.nframe()
[18:04:14.769]     ...future.conditions <- base::list()
[18:04:14.769]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.769]     if (FALSE) {
[18:04:14.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.769]     }
[18:04:14.769]     ...future.result <- base::tryCatch({
[18:04:14.769]         base::withCallingHandlers({
[18:04:14.769]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.769]             future::FutureResult(value = ...future.value$value, 
[18:04:14.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.769]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.769]                     ...future.globalenv.names))
[18:04:14.769]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.769]         }, condition = base::local({
[18:04:14.769]             c <- base::c
[18:04:14.769]             inherits <- base::inherits
[18:04:14.769]             invokeRestart <- base::invokeRestart
[18:04:14.769]             length <- base::length
[18:04:14.769]             list <- base::list
[18:04:14.769]             seq.int <- base::seq.int
[18:04:14.769]             signalCondition <- base::signalCondition
[18:04:14.769]             sys.calls <- base::sys.calls
[18:04:14.769]             `[[` <- base::`[[`
[18:04:14.769]             `+` <- base::`+`
[18:04:14.769]             `<<-` <- base::`<<-`
[18:04:14.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.769]                   3L)]
[18:04:14.769]             }
[18:04:14.769]             function(cond) {
[18:04:14.769]                 is_error <- inherits(cond, "error")
[18:04:14.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.769]                   NULL)
[18:04:14.769]                 if (is_error) {
[18:04:14.769]                   sessionInformation <- function() {
[18:04:14.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.769]                       search = base::search(), system = base::Sys.info())
[18:04:14.769]                   }
[18:04:14.769]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.769]                     cond$call), session = sessionInformation(), 
[18:04:14.769]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.769]                   signalCondition(cond)
[18:04:14.769]                 }
[18:04:14.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.769]                 "immediateCondition"))) {
[18:04:14.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.769]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.769]                   if (TRUE && !signal) {
[18:04:14.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.769]                     {
[18:04:14.769]                       inherits <- base::inherits
[18:04:14.769]                       invokeRestart <- base::invokeRestart
[18:04:14.769]                       is.null <- base::is.null
[18:04:14.769]                       muffled <- FALSE
[18:04:14.769]                       if (inherits(cond, "message")) {
[18:04:14.769]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.769]                         if (muffled) 
[18:04:14.769]                           invokeRestart("muffleMessage")
[18:04:14.769]                       }
[18:04:14.769]                       else if (inherits(cond, "warning")) {
[18:04:14.769]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.769]                         if (muffled) 
[18:04:14.769]                           invokeRestart("muffleWarning")
[18:04:14.769]                       }
[18:04:14.769]                       else if (inherits(cond, "condition")) {
[18:04:14.769]                         if (!is.null(pattern)) {
[18:04:14.769]                           computeRestarts <- base::computeRestarts
[18:04:14.769]                           grepl <- base::grepl
[18:04:14.769]                           restarts <- computeRestarts(cond)
[18:04:14.769]                           for (restart in restarts) {
[18:04:14.769]                             name <- restart$name
[18:04:14.769]                             if (is.null(name)) 
[18:04:14.769]                               next
[18:04:14.769]                             if (!grepl(pattern, name)) 
[18:04:14.769]                               next
[18:04:14.769]                             invokeRestart(restart)
[18:04:14.769]                             muffled <- TRUE
[18:04:14.769]                             break
[18:04:14.769]                           }
[18:04:14.769]                         }
[18:04:14.769]                       }
[18:04:14.769]                       invisible(muffled)
[18:04:14.769]                     }
[18:04:14.769]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.769]                   }
[18:04:14.769]                 }
[18:04:14.769]                 else {
[18:04:14.769]                   if (TRUE) {
[18:04:14.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.769]                     {
[18:04:14.769]                       inherits <- base::inherits
[18:04:14.769]                       invokeRestart <- base::invokeRestart
[18:04:14.769]                       is.null <- base::is.null
[18:04:14.769]                       muffled <- FALSE
[18:04:14.769]                       if (inherits(cond, "message")) {
[18:04:14.769]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.769]                         if (muffled) 
[18:04:14.769]                           invokeRestart("muffleMessage")
[18:04:14.769]                       }
[18:04:14.769]                       else if (inherits(cond, "warning")) {
[18:04:14.769]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.769]                         if (muffled) 
[18:04:14.769]                           invokeRestart("muffleWarning")
[18:04:14.769]                       }
[18:04:14.769]                       else if (inherits(cond, "condition")) {
[18:04:14.769]                         if (!is.null(pattern)) {
[18:04:14.769]                           computeRestarts <- base::computeRestarts
[18:04:14.769]                           grepl <- base::grepl
[18:04:14.769]                           restarts <- computeRestarts(cond)
[18:04:14.769]                           for (restart in restarts) {
[18:04:14.769]                             name <- restart$name
[18:04:14.769]                             if (is.null(name)) 
[18:04:14.769]                               next
[18:04:14.769]                             if (!grepl(pattern, name)) 
[18:04:14.769]                               next
[18:04:14.769]                             invokeRestart(restart)
[18:04:14.769]                             muffled <- TRUE
[18:04:14.769]                             break
[18:04:14.769]                           }
[18:04:14.769]                         }
[18:04:14.769]                       }
[18:04:14.769]                       invisible(muffled)
[18:04:14.769]                     }
[18:04:14.769]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.769]                   }
[18:04:14.769]                 }
[18:04:14.769]             }
[18:04:14.769]         }))
[18:04:14.769]     }, error = function(ex) {
[18:04:14.769]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.769]                 ...future.rng), started = ...future.startTime, 
[18:04:14.769]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.769]             version = "1.8"), class = "FutureResult")
[18:04:14.769]     }, finally = {
[18:04:14.769]         if (!identical(...future.workdir, getwd())) 
[18:04:14.769]             setwd(...future.workdir)
[18:04:14.769]         {
[18:04:14.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.769]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.769]             }
[18:04:14.769]             base::options(...future.oldOptions)
[18:04:14.769]             if (.Platform$OS.type == "windows") {
[18:04:14.769]                 old_names <- names(...future.oldEnvVars)
[18:04:14.769]                 envs <- base::Sys.getenv()
[18:04:14.769]                 names <- names(envs)
[18:04:14.769]                 common <- intersect(names, old_names)
[18:04:14.769]                 added <- setdiff(names, old_names)
[18:04:14.769]                 removed <- setdiff(old_names, names)
[18:04:14.769]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.769]                   envs[common]]
[18:04:14.769]                 NAMES <- toupper(changed)
[18:04:14.769]                 args <- list()
[18:04:14.769]                 for (kk in seq_along(NAMES)) {
[18:04:14.769]                   name <- changed[[kk]]
[18:04:14.769]                   NAME <- NAMES[[kk]]
[18:04:14.769]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.769]                     next
[18:04:14.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.769]                 }
[18:04:14.769]                 NAMES <- toupper(added)
[18:04:14.769]                 for (kk in seq_along(NAMES)) {
[18:04:14.769]                   name <- added[[kk]]
[18:04:14.769]                   NAME <- NAMES[[kk]]
[18:04:14.769]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.769]                     next
[18:04:14.769]                   args[[name]] <- ""
[18:04:14.769]                 }
[18:04:14.769]                 NAMES <- toupper(removed)
[18:04:14.769]                 for (kk in seq_along(NAMES)) {
[18:04:14.769]                   name <- removed[[kk]]
[18:04:14.769]                   NAME <- NAMES[[kk]]
[18:04:14.769]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.769]                     next
[18:04:14.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.769]                 }
[18:04:14.769]                 if (length(args) > 0) 
[18:04:14.769]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.769]             }
[18:04:14.769]             else {
[18:04:14.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.769]             }
[18:04:14.769]             {
[18:04:14.769]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.769]                   0L) {
[18:04:14.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.769]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.769]                   base::options(opts)
[18:04:14.769]                 }
[18:04:14.769]                 {
[18:04:14.769]                   {
[18:04:14.769]                     NULL
[18:04:14.769]                     RNGkind("Mersenne-Twister")
[18:04:14.769]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.769]                       inherits = FALSE)
[18:04:14.769]                   }
[18:04:14.769]                   options(future.plan = NULL)
[18:04:14.769]                   if (is.na(NA_character_)) 
[18:04:14.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.769]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.769]                     .init = FALSE)
[18:04:14.769]                 }
[18:04:14.769]             }
[18:04:14.769]         }
[18:04:14.769]     })
[18:04:14.769]     if (TRUE) {
[18:04:14.769]         base::sink(type = "output", split = FALSE)
[18:04:14.769]         if (TRUE) {
[18:04:14.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.769]         }
[18:04:14.769]         else {
[18:04:14.769]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.769]         }
[18:04:14.769]         base::close(...future.stdout)
[18:04:14.769]         ...future.stdout <- NULL
[18:04:14.769]     }
[18:04:14.769]     ...future.result$conditions <- ...future.conditions
[18:04:14.769]     ...future.result$finished <- base::Sys.time()
[18:04:14.769]     ...future.result
[18:04:14.769] }
[18:04:14.772] plan(): Setting new future strategy stack:
[18:04:14.773] List of future strategies:
[18:04:14.773] 1. sequential:
[18:04:14.773]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.773]    - tweaked: FALSE
[18:04:14.773]    - call: NULL
[18:04:14.777] plan(): nbrOfWorkers() = 1
[18:04:14.778] plan(): Setting new future strategy stack:
[18:04:14.778] List of future strategies:
[18:04:14.778] 1. sequential:
[18:04:14.778]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.778]    - tweaked: FALSE
[18:04:14.778]    - call: plan(strategy)
[18:04:14.779] plan(): nbrOfWorkers() = 1
[18:04:14.780] SequentialFuture started (and completed)
[18:04:14.780] - Launch lazy future ... done
[18:04:14.780] run() for ‘SequentialFuture’ ... done
[18:04:14.781] getGlobalsAndPackages() ...
[18:04:14.781] Searching for globals...
[18:04:14.782] 
[18:04:14.782] Searching for globals ... DONE
[18:04:14.782] - globals: [0] <none>
[18:04:14.783] getGlobalsAndPackages() ... DONE
[18:04:14.783] run() for ‘Future’ ...
[18:04:14.783] - state: ‘created’
[18:04:14.784] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.784] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.785]   - Field: ‘label’
[18:04:14.785]   - Field: ‘local’
[18:04:14.785]   - Field: ‘owner’
[18:04:14.785]   - Field: ‘envir’
[18:04:14.785]   - Field: ‘packages’
[18:04:14.786]   - Field: ‘gc’
[18:04:14.786]   - Field: ‘conditions’
[18:04:14.786]   - Field: ‘expr’
[18:04:14.786]   - Field: ‘uuid’
[18:04:14.786]   - Field: ‘seed’
[18:04:14.787]   - Field: ‘version’
[18:04:14.787]   - Field: ‘result’
[18:04:14.787]   - Field: ‘asynchronous’
[18:04:14.787]   - Field: ‘calls’
[18:04:14.787]   - Field: ‘globals’
[18:04:14.788]   - Field: ‘stdout’
[18:04:14.788]   - Field: ‘earlySignal’
[18:04:14.788]   - Field: ‘lazy’
[18:04:14.788]   - Field: ‘state’
[18:04:14.788] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.789] - Launch lazy future ...
[18:04:14.789] Packages needed by the future expression (n = 0): <none>
[18:04:14.789] Packages needed by future strategies (n = 0): <none>
[18:04:14.790] {
[18:04:14.790]     {
[18:04:14.790]         {
[18:04:14.790]             ...future.startTime <- base::Sys.time()
[18:04:14.790]             {
[18:04:14.790]                 {
[18:04:14.790]                   {
[18:04:14.790]                     base::local({
[18:04:14.790]                       has_future <- base::requireNamespace("future", 
[18:04:14.790]                         quietly = TRUE)
[18:04:14.790]                       if (has_future) {
[18:04:14.790]                         ns <- base::getNamespace("future")
[18:04:14.790]                         version <- ns[[".package"]][["version"]]
[18:04:14.790]                         if (is.null(version)) 
[18:04:14.790]                           version <- utils::packageVersion("future")
[18:04:14.790]                       }
[18:04:14.790]                       else {
[18:04:14.790]                         version <- NULL
[18:04:14.790]                       }
[18:04:14.790]                       if (!has_future || version < "1.8.0") {
[18:04:14.790]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.790]                           "", base::R.version$version.string), 
[18:04:14.790]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.790]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.790]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.790]                             "release", "version")], collapse = " "), 
[18:04:14.790]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.790]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.790]                           info)
[18:04:14.790]                         info <- base::paste(info, collapse = "; ")
[18:04:14.790]                         if (!has_future) {
[18:04:14.790]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.790]                             info)
[18:04:14.790]                         }
[18:04:14.790]                         else {
[18:04:14.790]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.790]                             info, version)
[18:04:14.790]                         }
[18:04:14.790]                         base::stop(msg)
[18:04:14.790]                       }
[18:04:14.790]                     })
[18:04:14.790]                   }
[18:04:14.790]                   ...future.strategy.old <- future::plan("list")
[18:04:14.790]                   options(future.plan = NULL)
[18:04:14.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.790]                 }
[18:04:14.790]                 ...future.workdir <- getwd()
[18:04:14.790]             }
[18:04:14.790]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.790]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.790]         }
[18:04:14.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.790]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.790]             base::names(...future.oldOptions))
[18:04:14.790]     }
[18:04:14.790]     if (FALSE) {
[18:04:14.790]     }
[18:04:14.790]     else {
[18:04:14.790]         if (TRUE) {
[18:04:14.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.790]                 open = "w")
[18:04:14.790]         }
[18:04:14.790]         else {
[18:04:14.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.790]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.790]         }
[18:04:14.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.790]             base::sink(type = "output", split = FALSE)
[18:04:14.790]             base::close(...future.stdout)
[18:04:14.790]         }, add = TRUE)
[18:04:14.790]     }
[18:04:14.790]     ...future.frame <- base::sys.nframe()
[18:04:14.790]     ...future.conditions <- base::list()
[18:04:14.790]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.790]     if (FALSE) {
[18:04:14.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.790]     }
[18:04:14.790]     ...future.result <- base::tryCatch({
[18:04:14.790]         base::withCallingHandlers({
[18:04:14.790]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.790]             future::FutureResult(value = ...future.value$value, 
[18:04:14.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.790]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.790]                     ...future.globalenv.names))
[18:04:14.790]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.790]         }, condition = base::local({
[18:04:14.790]             c <- base::c
[18:04:14.790]             inherits <- base::inherits
[18:04:14.790]             invokeRestart <- base::invokeRestart
[18:04:14.790]             length <- base::length
[18:04:14.790]             list <- base::list
[18:04:14.790]             seq.int <- base::seq.int
[18:04:14.790]             signalCondition <- base::signalCondition
[18:04:14.790]             sys.calls <- base::sys.calls
[18:04:14.790]             `[[` <- base::`[[`
[18:04:14.790]             `+` <- base::`+`
[18:04:14.790]             `<<-` <- base::`<<-`
[18:04:14.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.790]                   3L)]
[18:04:14.790]             }
[18:04:14.790]             function(cond) {
[18:04:14.790]                 is_error <- inherits(cond, "error")
[18:04:14.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.790]                   NULL)
[18:04:14.790]                 if (is_error) {
[18:04:14.790]                   sessionInformation <- function() {
[18:04:14.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.790]                       search = base::search(), system = base::Sys.info())
[18:04:14.790]                   }
[18:04:14.790]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.790]                     cond$call), session = sessionInformation(), 
[18:04:14.790]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.790]                   signalCondition(cond)
[18:04:14.790]                 }
[18:04:14.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.790]                 "immediateCondition"))) {
[18:04:14.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.790]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.790]                   if (TRUE && !signal) {
[18:04:14.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.790]                     {
[18:04:14.790]                       inherits <- base::inherits
[18:04:14.790]                       invokeRestart <- base::invokeRestart
[18:04:14.790]                       is.null <- base::is.null
[18:04:14.790]                       muffled <- FALSE
[18:04:14.790]                       if (inherits(cond, "message")) {
[18:04:14.790]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.790]                         if (muffled) 
[18:04:14.790]                           invokeRestart("muffleMessage")
[18:04:14.790]                       }
[18:04:14.790]                       else if (inherits(cond, "warning")) {
[18:04:14.790]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.790]                         if (muffled) 
[18:04:14.790]                           invokeRestart("muffleWarning")
[18:04:14.790]                       }
[18:04:14.790]                       else if (inherits(cond, "condition")) {
[18:04:14.790]                         if (!is.null(pattern)) {
[18:04:14.790]                           computeRestarts <- base::computeRestarts
[18:04:14.790]                           grepl <- base::grepl
[18:04:14.790]                           restarts <- computeRestarts(cond)
[18:04:14.790]                           for (restart in restarts) {
[18:04:14.790]                             name <- restart$name
[18:04:14.790]                             if (is.null(name)) 
[18:04:14.790]                               next
[18:04:14.790]                             if (!grepl(pattern, name)) 
[18:04:14.790]                               next
[18:04:14.790]                             invokeRestart(restart)
[18:04:14.790]                             muffled <- TRUE
[18:04:14.790]                             break
[18:04:14.790]                           }
[18:04:14.790]                         }
[18:04:14.790]                       }
[18:04:14.790]                       invisible(muffled)
[18:04:14.790]                     }
[18:04:14.790]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.790]                   }
[18:04:14.790]                 }
[18:04:14.790]                 else {
[18:04:14.790]                   if (TRUE) {
[18:04:14.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.790]                     {
[18:04:14.790]                       inherits <- base::inherits
[18:04:14.790]                       invokeRestart <- base::invokeRestart
[18:04:14.790]                       is.null <- base::is.null
[18:04:14.790]                       muffled <- FALSE
[18:04:14.790]                       if (inherits(cond, "message")) {
[18:04:14.790]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.790]                         if (muffled) 
[18:04:14.790]                           invokeRestart("muffleMessage")
[18:04:14.790]                       }
[18:04:14.790]                       else if (inherits(cond, "warning")) {
[18:04:14.790]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.790]                         if (muffled) 
[18:04:14.790]                           invokeRestart("muffleWarning")
[18:04:14.790]                       }
[18:04:14.790]                       else if (inherits(cond, "condition")) {
[18:04:14.790]                         if (!is.null(pattern)) {
[18:04:14.790]                           computeRestarts <- base::computeRestarts
[18:04:14.790]                           grepl <- base::grepl
[18:04:14.790]                           restarts <- computeRestarts(cond)
[18:04:14.790]                           for (restart in restarts) {
[18:04:14.790]                             name <- restart$name
[18:04:14.790]                             if (is.null(name)) 
[18:04:14.790]                               next
[18:04:14.790]                             if (!grepl(pattern, name)) 
[18:04:14.790]                               next
[18:04:14.790]                             invokeRestart(restart)
[18:04:14.790]                             muffled <- TRUE
[18:04:14.790]                             break
[18:04:14.790]                           }
[18:04:14.790]                         }
[18:04:14.790]                       }
[18:04:14.790]                       invisible(muffled)
[18:04:14.790]                     }
[18:04:14.790]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.790]                   }
[18:04:14.790]                 }
[18:04:14.790]             }
[18:04:14.790]         }))
[18:04:14.790]     }, error = function(ex) {
[18:04:14.790]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.790]                 ...future.rng), started = ...future.startTime, 
[18:04:14.790]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.790]             version = "1.8"), class = "FutureResult")
[18:04:14.790]     }, finally = {
[18:04:14.790]         if (!identical(...future.workdir, getwd())) 
[18:04:14.790]             setwd(...future.workdir)
[18:04:14.790]         {
[18:04:14.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.790]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.790]             }
[18:04:14.790]             base::options(...future.oldOptions)
[18:04:14.790]             if (.Platform$OS.type == "windows") {
[18:04:14.790]                 old_names <- names(...future.oldEnvVars)
[18:04:14.790]                 envs <- base::Sys.getenv()
[18:04:14.790]                 names <- names(envs)
[18:04:14.790]                 common <- intersect(names, old_names)
[18:04:14.790]                 added <- setdiff(names, old_names)
[18:04:14.790]                 removed <- setdiff(old_names, names)
[18:04:14.790]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.790]                   envs[common]]
[18:04:14.790]                 NAMES <- toupper(changed)
[18:04:14.790]                 args <- list()
[18:04:14.790]                 for (kk in seq_along(NAMES)) {
[18:04:14.790]                   name <- changed[[kk]]
[18:04:14.790]                   NAME <- NAMES[[kk]]
[18:04:14.790]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.790]                     next
[18:04:14.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.790]                 }
[18:04:14.790]                 NAMES <- toupper(added)
[18:04:14.790]                 for (kk in seq_along(NAMES)) {
[18:04:14.790]                   name <- added[[kk]]
[18:04:14.790]                   NAME <- NAMES[[kk]]
[18:04:14.790]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.790]                     next
[18:04:14.790]                   args[[name]] <- ""
[18:04:14.790]                 }
[18:04:14.790]                 NAMES <- toupper(removed)
[18:04:14.790]                 for (kk in seq_along(NAMES)) {
[18:04:14.790]                   name <- removed[[kk]]
[18:04:14.790]                   NAME <- NAMES[[kk]]
[18:04:14.790]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.790]                     next
[18:04:14.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.790]                 }
[18:04:14.790]                 if (length(args) > 0) 
[18:04:14.790]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.790]             }
[18:04:14.790]             else {
[18:04:14.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.790]             }
[18:04:14.790]             {
[18:04:14.790]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.790]                   0L) {
[18:04:14.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.790]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.790]                   base::options(opts)
[18:04:14.790]                 }
[18:04:14.790]                 {
[18:04:14.790]                   {
[18:04:14.790]                     NULL
[18:04:14.790]                     RNGkind("Mersenne-Twister")
[18:04:14.790]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.790]                       inherits = FALSE)
[18:04:14.790]                   }
[18:04:14.790]                   options(future.plan = NULL)
[18:04:14.790]                   if (is.na(NA_character_)) 
[18:04:14.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.790]                     .init = FALSE)
[18:04:14.790]                 }
[18:04:14.790]             }
[18:04:14.790]         }
[18:04:14.790]     })
[18:04:14.790]     if (TRUE) {
[18:04:14.790]         base::sink(type = "output", split = FALSE)
[18:04:14.790]         if (TRUE) {
[18:04:14.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.790]         }
[18:04:14.790]         else {
[18:04:14.790]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.790]         }
[18:04:14.790]         base::close(...future.stdout)
[18:04:14.790]         ...future.stdout <- NULL
[18:04:14.790]     }
[18:04:14.790]     ...future.result$conditions <- ...future.conditions
[18:04:14.790]     ...future.result$finished <- base::Sys.time()
[18:04:14.790]     ...future.result
[18:04:14.790] }
[18:04:14.794] plan(): Setting new future strategy stack:
[18:04:14.794] List of future strategies:
[18:04:14.794] 1. sequential:
[18:04:14.794]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.794]    - tweaked: FALSE
[18:04:14.794]    - call: NULL
[18:04:14.795] plan(): nbrOfWorkers() = 1
[18:04:14.797] plan(): Setting new future strategy stack:
[18:04:14.797] List of future strategies:
[18:04:14.797] 1. sequential:
[18:04:14.797]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.797]    - tweaked: FALSE
[18:04:14.797]    - call: plan(strategy)
[18:04:14.798] plan(): nbrOfWorkers() = 1
[18:04:14.798] SequentialFuture started (and completed)
[18:04:14.799] - Launch lazy future ... done
[18:04:14.799] run() for ‘SequentialFuture’ ... done
[18:04:14.800] getGlobalsAndPackages() ...
[18:04:14.800] Searching for globals...
[18:04:14.801] - globals found: [1] ‘{’
[18:04:14.802] Searching for globals ... DONE
[18:04:14.802] Resolving globals: FALSE
[18:04:14.803] 
[18:04:14.803] 
[18:04:14.803] getGlobalsAndPackages() ... DONE
[18:04:14.803] run() for ‘Future’ ...
[18:04:14.804] - state: ‘created’
[18:04:14.804] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.805] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.805] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.805]   - Field: ‘label’
[18:04:14.805]   - Field: ‘local’
[18:04:14.806]   - Field: ‘owner’
[18:04:14.806]   - Field: ‘envir’
[18:04:14.806]   - Field: ‘packages’
[18:04:14.806]   - Field: ‘gc’
[18:04:14.806]   - Field: ‘conditions’
[18:04:14.807]   - Field: ‘expr’
[18:04:14.807]   - Field: ‘uuid’
[18:04:14.807]   - Field: ‘seed’
[18:04:14.807]   - Field: ‘version’
[18:04:14.807]   - Field: ‘result’
[18:04:14.808]   - Field: ‘asynchronous’
[18:04:14.808]   - Field: ‘calls’
[18:04:14.808]   - Field: ‘globals’
[18:04:14.808]   - Field: ‘stdout’
[18:04:14.808]   - Field: ‘earlySignal’
[18:04:14.809]   - Field: ‘lazy’
[18:04:14.809]   - Field: ‘state’
[18:04:14.809] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.809] - Launch lazy future ...
[18:04:14.810] Packages needed by the future expression (n = 0): <none>
[18:04:14.810] Packages needed by future strategies (n = 0): <none>
[18:04:14.811] {
[18:04:14.811]     {
[18:04:14.811]         {
[18:04:14.811]             ...future.startTime <- base::Sys.time()
[18:04:14.811]             {
[18:04:14.811]                 {
[18:04:14.811]                   {
[18:04:14.811]                     base::local({
[18:04:14.811]                       has_future <- base::requireNamespace("future", 
[18:04:14.811]                         quietly = TRUE)
[18:04:14.811]                       if (has_future) {
[18:04:14.811]                         ns <- base::getNamespace("future")
[18:04:14.811]                         version <- ns[[".package"]][["version"]]
[18:04:14.811]                         if (is.null(version)) 
[18:04:14.811]                           version <- utils::packageVersion("future")
[18:04:14.811]                       }
[18:04:14.811]                       else {
[18:04:14.811]                         version <- NULL
[18:04:14.811]                       }
[18:04:14.811]                       if (!has_future || version < "1.8.0") {
[18:04:14.811]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.811]                           "", base::R.version$version.string), 
[18:04:14.811]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.811]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.811]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.811]                             "release", "version")], collapse = " "), 
[18:04:14.811]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.811]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.811]                           info)
[18:04:14.811]                         info <- base::paste(info, collapse = "; ")
[18:04:14.811]                         if (!has_future) {
[18:04:14.811]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.811]                             info)
[18:04:14.811]                         }
[18:04:14.811]                         else {
[18:04:14.811]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.811]                             info, version)
[18:04:14.811]                         }
[18:04:14.811]                         base::stop(msg)
[18:04:14.811]                       }
[18:04:14.811]                     })
[18:04:14.811]                   }
[18:04:14.811]                   ...future.strategy.old <- future::plan("list")
[18:04:14.811]                   options(future.plan = NULL)
[18:04:14.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.811]                 }
[18:04:14.811]                 ...future.workdir <- getwd()
[18:04:14.811]             }
[18:04:14.811]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.811]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.811]         }
[18:04:14.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.811]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.811]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.811]             base::names(...future.oldOptions))
[18:04:14.811]     }
[18:04:14.811]     if (FALSE) {
[18:04:14.811]     }
[18:04:14.811]     else {
[18:04:14.811]         if (TRUE) {
[18:04:14.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.811]                 open = "w")
[18:04:14.811]         }
[18:04:14.811]         else {
[18:04:14.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.811]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.811]         }
[18:04:14.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.811]             base::sink(type = "output", split = FALSE)
[18:04:14.811]             base::close(...future.stdout)
[18:04:14.811]         }, add = TRUE)
[18:04:14.811]     }
[18:04:14.811]     ...future.frame <- base::sys.nframe()
[18:04:14.811]     ...future.conditions <- base::list()
[18:04:14.811]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.811]     if (FALSE) {
[18:04:14.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.811]     }
[18:04:14.811]     ...future.result <- base::tryCatch({
[18:04:14.811]         base::withCallingHandlers({
[18:04:14.811]             ...future.value <- base::withVisible(base::local({
[18:04:14.811]                 4
[18:04:14.811]             }))
[18:04:14.811]             future::FutureResult(value = ...future.value$value, 
[18:04:14.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.811]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.811]                     ...future.globalenv.names))
[18:04:14.811]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.811]         }, condition = base::local({
[18:04:14.811]             c <- base::c
[18:04:14.811]             inherits <- base::inherits
[18:04:14.811]             invokeRestart <- base::invokeRestart
[18:04:14.811]             length <- base::length
[18:04:14.811]             list <- base::list
[18:04:14.811]             seq.int <- base::seq.int
[18:04:14.811]             signalCondition <- base::signalCondition
[18:04:14.811]             sys.calls <- base::sys.calls
[18:04:14.811]             `[[` <- base::`[[`
[18:04:14.811]             `+` <- base::`+`
[18:04:14.811]             `<<-` <- base::`<<-`
[18:04:14.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.811]                   3L)]
[18:04:14.811]             }
[18:04:14.811]             function(cond) {
[18:04:14.811]                 is_error <- inherits(cond, "error")
[18:04:14.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.811]                   NULL)
[18:04:14.811]                 if (is_error) {
[18:04:14.811]                   sessionInformation <- function() {
[18:04:14.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.811]                       search = base::search(), system = base::Sys.info())
[18:04:14.811]                   }
[18:04:14.811]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.811]                     cond$call), session = sessionInformation(), 
[18:04:14.811]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.811]                   signalCondition(cond)
[18:04:14.811]                 }
[18:04:14.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.811]                 "immediateCondition"))) {
[18:04:14.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.811]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.811]                   if (TRUE && !signal) {
[18:04:14.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.811]                     {
[18:04:14.811]                       inherits <- base::inherits
[18:04:14.811]                       invokeRestart <- base::invokeRestart
[18:04:14.811]                       is.null <- base::is.null
[18:04:14.811]                       muffled <- FALSE
[18:04:14.811]                       if (inherits(cond, "message")) {
[18:04:14.811]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.811]                         if (muffled) 
[18:04:14.811]                           invokeRestart("muffleMessage")
[18:04:14.811]                       }
[18:04:14.811]                       else if (inherits(cond, "warning")) {
[18:04:14.811]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.811]                         if (muffled) 
[18:04:14.811]                           invokeRestart("muffleWarning")
[18:04:14.811]                       }
[18:04:14.811]                       else if (inherits(cond, "condition")) {
[18:04:14.811]                         if (!is.null(pattern)) {
[18:04:14.811]                           computeRestarts <- base::computeRestarts
[18:04:14.811]                           grepl <- base::grepl
[18:04:14.811]                           restarts <- computeRestarts(cond)
[18:04:14.811]                           for (restart in restarts) {
[18:04:14.811]                             name <- restart$name
[18:04:14.811]                             if (is.null(name)) 
[18:04:14.811]                               next
[18:04:14.811]                             if (!grepl(pattern, name)) 
[18:04:14.811]                               next
[18:04:14.811]                             invokeRestart(restart)
[18:04:14.811]                             muffled <- TRUE
[18:04:14.811]                             break
[18:04:14.811]                           }
[18:04:14.811]                         }
[18:04:14.811]                       }
[18:04:14.811]                       invisible(muffled)
[18:04:14.811]                     }
[18:04:14.811]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.811]                   }
[18:04:14.811]                 }
[18:04:14.811]                 else {
[18:04:14.811]                   if (TRUE) {
[18:04:14.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.811]                     {
[18:04:14.811]                       inherits <- base::inherits
[18:04:14.811]                       invokeRestart <- base::invokeRestart
[18:04:14.811]                       is.null <- base::is.null
[18:04:14.811]                       muffled <- FALSE
[18:04:14.811]                       if (inherits(cond, "message")) {
[18:04:14.811]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.811]                         if (muffled) 
[18:04:14.811]                           invokeRestart("muffleMessage")
[18:04:14.811]                       }
[18:04:14.811]                       else if (inherits(cond, "warning")) {
[18:04:14.811]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.811]                         if (muffled) 
[18:04:14.811]                           invokeRestart("muffleWarning")
[18:04:14.811]                       }
[18:04:14.811]                       else if (inherits(cond, "condition")) {
[18:04:14.811]                         if (!is.null(pattern)) {
[18:04:14.811]                           computeRestarts <- base::computeRestarts
[18:04:14.811]                           grepl <- base::grepl
[18:04:14.811]                           restarts <- computeRestarts(cond)
[18:04:14.811]                           for (restart in restarts) {
[18:04:14.811]                             name <- restart$name
[18:04:14.811]                             if (is.null(name)) 
[18:04:14.811]                               next
[18:04:14.811]                             if (!grepl(pattern, name)) 
[18:04:14.811]                               next
[18:04:14.811]                             invokeRestart(restart)
[18:04:14.811]                             muffled <- TRUE
[18:04:14.811]                             break
[18:04:14.811]                           }
[18:04:14.811]                         }
[18:04:14.811]                       }
[18:04:14.811]                       invisible(muffled)
[18:04:14.811]                     }
[18:04:14.811]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.811]                   }
[18:04:14.811]                 }
[18:04:14.811]             }
[18:04:14.811]         }))
[18:04:14.811]     }, error = function(ex) {
[18:04:14.811]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.811]                 ...future.rng), started = ...future.startTime, 
[18:04:14.811]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.811]             version = "1.8"), class = "FutureResult")
[18:04:14.811]     }, finally = {
[18:04:14.811]         if (!identical(...future.workdir, getwd())) 
[18:04:14.811]             setwd(...future.workdir)
[18:04:14.811]         {
[18:04:14.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.811]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.811]             }
[18:04:14.811]             base::options(...future.oldOptions)
[18:04:14.811]             if (.Platform$OS.type == "windows") {
[18:04:14.811]                 old_names <- names(...future.oldEnvVars)
[18:04:14.811]                 envs <- base::Sys.getenv()
[18:04:14.811]                 names <- names(envs)
[18:04:14.811]                 common <- intersect(names, old_names)
[18:04:14.811]                 added <- setdiff(names, old_names)
[18:04:14.811]                 removed <- setdiff(old_names, names)
[18:04:14.811]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.811]                   envs[common]]
[18:04:14.811]                 NAMES <- toupper(changed)
[18:04:14.811]                 args <- list()
[18:04:14.811]                 for (kk in seq_along(NAMES)) {
[18:04:14.811]                   name <- changed[[kk]]
[18:04:14.811]                   NAME <- NAMES[[kk]]
[18:04:14.811]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.811]                     next
[18:04:14.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.811]                 }
[18:04:14.811]                 NAMES <- toupper(added)
[18:04:14.811]                 for (kk in seq_along(NAMES)) {
[18:04:14.811]                   name <- added[[kk]]
[18:04:14.811]                   NAME <- NAMES[[kk]]
[18:04:14.811]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.811]                     next
[18:04:14.811]                   args[[name]] <- ""
[18:04:14.811]                 }
[18:04:14.811]                 NAMES <- toupper(removed)
[18:04:14.811]                 for (kk in seq_along(NAMES)) {
[18:04:14.811]                   name <- removed[[kk]]
[18:04:14.811]                   NAME <- NAMES[[kk]]
[18:04:14.811]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.811]                     next
[18:04:14.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.811]                 }
[18:04:14.811]                 if (length(args) > 0) 
[18:04:14.811]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.811]             }
[18:04:14.811]             else {
[18:04:14.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.811]             }
[18:04:14.811]             {
[18:04:14.811]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.811]                   0L) {
[18:04:14.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.811]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.811]                   base::options(opts)
[18:04:14.811]                 }
[18:04:14.811]                 {
[18:04:14.811]                   {
[18:04:14.811]                     NULL
[18:04:14.811]                     RNGkind("Mersenne-Twister")
[18:04:14.811]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.811]                       inherits = FALSE)
[18:04:14.811]                   }
[18:04:14.811]                   options(future.plan = NULL)
[18:04:14.811]                   if (is.na(NA_character_)) 
[18:04:14.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.811]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.811]                     .init = FALSE)
[18:04:14.811]                 }
[18:04:14.811]             }
[18:04:14.811]         }
[18:04:14.811]     })
[18:04:14.811]     if (TRUE) {
[18:04:14.811]         base::sink(type = "output", split = FALSE)
[18:04:14.811]         if (TRUE) {
[18:04:14.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.811]         }
[18:04:14.811]         else {
[18:04:14.811]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.811]         }
[18:04:14.811]         base::close(...future.stdout)
[18:04:14.811]         ...future.stdout <- NULL
[18:04:14.811]     }
[18:04:14.811]     ...future.result$conditions <- ...future.conditions
[18:04:14.811]     ...future.result$finished <- base::Sys.time()
[18:04:14.811]     ...future.result
[18:04:14.811] }
[18:04:14.815] plan(): Setting new future strategy stack:
[18:04:14.815] List of future strategies:
[18:04:14.815] 1. sequential:
[18:04:14.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.815]    - tweaked: FALSE
[18:04:14.815]    - call: NULL
[18:04:14.816] plan(): nbrOfWorkers() = 1
[18:04:14.817] plan(): Setting new future strategy stack:
[18:04:14.818] List of future strategies:
[18:04:14.818] 1. sequential:
[18:04:14.818]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.818]    - tweaked: FALSE
[18:04:14.818]    - call: plan(strategy)
[18:04:14.819] plan(): nbrOfWorkers() = 1
[18:04:14.819] SequentialFuture started (and completed)
[18:04:14.819] - Launch lazy future ... done
[18:04:14.819] run() for ‘SequentialFuture’ ... done
<environment: 0x5e3c2b420568> 
<environment: 0x5e3c2b21c790> 
[18:04:14.822] resolved() for ‘SequentialFuture’ ...
[18:04:14.823] - state: ‘finished’
[18:04:14.823] - run: TRUE
[18:04:14.823] - result: ‘FutureResult’
[18:04:14.823] resolved() for ‘SequentialFuture’ ... done
[18:04:14.824] resolved() for ‘SequentialFuture’ ...
[18:04:14.824] - state: ‘finished’
[18:04:14.824] - run: TRUE
[18:04:14.824] - result: ‘FutureResult’
[18:04:14.824] resolved() for ‘SequentialFuture’ ... done
[18:04:14.825] resolved() for ‘SequentialFuture’ ...
[18:04:14.825] - state: ‘finished’
[18:04:14.825] - run: TRUE
[18:04:14.825] - result: ‘FutureResult’
[18:04:14.825] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:14.828] resolve() on environment ...
[18:04:14.828]  recursive: 0
[18:04:14.829]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:14.830] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.830] - nx: 4
[18:04:14.830] - relay: TRUE
[18:04:14.830] - stdout: TRUE
[18:04:14.830] - signal: TRUE
[18:04:14.831] - resignal: FALSE
[18:04:14.831] - force: TRUE
[18:04:14.831] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.831] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.831]  - until=2
[18:04:14.832]  - relaying element #2
[18:04:14.832] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.832] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.832] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.832]  length: 3 (resolved future 1)
[18:04:14.833] resolved() for ‘SequentialFuture’ ...
[18:04:14.833] - state: ‘finished’
[18:04:14.833] - run: TRUE
[18:04:14.833] - result: ‘FutureResult’
[18:04:14.833] resolved() for ‘SequentialFuture’ ... done
[18:04:14.834] Future #2
[18:04:14.834] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.834] - nx: 4
[18:04:14.834] - relay: TRUE
[18:04:14.835] - stdout: TRUE
[18:04:14.835] - signal: TRUE
[18:04:14.835] - resignal: FALSE
[18:04:14.835] - force: TRUE
[18:04:14.835] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.835] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.836]  - until=2
[18:04:14.836]  - relaying element #2
[18:04:14.836] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.837] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.837] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.837]  length: 2 (resolved future 2)
[18:04:14.837] resolved() for ‘SequentialFuture’ ...
[18:04:14.837] - state: ‘finished’
[18:04:14.838] - run: TRUE
[18:04:14.838] - result: ‘FutureResult’
[18:04:14.838] resolved() for ‘SequentialFuture’ ... done
[18:04:14.838] Future #3
[18:04:14.839] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.839] - nx: 4
[18:04:14.839] - relay: TRUE
[18:04:14.839] - stdout: TRUE
[18:04:14.839] - signal: TRUE
[18:04:14.842] - resignal: FALSE
[18:04:14.843] - force: TRUE
[18:04:14.843] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.843] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.843]  - until=3
[18:04:14.843]  - relaying element #3
[18:04:14.844] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.844] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.844] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.844]  length: 1 (resolved future 3)
[18:04:14.845] resolved() for ‘SequentialFuture’ ...
[18:04:14.845] - state: ‘finished’
[18:04:14.845] - run: TRUE
[18:04:14.845] - result: ‘FutureResult’
[18:04:14.846] resolved() for ‘SequentialFuture’ ... done
[18:04:14.846] Future #4
[18:04:14.846] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:14.846] - nx: 4
[18:04:14.846] - relay: TRUE
[18:04:14.847] - stdout: TRUE
[18:04:14.847] - signal: TRUE
[18:04:14.847] - resignal: FALSE
[18:04:14.847] - force: TRUE
[18:04:14.847] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.848] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.848]  - until=4
[18:04:14.848]  - relaying element #4
[18:04:14.848] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.849] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.849] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:14.849]  length: 0 (resolved future 4)
[18:04:14.849] Relaying remaining futures
[18:04:14.849] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.850] - nx: 4
[18:04:14.850] - relay: TRUE
[18:04:14.850] - stdout: TRUE
[18:04:14.850] - signal: TRUE
[18:04:14.850] - resignal: FALSE
[18:04:14.850] - force: TRUE
[18:04:14.851] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.851] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:14.851] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.851] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.851] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.852] resolve() on environment ... DONE
<environment: 0x5e3c2b3b5d40> 
Dimensions: c(2, 1, 3, 1)
[18:04:14.853] getGlobalsAndPackages() ...
[18:04:14.853] Searching for globals...
[18:04:14.854] 
[18:04:14.854] Searching for globals ... DONE
[18:04:14.854] - globals: [0] <none>
[18:04:14.855] getGlobalsAndPackages() ... DONE
[18:04:14.855] run() for ‘Future’ ...
[18:04:14.855] - state: ‘created’
[18:04:14.856] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.856] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.857]   - Field: ‘label’
[18:04:14.857]   - Field: ‘local’
[18:04:14.857]   - Field: ‘owner’
[18:04:14.857]   - Field: ‘envir’
[18:04:14.857]   - Field: ‘packages’
[18:04:14.858]   - Field: ‘gc’
[18:04:14.858]   - Field: ‘conditions’
[18:04:14.858]   - Field: ‘expr’
[18:04:14.858]   - Field: ‘uuid’
[18:04:14.858]   - Field: ‘seed’
[18:04:14.859]   - Field: ‘version’
[18:04:14.859]   - Field: ‘result’
[18:04:14.859]   - Field: ‘asynchronous’
[18:04:14.859]   - Field: ‘calls’
[18:04:14.859]   - Field: ‘globals’
[18:04:14.860]   - Field: ‘stdout’
[18:04:14.860]   - Field: ‘earlySignal’
[18:04:14.860]   - Field: ‘lazy’
[18:04:14.860]   - Field: ‘state’
[18:04:14.860] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.861] - Launch lazy future ...
[18:04:14.861] Packages needed by the future expression (n = 0): <none>
[18:04:14.861] Packages needed by future strategies (n = 0): <none>
[18:04:14.862] {
[18:04:14.862]     {
[18:04:14.862]         {
[18:04:14.862]             ...future.startTime <- base::Sys.time()
[18:04:14.862]             {
[18:04:14.862]                 {
[18:04:14.862]                   {
[18:04:14.862]                     base::local({
[18:04:14.862]                       has_future <- base::requireNamespace("future", 
[18:04:14.862]                         quietly = TRUE)
[18:04:14.862]                       if (has_future) {
[18:04:14.862]                         ns <- base::getNamespace("future")
[18:04:14.862]                         version <- ns[[".package"]][["version"]]
[18:04:14.862]                         if (is.null(version)) 
[18:04:14.862]                           version <- utils::packageVersion("future")
[18:04:14.862]                       }
[18:04:14.862]                       else {
[18:04:14.862]                         version <- NULL
[18:04:14.862]                       }
[18:04:14.862]                       if (!has_future || version < "1.8.0") {
[18:04:14.862]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.862]                           "", base::R.version$version.string), 
[18:04:14.862]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.862]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.862]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.862]                             "release", "version")], collapse = " "), 
[18:04:14.862]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.862]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.862]                           info)
[18:04:14.862]                         info <- base::paste(info, collapse = "; ")
[18:04:14.862]                         if (!has_future) {
[18:04:14.862]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.862]                             info)
[18:04:14.862]                         }
[18:04:14.862]                         else {
[18:04:14.862]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.862]                             info, version)
[18:04:14.862]                         }
[18:04:14.862]                         base::stop(msg)
[18:04:14.862]                       }
[18:04:14.862]                     })
[18:04:14.862]                   }
[18:04:14.862]                   ...future.strategy.old <- future::plan("list")
[18:04:14.862]                   options(future.plan = NULL)
[18:04:14.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.862]                 }
[18:04:14.862]                 ...future.workdir <- getwd()
[18:04:14.862]             }
[18:04:14.862]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.862]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.862]         }
[18:04:14.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.862]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.862]             base::names(...future.oldOptions))
[18:04:14.862]     }
[18:04:14.862]     if (FALSE) {
[18:04:14.862]     }
[18:04:14.862]     else {
[18:04:14.862]         if (TRUE) {
[18:04:14.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.862]                 open = "w")
[18:04:14.862]         }
[18:04:14.862]         else {
[18:04:14.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.862]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.862]         }
[18:04:14.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.862]             base::sink(type = "output", split = FALSE)
[18:04:14.862]             base::close(...future.stdout)
[18:04:14.862]         }, add = TRUE)
[18:04:14.862]     }
[18:04:14.862]     ...future.frame <- base::sys.nframe()
[18:04:14.862]     ...future.conditions <- base::list()
[18:04:14.862]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.862]     if (FALSE) {
[18:04:14.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.862]     }
[18:04:14.862]     ...future.result <- base::tryCatch({
[18:04:14.862]         base::withCallingHandlers({
[18:04:14.862]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.862]             future::FutureResult(value = ...future.value$value, 
[18:04:14.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.862]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.862]                     ...future.globalenv.names))
[18:04:14.862]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.862]         }, condition = base::local({
[18:04:14.862]             c <- base::c
[18:04:14.862]             inherits <- base::inherits
[18:04:14.862]             invokeRestart <- base::invokeRestart
[18:04:14.862]             length <- base::length
[18:04:14.862]             list <- base::list
[18:04:14.862]             seq.int <- base::seq.int
[18:04:14.862]             signalCondition <- base::signalCondition
[18:04:14.862]             sys.calls <- base::sys.calls
[18:04:14.862]             `[[` <- base::`[[`
[18:04:14.862]             `+` <- base::`+`
[18:04:14.862]             `<<-` <- base::`<<-`
[18:04:14.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.862]                   3L)]
[18:04:14.862]             }
[18:04:14.862]             function(cond) {
[18:04:14.862]                 is_error <- inherits(cond, "error")
[18:04:14.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.862]                   NULL)
[18:04:14.862]                 if (is_error) {
[18:04:14.862]                   sessionInformation <- function() {
[18:04:14.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.862]                       search = base::search(), system = base::Sys.info())
[18:04:14.862]                   }
[18:04:14.862]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.862]                     cond$call), session = sessionInformation(), 
[18:04:14.862]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.862]                   signalCondition(cond)
[18:04:14.862]                 }
[18:04:14.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.862]                 "immediateCondition"))) {
[18:04:14.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.862]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.862]                   if (TRUE && !signal) {
[18:04:14.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.862]                     {
[18:04:14.862]                       inherits <- base::inherits
[18:04:14.862]                       invokeRestart <- base::invokeRestart
[18:04:14.862]                       is.null <- base::is.null
[18:04:14.862]                       muffled <- FALSE
[18:04:14.862]                       if (inherits(cond, "message")) {
[18:04:14.862]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.862]                         if (muffled) 
[18:04:14.862]                           invokeRestart("muffleMessage")
[18:04:14.862]                       }
[18:04:14.862]                       else if (inherits(cond, "warning")) {
[18:04:14.862]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.862]                         if (muffled) 
[18:04:14.862]                           invokeRestart("muffleWarning")
[18:04:14.862]                       }
[18:04:14.862]                       else if (inherits(cond, "condition")) {
[18:04:14.862]                         if (!is.null(pattern)) {
[18:04:14.862]                           computeRestarts <- base::computeRestarts
[18:04:14.862]                           grepl <- base::grepl
[18:04:14.862]                           restarts <- computeRestarts(cond)
[18:04:14.862]                           for (restart in restarts) {
[18:04:14.862]                             name <- restart$name
[18:04:14.862]                             if (is.null(name)) 
[18:04:14.862]                               next
[18:04:14.862]                             if (!grepl(pattern, name)) 
[18:04:14.862]                               next
[18:04:14.862]                             invokeRestart(restart)
[18:04:14.862]                             muffled <- TRUE
[18:04:14.862]                             break
[18:04:14.862]                           }
[18:04:14.862]                         }
[18:04:14.862]                       }
[18:04:14.862]                       invisible(muffled)
[18:04:14.862]                     }
[18:04:14.862]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.862]                   }
[18:04:14.862]                 }
[18:04:14.862]                 else {
[18:04:14.862]                   if (TRUE) {
[18:04:14.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.862]                     {
[18:04:14.862]                       inherits <- base::inherits
[18:04:14.862]                       invokeRestart <- base::invokeRestart
[18:04:14.862]                       is.null <- base::is.null
[18:04:14.862]                       muffled <- FALSE
[18:04:14.862]                       if (inherits(cond, "message")) {
[18:04:14.862]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.862]                         if (muffled) 
[18:04:14.862]                           invokeRestart("muffleMessage")
[18:04:14.862]                       }
[18:04:14.862]                       else if (inherits(cond, "warning")) {
[18:04:14.862]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.862]                         if (muffled) 
[18:04:14.862]                           invokeRestart("muffleWarning")
[18:04:14.862]                       }
[18:04:14.862]                       else if (inherits(cond, "condition")) {
[18:04:14.862]                         if (!is.null(pattern)) {
[18:04:14.862]                           computeRestarts <- base::computeRestarts
[18:04:14.862]                           grepl <- base::grepl
[18:04:14.862]                           restarts <- computeRestarts(cond)
[18:04:14.862]                           for (restart in restarts) {
[18:04:14.862]                             name <- restart$name
[18:04:14.862]                             if (is.null(name)) 
[18:04:14.862]                               next
[18:04:14.862]                             if (!grepl(pattern, name)) 
[18:04:14.862]                               next
[18:04:14.862]                             invokeRestart(restart)
[18:04:14.862]                             muffled <- TRUE
[18:04:14.862]                             break
[18:04:14.862]                           }
[18:04:14.862]                         }
[18:04:14.862]                       }
[18:04:14.862]                       invisible(muffled)
[18:04:14.862]                     }
[18:04:14.862]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.862]                   }
[18:04:14.862]                 }
[18:04:14.862]             }
[18:04:14.862]         }))
[18:04:14.862]     }, error = function(ex) {
[18:04:14.862]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.862]                 ...future.rng), started = ...future.startTime, 
[18:04:14.862]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.862]             version = "1.8"), class = "FutureResult")
[18:04:14.862]     }, finally = {
[18:04:14.862]         if (!identical(...future.workdir, getwd())) 
[18:04:14.862]             setwd(...future.workdir)
[18:04:14.862]         {
[18:04:14.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.862]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.862]             }
[18:04:14.862]             base::options(...future.oldOptions)
[18:04:14.862]             if (.Platform$OS.type == "windows") {
[18:04:14.862]                 old_names <- names(...future.oldEnvVars)
[18:04:14.862]                 envs <- base::Sys.getenv()
[18:04:14.862]                 names <- names(envs)
[18:04:14.862]                 common <- intersect(names, old_names)
[18:04:14.862]                 added <- setdiff(names, old_names)
[18:04:14.862]                 removed <- setdiff(old_names, names)
[18:04:14.862]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.862]                   envs[common]]
[18:04:14.862]                 NAMES <- toupper(changed)
[18:04:14.862]                 args <- list()
[18:04:14.862]                 for (kk in seq_along(NAMES)) {
[18:04:14.862]                   name <- changed[[kk]]
[18:04:14.862]                   NAME <- NAMES[[kk]]
[18:04:14.862]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.862]                     next
[18:04:14.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.862]                 }
[18:04:14.862]                 NAMES <- toupper(added)
[18:04:14.862]                 for (kk in seq_along(NAMES)) {
[18:04:14.862]                   name <- added[[kk]]
[18:04:14.862]                   NAME <- NAMES[[kk]]
[18:04:14.862]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.862]                     next
[18:04:14.862]                   args[[name]] <- ""
[18:04:14.862]                 }
[18:04:14.862]                 NAMES <- toupper(removed)
[18:04:14.862]                 for (kk in seq_along(NAMES)) {
[18:04:14.862]                   name <- removed[[kk]]
[18:04:14.862]                   NAME <- NAMES[[kk]]
[18:04:14.862]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.862]                     next
[18:04:14.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.862]                 }
[18:04:14.862]                 if (length(args) > 0) 
[18:04:14.862]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.862]             }
[18:04:14.862]             else {
[18:04:14.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.862]             }
[18:04:14.862]             {
[18:04:14.862]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.862]                   0L) {
[18:04:14.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.862]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.862]                   base::options(opts)
[18:04:14.862]                 }
[18:04:14.862]                 {
[18:04:14.862]                   {
[18:04:14.862]                     NULL
[18:04:14.862]                     RNGkind("Mersenne-Twister")
[18:04:14.862]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.862]                       inherits = FALSE)
[18:04:14.862]                   }
[18:04:14.862]                   options(future.plan = NULL)
[18:04:14.862]                   if (is.na(NA_character_)) 
[18:04:14.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.862]                     .init = FALSE)
[18:04:14.862]                 }
[18:04:14.862]             }
[18:04:14.862]         }
[18:04:14.862]     })
[18:04:14.862]     if (TRUE) {
[18:04:14.862]         base::sink(type = "output", split = FALSE)
[18:04:14.862]         if (TRUE) {
[18:04:14.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.862]         }
[18:04:14.862]         else {
[18:04:14.862]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.862]         }
[18:04:14.862]         base::close(...future.stdout)
[18:04:14.862]         ...future.stdout <- NULL
[18:04:14.862]     }
[18:04:14.862]     ...future.result$conditions <- ...future.conditions
[18:04:14.862]     ...future.result$finished <- base::Sys.time()
[18:04:14.862]     ...future.result
[18:04:14.862] }
[18:04:14.866] plan(): Setting new future strategy stack:
[18:04:14.866] List of future strategies:
[18:04:14.866] 1. sequential:
[18:04:14.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.866]    - tweaked: FALSE
[18:04:14.866]    - call: NULL
[18:04:14.867] plan(): nbrOfWorkers() = 1
[18:04:14.869] plan(): Setting new future strategy stack:
[18:04:14.869] List of future strategies:
[18:04:14.869] 1. sequential:
[18:04:14.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.869]    - tweaked: FALSE
[18:04:14.869]    - call: plan(strategy)
[18:04:14.870] plan(): nbrOfWorkers() = 1
[18:04:14.871] SequentialFuture started (and completed)
[18:04:14.871] - Launch lazy future ... done
[18:04:14.871] run() for ‘SequentialFuture’ ... done
[18:04:14.871] getGlobalsAndPackages() ...
[18:04:14.872] Searching for globals...
[18:04:14.872] 
[18:04:14.872] Searching for globals ... DONE
[18:04:14.873] - globals: [0] <none>
[18:04:14.873] getGlobalsAndPackages() ... DONE
[18:04:14.873] run() for ‘Future’ ...
[18:04:14.874] - state: ‘created’
[18:04:14.874] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.874] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.875]   - Field: ‘label’
[18:04:14.875]   - Field: ‘local’
[18:04:14.875]   - Field: ‘owner’
[18:04:14.876]   - Field: ‘envir’
[18:04:14.876]   - Field: ‘packages’
[18:04:14.876]   - Field: ‘gc’
[18:04:14.876]   - Field: ‘conditions’
[18:04:14.876]   - Field: ‘expr’
[18:04:14.877]   - Field: ‘uuid’
[18:04:14.877]   - Field: ‘seed’
[18:04:14.877]   - Field: ‘version’
[18:04:14.877]   - Field: ‘result’
[18:04:14.877]   - Field: ‘asynchronous’
[18:04:14.878]   - Field: ‘calls’
[18:04:14.878]   - Field: ‘globals’
[18:04:14.878]   - Field: ‘stdout’
[18:04:14.878]   - Field: ‘earlySignal’
[18:04:14.879]   - Field: ‘lazy’
[18:04:14.879]   - Field: ‘state’
[18:04:14.879] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.879] - Launch lazy future ...
[18:04:14.880] Packages needed by the future expression (n = 0): <none>
[18:04:14.880] Packages needed by future strategies (n = 0): <none>
[18:04:14.881] {
[18:04:14.881]     {
[18:04:14.881]         {
[18:04:14.881]             ...future.startTime <- base::Sys.time()
[18:04:14.881]             {
[18:04:14.881]                 {
[18:04:14.881]                   {
[18:04:14.881]                     base::local({
[18:04:14.881]                       has_future <- base::requireNamespace("future", 
[18:04:14.881]                         quietly = TRUE)
[18:04:14.881]                       if (has_future) {
[18:04:14.881]                         ns <- base::getNamespace("future")
[18:04:14.881]                         version <- ns[[".package"]][["version"]]
[18:04:14.881]                         if (is.null(version)) 
[18:04:14.881]                           version <- utils::packageVersion("future")
[18:04:14.881]                       }
[18:04:14.881]                       else {
[18:04:14.881]                         version <- NULL
[18:04:14.881]                       }
[18:04:14.881]                       if (!has_future || version < "1.8.0") {
[18:04:14.881]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.881]                           "", base::R.version$version.string), 
[18:04:14.881]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.881]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.881]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.881]                             "release", "version")], collapse = " "), 
[18:04:14.881]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.881]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.881]                           info)
[18:04:14.881]                         info <- base::paste(info, collapse = "; ")
[18:04:14.881]                         if (!has_future) {
[18:04:14.881]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.881]                             info)
[18:04:14.881]                         }
[18:04:14.881]                         else {
[18:04:14.881]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.881]                             info, version)
[18:04:14.881]                         }
[18:04:14.881]                         base::stop(msg)
[18:04:14.881]                       }
[18:04:14.881]                     })
[18:04:14.881]                   }
[18:04:14.881]                   ...future.strategy.old <- future::plan("list")
[18:04:14.881]                   options(future.plan = NULL)
[18:04:14.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.881]                 }
[18:04:14.881]                 ...future.workdir <- getwd()
[18:04:14.881]             }
[18:04:14.881]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.881]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.881]         }
[18:04:14.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.881]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.881]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.881]             base::names(...future.oldOptions))
[18:04:14.881]     }
[18:04:14.881]     if (FALSE) {
[18:04:14.881]     }
[18:04:14.881]     else {
[18:04:14.881]         if (TRUE) {
[18:04:14.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.881]                 open = "w")
[18:04:14.881]         }
[18:04:14.881]         else {
[18:04:14.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.881]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.881]         }
[18:04:14.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.881]             base::sink(type = "output", split = FALSE)
[18:04:14.881]             base::close(...future.stdout)
[18:04:14.881]         }, add = TRUE)
[18:04:14.881]     }
[18:04:14.881]     ...future.frame <- base::sys.nframe()
[18:04:14.881]     ...future.conditions <- base::list()
[18:04:14.881]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.881]     if (FALSE) {
[18:04:14.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.881]     }
[18:04:14.881]     ...future.result <- base::tryCatch({
[18:04:14.881]         base::withCallingHandlers({
[18:04:14.881]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.881]             future::FutureResult(value = ...future.value$value, 
[18:04:14.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.881]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.881]                     ...future.globalenv.names))
[18:04:14.881]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.881]         }, condition = base::local({
[18:04:14.881]             c <- base::c
[18:04:14.881]             inherits <- base::inherits
[18:04:14.881]             invokeRestart <- base::invokeRestart
[18:04:14.881]             length <- base::length
[18:04:14.881]             list <- base::list
[18:04:14.881]             seq.int <- base::seq.int
[18:04:14.881]             signalCondition <- base::signalCondition
[18:04:14.881]             sys.calls <- base::sys.calls
[18:04:14.881]             `[[` <- base::`[[`
[18:04:14.881]             `+` <- base::`+`
[18:04:14.881]             `<<-` <- base::`<<-`
[18:04:14.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.881]                   3L)]
[18:04:14.881]             }
[18:04:14.881]             function(cond) {
[18:04:14.881]                 is_error <- inherits(cond, "error")
[18:04:14.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.881]                   NULL)
[18:04:14.881]                 if (is_error) {
[18:04:14.881]                   sessionInformation <- function() {
[18:04:14.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.881]                       search = base::search(), system = base::Sys.info())
[18:04:14.881]                   }
[18:04:14.881]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.881]                     cond$call), session = sessionInformation(), 
[18:04:14.881]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.881]                   signalCondition(cond)
[18:04:14.881]                 }
[18:04:14.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.881]                 "immediateCondition"))) {
[18:04:14.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.881]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.881]                   if (TRUE && !signal) {
[18:04:14.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.881]                     {
[18:04:14.881]                       inherits <- base::inherits
[18:04:14.881]                       invokeRestart <- base::invokeRestart
[18:04:14.881]                       is.null <- base::is.null
[18:04:14.881]                       muffled <- FALSE
[18:04:14.881]                       if (inherits(cond, "message")) {
[18:04:14.881]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.881]                         if (muffled) 
[18:04:14.881]                           invokeRestart("muffleMessage")
[18:04:14.881]                       }
[18:04:14.881]                       else if (inherits(cond, "warning")) {
[18:04:14.881]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.881]                         if (muffled) 
[18:04:14.881]                           invokeRestart("muffleWarning")
[18:04:14.881]                       }
[18:04:14.881]                       else if (inherits(cond, "condition")) {
[18:04:14.881]                         if (!is.null(pattern)) {
[18:04:14.881]                           computeRestarts <- base::computeRestarts
[18:04:14.881]                           grepl <- base::grepl
[18:04:14.881]                           restarts <- computeRestarts(cond)
[18:04:14.881]                           for (restart in restarts) {
[18:04:14.881]                             name <- restart$name
[18:04:14.881]                             if (is.null(name)) 
[18:04:14.881]                               next
[18:04:14.881]                             if (!grepl(pattern, name)) 
[18:04:14.881]                               next
[18:04:14.881]                             invokeRestart(restart)
[18:04:14.881]                             muffled <- TRUE
[18:04:14.881]                             break
[18:04:14.881]                           }
[18:04:14.881]                         }
[18:04:14.881]                       }
[18:04:14.881]                       invisible(muffled)
[18:04:14.881]                     }
[18:04:14.881]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.881]                   }
[18:04:14.881]                 }
[18:04:14.881]                 else {
[18:04:14.881]                   if (TRUE) {
[18:04:14.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.881]                     {
[18:04:14.881]                       inherits <- base::inherits
[18:04:14.881]                       invokeRestart <- base::invokeRestart
[18:04:14.881]                       is.null <- base::is.null
[18:04:14.881]                       muffled <- FALSE
[18:04:14.881]                       if (inherits(cond, "message")) {
[18:04:14.881]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.881]                         if (muffled) 
[18:04:14.881]                           invokeRestart("muffleMessage")
[18:04:14.881]                       }
[18:04:14.881]                       else if (inherits(cond, "warning")) {
[18:04:14.881]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.881]                         if (muffled) 
[18:04:14.881]                           invokeRestart("muffleWarning")
[18:04:14.881]                       }
[18:04:14.881]                       else if (inherits(cond, "condition")) {
[18:04:14.881]                         if (!is.null(pattern)) {
[18:04:14.881]                           computeRestarts <- base::computeRestarts
[18:04:14.881]                           grepl <- base::grepl
[18:04:14.881]                           restarts <- computeRestarts(cond)
[18:04:14.881]                           for (restart in restarts) {
[18:04:14.881]                             name <- restart$name
[18:04:14.881]                             if (is.null(name)) 
[18:04:14.881]                               next
[18:04:14.881]                             if (!grepl(pattern, name)) 
[18:04:14.881]                               next
[18:04:14.881]                             invokeRestart(restart)
[18:04:14.881]                             muffled <- TRUE
[18:04:14.881]                             break
[18:04:14.881]                           }
[18:04:14.881]                         }
[18:04:14.881]                       }
[18:04:14.881]                       invisible(muffled)
[18:04:14.881]                     }
[18:04:14.881]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.881]                   }
[18:04:14.881]                 }
[18:04:14.881]             }
[18:04:14.881]         }))
[18:04:14.881]     }, error = function(ex) {
[18:04:14.881]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.881]                 ...future.rng), started = ...future.startTime, 
[18:04:14.881]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.881]             version = "1.8"), class = "FutureResult")
[18:04:14.881]     }, finally = {
[18:04:14.881]         if (!identical(...future.workdir, getwd())) 
[18:04:14.881]             setwd(...future.workdir)
[18:04:14.881]         {
[18:04:14.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.881]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.881]             }
[18:04:14.881]             base::options(...future.oldOptions)
[18:04:14.881]             if (.Platform$OS.type == "windows") {
[18:04:14.881]                 old_names <- names(...future.oldEnvVars)
[18:04:14.881]                 envs <- base::Sys.getenv()
[18:04:14.881]                 names <- names(envs)
[18:04:14.881]                 common <- intersect(names, old_names)
[18:04:14.881]                 added <- setdiff(names, old_names)
[18:04:14.881]                 removed <- setdiff(old_names, names)
[18:04:14.881]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.881]                   envs[common]]
[18:04:14.881]                 NAMES <- toupper(changed)
[18:04:14.881]                 args <- list()
[18:04:14.881]                 for (kk in seq_along(NAMES)) {
[18:04:14.881]                   name <- changed[[kk]]
[18:04:14.881]                   NAME <- NAMES[[kk]]
[18:04:14.881]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.881]                     next
[18:04:14.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.881]                 }
[18:04:14.881]                 NAMES <- toupper(added)
[18:04:14.881]                 for (kk in seq_along(NAMES)) {
[18:04:14.881]                   name <- added[[kk]]
[18:04:14.881]                   NAME <- NAMES[[kk]]
[18:04:14.881]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.881]                     next
[18:04:14.881]                   args[[name]] <- ""
[18:04:14.881]                 }
[18:04:14.881]                 NAMES <- toupper(removed)
[18:04:14.881]                 for (kk in seq_along(NAMES)) {
[18:04:14.881]                   name <- removed[[kk]]
[18:04:14.881]                   NAME <- NAMES[[kk]]
[18:04:14.881]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.881]                     next
[18:04:14.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.881]                 }
[18:04:14.881]                 if (length(args) > 0) 
[18:04:14.881]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.881]             }
[18:04:14.881]             else {
[18:04:14.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.881]             }
[18:04:14.881]             {
[18:04:14.881]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.881]                   0L) {
[18:04:14.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.881]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.881]                   base::options(opts)
[18:04:14.881]                 }
[18:04:14.881]                 {
[18:04:14.881]                   {
[18:04:14.881]                     NULL
[18:04:14.881]                     RNGkind("Mersenne-Twister")
[18:04:14.881]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.881]                       inherits = FALSE)
[18:04:14.881]                   }
[18:04:14.881]                   options(future.plan = NULL)
[18:04:14.881]                   if (is.na(NA_character_)) 
[18:04:14.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.881]                     .init = FALSE)
[18:04:14.881]                 }
[18:04:14.881]             }
[18:04:14.881]         }
[18:04:14.881]     })
[18:04:14.881]     if (TRUE) {
[18:04:14.881]         base::sink(type = "output", split = FALSE)
[18:04:14.881]         if (TRUE) {
[18:04:14.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.881]         }
[18:04:14.881]         else {
[18:04:14.881]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.881]         }
[18:04:14.881]         base::close(...future.stdout)
[18:04:14.881]         ...future.stdout <- NULL
[18:04:14.881]     }
[18:04:14.881]     ...future.result$conditions <- ...future.conditions
[18:04:14.881]     ...future.result$finished <- base::Sys.time()
[18:04:14.881]     ...future.result
[18:04:14.881] }
[18:04:14.884] plan(): Setting new future strategy stack:
[18:04:14.885] List of future strategies:
[18:04:14.885] 1. sequential:
[18:04:14.885]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.885]    - tweaked: FALSE
[18:04:14.885]    - call: NULL
[18:04:14.886] plan(): nbrOfWorkers() = 1
[18:04:14.887] plan(): Setting new future strategy stack:
[18:04:14.888] List of future strategies:
[18:04:14.888] 1. sequential:
[18:04:14.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.888]    - tweaked: FALSE
[18:04:14.888]    - call: plan(strategy)
[18:04:14.889] plan(): nbrOfWorkers() = 1
[18:04:14.889] SequentialFuture started (and completed)
[18:04:14.889] - Launch lazy future ... done
[18:04:14.890] run() for ‘SequentialFuture’ ... done
[18:04:14.890] getGlobalsAndPackages() ...
[18:04:14.890] Searching for globals...
[18:04:14.892] - globals found: [1] ‘{’
[18:04:14.892] Searching for globals ... DONE
[18:04:14.892] Resolving globals: FALSE
[18:04:14.893] 
[18:04:14.893] 
[18:04:14.893] getGlobalsAndPackages() ... DONE
[18:04:14.894] run() for ‘Future’ ...
[18:04:14.894] - state: ‘created’
[18:04:14.894] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.895] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.895]   - Field: ‘label’
[18:04:14.896]   - Field: ‘local’
[18:04:14.896]   - Field: ‘owner’
[18:04:14.896]   - Field: ‘envir’
[18:04:14.896]   - Field: ‘packages’
[18:04:14.896]   - Field: ‘gc’
[18:04:14.897]   - Field: ‘conditions’
[18:04:14.897]   - Field: ‘expr’
[18:04:14.897]   - Field: ‘uuid’
[18:04:14.897]   - Field: ‘seed’
[18:04:14.897]   - Field: ‘version’
[18:04:14.898]   - Field: ‘result’
[18:04:14.898]   - Field: ‘asynchronous’
[18:04:14.898]   - Field: ‘calls’
[18:04:14.898]   - Field: ‘globals’
[18:04:14.898]   - Field: ‘stdout’
[18:04:14.899]   - Field: ‘earlySignal’
[18:04:14.899]   - Field: ‘lazy’
[18:04:14.899]   - Field: ‘state’
[18:04:14.899] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.899] - Launch lazy future ...
[18:04:14.900] Packages needed by the future expression (n = 0): <none>
[18:04:14.900] Packages needed by future strategies (n = 0): <none>
[18:04:14.901] {
[18:04:14.901]     {
[18:04:14.901]         {
[18:04:14.901]             ...future.startTime <- base::Sys.time()
[18:04:14.901]             {
[18:04:14.901]                 {
[18:04:14.901]                   {
[18:04:14.901]                     base::local({
[18:04:14.901]                       has_future <- base::requireNamespace("future", 
[18:04:14.901]                         quietly = TRUE)
[18:04:14.901]                       if (has_future) {
[18:04:14.901]                         ns <- base::getNamespace("future")
[18:04:14.901]                         version <- ns[[".package"]][["version"]]
[18:04:14.901]                         if (is.null(version)) 
[18:04:14.901]                           version <- utils::packageVersion("future")
[18:04:14.901]                       }
[18:04:14.901]                       else {
[18:04:14.901]                         version <- NULL
[18:04:14.901]                       }
[18:04:14.901]                       if (!has_future || version < "1.8.0") {
[18:04:14.901]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.901]                           "", base::R.version$version.string), 
[18:04:14.901]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.901]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.901]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.901]                             "release", "version")], collapse = " "), 
[18:04:14.901]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.901]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.901]                           info)
[18:04:14.901]                         info <- base::paste(info, collapse = "; ")
[18:04:14.901]                         if (!has_future) {
[18:04:14.901]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.901]                             info)
[18:04:14.901]                         }
[18:04:14.901]                         else {
[18:04:14.901]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.901]                             info, version)
[18:04:14.901]                         }
[18:04:14.901]                         base::stop(msg)
[18:04:14.901]                       }
[18:04:14.901]                     })
[18:04:14.901]                   }
[18:04:14.901]                   ...future.strategy.old <- future::plan("list")
[18:04:14.901]                   options(future.plan = NULL)
[18:04:14.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.901]                 }
[18:04:14.901]                 ...future.workdir <- getwd()
[18:04:14.901]             }
[18:04:14.901]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.901]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.901]         }
[18:04:14.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.901]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.901]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.901]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.901]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.901]             base::names(...future.oldOptions))
[18:04:14.901]     }
[18:04:14.901]     if (FALSE) {
[18:04:14.901]     }
[18:04:14.901]     else {
[18:04:14.901]         if (TRUE) {
[18:04:14.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.901]                 open = "w")
[18:04:14.901]         }
[18:04:14.901]         else {
[18:04:14.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.901]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.901]         }
[18:04:14.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.901]             base::sink(type = "output", split = FALSE)
[18:04:14.901]             base::close(...future.stdout)
[18:04:14.901]         }, add = TRUE)
[18:04:14.901]     }
[18:04:14.901]     ...future.frame <- base::sys.nframe()
[18:04:14.901]     ...future.conditions <- base::list()
[18:04:14.901]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.901]     if (FALSE) {
[18:04:14.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.901]     }
[18:04:14.901]     ...future.result <- base::tryCatch({
[18:04:14.901]         base::withCallingHandlers({
[18:04:14.901]             ...future.value <- base::withVisible(base::local({
[18:04:14.901]                 4
[18:04:14.901]             }))
[18:04:14.901]             future::FutureResult(value = ...future.value$value, 
[18:04:14.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.901]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.901]                     ...future.globalenv.names))
[18:04:14.901]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.901]         }, condition = base::local({
[18:04:14.901]             c <- base::c
[18:04:14.901]             inherits <- base::inherits
[18:04:14.901]             invokeRestart <- base::invokeRestart
[18:04:14.901]             length <- base::length
[18:04:14.901]             list <- base::list
[18:04:14.901]             seq.int <- base::seq.int
[18:04:14.901]             signalCondition <- base::signalCondition
[18:04:14.901]             sys.calls <- base::sys.calls
[18:04:14.901]             `[[` <- base::`[[`
[18:04:14.901]             `+` <- base::`+`
[18:04:14.901]             `<<-` <- base::`<<-`
[18:04:14.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.901]                   3L)]
[18:04:14.901]             }
[18:04:14.901]             function(cond) {
[18:04:14.901]                 is_error <- inherits(cond, "error")
[18:04:14.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.901]                   NULL)
[18:04:14.901]                 if (is_error) {
[18:04:14.901]                   sessionInformation <- function() {
[18:04:14.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.901]                       search = base::search(), system = base::Sys.info())
[18:04:14.901]                   }
[18:04:14.901]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.901]                     cond$call), session = sessionInformation(), 
[18:04:14.901]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.901]                   signalCondition(cond)
[18:04:14.901]                 }
[18:04:14.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.901]                 "immediateCondition"))) {
[18:04:14.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.901]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.901]                   if (TRUE && !signal) {
[18:04:14.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.901]                     {
[18:04:14.901]                       inherits <- base::inherits
[18:04:14.901]                       invokeRestart <- base::invokeRestart
[18:04:14.901]                       is.null <- base::is.null
[18:04:14.901]                       muffled <- FALSE
[18:04:14.901]                       if (inherits(cond, "message")) {
[18:04:14.901]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.901]                         if (muffled) 
[18:04:14.901]                           invokeRestart("muffleMessage")
[18:04:14.901]                       }
[18:04:14.901]                       else if (inherits(cond, "warning")) {
[18:04:14.901]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.901]                         if (muffled) 
[18:04:14.901]                           invokeRestart("muffleWarning")
[18:04:14.901]                       }
[18:04:14.901]                       else if (inherits(cond, "condition")) {
[18:04:14.901]                         if (!is.null(pattern)) {
[18:04:14.901]                           computeRestarts <- base::computeRestarts
[18:04:14.901]                           grepl <- base::grepl
[18:04:14.901]                           restarts <- computeRestarts(cond)
[18:04:14.901]                           for (restart in restarts) {
[18:04:14.901]                             name <- restart$name
[18:04:14.901]                             if (is.null(name)) 
[18:04:14.901]                               next
[18:04:14.901]                             if (!grepl(pattern, name)) 
[18:04:14.901]                               next
[18:04:14.901]                             invokeRestart(restart)
[18:04:14.901]                             muffled <- TRUE
[18:04:14.901]                             break
[18:04:14.901]                           }
[18:04:14.901]                         }
[18:04:14.901]                       }
[18:04:14.901]                       invisible(muffled)
[18:04:14.901]                     }
[18:04:14.901]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.901]                   }
[18:04:14.901]                 }
[18:04:14.901]                 else {
[18:04:14.901]                   if (TRUE) {
[18:04:14.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.901]                     {
[18:04:14.901]                       inherits <- base::inherits
[18:04:14.901]                       invokeRestart <- base::invokeRestart
[18:04:14.901]                       is.null <- base::is.null
[18:04:14.901]                       muffled <- FALSE
[18:04:14.901]                       if (inherits(cond, "message")) {
[18:04:14.901]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.901]                         if (muffled) 
[18:04:14.901]                           invokeRestart("muffleMessage")
[18:04:14.901]                       }
[18:04:14.901]                       else if (inherits(cond, "warning")) {
[18:04:14.901]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.901]                         if (muffled) 
[18:04:14.901]                           invokeRestart("muffleWarning")
[18:04:14.901]                       }
[18:04:14.901]                       else if (inherits(cond, "condition")) {
[18:04:14.901]                         if (!is.null(pattern)) {
[18:04:14.901]                           computeRestarts <- base::computeRestarts
[18:04:14.901]                           grepl <- base::grepl
[18:04:14.901]                           restarts <- computeRestarts(cond)
[18:04:14.901]                           for (restart in restarts) {
[18:04:14.901]                             name <- restart$name
[18:04:14.901]                             if (is.null(name)) 
[18:04:14.901]                               next
[18:04:14.901]                             if (!grepl(pattern, name)) 
[18:04:14.901]                               next
[18:04:14.901]                             invokeRestart(restart)
[18:04:14.901]                             muffled <- TRUE
[18:04:14.901]                             break
[18:04:14.901]                           }
[18:04:14.901]                         }
[18:04:14.901]                       }
[18:04:14.901]                       invisible(muffled)
[18:04:14.901]                     }
[18:04:14.901]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.901]                   }
[18:04:14.901]                 }
[18:04:14.901]             }
[18:04:14.901]         }))
[18:04:14.901]     }, error = function(ex) {
[18:04:14.901]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.901]                 ...future.rng), started = ...future.startTime, 
[18:04:14.901]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.901]             version = "1.8"), class = "FutureResult")
[18:04:14.901]     }, finally = {
[18:04:14.901]         if (!identical(...future.workdir, getwd())) 
[18:04:14.901]             setwd(...future.workdir)
[18:04:14.901]         {
[18:04:14.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.901]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.901]             }
[18:04:14.901]             base::options(...future.oldOptions)
[18:04:14.901]             if (.Platform$OS.type == "windows") {
[18:04:14.901]                 old_names <- names(...future.oldEnvVars)
[18:04:14.901]                 envs <- base::Sys.getenv()
[18:04:14.901]                 names <- names(envs)
[18:04:14.901]                 common <- intersect(names, old_names)
[18:04:14.901]                 added <- setdiff(names, old_names)
[18:04:14.901]                 removed <- setdiff(old_names, names)
[18:04:14.901]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.901]                   envs[common]]
[18:04:14.901]                 NAMES <- toupper(changed)
[18:04:14.901]                 args <- list()
[18:04:14.901]                 for (kk in seq_along(NAMES)) {
[18:04:14.901]                   name <- changed[[kk]]
[18:04:14.901]                   NAME <- NAMES[[kk]]
[18:04:14.901]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.901]                     next
[18:04:14.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.901]                 }
[18:04:14.901]                 NAMES <- toupper(added)
[18:04:14.901]                 for (kk in seq_along(NAMES)) {
[18:04:14.901]                   name <- added[[kk]]
[18:04:14.901]                   NAME <- NAMES[[kk]]
[18:04:14.901]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.901]                     next
[18:04:14.901]                   args[[name]] <- ""
[18:04:14.901]                 }
[18:04:14.901]                 NAMES <- toupper(removed)
[18:04:14.901]                 for (kk in seq_along(NAMES)) {
[18:04:14.901]                   name <- removed[[kk]]
[18:04:14.901]                   NAME <- NAMES[[kk]]
[18:04:14.901]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.901]                     next
[18:04:14.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.901]                 }
[18:04:14.901]                 if (length(args) > 0) 
[18:04:14.901]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.901]             }
[18:04:14.901]             else {
[18:04:14.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.901]             }
[18:04:14.901]             {
[18:04:14.901]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.901]                   0L) {
[18:04:14.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.901]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.901]                   base::options(opts)
[18:04:14.901]                 }
[18:04:14.901]                 {
[18:04:14.901]                   {
[18:04:14.901]                     NULL
[18:04:14.901]                     RNGkind("Mersenne-Twister")
[18:04:14.901]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.901]                       inherits = FALSE)
[18:04:14.901]                   }
[18:04:14.901]                   options(future.plan = NULL)
[18:04:14.901]                   if (is.na(NA_character_)) 
[18:04:14.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.901]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.901]                     .init = FALSE)
[18:04:14.901]                 }
[18:04:14.901]             }
[18:04:14.901]         }
[18:04:14.901]     })
[18:04:14.901]     if (TRUE) {
[18:04:14.901]         base::sink(type = "output", split = FALSE)
[18:04:14.901]         if (TRUE) {
[18:04:14.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.901]         }
[18:04:14.901]         else {
[18:04:14.901]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.901]         }
[18:04:14.901]         base::close(...future.stdout)
[18:04:14.901]         ...future.stdout <- NULL
[18:04:14.901]     }
[18:04:14.901]     ...future.result$conditions <- ...future.conditions
[18:04:14.901]     ...future.result$finished <- base::Sys.time()
[18:04:14.901]     ...future.result
[18:04:14.901] }
[18:04:14.905] plan(): Setting new future strategy stack:
[18:04:14.905] List of future strategies:
[18:04:14.905] 1. sequential:
[18:04:14.905]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.905]    - tweaked: FALSE
[18:04:14.905]    - call: NULL
[18:04:14.906] plan(): nbrOfWorkers() = 1
[18:04:14.910] plan(): Setting new future strategy stack:
[18:04:14.911] List of future strategies:
[18:04:14.911] 1. sequential:
[18:04:14.911]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.911]    - tweaked: FALSE
[18:04:14.911]    - call: plan(strategy)
[18:04:14.912] plan(): nbrOfWorkers() = 1
[18:04:14.912] SequentialFuture started (and completed)
[18:04:14.913] - Launch lazy future ... done
[18:04:14.913] run() for ‘SequentialFuture’ ... done
<environment: 0x5e3c28dcbef8> 
<environment: 0x5e3c298791c8> 
[18:04:14.916] resolved() for ‘SequentialFuture’ ...
[18:04:14.916] - state: ‘finished’
[18:04:14.916] - run: TRUE
[18:04:14.916] - result: ‘FutureResult’
[18:04:14.916] resolved() for ‘SequentialFuture’ ... done
[18:04:14.917] resolved() for ‘SequentialFuture’ ...
[18:04:14.917] - state: ‘finished’
[18:04:14.917] - run: TRUE
[18:04:14.917] - result: ‘FutureResult’
[18:04:14.917] resolved() for ‘SequentialFuture’ ... done
[18:04:14.918] resolved() for ‘SequentialFuture’ ...
[18:04:14.918] - state: ‘finished’
[18:04:14.918] - run: TRUE
[18:04:14.918] - result: ‘FutureResult’
[18:04:14.918] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:14.921] resolve() on environment ...
[18:04:14.921]  recursive: 0
[18:04:14.922]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:14.923] signalConditionsASAP(numeric, pos=1) ...
[18:04:14.923] - nx: 4
[18:04:14.923] - relay: TRUE
[18:04:14.923] - stdout: TRUE
[18:04:14.924] - signal: TRUE
[18:04:14.924] - resignal: FALSE
[18:04:14.924] - force: TRUE
[18:04:14.924] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.924] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.925]  - until=2
[18:04:14.925]  - relaying element #2
[18:04:14.925] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.925] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.925] signalConditionsASAP(NULL, pos=1) ... done
[18:04:14.925]  length: 3 (resolved future 1)
[18:04:14.926] resolved() for ‘SequentialFuture’ ...
[18:04:14.926] - state: ‘finished’
[18:04:14.926] - run: TRUE
[18:04:14.926] - result: ‘FutureResult’
[18:04:14.927] resolved() for ‘SequentialFuture’ ... done
[18:04:14.927] Future #2
[18:04:14.927] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:14.927] - nx: 4
[18:04:14.928] - relay: TRUE
[18:04:14.928] - stdout: TRUE
[18:04:14.928] - signal: TRUE
[18:04:14.928] - resignal: FALSE
[18:04:14.928] - force: TRUE
[18:04:14.928] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:14.929] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:14.929]  - until=2
[18:04:14.929]  - relaying element #2
[18:04:14.929] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.930] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.930] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:14.930]  length: 2 (resolved future 2)
[18:04:14.930] resolved() for ‘SequentialFuture’ ...
[18:04:14.930] - state: ‘finished’
[18:04:14.931] - run: TRUE
[18:04:14.931] - result: ‘FutureResult’
[18:04:14.931] resolved() for ‘SequentialFuture’ ... done
[18:04:14.931] Future #3
[18:04:14.932] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:14.932] - nx: 4
[18:04:14.932] - relay: TRUE
[18:04:14.932] - stdout: TRUE
[18:04:14.932] - signal: TRUE
[18:04:14.932] - resignal: FALSE
[18:04:14.933] - force: TRUE
[18:04:14.933] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:14.933] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:14.934]  - until=3
[18:04:14.934]  - relaying element #3
[18:04:14.934] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.934] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.935] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:14.935]  length: 1 (resolved future 3)
[18:04:14.935] resolved() for ‘SequentialFuture’ ...
[18:04:14.935] - state: ‘finished’
[18:04:14.936] - run: TRUE
[18:04:14.936] - result: ‘FutureResult’
[18:04:14.936] resolved() for ‘SequentialFuture’ ... done
[18:04:14.936] Future #4
[18:04:14.937] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:14.937] - nx: 4
[18:04:14.937] - relay: TRUE
[18:04:14.937] - stdout: TRUE
[18:04:14.937] - signal: TRUE
[18:04:14.937] - resignal: FALSE
[18:04:14.938] - force: TRUE
[18:04:14.938] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:14.938] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:14.938]  - until=4
[18:04:14.938]  - relaying element #4
[18:04:14.939] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.939] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.939] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:14.939]  length: 0 (resolved future 4)
[18:04:14.940] Relaying remaining futures
[18:04:14.940] signalConditionsASAP(NULL, pos=0) ...
[18:04:14.940] - nx: 4
[18:04:14.940] - relay: TRUE
[18:04:14.940] - stdout: TRUE
[18:04:14.940] - signal: TRUE
[18:04:14.941] - resignal: FALSE
[18:04:14.941] - force: TRUE
[18:04:14.941] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.941] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:14.942] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:14.942] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:14.942] signalConditionsASAP(NULL, pos=0) ... done
[18:04:14.942] resolve() on environment ... DONE
<environment: 0x5e3c28df8300> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[18:04:14.944] plan(): Setting new future strategy stack:
[18:04:14.944] List of future strategies:
[18:04:14.944] 1. sequential:
[18:04:14.944]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.944]    - tweaked: FALSE
[18:04:14.944]    - call: plan(strategy)
[18:04:14.945] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[18:04:14.946] getGlobalsAndPackages() ...
[18:04:14.946] Searching for globals...
[18:04:14.947] 
[18:04:14.947] Searching for globals ... DONE
[18:04:14.948] - globals: [0] <none>
[18:04:14.948] getGlobalsAndPackages() ... DONE
[18:04:14.948] run() for ‘Future’ ...
[18:04:14.948] - state: ‘created’
[18:04:14.949] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.949] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.950] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.950]   - Field: ‘label’
[18:04:14.950]   - Field: ‘local’
[18:04:14.950]   - Field: ‘owner’
[18:04:14.951]   - Field: ‘envir’
[18:04:14.951]   - Field: ‘packages’
[18:04:14.951]   - Field: ‘gc’
[18:04:14.951]   - Field: ‘conditions’
[18:04:14.951]   - Field: ‘expr’
[18:04:14.952]   - Field: ‘uuid’
[18:04:14.952]   - Field: ‘seed’
[18:04:14.952]   - Field: ‘version’
[18:04:14.952]   - Field: ‘result’
[18:04:14.952]   - Field: ‘asynchronous’
[18:04:14.953]   - Field: ‘calls’
[18:04:14.953]   - Field: ‘globals’
[18:04:14.953]   - Field: ‘stdout’
[18:04:14.953]   - Field: ‘earlySignal’
[18:04:14.953]   - Field: ‘lazy’
[18:04:14.954]   - Field: ‘state’
[18:04:14.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.954] - Launch lazy future ...
[18:04:14.954] Packages needed by the future expression (n = 0): <none>
[18:04:14.955] Packages needed by future strategies (n = 0): <none>
[18:04:14.956] {
[18:04:14.956]     {
[18:04:14.956]         {
[18:04:14.956]             ...future.startTime <- base::Sys.time()
[18:04:14.956]             {
[18:04:14.956]                 {
[18:04:14.956]                   {
[18:04:14.956]                     base::local({
[18:04:14.956]                       has_future <- base::requireNamespace("future", 
[18:04:14.956]                         quietly = TRUE)
[18:04:14.956]                       if (has_future) {
[18:04:14.956]                         ns <- base::getNamespace("future")
[18:04:14.956]                         version <- ns[[".package"]][["version"]]
[18:04:14.956]                         if (is.null(version)) 
[18:04:14.956]                           version <- utils::packageVersion("future")
[18:04:14.956]                       }
[18:04:14.956]                       else {
[18:04:14.956]                         version <- NULL
[18:04:14.956]                       }
[18:04:14.956]                       if (!has_future || version < "1.8.0") {
[18:04:14.956]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.956]                           "", base::R.version$version.string), 
[18:04:14.956]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.956]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.956]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.956]                             "release", "version")], collapse = " "), 
[18:04:14.956]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.956]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.956]                           info)
[18:04:14.956]                         info <- base::paste(info, collapse = "; ")
[18:04:14.956]                         if (!has_future) {
[18:04:14.956]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.956]                             info)
[18:04:14.956]                         }
[18:04:14.956]                         else {
[18:04:14.956]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.956]                             info, version)
[18:04:14.956]                         }
[18:04:14.956]                         base::stop(msg)
[18:04:14.956]                       }
[18:04:14.956]                     })
[18:04:14.956]                   }
[18:04:14.956]                   ...future.strategy.old <- future::plan("list")
[18:04:14.956]                   options(future.plan = NULL)
[18:04:14.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.956]                 }
[18:04:14.956]                 ...future.workdir <- getwd()
[18:04:14.956]             }
[18:04:14.956]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.956]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.956]         }
[18:04:14.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.956]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.956]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.956]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.956]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.956]             base::names(...future.oldOptions))
[18:04:14.956]     }
[18:04:14.956]     if (FALSE) {
[18:04:14.956]     }
[18:04:14.956]     else {
[18:04:14.956]         if (TRUE) {
[18:04:14.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.956]                 open = "w")
[18:04:14.956]         }
[18:04:14.956]         else {
[18:04:14.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.956]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.956]         }
[18:04:14.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.956]             base::sink(type = "output", split = FALSE)
[18:04:14.956]             base::close(...future.stdout)
[18:04:14.956]         }, add = TRUE)
[18:04:14.956]     }
[18:04:14.956]     ...future.frame <- base::sys.nframe()
[18:04:14.956]     ...future.conditions <- base::list()
[18:04:14.956]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.956]     if (FALSE) {
[18:04:14.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.956]     }
[18:04:14.956]     ...future.result <- base::tryCatch({
[18:04:14.956]         base::withCallingHandlers({
[18:04:14.956]             ...future.value <- base::withVisible(base::local(2))
[18:04:14.956]             future::FutureResult(value = ...future.value$value, 
[18:04:14.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.956]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.956]                     ...future.globalenv.names))
[18:04:14.956]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.956]         }, condition = base::local({
[18:04:14.956]             c <- base::c
[18:04:14.956]             inherits <- base::inherits
[18:04:14.956]             invokeRestart <- base::invokeRestart
[18:04:14.956]             length <- base::length
[18:04:14.956]             list <- base::list
[18:04:14.956]             seq.int <- base::seq.int
[18:04:14.956]             signalCondition <- base::signalCondition
[18:04:14.956]             sys.calls <- base::sys.calls
[18:04:14.956]             `[[` <- base::`[[`
[18:04:14.956]             `+` <- base::`+`
[18:04:14.956]             `<<-` <- base::`<<-`
[18:04:14.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.956]                   3L)]
[18:04:14.956]             }
[18:04:14.956]             function(cond) {
[18:04:14.956]                 is_error <- inherits(cond, "error")
[18:04:14.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.956]                   NULL)
[18:04:14.956]                 if (is_error) {
[18:04:14.956]                   sessionInformation <- function() {
[18:04:14.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.956]                       search = base::search(), system = base::Sys.info())
[18:04:14.956]                   }
[18:04:14.956]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.956]                     cond$call), session = sessionInformation(), 
[18:04:14.956]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.956]                   signalCondition(cond)
[18:04:14.956]                 }
[18:04:14.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.956]                 "immediateCondition"))) {
[18:04:14.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.956]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.956]                   if (TRUE && !signal) {
[18:04:14.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.956]                     {
[18:04:14.956]                       inherits <- base::inherits
[18:04:14.956]                       invokeRestart <- base::invokeRestart
[18:04:14.956]                       is.null <- base::is.null
[18:04:14.956]                       muffled <- FALSE
[18:04:14.956]                       if (inherits(cond, "message")) {
[18:04:14.956]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.956]                         if (muffled) 
[18:04:14.956]                           invokeRestart("muffleMessage")
[18:04:14.956]                       }
[18:04:14.956]                       else if (inherits(cond, "warning")) {
[18:04:14.956]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.956]                         if (muffled) 
[18:04:14.956]                           invokeRestart("muffleWarning")
[18:04:14.956]                       }
[18:04:14.956]                       else if (inherits(cond, "condition")) {
[18:04:14.956]                         if (!is.null(pattern)) {
[18:04:14.956]                           computeRestarts <- base::computeRestarts
[18:04:14.956]                           grepl <- base::grepl
[18:04:14.956]                           restarts <- computeRestarts(cond)
[18:04:14.956]                           for (restart in restarts) {
[18:04:14.956]                             name <- restart$name
[18:04:14.956]                             if (is.null(name)) 
[18:04:14.956]                               next
[18:04:14.956]                             if (!grepl(pattern, name)) 
[18:04:14.956]                               next
[18:04:14.956]                             invokeRestart(restart)
[18:04:14.956]                             muffled <- TRUE
[18:04:14.956]                             break
[18:04:14.956]                           }
[18:04:14.956]                         }
[18:04:14.956]                       }
[18:04:14.956]                       invisible(muffled)
[18:04:14.956]                     }
[18:04:14.956]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.956]                   }
[18:04:14.956]                 }
[18:04:14.956]                 else {
[18:04:14.956]                   if (TRUE) {
[18:04:14.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.956]                     {
[18:04:14.956]                       inherits <- base::inherits
[18:04:14.956]                       invokeRestart <- base::invokeRestart
[18:04:14.956]                       is.null <- base::is.null
[18:04:14.956]                       muffled <- FALSE
[18:04:14.956]                       if (inherits(cond, "message")) {
[18:04:14.956]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.956]                         if (muffled) 
[18:04:14.956]                           invokeRestart("muffleMessage")
[18:04:14.956]                       }
[18:04:14.956]                       else if (inherits(cond, "warning")) {
[18:04:14.956]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.956]                         if (muffled) 
[18:04:14.956]                           invokeRestart("muffleWarning")
[18:04:14.956]                       }
[18:04:14.956]                       else if (inherits(cond, "condition")) {
[18:04:14.956]                         if (!is.null(pattern)) {
[18:04:14.956]                           computeRestarts <- base::computeRestarts
[18:04:14.956]                           grepl <- base::grepl
[18:04:14.956]                           restarts <- computeRestarts(cond)
[18:04:14.956]                           for (restart in restarts) {
[18:04:14.956]                             name <- restart$name
[18:04:14.956]                             if (is.null(name)) 
[18:04:14.956]                               next
[18:04:14.956]                             if (!grepl(pattern, name)) 
[18:04:14.956]                               next
[18:04:14.956]                             invokeRestart(restart)
[18:04:14.956]                             muffled <- TRUE
[18:04:14.956]                             break
[18:04:14.956]                           }
[18:04:14.956]                         }
[18:04:14.956]                       }
[18:04:14.956]                       invisible(muffled)
[18:04:14.956]                     }
[18:04:14.956]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.956]                   }
[18:04:14.956]                 }
[18:04:14.956]             }
[18:04:14.956]         }))
[18:04:14.956]     }, error = function(ex) {
[18:04:14.956]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.956]                 ...future.rng), started = ...future.startTime, 
[18:04:14.956]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.956]             version = "1.8"), class = "FutureResult")
[18:04:14.956]     }, finally = {
[18:04:14.956]         if (!identical(...future.workdir, getwd())) 
[18:04:14.956]             setwd(...future.workdir)
[18:04:14.956]         {
[18:04:14.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.956]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.956]             }
[18:04:14.956]             base::options(...future.oldOptions)
[18:04:14.956]             if (.Platform$OS.type == "windows") {
[18:04:14.956]                 old_names <- names(...future.oldEnvVars)
[18:04:14.956]                 envs <- base::Sys.getenv()
[18:04:14.956]                 names <- names(envs)
[18:04:14.956]                 common <- intersect(names, old_names)
[18:04:14.956]                 added <- setdiff(names, old_names)
[18:04:14.956]                 removed <- setdiff(old_names, names)
[18:04:14.956]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.956]                   envs[common]]
[18:04:14.956]                 NAMES <- toupper(changed)
[18:04:14.956]                 args <- list()
[18:04:14.956]                 for (kk in seq_along(NAMES)) {
[18:04:14.956]                   name <- changed[[kk]]
[18:04:14.956]                   NAME <- NAMES[[kk]]
[18:04:14.956]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.956]                     next
[18:04:14.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.956]                 }
[18:04:14.956]                 NAMES <- toupper(added)
[18:04:14.956]                 for (kk in seq_along(NAMES)) {
[18:04:14.956]                   name <- added[[kk]]
[18:04:14.956]                   NAME <- NAMES[[kk]]
[18:04:14.956]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.956]                     next
[18:04:14.956]                   args[[name]] <- ""
[18:04:14.956]                 }
[18:04:14.956]                 NAMES <- toupper(removed)
[18:04:14.956]                 for (kk in seq_along(NAMES)) {
[18:04:14.956]                   name <- removed[[kk]]
[18:04:14.956]                   NAME <- NAMES[[kk]]
[18:04:14.956]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.956]                     next
[18:04:14.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.956]                 }
[18:04:14.956]                 if (length(args) > 0) 
[18:04:14.956]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.956]             }
[18:04:14.956]             else {
[18:04:14.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.956]             }
[18:04:14.956]             {
[18:04:14.956]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.956]                   0L) {
[18:04:14.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.956]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.956]                   base::options(opts)
[18:04:14.956]                 }
[18:04:14.956]                 {
[18:04:14.956]                   {
[18:04:14.956]                     NULL
[18:04:14.956]                     RNGkind("Mersenne-Twister")
[18:04:14.956]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.956]                       inherits = FALSE)
[18:04:14.956]                   }
[18:04:14.956]                   options(future.plan = NULL)
[18:04:14.956]                   if (is.na(NA_character_)) 
[18:04:14.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.956]                     .init = FALSE)
[18:04:14.956]                 }
[18:04:14.956]             }
[18:04:14.956]         }
[18:04:14.956]     })
[18:04:14.956]     if (TRUE) {
[18:04:14.956]         base::sink(type = "output", split = FALSE)
[18:04:14.956]         if (TRUE) {
[18:04:14.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.956]         }
[18:04:14.956]         else {
[18:04:14.956]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.956]         }
[18:04:14.956]         base::close(...future.stdout)
[18:04:14.956]         ...future.stdout <- NULL
[18:04:14.956]     }
[18:04:14.956]     ...future.result$conditions <- ...future.conditions
[18:04:14.956]     ...future.result$finished <- base::Sys.time()
[18:04:14.956]     ...future.result
[18:04:14.956] }
[18:04:14.959] plan(): Setting new future strategy stack:
[18:04:14.959] List of future strategies:
[18:04:14.959] 1. sequential:
[18:04:14.959]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.959]    - tweaked: FALSE
[18:04:14.959]    - call: NULL
[18:04:14.961] plan(): nbrOfWorkers() = 1
[18:04:14.962] plan(): Setting new future strategy stack:
[18:04:14.962] List of future strategies:
[18:04:14.962] 1. sequential:
[18:04:14.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.962]    - tweaked: FALSE
[18:04:14.962]    - call: plan(strategy)
[18:04:14.964] plan(): nbrOfWorkers() = 1
[18:04:14.964] SequentialFuture started (and completed)
[18:04:14.964] - Launch lazy future ... done
[18:04:14.964] run() for ‘SequentialFuture’ ... done
[18:04:14.965] getGlobalsAndPackages() ...
[18:04:14.965] Searching for globals...
[18:04:14.966] 
[18:04:14.966] Searching for globals ... DONE
[18:04:14.966] - globals: [0] <none>
[18:04:14.966] getGlobalsAndPackages() ... DONE
[18:04:14.967] run() for ‘Future’ ...
[18:04:14.967] - state: ‘created’
[18:04:14.967] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.968] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.971]   - Field: ‘label’
[18:04:14.971]   - Field: ‘local’
[18:04:14.972]   - Field: ‘owner’
[18:04:14.972]   - Field: ‘envir’
[18:04:14.972]   - Field: ‘packages’
[18:04:14.972]   - Field: ‘gc’
[18:04:14.972]   - Field: ‘conditions’
[18:04:14.973]   - Field: ‘expr’
[18:04:14.973]   - Field: ‘uuid’
[18:04:14.973]   - Field: ‘seed’
[18:04:14.973]   - Field: ‘version’
[18:04:14.973]   - Field: ‘result’
[18:04:14.974]   - Field: ‘asynchronous’
[18:04:14.974]   - Field: ‘calls’
[18:04:14.974]   - Field: ‘globals’
[18:04:14.974]   - Field: ‘stdout’
[18:04:14.974]   - Field: ‘earlySignal’
[18:04:14.975]   - Field: ‘lazy’
[18:04:14.975]   - Field: ‘state’
[18:04:14.975] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.975] - Launch lazy future ...
[18:04:14.976] Packages needed by the future expression (n = 0): <none>
[18:04:14.976] Packages needed by future strategies (n = 0): <none>
[18:04:14.977] {
[18:04:14.977]     {
[18:04:14.977]         {
[18:04:14.977]             ...future.startTime <- base::Sys.time()
[18:04:14.977]             {
[18:04:14.977]                 {
[18:04:14.977]                   {
[18:04:14.977]                     base::local({
[18:04:14.977]                       has_future <- base::requireNamespace("future", 
[18:04:14.977]                         quietly = TRUE)
[18:04:14.977]                       if (has_future) {
[18:04:14.977]                         ns <- base::getNamespace("future")
[18:04:14.977]                         version <- ns[[".package"]][["version"]]
[18:04:14.977]                         if (is.null(version)) 
[18:04:14.977]                           version <- utils::packageVersion("future")
[18:04:14.977]                       }
[18:04:14.977]                       else {
[18:04:14.977]                         version <- NULL
[18:04:14.977]                       }
[18:04:14.977]                       if (!has_future || version < "1.8.0") {
[18:04:14.977]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.977]                           "", base::R.version$version.string), 
[18:04:14.977]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.977]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.977]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.977]                             "release", "version")], collapse = " "), 
[18:04:14.977]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.977]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.977]                           info)
[18:04:14.977]                         info <- base::paste(info, collapse = "; ")
[18:04:14.977]                         if (!has_future) {
[18:04:14.977]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.977]                             info)
[18:04:14.977]                         }
[18:04:14.977]                         else {
[18:04:14.977]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.977]                             info, version)
[18:04:14.977]                         }
[18:04:14.977]                         base::stop(msg)
[18:04:14.977]                       }
[18:04:14.977]                     })
[18:04:14.977]                   }
[18:04:14.977]                   ...future.strategy.old <- future::plan("list")
[18:04:14.977]                   options(future.plan = NULL)
[18:04:14.977]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.977]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.977]                 }
[18:04:14.977]                 ...future.workdir <- getwd()
[18:04:14.977]             }
[18:04:14.977]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.977]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.977]         }
[18:04:14.977]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.977]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.977]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.977]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.977]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.977]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.977]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.977]             base::names(...future.oldOptions))
[18:04:14.977]     }
[18:04:14.977]     if (FALSE) {
[18:04:14.977]     }
[18:04:14.977]     else {
[18:04:14.977]         if (TRUE) {
[18:04:14.977]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.977]                 open = "w")
[18:04:14.977]         }
[18:04:14.977]         else {
[18:04:14.977]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.977]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.977]         }
[18:04:14.977]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.977]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.977]             base::sink(type = "output", split = FALSE)
[18:04:14.977]             base::close(...future.stdout)
[18:04:14.977]         }, add = TRUE)
[18:04:14.977]     }
[18:04:14.977]     ...future.frame <- base::sys.nframe()
[18:04:14.977]     ...future.conditions <- base::list()
[18:04:14.977]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.977]     if (FALSE) {
[18:04:14.977]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.977]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.977]     }
[18:04:14.977]     ...future.result <- base::tryCatch({
[18:04:14.977]         base::withCallingHandlers({
[18:04:14.977]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:14.977]             future::FutureResult(value = ...future.value$value, 
[18:04:14.977]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.977]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.977]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.977]                     ...future.globalenv.names))
[18:04:14.977]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.977]         }, condition = base::local({
[18:04:14.977]             c <- base::c
[18:04:14.977]             inherits <- base::inherits
[18:04:14.977]             invokeRestart <- base::invokeRestart
[18:04:14.977]             length <- base::length
[18:04:14.977]             list <- base::list
[18:04:14.977]             seq.int <- base::seq.int
[18:04:14.977]             signalCondition <- base::signalCondition
[18:04:14.977]             sys.calls <- base::sys.calls
[18:04:14.977]             `[[` <- base::`[[`
[18:04:14.977]             `+` <- base::`+`
[18:04:14.977]             `<<-` <- base::`<<-`
[18:04:14.977]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.977]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.977]                   3L)]
[18:04:14.977]             }
[18:04:14.977]             function(cond) {
[18:04:14.977]                 is_error <- inherits(cond, "error")
[18:04:14.977]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.977]                   NULL)
[18:04:14.977]                 if (is_error) {
[18:04:14.977]                   sessionInformation <- function() {
[18:04:14.977]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.977]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.977]                       search = base::search(), system = base::Sys.info())
[18:04:14.977]                   }
[18:04:14.977]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.977]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.977]                     cond$call), session = sessionInformation(), 
[18:04:14.977]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.977]                   signalCondition(cond)
[18:04:14.977]                 }
[18:04:14.977]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.977]                 "immediateCondition"))) {
[18:04:14.977]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.977]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.977]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.977]                   if (TRUE && !signal) {
[18:04:14.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.977]                     {
[18:04:14.977]                       inherits <- base::inherits
[18:04:14.977]                       invokeRestart <- base::invokeRestart
[18:04:14.977]                       is.null <- base::is.null
[18:04:14.977]                       muffled <- FALSE
[18:04:14.977]                       if (inherits(cond, "message")) {
[18:04:14.977]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.977]                         if (muffled) 
[18:04:14.977]                           invokeRestart("muffleMessage")
[18:04:14.977]                       }
[18:04:14.977]                       else if (inherits(cond, "warning")) {
[18:04:14.977]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.977]                         if (muffled) 
[18:04:14.977]                           invokeRestart("muffleWarning")
[18:04:14.977]                       }
[18:04:14.977]                       else if (inherits(cond, "condition")) {
[18:04:14.977]                         if (!is.null(pattern)) {
[18:04:14.977]                           computeRestarts <- base::computeRestarts
[18:04:14.977]                           grepl <- base::grepl
[18:04:14.977]                           restarts <- computeRestarts(cond)
[18:04:14.977]                           for (restart in restarts) {
[18:04:14.977]                             name <- restart$name
[18:04:14.977]                             if (is.null(name)) 
[18:04:14.977]                               next
[18:04:14.977]                             if (!grepl(pattern, name)) 
[18:04:14.977]                               next
[18:04:14.977]                             invokeRestart(restart)
[18:04:14.977]                             muffled <- TRUE
[18:04:14.977]                             break
[18:04:14.977]                           }
[18:04:14.977]                         }
[18:04:14.977]                       }
[18:04:14.977]                       invisible(muffled)
[18:04:14.977]                     }
[18:04:14.977]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.977]                   }
[18:04:14.977]                 }
[18:04:14.977]                 else {
[18:04:14.977]                   if (TRUE) {
[18:04:14.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.977]                     {
[18:04:14.977]                       inherits <- base::inherits
[18:04:14.977]                       invokeRestart <- base::invokeRestart
[18:04:14.977]                       is.null <- base::is.null
[18:04:14.977]                       muffled <- FALSE
[18:04:14.977]                       if (inherits(cond, "message")) {
[18:04:14.977]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.977]                         if (muffled) 
[18:04:14.977]                           invokeRestart("muffleMessage")
[18:04:14.977]                       }
[18:04:14.977]                       else if (inherits(cond, "warning")) {
[18:04:14.977]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.977]                         if (muffled) 
[18:04:14.977]                           invokeRestart("muffleWarning")
[18:04:14.977]                       }
[18:04:14.977]                       else if (inherits(cond, "condition")) {
[18:04:14.977]                         if (!is.null(pattern)) {
[18:04:14.977]                           computeRestarts <- base::computeRestarts
[18:04:14.977]                           grepl <- base::grepl
[18:04:14.977]                           restarts <- computeRestarts(cond)
[18:04:14.977]                           for (restart in restarts) {
[18:04:14.977]                             name <- restart$name
[18:04:14.977]                             if (is.null(name)) 
[18:04:14.977]                               next
[18:04:14.977]                             if (!grepl(pattern, name)) 
[18:04:14.977]                               next
[18:04:14.977]                             invokeRestart(restart)
[18:04:14.977]                             muffled <- TRUE
[18:04:14.977]                             break
[18:04:14.977]                           }
[18:04:14.977]                         }
[18:04:14.977]                       }
[18:04:14.977]                       invisible(muffled)
[18:04:14.977]                     }
[18:04:14.977]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.977]                   }
[18:04:14.977]                 }
[18:04:14.977]             }
[18:04:14.977]         }))
[18:04:14.977]     }, error = function(ex) {
[18:04:14.977]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.977]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.977]                 ...future.rng), started = ...future.startTime, 
[18:04:14.977]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.977]             version = "1.8"), class = "FutureResult")
[18:04:14.977]     }, finally = {
[18:04:14.977]         if (!identical(...future.workdir, getwd())) 
[18:04:14.977]             setwd(...future.workdir)
[18:04:14.977]         {
[18:04:14.977]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.977]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.977]             }
[18:04:14.977]             base::options(...future.oldOptions)
[18:04:14.977]             if (.Platform$OS.type == "windows") {
[18:04:14.977]                 old_names <- names(...future.oldEnvVars)
[18:04:14.977]                 envs <- base::Sys.getenv()
[18:04:14.977]                 names <- names(envs)
[18:04:14.977]                 common <- intersect(names, old_names)
[18:04:14.977]                 added <- setdiff(names, old_names)
[18:04:14.977]                 removed <- setdiff(old_names, names)
[18:04:14.977]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.977]                   envs[common]]
[18:04:14.977]                 NAMES <- toupper(changed)
[18:04:14.977]                 args <- list()
[18:04:14.977]                 for (kk in seq_along(NAMES)) {
[18:04:14.977]                   name <- changed[[kk]]
[18:04:14.977]                   NAME <- NAMES[[kk]]
[18:04:14.977]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.977]                     next
[18:04:14.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.977]                 }
[18:04:14.977]                 NAMES <- toupper(added)
[18:04:14.977]                 for (kk in seq_along(NAMES)) {
[18:04:14.977]                   name <- added[[kk]]
[18:04:14.977]                   NAME <- NAMES[[kk]]
[18:04:14.977]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.977]                     next
[18:04:14.977]                   args[[name]] <- ""
[18:04:14.977]                 }
[18:04:14.977]                 NAMES <- toupper(removed)
[18:04:14.977]                 for (kk in seq_along(NAMES)) {
[18:04:14.977]                   name <- removed[[kk]]
[18:04:14.977]                   NAME <- NAMES[[kk]]
[18:04:14.977]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.977]                     next
[18:04:14.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.977]                 }
[18:04:14.977]                 if (length(args) > 0) 
[18:04:14.977]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.977]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.977]             }
[18:04:14.977]             else {
[18:04:14.977]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.977]             }
[18:04:14.977]             {
[18:04:14.977]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.977]                   0L) {
[18:04:14.977]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.977]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.977]                   base::options(opts)
[18:04:14.977]                 }
[18:04:14.977]                 {
[18:04:14.977]                   {
[18:04:14.977]                     NULL
[18:04:14.977]                     RNGkind("Mersenne-Twister")
[18:04:14.977]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.977]                       inherits = FALSE)
[18:04:14.977]                   }
[18:04:14.977]                   options(future.plan = NULL)
[18:04:14.977]                   if (is.na(NA_character_)) 
[18:04:14.977]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.977]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.977]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.977]                     .init = FALSE)
[18:04:14.977]                 }
[18:04:14.977]             }
[18:04:14.977]         }
[18:04:14.977]     })
[18:04:14.977]     if (TRUE) {
[18:04:14.977]         base::sink(type = "output", split = FALSE)
[18:04:14.977]         if (TRUE) {
[18:04:14.977]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.977]         }
[18:04:14.977]         else {
[18:04:14.977]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.977]         }
[18:04:14.977]         base::close(...future.stdout)
[18:04:14.977]         ...future.stdout <- NULL
[18:04:14.977]     }
[18:04:14.977]     ...future.result$conditions <- ...future.conditions
[18:04:14.977]     ...future.result$finished <- base::Sys.time()
[18:04:14.977]     ...future.result
[18:04:14.977] }
[18:04:14.981] plan(): Setting new future strategy stack:
[18:04:14.981] List of future strategies:
[18:04:14.981] 1. sequential:
[18:04:14.981]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.981]    - tweaked: FALSE
[18:04:14.981]    - call: NULL
[18:04:14.982] plan(): nbrOfWorkers() = 1
[18:04:14.983] plan(): Setting new future strategy stack:
[18:04:14.984] List of future strategies:
[18:04:14.984] 1. sequential:
[18:04:14.984]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:14.984]    - tweaked: FALSE
[18:04:14.984]    - call: plan(strategy)
[18:04:14.985] plan(): nbrOfWorkers() = 1
[18:04:14.985] SequentialFuture started (and completed)
[18:04:14.986] - Launch lazy future ... done
[18:04:14.986] run() for ‘SequentialFuture’ ... done
[18:04:14.987] getGlobalsAndPackages() ...
[18:04:14.987] Searching for globals...
[18:04:14.988] - globals found: [1] ‘{’
[18:04:14.989] Searching for globals ... DONE
[18:04:14.989] Resolving globals: FALSE
[18:04:14.990] 
[18:04:14.990] 
[18:04:14.990] getGlobalsAndPackages() ... DONE
[18:04:14.990] run() for ‘Future’ ...
[18:04:14.991] - state: ‘created’
[18:04:14.991] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:14.992] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:14.992] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:14.992]   - Field: ‘label’
[18:04:14.992]   - Field: ‘local’
[18:04:14.992]   - Field: ‘owner’
[18:04:14.993]   - Field: ‘envir’
[18:04:14.993]   - Field: ‘packages’
[18:04:14.993]   - Field: ‘gc’
[18:04:14.993]   - Field: ‘conditions’
[18:04:14.994]   - Field: ‘expr’
[18:04:14.994]   - Field: ‘uuid’
[18:04:14.994]   - Field: ‘seed’
[18:04:14.994]   - Field: ‘version’
[18:04:14.994]   - Field: ‘result’
[18:04:14.995]   - Field: ‘asynchronous’
[18:04:14.995]   - Field: ‘calls’
[18:04:14.995]   - Field: ‘globals’
[18:04:14.995]   - Field: ‘stdout’
[18:04:14.995]   - Field: ‘earlySignal’
[18:04:14.996]   - Field: ‘lazy’
[18:04:14.996]   - Field: ‘state’
[18:04:14.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:14.996] - Launch lazy future ...
[18:04:14.997] Packages needed by the future expression (n = 0): <none>
[18:04:14.997] Packages needed by future strategies (n = 0): <none>
[18:04:14.998] {
[18:04:14.998]     {
[18:04:14.998]         {
[18:04:14.998]             ...future.startTime <- base::Sys.time()
[18:04:14.998]             {
[18:04:14.998]                 {
[18:04:14.998]                   {
[18:04:14.998]                     base::local({
[18:04:14.998]                       has_future <- base::requireNamespace("future", 
[18:04:14.998]                         quietly = TRUE)
[18:04:14.998]                       if (has_future) {
[18:04:14.998]                         ns <- base::getNamespace("future")
[18:04:14.998]                         version <- ns[[".package"]][["version"]]
[18:04:14.998]                         if (is.null(version)) 
[18:04:14.998]                           version <- utils::packageVersion("future")
[18:04:14.998]                       }
[18:04:14.998]                       else {
[18:04:14.998]                         version <- NULL
[18:04:14.998]                       }
[18:04:14.998]                       if (!has_future || version < "1.8.0") {
[18:04:14.998]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:14.998]                           "", base::R.version$version.string), 
[18:04:14.998]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:14.998]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:14.998]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:14.998]                             "release", "version")], collapse = " "), 
[18:04:14.998]                           hostname = base::Sys.info()[["nodename"]])
[18:04:14.998]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:14.998]                           info)
[18:04:14.998]                         info <- base::paste(info, collapse = "; ")
[18:04:14.998]                         if (!has_future) {
[18:04:14.998]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:14.998]                             info)
[18:04:14.998]                         }
[18:04:14.998]                         else {
[18:04:14.998]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:14.998]                             info, version)
[18:04:14.998]                         }
[18:04:14.998]                         base::stop(msg)
[18:04:14.998]                       }
[18:04:14.998]                     })
[18:04:14.998]                   }
[18:04:14.998]                   ...future.strategy.old <- future::plan("list")
[18:04:14.998]                   options(future.plan = NULL)
[18:04:14.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:14.998]                 }
[18:04:14.998]                 ...future.workdir <- getwd()
[18:04:14.998]             }
[18:04:14.998]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:14.998]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:14.998]         }
[18:04:14.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:14.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:14.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:14.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:14.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:14.998]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:14.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:14.998]             base::names(...future.oldOptions))
[18:04:14.998]     }
[18:04:14.998]     if (FALSE) {
[18:04:14.998]     }
[18:04:14.998]     else {
[18:04:14.998]         if (TRUE) {
[18:04:14.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:14.998]                 open = "w")
[18:04:14.998]         }
[18:04:14.998]         else {
[18:04:14.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:14.998]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:14.998]         }
[18:04:14.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:14.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:14.998]             base::sink(type = "output", split = FALSE)
[18:04:14.998]             base::close(...future.stdout)
[18:04:14.998]         }, add = TRUE)
[18:04:14.998]     }
[18:04:14.998]     ...future.frame <- base::sys.nframe()
[18:04:14.998]     ...future.conditions <- base::list()
[18:04:14.998]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:14.998]     if (FALSE) {
[18:04:14.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:14.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:14.998]     }
[18:04:14.998]     ...future.result <- base::tryCatch({
[18:04:14.998]         base::withCallingHandlers({
[18:04:14.998]             ...future.value <- base::withVisible(base::local({
[18:04:14.998]                 4
[18:04:14.998]             }))
[18:04:14.998]             future::FutureResult(value = ...future.value$value, 
[18:04:14.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.998]                   ...future.rng), globalenv = if (FALSE) 
[18:04:14.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:14.998]                     ...future.globalenv.names))
[18:04:14.998]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:14.998]         }, condition = base::local({
[18:04:14.998]             c <- base::c
[18:04:14.998]             inherits <- base::inherits
[18:04:14.998]             invokeRestart <- base::invokeRestart
[18:04:14.998]             length <- base::length
[18:04:14.998]             list <- base::list
[18:04:14.998]             seq.int <- base::seq.int
[18:04:14.998]             signalCondition <- base::signalCondition
[18:04:14.998]             sys.calls <- base::sys.calls
[18:04:14.998]             `[[` <- base::`[[`
[18:04:14.998]             `+` <- base::`+`
[18:04:14.998]             `<<-` <- base::`<<-`
[18:04:14.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:14.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:14.998]                   3L)]
[18:04:14.998]             }
[18:04:14.998]             function(cond) {
[18:04:14.998]                 is_error <- inherits(cond, "error")
[18:04:14.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:14.998]                   NULL)
[18:04:14.998]                 if (is_error) {
[18:04:14.998]                   sessionInformation <- function() {
[18:04:14.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:14.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:14.998]                       search = base::search(), system = base::Sys.info())
[18:04:14.998]                   }
[18:04:14.998]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:14.998]                     cond$call), session = sessionInformation(), 
[18:04:14.998]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:14.998]                   signalCondition(cond)
[18:04:14.998]                 }
[18:04:14.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:14.998]                 "immediateCondition"))) {
[18:04:14.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:14.998]                   ...future.conditions[[length(...future.conditions) + 
[18:04:14.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:14.998]                   if (TRUE && !signal) {
[18:04:14.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.998]                     {
[18:04:14.998]                       inherits <- base::inherits
[18:04:14.998]                       invokeRestart <- base::invokeRestart
[18:04:14.998]                       is.null <- base::is.null
[18:04:14.998]                       muffled <- FALSE
[18:04:14.998]                       if (inherits(cond, "message")) {
[18:04:14.998]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.998]                         if (muffled) 
[18:04:14.998]                           invokeRestart("muffleMessage")
[18:04:14.998]                       }
[18:04:14.998]                       else if (inherits(cond, "warning")) {
[18:04:14.998]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.998]                         if (muffled) 
[18:04:14.998]                           invokeRestart("muffleWarning")
[18:04:14.998]                       }
[18:04:14.998]                       else if (inherits(cond, "condition")) {
[18:04:14.998]                         if (!is.null(pattern)) {
[18:04:14.998]                           computeRestarts <- base::computeRestarts
[18:04:14.998]                           grepl <- base::grepl
[18:04:14.998]                           restarts <- computeRestarts(cond)
[18:04:14.998]                           for (restart in restarts) {
[18:04:14.998]                             name <- restart$name
[18:04:14.998]                             if (is.null(name)) 
[18:04:14.998]                               next
[18:04:14.998]                             if (!grepl(pattern, name)) 
[18:04:14.998]                               next
[18:04:14.998]                             invokeRestart(restart)
[18:04:14.998]                             muffled <- TRUE
[18:04:14.998]                             break
[18:04:14.998]                           }
[18:04:14.998]                         }
[18:04:14.998]                       }
[18:04:14.998]                       invisible(muffled)
[18:04:14.998]                     }
[18:04:14.998]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.998]                   }
[18:04:14.998]                 }
[18:04:14.998]                 else {
[18:04:14.998]                   if (TRUE) {
[18:04:14.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:14.998]                     {
[18:04:14.998]                       inherits <- base::inherits
[18:04:14.998]                       invokeRestart <- base::invokeRestart
[18:04:14.998]                       is.null <- base::is.null
[18:04:14.998]                       muffled <- FALSE
[18:04:14.998]                       if (inherits(cond, "message")) {
[18:04:14.998]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:14.998]                         if (muffled) 
[18:04:14.998]                           invokeRestart("muffleMessage")
[18:04:14.998]                       }
[18:04:14.998]                       else if (inherits(cond, "warning")) {
[18:04:14.998]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:14.998]                         if (muffled) 
[18:04:14.998]                           invokeRestart("muffleWarning")
[18:04:14.998]                       }
[18:04:14.998]                       else if (inherits(cond, "condition")) {
[18:04:14.998]                         if (!is.null(pattern)) {
[18:04:14.998]                           computeRestarts <- base::computeRestarts
[18:04:14.998]                           grepl <- base::grepl
[18:04:14.998]                           restarts <- computeRestarts(cond)
[18:04:14.998]                           for (restart in restarts) {
[18:04:14.998]                             name <- restart$name
[18:04:14.998]                             if (is.null(name)) 
[18:04:14.998]                               next
[18:04:14.998]                             if (!grepl(pattern, name)) 
[18:04:14.998]                               next
[18:04:14.998]                             invokeRestart(restart)
[18:04:14.998]                             muffled <- TRUE
[18:04:14.998]                             break
[18:04:14.998]                           }
[18:04:14.998]                         }
[18:04:14.998]                       }
[18:04:14.998]                       invisible(muffled)
[18:04:14.998]                     }
[18:04:14.998]                     muffleCondition(cond, pattern = "^muffle")
[18:04:14.998]                   }
[18:04:14.998]                 }
[18:04:14.998]             }
[18:04:14.998]         }))
[18:04:14.998]     }, error = function(ex) {
[18:04:14.998]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:14.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:14.998]                 ...future.rng), started = ...future.startTime, 
[18:04:14.998]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:14.998]             version = "1.8"), class = "FutureResult")
[18:04:14.998]     }, finally = {
[18:04:14.998]         if (!identical(...future.workdir, getwd())) 
[18:04:14.998]             setwd(...future.workdir)
[18:04:14.998]         {
[18:04:14.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:14.998]                 ...future.oldOptions$nwarnings <- NULL
[18:04:14.998]             }
[18:04:14.998]             base::options(...future.oldOptions)
[18:04:14.998]             if (.Platform$OS.type == "windows") {
[18:04:14.998]                 old_names <- names(...future.oldEnvVars)
[18:04:14.998]                 envs <- base::Sys.getenv()
[18:04:14.998]                 names <- names(envs)
[18:04:14.998]                 common <- intersect(names, old_names)
[18:04:14.998]                 added <- setdiff(names, old_names)
[18:04:14.998]                 removed <- setdiff(old_names, names)
[18:04:14.998]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:14.998]                   envs[common]]
[18:04:14.998]                 NAMES <- toupper(changed)
[18:04:14.998]                 args <- list()
[18:04:14.998]                 for (kk in seq_along(NAMES)) {
[18:04:14.998]                   name <- changed[[kk]]
[18:04:14.998]                   NAME <- NAMES[[kk]]
[18:04:14.998]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.998]                     next
[18:04:14.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.998]                 }
[18:04:14.998]                 NAMES <- toupper(added)
[18:04:14.998]                 for (kk in seq_along(NAMES)) {
[18:04:14.998]                   name <- added[[kk]]
[18:04:14.998]                   NAME <- NAMES[[kk]]
[18:04:14.998]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.998]                     next
[18:04:14.998]                   args[[name]] <- ""
[18:04:14.998]                 }
[18:04:14.998]                 NAMES <- toupper(removed)
[18:04:14.998]                 for (kk in seq_along(NAMES)) {
[18:04:14.998]                   name <- removed[[kk]]
[18:04:14.998]                   NAME <- NAMES[[kk]]
[18:04:14.998]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:14.998]                     next
[18:04:14.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:14.998]                 }
[18:04:14.998]                 if (length(args) > 0) 
[18:04:14.998]                   base::do.call(base::Sys.setenv, args = args)
[18:04:14.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:14.998]             }
[18:04:14.998]             else {
[18:04:14.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:14.998]             }
[18:04:14.998]             {
[18:04:14.998]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:14.998]                   0L) {
[18:04:14.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:14.998]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:14.998]                   base::options(opts)
[18:04:14.998]                 }
[18:04:14.998]                 {
[18:04:14.998]                   {
[18:04:14.998]                     NULL
[18:04:14.998]                     RNGkind("Mersenne-Twister")
[18:04:14.998]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:14.998]                       inherits = FALSE)
[18:04:14.998]                   }
[18:04:14.998]                   options(future.plan = NULL)
[18:04:14.998]                   if (is.na(NA_character_)) 
[18:04:14.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:14.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:14.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:14.998]                     .init = FALSE)
[18:04:14.998]                 }
[18:04:14.998]             }
[18:04:14.998]         }
[18:04:14.998]     })
[18:04:14.998]     if (TRUE) {
[18:04:14.998]         base::sink(type = "output", split = FALSE)
[18:04:14.998]         if (TRUE) {
[18:04:14.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:14.998]         }
[18:04:14.998]         else {
[18:04:14.998]             ...future.result["stdout"] <- base::list(NULL)
[18:04:14.998]         }
[18:04:14.998]         base::close(...future.stdout)
[18:04:14.998]         ...future.stdout <- NULL
[18:04:14.998]     }
[18:04:14.998]     ...future.result$conditions <- ...future.conditions
[18:04:14.998]     ...future.result$finished <- base::Sys.time()
[18:04:14.998]     ...future.result
[18:04:14.998] }
[18:04:15.002] plan(): Setting new future strategy stack:
[18:04:15.002] List of future strategies:
[18:04:15.002] 1. sequential:
[18:04:15.002]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.002]    - tweaked: FALSE
[18:04:15.002]    - call: NULL
[18:04:15.003] plan(): nbrOfWorkers() = 1
[18:04:15.004] plan(): Setting new future strategy stack:
[18:04:15.005] List of future strategies:
[18:04:15.005] 1. sequential:
[18:04:15.005]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.005]    - tweaked: FALSE
[18:04:15.005]    - call: plan(strategy)
[18:04:15.006] plan(): nbrOfWorkers() = 1
[18:04:15.006] SequentialFuture started (and completed)
[18:04:15.006] - Launch lazy future ... done
[18:04:15.007] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2b20dfe8> 
Classes 'listenv', 'environment' <environment: 0x5e3c2b057c90> 
[18:04:15.013] resolved() for ‘SequentialFuture’ ...
[18:04:15.014] - state: ‘finished’
[18:04:15.014] - run: TRUE
[18:04:15.014] - result: ‘FutureResult’
[18:04:15.014] resolved() for ‘SequentialFuture’ ... done
[18:04:15.014] resolved() for ‘SequentialFuture’ ...
[18:04:15.015] - state: ‘finished’
[18:04:15.015] - run: TRUE
[18:04:15.015] - result: ‘FutureResult’
[18:04:15.015] resolved() for ‘SequentialFuture’ ... done
[18:04:15.015] resolved() for ‘SequentialFuture’ ...
[18:04:15.016] - state: ‘finished’
[18:04:15.016] - run: TRUE
[18:04:15.016] - result: ‘FutureResult’
[18:04:15.016] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:15.020] resolve() on list environment ...
[18:04:15.021]  recursive: 0
[18:04:15.023]  length: 6
[18:04:15.023]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:15.023] signalConditionsASAP(numeric, pos=1) ...
[18:04:15.023] - nx: 6
[18:04:15.024] - relay: TRUE
[18:04:15.024] - stdout: TRUE
[18:04:15.024] - signal: TRUE
[18:04:15.024] - resignal: FALSE
[18:04:15.024] - force: TRUE
[18:04:15.025] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.025] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.025]  - until=2
[18:04:15.025]  - relaying element #2
[18:04:15.025] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.026] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.026] signalConditionsASAP(NULL, pos=1) ... done
[18:04:15.026]  length: 5 (resolved future 1)
[18:04:15.026] resolved() for ‘SequentialFuture’ ...
[18:04:15.027] - state: ‘finished’
[18:04:15.027] - run: TRUE
[18:04:15.027] - result: ‘FutureResult’
[18:04:15.027] resolved() for ‘SequentialFuture’ ... done
[18:04:15.027] Future #2
[18:04:15.028] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:15.028] - nx: 6
[18:04:15.028] - relay: TRUE
[18:04:15.028] - stdout: TRUE
[18:04:15.029] - signal: TRUE
[18:04:15.029] - resignal: FALSE
[18:04:15.029] - force: TRUE
[18:04:15.029] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.029] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.030]  - until=2
[18:04:15.030]  - relaying element #2
[18:04:15.030] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.030] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.031] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:15.031]  length: 4 (resolved future 2)
[18:04:15.031] resolved() for ‘SequentialFuture’ ...
[18:04:15.031] - state: ‘finished’
[18:04:15.035] - run: TRUE
[18:04:15.035] - result: ‘FutureResult’
[18:04:15.035] resolved() for ‘SequentialFuture’ ... done
[18:04:15.035] Future #3
[18:04:15.036] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:15.036] - nx: 6
[18:04:15.036] - relay: TRUE
[18:04:15.036] - stdout: TRUE
[18:04:15.036] - signal: TRUE
[18:04:15.037] - resignal: FALSE
[18:04:15.037] - force: TRUE
[18:04:15.037] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.037] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.037]  - until=3
[18:04:15.038]  - relaying element #3
[18:04:15.038] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.038] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.038] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:15.039]  length: 3 (resolved future 3)
[18:04:15.039] resolved() for ‘SequentialFuture’ ...
[18:04:15.039] - state: ‘finished’
[18:04:15.039] - run: TRUE
[18:04:15.039] - result: ‘FutureResult’
[18:04:15.040] resolved() for ‘SequentialFuture’ ... done
[18:04:15.040] Future #4
[18:04:15.040] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:15.040] - nx: 6
[18:04:15.041] - relay: TRUE
[18:04:15.041] - stdout: TRUE
[18:04:15.041] - signal: TRUE
[18:04:15.041] - resignal: FALSE
[18:04:15.041] - force: TRUE
[18:04:15.041] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.042] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.042]  - until=4
[18:04:15.042]  - relaying element #4
[18:04:15.043] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.043] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.043] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:15.043]  length: 2 (resolved future 4)
[18:04:15.043] signalConditionsASAP(NULL, pos=5) ...
[18:04:15.044] - nx: 6
[18:04:15.044] - relay: TRUE
[18:04:15.044] - stdout: TRUE
[18:04:15.044] - signal: TRUE
[18:04:15.044] - resignal: FALSE
[18:04:15.044] - force: TRUE
[18:04:15.045] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.045] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.045]  - until=6
[18:04:15.045]  - relaying element #6
[18:04:15.045] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.046] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.046] signalConditionsASAP(NULL, pos=5) ... done
[18:04:15.046]  length: 1 (resolved future 5)
[18:04:15.046] signalConditionsASAP(numeric, pos=6) ...
[18:04:15.046] - nx: 6
[18:04:15.047] - relay: TRUE
[18:04:15.047] - stdout: TRUE
[18:04:15.047] - signal: TRUE
[18:04:15.047] - resignal: FALSE
[18:04:15.047] - force: TRUE
[18:04:15.048] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.048] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.048]  - until=6
[18:04:15.048] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.048] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.048] signalConditionsASAP(numeric, pos=6) ... done
[18:04:15.049]  length: 0 (resolved future 6)
[18:04:15.049] Relaying remaining futures
[18:04:15.049] signalConditionsASAP(NULL, pos=0) ...
[18:04:15.049] - nx: 6
[18:04:15.049] - relay: TRUE
[18:04:15.050] - stdout: TRUE
[18:04:15.050] - signal: TRUE
[18:04:15.050] - resignal: FALSE
[18:04:15.050] - force: TRUE
[18:04:15.050] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.051] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:15.051] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.051] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.051] signalConditionsASAP(NULL, pos=0) ... done
[18:04:15.051] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5e3c2b336a98> 
Dimensions: c(1, 6)
[18:04:15.053] getGlobalsAndPackages() ...
[18:04:15.053] Searching for globals...
[18:04:15.054] 
[18:04:15.054] Searching for globals ... DONE
[18:04:15.055] - globals: [0] <none>
[18:04:15.055] getGlobalsAndPackages() ... DONE
[18:04:15.055] run() for ‘Future’ ...
[18:04:15.056] - state: ‘created’
[18:04:15.056] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.056] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.057] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.057]   - Field: ‘label’
[18:04:15.057]   - Field: ‘local’
[18:04:15.057]   - Field: ‘owner’
[18:04:15.057]   - Field: ‘envir’
[18:04:15.058]   - Field: ‘packages’
[18:04:15.058]   - Field: ‘gc’
[18:04:15.058]   - Field: ‘conditions’
[18:04:15.058]   - Field: ‘expr’
[18:04:15.059]   - Field: ‘uuid’
[18:04:15.059]   - Field: ‘seed’
[18:04:15.059]   - Field: ‘version’
[18:04:15.059]   - Field: ‘result’
[18:04:15.059]   - Field: ‘asynchronous’
[18:04:15.060]   - Field: ‘calls’
[18:04:15.060]   - Field: ‘globals’
[18:04:15.060]   - Field: ‘stdout’
[18:04:15.060]   - Field: ‘earlySignal’
[18:04:15.060]   - Field: ‘lazy’
[18:04:15.061]   - Field: ‘state’
[18:04:15.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.061] - Launch lazy future ...
[18:04:15.061] Packages needed by the future expression (n = 0): <none>
[18:04:15.062] Packages needed by future strategies (n = 0): <none>
[18:04:15.062] {
[18:04:15.062]     {
[18:04:15.062]         {
[18:04:15.062]             ...future.startTime <- base::Sys.time()
[18:04:15.062]             {
[18:04:15.062]                 {
[18:04:15.062]                   {
[18:04:15.062]                     base::local({
[18:04:15.062]                       has_future <- base::requireNamespace("future", 
[18:04:15.062]                         quietly = TRUE)
[18:04:15.062]                       if (has_future) {
[18:04:15.062]                         ns <- base::getNamespace("future")
[18:04:15.062]                         version <- ns[[".package"]][["version"]]
[18:04:15.062]                         if (is.null(version)) 
[18:04:15.062]                           version <- utils::packageVersion("future")
[18:04:15.062]                       }
[18:04:15.062]                       else {
[18:04:15.062]                         version <- NULL
[18:04:15.062]                       }
[18:04:15.062]                       if (!has_future || version < "1.8.0") {
[18:04:15.062]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.062]                           "", base::R.version$version.string), 
[18:04:15.062]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.062]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.062]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.062]                             "release", "version")], collapse = " "), 
[18:04:15.062]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.062]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.062]                           info)
[18:04:15.062]                         info <- base::paste(info, collapse = "; ")
[18:04:15.062]                         if (!has_future) {
[18:04:15.062]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.062]                             info)
[18:04:15.062]                         }
[18:04:15.062]                         else {
[18:04:15.062]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.062]                             info, version)
[18:04:15.062]                         }
[18:04:15.062]                         base::stop(msg)
[18:04:15.062]                       }
[18:04:15.062]                     })
[18:04:15.062]                   }
[18:04:15.062]                   ...future.strategy.old <- future::plan("list")
[18:04:15.062]                   options(future.plan = NULL)
[18:04:15.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.062]                 }
[18:04:15.062]                 ...future.workdir <- getwd()
[18:04:15.062]             }
[18:04:15.062]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.062]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.062]         }
[18:04:15.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.062]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.062]             base::names(...future.oldOptions))
[18:04:15.062]     }
[18:04:15.062]     if (FALSE) {
[18:04:15.062]     }
[18:04:15.062]     else {
[18:04:15.062]         if (TRUE) {
[18:04:15.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.062]                 open = "w")
[18:04:15.062]         }
[18:04:15.062]         else {
[18:04:15.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.062]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.062]         }
[18:04:15.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.062]             base::sink(type = "output", split = FALSE)
[18:04:15.062]             base::close(...future.stdout)
[18:04:15.062]         }, add = TRUE)
[18:04:15.062]     }
[18:04:15.062]     ...future.frame <- base::sys.nframe()
[18:04:15.062]     ...future.conditions <- base::list()
[18:04:15.062]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.062]     if (FALSE) {
[18:04:15.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.062]     }
[18:04:15.062]     ...future.result <- base::tryCatch({
[18:04:15.062]         base::withCallingHandlers({
[18:04:15.062]             ...future.value <- base::withVisible(base::local(2))
[18:04:15.062]             future::FutureResult(value = ...future.value$value, 
[18:04:15.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.062]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.062]                     ...future.globalenv.names))
[18:04:15.062]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.062]         }, condition = base::local({
[18:04:15.062]             c <- base::c
[18:04:15.062]             inherits <- base::inherits
[18:04:15.062]             invokeRestart <- base::invokeRestart
[18:04:15.062]             length <- base::length
[18:04:15.062]             list <- base::list
[18:04:15.062]             seq.int <- base::seq.int
[18:04:15.062]             signalCondition <- base::signalCondition
[18:04:15.062]             sys.calls <- base::sys.calls
[18:04:15.062]             `[[` <- base::`[[`
[18:04:15.062]             `+` <- base::`+`
[18:04:15.062]             `<<-` <- base::`<<-`
[18:04:15.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.062]                   3L)]
[18:04:15.062]             }
[18:04:15.062]             function(cond) {
[18:04:15.062]                 is_error <- inherits(cond, "error")
[18:04:15.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.062]                   NULL)
[18:04:15.062]                 if (is_error) {
[18:04:15.062]                   sessionInformation <- function() {
[18:04:15.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.062]                       search = base::search(), system = base::Sys.info())
[18:04:15.062]                   }
[18:04:15.062]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.062]                     cond$call), session = sessionInformation(), 
[18:04:15.062]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.062]                   signalCondition(cond)
[18:04:15.062]                 }
[18:04:15.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.062]                 "immediateCondition"))) {
[18:04:15.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.062]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.062]                   if (TRUE && !signal) {
[18:04:15.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.062]                     {
[18:04:15.062]                       inherits <- base::inherits
[18:04:15.062]                       invokeRestart <- base::invokeRestart
[18:04:15.062]                       is.null <- base::is.null
[18:04:15.062]                       muffled <- FALSE
[18:04:15.062]                       if (inherits(cond, "message")) {
[18:04:15.062]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.062]                         if (muffled) 
[18:04:15.062]                           invokeRestart("muffleMessage")
[18:04:15.062]                       }
[18:04:15.062]                       else if (inherits(cond, "warning")) {
[18:04:15.062]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.062]                         if (muffled) 
[18:04:15.062]                           invokeRestart("muffleWarning")
[18:04:15.062]                       }
[18:04:15.062]                       else if (inherits(cond, "condition")) {
[18:04:15.062]                         if (!is.null(pattern)) {
[18:04:15.062]                           computeRestarts <- base::computeRestarts
[18:04:15.062]                           grepl <- base::grepl
[18:04:15.062]                           restarts <- computeRestarts(cond)
[18:04:15.062]                           for (restart in restarts) {
[18:04:15.062]                             name <- restart$name
[18:04:15.062]                             if (is.null(name)) 
[18:04:15.062]                               next
[18:04:15.062]                             if (!grepl(pattern, name)) 
[18:04:15.062]                               next
[18:04:15.062]                             invokeRestart(restart)
[18:04:15.062]                             muffled <- TRUE
[18:04:15.062]                             break
[18:04:15.062]                           }
[18:04:15.062]                         }
[18:04:15.062]                       }
[18:04:15.062]                       invisible(muffled)
[18:04:15.062]                     }
[18:04:15.062]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.062]                   }
[18:04:15.062]                 }
[18:04:15.062]                 else {
[18:04:15.062]                   if (TRUE) {
[18:04:15.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.062]                     {
[18:04:15.062]                       inherits <- base::inherits
[18:04:15.062]                       invokeRestart <- base::invokeRestart
[18:04:15.062]                       is.null <- base::is.null
[18:04:15.062]                       muffled <- FALSE
[18:04:15.062]                       if (inherits(cond, "message")) {
[18:04:15.062]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.062]                         if (muffled) 
[18:04:15.062]                           invokeRestart("muffleMessage")
[18:04:15.062]                       }
[18:04:15.062]                       else if (inherits(cond, "warning")) {
[18:04:15.062]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.062]                         if (muffled) 
[18:04:15.062]                           invokeRestart("muffleWarning")
[18:04:15.062]                       }
[18:04:15.062]                       else if (inherits(cond, "condition")) {
[18:04:15.062]                         if (!is.null(pattern)) {
[18:04:15.062]                           computeRestarts <- base::computeRestarts
[18:04:15.062]                           grepl <- base::grepl
[18:04:15.062]                           restarts <- computeRestarts(cond)
[18:04:15.062]                           for (restart in restarts) {
[18:04:15.062]                             name <- restart$name
[18:04:15.062]                             if (is.null(name)) 
[18:04:15.062]                               next
[18:04:15.062]                             if (!grepl(pattern, name)) 
[18:04:15.062]                               next
[18:04:15.062]                             invokeRestart(restart)
[18:04:15.062]                             muffled <- TRUE
[18:04:15.062]                             break
[18:04:15.062]                           }
[18:04:15.062]                         }
[18:04:15.062]                       }
[18:04:15.062]                       invisible(muffled)
[18:04:15.062]                     }
[18:04:15.062]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.062]                   }
[18:04:15.062]                 }
[18:04:15.062]             }
[18:04:15.062]         }))
[18:04:15.062]     }, error = function(ex) {
[18:04:15.062]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.062]                 ...future.rng), started = ...future.startTime, 
[18:04:15.062]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.062]             version = "1.8"), class = "FutureResult")
[18:04:15.062]     }, finally = {
[18:04:15.062]         if (!identical(...future.workdir, getwd())) 
[18:04:15.062]             setwd(...future.workdir)
[18:04:15.062]         {
[18:04:15.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.062]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.062]             }
[18:04:15.062]             base::options(...future.oldOptions)
[18:04:15.062]             if (.Platform$OS.type == "windows") {
[18:04:15.062]                 old_names <- names(...future.oldEnvVars)
[18:04:15.062]                 envs <- base::Sys.getenv()
[18:04:15.062]                 names <- names(envs)
[18:04:15.062]                 common <- intersect(names, old_names)
[18:04:15.062]                 added <- setdiff(names, old_names)
[18:04:15.062]                 removed <- setdiff(old_names, names)
[18:04:15.062]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.062]                   envs[common]]
[18:04:15.062]                 NAMES <- toupper(changed)
[18:04:15.062]                 args <- list()
[18:04:15.062]                 for (kk in seq_along(NAMES)) {
[18:04:15.062]                   name <- changed[[kk]]
[18:04:15.062]                   NAME <- NAMES[[kk]]
[18:04:15.062]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.062]                     next
[18:04:15.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.062]                 }
[18:04:15.062]                 NAMES <- toupper(added)
[18:04:15.062]                 for (kk in seq_along(NAMES)) {
[18:04:15.062]                   name <- added[[kk]]
[18:04:15.062]                   NAME <- NAMES[[kk]]
[18:04:15.062]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.062]                     next
[18:04:15.062]                   args[[name]] <- ""
[18:04:15.062]                 }
[18:04:15.062]                 NAMES <- toupper(removed)
[18:04:15.062]                 for (kk in seq_along(NAMES)) {
[18:04:15.062]                   name <- removed[[kk]]
[18:04:15.062]                   NAME <- NAMES[[kk]]
[18:04:15.062]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.062]                     next
[18:04:15.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.062]                 }
[18:04:15.062]                 if (length(args) > 0) 
[18:04:15.062]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.062]             }
[18:04:15.062]             else {
[18:04:15.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.062]             }
[18:04:15.062]             {
[18:04:15.062]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.062]                   0L) {
[18:04:15.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.062]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.062]                   base::options(opts)
[18:04:15.062]                 }
[18:04:15.062]                 {
[18:04:15.062]                   {
[18:04:15.062]                     NULL
[18:04:15.062]                     RNGkind("Mersenne-Twister")
[18:04:15.062]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.062]                       inherits = FALSE)
[18:04:15.062]                   }
[18:04:15.062]                   options(future.plan = NULL)
[18:04:15.062]                   if (is.na(NA_character_)) 
[18:04:15.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.062]                     .init = FALSE)
[18:04:15.062]                 }
[18:04:15.062]             }
[18:04:15.062]         }
[18:04:15.062]     })
[18:04:15.062]     if (TRUE) {
[18:04:15.062]         base::sink(type = "output", split = FALSE)
[18:04:15.062]         if (TRUE) {
[18:04:15.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.062]         }
[18:04:15.062]         else {
[18:04:15.062]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.062]         }
[18:04:15.062]         base::close(...future.stdout)
[18:04:15.062]         ...future.stdout <- NULL
[18:04:15.062]     }
[18:04:15.062]     ...future.result$conditions <- ...future.conditions
[18:04:15.062]     ...future.result$finished <- base::Sys.time()
[18:04:15.062]     ...future.result
[18:04:15.062] }
[18:04:15.066] plan(): Setting new future strategy stack:
[18:04:15.066] List of future strategies:
[18:04:15.066] 1. sequential:
[18:04:15.066]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.066]    - tweaked: FALSE
[18:04:15.066]    - call: NULL
[18:04:15.068] plan(): nbrOfWorkers() = 1
[18:04:15.069] plan(): Setting new future strategy stack:
[18:04:15.069] List of future strategies:
[18:04:15.069] 1. sequential:
[18:04:15.069]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.069]    - tweaked: FALSE
[18:04:15.069]    - call: plan(strategy)
[18:04:15.070] plan(): nbrOfWorkers() = 1
[18:04:15.071] SequentialFuture started (and completed)
[18:04:15.071] - Launch lazy future ... done
[18:04:15.071] run() for ‘SequentialFuture’ ... done
[18:04:15.072] getGlobalsAndPackages() ...
[18:04:15.072] Searching for globals...
[18:04:15.072] 
[18:04:15.073] Searching for globals ... DONE
[18:04:15.073] - globals: [0] <none>
[18:04:15.073] getGlobalsAndPackages() ... DONE
[18:04:15.074] run() for ‘Future’ ...
[18:04:15.074] - state: ‘created’
[18:04:15.074] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.075] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.075]   - Field: ‘label’
[18:04:15.076]   - Field: ‘local’
[18:04:15.076]   - Field: ‘owner’
[18:04:15.076]   - Field: ‘envir’
[18:04:15.076]   - Field: ‘packages’
[18:04:15.076]   - Field: ‘gc’
[18:04:15.077]   - Field: ‘conditions’
[18:04:15.077]   - Field: ‘expr’
[18:04:15.077]   - Field: ‘uuid’
[18:04:15.077]   - Field: ‘seed’
[18:04:15.077]   - Field: ‘version’
[18:04:15.078]   - Field: ‘result’
[18:04:15.078]   - Field: ‘asynchronous’
[18:04:15.078]   - Field: ‘calls’
[18:04:15.078]   - Field: ‘globals’
[18:04:15.078]   - Field: ‘stdout’
[18:04:15.079]   - Field: ‘earlySignal’
[18:04:15.079]   - Field: ‘lazy’
[18:04:15.079]   - Field: ‘state’
[18:04:15.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.079] - Launch lazy future ...
[18:04:15.080] Packages needed by the future expression (n = 0): <none>
[18:04:15.080] Packages needed by future strategies (n = 0): <none>
[18:04:15.081] {
[18:04:15.081]     {
[18:04:15.081]         {
[18:04:15.081]             ...future.startTime <- base::Sys.time()
[18:04:15.081]             {
[18:04:15.081]                 {
[18:04:15.081]                   {
[18:04:15.081]                     base::local({
[18:04:15.081]                       has_future <- base::requireNamespace("future", 
[18:04:15.081]                         quietly = TRUE)
[18:04:15.081]                       if (has_future) {
[18:04:15.081]                         ns <- base::getNamespace("future")
[18:04:15.081]                         version <- ns[[".package"]][["version"]]
[18:04:15.081]                         if (is.null(version)) 
[18:04:15.081]                           version <- utils::packageVersion("future")
[18:04:15.081]                       }
[18:04:15.081]                       else {
[18:04:15.081]                         version <- NULL
[18:04:15.081]                       }
[18:04:15.081]                       if (!has_future || version < "1.8.0") {
[18:04:15.081]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.081]                           "", base::R.version$version.string), 
[18:04:15.081]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.081]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.081]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.081]                             "release", "version")], collapse = " "), 
[18:04:15.081]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.081]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.081]                           info)
[18:04:15.081]                         info <- base::paste(info, collapse = "; ")
[18:04:15.081]                         if (!has_future) {
[18:04:15.081]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.081]                             info)
[18:04:15.081]                         }
[18:04:15.081]                         else {
[18:04:15.081]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.081]                             info, version)
[18:04:15.081]                         }
[18:04:15.081]                         base::stop(msg)
[18:04:15.081]                       }
[18:04:15.081]                     })
[18:04:15.081]                   }
[18:04:15.081]                   ...future.strategy.old <- future::plan("list")
[18:04:15.081]                   options(future.plan = NULL)
[18:04:15.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.081]                 }
[18:04:15.081]                 ...future.workdir <- getwd()
[18:04:15.081]             }
[18:04:15.081]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.081]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.081]         }
[18:04:15.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.081]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.081]             base::names(...future.oldOptions))
[18:04:15.081]     }
[18:04:15.081]     if (FALSE) {
[18:04:15.081]     }
[18:04:15.081]     else {
[18:04:15.081]         if (TRUE) {
[18:04:15.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.081]                 open = "w")
[18:04:15.081]         }
[18:04:15.081]         else {
[18:04:15.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.081]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.081]         }
[18:04:15.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.081]             base::sink(type = "output", split = FALSE)
[18:04:15.081]             base::close(...future.stdout)
[18:04:15.081]         }, add = TRUE)
[18:04:15.081]     }
[18:04:15.081]     ...future.frame <- base::sys.nframe()
[18:04:15.081]     ...future.conditions <- base::list()
[18:04:15.081]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.081]     if (FALSE) {
[18:04:15.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.081]     }
[18:04:15.081]     ...future.result <- base::tryCatch({
[18:04:15.081]         base::withCallingHandlers({
[18:04:15.081]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:15.081]             future::FutureResult(value = ...future.value$value, 
[18:04:15.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.081]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.081]                     ...future.globalenv.names))
[18:04:15.081]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.081]         }, condition = base::local({
[18:04:15.081]             c <- base::c
[18:04:15.081]             inherits <- base::inherits
[18:04:15.081]             invokeRestart <- base::invokeRestart
[18:04:15.081]             length <- base::length
[18:04:15.081]             list <- base::list
[18:04:15.081]             seq.int <- base::seq.int
[18:04:15.081]             signalCondition <- base::signalCondition
[18:04:15.081]             sys.calls <- base::sys.calls
[18:04:15.081]             `[[` <- base::`[[`
[18:04:15.081]             `+` <- base::`+`
[18:04:15.081]             `<<-` <- base::`<<-`
[18:04:15.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.081]                   3L)]
[18:04:15.081]             }
[18:04:15.081]             function(cond) {
[18:04:15.081]                 is_error <- inherits(cond, "error")
[18:04:15.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.081]                   NULL)
[18:04:15.081]                 if (is_error) {
[18:04:15.081]                   sessionInformation <- function() {
[18:04:15.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.081]                       search = base::search(), system = base::Sys.info())
[18:04:15.081]                   }
[18:04:15.081]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.081]                     cond$call), session = sessionInformation(), 
[18:04:15.081]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.081]                   signalCondition(cond)
[18:04:15.081]                 }
[18:04:15.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.081]                 "immediateCondition"))) {
[18:04:15.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.081]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.081]                   if (TRUE && !signal) {
[18:04:15.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.081]                     {
[18:04:15.081]                       inherits <- base::inherits
[18:04:15.081]                       invokeRestart <- base::invokeRestart
[18:04:15.081]                       is.null <- base::is.null
[18:04:15.081]                       muffled <- FALSE
[18:04:15.081]                       if (inherits(cond, "message")) {
[18:04:15.081]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.081]                         if (muffled) 
[18:04:15.081]                           invokeRestart("muffleMessage")
[18:04:15.081]                       }
[18:04:15.081]                       else if (inherits(cond, "warning")) {
[18:04:15.081]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.081]                         if (muffled) 
[18:04:15.081]                           invokeRestart("muffleWarning")
[18:04:15.081]                       }
[18:04:15.081]                       else if (inherits(cond, "condition")) {
[18:04:15.081]                         if (!is.null(pattern)) {
[18:04:15.081]                           computeRestarts <- base::computeRestarts
[18:04:15.081]                           grepl <- base::grepl
[18:04:15.081]                           restarts <- computeRestarts(cond)
[18:04:15.081]                           for (restart in restarts) {
[18:04:15.081]                             name <- restart$name
[18:04:15.081]                             if (is.null(name)) 
[18:04:15.081]                               next
[18:04:15.081]                             if (!grepl(pattern, name)) 
[18:04:15.081]                               next
[18:04:15.081]                             invokeRestart(restart)
[18:04:15.081]                             muffled <- TRUE
[18:04:15.081]                             break
[18:04:15.081]                           }
[18:04:15.081]                         }
[18:04:15.081]                       }
[18:04:15.081]                       invisible(muffled)
[18:04:15.081]                     }
[18:04:15.081]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.081]                   }
[18:04:15.081]                 }
[18:04:15.081]                 else {
[18:04:15.081]                   if (TRUE) {
[18:04:15.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.081]                     {
[18:04:15.081]                       inherits <- base::inherits
[18:04:15.081]                       invokeRestart <- base::invokeRestart
[18:04:15.081]                       is.null <- base::is.null
[18:04:15.081]                       muffled <- FALSE
[18:04:15.081]                       if (inherits(cond, "message")) {
[18:04:15.081]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.081]                         if (muffled) 
[18:04:15.081]                           invokeRestart("muffleMessage")
[18:04:15.081]                       }
[18:04:15.081]                       else if (inherits(cond, "warning")) {
[18:04:15.081]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.081]                         if (muffled) 
[18:04:15.081]                           invokeRestart("muffleWarning")
[18:04:15.081]                       }
[18:04:15.081]                       else if (inherits(cond, "condition")) {
[18:04:15.081]                         if (!is.null(pattern)) {
[18:04:15.081]                           computeRestarts <- base::computeRestarts
[18:04:15.081]                           grepl <- base::grepl
[18:04:15.081]                           restarts <- computeRestarts(cond)
[18:04:15.081]                           for (restart in restarts) {
[18:04:15.081]                             name <- restart$name
[18:04:15.081]                             if (is.null(name)) 
[18:04:15.081]                               next
[18:04:15.081]                             if (!grepl(pattern, name)) 
[18:04:15.081]                               next
[18:04:15.081]                             invokeRestart(restart)
[18:04:15.081]                             muffled <- TRUE
[18:04:15.081]                             break
[18:04:15.081]                           }
[18:04:15.081]                         }
[18:04:15.081]                       }
[18:04:15.081]                       invisible(muffled)
[18:04:15.081]                     }
[18:04:15.081]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.081]                   }
[18:04:15.081]                 }
[18:04:15.081]             }
[18:04:15.081]         }))
[18:04:15.081]     }, error = function(ex) {
[18:04:15.081]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.081]                 ...future.rng), started = ...future.startTime, 
[18:04:15.081]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.081]             version = "1.8"), class = "FutureResult")
[18:04:15.081]     }, finally = {
[18:04:15.081]         if (!identical(...future.workdir, getwd())) 
[18:04:15.081]             setwd(...future.workdir)
[18:04:15.081]         {
[18:04:15.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.081]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.081]             }
[18:04:15.081]             base::options(...future.oldOptions)
[18:04:15.081]             if (.Platform$OS.type == "windows") {
[18:04:15.081]                 old_names <- names(...future.oldEnvVars)
[18:04:15.081]                 envs <- base::Sys.getenv()
[18:04:15.081]                 names <- names(envs)
[18:04:15.081]                 common <- intersect(names, old_names)
[18:04:15.081]                 added <- setdiff(names, old_names)
[18:04:15.081]                 removed <- setdiff(old_names, names)
[18:04:15.081]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.081]                   envs[common]]
[18:04:15.081]                 NAMES <- toupper(changed)
[18:04:15.081]                 args <- list()
[18:04:15.081]                 for (kk in seq_along(NAMES)) {
[18:04:15.081]                   name <- changed[[kk]]
[18:04:15.081]                   NAME <- NAMES[[kk]]
[18:04:15.081]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.081]                     next
[18:04:15.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.081]                 }
[18:04:15.081]                 NAMES <- toupper(added)
[18:04:15.081]                 for (kk in seq_along(NAMES)) {
[18:04:15.081]                   name <- added[[kk]]
[18:04:15.081]                   NAME <- NAMES[[kk]]
[18:04:15.081]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.081]                     next
[18:04:15.081]                   args[[name]] <- ""
[18:04:15.081]                 }
[18:04:15.081]                 NAMES <- toupper(removed)
[18:04:15.081]                 for (kk in seq_along(NAMES)) {
[18:04:15.081]                   name <- removed[[kk]]
[18:04:15.081]                   NAME <- NAMES[[kk]]
[18:04:15.081]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.081]                     next
[18:04:15.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.081]                 }
[18:04:15.081]                 if (length(args) > 0) 
[18:04:15.081]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.081]             }
[18:04:15.081]             else {
[18:04:15.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.081]             }
[18:04:15.081]             {
[18:04:15.081]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.081]                   0L) {
[18:04:15.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.081]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.081]                   base::options(opts)
[18:04:15.081]                 }
[18:04:15.081]                 {
[18:04:15.081]                   {
[18:04:15.081]                     NULL
[18:04:15.081]                     RNGkind("Mersenne-Twister")
[18:04:15.081]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.081]                       inherits = FALSE)
[18:04:15.081]                   }
[18:04:15.081]                   options(future.plan = NULL)
[18:04:15.081]                   if (is.na(NA_character_)) 
[18:04:15.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.081]                     .init = FALSE)
[18:04:15.081]                 }
[18:04:15.081]             }
[18:04:15.081]         }
[18:04:15.081]     })
[18:04:15.081]     if (TRUE) {
[18:04:15.081]         base::sink(type = "output", split = FALSE)
[18:04:15.081]         if (TRUE) {
[18:04:15.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.081]         }
[18:04:15.081]         else {
[18:04:15.081]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.081]         }
[18:04:15.081]         base::close(...future.stdout)
[18:04:15.081]         ...future.stdout <- NULL
[18:04:15.081]     }
[18:04:15.081]     ...future.result$conditions <- ...future.conditions
[18:04:15.081]     ...future.result$finished <- base::Sys.time()
[18:04:15.081]     ...future.result
[18:04:15.081] }
[18:04:15.085] plan(): Setting new future strategy stack:
[18:04:15.085] List of future strategies:
[18:04:15.085] 1. sequential:
[18:04:15.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.085]    - tweaked: FALSE
[18:04:15.085]    - call: NULL
[18:04:15.086] plan(): nbrOfWorkers() = 1
[18:04:15.088] plan(): Setting new future strategy stack:
[18:04:15.088] List of future strategies:
[18:04:15.088] 1. sequential:
[18:04:15.088]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.088]    - tweaked: FALSE
[18:04:15.088]    - call: plan(strategy)
[18:04:15.089] plan(): nbrOfWorkers() = 1
[18:04:15.089] SequentialFuture started (and completed)
[18:04:15.089] - Launch lazy future ... done
[18:04:15.090] run() for ‘SequentialFuture’ ... done
[18:04:15.090] getGlobalsAndPackages() ...
[18:04:15.091] Searching for globals...
[18:04:15.092] - globals found: [1] ‘{’
[18:04:15.092] Searching for globals ... DONE
[18:04:15.095] Resolving globals: FALSE
[18:04:15.096] 
[18:04:15.096] 
[18:04:15.097] getGlobalsAndPackages() ... DONE
[18:04:15.097] run() for ‘Future’ ...
[18:04:15.097] - state: ‘created’
[18:04:15.098] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.098] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.098] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.099]   - Field: ‘label’
[18:04:15.099]   - Field: ‘local’
[18:04:15.099]   - Field: ‘owner’
[18:04:15.099]   - Field: ‘envir’
[18:04:15.100]   - Field: ‘packages’
[18:04:15.100]   - Field: ‘gc’
[18:04:15.100]   - Field: ‘conditions’
[18:04:15.100]   - Field: ‘expr’
[18:04:15.100]   - Field: ‘uuid’
[18:04:15.101]   - Field: ‘seed’
[18:04:15.101]   - Field: ‘version’
[18:04:15.101]   - Field: ‘result’
[18:04:15.101]   - Field: ‘asynchronous’
[18:04:15.101]   - Field: ‘calls’
[18:04:15.102]   - Field: ‘globals’
[18:04:15.102]   - Field: ‘stdout’
[18:04:15.102]   - Field: ‘earlySignal’
[18:04:15.102]   - Field: ‘lazy’
[18:04:15.102]   - Field: ‘state’
[18:04:15.103] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.103] - Launch lazy future ...
[18:04:15.103] Packages needed by the future expression (n = 0): <none>
[18:04:15.103] Packages needed by future strategies (n = 0): <none>
[18:04:15.104] {
[18:04:15.104]     {
[18:04:15.104]         {
[18:04:15.104]             ...future.startTime <- base::Sys.time()
[18:04:15.104]             {
[18:04:15.104]                 {
[18:04:15.104]                   {
[18:04:15.104]                     base::local({
[18:04:15.104]                       has_future <- base::requireNamespace("future", 
[18:04:15.104]                         quietly = TRUE)
[18:04:15.104]                       if (has_future) {
[18:04:15.104]                         ns <- base::getNamespace("future")
[18:04:15.104]                         version <- ns[[".package"]][["version"]]
[18:04:15.104]                         if (is.null(version)) 
[18:04:15.104]                           version <- utils::packageVersion("future")
[18:04:15.104]                       }
[18:04:15.104]                       else {
[18:04:15.104]                         version <- NULL
[18:04:15.104]                       }
[18:04:15.104]                       if (!has_future || version < "1.8.0") {
[18:04:15.104]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.104]                           "", base::R.version$version.string), 
[18:04:15.104]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.104]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.104]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.104]                             "release", "version")], collapse = " "), 
[18:04:15.104]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.104]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.104]                           info)
[18:04:15.104]                         info <- base::paste(info, collapse = "; ")
[18:04:15.104]                         if (!has_future) {
[18:04:15.104]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.104]                             info)
[18:04:15.104]                         }
[18:04:15.104]                         else {
[18:04:15.104]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.104]                             info, version)
[18:04:15.104]                         }
[18:04:15.104]                         base::stop(msg)
[18:04:15.104]                       }
[18:04:15.104]                     })
[18:04:15.104]                   }
[18:04:15.104]                   ...future.strategy.old <- future::plan("list")
[18:04:15.104]                   options(future.plan = NULL)
[18:04:15.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.104]                 }
[18:04:15.104]                 ...future.workdir <- getwd()
[18:04:15.104]             }
[18:04:15.104]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.104]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.104]         }
[18:04:15.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.104]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.104]             base::names(...future.oldOptions))
[18:04:15.104]     }
[18:04:15.104]     if (FALSE) {
[18:04:15.104]     }
[18:04:15.104]     else {
[18:04:15.104]         if (TRUE) {
[18:04:15.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.104]                 open = "w")
[18:04:15.104]         }
[18:04:15.104]         else {
[18:04:15.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.104]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.104]         }
[18:04:15.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.104]             base::sink(type = "output", split = FALSE)
[18:04:15.104]             base::close(...future.stdout)
[18:04:15.104]         }, add = TRUE)
[18:04:15.104]     }
[18:04:15.104]     ...future.frame <- base::sys.nframe()
[18:04:15.104]     ...future.conditions <- base::list()
[18:04:15.104]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.104]     if (FALSE) {
[18:04:15.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.104]     }
[18:04:15.104]     ...future.result <- base::tryCatch({
[18:04:15.104]         base::withCallingHandlers({
[18:04:15.104]             ...future.value <- base::withVisible(base::local({
[18:04:15.104]                 4
[18:04:15.104]             }))
[18:04:15.104]             future::FutureResult(value = ...future.value$value, 
[18:04:15.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.104]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.104]                     ...future.globalenv.names))
[18:04:15.104]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.104]         }, condition = base::local({
[18:04:15.104]             c <- base::c
[18:04:15.104]             inherits <- base::inherits
[18:04:15.104]             invokeRestart <- base::invokeRestart
[18:04:15.104]             length <- base::length
[18:04:15.104]             list <- base::list
[18:04:15.104]             seq.int <- base::seq.int
[18:04:15.104]             signalCondition <- base::signalCondition
[18:04:15.104]             sys.calls <- base::sys.calls
[18:04:15.104]             `[[` <- base::`[[`
[18:04:15.104]             `+` <- base::`+`
[18:04:15.104]             `<<-` <- base::`<<-`
[18:04:15.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.104]                   3L)]
[18:04:15.104]             }
[18:04:15.104]             function(cond) {
[18:04:15.104]                 is_error <- inherits(cond, "error")
[18:04:15.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.104]                   NULL)
[18:04:15.104]                 if (is_error) {
[18:04:15.104]                   sessionInformation <- function() {
[18:04:15.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.104]                       search = base::search(), system = base::Sys.info())
[18:04:15.104]                   }
[18:04:15.104]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.104]                     cond$call), session = sessionInformation(), 
[18:04:15.104]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.104]                   signalCondition(cond)
[18:04:15.104]                 }
[18:04:15.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.104]                 "immediateCondition"))) {
[18:04:15.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.104]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.104]                   if (TRUE && !signal) {
[18:04:15.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.104]                     {
[18:04:15.104]                       inherits <- base::inherits
[18:04:15.104]                       invokeRestart <- base::invokeRestart
[18:04:15.104]                       is.null <- base::is.null
[18:04:15.104]                       muffled <- FALSE
[18:04:15.104]                       if (inherits(cond, "message")) {
[18:04:15.104]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.104]                         if (muffled) 
[18:04:15.104]                           invokeRestart("muffleMessage")
[18:04:15.104]                       }
[18:04:15.104]                       else if (inherits(cond, "warning")) {
[18:04:15.104]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.104]                         if (muffled) 
[18:04:15.104]                           invokeRestart("muffleWarning")
[18:04:15.104]                       }
[18:04:15.104]                       else if (inherits(cond, "condition")) {
[18:04:15.104]                         if (!is.null(pattern)) {
[18:04:15.104]                           computeRestarts <- base::computeRestarts
[18:04:15.104]                           grepl <- base::grepl
[18:04:15.104]                           restarts <- computeRestarts(cond)
[18:04:15.104]                           for (restart in restarts) {
[18:04:15.104]                             name <- restart$name
[18:04:15.104]                             if (is.null(name)) 
[18:04:15.104]                               next
[18:04:15.104]                             if (!grepl(pattern, name)) 
[18:04:15.104]                               next
[18:04:15.104]                             invokeRestart(restart)
[18:04:15.104]                             muffled <- TRUE
[18:04:15.104]                             break
[18:04:15.104]                           }
[18:04:15.104]                         }
[18:04:15.104]                       }
[18:04:15.104]                       invisible(muffled)
[18:04:15.104]                     }
[18:04:15.104]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.104]                   }
[18:04:15.104]                 }
[18:04:15.104]                 else {
[18:04:15.104]                   if (TRUE) {
[18:04:15.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.104]                     {
[18:04:15.104]                       inherits <- base::inherits
[18:04:15.104]                       invokeRestart <- base::invokeRestart
[18:04:15.104]                       is.null <- base::is.null
[18:04:15.104]                       muffled <- FALSE
[18:04:15.104]                       if (inherits(cond, "message")) {
[18:04:15.104]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.104]                         if (muffled) 
[18:04:15.104]                           invokeRestart("muffleMessage")
[18:04:15.104]                       }
[18:04:15.104]                       else if (inherits(cond, "warning")) {
[18:04:15.104]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.104]                         if (muffled) 
[18:04:15.104]                           invokeRestart("muffleWarning")
[18:04:15.104]                       }
[18:04:15.104]                       else if (inherits(cond, "condition")) {
[18:04:15.104]                         if (!is.null(pattern)) {
[18:04:15.104]                           computeRestarts <- base::computeRestarts
[18:04:15.104]                           grepl <- base::grepl
[18:04:15.104]                           restarts <- computeRestarts(cond)
[18:04:15.104]                           for (restart in restarts) {
[18:04:15.104]                             name <- restart$name
[18:04:15.104]                             if (is.null(name)) 
[18:04:15.104]                               next
[18:04:15.104]                             if (!grepl(pattern, name)) 
[18:04:15.104]                               next
[18:04:15.104]                             invokeRestart(restart)
[18:04:15.104]                             muffled <- TRUE
[18:04:15.104]                             break
[18:04:15.104]                           }
[18:04:15.104]                         }
[18:04:15.104]                       }
[18:04:15.104]                       invisible(muffled)
[18:04:15.104]                     }
[18:04:15.104]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.104]                   }
[18:04:15.104]                 }
[18:04:15.104]             }
[18:04:15.104]         }))
[18:04:15.104]     }, error = function(ex) {
[18:04:15.104]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.104]                 ...future.rng), started = ...future.startTime, 
[18:04:15.104]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.104]             version = "1.8"), class = "FutureResult")
[18:04:15.104]     }, finally = {
[18:04:15.104]         if (!identical(...future.workdir, getwd())) 
[18:04:15.104]             setwd(...future.workdir)
[18:04:15.104]         {
[18:04:15.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.104]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.104]             }
[18:04:15.104]             base::options(...future.oldOptions)
[18:04:15.104]             if (.Platform$OS.type == "windows") {
[18:04:15.104]                 old_names <- names(...future.oldEnvVars)
[18:04:15.104]                 envs <- base::Sys.getenv()
[18:04:15.104]                 names <- names(envs)
[18:04:15.104]                 common <- intersect(names, old_names)
[18:04:15.104]                 added <- setdiff(names, old_names)
[18:04:15.104]                 removed <- setdiff(old_names, names)
[18:04:15.104]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.104]                   envs[common]]
[18:04:15.104]                 NAMES <- toupper(changed)
[18:04:15.104]                 args <- list()
[18:04:15.104]                 for (kk in seq_along(NAMES)) {
[18:04:15.104]                   name <- changed[[kk]]
[18:04:15.104]                   NAME <- NAMES[[kk]]
[18:04:15.104]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.104]                     next
[18:04:15.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.104]                 }
[18:04:15.104]                 NAMES <- toupper(added)
[18:04:15.104]                 for (kk in seq_along(NAMES)) {
[18:04:15.104]                   name <- added[[kk]]
[18:04:15.104]                   NAME <- NAMES[[kk]]
[18:04:15.104]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.104]                     next
[18:04:15.104]                   args[[name]] <- ""
[18:04:15.104]                 }
[18:04:15.104]                 NAMES <- toupper(removed)
[18:04:15.104]                 for (kk in seq_along(NAMES)) {
[18:04:15.104]                   name <- removed[[kk]]
[18:04:15.104]                   NAME <- NAMES[[kk]]
[18:04:15.104]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.104]                     next
[18:04:15.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.104]                 }
[18:04:15.104]                 if (length(args) > 0) 
[18:04:15.104]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.104]             }
[18:04:15.104]             else {
[18:04:15.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.104]             }
[18:04:15.104]             {
[18:04:15.104]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.104]                   0L) {
[18:04:15.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.104]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.104]                   base::options(opts)
[18:04:15.104]                 }
[18:04:15.104]                 {
[18:04:15.104]                   {
[18:04:15.104]                     NULL
[18:04:15.104]                     RNGkind("Mersenne-Twister")
[18:04:15.104]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.104]                       inherits = FALSE)
[18:04:15.104]                   }
[18:04:15.104]                   options(future.plan = NULL)
[18:04:15.104]                   if (is.na(NA_character_)) 
[18:04:15.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.104]                     .init = FALSE)
[18:04:15.104]                 }
[18:04:15.104]             }
[18:04:15.104]         }
[18:04:15.104]     })
[18:04:15.104]     if (TRUE) {
[18:04:15.104]         base::sink(type = "output", split = FALSE)
[18:04:15.104]         if (TRUE) {
[18:04:15.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.104]         }
[18:04:15.104]         else {
[18:04:15.104]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.104]         }
[18:04:15.104]         base::close(...future.stdout)
[18:04:15.104]         ...future.stdout <- NULL
[18:04:15.104]     }
[18:04:15.104]     ...future.result$conditions <- ...future.conditions
[18:04:15.104]     ...future.result$finished <- base::Sys.time()
[18:04:15.104]     ...future.result
[18:04:15.104] }
[18:04:15.108] plan(): Setting new future strategy stack:
[18:04:15.108] List of future strategies:
[18:04:15.108] 1. sequential:
[18:04:15.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.108]    - tweaked: FALSE
[18:04:15.108]    - call: NULL
[18:04:15.109] plan(): nbrOfWorkers() = 1
[18:04:15.111] plan(): Setting new future strategy stack:
[18:04:15.111] List of future strategies:
[18:04:15.111] 1. sequential:
[18:04:15.111]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.111]    - tweaked: FALSE
[18:04:15.111]    - call: plan(strategy)
[18:04:15.112] plan(): nbrOfWorkers() = 1
[18:04:15.113] SequentialFuture started (and completed)
[18:04:15.113] - Launch lazy future ... done
[18:04:15.113] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2abe8a50> 
Classes 'listenv', 'environment' <environment: 0x5e3c295f52e0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[18:04:15.122] resolved() for ‘SequentialFuture’ ...
[18:04:15.122] - state: ‘finished’
[18:04:15.122] - run: TRUE
[18:04:15.122] - result: ‘FutureResult’
[18:04:15.123] resolved() for ‘SequentialFuture’ ... done
[18:04:15.123] resolved() for ‘SequentialFuture’ ...
[18:04:15.123] - state: ‘finished’
[18:04:15.123] - run: TRUE
[18:04:15.123] - result: ‘FutureResult’
[18:04:15.124] resolved() for ‘SequentialFuture’ ... done
[18:04:15.124] resolved() for ‘SequentialFuture’ ...
[18:04:15.124] - state: ‘finished’
[18:04:15.124] - run: TRUE
[18:04:15.124] - result: ‘FutureResult’
[18:04:15.125] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:15.130] resolve() on list environment ...
[18:04:15.130]  recursive: 0
[18:04:15.133]  length: 6
[18:04:15.133]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:15.133] signalConditionsASAP(numeric, pos=1) ...
[18:04:15.133] - nx: 6
[18:04:15.134] - relay: TRUE
[18:04:15.134] - stdout: TRUE
[18:04:15.134] - signal: TRUE
[18:04:15.134] - resignal: FALSE
[18:04:15.134] - force: TRUE
[18:04:15.135] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.135] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.135]  - until=2
[18:04:15.135]  - relaying element #2
[18:04:15.135] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.136] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.136] signalConditionsASAP(NULL, pos=1) ... done
[18:04:15.136]  length: 5 (resolved future 1)
[18:04:15.136] resolved() for ‘SequentialFuture’ ...
[18:04:15.137] - state: ‘finished’
[18:04:15.137] - run: TRUE
[18:04:15.137] - result: ‘FutureResult’
[18:04:15.137] resolved() for ‘SequentialFuture’ ... done
[18:04:15.137] Future #2
[18:04:15.138] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:15.138] - nx: 6
[18:04:15.138] - relay: TRUE
[18:04:15.138] - stdout: TRUE
[18:04:15.138] - signal: TRUE
[18:04:15.139] - resignal: FALSE
[18:04:15.139] - force: TRUE
[18:04:15.139] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.139] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.139]  - until=2
[18:04:15.140]  - relaying element #2
[18:04:15.140] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.140] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.140] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:15.141]  length: 4 (resolved future 2)
[18:04:15.141] resolved() for ‘SequentialFuture’ ...
[18:04:15.141] - state: ‘finished’
[18:04:15.141] - run: TRUE
[18:04:15.142] - result: ‘FutureResult’
[18:04:15.142] resolved() for ‘SequentialFuture’ ... done
[18:04:15.142] Future #3
[18:04:15.142] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:15.142] - nx: 6
[18:04:15.143] - relay: TRUE
[18:04:15.143] - stdout: TRUE
[18:04:15.143] - signal: TRUE
[18:04:15.143] - resignal: FALSE
[18:04:15.143] - force: TRUE
[18:04:15.144] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.144] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.144]  - until=3
[18:04:15.144]  - relaying element #3
[18:04:15.145] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.145] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.145] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:15.145]  length: 3 (resolved future 3)
[18:04:15.145] resolved() for ‘SequentialFuture’ ...
[18:04:15.146] - state: ‘finished’
[18:04:15.146] - run: TRUE
[18:04:15.146] - result: ‘FutureResult’
[18:04:15.146] resolved() for ‘SequentialFuture’ ... done
[18:04:15.146] Future #4
[18:04:15.147] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:15.147] - nx: 6
[18:04:15.147] - relay: TRUE
[18:04:15.147] - stdout: TRUE
[18:04:15.147] - signal: TRUE
[18:04:15.148] - resignal: FALSE
[18:04:15.148] - force: TRUE
[18:04:15.148] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.148] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.148]  - until=4
[18:04:15.149]  - relaying element #4
[18:04:15.149] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.149] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.183] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:15.183]  length: 2 (resolved future 4)
[18:04:15.183] signalConditionsASAP(NULL, pos=5) ...
[18:04:15.183] - nx: 6
[18:04:15.184] - relay: TRUE
[18:04:15.184] - stdout: TRUE
[18:04:15.184] - signal: TRUE
[18:04:15.184] - resignal: FALSE
[18:04:15.184] - force: TRUE
[18:04:15.185] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.185] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.185]  - until=6
[18:04:15.185]  - relaying element #6
[18:04:15.185] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.186] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.186] signalConditionsASAP(NULL, pos=5) ... done
[18:04:15.186]  length: 1 (resolved future 5)
[18:04:15.186] signalConditionsASAP(numeric, pos=6) ...
[18:04:15.186] - nx: 6
[18:04:15.187] - relay: TRUE
[18:04:15.187] - stdout: TRUE
[18:04:15.187] - signal: TRUE
[18:04:15.187] - resignal: FALSE
[18:04:15.187] - force: TRUE
[18:04:15.187] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.188] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.188]  - until=6
[18:04:15.188] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.188] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.188] signalConditionsASAP(numeric, pos=6) ... done
[18:04:15.189]  length: 0 (resolved future 6)
[18:04:15.189] Relaying remaining futures
[18:04:15.189] signalConditionsASAP(NULL, pos=0) ...
[18:04:15.189] - nx: 6
[18:04:15.189] - relay: TRUE
[18:04:15.189] - stdout: TRUE
[18:04:15.190] - signal: TRUE
[18:04:15.190] - resignal: FALSE
[18:04:15.190] - force: TRUE
[18:04:15.190] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.190] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:15.191] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.191] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.191] signalConditionsASAP(NULL, pos=0) ... done
[18:04:15.191] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5e3c2b096cb0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[18:04:15.195] getGlobalsAndPackages() ...
[18:04:15.195] Searching for globals...
[18:04:15.196] 
[18:04:15.196] Searching for globals ... DONE
[18:04:15.196] - globals: [0] <none>
[18:04:15.197] getGlobalsAndPackages() ... DONE
[18:04:15.197] run() for ‘Future’ ...
[18:04:15.197] - state: ‘created’
[18:04:15.198] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.198] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.198] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.198]   - Field: ‘label’
[18:04:15.199]   - Field: ‘local’
[18:04:15.199]   - Field: ‘owner’
[18:04:15.199]   - Field: ‘envir’
[18:04:15.199]   - Field: ‘packages’
[18:04:15.199]   - Field: ‘gc’
[18:04:15.200]   - Field: ‘conditions’
[18:04:15.200]   - Field: ‘expr’
[18:04:15.200]   - Field: ‘uuid’
[18:04:15.200]   - Field: ‘seed’
[18:04:15.200]   - Field: ‘version’
[18:04:15.201]   - Field: ‘result’
[18:04:15.201]   - Field: ‘asynchronous’
[18:04:15.201]   - Field: ‘calls’
[18:04:15.201]   - Field: ‘globals’
[18:04:15.201]   - Field: ‘stdout’
[18:04:15.202]   - Field: ‘earlySignal’
[18:04:15.202]   - Field: ‘lazy’
[18:04:15.202]   - Field: ‘state’
[18:04:15.202] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.202] - Launch lazy future ...
[18:04:15.203] Packages needed by the future expression (n = 0): <none>
[18:04:15.203] Packages needed by future strategies (n = 0): <none>
[18:04:15.204] {
[18:04:15.204]     {
[18:04:15.204]         {
[18:04:15.204]             ...future.startTime <- base::Sys.time()
[18:04:15.204]             {
[18:04:15.204]                 {
[18:04:15.204]                   {
[18:04:15.204]                     base::local({
[18:04:15.204]                       has_future <- base::requireNamespace("future", 
[18:04:15.204]                         quietly = TRUE)
[18:04:15.204]                       if (has_future) {
[18:04:15.204]                         ns <- base::getNamespace("future")
[18:04:15.204]                         version <- ns[[".package"]][["version"]]
[18:04:15.204]                         if (is.null(version)) 
[18:04:15.204]                           version <- utils::packageVersion("future")
[18:04:15.204]                       }
[18:04:15.204]                       else {
[18:04:15.204]                         version <- NULL
[18:04:15.204]                       }
[18:04:15.204]                       if (!has_future || version < "1.8.0") {
[18:04:15.204]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.204]                           "", base::R.version$version.string), 
[18:04:15.204]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.204]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.204]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.204]                             "release", "version")], collapse = " "), 
[18:04:15.204]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.204]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.204]                           info)
[18:04:15.204]                         info <- base::paste(info, collapse = "; ")
[18:04:15.204]                         if (!has_future) {
[18:04:15.204]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.204]                             info)
[18:04:15.204]                         }
[18:04:15.204]                         else {
[18:04:15.204]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.204]                             info, version)
[18:04:15.204]                         }
[18:04:15.204]                         base::stop(msg)
[18:04:15.204]                       }
[18:04:15.204]                     })
[18:04:15.204]                   }
[18:04:15.204]                   ...future.strategy.old <- future::plan("list")
[18:04:15.204]                   options(future.plan = NULL)
[18:04:15.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.204]                 }
[18:04:15.204]                 ...future.workdir <- getwd()
[18:04:15.204]             }
[18:04:15.204]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.204]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.204]         }
[18:04:15.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.204]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.204]             base::names(...future.oldOptions))
[18:04:15.204]     }
[18:04:15.204]     if (FALSE) {
[18:04:15.204]     }
[18:04:15.204]     else {
[18:04:15.204]         if (TRUE) {
[18:04:15.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.204]                 open = "w")
[18:04:15.204]         }
[18:04:15.204]         else {
[18:04:15.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.204]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.204]         }
[18:04:15.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.204]             base::sink(type = "output", split = FALSE)
[18:04:15.204]             base::close(...future.stdout)
[18:04:15.204]         }, add = TRUE)
[18:04:15.204]     }
[18:04:15.204]     ...future.frame <- base::sys.nframe()
[18:04:15.204]     ...future.conditions <- base::list()
[18:04:15.204]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.204]     if (FALSE) {
[18:04:15.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.204]     }
[18:04:15.204]     ...future.result <- base::tryCatch({
[18:04:15.204]         base::withCallingHandlers({
[18:04:15.204]             ...future.value <- base::withVisible(base::local(2))
[18:04:15.204]             future::FutureResult(value = ...future.value$value, 
[18:04:15.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.204]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.204]                     ...future.globalenv.names))
[18:04:15.204]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.204]         }, condition = base::local({
[18:04:15.204]             c <- base::c
[18:04:15.204]             inherits <- base::inherits
[18:04:15.204]             invokeRestart <- base::invokeRestart
[18:04:15.204]             length <- base::length
[18:04:15.204]             list <- base::list
[18:04:15.204]             seq.int <- base::seq.int
[18:04:15.204]             signalCondition <- base::signalCondition
[18:04:15.204]             sys.calls <- base::sys.calls
[18:04:15.204]             `[[` <- base::`[[`
[18:04:15.204]             `+` <- base::`+`
[18:04:15.204]             `<<-` <- base::`<<-`
[18:04:15.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.204]                   3L)]
[18:04:15.204]             }
[18:04:15.204]             function(cond) {
[18:04:15.204]                 is_error <- inherits(cond, "error")
[18:04:15.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.204]                   NULL)
[18:04:15.204]                 if (is_error) {
[18:04:15.204]                   sessionInformation <- function() {
[18:04:15.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.204]                       search = base::search(), system = base::Sys.info())
[18:04:15.204]                   }
[18:04:15.204]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.204]                     cond$call), session = sessionInformation(), 
[18:04:15.204]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.204]                   signalCondition(cond)
[18:04:15.204]                 }
[18:04:15.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.204]                 "immediateCondition"))) {
[18:04:15.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.204]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.204]                   if (TRUE && !signal) {
[18:04:15.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.204]                     {
[18:04:15.204]                       inherits <- base::inherits
[18:04:15.204]                       invokeRestart <- base::invokeRestart
[18:04:15.204]                       is.null <- base::is.null
[18:04:15.204]                       muffled <- FALSE
[18:04:15.204]                       if (inherits(cond, "message")) {
[18:04:15.204]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.204]                         if (muffled) 
[18:04:15.204]                           invokeRestart("muffleMessage")
[18:04:15.204]                       }
[18:04:15.204]                       else if (inherits(cond, "warning")) {
[18:04:15.204]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.204]                         if (muffled) 
[18:04:15.204]                           invokeRestart("muffleWarning")
[18:04:15.204]                       }
[18:04:15.204]                       else if (inherits(cond, "condition")) {
[18:04:15.204]                         if (!is.null(pattern)) {
[18:04:15.204]                           computeRestarts <- base::computeRestarts
[18:04:15.204]                           grepl <- base::grepl
[18:04:15.204]                           restarts <- computeRestarts(cond)
[18:04:15.204]                           for (restart in restarts) {
[18:04:15.204]                             name <- restart$name
[18:04:15.204]                             if (is.null(name)) 
[18:04:15.204]                               next
[18:04:15.204]                             if (!grepl(pattern, name)) 
[18:04:15.204]                               next
[18:04:15.204]                             invokeRestart(restart)
[18:04:15.204]                             muffled <- TRUE
[18:04:15.204]                             break
[18:04:15.204]                           }
[18:04:15.204]                         }
[18:04:15.204]                       }
[18:04:15.204]                       invisible(muffled)
[18:04:15.204]                     }
[18:04:15.204]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.204]                   }
[18:04:15.204]                 }
[18:04:15.204]                 else {
[18:04:15.204]                   if (TRUE) {
[18:04:15.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.204]                     {
[18:04:15.204]                       inherits <- base::inherits
[18:04:15.204]                       invokeRestart <- base::invokeRestart
[18:04:15.204]                       is.null <- base::is.null
[18:04:15.204]                       muffled <- FALSE
[18:04:15.204]                       if (inherits(cond, "message")) {
[18:04:15.204]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.204]                         if (muffled) 
[18:04:15.204]                           invokeRestart("muffleMessage")
[18:04:15.204]                       }
[18:04:15.204]                       else if (inherits(cond, "warning")) {
[18:04:15.204]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.204]                         if (muffled) 
[18:04:15.204]                           invokeRestart("muffleWarning")
[18:04:15.204]                       }
[18:04:15.204]                       else if (inherits(cond, "condition")) {
[18:04:15.204]                         if (!is.null(pattern)) {
[18:04:15.204]                           computeRestarts <- base::computeRestarts
[18:04:15.204]                           grepl <- base::grepl
[18:04:15.204]                           restarts <- computeRestarts(cond)
[18:04:15.204]                           for (restart in restarts) {
[18:04:15.204]                             name <- restart$name
[18:04:15.204]                             if (is.null(name)) 
[18:04:15.204]                               next
[18:04:15.204]                             if (!grepl(pattern, name)) 
[18:04:15.204]                               next
[18:04:15.204]                             invokeRestart(restart)
[18:04:15.204]                             muffled <- TRUE
[18:04:15.204]                             break
[18:04:15.204]                           }
[18:04:15.204]                         }
[18:04:15.204]                       }
[18:04:15.204]                       invisible(muffled)
[18:04:15.204]                     }
[18:04:15.204]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.204]                   }
[18:04:15.204]                 }
[18:04:15.204]             }
[18:04:15.204]         }))
[18:04:15.204]     }, error = function(ex) {
[18:04:15.204]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.204]                 ...future.rng), started = ...future.startTime, 
[18:04:15.204]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.204]             version = "1.8"), class = "FutureResult")
[18:04:15.204]     }, finally = {
[18:04:15.204]         if (!identical(...future.workdir, getwd())) 
[18:04:15.204]             setwd(...future.workdir)
[18:04:15.204]         {
[18:04:15.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.204]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.204]             }
[18:04:15.204]             base::options(...future.oldOptions)
[18:04:15.204]             if (.Platform$OS.type == "windows") {
[18:04:15.204]                 old_names <- names(...future.oldEnvVars)
[18:04:15.204]                 envs <- base::Sys.getenv()
[18:04:15.204]                 names <- names(envs)
[18:04:15.204]                 common <- intersect(names, old_names)
[18:04:15.204]                 added <- setdiff(names, old_names)
[18:04:15.204]                 removed <- setdiff(old_names, names)
[18:04:15.204]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.204]                   envs[common]]
[18:04:15.204]                 NAMES <- toupper(changed)
[18:04:15.204]                 args <- list()
[18:04:15.204]                 for (kk in seq_along(NAMES)) {
[18:04:15.204]                   name <- changed[[kk]]
[18:04:15.204]                   NAME <- NAMES[[kk]]
[18:04:15.204]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.204]                     next
[18:04:15.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.204]                 }
[18:04:15.204]                 NAMES <- toupper(added)
[18:04:15.204]                 for (kk in seq_along(NAMES)) {
[18:04:15.204]                   name <- added[[kk]]
[18:04:15.204]                   NAME <- NAMES[[kk]]
[18:04:15.204]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.204]                     next
[18:04:15.204]                   args[[name]] <- ""
[18:04:15.204]                 }
[18:04:15.204]                 NAMES <- toupper(removed)
[18:04:15.204]                 for (kk in seq_along(NAMES)) {
[18:04:15.204]                   name <- removed[[kk]]
[18:04:15.204]                   NAME <- NAMES[[kk]]
[18:04:15.204]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.204]                     next
[18:04:15.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.204]                 }
[18:04:15.204]                 if (length(args) > 0) 
[18:04:15.204]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.204]             }
[18:04:15.204]             else {
[18:04:15.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.204]             }
[18:04:15.204]             {
[18:04:15.204]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.204]                   0L) {
[18:04:15.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.204]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.204]                   base::options(opts)
[18:04:15.204]                 }
[18:04:15.204]                 {
[18:04:15.204]                   {
[18:04:15.204]                     NULL
[18:04:15.204]                     RNGkind("Mersenne-Twister")
[18:04:15.204]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.204]                       inherits = FALSE)
[18:04:15.204]                   }
[18:04:15.204]                   options(future.plan = NULL)
[18:04:15.204]                   if (is.na(NA_character_)) 
[18:04:15.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.204]                     .init = FALSE)
[18:04:15.204]                 }
[18:04:15.204]             }
[18:04:15.204]         }
[18:04:15.204]     })
[18:04:15.204]     if (TRUE) {
[18:04:15.204]         base::sink(type = "output", split = FALSE)
[18:04:15.204]         if (TRUE) {
[18:04:15.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.204]         }
[18:04:15.204]         else {
[18:04:15.204]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.204]         }
[18:04:15.204]         base::close(...future.stdout)
[18:04:15.204]         ...future.stdout <- NULL
[18:04:15.204]     }
[18:04:15.204]     ...future.result$conditions <- ...future.conditions
[18:04:15.204]     ...future.result$finished <- base::Sys.time()
[18:04:15.204]     ...future.result
[18:04:15.204] }
[18:04:15.207] plan(): Setting new future strategy stack:
[18:04:15.208] List of future strategies:
[18:04:15.208] 1. sequential:
[18:04:15.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.208]    - tweaked: FALSE
[18:04:15.208]    - call: NULL
[18:04:15.209] plan(): nbrOfWorkers() = 1
[18:04:15.211] plan(): Setting new future strategy stack:
[18:04:15.211] List of future strategies:
[18:04:15.211] 1. sequential:
[18:04:15.211]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.211]    - tweaked: FALSE
[18:04:15.211]    - call: plan(strategy)
[18:04:15.212] plan(): nbrOfWorkers() = 1
[18:04:15.212] SequentialFuture started (and completed)
[18:04:15.212] - Launch lazy future ... done
[18:04:15.213] run() for ‘SequentialFuture’ ... done
[18:04:15.213] getGlobalsAndPackages() ...
[18:04:15.213] Searching for globals...
[18:04:15.214] 
[18:04:15.214] Searching for globals ... DONE
[18:04:15.214] - globals: [0] <none>
[18:04:15.214] getGlobalsAndPackages() ... DONE
[18:04:15.215] run() for ‘Future’ ...
[18:04:15.215] - state: ‘created’
[18:04:15.216] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.216] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.217]   - Field: ‘label’
[18:04:15.217]   - Field: ‘local’
[18:04:15.217]   - Field: ‘owner’
[18:04:15.217]   - Field: ‘envir’
[18:04:15.217]   - Field: ‘packages’
[18:04:15.218]   - Field: ‘gc’
[18:04:15.218]   - Field: ‘conditions’
[18:04:15.218]   - Field: ‘expr’
[18:04:15.218]   - Field: ‘uuid’
[18:04:15.218]   - Field: ‘seed’
[18:04:15.219]   - Field: ‘version’
[18:04:15.219]   - Field: ‘result’
[18:04:15.219]   - Field: ‘asynchronous’
[18:04:15.219]   - Field: ‘calls’
[18:04:15.219]   - Field: ‘globals’
[18:04:15.220]   - Field: ‘stdout’
[18:04:15.220]   - Field: ‘earlySignal’
[18:04:15.220]   - Field: ‘lazy’
[18:04:15.220]   - Field: ‘state’
[18:04:15.221] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.221] - Launch lazy future ...
[18:04:15.222] Packages needed by the future expression (n = 0): <none>
[18:04:15.222] Packages needed by future strategies (n = 0): <none>
[18:04:15.223] {
[18:04:15.223]     {
[18:04:15.223]         {
[18:04:15.223]             ...future.startTime <- base::Sys.time()
[18:04:15.223]             {
[18:04:15.223]                 {
[18:04:15.223]                   {
[18:04:15.223]                     base::local({
[18:04:15.223]                       has_future <- base::requireNamespace("future", 
[18:04:15.223]                         quietly = TRUE)
[18:04:15.223]                       if (has_future) {
[18:04:15.223]                         ns <- base::getNamespace("future")
[18:04:15.223]                         version <- ns[[".package"]][["version"]]
[18:04:15.223]                         if (is.null(version)) 
[18:04:15.223]                           version <- utils::packageVersion("future")
[18:04:15.223]                       }
[18:04:15.223]                       else {
[18:04:15.223]                         version <- NULL
[18:04:15.223]                       }
[18:04:15.223]                       if (!has_future || version < "1.8.0") {
[18:04:15.223]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.223]                           "", base::R.version$version.string), 
[18:04:15.223]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.223]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.223]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.223]                             "release", "version")], collapse = " "), 
[18:04:15.223]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.223]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.223]                           info)
[18:04:15.223]                         info <- base::paste(info, collapse = "; ")
[18:04:15.223]                         if (!has_future) {
[18:04:15.223]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.223]                             info)
[18:04:15.223]                         }
[18:04:15.223]                         else {
[18:04:15.223]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.223]                             info, version)
[18:04:15.223]                         }
[18:04:15.223]                         base::stop(msg)
[18:04:15.223]                       }
[18:04:15.223]                     })
[18:04:15.223]                   }
[18:04:15.223]                   ...future.strategy.old <- future::plan("list")
[18:04:15.223]                   options(future.plan = NULL)
[18:04:15.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.223]                 }
[18:04:15.223]                 ...future.workdir <- getwd()
[18:04:15.223]             }
[18:04:15.223]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.223]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.223]         }
[18:04:15.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.223]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.223]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.223]             base::names(...future.oldOptions))
[18:04:15.223]     }
[18:04:15.223]     if (FALSE) {
[18:04:15.223]     }
[18:04:15.223]     else {
[18:04:15.223]         if (TRUE) {
[18:04:15.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.223]                 open = "w")
[18:04:15.223]         }
[18:04:15.223]         else {
[18:04:15.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.223]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.223]         }
[18:04:15.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.223]             base::sink(type = "output", split = FALSE)
[18:04:15.223]             base::close(...future.stdout)
[18:04:15.223]         }, add = TRUE)
[18:04:15.223]     }
[18:04:15.223]     ...future.frame <- base::sys.nframe()
[18:04:15.223]     ...future.conditions <- base::list()
[18:04:15.223]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.223]     if (FALSE) {
[18:04:15.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.223]     }
[18:04:15.223]     ...future.result <- base::tryCatch({
[18:04:15.223]         base::withCallingHandlers({
[18:04:15.223]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:15.223]             future::FutureResult(value = ...future.value$value, 
[18:04:15.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.223]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.223]                     ...future.globalenv.names))
[18:04:15.223]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.223]         }, condition = base::local({
[18:04:15.223]             c <- base::c
[18:04:15.223]             inherits <- base::inherits
[18:04:15.223]             invokeRestart <- base::invokeRestart
[18:04:15.223]             length <- base::length
[18:04:15.223]             list <- base::list
[18:04:15.223]             seq.int <- base::seq.int
[18:04:15.223]             signalCondition <- base::signalCondition
[18:04:15.223]             sys.calls <- base::sys.calls
[18:04:15.223]             `[[` <- base::`[[`
[18:04:15.223]             `+` <- base::`+`
[18:04:15.223]             `<<-` <- base::`<<-`
[18:04:15.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.223]                   3L)]
[18:04:15.223]             }
[18:04:15.223]             function(cond) {
[18:04:15.223]                 is_error <- inherits(cond, "error")
[18:04:15.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.223]                   NULL)
[18:04:15.223]                 if (is_error) {
[18:04:15.223]                   sessionInformation <- function() {
[18:04:15.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.223]                       search = base::search(), system = base::Sys.info())
[18:04:15.223]                   }
[18:04:15.223]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.223]                     cond$call), session = sessionInformation(), 
[18:04:15.223]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.223]                   signalCondition(cond)
[18:04:15.223]                 }
[18:04:15.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.223]                 "immediateCondition"))) {
[18:04:15.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.223]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.223]                   if (TRUE && !signal) {
[18:04:15.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.223]                     {
[18:04:15.223]                       inherits <- base::inherits
[18:04:15.223]                       invokeRestart <- base::invokeRestart
[18:04:15.223]                       is.null <- base::is.null
[18:04:15.223]                       muffled <- FALSE
[18:04:15.223]                       if (inherits(cond, "message")) {
[18:04:15.223]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.223]                         if (muffled) 
[18:04:15.223]                           invokeRestart("muffleMessage")
[18:04:15.223]                       }
[18:04:15.223]                       else if (inherits(cond, "warning")) {
[18:04:15.223]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.223]                         if (muffled) 
[18:04:15.223]                           invokeRestart("muffleWarning")
[18:04:15.223]                       }
[18:04:15.223]                       else if (inherits(cond, "condition")) {
[18:04:15.223]                         if (!is.null(pattern)) {
[18:04:15.223]                           computeRestarts <- base::computeRestarts
[18:04:15.223]                           grepl <- base::grepl
[18:04:15.223]                           restarts <- computeRestarts(cond)
[18:04:15.223]                           for (restart in restarts) {
[18:04:15.223]                             name <- restart$name
[18:04:15.223]                             if (is.null(name)) 
[18:04:15.223]                               next
[18:04:15.223]                             if (!grepl(pattern, name)) 
[18:04:15.223]                               next
[18:04:15.223]                             invokeRestart(restart)
[18:04:15.223]                             muffled <- TRUE
[18:04:15.223]                             break
[18:04:15.223]                           }
[18:04:15.223]                         }
[18:04:15.223]                       }
[18:04:15.223]                       invisible(muffled)
[18:04:15.223]                     }
[18:04:15.223]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.223]                   }
[18:04:15.223]                 }
[18:04:15.223]                 else {
[18:04:15.223]                   if (TRUE) {
[18:04:15.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.223]                     {
[18:04:15.223]                       inherits <- base::inherits
[18:04:15.223]                       invokeRestart <- base::invokeRestart
[18:04:15.223]                       is.null <- base::is.null
[18:04:15.223]                       muffled <- FALSE
[18:04:15.223]                       if (inherits(cond, "message")) {
[18:04:15.223]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.223]                         if (muffled) 
[18:04:15.223]                           invokeRestart("muffleMessage")
[18:04:15.223]                       }
[18:04:15.223]                       else if (inherits(cond, "warning")) {
[18:04:15.223]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.223]                         if (muffled) 
[18:04:15.223]                           invokeRestart("muffleWarning")
[18:04:15.223]                       }
[18:04:15.223]                       else if (inherits(cond, "condition")) {
[18:04:15.223]                         if (!is.null(pattern)) {
[18:04:15.223]                           computeRestarts <- base::computeRestarts
[18:04:15.223]                           grepl <- base::grepl
[18:04:15.223]                           restarts <- computeRestarts(cond)
[18:04:15.223]                           for (restart in restarts) {
[18:04:15.223]                             name <- restart$name
[18:04:15.223]                             if (is.null(name)) 
[18:04:15.223]                               next
[18:04:15.223]                             if (!grepl(pattern, name)) 
[18:04:15.223]                               next
[18:04:15.223]                             invokeRestart(restart)
[18:04:15.223]                             muffled <- TRUE
[18:04:15.223]                             break
[18:04:15.223]                           }
[18:04:15.223]                         }
[18:04:15.223]                       }
[18:04:15.223]                       invisible(muffled)
[18:04:15.223]                     }
[18:04:15.223]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.223]                   }
[18:04:15.223]                 }
[18:04:15.223]             }
[18:04:15.223]         }))
[18:04:15.223]     }, error = function(ex) {
[18:04:15.223]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.223]                 ...future.rng), started = ...future.startTime, 
[18:04:15.223]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.223]             version = "1.8"), class = "FutureResult")
[18:04:15.223]     }, finally = {
[18:04:15.223]         if (!identical(...future.workdir, getwd())) 
[18:04:15.223]             setwd(...future.workdir)
[18:04:15.223]         {
[18:04:15.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.223]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.223]             }
[18:04:15.223]             base::options(...future.oldOptions)
[18:04:15.223]             if (.Platform$OS.type == "windows") {
[18:04:15.223]                 old_names <- names(...future.oldEnvVars)
[18:04:15.223]                 envs <- base::Sys.getenv()
[18:04:15.223]                 names <- names(envs)
[18:04:15.223]                 common <- intersect(names, old_names)
[18:04:15.223]                 added <- setdiff(names, old_names)
[18:04:15.223]                 removed <- setdiff(old_names, names)
[18:04:15.223]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.223]                   envs[common]]
[18:04:15.223]                 NAMES <- toupper(changed)
[18:04:15.223]                 args <- list()
[18:04:15.223]                 for (kk in seq_along(NAMES)) {
[18:04:15.223]                   name <- changed[[kk]]
[18:04:15.223]                   NAME <- NAMES[[kk]]
[18:04:15.223]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.223]                     next
[18:04:15.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.223]                 }
[18:04:15.223]                 NAMES <- toupper(added)
[18:04:15.223]                 for (kk in seq_along(NAMES)) {
[18:04:15.223]                   name <- added[[kk]]
[18:04:15.223]                   NAME <- NAMES[[kk]]
[18:04:15.223]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.223]                     next
[18:04:15.223]                   args[[name]] <- ""
[18:04:15.223]                 }
[18:04:15.223]                 NAMES <- toupper(removed)
[18:04:15.223]                 for (kk in seq_along(NAMES)) {
[18:04:15.223]                   name <- removed[[kk]]
[18:04:15.223]                   NAME <- NAMES[[kk]]
[18:04:15.223]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.223]                     next
[18:04:15.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.223]                 }
[18:04:15.223]                 if (length(args) > 0) 
[18:04:15.223]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.223]             }
[18:04:15.223]             else {
[18:04:15.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.223]             }
[18:04:15.223]             {
[18:04:15.223]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.223]                   0L) {
[18:04:15.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.223]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.223]                   base::options(opts)
[18:04:15.223]                 }
[18:04:15.223]                 {
[18:04:15.223]                   {
[18:04:15.223]                     NULL
[18:04:15.223]                     RNGkind("Mersenne-Twister")
[18:04:15.223]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.223]                       inherits = FALSE)
[18:04:15.223]                   }
[18:04:15.223]                   options(future.plan = NULL)
[18:04:15.223]                   if (is.na(NA_character_)) 
[18:04:15.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.223]                     .init = FALSE)
[18:04:15.223]                 }
[18:04:15.223]             }
[18:04:15.223]         }
[18:04:15.223]     })
[18:04:15.223]     if (TRUE) {
[18:04:15.223]         base::sink(type = "output", split = FALSE)
[18:04:15.223]         if (TRUE) {
[18:04:15.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.223]         }
[18:04:15.223]         else {
[18:04:15.223]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.223]         }
[18:04:15.223]         base::close(...future.stdout)
[18:04:15.223]         ...future.stdout <- NULL
[18:04:15.223]     }
[18:04:15.223]     ...future.result$conditions <- ...future.conditions
[18:04:15.223]     ...future.result$finished <- base::Sys.time()
[18:04:15.223]     ...future.result
[18:04:15.223] }
[18:04:15.226] plan(): Setting new future strategy stack:
[18:04:15.227] List of future strategies:
[18:04:15.227] 1. sequential:
[18:04:15.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.227]    - tweaked: FALSE
[18:04:15.227]    - call: NULL
[18:04:15.228] plan(): nbrOfWorkers() = 1
[18:04:15.229] plan(): Setting new future strategy stack:
[18:04:15.230] List of future strategies:
[18:04:15.230] 1. sequential:
[18:04:15.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.230]    - tweaked: FALSE
[18:04:15.230]    - call: plan(strategy)
[18:04:15.231] plan(): nbrOfWorkers() = 1
[18:04:15.231] SequentialFuture started (and completed)
[18:04:15.231] - Launch lazy future ... done
[18:04:15.231] run() for ‘SequentialFuture’ ... done
[18:04:15.232] getGlobalsAndPackages() ...
[18:04:15.232] Searching for globals...
[18:04:15.234] - globals found: [1] ‘{’
[18:04:15.234] Searching for globals ... DONE
[18:04:15.234] Resolving globals: FALSE
[18:04:15.235] 
[18:04:15.235] 
[18:04:15.235] getGlobalsAndPackages() ... DONE
[18:04:15.236] run() for ‘Future’ ...
[18:04:15.236] - state: ‘created’
[18:04:15.236] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.237] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.237] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.237]   - Field: ‘label’
[18:04:15.237]   - Field: ‘local’
[18:04:15.237]   - Field: ‘owner’
[18:04:15.238]   - Field: ‘envir’
[18:04:15.238]   - Field: ‘packages’
[18:04:15.238]   - Field: ‘gc’
[18:04:15.238]   - Field: ‘conditions’
[18:04:15.238]   - Field: ‘expr’
[18:04:15.239]   - Field: ‘uuid’
[18:04:15.239]   - Field: ‘seed’
[18:04:15.239]   - Field: ‘version’
[18:04:15.239]   - Field: ‘result’
[18:04:15.239]   - Field: ‘asynchronous’
[18:04:15.240]   - Field: ‘calls’
[18:04:15.240]   - Field: ‘globals’
[18:04:15.240]   - Field: ‘stdout’
[18:04:15.240]   - Field: ‘earlySignal’
[18:04:15.240]   - Field: ‘lazy’
[18:04:15.241]   - Field: ‘state’
[18:04:15.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.241] - Launch lazy future ...
[18:04:15.241] Packages needed by the future expression (n = 0): <none>
[18:04:15.242] Packages needed by future strategies (n = 0): <none>
[18:04:15.243] {
[18:04:15.243]     {
[18:04:15.243]         {
[18:04:15.243]             ...future.startTime <- base::Sys.time()
[18:04:15.243]             {
[18:04:15.243]                 {
[18:04:15.243]                   {
[18:04:15.243]                     base::local({
[18:04:15.243]                       has_future <- base::requireNamespace("future", 
[18:04:15.243]                         quietly = TRUE)
[18:04:15.243]                       if (has_future) {
[18:04:15.243]                         ns <- base::getNamespace("future")
[18:04:15.243]                         version <- ns[[".package"]][["version"]]
[18:04:15.243]                         if (is.null(version)) 
[18:04:15.243]                           version <- utils::packageVersion("future")
[18:04:15.243]                       }
[18:04:15.243]                       else {
[18:04:15.243]                         version <- NULL
[18:04:15.243]                       }
[18:04:15.243]                       if (!has_future || version < "1.8.0") {
[18:04:15.243]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.243]                           "", base::R.version$version.string), 
[18:04:15.243]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.243]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.243]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.243]                             "release", "version")], collapse = " "), 
[18:04:15.243]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.243]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.243]                           info)
[18:04:15.243]                         info <- base::paste(info, collapse = "; ")
[18:04:15.243]                         if (!has_future) {
[18:04:15.243]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.243]                             info)
[18:04:15.243]                         }
[18:04:15.243]                         else {
[18:04:15.243]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.243]                             info, version)
[18:04:15.243]                         }
[18:04:15.243]                         base::stop(msg)
[18:04:15.243]                       }
[18:04:15.243]                     })
[18:04:15.243]                   }
[18:04:15.243]                   ...future.strategy.old <- future::plan("list")
[18:04:15.243]                   options(future.plan = NULL)
[18:04:15.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.243]                 }
[18:04:15.243]                 ...future.workdir <- getwd()
[18:04:15.243]             }
[18:04:15.243]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.243]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.243]         }
[18:04:15.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.243]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.243]             base::names(...future.oldOptions))
[18:04:15.243]     }
[18:04:15.243]     if (FALSE) {
[18:04:15.243]     }
[18:04:15.243]     else {
[18:04:15.243]         if (TRUE) {
[18:04:15.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.243]                 open = "w")
[18:04:15.243]         }
[18:04:15.243]         else {
[18:04:15.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.243]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.243]         }
[18:04:15.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.243]             base::sink(type = "output", split = FALSE)
[18:04:15.243]             base::close(...future.stdout)
[18:04:15.243]         }, add = TRUE)
[18:04:15.243]     }
[18:04:15.243]     ...future.frame <- base::sys.nframe()
[18:04:15.243]     ...future.conditions <- base::list()
[18:04:15.243]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.243]     if (FALSE) {
[18:04:15.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.243]     }
[18:04:15.243]     ...future.result <- base::tryCatch({
[18:04:15.243]         base::withCallingHandlers({
[18:04:15.243]             ...future.value <- base::withVisible(base::local({
[18:04:15.243]                 4
[18:04:15.243]             }))
[18:04:15.243]             future::FutureResult(value = ...future.value$value, 
[18:04:15.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.243]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.243]                     ...future.globalenv.names))
[18:04:15.243]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.243]         }, condition = base::local({
[18:04:15.243]             c <- base::c
[18:04:15.243]             inherits <- base::inherits
[18:04:15.243]             invokeRestart <- base::invokeRestart
[18:04:15.243]             length <- base::length
[18:04:15.243]             list <- base::list
[18:04:15.243]             seq.int <- base::seq.int
[18:04:15.243]             signalCondition <- base::signalCondition
[18:04:15.243]             sys.calls <- base::sys.calls
[18:04:15.243]             `[[` <- base::`[[`
[18:04:15.243]             `+` <- base::`+`
[18:04:15.243]             `<<-` <- base::`<<-`
[18:04:15.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.243]                   3L)]
[18:04:15.243]             }
[18:04:15.243]             function(cond) {
[18:04:15.243]                 is_error <- inherits(cond, "error")
[18:04:15.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.243]                   NULL)
[18:04:15.243]                 if (is_error) {
[18:04:15.243]                   sessionInformation <- function() {
[18:04:15.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.243]                       search = base::search(), system = base::Sys.info())
[18:04:15.243]                   }
[18:04:15.243]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.243]                     cond$call), session = sessionInformation(), 
[18:04:15.243]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.243]                   signalCondition(cond)
[18:04:15.243]                 }
[18:04:15.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.243]                 "immediateCondition"))) {
[18:04:15.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.243]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.243]                   if (TRUE && !signal) {
[18:04:15.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.243]                     {
[18:04:15.243]                       inherits <- base::inherits
[18:04:15.243]                       invokeRestart <- base::invokeRestart
[18:04:15.243]                       is.null <- base::is.null
[18:04:15.243]                       muffled <- FALSE
[18:04:15.243]                       if (inherits(cond, "message")) {
[18:04:15.243]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.243]                         if (muffled) 
[18:04:15.243]                           invokeRestart("muffleMessage")
[18:04:15.243]                       }
[18:04:15.243]                       else if (inherits(cond, "warning")) {
[18:04:15.243]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.243]                         if (muffled) 
[18:04:15.243]                           invokeRestart("muffleWarning")
[18:04:15.243]                       }
[18:04:15.243]                       else if (inherits(cond, "condition")) {
[18:04:15.243]                         if (!is.null(pattern)) {
[18:04:15.243]                           computeRestarts <- base::computeRestarts
[18:04:15.243]                           grepl <- base::grepl
[18:04:15.243]                           restarts <- computeRestarts(cond)
[18:04:15.243]                           for (restart in restarts) {
[18:04:15.243]                             name <- restart$name
[18:04:15.243]                             if (is.null(name)) 
[18:04:15.243]                               next
[18:04:15.243]                             if (!grepl(pattern, name)) 
[18:04:15.243]                               next
[18:04:15.243]                             invokeRestart(restart)
[18:04:15.243]                             muffled <- TRUE
[18:04:15.243]                             break
[18:04:15.243]                           }
[18:04:15.243]                         }
[18:04:15.243]                       }
[18:04:15.243]                       invisible(muffled)
[18:04:15.243]                     }
[18:04:15.243]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.243]                   }
[18:04:15.243]                 }
[18:04:15.243]                 else {
[18:04:15.243]                   if (TRUE) {
[18:04:15.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.243]                     {
[18:04:15.243]                       inherits <- base::inherits
[18:04:15.243]                       invokeRestart <- base::invokeRestart
[18:04:15.243]                       is.null <- base::is.null
[18:04:15.243]                       muffled <- FALSE
[18:04:15.243]                       if (inherits(cond, "message")) {
[18:04:15.243]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.243]                         if (muffled) 
[18:04:15.243]                           invokeRestart("muffleMessage")
[18:04:15.243]                       }
[18:04:15.243]                       else if (inherits(cond, "warning")) {
[18:04:15.243]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.243]                         if (muffled) 
[18:04:15.243]                           invokeRestart("muffleWarning")
[18:04:15.243]                       }
[18:04:15.243]                       else if (inherits(cond, "condition")) {
[18:04:15.243]                         if (!is.null(pattern)) {
[18:04:15.243]                           computeRestarts <- base::computeRestarts
[18:04:15.243]                           grepl <- base::grepl
[18:04:15.243]                           restarts <- computeRestarts(cond)
[18:04:15.243]                           for (restart in restarts) {
[18:04:15.243]                             name <- restart$name
[18:04:15.243]                             if (is.null(name)) 
[18:04:15.243]                               next
[18:04:15.243]                             if (!grepl(pattern, name)) 
[18:04:15.243]                               next
[18:04:15.243]                             invokeRestart(restart)
[18:04:15.243]                             muffled <- TRUE
[18:04:15.243]                             break
[18:04:15.243]                           }
[18:04:15.243]                         }
[18:04:15.243]                       }
[18:04:15.243]                       invisible(muffled)
[18:04:15.243]                     }
[18:04:15.243]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.243]                   }
[18:04:15.243]                 }
[18:04:15.243]             }
[18:04:15.243]         }))
[18:04:15.243]     }, error = function(ex) {
[18:04:15.243]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.243]                 ...future.rng), started = ...future.startTime, 
[18:04:15.243]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.243]             version = "1.8"), class = "FutureResult")
[18:04:15.243]     }, finally = {
[18:04:15.243]         if (!identical(...future.workdir, getwd())) 
[18:04:15.243]             setwd(...future.workdir)
[18:04:15.243]         {
[18:04:15.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.243]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.243]             }
[18:04:15.243]             base::options(...future.oldOptions)
[18:04:15.243]             if (.Platform$OS.type == "windows") {
[18:04:15.243]                 old_names <- names(...future.oldEnvVars)
[18:04:15.243]                 envs <- base::Sys.getenv()
[18:04:15.243]                 names <- names(envs)
[18:04:15.243]                 common <- intersect(names, old_names)
[18:04:15.243]                 added <- setdiff(names, old_names)
[18:04:15.243]                 removed <- setdiff(old_names, names)
[18:04:15.243]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.243]                   envs[common]]
[18:04:15.243]                 NAMES <- toupper(changed)
[18:04:15.243]                 args <- list()
[18:04:15.243]                 for (kk in seq_along(NAMES)) {
[18:04:15.243]                   name <- changed[[kk]]
[18:04:15.243]                   NAME <- NAMES[[kk]]
[18:04:15.243]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.243]                     next
[18:04:15.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.243]                 }
[18:04:15.243]                 NAMES <- toupper(added)
[18:04:15.243]                 for (kk in seq_along(NAMES)) {
[18:04:15.243]                   name <- added[[kk]]
[18:04:15.243]                   NAME <- NAMES[[kk]]
[18:04:15.243]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.243]                     next
[18:04:15.243]                   args[[name]] <- ""
[18:04:15.243]                 }
[18:04:15.243]                 NAMES <- toupper(removed)
[18:04:15.243]                 for (kk in seq_along(NAMES)) {
[18:04:15.243]                   name <- removed[[kk]]
[18:04:15.243]                   NAME <- NAMES[[kk]]
[18:04:15.243]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.243]                     next
[18:04:15.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.243]                 }
[18:04:15.243]                 if (length(args) > 0) 
[18:04:15.243]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.243]             }
[18:04:15.243]             else {
[18:04:15.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.243]             }
[18:04:15.243]             {
[18:04:15.243]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.243]                   0L) {
[18:04:15.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.243]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.243]                   base::options(opts)
[18:04:15.243]                 }
[18:04:15.243]                 {
[18:04:15.243]                   {
[18:04:15.243]                     NULL
[18:04:15.243]                     RNGkind("Mersenne-Twister")
[18:04:15.243]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.243]                       inherits = FALSE)
[18:04:15.243]                   }
[18:04:15.243]                   options(future.plan = NULL)
[18:04:15.243]                   if (is.na(NA_character_)) 
[18:04:15.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.243]                     .init = FALSE)
[18:04:15.243]                 }
[18:04:15.243]             }
[18:04:15.243]         }
[18:04:15.243]     })
[18:04:15.243]     if (TRUE) {
[18:04:15.243]         base::sink(type = "output", split = FALSE)
[18:04:15.243]         if (TRUE) {
[18:04:15.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.243]         }
[18:04:15.243]         else {
[18:04:15.243]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.243]         }
[18:04:15.243]         base::close(...future.stdout)
[18:04:15.243]         ...future.stdout <- NULL
[18:04:15.243]     }
[18:04:15.243]     ...future.result$conditions <- ...future.conditions
[18:04:15.243]     ...future.result$finished <- base::Sys.time()
[18:04:15.243]     ...future.result
[18:04:15.243] }
[18:04:15.246] plan(): Setting new future strategy stack:
[18:04:15.246] List of future strategies:
[18:04:15.246] 1. sequential:
[18:04:15.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.246]    - tweaked: FALSE
[18:04:15.246]    - call: NULL
[18:04:15.247] plan(): nbrOfWorkers() = 1
[18:04:15.249] plan(): Setting new future strategy stack:
[18:04:15.249] List of future strategies:
[18:04:15.249] 1. sequential:
[18:04:15.249]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.249]    - tweaked: FALSE
[18:04:15.249]    - call: plan(strategy)
[18:04:15.252] plan(): nbrOfWorkers() = 1
[18:04:15.252] SequentialFuture started (and completed)
[18:04:15.253] - Launch lazy future ... done
[18:04:15.253] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c28de6600> 
Classes 'listenv', 'environment' <environment: 0x5e3c2a595758> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[18:04:15.260] resolved() for ‘SequentialFuture’ ...
[18:04:15.261] - state: ‘finished’
[18:04:15.261] - run: TRUE
[18:04:15.261] - result: ‘FutureResult’
[18:04:15.261] resolved() for ‘SequentialFuture’ ... done
[18:04:15.262] resolved() for ‘SequentialFuture’ ...
[18:04:15.262] - state: ‘finished’
[18:04:15.262] - run: TRUE
[18:04:15.262] - result: ‘FutureResult’
[18:04:15.262] resolved() for ‘SequentialFuture’ ... done
[18:04:15.263] resolved() for ‘SequentialFuture’ ...
[18:04:15.263] - state: ‘finished’
[18:04:15.263] - run: TRUE
[18:04:15.263] - result: ‘FutureResult’
[18:04:15.263] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:15.268] resolve() on list environment ...
[18:04:15.268]  recursive: 0
[18:04:15.271]  length: 6
[18:04:15.271]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:15.271] signalConditionsASAP(numeric, pos=1) ...
[18:04:15.272] - nx: 6
[18:04:15.272] - relay: TRUE
[18:04:15.272] - stdout: TRUE
[18:04:15.272] - signal: TRUE
[18:04:15.272] - resignal: FALSE
[18:04:15.273] - force: TRUE
[18:04:15.273] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.273] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.273]  - until=2
[18:04:15.273]  - relaying element #2
[18:04:15.274] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.274] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.274] signalConditionsASAP(NULL, pos=1) ... done
[18:04:15.274]  length: 5 (resolved future 1)
[18:04:15.274] resolved() for ‘SequentialFuture’ ...
[18:04:15.275] - state: ‘finished’
[18:04:15.275] - run: TRUE
[18:04:15.275] - result: ‘FutureResult’
[18:04:15.275] resolved() for ‘SequentialFuture’ ... done
[18:04:15.275] Future #2
[18:04:15.276] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:15.276] - nx: 6
[18:04:15.276] - relay: TRUE
[18:04:15.276] - stdout: TRUE
[18:04:15.276] - signal: TRUE
[18:04:15.277] - resignal: FALSE
[18:04:15.277] - force: TRUE
[18:04:15.277] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.277] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.277]  - until=2
[18:04:15.277]  - relaying element #2
[18:04:15.278] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.278] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.278] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:15.279]  length: 4 (resolved future 2)
[18:04:15.279] resolved() for ‘SequentialFuture’ ...
[18:04:15.279] - state: ‘finished’
[18:04:15.279] - run: TRUE
[18:04:15.279] - result: ‘FutureResult’
[18:04:15.280] resolved() for ‘SequentialFuture’ ... done
[18:04:15.280] Future #3
[18:04:15.280] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:15.280] - nx: 6
[18:04:15.280] - relay: TRUE
[18:04:15.281] - stdout: TRUE
[18:04:15.281] - signal: TRUE
[18:04:15.281] - resignal: FALSE
[18:04:15.281] - force: TRUE
[18:04:15.281] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.281] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.282]  - until=3
[18:04:15.282]  - relaying element #3
[18:04:15.282] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.282] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.283] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:15.283]  length: 3 (resolved future 3)
[18:04:15.283] resolved() for ‘SequentialFuture’ ...
[18:04:15.283] - state: ‘finished’
[18:04:15.284] - run: TRUE
[18:04:15.284] - result: ‘FutureResult’
[18:04:15.284] resolved() for ‘SequentialFuture’ ... done
[18:04:15.284] Future #4
[18:04:15.284] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:15.285] - nx: 6
[18:04:15.285] - relay: TRUE
[18:04:15.285] - stdout: TRUE
[18:04:15.285] - signal: TRUE
[18:04:15.285] - resignal: FALSE
[18:04:15.286] - force: TRUE
[18:04:15.286] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.286] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.286]  - until=4
[18:04:15.286]  - relaying element #4
[18:04:15.287] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.287] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.287] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:15.287]  length: 2 (resolved future 4)
[18:04:15.288] signalConditionsASAP(NULL, pos=5) ...
[18:04:15.288] - nx: 6
[18:04:15.288] - relay: TRUE
[18:04:15.288] - stdout: TRUE
[18:04:15.288] - signal: TRUE
[18:04:15.288] - resignal: FALSE
[18:04:15.289] - force: TRUE
[18:04:15.289] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.289] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.289]  - until=6
[18:04:15.289]  - relaying element #6
[18:04:15.290] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.290] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.290] signalConditionsASAP(NULL, pos=5) ... done
[18:04:15.290]  length: 1 (resolved future 5)
[18:04:15.290] signalConditionsASAP(numeric, pos=6) ...
[18:04:15.291] - nx: 6
[18:04:15.291] - relay: TRUE
[18:04:15.291] - stdout: TRUE
[18:04:15.291] - signal: TRUE
[18:04:15.291] - resignal: FALSE
[18:04:15.291] - force: TRUE
[18:04:15.292] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.292] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.292]  - until=6
[18:04:15.292] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.292] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.293] signalConditionsASAP(numeric, pos=6) ... done
[18:04:15.293]  length: 0 (resolved future 6)
[18:04:15.293] Relaying remaining futures
[18:04:15.293] signalConditionsASAP(NULL, pos=0) ...
[18:04:15.293] - nx: 6
[18:04:15.293] - relay: TRUE
[18:04:15.294] - stdout: TRUE
[18:04:15.294] - signal: TRUE
[18:04:15.294] - resignal: FALSE
[18:04:15.294] - force: TRUE
[18:04:15.294] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.294] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:15.295] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.295] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.295] signalConditionsASAP(NULL, pos=0) ... done
[18:04:15.295] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5e3c29a05538> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[18:04:15.299] getGlobalsAndPackages() ...
[18:04:15.299] Searching for globals...
[18:04:15.300] 
[18:04:15.300] Searching for globals ... DONE
[18:04:15.300] - globals: [0] <none>
[18:04:15.301] getGlobalsAndPackages() ... DONE
[18:04:15.301] run() for ‘Future’ ...
[18:04:15.301] - state: ‘created’
[18:04:15.302] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.302] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.302]   - Field: ‘label’
[18:04:15.303]   - Field: ‘local’
[18:04:15.303]   - Field: ‘owner’
[18:04:15.303]   - Field: ‘envir’
[18:04:15.303]   - Field: ‘packages’
[18:04:15.303]   - Field: ‘gc’
[18:04:15.304]   - Field: ‘conditions’
[18:04:15.304]   - Field: ‘expr’
[18:04:15.304]   - Field: ‘uuid’
[18:04:15.304]   - Field: ‘seed’
[18:04:15.304]   - Field: ‘version’
[18:04:15.307]   - Field: ‘result’
[18:04:15.307]   - Field: ‘asynchronous’
[18:04:15.307]   - Field: ‘calls’
[18:04:15.307]   - Field: ‘globals’
[18:04:15.308]   - Field: ‘stdout’
[18:04:15.308]   - Field: ‘earlySignal’
[18:04:15.308]   - Field: ‘lazy’
[18:04:15.308]   - Field: ‘state’
[18:04:15.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.309] - Launch lazy future ...
[18:04:15.309] Packages needed by the future expression (n = 0): <none>
[18:04:15.309] Packages needed by future strategies (n = 0): <none>
[18:04:15.310] {
[18:04:15.310]     {
[18:04:15.310]         {
[18:04:15.310]             ...future.startTime <- base::Sys.time()
[18:04:15.310]             {
[18:04:15.310]                 {
[18:04:15.310]                   {
[18:04:15.310]                     base::local({
[18:04:15.310]                       has_future <- base::requireNamespace("future", 
[18:04:15.310]                         quietly = TRUE)
[18:04:15.310]                       if (has_future) {
[18:04:15.310]                         ns <- base::getNamespace("future")
[18:04:15.310]                         version <- ns[[".package"]][["version"]]
[18:04:15.310]                         if (is.null(version)) 
[18:04:15.310]                           version <- utils::packageVersion("future")
[18:04:15.310]                       }
[18:04:15.310]                       else {
[18:04:15.310]                         version <- NULL
[18:04:15.310]                       }
[18:04:15.310]                       if (!has_future || version < "1.8.0") {
[18:04:15.310]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.310]                           "", base::R.version$version.string), 
[18:04:15.310]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.310]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.310]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.310]                             "release", "version")], collapse = " "), 
[18:04:15.310]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.310]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.310]                           info)
[18:04:15.310]                         info <- base::paste(info, collapse = "; ")
[18:04:15.310]                         if (!has_future) {
[18:04:15.310]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.310]                             info)
[18:04:15.310]                         }
[18:04:15.310]                         else {
[18:04:15.310]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.310]                             info, version)
[18:04:15.310]                         }
[18:04:15.310]                         base::stop(msg)
[18:04:15.310]                       }
[18:04:15.310]                     })
[18:04:15.310]                   }
[18:04:15.310]                   ...future.strategy.old <- future::plan("list")
[18:04:15.310]                   options(future.plan = NULL)
[18:04:15.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.310]                 }
[18:04:15.310]                 ...future.workdir <- getwd()
[18:04:15.310]             }
[18:04:15.310]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.310]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.310]         }
[18:04:15.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.310]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.310]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.310]             base::names(...future.oldOptions))
[18:04:15.310]     }
[18:04:15.310]     if (FALSE) {
[18:04:15.310]     }
[18:04:15.310]     else {
[18:04:15.310]         if (TRUE) {
[18:04:15.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.310]                 open = "w")
[18:04:15.310]         }
[18:04:15.310]         else {
[18:04:15.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.310]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.310]         }
[18:04:15.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.310]             base::sink(type = "output", split = FALSE)
[18:04:15.310]             base::close(...future.stdout)
[18:04:15.310]         }, add = TRUE)
[18:04:15.310]     }
[18:04:15.310]     ...future.frame <- base::sys.nframe()
[18:04:15.310]     ...future.conditions <- base::list()
[18:04:15.310]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.310]     if (FALSE) {
[18:04:15.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.310]     }
[18:04:15.310]     ...future.result <- base::tryCatch({
[18:04:15.310]         base::withCallingHandlers({
[18:04:15.310]             ...future.value <- base::withVisible(base::local(2))
[18:04:15.310]             future::FutureResult(value = ...future.value$value, 
[18:04:15.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.310]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.310]                     ...future.globalenv.names))
[18:04:15.310]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.310]         }, condition = base::local({
[18:04:15.310]             c <- base::c
[18:04:15.310]             inherits <- base::inherits
[18:04:15.310]             invokeRestart <- base::invokeRestart
[18:04:15.310]             length <- base::length
[18:04:15.310]             list <- base::list
[18:04:15.310]             seq.int <- base::seq.int
[18:04:15.310]             signalCondition <- base::signalCondition
[18:04:15.310]             sys.calls <- base::sys.calls
[18:04:15.310]             `[[` <- base::`[[`
[18:04:15.310]             `+` <- base::`+`
[18:04:15.310]             `<<-` <- base::`<<-`
[18:04:15.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.310]                   3L)]
[18:04:15.310]             }
[18:04:15.310]             function(cond) {
[18:04:15.310]                 is_error <- inherits(cond, "error")
[18:04:15.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.310]                   NULL)
[18:04:15.310]                 if (is_error) {
[18:04:15.310]                   sessionInformation <- function() {
[18:04:15.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.310]                       search = base::search(), system = base::Sys.info())
[18:04:15.310]                   }
[18:04:15.310]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.310]                     cond$call), session = sessionInformation(), 
[18:04:15.310]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.310]                   signalCondition(cond)
[18:04:15.310]                 }
[18:04:15.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.310]                 "immediateCondition"))) {
[18:04:15.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.310]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.310]                   if (TRUE && !signal) {
[18:04:15.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.310]                     {
[18:04:15.310]                       inherits <- base::inherits
[18:04:15.310]                       invokeRestart <- base::invokeRestart
[18:04:15.310]                       is.null <- base::is.null
[18:04:15.310]                       muffled <- FALSE
[18:04:15.310]                       if (inherits(cond, "message")) {
[18:04:15.310]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.310]                         if (muffled) 
[18:04:15.310]                           invokeRestart("muffleMessage")
[18:04:15.310]                       }
[18:04:15.310]                       else if (inherits(cond, "warning")) {
[18:04:15.310]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.310]                         if (muffled) 
[18:04:15.310]                           invokeRestart("muffleWarning")
[18:04:15.310]                       }
[18:04:15.310]                       else if (inherits(cond, "condition")) {
[18:04:15.310]                         if (!is.null(pattern)) {
[18:04:15.310]                           computeRestarts <- base::computeRestarts
[18:04:15.310]                           grepl <- base::grepl
[18:04:15.310]                           restarts <- computeRestarts(cond)
[18:04:15.310]                           for (restart in restarts) {
[18:04:15.310]                             name <- restart$name
[18:04:15.310]                             if (is.null(name)) 
[18:04:15.310]                               next
[18:04:15.310]                             if (!grepl(pattern, name)) 
[18:04:15.310]                               next
[18:04:15.310]                             invokeRestart(restart)
[18:04:15.310]                             muffled <- TRUE
[18:04:15.310]                             break
[18:04:15.310]                           }
[18:04:15.310]                         }
[18:04:15.310]                       }
[18:04:15.310]                       invisible(muffled)
[18:04:15.310]                     }
[18:04:15.310]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.310]                   }
[18:04:15.310]                 }
[18:04:15.310]                 else {
[18:04:15.310]                   if (TRUE) {
[18:04:15.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.310]                     {
[18:04:15.310]                       inherits <- base::inherits
[18:04:15.310]                       invokeRestart <- base::invokeRestart
[18:04:15.310]                       is.null <- base::is.null
[18:04:15.310]                       muffled <- FALSE
[18:04:15.310]                       if (inherits(cond, "message")) {
[18:04:15.310]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.310]                         if (muffled) 
[18:04:15.310]                           invokeRestart("muffleMessage")
[18:04:15.310]                       }
[18:04:15.310]                       else if (inherits(cond, "warning")) {
[18:04:15.310]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.310]                         if (muffled) 
[18:04:15.310]                           invokeRestart("muffleWarning")
[18:04:15.310]                       }
[18:04:15.310]                       else if (inherits(cond, "condition")) {
[18:04:15.310]                         if (!is.null(pattern)) {
[18:04:15.310]                           computeRestarts <- base::computeRestarts
[18:04:15.310]                           grepl <- base::grepl
[18:04:15.310]                           restarts <- computeRestarts(cond)
[18:04:15.310]                           for (restart in restarts) {
[18:04:15.310]                             name <- restart$name
[18:04:15.310]                             if (is.null(name)) 
[18:04:15.310]                               next
[18:04:15.310]                             if (!grepl(pattern, name)) 
[18:04:15.310]                               next
[18:04:15.310]                             invokeRestart(restart)
[18:04:15.310]                             muffled <- TRUE
[18:04:15.310]                             break
[18:04:15.310]                           }
[18:04:15.310]                         }
[18:04:15.310]                       }
[18:04:15.310]                       invisible(muffled)
[18:04:15.310]                     }
[18:04:15.310]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.310]                   }
[18:04:15.310]                 }
[18:04:15.310]             }
[18:04:15.310]         }))
[18:04:15.310]     }, error = function(ex) {
[18:04:15.310]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.310]                 ...future.rng), started = ...future.startTime, 
[18:04:15.310]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.310]             version = "1.8"), class = "FutureResult")
[18:04:15.310]     }, finally = {
[18:04:15.310]         if (!identical(...future.workdir, getwd())) 
[18:04:15.310]             setwd(...future.workdir)
[18:04:15.310]         {
[18:04:15.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.310]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.310]             }
[18:04:15.310]             base::options(...future.oldOptions)
[18:04:15.310]             if (.Platform$OS.type == "windows") {
[18:04:15.310]                 old_names <- names(...future.oldEnvVars)
[18:04:15.310]                 envs <- base::Sys.getenv()
[18:04:15.310]                 names <- names(envs)
[18:04:15.310]                 common <- intersect(names, old_names)
[18:04:15.310]                 added <- setdiff(names, old_names)
[18:04:15.310]                 removed <- setdiff(old_names, names)
[18:04:15.310]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.310]                   envs[common]]
[18:04:15.310]                 NAMES <- toupper(changed)
[18:04:15.310]                 args <- list()
[18:04:15.310]                 for (kk in seq_along(NAMES)) {
[18:04:15.310]                   name <- changed[[kk]]
[18:04:15.310]                   NAME <- NAMES[[kk]]
[18:04:15.310]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.310]                     next
[18:04:15.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.310]                 }
[18:04:15.310]                 NAMES <- toupper(added)
[18:04:15.310]                 for (kk in seq_along(NAMES)) {
[18:04:15.310]                   name <- added[[kk]]
[18:04:15.310]                   NAME <- NAMES[[kk]]
[18:04:15.310]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.310]                     next
[18:04:15.310]                   args[[name]] <- ""
[18:04:15.310]                 }
[18:04:15.310]                 NAMES <- toupper(removed)
[18:04:15.310]                 for (kk in seq_along(NAMES)) {
[18:04:15.310]                   name <- removed[[kk]]
[18:04:15.310]                   NAME <- NAMES[[kk]]
[18:04:15.310]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.310]                     next
[18:04:15.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.310]                 }
[18:04:15.310]                 if (length(args) > 0) 
[18:04:15.310]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.310]             }
[18:04:15.310]             else {
[18:04:15.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.310]             }
[18:04:15.310]             {
[18:04:15.310]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.310]                   0L) {
[18:04:15.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.310]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.310]                   base::options(opts)
[18:04:15.310]                 }
[18:04:15.310]                 {
[18:04:15.310]                   {
[18:04:15.310]                     NULL
[18:04:15.310]                     RNGkind("Mersenne-Twister")
[18:04:15.310]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.310]                       inherits = FALSE)
[18:04:15.310]                   }
[18:04:15.310]                   options(future.plan = NULL)
[18:04:15.310]                   if (is.na(NA_character_)) 
[18:04:15.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.310]                     .init = FALSE)
[18:04:15.310]                 }
[18:04:15.310]             }
[18:04:15.310]         }
[18:04:15.310]     })
[18:04:15.310]     if (TRUE) {
[18:04:15.310]         base::sink(type = "output", split = FALSE)
[18:04:15.310]         if (TRUE) {
[18:04:15.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.310]         }
[18:04:15.310]         else {
[18:04:15.310]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.310]         }
[18:04:15.310]         base::close(...future.stdout)
[18:04:15.310]         ...future.stdout <- NULL
[18:04:15.310]     }
[18:04:15.310]     ...future.result$conditions <- ...future.conditions
[18:04:15.310]     ...future.result$finished <- base::Sys.time()
[18:04:15.310]     ...future.result
[18:04:15.310] }
[18:04:15.314] plan(): Setting new future strategy stack:
[18:04:15.314] List of future strategies:
[18:04:15.314] 1. sequential:
[18:04:15.314]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.314]    - tweaked: FALSE
[18:04:15.314]    - call: NULL
[18:04:15.315] plan(): nbrOfWorkers() = 1
[18:04:15.316] plan(): Setting new future strategy stack:
[18:04:15.316] List of future strategies:
[18:04:15.316] 1. sequential:
[18:04:15.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.316]    - tweaked: FALSE
[18:04:15.316]    - call: plan(strategy)
[18:04:15.317] plan(): nbrOfWorkers() = 1
[18:04:15.318] SequentialFuture started (and completed)
[18:04:15.318] - Launch lazy future ... done
[18:04:15.318] run() for ‘SequentialFuture’ ... done
[18:04:15.318] getGlobalsAndPackages() ...
[18:04:15.318] Searching for globals...
[18:04:15.319] 
[18:04:15.319] Searching for globals ... DONE
[18:04:15.319] - globals: [0] <none>
[18:04:15.320] getGlobalsAndPackages() ... DONE
[18:04:15.320] run() for ‘Future’ ...
[18:04:15.320] - state: ‘created’
[18:04:15.321] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.321] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.321] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.321]   - Field: ‘label’
[18:04:15.322]   - Field: ‘local’
[18:04:15.322]   - Field: ‘owner’
[18:04:15.322]   - Field: ‘envir’
[18:04:15.322]   - Field: ‘packages’
[18:04:15.322]   - Field: ‘gc’
[18:04:15.323]   - Field: ‘conditions’
[18:04:15.323]   - Field: ‘expr’
[18:04:15.323]   - Field: ‘uuid’
[18:04:15.323]   - Field: ‘seed’
[18:04:15.323]   - Field: ‘version’
[18:04:15.324]   - Field: ‘result’
[18:04:15.324]   - Field: ‘asynchronous’
[18:04:15.324]   - Field: ‘calls’
[18:04:15.324]   - Field: ‘globals’
[18:04:15.324]   - Field: ‘stdout’
[18:04:15.325]   - Field: ‘earlySignal’
[18:04:15.325]   - Field: ‘lazy’
[18:04:15.325]   - Field: ‘state’
[18:04:15.325] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.325] - Launch lazy future ...
[18:04:15.326] Packages needed by the future expression (n = 0): <none>
[18:04:15.326] Packages needed by future strategies (n = 0): <none>
[18:04:15.327] {
[18:04:15.327]     {
[18:04:15.327]         {
[18:04:15.327]             ...future.startTime <- base::Sys.time()
[18:04:15.327]             {
[18:04:15.327]                 {
[18:04:15.327]                   {
[18:04:15.327]                     base::local({
[18:04:15.327]                       has_future <- base::requireNamespace("future", 
[18:04:15.327]                         quietly = TRUE)
[18:04:15.327]                       if (has_future) {
[18:04:15.327]                         ns <- base::getNamespace("future")
[18:04:15.327]                         version <- ns[[".package"]][["version"]]
[18:04:15.327]                         if (is.null(version)) 
[18:04:15.327]                           version <- utils::packageVersion("future")
[18:04:15.327]                       }
[18:04:15.327]                       else {
[18:04:15.327]                         version <- NULL
[18:04:15.327]                       }
[18:04:15.327]                       if (!has_future || version < "1.8.0") {
[18:04:15.327]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.327]                           "", base::R.version$version.string), 
[18:04:15.327]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.327]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.327]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.327]                             "release", "version")], collapse = " "), 
[18:04:15.327]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.327]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.327]                           info)
[18:04:15.327]                         info <- base::paste(info, collapse = "; ")
[18:04:15.327]                         if (!has_future) {
[18:04:15.327]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.327]                             info)
[18:04:15.327]                         }
[18:04:15.327]                         else {
[18:04:15.327]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.327]                             info, version)
[18:04:15.327]                         }
[18:04:15.327]                         base::stop(msg)
[18:04:15.327]                       }
[18:04:15.327]                     })
[18:04:15.327]                   }
[18:04:15.327]                   ...future.strategy.old <- future::plan("list")
[18:04:15.327]                   options(future.plan = NULL)
[18:04:15.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.327]                 }
[18:04:15.327]                 ...future.workdir <- getwd()
[18:04:15.327]             }
[18:04:15.327]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.327]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.327]         }
[18:04:15.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.327]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.327]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.327]             base::names(...future.oldOptions))
[18:04:15.327]     }
[18:04:15.327]     if (FALSE) {
[18:04:15.327]     }
[18:04:15.327]     else {
[18:04:15.327]         if (TRUE) {
[18:04:15.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.327]                 open = "w")
[18:04:15.327]         }
[18:04:15.327]         else {
[18:04:15.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.327]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.327]         }
[18:04:15.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.327]             base::sink(type = "output", split = FALSE)
[18:04:15.327]             base::close(...future.stdout)
[18:04:15.327]         }, add = TRUE)
[18:04:15.327]     }
[18:04:15.327]     ...future.frame <- base::sys.nframe()
[18:04:15.327]     ...future.conditions <- base::list()
[18:04:15.327]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.327]     if (FALSE) {
[18:04:15.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.327]     }
[18:04:15.327]     ...future.result <- base::tryCatch({
[18:04:15.327]         base::withCallingHandlers({
[18:04:15.327]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:15.327]             future::FutureResult(value = ...future.value$value, 
[18:04:15.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.327]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.327]                     ...future.globalenv.names))
[18:04:15.327]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.327]         }, condition = base::local({
[18:04:15.327]             c <- base::c
[18:04:15.327]             inherits <- base::inherits
[18:04:15.327]             invokeRestart <- base::invokeRestart
[18:04:15.327]             length <- base::length
[18:04:15.327]             list <- base::list
[18:04:15.327]             seq.int <- base::seq.int
[18:04:15.327]             signalCondition <- base::signalCondition
[18:04:15.327]             sys.calls <- base::sys.calls
[18:04:15.327]             `[[` <- base::`[[`
[18:04:15.327]             `+` <- base::`+`
[18:04:15.327]             `<<-` <- base::`<<-`
[18:04:15.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.327]                   3L)]
[18:04:15.327]             }
[18:04:15.327]             function(cond) {
[18:04:15.327]                 is_error <- inherits(cond, "error")
[18:04:15.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.327]                   NULL)
[18:04:15.327]                 if (is_error) {
[18:04:15.327]                   sessionInformation <- function() {
[18:04:15.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.327]                       search = base::search(), system = base::Sys.info())
[18:04:15.327]                   }
[18:04:15.327]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.327]                     cond$call), session = sessionInformation(), 
[18:04:15.327]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.327]                   signalCondition(cond)
[18:04:15.327]                 }
[18:04:15.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.327]                 "immediateCondition"))) {
[18:04:15.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.327]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.327]                   if (TRUE && !signal) {
[18:04:15.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.327]                     {
[18:04:15.327]                       inherits <- base::inherits
[18:04:15.327]                       invokeRestart <- base::invokeRestart
[18:04:15.327]                       is.null <- base::is.null
[18:04:15.327]                       muffled <- FALSE
[18:04:15.327]                       if (inherits(cond, "message")) {
[18:04:15.327]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.327]                         if (muffled) 
[18:04:15.327]                           invokeRestart("muffleMessage")
[18:04:15.327]                       }
[18:04:15.327]                       else if (inherits(cond, "warning")) {
[18:04:15.327]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.327]                         if (muffled) 
[18:04:15.327]                           invokeRestart("muffleWarning")
[18:04:15.327]                       }
[18:04:15.327]                       else if (inherits(cond, "condition")) {
[18:04:15.327]                         if (!is.null(pattern)) {
[18:04:15.327]                           computeRestarts <- base::computeRestarts
[18:04:15.327]                           grepl <- base::grepl
[18:04:15.327]                           restarts <- computeRestarts(cond)
[18:04:15.327]                           for (restart in restarts) {
[18:04:15.327]                             name <- restart$name
[18:04:15.327]                             if (is.null(name)) 
[18:04:15.327]                               next
[18:04:15.327]                             if (!grepl(pattern, name)) 
[18:04:15.327]                               next
[18:04:15.327]                             invokeRestart(restart)
[18:04:15.327]                             muffled <- TRUE
[18:04:15.327]                             break
[18:04:15.327]                           }
[18:04:15.327]                         }
[18:04:15.327]                       }
[18:04:15.327]                       invisible(muffled)
[18:04:15.327]                     }
[18:04:15.327]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.327]                   }
[18:04:15.327]                 }
[18:04:15.327]                 else {
[18:04:15.327]                   if (TRUE) {
[18:04:15.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.327]                     {
[18:04:15.327]                       inherits <- base::inherits
[18:04:15.327]                       invokeRestart <- base::invokeRestart
[18:04:15.327]                       is.null <- base::is.null
[18:04:15.327]                       muffled <- FALSE
[18:04:15.327]                       if (inherits(cond, "message")) {
[18:04:15.327]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.327]                         if (muffled) 
[18:04:15.327]                           invokeRestart("muffleMessage")
[18:04:15.327]                       }
[18:04:15.327]                       else if (inherits(cond, "warning")) {
[18:04:15.327]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.327]                         if (muffled) 
[18:04:15.327]                           invokeRestart("muffleWarning")
[18:04:15.327]                       }
[18:04:15.327]                       else if (inherits(cond, "condition")) {
[18:04:15.327]                         if (!is.null(pattern)) {
[18:04:15.327]                           computeRestarts <- base::computeRestarts
[18:04:15.327]                           grepl <- base::grepl
[18:04:15.327]                           restarts <- computeRestarts(cond)
[18:04:15.327]                           for (restart in restarts) {
[18:04:15.327]                             name <- restart$name
[18:04:15.327]                             if (is.null(name)) 
[18:04:15.327]                               next
[18:04:15.327]                             if (!grepl(pattern, name)) 
[18:04:15.327]                               next
[18:04:15.327]                             invokeRestart(restart)
[18:04:15.327]                             muffled <- TRUE
[18:04:15.327]                             break
[18:04:15.327]                           }
[18:04:15.327]                         }
[18:04:15.327]                       }
[18:04:15.327]                       invisible(muffled)
[18:04:15.327]                     }
[18:04:15.327]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.327]                   }
[18:04:15.327]                 }
[18:04:15.327]             }
[18:04:15.327]         }))
[18:04:15.327]     }, error = function(ex) {
[18:04:15.327]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.327]                 ...future.rng), started = ...future.startTime, 
[18:04:15.327]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.327]             version = "1.8"), class = "FutureResult")
[18:04:15.327]     }, finally = {
[18:04:15.327]         if (!identical(...future.workdir, getwd())) 
[18:04:15.327]             setwd(...future.workdir)
[18:04:15.327]         {
[18:04:15.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.327]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.327]             }
[18:04:15.327]             base::options(...future.oldOptions)
[18:04:15.327]             if (.Platform$OS.type == "windows") {
[18:04:15.327]                 old_names <- names(...future.oldEnvVars)
[18:04:15.327]                 envs <- base::Sys.getenv()
[18:04:15.327]                 names <- names(envs)
[18:04:15.327]                 common <- intersect(names, old_names)
[18:04:15.327]                 added <- setdiff(names, old_names)
[18:04:15.327]                 removed <- setdiff(old_names, names)
[18:04:15.327]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.327]                   envs[common]]
[18:04:15.327]                 NAMES <- toupper(changed)
[18:04:15.327]                 args <- list()
[18:04:15.327]                 for (kk in seq_along(NAMES)) {
[18:04:15.327]                   name <- changed[[kk]]
[18:04:15.327]                   NAME <- NAMES[[kk]]
[18:04:15.327]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.327]                     next
[18:04:15.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.327]                 }
[18:04:15.327]                 NAMES <- toupper(added)
[18:04:15.327]                 for (kk in seq_along(NAMES)) {
[18:04:15.327]                   name <- added[[kk]]
[18:04:15.327]                   NAME <- NAMES[[kk]]
[18:04:15.327]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.327]                     next
[18:04:15.327]                   args[[name]] <- ""
[18:04:15.327]                 }
[18:04:15.327]                 NAMES <- toupper(removed)
[18:04:15.327]                 for (kk in seq_along(NAMES)) {
[18:04:15.327]                   name <- removed[[kk]]
[18:04:15.327]                   NAME <- NAMES[[kk]]
[18:04:15.327]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.327]                     next
[18:04:15.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.327]                 }
[18:04:15.327]                 if (length(args) > 0) 
[18:04:15.327]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.327]             }
[18:04:15.327]             else {
[18:04:15.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.327]             }
[18:04:15.327]             {
[18:04:15.327]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.327]                   0L) {
[18:04:15.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.327]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.327]                   base::options(opts)
[18:04:15.327]                 }
[18:04:15.327]                 {
[18:04:15.327]                   {
[18:04:15.327]                     NULL
[18:04:15.327]                     RNGkind("Mersenne-Twister")
[18:04:15.327]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.327]                       inherits = FALSE)
[18:04:15.327]                   }
[18:04:15.327]                   options(future.plan = NULL)
[18:04:15.327]                   if (is.na(NA_character_)) 
[18:04:15.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.327]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.327]                     .init = FALSE)
[18:04:15.327]                 }
[18:04:15.327]             }
[18:04:15.327]         }
[18:04:15.327]     })
[18:04:15.327]     if (TRUE) {
[18:04:15.327]         base::sink(type = "output", split = FALSE)
[18:04:15.327]         if (TRUE) {
[18:04:15.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.327]         }
[18:04:15.327]         else {
[18:04:15.327]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.327]         }
[18:04:15.327]         base::close(...future.stdout)
[18:04:15.327]         ...future.stdout <- NULL
[18:04:15.327]     }
[18:04:15.327]     ...future.result$conditions <- ...future.conditions
[18:04:15.327]     ...future.result$finished <- base::Sys.time()
[18:04:15.327]     ...future.result
[18:04:15.327] }
[18:04:15.330] plan(): Setting new future strategy stack:
[18:04:15.330] List of future strategies:
[18:04:15.330] 1. sequential:
[18:04:15.330]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.330]    - tweaked: FALSE
[18:04:15.330]    - call: NULL
[18:04:15.331] plan(): nbrOfWorkers() = 1
[18:04:15.333] plan(): Setting new future strategy stack:
[18:04:15.333] List of future strategies:
[18:04:15.333] 1. sequential:
[18:04:15.333]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.333]    - tweaked: FALSE
[18:04:15.333]    - call: plan(strategy)
[18:04:15.334] plan(): nbrOfWorkers() = 1
[18:04:15.334] SequentialFuture started (and completed)
[18:04:15.334] - Launch lazy future ... done
[18:04:15.335] run() for ‘SequentialFuture’ ... done
[18:04:15.335] getGlobalsAndPackages() ...
[18:04:15.335] Searching for globals...
[18:04:15.337] - globals found: [1] ‘{’
[18:04:15.337] Searching for globals ... DONE
[18:04:15.337] Resolving globals: FALSE
[18:04:15.338] 
[18:04:15.338] 
[18:04:15.338] getGlobalsAndPackages() ... DONE
[18:04:15.338] run() for ‘Future’ ...
[18:04:15.339] - state: ‘created’
[18:04:15.339] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.339] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.340] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.341]   - Field: ‘label’
[18:04:15.342]   - Field: ‘local’
[18:04:15.342]   - Field: ‘owner’
[18:04:15.343]   - Field: ‘envir’
[18:04:15.343]   - Field: ‘packages’
[18:04:15.343]   - Field: ‘gc’
[18:04:15.343]   - Field: ‘conditions’
[18:04:15.343]   - Field: ‘expr’
[18:04:15.344]   - Field: ‘uuid’
[18:04:15.344]   - Field: ‘seed’
[18:04:15.344]   - Field: ‘version’
[18:04:15.344]   - Field: ‘result’
[18:04:15.345]   - Field: ‘asynchronous’
[18:04:15.345]   - Field: ‘calls’
[18:04:15.345]   - Field: ‘globals’
[18:04:15.345]   - Field: ‘stdout’
[18:04:15.345]   - Field: ‘earlySignal’
[18:04:15.346]   - Field: ‘lazy’
[18:04:15.346]   - Field: ‘state’
[18:04:15.346] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.346] - Launch lazy future ...
[18:04:15.347] Packages needed by the future expression (n = 0): <none>
[18:04:15.347] Packages needed by future strategies (n = 0): <none>
[18:04:15.348] {
[18:04:15.348]     {
[18:04:15.348]         {
[18:04:15.348]             ...future.startTime <- base::Sys.time()
[18:04:15.348]             {
[18:04:15.348]                 {
[18:04:15.348]                   {
[18:04:15.348]                     base::local({
[18:04:15.348]                       has_future <- base::requireNamespace("future", 
[18:04:15.348]                         quietly = TRUE)
[18:04:15.348]                       if (has_future) {
[18:04:15.348]                         ns <- base::getNamespace("future")
[18:04:15.348]                         version <- ns[[".package"]][["version"]]
[18:04:15.348]                         if (is.null(version)) 
[18:04:15.348]                           version <- utils::packageVersion("future")
[18:04:15.348]                       }
[18:04:15.348]                       else {
[18:04:15.348]                         version <- NULL
[18:04:15.348]                       }
[18:04:15.348]                       if (!has_future || version < "1.8.0") {
[18:04:15.348]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.348]                           "", base::R.version$version.string), 
[18:04:15.348]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.348]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.348]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.348]                             "release", "version")], collapse = " "), 
[18:04:15.348]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.348]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.348]                           info)
[18:04:15.348]                         info <- base::paste(info, collapse = "; ")
[18:04:15.348]                         if (!has_future) {
[18:04:15.348]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.348]                             info)
[18:04:15.348]                         }
[18:04:15.348]                         else {
[18:04:15.348]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.348]                             info, version)
[18:04:15.348]                         }
[18:04:15.348]                         base::stop(msg)
[18:04:15.348]                       }
[18:04:15.348]                     })
[18:04:15.348]                   }
[18:04:15.348]                   ...future.strategy.old <- future::plan("list")
[18:04:15.348]                   options(future.plan = NULL)
[18:04:15.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.348]                 }
[18:04:15.348]                 ...future.workdir <- getwd()
[18:04:15.348]             }
[18:04:15.348]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.348]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.348]         }
[18:04:15.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.348]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.348]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.348]             base::names(...future.oldOptions))
[18:04:15.348]     }
[18:04:15.348]     if (FALSE) {
[18:04:15.348]     }
[18:04:15.348]     else {
[18:04:15.348]         if (TRUE) {
[18:04:15.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.348]                 open = "w")
[18:04:15.348]         }
[18:04:15.348]         else {
[18:04:15.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.348]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.348]         }
[18:04:15.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.348]             base::sink(type = "output", split = FALSE)
[18:04:15.348]             base::close(...future.stdout)
[18:04:15.348]         }, add = TRUE)
[18:04:15.348]     }
[18:04:15.348]     ...future.frame <- base::sys.nframe()
[18:04:15.348]     ...future.conditions <- base::list()
[18:04:15.348]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.348]     if (FALSE) {
[18:04:15.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.348]     }
[18:04:15.348]     ...future.result <- base::tryCatch({
[18:04:15.348]         base::withCallingHandlers({
[18:04:15.348]             ...future.value <- base::withVisible(base::local({
[18:04:15.348]                 4
[18:04:15.348]             }))
[18:04:15.348]             future::FutureResult(value = ...future.value$value, 
[18:04:15.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.348]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.348]                     ...future.globalenv.names))
[18:04:15.348]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.348]         }, condition = base::local({
[18:04:15.348]             c <- base::c
[18:04:15.348]             inherits <- base::inherits
[18:04:15.348]             invokeRestart <- base::invokeRestart
[18:04:15.348]             length <- base::length
[18:04:15.348]             list <- base::list
[18:04:15.348]             seq.int <- base::seq.int
[18:04:15.348]             signalCondition <- base::signalCondition
[18:04:15.348]             sys.calls <- base::sys.calls
[18:04:15.348]             `[[` <- base::`[[`
[18:04:15.348]             `+` <- base::`+`
[18:04:15.348]             `<<-` <- base::`<<-`
[18:04:15.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.348]                   3L)]
[18:04:15.348]             }
[18:04:15.348]             function(cond) {
[18:04:15.348]                 is_error <- inherits(cond, "error")
[18:04:15.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.348]                   NULL)
[18:04:15.348]                 if (is_error) {
[18:04:15.348]                   sessionInformation <- function() {
[18:04:15.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.348]                       search = base::search(), system = base::Sys.info())
[18:04:15.348]                   }
[18:04:15.348]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.348]                     cond$call), session = sessionInformation(), 
[18:04:15.348]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.348]                   signalCondition(cond)
[18:04:15.348]                 }
[18:04:15.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.348]                 "immediateCondition"))) {
[18:04:15.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.348]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.348]                   if (TRUE && !signal) {
[18:04:15.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.348]                     {
[18:04:15.348]                       inherits <- base::inherits
[18:04:15.348]                       invokeRestart <- base::invokeRestart
[18:04:15.348]                       is.null <- base::is.null
[18:04:15.348]                       muffled <- FALSE
[18:04:15.348]                       if (inherits(cond, "message")) {
[18:04:15.348]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.348]                         if (muffled) 
[18:04:15.348]                           invokeRestart("muffleMessage")
[18:04:15.348]                       }
[18:04:15.348]                       else if (inherits(cond, "warning")) {
[18:04:15.348]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.348]                         if (muffled) 
[18:04:15.348]                           invokeRestart("muffleWarning")
[18:04:15.348]                       }
[18:04:15.348]                       else if (inherits(cond, "condition")) {
[18:04:15.348]                         if (!is.null(pattern)) {
[18:04:15.348]                           computeRestarts <- base::computeRestarts
[18:04:15.348]                           grepl <- base::grepl
[18:04:15.348]                           restarts <- computeRestarts(cond)
[18:04:15.348]                           for (restart in restarts) {
[18:04:15.348]                             name <- restart$name
[18:04:15.348]                             if (is.null(name)) 
[18:04:15.348]                               next
[18:04:15.348]                             if (!grepl(pattern, name)) 
[18:04:15.348]                               next
[18:04:15.348]                             invokeRestart(restart)
[18:04:15.348]                             muffled <- TRUE
[18:04:15.348]                             break
[18:04:15.348]                           }
[18:04:15.348]                         }
[18:04:15.348]                       }
[18:04:15.348]                       invisible(muffled)
[18:04:15.348]                     }
[18:04:15.348]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.348]                   }
[18:04:15.348]                 }
[18:04:15.348]                 else {
[18:04:15.348]                   if (TRUE) {
[18:04:15.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.348]                     {
[18:04:15.348]                       inherits <- base::inherits
[18:04:15.348]                       invokeRestart <- base::invokeRestart
[18:04:15.348]                       is.null <- base::is.null
[18:04:15.348]                       muffled <- FALSE
[18:04:15.348]                       if (inherits(cond, "message")) {
[18:04:15.348]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.348]                         if (muffled) 
[18:04:15.348]                           invokeRestart("muffleMessage")
[18:04:15.348]                       }
[18:04:15.348]                       else if (inherits(cond, "warning")) {
[18:04:15.348]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.348]                         if (muffled) 
[18:04:15.348]                           invokeRestart("muffleWarning")
[18:04:15.348]                       }
[18:04:15.348]                       else if (inherits(cond, "condition")) {
[18:04:15.348]                         if (!is.null(pattern)) {
[18:04:15.348]                           computeRestarts <- base::computeRestarts
[18:04:15.348]                           grepl <- base::grepl
[18:04:15.348]                           restarts <- computeRestarts(cond)
[18:04:15.348]                           for (restart in restarts) {
[18:04:15.348]                             name <- restart$name
[18:04:15.348]                             if (is.null(name)) 
[18:04:15.348]                               next
[18:04:15.348]                             if (!grepl(pattern, name)) 
[18:04:15.348]                               next
[18:04:15.348]                             invokeRestart(restart)
[18:04:15.348]                             muffled <- TRUE
[18:04:15.348]                             break
[18:04:15.348]                           }
[18:04:15.348]                         }
[18:04:15.348]                       }
[18:04:15.348]                       invisible(muffled)
[18:04:15.348]                     }
[18:04:15.348]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.348]                   }
[18:04:15.348]                 }
[18:04:15.348]             }
[18:04:15.348]         }))
[18:04:15.348]     }, error = function(ex) {
[18:04:15.348]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.348]                 ...future.rng), started = ...future.startTime, 
[18:04:15.348]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.348]             version = "1.8"), class = "FutureResult")
[18:04:15.348]     }, finally = {
[18:04:15.348]         if (!identical(...future.workdir, getwd())) 
[18:04:15.348]             setwd(...future.workdir)
[18:04:15.348]         {
[18:04:15.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.348]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.348]             }
[18:04:15.348]             base::options(...future.oldOptions)
[18:04:15.348]             if (.Platform$OS.type == "windows") {
[18:04:15.348]                 old_names <- names(...future.oldEnvVars)
[18:04:15.348]                 envs <- base::Sys.getenv()
[18:04:15.348]                 names <- names(envs)
[18:04:15.348]                 common <- intersect(names, old_names)
[18:04:15.348]                 added <- setdiff(names, old_names)
[18:04:15.348]                 removed <- setdiff(old_names, names)
[18:04:15.348]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.348]                   envs[common]]
[18:04:15.348]                 NAMES <- toupper(changed)
[18:04:15.348]                 args <- list()
[18:04:15.348]                 for (kk in seq_along(NAMES)) {
[18:04:15.348]                   name <- changed[[kk]]
[18:04:15.348]                   NAME <- NAMES[[kk]]
[18:04:15.348]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.348]                     next
[18:04:15.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.348]                 }
[18:04:15.348]                 NAMES <- toupper(added)
[18:04:15.348]                 for (kk in seq_along(NAMES)) {
[18:04:15.348]                   name <- added[[kk]]
[18:04:15.348]                   NAME <- NAMES[[kk]]
[18:04:15.348]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.348]                     next
[18:04:15.348]                   args[[name]] <- ""
[18:04:15.348]                 }
[18:04:15.348]                 NAMES <- toupper(removed)
[18:04:15.348]                 for (kk in seq_along(NAMES)) {
[18:04:15.348]                   name <- removed[[kk]]
[18:04:15.348]                   NAME <- NAMES[[kk]]
[18:04:15.348]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.348]                     next
[18:04:15.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.348]                 }
[18:04:15.348]                 if (length(args) > 0) 
[18:04:15.348]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.348]             }
[18:04:15.348]             else {
[18:04:15.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.348]             }
[18:04:15.348]             {
[18:04:15.348]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.348]                   0L) {
[18:04:15.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.348]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.348]                   base::options(opts)
[18:04:15.348]                 }
[18:04:15.348]                 {
[18:04:15.348]                   {
[18:04:15.348]                     NULL
[18:04:15.348]                     RNGkind("Mersenne-Twister")
[18:04:15.348]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.348]                       inherits = FALSE)
[18:04:15.348]                   }
[18:04:15.348]                   options(future.plan = NULL)
[18:04:15.348]                   if (is.na(NA_character_)) 
[18:04:15.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.348]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.348]                     .init = FALSE)
[18:04:15.348]                 }
[18:04:15.348]             }
[18:04:15.348]         }
[18:04:15.348]     })
[18:04:15.348]     if (TRUE) {
[18:04:15.348]         base::sink(type = "output", split = FALSE)
[18:04:15.348]         if (TRUE) {
[18:04:15.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.348]         }
[18:04:15.348]         else {
[18:04:15.348]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.348]         }
[18:04:15.348]         base::close(...future.stdout)
[18:04:15.348]         ...future.stdout <- NULL
[18:04:15.348]     }
[18:04:15.348]     ...future.result$conditions <- ...future.conditions
[18:04:15.348]     ...future.result$finished <- base::Sys.time()
[18:04:15.348]     ...future.result
[18:04:15.348] }
[18:04:15.351] plan(): Setting new future strategy stack:
[18:04:15.351] List of future strategies:
[18:04:15.351] 1. sequential:
[18:04:15.351]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.351]    - tweaked: FALSE
[18:04:15.351]    - call: NULL
[18:04:15.352] plan(): nbrOfWorkers() = 1
[18:04:15.354] plan(): Setting new future strategy stack:
[18:04:15.354] List of future strategies:
[18:04:15.354] 1. sequential:
[18:04:15.354]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.354]    - tweaked: FALSE
[18:04:15.354]    - call: plan(strategy)
[18:04:15.355] plan(): nbrOfWorkers() = 1
[18:04:15.355] SequentialFuture started (and completed)
[18:04:15.355] - Launch lazy future ... done
[18:04:15.356] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2b632300> 
Classes 'listenv', 'environment' <environment: 0x5e3c2b316ea0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[18:04:15.363] resolved() for ‘SequentialFuture’ ...
[18:04:15.363] - state: ‘finished’
[18:04:15.364] - run: TRUE
[18:04:15.364] - result: ‘FutureResult’
[18:04:15.364] resolved() for ‘SequentialFuture’ ... done
[18:04:15.364] resolved() for ‘SequentialFuture’ ...
[18:04:15.364] - state: ‘finished’
[18:04:15.365] - run: TRUE
[18:04:15.365] - result: ‘FutureResult’
[18:04:15.365] resolved() for ‘SequentialFuture’ ... done
[18:04:15.365] resolved() for ‘SequentialFuture’ ...
[18:04:15.365] - state: ‘finished’
[18:04:15.366] - run: TRUE
[18:04:15.366] - result: ‘FutureResult’
[18:04:15.366] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:15.374] resolve() on list environment ...
[18:04:15.375]  recursive: 0
[18:04:15.377]  length: 6
[18:04:15.377]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:15.377] signalConditionsASAP(numeric, pos=1) ...
[18:04:15.378] - nx: 6
[18:04:15.378] - relay: TRUE
[18:04:15.378] - stdout: TRUE
[18:04:15.378] - signal: TRUE
[18:04:15.378] - resignal: FALSE
[18:04:15.379] - force: TRUE
[18:04:15.379] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.379] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.379]  - until=2
[18:04:15.379]  - relaying element #2
[18:04:15.380] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.380] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.380] signalConditionsASAP(NULL, pos=1) ... done
[18:04:15.380]  length: 5 (resolved future 1)
[18:04:15.380] resolved() for ‘SequentialFuture’ ...
[18:04:15.381] - state: ‘finished’
[18:04:15.381] - run: TRUE
[18:04:15.381] - result: ‘FutureResult’
[18:04:15.381] resolved() for ‘SequentialFuture’ ... done
[18:04:15.381] Future #2
[18:04:15.382] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:15.382] - nx: 6
[18:04:15.382] - relay: TRUE
[18:04:15.382] - stdout: TRUE
[18:04:15.382] - signal: TRUE
[18:04:15.383] - resignal: FALSE
[18:04:15.383] - force: TRUE
[18:04:15.383] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.383] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.383]  - until=2
[18:04:15.383]  - relaying element #2
[18:04:15.384] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.384] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.384] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:15.384]  length: 4 (resolved future 2)
[18:04:15.385] resolved() for ‘SequentialFuture’ ...
[18:04:15.385] - state: ‘finished’
[18:04:15.385] - run: TRUE
[18:04:15.385] - result: ‘FutureResult’
[18:04:15.385] resolved() for ‘SequentialFuture’ ... done
[18:04:15.386] Future #3
[18:04:15.386] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:15.386] - nx: 6
[18:04:15.386] - relay: TRUE
[18:04:15.387] - stdout: TRUE
[18:04:15.387] - signal: TRUE
[18:04:15.387] - resignal: FALSE
[18:04:15.387] - force: TRUE
[18:04:15.387] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.387] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.388]  - until=3
[18:04:15.388]  - relaying element #3
[18:04:15.388] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.388] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.389] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:15.389]  length: 3 (resolved future 3)
[18:04:15.389] resolved() for ‘SequentialFuture’ ...
[18:04:15.389] - state: ‘finished’
[18:04:15.389] - run: TRUE
[18:04:15.390] - result: ‘FutureResult’
[18:04:15.390] resolved() for ‘SequentialFuture’ ... done
[18:04:15.390] Future #4
[18:04:15.390] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:15.390] - nx: 6
[18:04:15.391] - relay: TRUE
[18:04:15.391] - stdout: TRUE
[18:04:15.391] - signal: TRUE
[18:04:15.391] - resignal: FALSE
[18:04:15.391] - force: TRUE
[18:04:15.391] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.392] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.392]  - until=4
[18:04:15.392]  - relaying element #4
[18:04:15.392] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.393] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.393] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:15.393]  length: 2 (resolved future 4)
[18:04:15.393] signalConditionsASAP(NULL, pos=5) ...
[18:04:15.393] - nx: 6
[18:04:15.394] - relay: TRUE
[18:04:15.394] - stdout: TRUE
[18:04:15.394] - signal: TRUE
[18:04:15.394] - resignal: FALSE
[18:04:15.394] - force: TRUE
[18:04:15.394] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.395] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.395]  - until=6
[18:04:15.395]  - relaying element #6
[18:04:15.395] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.395] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.396] signalConditionsASAP(NULL, pos=5) ... done
[18:04:15.396]  length: 1 (resolved future 5)
[18:04:15.396] signalConditionsASAP(numeric, pos=6) ...
[18:04:15.396] - nx: 6
[18:04:15.396] - relay: TRUE
[18:04:15.397] - stdout: TRUE
[18:04:15.397] - signal: TRUE
[18:04:15.397] - resignal: FALSE
[18:04:15.397] - force: TRUE
[18:04:15.397] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.397] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.398]  - until=6
[18:04:15.398] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.398] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.398] signalConditionsASAP(numeric, pos=6) ... done
[18:04:15.398]  length: 0 (resolved future 6)
[18:04:15.399] Relaying remaining futures
[18:04:15.399] signalConditionsASAP(NULL, pos=0) ...
[18:04:15.399] - nx: 6
[18:04:15.399] - relay: TRUE
[18:04:15.399] - stdout: TRUE
[18:04:15.399] - signal: TRUE
[18:04:15.400] - resignal: FALSE
[18:04:15.400] - force: TRUE
[18:04:15.400] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.400] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:15.400] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.401] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.401] signalConditionsASAP(NULL, pos=0) ... done
[18:04:15.401] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5e3c2ba07038> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[18:04:15.405] getGlobalsAndPackages() ...
[18:04:15.406] Searching for globals...
[18:04:15.406] 
[18:04:15.407] Searching for globals ... DONE
[18:04:15.407] - globals: [0] <none>
[18:04:15.407] getGlobalsAndPackages() ... DONE
[18:04:15.407] run() for ‘Future’ ...
[18:04:15.408] - state: ‘created’
[18:04:15.408] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.409] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.409]   - Field: ‘label’
[18:04:15.409]   - Field: ‘local’
[18:04:15.409]   - Field: ‘owner’
[18:04:15.409]   - Field: ‘envir’
[18:04:15.410]   - Field: ‘packages’
[18:04:15.410]   - Field: ‘gc’
[18:04:15.410]   - Field: ‘conditions’
[18:04:15.410]   - Field: ‘expr’
[18:04:15.410]   - Field: ‘uuid’
[18:04:15.411]   - Field: ‘seed’
[18:04:15.411]   - Field: ‘version’
[18:04:15.411]   - Field: ‘result’
[18:04:15.411]   - Field: ‘asynchronous’
[18:04:15.411]   - Field: ‘calls’
[18:04:15.412]   - Field: ‘globals’
[18:04:15.412]   - Field: ‘stdout’
[18:04:15.412]   - Field: ‘earlySignal’
[18:04:15.412]   - Field: ‘lazy’
[18:04:15.412]   - Field: ‘state’
[18:04:15.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.413] - Launch lazy future ...
[18:04:15.413] Packages needed by the future expression (n = 0): <none>
[18:04:15.413] Packages needed by future strategies (n = 0): <none>
[18:04:15.414] {
[18:04:15.414]     {
[18:04:15.414]         {
[18:04:15.414]             ...future.startTime <- base::Sys.time()
[18:04:15.414]             {
[18:04:15.414]                 {
[18:04:15.414]                   {
[18:04:15.414]                     base::local({
[18:04:15.414]                       has_future <- base::requireNamespace("future", 
[18:04:15.414]                         quietly = TRUE)
[18:04:15.414]                       if (has_future) {
[18:04:15.414]                         ns <- base::getNamespace("future")
[18:04:15.414]                         version <- ns[[".package"]][["version"]]
[18:04:15.414]                         if (is.null(version)) 
[18:04:15.414]                           version <- utils::packageVersion("future")
[18:04:15.414]                       }
[18:04:15.414]                       else {
[18:04:15.414]                         version <- NULL
[18:04:15.414]                       }
[18:04:15.414]                       if (!has_future || version < "1.8.0") {
[18:04:15.414]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.414]                           "", base::R.version$version.string), 
[18:04:15.414]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.414]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.414]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.414]                             "release", "version")], collapse = " "), 
[18:04:15.414]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.414]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.414]                           info)
[18:04:15.414]                         info <- base::paste(info, collapse = "; ")
[18:04:15.414]                         if (!has_future) {
[18:04:15.414]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.414]                             info)
[18:04:15.414]                         }
[18:04:15.414]                         else {
[18:04:15.414]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.414]                             info, version)
[18:04:15.414]                         }
[18:04:15.414]                         base::stop(msg)
[18:04:15.414]                       }
[18:04:15.414]                     })
[18:04:15.414]                   }
[18:04:15.414]                   ...future.strategy.old <- future::plan("list")
[18:04:15.414]                   options(future.plan = NULL)
[18:04:15.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.414]                 }
[18:04:15.414]                 ...future.workdir <- getwd()
[18:04:15.414]             }
[18:04:15.414]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.414]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.414]         }
[18:04:15.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.414]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.414]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.414]             base::names(...future.oldOptions))
[18:04:15.414]     }
[18:04:15.414]     if (FALSE) {
[18:04:15.414]     }
[18:04:15.414]     else {
[18:04:15.414]         if (TRUE) {
[18:04:15.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.414]                 open = "w")
[18:04:15.414]         }
[18:04:15.414]         else {
[18:04:15.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.414]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.414]         }
[18:04:15.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.414]             base::sink(type = "output", split = FALSE)
[18:04:15.414]             base::close(...future.stdout)
[18:04:15.414]         }, add = TRUE)
[18:04:15.414]     }
[18:04:15.414]     ...future.frame <- base::sys.nframe()
[18:04:15.414]     ...future.conditions <- base::list()
[18:04:15.414]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.414]     if (FALSE) {
[18:04:15.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.414]     }
[18:04:15.414]     ...future.result <- base::tryCatch({
[18:04:15.414]         base::withCallingHandlers({
[18:04:15.414]             ...future.value <- base::withVisible(base::local(2))
[18:04:15.414]             future::FutureResult(value = ...future.value$value, 
[18:04:15.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.414]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.414]                     ...future.globalenv.names))
[18:04:15.414]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.414]         }, condition = base::local({
[18:04:15.414]             c <- base::c
[18:04:15.414]             inherits <- base::inherits
[18:04:15.414]             invokeRestart <- base::invokeRestart
[18:04:15.414]             length <- base::length
[18:04:15.414]             list <- base::list
[18:04:15.414]             seq.int <- base::seq.int
[18:04:15.414]             signalCondition <- base::signalCondition
[18:04:15.414]             sys.calls <- base::sys.calls
[18:04:15.414]             `[[` <- base::`[[`
[18:04:15.414]             `+` <- base::`+`
[18:04:15.414]             `<<-` <- base::`<<-`
[18:04:15.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.414]                   3L)]
[18:04:15.414]             }
[18:04:15.414]             function(cond) {
[18:04:15.414]                 is_error <- inherits(cond, "error")
[18:04:15.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.414]                   NULL)
[18:04:15.414]                 if (is_error) {
[18:04:15.414]                   sessionInformation <- function() {
[18:04:15.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.414]                       search = base::search(), system = base::Sys.info())
[18:04:15.414]                   }
[18:04:15.414]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.414]                     cond$call), session = sessionInformation(), 
[18:04:15.414]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.414]                   signalCondition(cond)
[18:04:15.414]                 }
[18:04:15.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.414]                 "immediateCondition"))) {
[18:04:15.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.414]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.414]                   if (TRUE && !signal) {
[18:04:15.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.414]                     {
[18:04:15.414]                       inherits <- base::inherits
[18:04:15.414]                       invokeRestart <- base::invokeRestart
[18:04:15.414]                       is.null <- base::is.null
[18:04:15.414]                       muffled <- FALSE
[18:04:15.414]                       if (inherits(cond, "message")) {
[18:04:15.414]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.414]                         if (muffled) 
[18:04:15.414]                           invokeRestart("muffleMessage")
[18:04:15.414]                       }
[18:04:15.414]                       else if (inherits(cond, "warning")) {
[18:04:15.414]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.414]                         if (muffled) 
[18:04:15.414]                           invokeRestart("muffleWarning")
[18:04:15.414]                       }
[18:04:15.414]                       else if (inherits(cond, "condition")) {
[18:04:15.414]                         if (!is.null(pattern)) {
[18:04:15.414]                           computeRestarts <- base::computeRestarts
[18:04:15.414]                           grepl <- base::grepl
[18:04:15.414]                           restarts <- computeRestarts(cond)
[18:04:15.414]                           for (restart in restarts) {
[18:04:15.414]                             name <- restart$name
[18:04:15.414]                             if (is.null(name)) 
[18:04:15.414]                               next
[18:04:15.414]                             if (!grepl(pattern, name)) 
[18:04:15.414]                               next
[18:04:15.414]                             invokeRestart(restart)
[18:04:15.414]                             muffled <- TRUE
[18:04:15.414]                             break
[18:04:15.414]                           }
[18:04:15.414]                         }
[18:04:15.414]                       }
[18:04:15.414]                       invisible(muffled)
[18:04:15.414]                     }
[18:04:15.414]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.414]                   }
[18:04:15.414]                 }
[18:04:15.414]                 else {
[18:04:15.414]                   if (TRUE) {
[18:04:15.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.414]                     {
[18:04:15.414]                       inherits <- base::inherits
[18:04:15.414]                       invokeRestart <- base::invokeRestart
[18:04:15.414]                       is.null <- base::is.null
[18:04:15.414]                       muffled <- FALSE
[18:04:15.414]                       if (inherits(cond, "message")) {
[18:04:15.414]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.414]                         if (muffled) 
[18:04:15.414]                           invokeRestart("muffleMessage")
[18:04:15.414]                       }
[18:04:15.414]                       else if (inherits(cond, "warning")) {
[18:04:15.414]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.414]                         if (muffled) 
[18:04:15.414]                           invokeRestart("muffleWarning")
[18:04:15.414]                       }
[18:04:15.414]                       else if (inherits(cond, "condition")) {
[18:04:15.414]                         if (!is.null(pattern)) {
[18:04:15.414]                           computeRestarts <- base::computeRestarts
[18:04:15.414]                           grepl <- base::grepl
[18:04:15.414]                           restarts <- computeRestarts(cond)
[18:04:15.414]                           for (restart in restarts) {
[18:04:15.414]                             name <- restart$name
[18:04:15.414]                             if (is.null(name)) 
[18:04:15.414]                               next
[18:04:15.414]                             if (!grepl(pattern, name)) 
[18:04:15.414]                               next
[18:04:15.414]                             invokeRestart(restart)
[18:04:15.414]                             muffled <- TRUE
[18:04:15.414]                             break
[18:04:15.414]                           }
[18:04:15.414]                         }
[18:04:15.414]                       }
[18:04:15.414]                       invisible(muffled)
[18:04:15.414]                     }
[18:04:15.414]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.414]                   }
[18:04:15.414]                 }
[18:04:15.414]             }
[18:04:15.414]         }))
[18:04:15.414]     }, error = function(ex) {
[18:04:15.414]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.414]                 ...future.rng), started = ...future.startTime, 
[18:04:15.414]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.414]             version = "1.8"), class = "FutureResult")
[18:04:15.414]     }, finally = {
[18:04:15.414]         if (!identical(...future.workdir, getwd())) 
[18:04:15.414]             setwd(...future.workdir)
[18:04:15.414]         {
[18:04:15.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.414]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.414]             }
[18:04:15.414]             base::options(...future.oldOptions)
[18:04:15.414]             if (.Platform$OS.type == "windows") {
[18:04:15.414]                 old_names <- names(...future.oldEnvVars)
[18:04:15.414]                 envs <- base::Sys.getenv()
[18:04:15.414]                 names <- names(envs)
[18:04:15.414]                 common <- intersect(names, old_names)
[18:04:15.414]                 added <- setdiff(names, old_names)
[18:04:15.414]                 removed <- setdiff(old_names, names)
[18:04:15.414]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.414]                   envs[common]]
[18:04:15.414]                 NAMES <- toupper(changed)
[18:04:15.414]                 args <- list()
[18:04:15.414]                 for (kk in seq_along(NAMES)) {
[18:04:15.414]                   name <- changed[[kk]]
[18:04:15.414]                   NAME <- NAMES[[kk]]
[18:04:15.414]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.414]                     next
[18:04:15.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.414]                 }
[18:04:15.414]                 NAMES <- toupper(added)
[18:04:15.414]                 for (kk in seq_along(NAMES)) {
[18:04:15.414]                   name <- added[[kk]]
[18:04:15.414]                   NAME <- NAMES[[kk]]
[18:04:15.414]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.414]                     next
[18:04:15.414]                   args[[name]] <- ""
[18:04:15.414]                 }
[18:04:15.414]                 NAMES <- toupper(removed)
[18:04:15.414]                 for (kk in seq_along(NAMES)) {
[18:04:15.414]                   name <- removed[[kk]]
[18:04:15.414]                   NAME <- NAMES[[kk]]
[18:04:15.414]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.414]                     next
[18:04:15.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.414]                 }
[18:04:15.414]                 if (length(args) > 0) 
[18:04:15.414]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.414]             }
[18:04:15.414]             else {
[18:04:15.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.414]             }
[18:04:15.414]             {
[18:04:15.414]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.414]                   0L) {
[18:04:15.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.414]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.414]                   base::options(opts)
[18:04:15.414]                 }
[18:04:15.414]                 {
[18:04:15.414]                   {
[18:04:15.414]                     NULL
[18:04:15.414]                     RNGkind("Mersenne-Twister")
[18:04:15.414]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.414]                       inherits = FALSE)
[18:04:15.414]                   }
[18:04:15.414]                   options(future.plan = NULL)
[18:04:15.414]                   if (is.na(NA_character_)) 
[18:04:15.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.414]                     .init = FALSE)
[18:04:15.414]                 }
[18:04:15.414]             }
[18:04:15.414]         }
[18:04:15.414]     })
[18:04:15.414]     if (TRUE) {
[18:04:15.414]         base::sink(type = "output", split = FALSE)
[18:04:15.414]         if (TRUE) {
[18:04:15.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.414]         }
[18:04:15.414]         else {
[18:04:15.414]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.414]         }
[18:04:15.414]         base::close(...future.stdout)
[18:04:15.414]         ...future.stdout <- NULL
[18:04:15.414]     }
[18:04:15.414]     ...future.result$conditions <- ...future.conditions
[18:04:15.414]     ...future.result$finished <- base::Sys.time()
[18:04:15.414]     ...future.result
[18:04:15.414] }
[18:04:15.418] plan(): Setting new future strategy stack:
[18:04:15.418] List of future strategies:
[18:04:15.418] 1. sequential:
[18:04:15.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.418]    - tweaked: FALSE
[18:04:15.418]    - call: NULL
[18:04:15.419] plan(): nbrOfWorkers() = 1
[18:04:15.421] plan(): Setting new future strategy stack:
[18:04:15.421] List of future strategies:
[18:04:15.421] 1. sequential:
[18:04:15.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.421]    - tweaked: FALSE
[18:04:15.421]    - call: plan(strategy)
[18:04:15.422] plan(): nbrOfWorkers() = 1
[18:04:15.422] SequentialFuture started (and completed)
[18:04:15.423] - Launch lazy future ... done
[18:04:15.423] run() for ‘SequentialFuture’ ... done
[18:04:15.423] getGlobalsAndPackages() ...
[18:04:15.423] Searching for globals...
[18:04:15.424] 
[18:04:15.424] Searching for globals ... DONE
[18:04:15.424] - globals: [0] <none>
[18:04:15.425] getGlobalsAndPackages() ... DONE
[18:04:15.425] run() for ‘Future’ ...
[18:04:15.425] - state: ‘created’
[18:04:15.426] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.426] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.426] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.427]   - Field: ‘label’
[18:04:15.427]   - Field: ‘local’
[18:04:15.427]   - Field: ‘owner’
[18:04:15.427]   - Field: ‘envir’
[18:04:15.428]   - Field: ‘packages’
[18:04:15.428]   - Field: ‘gc’
[18:04:15.428]   - Field: ‘conditions’
[18:04:15.428]   - Field: ‘expr’
[18:04:15.428]   - Field: ‘uuid’
[18:04:15.429]   - Field: ‘seed’
[18:04:15.429]   - Field: ‘version’
[18:04:15.429]   - Field: ‘result’
[18:04:15.429]   - Field: ‘asynchronous’
[18:04:15.429]   - Field: ‘calls’
[18:04:15.430]   - Field: ‘globals’
[18:04:15.430]   - Field: ‘stdout’
[18:04:15.430]   - Field: ‘earlySignal’
[18:04:15.430]   - Field: ‘lazy’
[18:04:15.433]   - Field: ‘state’
[18:04:15.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.433] - Launch lazy future ...
[18:04:15.434] Packages needed by the future expression (n = 0): <none>
[18:04:15.434] Packages needed by future strategies (n = 0): <none>
[18:04:15.435] {
[18:04:15.435]     {
[18:04:15.435]         {
[18:04:15.435]             ...future.startTime <- base::Sys.time()
[18:04:15.435]             {
[18:04:15.435]                 {
[18:04:15.435]                   {
[18:04:15.435]                     base::local({
[18:04:15.435]                       has_future <- base::requireNamespace("future", 
[18:04:15.435]                         quietly = TRUE)
[18:04:15.435]                       if (has_future) {
[18:04:15.435]                         ns <- base::getNamespace("future")
[18:04:15.435]                         version <- ns[[".package"]][["version"]]
[18:04:15.435]                         if (is.null(version)) 
[18:04:15.435]                           version <- utils::packageVersion("future")
[18:04:15.435]                       }
[18:04:15.435]                       else {
[18:04:15.435]                         version <- NULL
[18:04:15.435]                       }
[18:04:15.435]                       if (!has_future || version < "1.8.0") {
[18:04:15.435]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.435]                           "", base::R.version$version.string), 
[18:04:15.435]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.435]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.435]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.435]                             "release", "version")], collapse = " "), 
[18:04:15.435]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.435]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.435]                           info)
[18:04:15.435]                         info <- base::paste(info, collapse = "; ")
[18:04:15.435]                         if (!has_future) {
[18:04:15.435]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.435]                             info)
[18:04:15.435]                         }
[18:04:15.435]                         else {
[18:04:15.435]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.435]                             info, version)
[18:04:15.435]                         }
[18:04:15.435]                         base::stop(msg)
[18:04:15.435]                       }
[18:04:15.435]                     })
[18:04:15.435]                   }
[18:04:15.435]                   ...future.strategy.old <- future::plan("list")
[18:04:15.435]                   options(future.plan = NULL)
[18:04:15.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.435]                 }
[18:04:15.435]                 ...future.workdir <- getwd()
[18:04:15.435]             }
[18:04:15.435]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.435]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.435]         }
[18:04:15.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.435]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.435]             base::names(...future.oldOptions))
[18:04:15.435]     }
[18:04:15.435]     if (FALSE) {
[18:04:15.435]     }
[18:04:15.435]     else {
[18:04:15.435]         if (TRUE) {
[18:04:15.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.435]                 open = "w")
[18:04:15.435]         }
[18:04:15.435]         else {
[18:04:15.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.435]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.435]         }
[18:04:15.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.435]             base::sink(type = "output", split = FALSE)
[18:04:15.435]             base::close(...future.stdout)
[18:04:15.435]         }, add = TRUE)
[18:04:15.435]     }
[18:04:15.435]     ...future.frame <- base::sys.nframe()
[18:04:15.435]     ...future.conditions <- base::list()
[18:04:15.435]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.435]     if (FALSE) {
[18:04:15.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.435]     }
[18:04:15.435]     ...future.result <- base::tryCatch({
[18:04:15.435]         base::withCallingHandlers({
[18:04:15.435]             ...future.value <- base::withVisible(base::local(NULL))
[18:04:15.435]             future::FutureResult(value = ...future.value$value, 
[18:04:15.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.435]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.435]                     ...future.globalenv.names))
[18:04:15.435]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.435]         }, condition = base::local({
[18:04:15.435]             c <- base::c
[18:04:15.435]             inherits <- base::inherits
[18:04:15.435]             invokeRestart <- base::invokeRestart
[18:04:15.435]             length <- base::length
[18:04:15.435]             list <- base::list
[18:04:15.435]             seq.int <- base::seq.int
[18:04:15.435]             signalCondition <- base::signalCondition
[18:04:15.435]             sys.calls <- base::sys.calls
[18:04:15.435]             `[[` <- base::`[[`
[18:04:15.435]             `+` <- base::`+`
[18:04:15.435]             `<<-` <- base::`<<-`
[18:04:15.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.435]                   3L)]
[18:04:15.435]             }
[18:04:15.435]             function(cond) {
[18:04:15.435]                 is_error <- inherits(cond, "error")
[18:04:15.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.435]                   NULL)
[18:04:15.435]                 if (is_error) {
[18:04:15.435]                   sessionInformation <- function() {
[18:04:15.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.435]                       search = base::search(), system = base::Sys.info())
[18:04:15.435]                   }
[18:04:15.435]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.435]                     cond$call), session = sessionInformation(), 
[18:04:15.435]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.435]                   signalCondition(cond)
[18:04:15.435]                 }
[18:04:15.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.435]                 "immediateCondition"))) {
[18:04:15.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.435]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.435]                   if (TRUE && !signal) {
[18:04:15.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.435]                     {
[18:04:15.435]                       inherits <- base::inherits
[18:04:15.435]                       invokeRestart <- base::invokeRestart
[18:04:15.435]                       is.null <- base::is.null
[18:04:15.435]                       muffled <- FALSE
[18:04:15.435]                       if (inherits(cond, "message")) {
[18:04:15.435]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.435]                         if (muffled) 
[18:04:15.435]                           invokeRestart("muffleMessage")
[18:04:15.435]                       }
[18:04:15.435]                       else if (inherits(cond, "warning")) {
[18:04:15.435]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.435]                         if (muffled) 
[18:04:15.435]                           invokeRestart("muffleWarning")
[18:04:15.435]                       }
[18:04:15.435]                       else if (inherits(cond, "condition")) {
[18:04:15.435]                         if (!is.null(pattern)) {
[18:04:15.435]                           computeRestarts <- base::computeRestarts
[18:04:15.435]                           grepl <- base::grepl
[18:04:15.435]                           restarts <- computeRestarts(cond)
[18:04:15.435]                           for (restart in restarts) {
[18:04:15.435]                             name <- restart$name
[18:04:15.435]                             if (is.null(name)) 
[18:04:15.435]                               next
[18:04:15.435]                             if (!grepl(pattern, name)) 
[18:04:15.435]                               next
[18:04:15.435]                             invokeRestart(restart)
[18:04:15.435]                             muffled <- TRUE
[18:04:15.435]                             break
[18:04:15.435]                           }
[18:04:15.435]                         }
[18:04:15.435]                       }
[18:04:15.435]                       invisible(muffled)
[18:04:15.435]                     }
[18:04:15.435]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.435]                   }
[18:04:15.435]                 }
[18:04:15.435]                 else {
[18:04:15.435]                   if (TRUE) {
[18:04:15.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.435]                     {
[18:04:15.435]                       inherits <- base::inherits
[18:04:15.435]                       invokeRestart <- base::invokeRestart
[18:04:15.435]                       is.null <- base::is.null
[18:04:15.435]                       muffled <- FALSE
[18:04:15.435]                       if (inherits(cond, "message")) {
[18:04:15.435]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.435]                         if (muffled) 
[18:04:15.435]                           invokeRestart("muffleMessage")
[18:04:15.435]                       }
[18:04:15.435]                       else if (inherits(cond, "warning")) {
[18:04:15.435]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.435]                         if (muffled) 
[18:04:15.435]                           invokeRestart("muffleWarning")
[18:04:15.435]                       }
[18:04:15.435]                       else if (inherits(cond, "condition")) {
[18:04:15.435]                         if (!is.null(pattern)) {
[18:04:15.435]                           computeRestarts <- base::computeRestarts
[18:04:15.435]                           grepl <- base::grepl
[18:04:15.435]                           restarts <- computeRestarts(cond)
[18:04:15.435]                           for (restart in restarts) {
[18:04:15.435]                             name <- restart$name
[18:04:15.435]                             if (is.null(name)) 
[18:04:15.435]                               next
[18:04:15.435]                             if (!grepl(pattern, name)) 
[18:04:15.435]                               next
[18:04:15.435]                             invokeRestart(restart)
[18:04:15.435]                             muffled <- TRUE
[18:04:15.435]                             break
[18:04:15.435]                           }
[18:04:15.435]                         }
[18:04:15.435]                       }
[18:04:15.435]                       invisible(muffled)
[18:04:15.435]                     }
[18:04:15.435]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.435]                   }
[18:04:15.435]                 }
[18:04:15.435]             }
[18:04:15.435]         }))
[18:04:15.435]     }, error = function(ex) {
[18:04:15.435]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.435]                 ...future.rng), started = ...future.startTime, 
[18:04:15.435]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.435]             version = "1.8"), class = "FutureResult")
[18:04:15.435]     }, finally = {
[18:04:15.435]         if (!identical(...future.workdir, getwd())) 
[18:04:15.435]             setwd(...future.workdir)
[18:04:15.435]         {
[18:04:15.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.435]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.435]             }
[18:04:15.435]             base::options(...future.oldOptions)
[18:04:15.435]             if (.Platform$OS.type == "windows") {
[18:04:15.435]                 old_names <- names(...future.oldEnvVars)
[18:04:15.435]                 envs <- base::Sys.getenv()
[18:04:15.435]                 names <- names(envs)
[18:04:15.435]                 common <- intersect(names, old_names)
[18:04:15.435]                 added <- setdiff(names, old_names)
[18:04:15.435]                 removed <- setdiff(old_names, names)
[18:04:15.435]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.435]                   envs[common]]
[18:04:15.435]                 NAMES <- toupper(changed)
[18:04:15.435]                 args <- list()
[18:04:15.435]                 for (kk in seq_along(NAMES)) {
[18:04:15.435]                   name <- changed[[kk]]
[18:04:15.435]                   NAME <- NAMES[[kk]]
[18:04:15.435]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.435]                     next
[18:04:15.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.435]                 }
[18:04:15.435]                 NAMES <- toupper(added)
[18:04:15.435]                 for (kk in seq_along(NAMES)) {
[18:04:15.435]                   name <- added[[kk]]
[18:04:15.435]                   NAME <- NAMES[[kk]]
[18:04:15.435]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.435]                     next
[18:04:15.435]                   args[[name]] <- ""
[18:04:15.435]                 }
[18:04:15.435]                 NAMES <- toupper(removed)
[18:04:15.435]                 for (kk in seq_along(NAMES)) {
[18:04:15.435]                   name <- removed[[kk]]
[18:04:15.435]                   NAME <- NAMES[[kk]]
[18:04:15.435]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.435]                     next
[18:04:15.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.435]                 }
[18:04:15.435]                 if (length(args) > 0) 
[18:04:15.435]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.435]             }
[18:04:15.435]             else {
[18:04:15.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.435]             }
[18:04:15.435]             {
[18:04:15.435]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.435]                   0L) {
[18:04:15.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.435]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.435]                   base::options(opts)
[18:04:15.435]                 }
[18:04:15.435]                 {
[18:04:15.435]                   {
[18:04:15.435]                     NULL
[18:04:15.435]                     RNGkind("Mersenne-Twister")
[18:04:15.435]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.435]                       inherits = FALSE)
[18:04:15.435]                   }
[18:04:15.435]                   options(future.plan = NULL)
[18:04:15.435]                   if (is.na(NA_character_)) 
[18:04:15.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.435]                     .init = FALSE)
[18:04:15.435]                 }
[18:04:15.435]             }
[18:04:15.435]         }
[18:04:15.435]     })
[18:04:15.435]     if (TRUE) {
[18:04:15.435]         base::sink(type = "output", split = FALSE)
[18:04:15.435]         if (TRUE) {
[18:04:15.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.435]         }
[18:04:15.435]         else {
[18:04:15.435]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.435]         }
[18:04:15.435]         base::close(...future.stdout)
[18:04:15.435]         ...future.stdout <- NULL
[18:04:15.435]     }
[18:04:15.435]     ...future.result$conditions <- ...future.conditions
[18:04:15.435]     ...future.result$finished <- base::Sys.time()
[18:04:15.435]     ...future.result
[18:04:15.435] }
[18:04:15.439] plan(): Setting new future strategy stack:
[18:04:15.439] List of future strategies:
[18:04:15.439] 1. sequential:
[18:04:15.439]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.439]    - tweaked: FALSE
[18:04:15.439]    - call: NULL
[18:04:15.440] plan(): nbrOfWorkers() = 1
[18:04:15.442] plan(): Setting new future strategy stack:
[18:04:15.442] List of future strategies:
[18:04:15.442] 1. sequential:
[18:04:15.442]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.442]    - tweaked: FALSE
[18:04:15.442]    - call: plan(strategy)
[18:04:15.443] plan(): nbrOfWorkers() = 1
[18:04:15.444] SequentialFuture started (and completed)
[18:04:15.444] - Launch lazy future ... done
[18:04:15.444] run() for ‘SequentialFuture’ ... done
[18:04:15.445] getGlobalsAndPackages() ...
[18:04:15.445] Searching for globals...
[18:04:15.447] - globals found: [1] ‘{’
[18:04:15.447] Searching for globals ... DONE
[18:04:15.447] Resolving globals: FALSE
[18:04:15.448] 
[18:04:15.448] 
[18:04:15.448] getGlobalsAndPackages() ... DONE
[18:04:15.449] run() for ‘Future’ ...
[18:04:15.449] - state: ‘created’
[18:04:15.449] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:15.450] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:15.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:15.450]   - Field: ‘label’
[18:04:15.450]   - Field: ‘local’
[18:04:15.451]   - Field: ‘owner’
[18:04:15.451]   - Field: ‘envir’
[18:04:15.451]   - Field: ‘packages’
[18:04:15.451]   - Field: ‘gc’
[18:04:15.451]   - Field: ‘conditions’
[18:04:15.452]   - Field: ‘expr’
[18:04:15.452]   - Field: ‘uuid’
[18:04:15.452]   - Field: ‘seed’
[18:04:15.452]   - Field: ‘version’
[18:04:15.452]   - Field: ‘result’
[18:04:15.453]   - Field: ‘asynchronous’
[18:04:15.453]   - Field: ‘calls’
[18:04:15.453]   - Field: ‘globals’
[18:04:15.453]   - Field: ‘stdout’
[18:04:15.453]   - Field: ‘earlySignal’
[18:04:15.454]   - Field: ‘lazy’
[18:04:15.454]   - Field: ‘state’
[18:04:15.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:15.454] - Launch lazy future ...
[18:04:15.455] Packages needed by the future expression (n = 0): <none>
[18:04:15.455] Packages needed by future strategies (n = 0): <none>
[18:04:15.456] {
[18:04:15.456]     {
[18:04:15.456]         {
[18:04:15.456]             ...future.startTime <- base::Sys.time()
[18:04:15.456]             {
[18:04:15.456]                 {
[18:04:15.456]                   {
[18:04:15.456]                     base::local({
[18:04:15.456]                       has_future <- base::requireNamespace("future", 
[18:04:15.456]                         quietly = TRUE)
[18:04:15.456]                       if (has_future) {
[18:04:15.456]                         ns <- base::getNamespace("future")
[18:04:15.456]                         version <- ns[[".package"]][["version"]]
[18:04:15.456]                         if (is.null(version)) 
[18:04:15.456]                           version <- utils::packageVersion("future")
[18:04:15.456]                       }
[18:04:15.456]                       else {
[18:04:15.456]                         version <- NULL
[18:04:15.456]                       }
[18:04:15.456]                       if (!has_future || version < "1.8.0") {
[18:04:15.456]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.456]                           "", base::R.version$version.string), 
[18:04:15.456]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:15.456]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.456]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.456]                             "release", "version")], collapse = " "), 
[18:04:15.456]                           hostname = base::Sys.info()[["nodename"]])
[18:04:15.456]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.456]                           info)
[18:04:15.456]                         info <- base::paste(info, collapse = "; ")
[18:04:15.456]                         if (!has_future) {
[18:04:15.456]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.456]                             info)
[18:04:15.456]                         }
[18:04:15.456]                         else {
[18:04:15.456]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.456]                             info, version)
[18:04:15.456]                         }
[18:04:15.456]                         base::stop(msg)
[18:04:15.456]                       }
[18:04:15.456]                     })
[18:04:15.456]                   }
[18:04:15.456]                   ...future.strategy.old <- future::plan("list")
[18:04:15.456]                   options(future.plan = NULL)
[18:04:15.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.456]                 }
[18:04:15.456]                 ...future.workdir <- getwd()
[18:04:15.456]             }
[18:04:15.456]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.456]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.456]         }
[18:04:15.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.456]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.456]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.456]             base::names(...future.oldOptions))
[18:04:15.456]     }
[18:04:15.456]     if (FALSE) {
[18:04:15.456]     }
[18:04:15.456]     else {
[18:04:15.456]         if (TRUE) {
[18:04:15.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.456]                 open = "w")
[18:04:15.456]         }
[18:04:15.456]         else {
[18:04:15.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.456]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.456]         }
[18:04:15.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.456]             base::sink(type = "output", split = FALSE)
[18:04:15.456]             base::close(...future.stdout)
[18:04:15.456]         }, add = TRUE)
[18:04:15.456]     }
[18:04:15.456]     ...future.frame <- base::sys.nframe()
[18:04:15.456]     ...future.conditions <- base::list()
[18:04:15.456]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.456]     if (FALSE) {
[18:04:15.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.456]     }
[18:04:15.456]     ...future.result <- base::tryCatch({
[18:04:15.456]         base::withCallingHandlers({
[18:04:15.456]             ...future.value <- base::withVisible(base::local({
[18:04:15.456]                 4
[18:04:15.456]             }))
[18:04:15.456]             future::FutureResult(value = ...future.value$value, 
[18:04:15.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.456]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.456]                     ...future.globalenv.names))
[18:04:15.456]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.456]         }, condition = base::local({
[18:04:15.456]             c <- base::c
[18:04:15.456]             inherits <- base::inherits
[18:04:15.456]             invokeRestart <- base::invokeRestart
[18:04:15.456]             length <- base::length
[18:04:15.456]             list <- base::list
[18:04:15.456]             seq.int <- base::seq.int
[18:04:15.456]             signalCondition <- base::signalCondition
[18:04:15.456]             sys.calls <- base::sys.calls
[18:04:15.456]             `[[` <- base::`[[`
[18:04:15.456]             `+` <- base::`+`
[18:04:15.456]             `<<-` <- base::`<<-`
[18:04:15.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.456]                   3L)]
[18:04:15.456]             }
[18:04:15.456]             function(cond) {
[18:04:15.456]                 is_error <- inherits(cond, "error")
[18:04:15.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.456]                   NULL)
[18:04:15.456]                 if (is_error) {
[18:04:15.456]                   sessionInformation <- function() {
[18:04:15.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.456]                       search = base::search(), system = base::Sys.info())
[18:04:15.456]                   }
[18:04:15.456]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.456]                     cond$call), session = sessionInformation(), 
[18:04:15.456]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.456]                   signalCondition(cond)
[18:04:15.456]                 }
[18:04:15.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.456]                 "immediateCondition"))) {
[18:04:15.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.456]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.456]                   if (TRUE && !signal) {
[18:04:15.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.456]                     {
[18:04:15.456]                       inherits <- base::inherits
[18:04:15.456]                       invokeRestart <- base::invokeRestart
[18:04:15.456]                       is.null <- base::is.null
[18:04:15.456]                       muffled <- FALSE
[18:04:15.456]                       if (inherits(cond, "message")) {
[18:04:15.456]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.456]                         if (muffled) 
[18:04:15.456]                           invokeRestart("muffleMessage")
[18:04:15.456]                       }
[18:04:15.456]                       else if (inherits(cond, "warning")) {
[18:04:15.456]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.456]                         if (muffled) 
[18:04:15.456]                           invokeRestart("muffleWarning")
[18:04:15.456]                       }
[18:04:15.456]                       else if (inherits(cond, "condition")) {
[18:04:15.456]                         if (!is.null(pattern)) {
[18:04:15.456]                           computeRestarts <- base::computeRestarts
[18:04:15.456]                           grepl <- base::grepl
[18:04:15.456]                           restarts <- computeRestarts(cond)
[18:04:15.456]                           for (restart in restarts) {
[18:04:15.456]                             name <- restart$name
[18:04:15.456]                             if (is.null(name)) 
[18:04:15.456]                               next
[18:04:15.456]                             if (!grepl(pattern, name)) 
[18:04:15.456]                               next
[18:04:15.456]                             invokeRestart(restart)
[18:04:15.456]                             muffled <- TRUE
[18:04:15.456]                             break
[18:04:15.456]                           }
[18:04:15.456]                         }
[18:04:15.456]                       }
[18:04:15.456]                       invisible(muffled)
[18:04:15.456]                     }
[18:04:15.456]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.456]                   }
[18:04:15.456]                 }
[18:04:15.456]                 else {
[18:04:15.456]                   if (TRUE) {
[18:04:15.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.456]                     {
[18:04:15.456]                       inherits <- base::inherits
[18:04:15.456]                       invokeRestart <- base::invokeRestart
[18:04:15.456]                       is.null <- base::is.null
[18:04:15.456]                       muffled <- FALSE
[18:04:15.456]                       if (inherits(cond, "message")) {
[18:04:15.456]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.456]                         if (muffled) 
[18:04:15.456]                           invokeRestart("muffleMessage")
[18:04:15.456]                       }
[18:04:15.456]                       else if (inherits(cond, "warning")) {
[18:04:15.456]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.456]                         if (muffled) 
[18:04:15.456]                           invokeRestart("muffleWarning")
[18:04:15.456]                       }
[18:04:15.456]                       else if (inherits(cond, "condition")) {
[18:04:15.456]                         if (!is.null(pattern)) {
[18:04:15.456]                           computeRestarts <- base::computeRestarts
[18:04:15.456]                           grepl <- base::grepl
[18:04:15.456]                           restarts <- computeRestarts(cond)
[18:04:15.456]                           for (restart in restarts) {
[18:04:15.456]                             name <- restart$name
[18:04:15.456]                             if (is.null(name)) 
[18:04:15.456]                               next
[18:04:15.456]                             if (!grepl(pattern, name)) 
[18:04:15.456]                               next
[18:04:15.456]                             invokeRestart(restart)
[18:04:15.456]                             muffled <- TRUE
[18:04:15.456]                             break
[18:04:15.456]                           }
[18:04:15.456]                         }
[18:04:15.456]                       }
[18:04:15.456]                       invisible(muffled)
[18:04:15.456]                     }
[18:04:15.456]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.456]                   }
[18:04:15.456]                 }
[18:04:15.456]             }
[18:04:15.456]         }))
[18:04:15.456]     }, error = function(ex) {
[18:04:15.456]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.456]                 ...future.rng), started = ...future.startTime, 
[18:04:15.456]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.456]             version = "1.8"), class = "FutureResult")
[18:04:15.456]     }, finally = {
[18:04:15.456]         if (!identical(...future.workdir, getwd())) 
[18:04:15.456]             setwd(...future.workdir)
[18:04:15.456]         {
[18:04:15.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.456]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.456]             }
[18:04:15.456]             base::options(...future.oldOptions)
[18:04:15.456]             if (.Platform$OS.type == "windows") {
[18:04:15.456]                 old_names <- names(...future.oldEnvVars)
[18:04:15.456]                 envs <- base::Sys.getenv()
[18:04:15.456]                 names <- names(envs)
[18:04:15.456]                 common <- intersect(names, old_names)
[18:04:15.456]                 added <- setdiff(names, old_names)
[18:04:15.456]                 removed <- setdiff(old_names, names)
[18:04:15.456]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.456]                   envs[common]]
[18:04:15.456]                 NAMES <- toupper(changed)
[18:04:15.456]                 args <- list()
[18:04:15.456]                 for (kk in seq_along(NAMES)) {
[18:04:15.456]                   name <- changed[[kk]]
[18:04:15.456]                   NAME <- NAMES[[kk]]
[18:04:15.456]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.456]                     next
[18:04:15.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.456]                 }
[18:04:15.456]                 NAMES <- toupper(added)
[18:04:15.456]                 for (kk in seq_along(NAMES)) {
[18:04:15.456]                   name <- added[[kk]]
[18:04:15.456]                   NAME <- NAMES[[kk]]
[18:04:15.456]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.456]                     next
[18:04:15.456]                   args[[name]] <- ""
[18:04:15.456]                 }
[18:04:15.456]                 NAMES <- toupper(removed)
[18:04:15.456]                 for (kk in seq_along(NAMES)) {
[18:04:15.456]                   name <- removed[[kk]]
[18:04:15.456]                   NAME <- NAMES[[kk]]
[18:04:15.456]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.456]                     next
[18:04:15.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.456]                 }
[18:04:15.456]                 if (length(args) > 0) 
[18:04:15.456]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.456]             }
[18:04:15.456]             else {
[18:04:15.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.456]             }
[18:04:15.456]             {
[18:04:15.456]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.456]                   0L) {
[18:04:15.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.456]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.456]                   base::options(opts)
[18:04:15.456]                 }
[18:04:15.456]                 {
[18:04:15.456]                   {
[18:04:15.456]                     NULL
[18:04:15.456]                     RNGkind("Mersenne-Twister")
[18:04:15.456]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:15.456]                       inherits = FALSE)
[18:04:15.456]                   }
[18:04:15.456]                   options(future.plan = NULL)
[18:04:15.456]                   if (is.na(NA_character_)) 
[18:04:15.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.456]                     .init = FALSE)
[18:04:15.456]                 }
[18:04:15.456]             }
[18:04:15.456]         }
[18:04:15.456]     })
[18:04:15.456]     if (TRUE) {
[18:04:15.456]         base::sink(type = "output", split = FALSE)
[18:04:15.456]         if (TRUE) {
[18:04:15.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.456]         }
[18:04:15.456]         else {
[18:04:15.456]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.456]         }
[18:04:15.456]         base::close(...future.stdout)
[18:04:15.456]         ...future.stdout <- NULL
[18:04:15.456]     }
[18:04:15.456]     ...future.result$conditions <- ...future.conditions
[18:04:15.456]     ...future.result$finished <- base::Sys.time()
[18:04:15.456]     ...future.result
[18:04:15.456] }
[18:04:15.459] plan(): Setting new future strategy stack:
[18:04:15.460] List of future strategies:
[18:04:15.460] 1. sequential:
[18:04:15.460]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.460]    - tweaked: FALSE
[18:04:15.460]    - call: NULL
[18:04:15.461] plan(): nbrOfWorkers() = 1
[18:04:15.462] plan(): Setting new future strategy stack:
[18:04:15.463] List of future strategies:
[18:04:15.463] 1. sequential:
[18:04:15.463]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.463]    - tweaked: FALSE
[18:04:15.463]    - call: plan(strategy)
[18:04:15.464] plan(): nbrOfWorkers() = 1
[18:04:15.464] SequentialFuture started (and completed)
[18:04:15.464] - Launch lazy future ... done
[18:04:15.465] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2b1096c8> 
Classes 'listenv', 'environment' <environment: 0x5e3c2aca59b0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[18:04:15.474] resolved() for ‘SequentialFuture’ ...
[18:04:15.474] - state: ‘finished’
[18:04:15.474] - run: TRUE
[18:04:15.474] - result: ‘FutureResult’
[18:04:15.475] resolved() for ‘SequentialFuture’ ... done
[18:04:15.475] resolved() for ‘SequentialFuture’ ...
[18:04:15.475] - state: ‘finished’
[18:04:15.475] - run: TRUE
[18:04:15.475] - result: ‘FutureResult’
[18:04:15.476] resolved() for ‘SequentialFuture’ ... done
[18:04:15.476] resolved() for ‘SequentialFuture’ ...
[18:04:15.476] - state: ‘finished’
[18:04:15.476] - run: TRUE
[18:04:15.477] - result: ‘FutureResult’
[18:04:15.477] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:15.483] resolve() on list environment ...
[18:04:15.483]  recursive: 0
[18:04:15.486]  length: 6
[18:04:15.486]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:15.486] signalConditionsASAP(numeric, pos=1) ...
[18:04:15.486] - nx: 6
[18:04:15.487] - relay: TRUE
[18:04:15.487] - stdout: TRUE
[18:04:15.487] - signal: TRUE
[18:04:15.487] - resignal: FALSE
[18:04:15.487] - force: TRUE
[18:04:15.487] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.488] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.488]  - until=2
[18:04:15.488]  - relaying element #2
[18:04:15.488] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.488] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.489] signalConditionsASAP(NULL, pos=1) ... done
[18:04:15.489]  length: 5 (resolved future 1)
[18:04:15.489] resolved() for ‘SequentialFuture’ ...
[18:04:15.489] - state: ‘finished’
[18:04:15.490] - run: TRUE
[18:04:15.490] - result: ‘FutureResult’
[18:04:15.490] resolved() for ‘SequentialFuture’ ... done
[18:04:15.490] Future #2
[18:04:15.491] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:04:15.491] - nx: 6
[18:04:15.491] - relay: TRUE
[18:04:15.491] - stdout: TRUE
[18:04:15.491] - signal: TRUE
[18:04:15.491] - resignal: FALSE
[18:04:15.492] - force: TRUE
[18:04:15.492] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.492] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.492]  - until=2
[18:04:15.492]  - relaying element #2
[18:04:15.493] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.493] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.493] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:04:15.494]  length: 4 (resolved future 2)
[18:04:15.494] resolved() for ‘SequentialFuture’ ...
[18:04:15.494] - state: ‘finished’
[18:04:15.494] - run: TRUE
[18:04:15.494] - result: ‘FutureResult’
[18:04:15.495] resolved() for ‘SequentialFuture’ ... done
[18:04:15.495] Future #3
[18:04:15.495] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:04:15.495] - nx: 6
[18:04:15.496] - relay: TRUE
[18:04:15.496] - stdout: TRUE
[18:04:15.496] - signal: TRUE
[18:04:15.499] - resignal: FALSE
[18:04:15.499] - force: TRUE
[18:04:15.499] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.499] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.499]  - until=3
[18:04:15.500]  - relaying element #3
[18:04:15.500] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.500] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.501] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:04:15.501]  length: 3 (resolved future 3)
[18:04:15.501] resolved() for ‘SequentialFuture’ ...
[18:04:15.501] - state: ‘finished’
[18:04:15.502] - run: TRUE
[18:04:15.502] - result: ‘FutureResult’
[18:04:15.502] resolved() for ‘SequentialFuture’ ... done
[18:04:15.502] Future #4
[18:04:15.503] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:04:15.503] - nx: 6
[18:04:15.503] - relay: TRUE
[18:04:15.503] - stdout: TRUE
[18:04:15.503] - signal: TRUE
[18:04:15.504] - resignal: FALSE
[18:04:15.504] - force: TRUE
[18:04:15.504] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.504] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.504]  - until=4
[18:04:15.505]  - relaying element #4
[18:04:15.505] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.505] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.505] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:04:15.506]  length: 2 (resolved future 4)
[18:04:15.506] signalConditionsASAP(NULL, pos=5) ...
[18:04:15.506] - nx: 6
[18:04:15.506] - relay: TRUE
[18:04:15.506] - stdout: TRUE
[18:04:15.507] - signal: TRUE
[18:04:15.507] - resignal: FALSE
[18:04:15.507] - force: TRUE
[18:04:15.507] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.507] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.507]  - until=6
[18:04:15.508]  - relaying element #6
[18:04:15.508] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.508] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.508] signalConditionsASAP(NULL, pos=5) ... done
[18:04:15.508]  length: 1 (resolved future 5)
[18:04:15.509] signalConditionsASAP(numeric, pos=6) ...
[18:04:15.509] - nx: 6
[18:04:15.509] - relay: TRUE
[18:04:15.509] - stdout: TRUE
[18:04:15.509] - signal: TRUE
[18:04:15.510] - resignal: FALSE
[18:04:15.510] - force: TRUE
[18:04:15.510] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.510] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.510]  - until=6
[18:04:15.511] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.511] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.511] signalConditionsASAP(numeric, pos=6) ... done
[18:04:15.511]  length: 0 (resolved future 6)
[18:04:15.511] Relaying remaining futures
[18:04:15.512] signalConditionsASAP(NULL, pos=0) ...
[18:04:15.512] - nx: 6
[18:04:15.512] - relay: TRUE
[18:04:15.512] - stdout: TRUE
[18:04:15.512] - signal: TRUE
[18:04:15.512] - resignal: FALSE
[18:04:15.513] - force: TRUE
[18:04:15.513] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.513] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:15.514] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.514] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.514] signalConditionsASAP(NULL, pos=0) ... done
[18:04:15.514] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5e3c2b36fbc0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[18:04:15.521] plan(): Setting new future strategy stack:
[18:04:15.522] List of future strategies:
[18:04:15.522] 1. multicore:
[18:04:15.522]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:15.522]    - tweaked: FALSE
[18:04:15.522]    - call: plan(strategy)
[18:04:15.528] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[18:04:15.529] getGlobalsAndPackages() ...
[18:04:15.529] Searching for globals...
[18:04:15.530] 
[18:04:15.530] Searching for globals ... DONE
[18:04:15.530] - globals: [0] <none>
[18:04:15.530] getGlobalsAndPackages() ... DONE
[18:04:15.531] run() for ‘Future’ ...
[18:04:15.531] - state: ‘created’
[18:04:15.531] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:15.538] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:15.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:15.539]   - Field: ‘label’
[18:04:15.539]   - Field: ‘local’
[18:04:15.539]   - Field: ‘owner’
[18:04:15.539]   - Field: ‘envir’
[18:04:15.540]   - Field: ‘workers’
[18:04:15.540]   - Field: ‘packages’
[18:04:15.540]   - Field: ‘gc’
[18:04:15.540]   - Field: ‘job’
[18:04:15.540]   - Field: ‘conditions’
[18:04:15.541]   - Field: ‘expr’
[18:04:15.541]   - Field: ‘uuid’
[18:04:15.541]   - Field: ‘seed’
[18:04:15.541]   - Field: ‘version’
[18:04:15.542]   - Field: ‘result’
[18:04:15.542]   - Field: ‘asynchronous’
[18:04:15.542]   - Field: ‘calls’
[18:04:15.542]   - Field: ‘globals’
[18:04:15.542]   - Field: ‘stdout’
[18:04:15.543]   - Field: ‘earlySignal’
[18:04:15.543]   - Field: ‘lazy’
[18:04:15.543]   - Field: ‘state’
[18:04:15.543] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:15.543] - Launch lazy future ...
[18:04:15.545] Packages needed by the future expression (n = 0): <none>
[18:04:15.546] Packages needed by future strategies (n = 0): <none>
[18:04:15.547] {
[18:04:15.547]     {
[18:04:15.547]         {
[18:04:15.547]             ...future.startTime <- base::Sys.time()
[18:04:15.547]             {
[18:04:15.547]                 {
[18:04:15.547]                   {
[18:04:15.547]                     {
[18:04:15.547]                       base::local({
[18:04:15.547]                         has_future <- base::requireNamespace("future", 
[18:04:15.547]                           quietly = TRUE)
[18:04:15.547]                         if (has_future) {
[18:04:15.547]                           ns <- base::getNamespace("future")
[18:04:15.547]                           version <- ns[[".package"]][["version"]]
[18:04:15.547]                           if (is.null(version)) 
[18:04:15.547]                             version <- utils::packageVersion("future")
[18:04:15.547]                         }
[18:04:15.547]                         else {
[18:04:15.547]                           version <- NULL
[18:04:15.547]                         }
[18:04:15.547]                         if (!has_future || version < "1.8.0") {
[18:04:15.547]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.547]                             "", base::R.version$version.string), 
[18:04:15.547]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:15.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.547]                               "release", "version")], collapse = " "), 
[18:04:15.547]                             hostname = base::Sys.info()[["nodename"]])
[18:04:15.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.547]                             info)
[18:04:15.547]                           info <- base::paste(info, collapse = "; ")
[18:04:15.547]                           if (!has_future) {
[18:04:15.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.547]                               info)
[18:04:15.547]                           }
[18:04:15.547]                           else {
[18:04:15.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.547]                               info, version)
[18:04:15.547]                           }
[18:04:15.547]                           base::stop(msg)
[18:04:15.547]                         }
[18:04:15.547]                       })
[18:04:15.547]                     }
[18:04:15.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:15.547]                     base::options(mc.cores = 1L)
[18:04:15.547]                   }
[18:04:15.547]                   ...future.strategy.old <- future::plan("list")
[18:04:15.547]                   options(future.plan = NULL)
[18:04:15.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.547]                 }
[18:04:15.547]                 ...future.workdir <- getwd()
[18:04:15.547]             }
[18:04:15.547]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.547]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.547]         }
[18:04:15.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.547]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.547]             base::names(...future.oldOptions))
[18:04:15.547]     }
[18:04:15.547]     if (FALSE) {
[18:04:15.547]     }
[18:04:15.547]     else {
[18:04:15.547]         if (TRUE) {
[18:04:15.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.547]                 open = "w")
[18:04:15.547]         }
[18:04:15.547]         else {
[18:04:15.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.547]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.547]         }
[18:04:15.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.547]             base::sink(type = "output", split = FALSE)
[18:04:15.547]             base::close(...future.stdout)
[18:04:15.547]         }, add = TRUE)
[18:04:15.547]     }
[18:04:15.547]     ...future.frame <- base::sys.nframe()
[18:04:15.547]     ...future.conditions <- base::list()
[18:04:15.547]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.547]     if (FALSE) {
[18:04:15.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.547]     }
[18:04:15.547]     ...future.result <- base::tryCatch({
[18:04:15.547]         base::withCallingHandlers({
[18:04:15.547]             ...future.value <- base::withVisible(base::local({
[18:04:15.547]                 withCallingHandlers({
[18:04:15.547]                   2
[18:04:15.547]                 }, immediateCondition = function(cond) {
[18:04:15.547]                   save_rds <- function (object, pathname, ...) 
[18:04:15.547]                   {
[18:04:15.547]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:15.547]                     if (file_test("-f", pathname_tmp)) {
[18:04:15.547]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.547]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:15.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.547]                         fi_tmp[["mtime"]])
[18:04:15.547]                     }
[18:04:15.547]                     tryCatch({
[18:04:15.547]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:15.547]                     }, error = function(ex) {
[18:04:15.547]                       msg <- conditionMessage(ex)
[18:04:15.547]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.547]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:15.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.547]                         fi_tmp[["mtime"]], msg)
[18:04:15.547]                       ex$message <- msg
[18:04:15.547]                       stop(ex)
[18:04:15.547]                     })
[18:04:15.547]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:15.547]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:15.547]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:15.547]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.547]                       fi <- file.info(pathname)
[18:04:15.547]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:15.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.547]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:15.547]                         fi[["size"]], fi[["mtime"]])
[18:04:15.547]                       stop(msg)
[18:04:15.547]                     }
[18:04:15.547]                     invisible(pathname)
[18:04:15.547]                   }
[18:04:15.547]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:15.547]                     rootPath = tempdir()) 
[18:04:15.547]                   {
[18:04:15.547]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:15.547]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:15.547]                       tmpdir = path, fileext = ".rds")
[18:04:15.547]                     save_rds(obj, file)
[18:04:15.547]                   }
[18:04:15.547]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:15.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.547]                   {
[18:04:15.547]                     inherits <- base::inherits
[18:04:15.547]                     invokeRestart <- base::invokeRestart
[18:04:15.547]                     is.null <- base::is.null
[18:04:15.547]                     muffled <- FALSE
[18:04:15.547]                     if (inherits(cond, "message")) {
[18:04:15.547]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:15.547]                       if (muffled) 
[18:04:15.547]                         invokeRestart("muffleMessage")
[18:04:15.547]                     }
[18:04:15.547]                     else if (inherits(cond, "warning")) {
[18:04:15.547]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:15.547]                       if (muffled) 
[18:04:15.547]                         invokeRestart("muffleWarning")
[18:04:15.547]                     }
[18:04:15.547]                     else if (inherits(cond, "condition")) {
[18:04:15.547]                       if (!is.null(pattern)) {
[18:04:15.547]                         computeRestarts <- base::computeRestarts
[18:04:15.547]                         grepl <- base::grepl
[18:04:15.547]                         restarts <- computeRestarts(cond)
[18:04:15.547]                         for (restart in restarts) {
[18:04:15.547]                           name <- restart$name
[18:04:15.547]                           if (is.null(name)) 
[18:04:15.547]                             next
[18:04:15.547]                           if (!grepl(pattern, name)) 
[18:04:15.547]                             next
[18:04:15.547]                           invokeRestart(restart)
[18:04:15.547]                           muffled <- TRUE
[18:04:15.547]                           break
[18:04:15.547]                         }
[18:04:15.547]                       }
[18:04:15.547]                     }
[18:04:15.547]                     invisible(muffled)
[18:04:15.547]                   }
[18:04:15.547]                   muffleCondition(cond)
[18:04:15.547]                 })
[18:04:15.547]             }))
[18:04:15.547]             future::FutureResult(value = ...future.value$value, 
[18:04:15.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.547]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.547]                     ...future.globalenv.names))
[18:04:15.547]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.547]         }, condition = base::local({
[18:04:15.547]             c <- base::c
[18:04:15.547]             inherits <- base::inherits
[18:04:15.547]             invokeRestart <- base::invokeRestart
[18:04:15.547]             length <- base::length
[18:04:15.547]             list <- base::list
[18:04:15.547]             seq.int <- base::seq.int
[18:04:15.547]             signalCondition <- base::signalCondition
[18:04:15.547]             sys.calls <- base::sys.calls
[18:04:15.547]             `[[` <- base::`[[`
[18:04:15.547]             `+` <- base::`+`
[18:04:15.547]             `<<-` <- base::`<<-`
[18:04:15.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.547]                   3L)]
[18:04:15.547]             }
[18:04:15.547]             function(cond) {
[18:04:15.547]                 is_error <- inherits(cond, "error")
[18:04:15.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.547]                   NULL)
[18:04:15.547]                 if (is_error) {
[18:04:15.547]                   sessionInformation <- function() {
[18:04:15.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.547]                       search = base::search(), system = base::Sys.info())
[18:04:15.547]                   }
[18:04:15.547]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.547]                     cond$call), session = sessionInformation(), 
[18:04:15.547]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.547]                   signalCondition(cond)
[18:04:15.547]                 }
[18:04:15.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.547]                 "immediateCondition"))) {
[18:04:15.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.547]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.547]                   if (TRUE && !signal) {
[18:04:15.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.547]                     {
[18:04:15.547]                       inherits <- base::inherits
[18:04:15.547]                       invokeRestart <- base::invokeRestart
[18:04:15.547]                       is.null <- base::is.null
[18:04:15.547]                       muffled <- FALSE
[18:04:15.547]                       if (inherits(cond, "message")) {
[18:04:15.547]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.547]                         if (muffled) 
[18:04:15.547]                           invokeRestart("muffleMessage")
[18:04:15.547]                       }
[18:04:15.547]                       else if (inherits(cond, "warning")) {
[18:04:15.547]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.547]                         if (muffled) 
[18:04:15.547]                           invokeRestart("muffleWarning")
[18:04:15.547]                       }
[18:04:15.547]                       else if (inherits(cond, "condition")) {
[18:04:15.547]                         if (!is.null(pattern)) {
[18:04:15.547]                           computeRestarts <- base::computeRestarts
[18:04:15.547]                           grepl <- base::grepl
[18:04:15.547]                           restarts <- computeRestarts(cond)
[18:04:15.547]                           for (restart in restarts) {
[18:04:15.547]                             name <- restart$name
[18:04:15.547]                             if (is.null(name)) 
[18:04:15.547]                               next
[18:04:15.547]                             if (!grepl(pattern, name)) 
[18:04:15.547]                               next
[18:04:15.547]                             invokeRestart(restart)
[18:04:15.547]                             muffled <- TRUE
[18:04:15.547]                             break
[18:04:15.547]                           }
[18:04:15.547]                         }
[18:04:15.547]                       }
[18:04:15.547]                       invisible(muffled)
[18:04:15.547]                     }
[18:04:15.547]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.547]                   }
[18:04:15.547]                 }
[18:04:15.547]                 else {
[18:04:15.547]                   if (TRUE) {
[18:04:15.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.547]                     {
[18:04:15.547]                       inherits <- base::inherits
[18:04:15.547]                       invokeRestart <- base::invokeRestart
[18:04:15.547]                       is.null <- base::is.null
[18:04:15.547]                       muffled <- FALSE
[18:04:15.547]                       if (inherits(cond, "message")) {
[18:04:15.547]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.547]                         if (muffled) 
[18:04:15.547]                           invokeRestart("muffleMessage")
[18:04:15.547]                       }
[18:04:15.547]                       else if (inherits(cond, "warning")) {
[18:04:15.547]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.547]                         if (muffled) 
[18:04:15.547]                           invokeRestart("muffleWarning")
[18:04:15.547]                       }
[18:04:15.547]                       else if (inherits(cond, "condition")) {
[18:04:15.547]                         if (!is.null(pattern)) {
[18:04:15.547]                           computeRestarts <- base::computeRestarts
[18:04:15.547]                           grepl <- base::grepl
[18:04:15.547]                           restarts <- computeRestarts(cond)
[18:04:15.547]                           for (restart in restarts) {
[18:04:15.547]                             name <- restart$name
[18:04:15.547]                             if (is.null(name)) 
[18:04:15.547]                               next
[18:04:15.547]                             if (!grepl(pattern, name)) 
[18:04:15.547]                               next
[18:04:15.547]                             invokeRestart(restart)
[18:04:15.547]                             muffled <- TRUE
[18:04:15.547]                             break
[18:04:15.547]                           }
[18:04:15.547]                         }
[18:04:15.547]                       }
[18:04:15.547]                       invisible(muffled)
[18:04:15.547]                     }
[18:04:15.547]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.547]                   }
[18:04:15.547]                 }
[18:04:15.547]             }
[18:04:15.547]         }))
[18:04:15.547]     }, error = function(ex) {
[18:04:15.547]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.547]                 ...future.rng), started = ...future.startTime, 
[18:04:15.547]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.547]             version = "1.8"), class = "FutureResult")
[18:04:15.547]     }, finally = {
[18:04:15.547]         if (!identical(...future.workdir, getwd())) 
[18:04:15.547]             setwd(...future.workdir)
[18:04:15.547]         {
[18:04:15.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.547]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.547]             }
[18:04:15.547]             base::options(...future.oldOptions)
[18:04:15.547]             if (.Platform$OS.type == "windows") {
[18:04:15.547]                 old_names <- names(...future.oldEnvVars)
[18:04:15.547]                 envs <- base::Sys.getenv()
[18:04:15.547]                 names <- names(envs)
[18:04:15.547]                 common <- intersect(names, old_names)
[18:04:15.547]                 added <- setdiff(names, old_names)
[18:04:15.547]                 removed <- setdiff(old_names, names)
[18:04:15.547]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.547]                   envs[common]]
[18:04:15.547]                 NAMES <- toupper(changed)
[18:04:15.547]                 args <- list()
[18:04:15.547]                 for (kk in seq_along(NAMES)) {
[18:04:15.547]                   name <- changed[[kk]]
[18:04:15.547]                   NAME <- NAMES[[kk]]
[18:04:15.547]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.547]                     next
[18:04:15.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.547]                 }
[18:04:15.547]                 NAMES <- toupper(added)
[18:04:15.547]                 for (kk in seq_along(NAMES)) {
[18:04:15.547]                   name <- added[[kk]]
[18:04:15.547]                   NAME <- NAMES[[kk]]
[18:04:15.547]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.547]                     next
[18:04:15.547]                   args[[name]] <- ""
[18:04:15.547]                 }
[18:04:15.547]                 NAMES <- toupper(removed)
[18:04:15.547]                 for (kk in seq_along(NAMES)) {
[18:04:15.547]                   name <- removed[[kk]]
[18:04:15.547]                   NAME <- NAMES[[kk]]
[18:04:15.547]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.547]                     next
[18:04:15.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.547]                 }
[18:04:15.547]                 if (length(args) > 0) 
[18:04:15.547]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.547]             }
[18:04:15.547]             else {
[18:04:15.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.547]             }
[18:04:15.547]             {
[18:04:15.547]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.547]                   0L) {
[18:04:15.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.547]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.547]                   base::options(opts)
[18:04:15.547]                 }
[18:04:15.547]                 {
[18:04:15.547]                   {
[18:04:15.547]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:15.547]                     NULL
[18:04:15.547]                   }
[18:04:15.547]                   options(future.plan = NULL)
[18:04:15.547]                   if (is.na(NA_character_)) 
[18:04:15.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.547]                     .init = FALSE)
[18:04:15.547]                 }
[18:04:15.547]             }
[18:04:15.547]         }
[18:04:15.547]     })
[18:04:15.547]     if (TRUE) {
[18:04:15.547]         base::sink(type = "output", split = FALSE)
[18:04:15.547]         if (TRUE) {
[18:04:15.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.547]         }
[18:04:15.547]         else {
[18:04:15.547]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.547]         }
[18:04:15.547]         base::close(...future.stdout)
[18:04:15.547]         ...future.stdout <- NULL
[18:04:15.547]     }
[18:04:15.547]     ...future.result$conditions <- ...future.conditions
[18:04:15.547]     ...future.result$finished <- base::Sys.time()
[18:04:15.547]     ...future.result
[18:04:15.547] }
[18:04:15.551] requestCore(): workers = 2
[18:04:15.556] MulticoreFuture started
[18:04:15.559] - Launch lazy future ... done
[18:04:15.560] run() for ‘MulticoreFuture’ ... done
[18:04:15.561] plan(): Setting new future strategy stack:
[18:04:15.560] getGlobalsAndPackages() ...
[18:04:15.563] Searching for globals...
[18:04:15.562] List of future strategies:
[18:04:15.562] 1. sequential:
[18:04:15.562]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.562]    - tweaked: FALSE
[18:04:15.562]    - call: NULL
[18:04:15.566] plan(): nbrOfWorkers() = 1
[18:04:15.565] 
[18:04:15.567] Searching for globals ... DONE
[18:04:15.568] - globals: [0] <none>
[18:04:15.568] getGlobalsAndPackages() ... DONE
[18:04:15.571] run() for ‘Future’ ...
[18:04:15.572] - state: ‘created’
[18:04:15.572] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:15.574] plan(): Setting new future strategy stack:
[18:04:15.575] List of future strategies:
[18:04:15.575] 1. multicore:
[18:04:15.575]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:15.575]    - tweaked: FALSE
[18:04:15.575]    - call: plan(strategy)
[18:04:15.590] plan(): nbrOfWorkers() = 2
[18:04:15.589] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:15.591] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:15.592]   - Field: ‘label’
[18:04:15.592]   - Field: ‘local’
[18:04:15.593]   - Field: ‘owner’
[18:04:15.593]   - Field: ‘envir’
[18:04:15.593]   - Field: ‘workers’
[18:04:15.594]   - Field: ‘packages’
[18:04:15.594]   - Field: ‘gc’
[18:04:15.594]   - Field: ‘job’
[18:04:15.595]   - Field: ‘conditions’
[18:04:15.595]   - Field: ‘expr’
[18:04:15.595]   - Field: ‘uuid’
[18:04:15.596]   - Field: ‘seed’
[18:04:15.596]   - Field: ‘version’
[18:04:15.596]   - Field: ‘result’
[18:04:15.597]   - Field: ‘asynchronous’
[18:04:15.597]   - Field: ‘calls’
[18:04:15.597]   - Field: ‘globals’
[18:04:15.598]   - Field: ‘stdout’
[18:04:15.598]   - Field: ‘earlySignal’
[18:04:15.598]   - Field: ‘lazy’
[18:04:15.599]   - Field: ‘state’
[18:04:15.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:15.599] - Launch lazy future ...
[18:04:15.600] Packages needed by the future expression (n = 0): <none>
[18:04:15.601] Packages needed by future strategies (n = 0): <none>
[18:04:15.602] {
[18:04:15.602]     {
[18:04:15.602]         {
[18:04:15.602]             ...future.startTime <- base::Sys.time()
[18:04:15.602]             {
[18:04:15.602]                 {
[18:04:15.602]                   {
[18:04:15.602]                     {
[18:04:15.602]                       base::local({
[18:04:15.602]                         has_future <- base::requireNamespace("future", 
[18:04:15.602]                           quietly = TRUE)
[18:04:15.602]                         if (has_future) {
[18:04:15.602]                           ns <- base::getNamespace("future")
[18:04:15.602]                           version <- ns[[".package"]][["version"]]
[18:04:15.602]                           if (is.null(version)) 
[18:04:15.602]                             version <- utils::packageVersion("future")
[18:04:15.602]                         }
[18:04:15.602]                         else {
[18:04:15.602]                           version <- NULL
[18:04:15.602]                         }
[18:04:15.602]                         if (!has_future || version < "1.8.0") {
[18:04:15.602]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.602]                             "", base::R.version$version.string), 
[18:04:15.602]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:15.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.602]                               "release", "version")], collapse = " "), 
[18:04:15.602]                             hostname = base::Sys.info()[["nodename"]])
[18:04:15.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.602]                             info)
[18:04:15.602]                           info <- base::paste(info, collapse = "; ")
[18:04:15.602]                           if (!has_future) {
[18:04:15.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.602]                               info)
[18:04:15.602]                           }
[18:04:15.602]                           else {
[18:04:15.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.602]                               info, version)
[18:04:15.602]                           }
[18:04:15.602]                           base::stop(msg)
[18:04:15.602]                         }
[18:04:15.602]                       })
[18:04:15.602]                     }
[18:04:15.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:15.602]                     base::options(mc.cores = 1L)
[18:04:15.602]                   }
[18:04:15.602]                   ...future.strategy.old <- future::plan("list")
[18:04:15.602]                   options(future.plan = NULL)
[18:04:15.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.602]                 }
[18:04:15.602]                 ...future.workdir <- getwd()
[18:04:15.602]             }
[18:04:15.602]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.602]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.602]         }
[18:04:15.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.602]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.602]             base::names(...future.oldOptions))
[18:04:15.602]     }
[18:04:15.602]     if (FALSE) {
[18:04:15.602]     }
[18:04:15.602]     else {
[18:04:15.602]         if (TRUE) {
[18:04:15.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.602]                 open = "w")
[18:04:15.602]         }
[18:04:15.602]         else {
[18:04:15.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.602]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.602]         }
[18:04:15.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.602]             base::sink(type = "output", split = FALSE)
[18:04:15.602]             base::close(...future.stdout)
[18:04:15.602]         }, add = TRUE)
[18:04:15.602]     }
[18:04:15.602]     ...future.frame <- base::sys.nframe()
[18:04:15.602]     ...future.conditions <- base::list()
[18:04:15.602]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.602]     if (FALSE) {
[18:04:15.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.602]     }
[18:04:15.602]     ...future.result <- base::tryCatch({
[18:04:15.602]         base::withCallingHandlers({
[18:04:15.602]             ...future.value <- base::withVisible(base::local({
[18:04:15.602]                 withCallingHandlers({
[18:04:15.602]                   NULL
[18:04:15.602]                 }, immediateCondition = function(cond) {
[18:04:15.602]                   save_rds <- function (object, pathname, ...) 
[18:04:15.602]                   {
[18:04:15.602]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:15.602]                     if (file_test("-f", pathname_tmp)) {
[18:04:15.602]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.602]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:15.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.602]                         fi_tmp[["mtime"]])
[18:04:15.602]                     }
[18:04:15.602]                     tryCatch({
[18:04:15.602]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:15.602]                     }, error = function(ex) {
[18:04:15.602]                       msg <- conditionMessage(ex)
[18:04:15.602]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.602]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:15.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.602]                         fi_tmp[["mtime"]], msg)
[18:04:15.602]                       ex$message <- msg
[18:04:15.602]                       stop(ex)
[18:04:15.602]                     })
[18:04:15.602]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:15.602]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:15.602]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:15.602]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.602]                       fi <- file.info(pathname)
[18:04:15.602]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:15.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.602]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:15.602]                         fi[["size"]], fi[["mtime"]])
[18:04:15.602]                       stop(msg)
[18:04:15.602]                     }
[18:04:15.602]                     invisible(pathname)
[18:04:15.602]                   }
[18:04:15.602]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:15.602]                     rootPath = tempdir()) 
[18:04:15.602]                   {
[18:04:15.602]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:15.602]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:15.602]                       tmpdir = path, fileext = ".rds")
[18:04:15.602]                     save_rds(obj, file)
[18:04:15.602]                   }
[18:04:15.602]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:15.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.602]                   {
[18:04:15.602]                     inherits <- base::inherits
[18:04:15.602]                     invokeRestart <- base::invokeRestart
[18:04:15.602]                     is.null <- base::is.null
[18:04:15.602]                     muffled <- FALSE
[18:04:15.602]                     if (inherits(cond, "message")) {
[18:04:15.602]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:15.602]                       if (muffled) 
[18:04:15.602]                         invokeRestart("muffleMessage")
[18:04:15.602]                     }
[18:04:15.602]                     else if (inherits(cond, "warning")) {
[18:04:15.602]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:15.602]                       if (muffled) 
[18:04:15.602]                         invokeRestart("muffleWarning")
[18:04:15.602]                     }
[18:04:15.602]                     else if (inherits(cond, "condition")) {
[18:04:15.602]                       if (!is.null(pattern)) {
[18:04:15.602]                         computeRestarts <- base::computeRestarts
[18:04:15.602]                         grepl <- base::grepl
[18:04:15.602]                         restarts <- computeRestarts(cond)
[18:04:15.602]                         for (restart in restarts) {
[18:04:15.602]                           name <- restart$name
[18:04:15.602]                           if (is.null(name)) 
[18:04:15.602]                             next
[18:04:15.602]                           if (!grepl(pattern, name)) 
[18:04:15.602]                             next
[18:04:15.602]                           invokeRestart(restart)
[18:04:15.602]                           muffled <- TRUE
[18:04:15.602]                           break
[18:04:15.602]                         }
[18:04:15.602]                       }
[18:04:15.602]                     }
[18:04:15.602]                     invisible(muffled)
[18:04:15.602]                   }
[18:04:15.602]                   muffleCondition(cond)
[18:04:15.602]                 })
[18:04:15.602]             }))
[18:04:15.602]             future::FutureResult(value = ...future.value$value, 
[18:04:15.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.602]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.602]                     ...future.globalenv.names))
[18:04:15.602]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.602]         }, condition = base::local({
[18:04:15.602]             c <- base::c
[18:04:15.602]             inherits <- base::inherits
[18:04:15.602]             invokeRestart <- base::invokeRestart
[18:04:15.602]             length <- base::length
[18:04:15.602]             list <- base::list
[18:04:15.602]             seq.int <- base::seq.int
[18:04:15.602]             signalCondition <- base::signalCondition
[18:04:15.602]             sys.calls <- base::sys.calls
[18:04:15.602]             `[[` <- base::`[[`
[18:04:15.602]             `+` <- base::`+`
[18:04:15.602]             `<<-` <- base::`<<-`
[18:04:15.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.602]                   3L)]
[18:04:15.602]             }
[18:04:15.602]             function(cond) {
[18:04:15.602]                 is_error <- inherits(cond, "error")
[18:04:15.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.602]                   NULL)
[18:04:15.602]                 if (is_error) {
[18:04:15.602]                   sessionInformation <- function() {
[18:04:15.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.602]                       search = base::search(), system = base::Sys.info())
[18:04:15.602]                   }
[18:04:15.602]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.602]                     cond$call), session = sessionInformation(), 
[18:04:15.602]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.602]                   signalCondition(cond)
[18:04:15.602]                 }
[18:04:15.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.602]                 "immediateCondition"))) {
[18:04:15.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.602]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.602]                   if (TRUE && !signal) {
[18:04:15.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.602]                     {
[18:04:15.602]                       inherits <- base::inherits
[18:04:15.602]                       invokeRestart <- base::invokeRestart
[18:04:15.602]                       is.null <- base::is.null
[18:04:15.602]                       muffled <- FALSE
[18:04:15.602]                       if (inherits(cond, "message")) {
[18:04:15.602]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.602]                         if (muffled) 
[18:04:15.602]                           invokeRestart("muffleMessage")
[18:04:15.602]                       }
[18:04:15.602]                       else if (inherits(cond, "warning")) {
[18:04:15.602]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.602]                         if (muffled) 
[18:04:15.602]                           invokeRestart("muffleWarning")
[18:04:15.602]                       }
[18:04:15.602]                       else if (inherits(cond, "condition")) {
[18:04:15.602]                         if (!is.null(pattern)) {
[18:04:15.602]                           computeRestarts <- base::computeRestarts
[18:04:15.602]                           grepl <- base::grepl
[18:04:15.602]                           restarts <- computeRestarts(cond)
[18:04:15.602]                           for (restart in restarts) {
[18:04:15.602]                             name <- restart$name
[18:04:15.602]                             if (is.null(name)) 
[18:04:15.602]                               next
[18:04:15.602]                             if (!grepl(pattern, name)) 
[18:04:15.602]                               next
[18:04:15.602]                             invokeRestart(restart)
[18:04:15.602]                             muffled <- TRUE
[18:04:15.602]                             break
[18:04:15.602]                           }
[18:04:15.602]                         }
[18:04:15.602]                       }
[18:04:15.602]                       invisible(muffled)
[18:04:15.602]                     }
[18:04:15.602]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.602]                   }
[18:04:15.602]                 }
[18:04:15.602]                 else {
[18:04:15.602]                   if (TRUE) {
[18:04:15.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.602]                     {
[18:04:15.602]                       inherits <- base::inherits
[18:04:15.602]                       invokeRestart <- base::invokeRestart
[18:04:15.602]                       is.null <- base::is.null
[18:04:15.602]                       muffled <- FALSE
[18:04:15.602]                       if (inherits(cond, "message")) {
[18:04:15.602]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.602]                         if (muffled) 
[18:04:15.602]                           invokeRestart("muffleMessage")
[18:04:15.602]                       }
[18:04:15.602]                       else if (inherits(cond, "warning")) {
[18:04:15.602]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.602]                         if (muffled) 
[18:04:15.602]                           invokeRestart("muffleWarning")
[18:04:15.602]                       }
[18:04:15.602]                       else if (inherits(cond, "condition")) {
[18:04:15.602]                         if (!is.null(pattern)) {
[18:04:15.602]                           computeRestarts <- base::computeRestarts
[18:04:15.602]                           grepl <- base::grepl
[18:04:15.602]                           restarts <- computeRestarts(cond)
[18:04:15.602]                           for (restart in restarts) {
[18:04:15.602]                             name <- restart$name
[18:04:15.602]                             if (is.null(name)) 
[18:04:15.602]                               next
[18:04:15.602]                             if (!grepl(pattern, name)) 
[18:04:15.602]                               next
[18:04:15.602]                             invokeRestart(restart)
[18:04:15.602]                             muffled <- TRUE
[18:04:15.602]                             break
[18:04:15.602]                           }
[18:04:15.602]                         }
[18:04:15.602]                       }
[18:04:15.602]                       invisible(muffled)
[18:04:15.602]                     }
[18:04:15.602]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.602]                   }
[18:04:15.602]                 }
[18:04:15.602]             }
[18:04:15.602]         }))
[18:04:15.602]     }, error = function(ex) {
[18:04:15.602]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.602]                 ...future.rng), started = ...future.startTime, 
[18:04:15.602]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.602]             version = "1.8"), class = "FutureResult")
[18:04:15.602]     }, finally = {
[18:04:15.602]         if (!identical(...future.workdir, getwd())) 
[18:04:15.602]             setwd(...future.workdir)
[18:04:15.602]         {
[18:04:15.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.602]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.602]             }
[18:04:15.602]             base::options(...future.oldOptions)
[18:04:15.602]             if (.Platform$OS.type == "windows") {
[18:04:15.602]                 old_names <- names(...future.oldEnvVars)
[18:04:15.602]                 envs <- base::Sys.getenv()
[18:04:15.602]                 names <- names(envs)
[18:04:15.602]                 common <- intersect(names, old_names)
[18:04:15.602]                 added <- setdiff(names, old_names)
[18:04:15.602]                 removed <- setdiff(old_names, names)
[18:04:15.602]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.602]                   envs[common]]
[18:04:15.602]                 NAMES <- toupper(changed)
[18:04:15.602]                 args <- list()
[18:04:15.602]                 for (kk in seq_along(NAMES)) {
[18:04:15.602]                   name <- changed[[kk]]
[18:04:15.602]                   NAME <- NAMES[[kk]]
[18:04:15.602]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.602]                     next
[18:04:15.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.602]                 }
[18:04:15.602]                 NAMES <- toupper(added)
[18:04:15.602]                 for (kk in seq_along(NAMES)) {
[18:04:15.602]                   name <- added[[kk]]
[18:04:15.602]                   NAME <- NAMES[[kk]]
[18:04:15.602]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.602]                     next
[18:04:15.602]                   args[[name]] <- ""
[18:04:15.602]                 }
[18:04:15.602]                 NAMES <- toupper(removed)
[18:04:15.602]                 for (kk in seq_along(NAMES)) {
[18:04:15.602]                   name <- removed[[kk]]
[18:04:15.602]                   NAME <- NAMES[[kk]]
[18:04:15.602]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.602]                     next
[18:04:15.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.602]                 }
[18:04:15.602]                 if (length(args) > 0) 
[18:04:15.602]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.602]             }
[18:04:15.602]             else {
[18:04:15.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.602]             }
[18:04:15.602]             {
[18:04:15.602]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.602]                   0L) {
[18:04:15.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.602]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.602]                   base::options(opts)
[18:04:15.602]                 }
[18:04:15.602]                 {
[18:04:15.602]                   {
[18:04:15.602]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:15.602]                     NULL
[18:04:15.602]                   }
[18:04:15.602]                   options(future.plan = NULL)
[18:04:15.602]                   if (is.na(NA_character_)) 
[18:04:15.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.602]                     .init = FALSE)
[18:04:15.602]                 }
[18:04:15.602]             }
[18:04:15.602]         }
[18:04:15.602]     })
[18:04:15.602]     if (TRUE) {
[18:04:15.602]         base::sink(type = "output", split = FALSE)
[18:04:15.602]         if (TRUE) {
[18:04:15.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.602]         }
[18:04:15.602]         else {
[18:04:15.602]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.602]         }
[18:04:15.602]         base::close(...future.stdout)
[18:04:15.602]         ...future.stdout <- NULL
[18:04:15.602]     }
[18:04:15.602]     ...future.result$conditions <- ...future.conditions
[18:04:15.602]     ...future.result$finished <- base::Sys.time()
[18:04:15.602]     ...future.result
[18:04:15.602] }
[18:04:15.609] requestCore(): workers = 2
[18:04:15.631] MulticoreFuture started
[18:04:15.631] - Launch lazy future ... done
[18:04:15.632] run() for ‘MulticoreFuture’ ... done
[18:04:15.633] plan(): Setting new future strategy stack:
List of 6
 $ a:[18:04:15.633] List of future strategies:
[18:04:15.633] 1. sequential:
[18:04:15.633]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.633]    - tweaked: FALSE
[18:04:15.633]    - call: NULL
 num 1
 $ b:[18:04:15.636] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2ad63f90> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b3782f8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
[18:04:15.643] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2ad63f90> 
 $ c:[18:04:15.644] List of future strategies:
[18:04:15.644] 1. multicore:
[18:04:15.644]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:15.644]    - tweaked: FALSE
[18:04:15.644]    - call: plan(strategy)
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b3782f8> 
 $  : NULL
 $  : NULL
 $  : num 6
[18:04:15.658] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:15.662] resolve() on list ...
[18:04:15.662]  recursive: 0
[18:04:15.663]  length: 6
[18:04:15.663]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:15.664] signalConditionsASAP(numeric, pos=1) ...
[18:04:15.664] - nx: 6
[18:04:15.664] - relay: TRUE
[18:04:15.665] - stdout: TRUE
[18:04:15.665] - signal: TRUE
[18:04:15.665] - resignal: FALSE
[18:04:15.665] - force: TRUE
[18:04:15.666] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.666] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.666]  - until=2
[18:04:15.667]  - relaying element #2
[18:04:15.667] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.667] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.668] signalConditionsASAP(NULL, pos=1) ... done
[18:04:15.668]  length: 5 (resolved future 1)
[18:04:15.669] Future #2
[18:04:15.670] result() for MulticoreFuture ...
[18:04:15.674] result() for MulticoreFuture ...
[18:04:15.678] result() for MulticoreFuture ... done
[18:04:15.678] result() for MulticoreFuture ... done
[18:04:15.679] result() for MulticoreFuture ...
[18:04:15.679] result() for MulticoreFuture ... done
[18:04:15.680] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:15.681] - nx: 6
[18:04:15.682] - relay: TRUE
[18:04:15.682] - stdout: TRUE
[18:04:15.682] - signal: TRUE
[18:04:15.685] - resignal: FALSE
[18:04:15.685] - force: TRUE
[18:04:15.686] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.686] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.687]  - until=2
[18:04:15.687]  - relaying element #2
[18:04:15.687] result() for MulticoreFuture ...
[18:04:15.688] result() for MulticoreFuture ... done
[18:04:15.688] result() for MulticoreFuture ...
[18:04:15.688] result() for MulticoreFuture ... done
[18:04:15.689] result() for MulticoreFuture ...
[18:04:15.689] result() for MulticoreFuture ... done
[18:04:15.689] result() for MulticoreFuture ...
[18:04:15.689] result() for MulticoreFuture ... done
[18:04:15.690] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.690] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.690] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:15.691]  length: 4 (resolved future 2)
[18:04:15.691] Future #3
[18:04:15.692] result() for MulticoreFuture ...
[18:04:15.693] result() for MulticoreFuture ...
[18:04:15.694] result() for MulticoreFuture ... done
[18:04:15.696] result() for MulticoreFuture ... done
[18:04:15.696] result() for MulticoreFuture ...
[18:04:15.697] result() for MulticoreFuture ... done
[18:04:15.697] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:15.697] - nx: 6
[18:04:15.697] - relay: TRUE
[18:04:15.698] - stdout: TRUE
[18:04:15.699] - signal: TRUE
[18:04:15.699] - resignal: FALSE
[18:04:15.700] - force: TRUE
[18:04:15.700] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.700] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.700]  - until=3
[18:04:15.701]  - relaying element #3
[18:04:15.701] result() for MulticoreFuture ...
[18:04:15.701] result() for MulticoreFuture ... done
[18:04:15.701] result() for MulticoreFuture ...
[18:04:15.701] result() for MulticoreFuture ... done
[18:04:15.702] result() for MulticoreFuture ...
[18:04:15.702] result() for MulticoreFuture ... done
[18:04:15.702] result() for MulticoreFuture ...
[18:04:15.703] result() for MulticoreFuture ... done
[18:04:15.703] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.703] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.703] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:15.704]  length: 3 (resolved future 3)
[18:04:15.704] signalConditionsASAP(NULL, pos=4) ...
[18:04:15.704] - nx: 6
[18:04:15.704] - relay: TRUE
[18:04:15.704] - stdout: TRUE
[18:04:15.705] - signal: TRUE
[18:04:15.705] - resignal: FALSE
[18:04:15.705] - force: TRUE
[18:04:15.706] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.706] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.706]  - until=5
[18:04:15.706]  - relaying element #5
[18:04:15.706] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.707] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.707] signalConditionsASAP(NULL, pos=4) ... done
[18:04:15.707]  length: 2 (resolved future 4)
[18:04:15.708] signalConditionsASAP(NULL, pos=5) ...
[18:04:15.708] - nx: 6
[18:04:15.708] - relay: TRUE
[18:04:15.709] - stdout: TRUE
[18:04:15.709] - signal: TRUE
[18:04:15.709] - resignal: FALSE
[18:04:15.709] - force: TRUE
[18:04:15.709] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.710] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.710]  - until=6
[18:04:15.710]  - relaying element #6
[18:04:15.710] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.711] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.711] signalConditionsASAP(NULL, pos=5) ... done
[18:04:15.711]  length: 1 (resolved future 5)
[18:04:15.711] signalConditionsASAP(numeric, pos=6) ...
[18:04:15.712] - nx: 6
[18:04:15.712] - relay: TRUE
[18:04:15.712] - stdout: TRUE
[18:04:15.712] - signal: TRUE
[18:04:15.712] - resignal: FALSE
[18:04:15.713] - force: TRUE
[18:04:15.713] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.713] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.713]  - until=6
[18:04:15.714] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.714] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.714] signalConditionsASAP(numeric, pos=6) ... done
[18:04:15.714]  length: 0 (resolved future 6)
[18:04:15.715] Relaying remaining futures
[18:04:15.715] signalConditionsASAP(NULL, pos=0) ...
[18:04:15.715] - nx: 6
[18:04:15.715] - relay: TRUE
[18:04:15.715] - stdout: TRUE
[18:04:15.715] - signal: TRUE
[18:04:15.716] - resignal: FALSE
[18:04:15.716] - force: TRUE
[18:04:15.716] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.716] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:15.717] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.717] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.717] signalConditionsASAP(NULL, pos=0) ... done
[18:04:15.717] resolve() on list ... DONE
[18:04:15.718] result() for MulticoreFuture ...
[18:04:15.718] result() for MulticoreFuture ... done
[18:04:15.718] result() for MulticoreFuture ...
[18:04:15.718] result() for MulticoreFuture ... done
[18:04:15.719] result() for MulticoreFuture ...
[18:04:15.719] result() for MulticoreFuture ... done
[18:04:15.719] result() for MulticoreFuture ...
[18:04:15.719] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[18:04:15.724] getGlobalsAndPackages() ...
[18:04:15.724] Searching for globals...
[18:04:15.725] 
[18:04:15.725] Searching for globals ... DONE
[18:04:15.725] - globals: [0] <none>
[18:04:15.726] getGlobalsAndPackages() ... DONE
[18:04:15.726] run() for ‘Future’ ...
[18:04:15.726] - state: ‘created’
[18:04:15.727] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:15.736] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:15.736] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:15.737]   - Field: ‘label’
[18:04:15.737]   - Field: ‘local’
[18:04:15.737]   - Field: ‘owner’
[18:04:15.737]   - Field: ‘envir’
[18:04:15.738]   - Field: ‘workers’
[18:04:15.738]   - Field: ‘packages’
[18:04:15.738]   - Field: ‘gc’
[18:04:15.738]   - Field: ‘job’
[18:04:15.738]   - Field: ‘conditions’
[18:04:15.739]   - Field: ‘expr’
[18:04:15.739]   - Field: ‘uuid’
[18:04:15.739]   - Field: ‘seed’
[18:04:15.739]   - Field: ‘version’
[18:04:15.739]   - Field: ‘result’
[18:04:15.740]   - Field: ‘asynchronous’
[18:04:15.740]   - Field: ‘calls’
[18:04:15.740]   - Field: ‘globals’
[18:04:15.740]   - Field: ‘stdout’
[18:04:15.740]   - Field: ‘earlySignal’
[18:04:15.741]   - Field: ‘lazy’
[18:04:15.741]   - Field: ‘state’
[18:04:15.741] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:15.741] - Launch lazy future ...
[18:04:15.742] Packages needed by the future expression (n = 0): <none>
[18:04:15.742] Packages needed by future strategies (n = 0): <none>
[18:04:15.743] {
[18:04:15.743]     {
[18:04:15.743]         {
[18:04:15.743]             ...future.startTime <- base::Sys.time()
[18:04:15.743]             {
[18:04:15.743]                 {
[18:04:15.743]                   {
[18:04:15.743]                     {
[18:04:15.743]                       base::local({
[18:04:15.743]                         has_future <- base::requireNamespace("future", 
[18:04:15.743]                           quietly = TRUE)
[18:04:15.743]                         if (has_future) {
[18:04:15.743]                           ns <- base::getNamespace("future")
[18:04:15.743]                           version <- ns[[".package"]][["version"]]
[18:04:15.743]                           if (is.null(version)) 
[18:04:15.743]                             version <- utils::packageVersion("future")
[18:04:15.743]                         }
[18:04:15.743]                         else {
[18:04:15.743]                           version <- NULL
[18:04:15.743]                         }
[18:04:15.743]                         if (!has_future || version < "1.8.0") {
[18:04:15.743]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.743]                             "", base::R.version$version.string), 
[18:04:15.743]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:15.743]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.743]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.743]                               "release", "version")], collapse = " "), 
[18:04:15.743]                             hostname = base::Sys.info()[["nodename"]])
[18:04:15.743]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.743]                             info)
[18:04:15.743]                           info <- base::paste(info, collapse = "; ")
[18:04:15.743]                           if (!has_future) {
[18:04:15.743]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.743]                               info)
[18:04:15.743]                           }
[18:04:15.743]                           else {
[18:04:15.743]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.743]                               info, version)
[18:04:15.743]                           }
[18:04:15.743]                           base::stop(msg)
[18:04:15.743]                         }
[18:04:15.743]                       })
[18:04:15.743]                     }
[18:04:15.743]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:15.743]                     base::options(mc.cores = 1L)
[18:04:15.743]                   }
[18:04:15.743]                   ...future.strategy.old <- future::plan("list")
[18:04:15.743]                   options(future.plan = NULL)
[18:04:15.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.743]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.743]                 }
[18:04:15.743]                 ...future.workdir <- getwd()
[18:04:15.743]             }
[18:04:15.743]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.743]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.743]         }
[18:04:15.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.743]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.743]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.743]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.743]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.743]             base::names(...future.oldOptions))
[18:04:15.743]     }
[18:04:15.743]     if (FALSE) {
[18:04:15.743]     }
[18:04:15.743]     else {
[18:04:15.743]         if (TRUE) {
[18:04:15.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.743]                 open = "w")
[18:04:15.743]         }
[18:04:15.743]         else {
[18:04:15.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.743]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.743]         }
[18:04:15.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.743]             base::sink(type = "output", split = FALSE)
[18:04:15.743]             base::close(...future.stdout)
[18:04:15.743]         }, add = TRUE)
[18:04:15.743]     }
[18:04:15.743]     ...future.frame <- base::sys.nframe()
[18:04:15.743]     ...future.conditions <- base::list()
[18:04:15.743]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.743]     if (FALSE) {
[18:04:15.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.743]     }
[18:04:15.743]     ...future.result <- base::tryCatch({
[18:04:15.743]         base::withCallingHandlers({
[18:04:15.743]             ...future.value <- base::withVisible(base::local({
[18:04:15.743]                 withCallingHandlers({
[18:04:15.743]                   2
[18:04:15.743]                 }, immediateCondition = function(cond) {
[18:04:15.743]                   save_rds <- function (object, pathname, ...) 
[18:04:15.743]                   {
[18:04:15.743]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:15.743]                     if (file_test("-f", pathname_tmp)) {
[18:04:15.743]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.743]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:15.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.743]                         fi_tmp[["mtime"]])
[18:04:15.743]                     }
[18:04:15.743]                     tryCatch({
[18:04:15.743]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:15.743]                     }, error = function(ex) {
[18:04:15.743]                       msg <- conditionMessage(ex)
[18:04:15.743]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.743]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:15.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.743]                         fi_tmp[["mtime"]], msg)
[18:04:15.743]                       ex$message <- msg
[18:04:15.743]                       stop(ex)
[18:04:15.743]                     })
[18:04:15.743]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:15.743]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:15.743]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:15.743]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.743]                       fi <- file.info(pathname)
[18:04:15.743]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:15.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.743]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:15.743]                         fi[["size"]], fi[["mtime"]])
[18:04:15.743]                       stop(msg)
[18:04:15.743]                     }
[18:04:15.743]                     invisible(pathname)
[18:04:15.743]                   }
[18:04:15.743]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:15.743]                     rootPath = tempdir()) 
[18:04:15.743]                   {
[18:04:15.743]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:15.743]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:15.743]                       tmpdir = path, fileext = ".rds")
[18:04:15.743]                     save_rds(obj, file)
[18:04:15.743]                   }
[18:04:15.743]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:15.743]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.743]                   {
[18:04:15.743]                     inherits <- base::inherits
[18:04:15.743]                     invokeRestart <- base::invokeRestart
[18:04:15.743]                     is.null <- base::is.null
[18:04:15.743]                     muffled <- FALSE
[18:04:15.743]                     if (inherits(cond, "message")) {
[18:04:15.743]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:15.743]                       if (muffled) 
[18:04:15.743]                         invokeRestart("muffleMessage")
[18:04:15.743]                     }
[18:04:15.743]                     else if (inherits(cond, "warning")) {
[18:04:15.743]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:15.743]                       if (muffled) 
[18:04:15.743]                         invokeRestart("muffleWarning")
[18:04:15.743]                     }
[18:04:15.743]                     else if (inherits(cond, "condition")) {
[18:04:15.743]                       if (!is.null(pattern)) {
[18:04:15.743]                         computeRestarts <- base::computeRestarts
[18:04:15.743]                         grepl <- base::grepl
[18:04:15.743]                         restarts <- computeRestarts(cond)
[18:04:15.743]                         for (restart in restarts) {
[18:04:15.743]                           name <- restart$name
[18:04:15.743]                           if (is.null(name)) 
[18:04:15.743]                             next
[18:04:15.743]                           if (!grepl(pattern, name)) 
[18:04:15.743]                             next
[18:04:15.743]                           invokeRestart(restart)
[18:04:15.743]                           muffled <- TRUE
[18:04:15.743]                           break
[18:04:15.743]                         }
[18:04:15.743]                       }
[18:04:15.743]                     }
[18:04:15.743]                     invisible(muffled)
[18:04:15.743]                   }
[18:04:15.743]                   muffleCondition(cond)
[18:04:15.743]                 })
[18:04:15.743]             }))
[18:04:15.743]             future::FutureResult(value = ...future.value$value, 
[18:04:15.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.743]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.743]                     ...future.globalenv.names))
[18:04:15.743]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.743]         }, condition = base::local({
[18:04:15.743]             c <- base::c
[18:04:15.743]             inherits <- base::inherits
[18:04:15.743]             invokeRestart <- base::invokeRestart
[18:04:15.743]             length <- base::length
[18:04:15.743]             list <- base::list
[18:04:15.743]             seq.int <- base::seq.int
[18:04:15.743]             signalCondition <- base::signalCondition
[18:04:15.743]             sys.calls <- base::sys.calls
[18:04:15.743]             `[[` <- base::`[[`
[18:04:15.743]             `+` <- base::`+`
[18:04:15.743]             `<<-` <- base::`<<-`
[18:04:15.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.743]                   3L)]
[18:04:15.743]             }
[18:04:15.743]             function(cond) {
[18:04:15.743]                 is_error <- inherits(cond, "error")
[18:04:15.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.743]                   NULL)
[18:04:15.743]                 if (is_error) {
[18:04:15.743]                   sessionInformation <- function() {
[18:04:15.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.743]                       search = base::search(), system = base::Sys.info())
[18:04:15.743]                   }
[18:04:15.743]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.743]                     cond$call), session = sessionInformation(), 
[18:04:15.743]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.743]                   signalCondition(cond)
[18:04:15.743]                 }
[18:04:15.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.743]                 "immediateCondition"))) {
[18:04:15.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.743]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.743]                   if (TRUE && !signal) {
[18:04:15.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.743]                     {
[18:04:15.743]                       inherits <- base::inherits
[18:04:15.743]                       invokeRestart <- base::invokeRestart
[18:04:15.743]                       is.null <- base::is.null
[18:04:15.743]                       muffled <- FALSE
[18:04:15.743]                       if (inherits(cond, "message")) {
[18:04:15.743]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.743]                         if (muffled) 
[18:04:15.743]                           invokeRestart("muffleMessage")
[18:04:15.743]                       }
[18:04:15.743]                       else if (inherits(cond, "warning")) {
[18:04:15.743]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.743]                         if (muffled) 
[18:04:15.743]                           invokeRestart("muffleWarning")
[18:04:15.743]                       }
[18:04:15.743]                       else if (inherits(cond, "condition")) {
[18:04:15.743]                         if (!is.null(pattern)) {
[18:04:15.743]                           computeRestarts <- base::computeRestarts
[18:04:15.743]                           grepl <- base::grepl
[18:04:15.743]                           restarts <- computeRestarts(cond)
[18:04:15.743]                           for (restart in restarts) {
[18:04:15.743]                             name <- restart$name
[18:04:15.743]                             if (is.null(name)) 
[18:04:15.743]                               next
[18:04:15.743]                             if (!grepl(pattern, name)) 
[18:04:15.743]                               next
[18:04:15.743]                             invokeRestart(restart)
[18:04:15.743]                             muffled <- TRUE
[18:04:15.743]                             break
[18:04:15.743]                           }
[18:04:15.743]                         }
[18:04:15.743]                       }
[18:04:15.743]                       invisible(muffled)
[18:04:15.743]                     }
[18:04:15.743]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.743]                   }
[18:04:15.743]                 }
[18:04:15.743]                 else {
[18:04:15.743]                   if (TRUE) {
[18:04:15.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.743]                     {
[18:04:15.743]                       inherits <- base::inherits
[18:04:15.743]                       invokeRestart <- base::invokeRestart
[18:04:15.743]                       is.null <- base::is.null
[18:04:15.743]                       muffled <- FALSE
[18:04:15.743]                       if (inherits(cond, "message")) {
[18:04:15.743]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.743]                         if (muffled) 
[18:04:15.743]                           invokeRestart("muffleMessage")
[18:04:15.743]                       }
[18:04:15.743]                       else if (inherits(cond, "warning")) {
[18:04:15.743]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.743]                         if (muffled) 
[18:04:15.743]                           invokeRestart("muffleWarning")
[18:04:15.743]                       }
[18:04:15.743]                       else if (inherits(cond, "condition")) {
[18:04:15.743]                         if (!is.null(pattern)) {
[18:04:15.743]                           computeRestarts <- base::computeRestarts
[18:04:15.743]                           grepl <- base::grepl
[18:04:15.743]                           restarts <- computeRestarts(cond)
[18:04:15.743]                           for (restart in restarts) {
[18:04:15.743]                             name <- restart$name
[18:04:15.743]                             if (is.null(name)) 
[18:04:15.743]                               next
[18:04:15.743]                             if (!grepl(pattern, name)) 
[18:04:15.743]                               next
[18:04:15.743]                             invokeRestart(restart)
[18:04:15.743]                             muffled <- TRUE
[18:04:15.743]                             break
[18:04:15.743]                           }
[18:04:15.743]                         }
[18:04:15.743]                       }
[18:04:15.743]                       invisible(muffled)
[18:04:15.743]                     }
[18:04:15.743]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.743]                   }
[18:04:15.743]                 }
[18:04:15.743]             }
[18:04:15.743]         }))
[18:04:15.743]     }, error = function(ex) {
[18:04:15.743]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.743]                 ...future.rng), started = ...future.startTime, 
[18:04:15.743]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.743]             version = "1.8"), class = "FutureResult")
[18:04:15.743]     }, finally = {
[18:04:15.743]         if (!identical(...future.workdir, getwd())) 
[18:04:15.743]             setwd(...future.workdir)
[18:04:15.743]         {
[18:04:15.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.743]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.743]             }
[18:04:15.743]             base::options(...future.oldOptions)
[18:04:15.743]             if (.Platform$OS.type == "windows") {
[18:04:15.743]                 old_names <- names(...future.oldEnvVars)
[18:04:15.743]                 envs <- base::Sys.getenv()
[18:04:15.743]                 names <- names(envs)
[18:04:15.743]                 common <- intersect(names, old_names)
[18:04:15.743]                 added <- setdiff(names, old_names)
[18:04:15.743]                 removed <- setdiff(old_names, names)
[18:04:15.743]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.743]                   envs[common]]
[18:04:15.743]                 NAMES <- toupper(changed)
[18:04:15.743]                 args <- list()
[18:04:15.743]                 for (kk in seq_along(NAMES)) {
[18:04:15.743]                   name <- changed[[kk]]
[18:04:15.743]                   NAME <- NAMES[[kk]]
[18:04:15.743]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.743]                     next
[18:04:15.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.743]                 }
[18:04:15.743]                 NAMES <- toupper(added)
[18:04:15.743]                 for (kk in seq_along(NAMES)) {
[18:04:15.743]                   name <- added[[kk]]
[18:04:15.743]                   NAME <- NAMES[[kk]]
[18:04:15.743]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.743]                     next
[18:04:15.743]                   args[[name]] <- ""
[18:04:15.743]                 }
[18:04:15.743]                 NAMES <- toupper(removed)
[18:04:15.743]                 for (kk in seq_along(NAMES)) {
[18:04:15.743]                   name <- removed[[kk]]
[18:04:15.743]                   NAME <- NAMES[[kk]]
[18:04:15.743]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.743]                     next
[18:04:15.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.743]                 }
[18:04:15.743]                 if (length(args) > 0) 
[18:04:15.743]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.743]             }
[18:04:15.743]             else {
[18:04:15.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.743]             }
[18:04:15.743]             {
[18:04:15.743]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.743]                   0L) {
[18:04:15.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.743]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.743]                   base::options(opts)
[18:04:15.743]                 }
[18:04:15.743]                 {
[18:04:15.743]                   {
[18:04:15.743]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:15.743]                     NULL
[18:04:15.743]                   }
[18:04:15.743]                   options(future.plan = NULL)
[18:04:15.743]                   if (is.na(NA_character_)) 
[18:04:15.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.743]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.743]                     .init = FALSE)
[18:04:15.743]                 }
[18:04:15.743]             }
[18:04:15.743]         }
[18:04:15.743]     })
[18:04:15.743]     if (TRUE) {
[18:04:15.743]         base::sink(type = "output", split = FALSE)
[18:04:15.743]         if (TRUE) {
[18:04:15.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.743]         }
[18:04:15.743]         else {
[18:04:15.743]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.743]         }
[18:04:15.743]         base::close(...future.stdout)
[18:04:15.743]         ...future.stdout <- NULL
[18:04:15.743]     }
[18:04:15.743]     ...future.result$conditions <- ...future.conditions
[18:04:15.743]     ...future.result$finished <- base::Sys.time()
[18:04:15.743]     ...future.result
[18:04:15.743] }
[18:04:15.748] requestCore(): workers = 2
[18:04:15.751] MulticoreFuture started
[18:04:15.752] - Launch lazy future ... done
[18:04:15.753] run() for ‘MulticoreFuture’ ... done
[18:04:15.753] plan(): Setting new future strategy stack:
[18:04:15.753] getGlobalsAndPackages() ...
[18:04:15.754] Searching for globals...
[18:04:15.754] List of future strategies:
[18:04:15.754] 1. sequential:
[18:04:15.754]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.754]    - tweaked: FALSE
[18:04:15.754]    - call: NULL
[18:04:15.756] 
[18:04:15.756] plan(): nbrOfWorkers() = 1
[18:04:15.756] Searching for globals ... DONE
[18:04:15.757] - globals: [0] <none>
[18:04:15.757] getGlobalsAndPackages() ... DONE
[18:04:15.758] run() for ‘Future’ ...
[18:04:15.759] - state: ‘created’
[18:04:15.760] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:15.760] plan(): Setting new future strategy stack:
[18:04:15.761] List of future strategies:
[18:04:15.761] 1. multicore:
[18:04:15.761]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:15.761]    - tweaked: FALSE
[18:04:15.761]    - call: plan(strategy)
[18:04:15.769] plan(): nbrOfWorkers() = 2
[18:04:15.769] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:15.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:15.770]   - Field: ‘label’
[18:04:15.770]   - Field: ‘local’
[18:04:15.770]   - Field: ‘owner’
[18:04:15.771]   - Field: ‘envir’
[18:04:15.771]   - Field: ‘workers’
[18:04:15.772]   - Field: ‘packages’
[18:04:15.772]   - Field: ‘gc’
[18:04:15.772]   - Field: ‘job’
[18:04:15.773]   - Field: ‘conditions’
[18:04:15.773]   - Field: ‘expr’
[18:04:15.773]   - Field: ‘uuid’
[18:04:15.774]   - Field: ‘seed’
[18:04:15.774]   - Field: ‘version’
[18:04:15.774]   - Field: ‘result’
[18:04:15.775]   - Field: ‘asynchronous’
[18:04:15.775]   - Field: ‘calls’
[18:04:15.775]   - Field: ‘globals’
[18:04:15.776]   - Field: ‘stdout’
[18:04:15.776]   - Field: ‘earlySignal’
[18:04:15.776]   - Field: ‘lazy’
[18:04:15.777]   - Field: ‘state’
[18:04:15.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:15.777] - Launch lazy future ...
[18:04:15.778] Packages needed by the future expression (n = 0): <none>
[18:04:15.778] Packages needed by future strategies (n = 0): <none>
[18:04:15.780] {
[18:04:15.780]     {
[18:04:15.780]         {
[18:04:15.780]             ...future.startTime <- base::Sys.time()
[18:04:15.780]             {
[18:04:15.780]                 {
[18:04:15.780]                   {
[18:04:15.780]                     {
[18:04:15.780]                       base::local({
[18:04:15.780]                         has_future <- base::requireNamespace("future", 
[18:04:15.780]                           quietly = TRUE)
[18:04:15.780]                         if (has_future) {
[18:04:15.780]                           ns <- base::getNamespace("future")
[18:04:15.780]                           version <- ns[[".package"]][["version"]]
[18:04:15.780]                           if (is.null(version)) 
[18:04:15.780]                             version <- utils::packageVersion("future")
[18:04:15.780]                         }
[18:04:15.780]                         else {
[18:04:15.780]                           version <- NULL
[18:04:15.780]                         }
[18:04:15.780]                         if (!has_future || version < "1.8.0") {
[18:04:15.780]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.780]                             "", base::R.version$version.string), 
[18:04:15.780]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:15.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.780]                               "release", "version")], collapse = " "), 
[18:04:15.780]                             hostname = base::Sys.info()[["nodename"]])
[18:04:15.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.780]                             info)
[18:04:15.780]                           info <- base::paste(info, collapse = "; ")
[18:04:15.780]                           if (!has_future) {
[18:04:15.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.780]                               info)
[18:04:15.780]                           }
[18:04:15.780]                           else {
[18:04:15.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.780]                               info, version)
[18:04:15.780]                           }
[18:04:15.780]                           base::stop(msg)
[18:04:15.780]                         }
[18:04:15.780]                       })
[18:04:15.780]                     }
[18:04:15.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:15.780]                     base::options(mc.cores = 1L)
[18:04:15.780]                   }
[18:04:15.780]                   ...future.strategy.old <- future::plan("list")
[18:04:15.780]                   options(future.plan = NULL)
[18:04:15.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.780]                 }
[18:04:15.780]                 ...future.workdir <- getwd()
[18:04:15.780]             }
[18:04:15.780]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.780]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.780]         }
[18:04:15.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.780]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.780]             base::names(...future.oldOptions))
[18:04:15.780]     }
[18:04:15.780]     if (FALSE) {
[18:04:15.780]     }
[18:04:15.780]     else {
[18:04:15.780]         if (TRUE) {
[18:04:15.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.780]                 open = "w")
[18:04:15.780]         }
[18:04:15.780]         else {
[18:04:15.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.780]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.780]         }
[18:04:15.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.780]             base::sink(type = "output", split = FALSE)
[18:04:15.780]             base::close(...future.stdout)
[18:04:15.780]         }, add = TRUE)
[18:04:15.780]     }
[18:04:15.780]     ...future.frame <- base::sys.nframe()
[18:04:15.780]     ...future.conditions <- base::list()
[18:04:15.780]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.780]     if (FALSE) {
[18:04:15.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.780]     }
[18:04:15.780]     ...future.result <- base::tryCatch({
[18:04:15.780]         base::withCallingHandlers({
[18:04:15.780]             ...future.value <- base::withVisible(base::local({
[18:04:15.780]                 withCallingHandlers({
[18:04:15.780]                   NULL
[18:04:15.780]                 }, immediateCondition = function(cond) {
[18:04:15.780]                   save_rds <- function (object, pathname, ...) 
[18:04:15.780]                   {
[18:04:15.780]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:15.780]                     if (file_test("-f", pathname_tmp)) {
[18:04:15.780]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.780]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:15.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.780]                         fi_tmp[["mtime"]])
[18:04:15.780]                     }
[18:04:15.780]                     tryCatch({
[18:04:15.780]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:15.780]                     }, error = function(ex) {
[18:04:15.780]                       msg <- conditionMessage(ex)
[18:04:15.780]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.780]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:15.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.780]                         fi_tmp[["mtime"]], msg)
[18:04:15.780]                       ex$message <- msg
[18:04:15.780]                       stop(ex)
[18:04:15.780]                     })
[18:04:15.780]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:15.780]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:15.780]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:15.780]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.780]                       fi <- file.info(pathname)
[18:04:15.780]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:15.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.780]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:15.780]                         fi[["size"]], fi[["mtime"]])
[18:04:15.780]                       stop(msg)
[18:04:15.780]                     }
[18:04:15.780]                     invisible(pathname)
[18:04:15.780]                   }
[18:04:15.780]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:15.780]                     rootPath = tempdir()) 
[18:04:15.780]                   {
[18:04:15.780]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:15.780]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:15.780]                       tmpdir = path, fileext = ".rds")
[18:04:15.780]                     save_rds(obj, file)
[18:04:15.780]                   }
[18:04:15.780]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:15.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.780]                   {
[18:04:15.780]                     inherits <- base::inherits
[18:04:15.780]                     invokeRestart <- base::invokeRestart
[18:04:15.780]                     is.null <- base::is.null
[18:04:15.780]                     muffled <- FALSE
[18:04:15.780]                     if (inherits(cond, "message")) {
[18:04:15.780]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:15.780]                       if (muffled) 
[18:04:15.780]                         invokeRestart("muffleMessage")
[18:04:15.780]                     }
[18:04:15.780]                     else if (inherits(cond, "warning")) {
[18:04:15.780]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:15.780]                       if (muffled) 
[18:04:15.780]                         invokeRestart("muffleWarning")
[18:04:15.780]                     }
[18:04:15.780]                     else if (inherits(cond, "condition")) {
[18:04:15.780]                       if (!is.null(pattern)) {
[18:04:15.780]                         computeRestarts <- base::computeRestarts
[18:04:15.780]                         grepl <- base::grepl
[18:04:15.780]                         restarts <- computeRestarts(cond)
[18:04:15.780]                         for (restart in restarts) {
[18:04:15.780]                           name <- restart$name
[18:04:15.780]                           if (is.null(name)) 
[18:04:15.780]                             next
[18:04:15.780]                           if (!grepl(pattern, name)) 
[18:04:15.780]                             next
[18:04:15.780]                           invokeRestart(restart)
[18:04:15.780]                           muffled <- TRUE
[18:04:15.780]                           break
[18:04:15.780]                         }
[18:04:15.780]                       }
[18:04:15.780]                     }
[18:04:15.780]                     invisible(muffled)
[18:04:15.780]                   }
[18:04:15.780]                   muffleCondition(cond)
[18:04:15.780]                 })
[18:04:15.780]             }))
[18:04:15.780]             future::FutureResult(value = ...future.value$value, 
[18:04:15.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.780]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.780]                     ...future.globalenv.names))
[18:04:15.780]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.780]         }, condition = base::local({
[18:04:15.780]             c <- base::c
[18:04:15.780]             inherits <- base::inherits
[18:04:15.780]             invokeRestart <- base::invokeRestart
[18:04:15.780]             length <- base::length
[18:04:15.780]             list <- base::list
[18:04:15.780]             seq.int <- base::seq.int
[18:04:15.780]             signalCondition <- base::signalCondition
[18:04:15.780]             sys.calls <- base::sys.calls
[18:04:15.780]             `[[` <- base::`[[`
[18:04:15.780]             `+` <- base::`+`
[18:04:15.780]             `<<-` <- base::`<<-`
[18:04:15.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.780]                   3L)]
[18:04:15.780]             }
[18:04:15.780]             function(cond) {
[18:04:15.780]                 is_error <- inherits(cond, "error")
[18:04:15.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.780]                   NULL)
[18:04:15.780]                 if (is_error) {
[18:04:15.780]                   sessionInformation <- function() {
[18:04:15.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.780]                       search = base::search(), system = base::Sys.info())
[18:04:15.780]                   }
[18:04:15.780]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.780]                     cond$call), session = sessionInformation(), 
[18:04:15.780]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.780]                   signalCondition(cond)
[18:04:15.780]                 }
[18:04:15.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.780]                 "immediateCondition"))) {
[18:04:15.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.780]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.780]                   if (TRUE && !signal) {
[18:04:15.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.780]                     {
[18:04:15.780]                       inherits <- base::inherits
[18:04:15.780]                       invokeRestart <- base::invokeRestart
[18:04:15.780]                       is.null <- base::is.null
[18:04:15.780]                       muffled <- FALSE
[18:04:15.780]                       if (inherits(cond, "message")) {
[18:04:15.780]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.780]                         if (muffled) 
[18:04:15.780]                           invokeRestart("muffleMessage")
[18:04:15.780]                       }
[18:04:15.780]                       else if (inherits(cond, "warning")) {
[18:04:15.780]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.780]                         if (muffled) 
[18:04:15.780]                           invokeRestart("muffleWarning")
[18:04:15.780]                       }
[18:04:15.780]                       else if (inherits(cond, "condition")) {
[18:04:15.780]                         if (!is.null(pattern)) {
[18:04:15.780]                           computeRestarts <- base::computeRestarts
[18:04:15.780]                           grepl <- base::grepl
[18:04:15.780]                           restarts <- computeRestarts(cond)
[18:04:15.780]                           for (restart in restarts) {
[18:04:15.780]                             name <- restart$name
[18:04:15.780]                             if (is.null(name)) 
[18:04:15.780]                               next
[18:04:15.780]                             if (!grepl(pattern, name)) 
[18:04:15.780]                               next
[18:04:15.780]                             invokeRestart(restart)
[18:04:15.780]                             muffled <- TRUE
[18:04:15.780]                             break
[18:04:15.780]                           }
[18:04:15.780]                         }
[18:04:15.780]                       }
[18:04:15.780]                       invisible(muffled)
[18:04:15.780]                     }
[18:04:15.780]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.780]                   }
[18:04:15.780]                 }
[18:04:15.780]                 else {
[18:04:15.780]                   if (TRUE) {
[18:04:15.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.780]                     {
[18:04:15.780]                       inherits <- base::inherits
[18:04:15.780]                       invokeRestart <- base::invokeRestart
[18:04:15.780]                       is.null <- base::is.null
[18:04:15.780]                       muffled <- FALSE
[18:04:15.780]                       if (inherits(cond, "message")) {
[18:04:15.780]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.780]                         if (muffled) 
[18:04:15.780]                           invokeRestart("muffleMessage")
[18:04:15.780]                       }
[18:04:15.780]                       else if (inherits(cond, "warning")) {
[18:04:15.780]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.780]                         if (muffled) 
[18:04:15.780]                           invokeRestart("muffleWarning")
[18:04:15.780]                       }
[18:04:15.780]                       else if (inherits(cond, "condition")) {
[18:04:15.780]                         if (!is.null(pattern)) {
[18:04:15.780]                           computeRestarts <- base::computeRestarts
[18:04:15.780]                           grepl <- base::grepl
[18:04:15.780]                           restarts <- computeRestarts(cond)
[18:04:15.780]                           for (restart in restarts) {
[18:04:15.780]                             name <- restart$name
[18:04:15.780]                             if (is.null(name)) 
[18:04:15.780]                               next
[18:04:15.780]                             if (!grepl(pattern, name)) 
[18:04:15.780]                               next
[18:04:15.780]                             invokeRestart(restart)
[18:04:15.780]                             muffled <- TRUE
[18:04:15.780]                             break
[18:04:15.780]                           }
[18:04:15.780]                         }
[18:04:15.780]                       }
[18:04:15.780]                       invisible(muffled)
[18:04:15.780]                     }
[18:04:15.780]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.780]                   }
[18:04:15.780]                 }
[18:04:15.780]             }
[18:04:15.780]         }))
[18:04:15.780]     }, error = function(ex) {
[18:04:15.780]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.780]                 ...future.rng), started = ...future.startTime, 
[18:04:15.780]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.780]             version = "1.8"), class = "FutureResult")
[18:04:15.780]     }, finally = {
[18:04:15.780]         if (!identical(...future.workdir, getwd())) 
[18:04:15.780]             setwd(...future.workdir)
[18:04:15.780]         {
[18:04:15.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.780]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.780]             }
[18:04:15.780]             base::options(...future.oldOptions)
[18:04:15.780]             if (.Platform$OS.type == "windows") {
[18:04:15.780]                 old_names <- names(...future.oldEnvVars)
[18:04:15.780]                 envs <- base::Sys.getenv()
[18:04:15.780]                 names <- names(envs)
[18:04:15.780]                 common <- intersect(names, old_names)
[18:04:15.780]                 added <- setdiff(names, old_names)
[18:04:15.780]                 removed <- setdiff(old_names, names)
[18:04:15.780]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.780]                   envs[common]]
[18:04:15.780]                 NAMES <- toupper(changed)
[18:04:15.780]                 args <- list()
[18:04:15.780]                 for (kk in seq_along(NAMES)) {
[18:04:15.780]                   name <- changed[[kk]]
[18:04:15.780]                   NAME <- NAMES[[kk]]
[18:04:15.780]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.780]                     next
[18:04:15.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.780]                 }
[18:04:15.780]                 NAMES <- toupper(added)
[18:04:15.780]                 for (kk in seq_along(NAMES)) {
[18:04:15.780]                   name <- added[[kk]]
[18:04:15.780]                   NAME <- NAMES[[kk]]
[18:04:15.780]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.780]                     next
[18:04:15.780]                   args[[name]] <- ""
[18:04:15.780]                 }
[18:04:15.780]                 NAMES <- toupper(removed)
[18:04:15.780]                 for (kk in seq_along(NAMES)) {
[18:04:15.780]                   name <- removed[[kk]]
[18:04:15.780]                   NAME <- NAMES[[kk]]
[18:04:15.780]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.780]                     next
[18:04:15.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.780]                 }
[18:04:15.780]                 if (length(args) > 0) 
[18:04:15.780]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.780]             }
[18:04:15.780]             else {
[18:04:15.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.780]             }
[18:04:15.780]             {
[18:04:15.780]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.780]                   0L) {
[18:04:15.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.780]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.780]                   base::options(opts)
[18:04:15.780]                 }
[18:04:15.780]                 {
[18:04:15.780]                   {
[18:04:15.780]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:15.780]                     NULL
[18:04:15.780]                   }
[18:04:15.780]                   options(future.plan = NULL)
[18:04:15.780]                   if (is.na(NA_character_)) 
[18:04:15.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.780]                     .init = FALSE)
[18:04:15.780]                 }
[18:04:15.780]             }
[18:04:15.780]         }
[18:04:15.780]     })
[18:04:15.780]     if (TRUE) {
[18:04:15.780]         base::sink(type = "output", split = FALSE)
[18:04:15.780]         if (TRUE) {
[18:04:15.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.780]         }
[18:04:15.780]         else {
[18:04:15.780]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.780]         }
[18:04:15.780]         base::close(...future.stdout)
[18:04:15.780]         ...future.stdout <- NULL
[18:04:15.780]     }
[18:04:15.780]     ...future.result$conditions <- ...future.conditions
[18:04:15.780]     ...future.result$finished <- base::Sys.time()
[18:04:15.780]     ...future.result
[18:04:15.780] }
[18:04:15.788] requestCore(): workers = 2
[18:04:15.791] MulticoreFuture started
[18:04:15.792] - Launch lazy future ... done
[18:04:15.793] run() for ‘MulticoreFuture’ ... done
List of 6
[18:04:15.794] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[18:04:15.794] List of future strategies:
[18:04:15.794] 1. sequential:
[18:04:15.794]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.794]    - tweaked: FALSE
[18:04:15.794]    - call: NULL
[18:04:15.796] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b993258> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c28e7f158> 
 $  : NULL
 $  : NULL
 $  : num 6
[18:04:15.801] plan(): Setting new future strategy stack:
List of 6
 $ a:[18:04:15.801] List of future strategies:
[18:04:15.801] 1. multicore:
[18:04:15.801]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:15.801]    - tweaked: FALSE
[18:04:15.801]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b993258> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c28e7f158> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ :[18:04:15.810] plan(): nbrOfWorkers() = 2
 chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:15.817] resolve() on list ...
[18:04:15.817]  recursive: 0
[18:04:15.818]  length: 6
[18:04:15.818]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:15.818] signalConditionsASAP(numeric, pos=1) ...
[18:04:15.819] - nx: 6
[18:04:15.819] - relay: TRUE
[18:04:15.819] - stdout: TRUE
[18:04:15.819] - signal: TRUE
[18:04:15.820] - resignal: FALSE
[18:04:15.820] - force: TRUE
[18:04:15.820] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.821] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.821]  - until=2
[18:04:15.821]  - relaying element #2
[18:04:15.822] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.822] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.822] signalConditionsASAP(NULL, pos=1) ... done
[18:04:15.823]  length: 5 (resolved future 1)
[18:04:15.823] Future #2
[18:04:15.824] result() for MulticoreFuture ...
[18:04:15.825] result() for MulticoreFuture ...
[18:04:15.826] result() for MulticoreFuture ... done
[18:04:15.826] result() for MulticoreFuture ... done
[18:04:15.827] result() for MulticoreFuture ...
[18:04:15.827] result() for MulticoreFuture ... done
[18:04:15.827] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:15.828] - nx: 6
[18:04:15.828] - relay: TRUE
[18:04:15.828] - stdout: TRUE
[18:04:15.828] - signal: TRUE
[18:04:15.829] - resignal: FALSE
[18:04:15.829] - force: TRUE
[18:04:15.829] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.829] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.830]  - until=2
[18:04:15.830]  - relaying element #2
[18:04:15.830] result() for MulticoreFuture ...
[18:04:15.831] result() for MulticoreFuture ... done
[18:04:15.831] result() for MulticoreFuture ...
[18:04:15.831] result() for MulticoreFuture ... done
[18:04:15.832] result() for MulticoreFuture ...
[18:04:15.832] result() for MulticoreFuture ... done
[18:04:15.832] result() for MulticoreFuture ...
[18:04:15.832] result() for MulticoreFuture ... done
[18:04:15.833] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.833] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.834] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:15.835]  length: 4 (resolved future 2)
[18:04:15.835] Future #3
[18:04:15.836] result() for MulticoreFuture ...
[18:04:15.837] result() for MulticoreFuture ...
[18:04:15.838] result() for MulticoreFuture ... done
[18:04:15.838] result() for MulticoreFuture ... done
[18:04:15.838] result() for MulticoreFuture ...
[18:04:15.838] result() for MulticoreFuture ... done
[18:04:15.839] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:15.839] - nx: 6
[18:04:15.839] - relay: TRUE
[18:04:15.840] - stdout: TRUE
[18:04:15.840] - signal: TRUE
[18:04:15.840] - resignal: FALSE
[18:04:15.840] - force: TRUE
[18:04:15.841] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.841] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:15.841]  - until=3
[18:04:15.845]  - relaying element #3
[18:04:15.845] result() for MulticoreFuture ...
[18:04:15.845] result() for MulticoreFuture ... done
[18:04:15.846] result() for MulticoreFuture ...
[18:04:15.846] result() for MulticoreFuture ... done
[18:04:15.846] result() for MulticoreFuture ...
[18:04:15.847] result() for MulticoreFuture ... done
[18:04:15.847] result() for MulticoreFuture ...
[18:04:15.847] result() for MulticoreFuture ... done
[18:04:15.848] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.848] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.848] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:15.848]  length: 3 (resolved future 3)
[18:04:15.849] signalConditionsASAP(NULL, pos=4) ...
[18:04:15.849] - nx: 6
[18:04:15.849] - relay: TRUE
[18:04:15.849] - stdout: TRUE
[18:04:15.850] - signal: TRUE
[18:04:15.850] - resignal: FALSE
[18:04:15.850] - force: TRUE
[18:04:15.850] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.850] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.851]  - until=5
[18:04:15.851]  - relaying element #5
[18:04:15.851] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.851] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.852] signalConditionsASAP(NULL, pos=4) ... done
[18:04:15.852]  length: 2 (resolved future 4)
[18:04:15.852] signalConditionsASAP(NULL, pos=5) ...
[18:04:15.852] - nx: 6
[18:04:15.852] - relay: TRUE
[18:04:15.853] - stdout: TRUE
[18:04:15.853] - signal: TRUE
[18:04:15.853] - resignal: FALSE
[18:04:15.853] - force: TRUE
[18:04:15.853] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:15.854] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.854]  - until=6
[18:04:15.854]  - relaying element #6
[18:04:15.854] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.855] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.855] signalConditionsASAP(NULL, pos=5) ... done
[18:04:15.855]  length: 1 (resolved future 5)
[18:04:15.855] signalConditionsASAP(numeric, pos=6) ...
[18:04:15.855] - nx: 6
[18:04:15.856] - relay: TRUE
[18:04:15.856] - stdout: TRUE
[18:04:15.856] - signal: TRUE
[18:04:15.856] - resignal: FALSE
[18:04:15.857] - force: TRUE
[18:04:15.857] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:15.857] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.857]  - until=6
[18:04:15.857] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.858] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.858] signalConditionsASAP(numeric, pos=6) ... done
[18:04:15.858]  length: 0 (resolved future 6)
[18:04:15.858] Relaying remaining futures
[18:04:15.858] signalConditionsASAP(NULL, pos=0) ...
[18:04:15.859] - nx: 6
[18:04:15.859] - relay: TRUE
[18:04:15.859] - stdout: TRUE
[18:04:15.859] - signal: TRUE
[18:04:15.859] - resignal: FALSE
[18:04:15.860] - force: TRUE
[18:04:15.860] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.860] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:15.860] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:15.861] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:15.861] signalConditionsASAP(NULL, pos=0) ... done
[18:04:15.861] resolve() on list ... DONE
[18:04:15.861] result() for MulticoreFuture ...
[18:04:15.862] result() for MulticoreFuture ... done
[18:04:15.862] result() for MulticoreFuture ...
[18:04:15.862] result() for MulticoreFuture ... done
[18:04:15.862] result() for MulticoreFuture ...
[18:04:15.862] result() for MulticoreFuture ... done
[18:04:15.863] result() for MulticoreFuture ...
[18:04:15.863] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[18:04:15.870] getGlobalsAndPackages() ...
[18:04:15.870] Searching for globals...
[18:04:15.871] 
[18:04:15.871] Searching for globals ... DONE
[18:04:15.871] - globals: [0] <none>
[18:04:15.871] getGlobalsAndPackages() ... DONE
[18:04:15.872] run() for ‘Future’ ...
[18:04:15.872] - state: ‘created’
[18:04:15.873] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:15.879] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:15.880] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:15.880]   - Field: ‘label’
[18:04:15.880]   - Field: ‘local’
[18:04:15.881]   - Field: ‘owner’
[18:04:15.881]   - Field: ‘envir’
[18:04:15.881]   - Field: ‘workers’
[18:04:15.881]   - Field: ‘packages’
[18:04:15.881]   - Field: ‘gc’
[18:04:15.882]   - Field: ‘job’
[18:04:15.882]   - Field: ‘conditions’
[18:04:15.882]   - Field: ‘expr’
[18:04:15.882]   - Field: ‘uuid’
[18:04:15.882]   - Field: ‘seed’
[18:04:15.883]   - Field: ‘version’
[18:04:15.883]   - Field: ‘result’
[18:04:15.883]   - Field: ‘asynchronous’
[18:04:15.883]   - Field: ‘calls’
[18:04:15.883]   - Field: ‘globals’
[18:04:15.884]   - Field: ‘stdout’
[18:04:15.884]   - Field: ‘earlySignal’
[18:04:15.884]   - Field: ‘lazy’
[18:04:15.884]   - Field: ‘state’
[18:04:15.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:15.885] - Launch lazy future ...
[18:04:15.885] Packages needed by the future expression (n = 0): <none>
[18:04:15.886] Packages needed by future strategies (n = 0): <none>
[18:04:15.887] {
[18:04:15.887]     {
[18:04:15.887]         {
[18:04:15.887]             ...future.startTime <- base::Sys.time()
[18:04:15.887]             {
[18:04:15.887]                 {
[18:04:15.887]                   {
[18:04:15.887]                     {
[18:04:15.887]                       base::local({
[18:04:15.887]                         has_future <- base::requireNamespace("future", 
[18:04:15.887]                           quietly = TRUE)
[18:04:15.887]                         if (has_future) {
[18:04:15.887]                           ns <- base::getNamespace("future")
[18:04:15.887]                           version <- ns[[".package"]][["version"]]
[18:04:15.887]                           if (is.null(version)) 
[18:04:15.887]                             version <- utils::packageVersion("future")
[18:04:15.887]                         }
[18:04:15.887]                         else {
[18:04:15.887]                           version <- NULL
[18:04:15.887]                         }
[18:04:15.887]                         if (!has_future || version < "1.8.0") {
[18:04:15.887]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.887]                             "", base::R.version$version.string), 
[18:04:15.887]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:15.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.887]                               "release", "version")], collapse = " "), 
[18:04:15.887]                             hostname = base::Sys.info()[["nodename"]])
[18:04:15.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.887]                             info)
[18:04:15.887]                           info <- base::paste(info, collapse = "; ")
[18:04:15.887]                           if (!has_future) {
[18:04:15.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.887]                               info)
[18:04:15.887]                           }
[18:04:15.887]                           else {
[18:04:15.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.887]                               info, version)
[18:04:15.887]                           }
[18:04:15.887]                           base::stop(msg)
[18:04:15.887]                         }
[18:04:15.887]                       })
[18:04:15.887]                     }
[18:04:15.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:15.887]                     base::options(mc.cores = 1L)
[18:04:15.887]                   }
[18:04:15.887]                   ...future.strategy.old <- future::plan("list")
[18:04:15.887]                   options(future.plan = NULL)
[18:04:15.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.887]                 }
[18:04:15.887]                 ...future.workdir <- getwd()
[18:04:15.887]             }
[18:04:15.887]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.887]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.887]         }
[18:04:15.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.887]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.887]             base::names(...future.oldOptions))
[18:04:15.887]     }
[18:04:15.887]     if (FALSE) {
[18:04:15.887]     }
[18:04:15.887]     else {
[18:04:15.887]         if (TRUE) {
[18:04:15.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.887]                 open = "w")
[18:04:15.887]         }
[18:04:15.887]         else {
[18:04:15.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.887]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.887]         }
[18:04:15.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.887]             base::sink(type = "output", split = FALSE)
[18:04:15.887]             base::close(...future.stdout)
[18:04:15.887]         }, add = TRUE)
[18:04:15.887]     }
[18:04:15.887]     ...future.frame <- base::sys.nframe()
[18:04:15.887]     ...future.conditions <- base::list()
[18:04:15.887]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.887]     if (FALSE) {
[18:04:15.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.887]     }
[18:04:15.887]     ...future.result <- base::tryCatch({
[18:04:15.887]         base::withCallingHandlers({
[18:04:15.887]             ...future.value <- base::withVisible(base::local({
[18:04:15.887]                 withCallingHandlers({
[18:04:15.887]                   2
[18:04:15.887]                 }, immediateCondition = function(cond) {
[18:04:15.887]                   save_rds <- function (object, pathname, ...) 
[18:04:15.887]                   {
[18:04:15.887]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:15.887]                     if (file_test("-f", pathname_tmp)) {
[18:04:15.887]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.887]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:15.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.887]                         fi_tmp[["mtime"]])
[18:04:15.887]                     }
[18:04:15.887]                     tryCatch({
[18:04:15.887]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:15.887]                     }, error = function(ex) {
[18:04:15.887]                       msg <- conditionMessage(ex)
[18:04:15.887]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.887]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:15.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.887]                         fi_tmp[["mtime"]], msg)
[18:04:15.887]                       ex$message <- msg
[18:04:15.887]                       stop(ex)
[18:04:15.887]                     })
[18:04:15.887]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:15.887]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:15.887]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:15.887]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.887]                       fi <- file.info(pathname)
[18:04:15.887]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:15.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.887]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:15.887]                         fi[["size"]], fi[["mtime"]])
[18:04:15.887]                       stop(msg)
[18:04:15.887]                     }
[18:04:15.887]                     invisible(pathname)
[18:04:15.887]                   }
[18:04:15.887]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:15.887]                     rootPath = tempdir()) 
[18:04:15.887]                   {
[18:04:15.887]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:15.887]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:15.887]                       tmpdir = path, fileext = ".rds")
[18:04:15.887]                     save_rds(obj, file)
[18:04:15.887]                   }
[18:04:15.887]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:15.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.887]                   {
[18:04:15.887]                     inherits <- base::inherits
[18:04:15.887]                     invokeRestart <- base::invokeRestart
[18:04:15.887]                     is.null <- base::is.null
[18:04:15.887]                     muffled <- FALSE
[18:04:15.887]                     if (inherits(cond, "message")) {
[18:04:15.887]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:15.887]                       if (muffled) 
[18:04:15.887]                         invokeRestart("muffleMessage")
[18:04:15.887]                     }
[18:04:15.887]                     else if (inherits(cond, "warning")) {
[18:04:15.887]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:15.887]                       if (muffled) 
[18:04:15.887]                         invokeRestart("muffleWarning")
[18:04:15.887]                     }
[18:04:15.887]                     else if (inherits(cond, "condition")) {
[18:04:15.887]                       if (!is.null(pattern)) {
[18:04:15.887]                         computeRestarts <- base::computeRestarts
[18:04:15.887]                         grepl <- base::grepl
[18:04:15.887]                         restarts <- computeRestarts(cond)
[18:04:15.887]                         for (restart in restarts) {
[18:04:15.887]                           name <- restart$name
[18:04:15.887]                           if (is.null(name)) 
[18:04:15.887]                             next
[18:04:15.887]                           if (!grepl(pattern, name)) 
[18:04:15.887]                             next
[18:04:15.887]                           invokeRestart(restart)
[18:04:15.887]                           muffled <- TRUE
[18:04:15.887]                           break
[18:04:15.887]                         }
[18:04:15.887]                       }
[18:04:15.887]                     }
[18:04:15.887]                     invisible(muffled)
[18:04:15.887]                   }
[18:04:15.887]                   muffleCondition(cond)
[18:04:15.887]                 })
[18:04:15.887]             }))
[18:04:15.887]             future::FutureResult(value = ...future.value$value, 
[18:04:15.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.887]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.887]                     ...future.globalenv.names))
[18:04:15.887]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.887]         }, condition = base::local({
[18:04:15.887]             c <- base::c
[18:04:15.887]             inherits <- base::inherits
[18:04:15.887]             invokeRestart <- base::invokeRestart
[18:04:15.887]             length <- base::length
[18:04:15.887]             list <- base::list
[18:04:15.887]             seq.int <- base::seq.int
[18:04:15.887]             signalCondition <- base::signalCondition
[18:04:15.887]             sys.calls <- base::sys.calls
[18:04:15.887]             `[[` <- base::`[[`
[18:04:15.887]             `+` <- base::`+`
[18:04:15.887]             `<<-` <- base::`<<-`
[18:04:15.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.887]                   3L)]
[18:04:15.887]             }
[18:04:15.887]             function(cond) {
[18:04:15.887]                 is_error <- inherits(cond, "error")
[18:04:15.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.887]                   NULL)
[18:04:15.887]                 if (is_error) {
[18:04:15.887]                   sessionInformation <- function() {
[18:04:15.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.887]                       search = base::search(), system = base::Sys.info())
[18:04:15.887]                   }
[18:04:15.887]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.887]                     cond$call), session = sessionInformation(), 
[18:04:15.887]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.887]                   signalCondition(cond)
[18:04:15.887]                 }
[18:04:15.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.887]                 "immediateCondition"))) {
[18:04:15.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.887]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.887]                   if (TRUE && !signal) {
[18:04:15.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.887]                     {
[18:04:15.887]                       inherits <- base::inherits
[18:04:15.887]                       invokeRestart <- base::invokeRestart
[18:04:15.887]                       is.null <- base::is.null
[18:04:15.887]                       muffled <- FALSE
[18:04:15.887]                       if (inherits(cond, "message")) {
[18:04:15.887]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.887]                         if (muffled) 
[18:04:15.887]                           invokeRestart("muffleMessage")
[18:04:15.887]                       }
[18:04:15.887]                       else if (inherits(cond, "warning")) {
[18:04:15.887]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.887]                         if (muffled) 
[18:04:15.887]                           invokeRestart("muffleWarning")
[18:04:15.887]                       }
[18:04:15.887]                       else if (inherits(cond, "condition")) {
[18:04:15.887]                         if (!is.null(pattern)) {
[18:04:15.887]                           computeRestarts <- base::computeRestarts
[18:04:15.887]                           grepl <- base::grepl
[18:04:15.887]                           restarts <- computeRestarts(cond)
[18:04:15.887]                           for (restart in restarts) {
[18:04:15.887]                             name <- restart$name
[18:04:15.887]                             if (is.null(name)) 
[18:04:15.887]                               next
[18:04:15.887]                             if (!grepl(pattern, name)) 
[18:04:15.887]                               next
[18:04:15.887]                             invokeRestart(restart)
[18:04:15.887]                             muffled <- TRUE
[18:04:15.887]                             break
[18:04:15.887]                           }
[18:04:15.887]                         }
[18:04:15.887]                       }
[18:04:15.887]                       invisible(muffled)
[18:04:15.887]                     }
[18:04:15.887]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.887]                   }
[18:04:15.887]                 }
[18:04:15.887]                 else {
[18:04:15.887]                   if (TRUE) {
[18:04:15.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.887]                     {
[18:04:15.887]                       inherits <- base::inherits
[18:04:15.887]                       invokeRestart <- base::invokeRestart
[18:04:15.887]                       is.null <- base::is.null
[18:04:15.887]                       muffled <- FALSE
[18:04:15.887]                       if (inherits(cond, "message")) {
[18:04:15.887]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.887]                         if (muffled) 
[18:04:15.887]                           invokeRestart("muffleMessage")
[18:04:15.887]                       }
[18:04:15.887]                       else if (inherits(cond, "warning")) {
[18:04:15.887]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.887]                         if (muffled) 
[18:04:15.887]                           invokeRestart("muffleWarning")
[18:04:15.887]                       }
[18:04:15.887]                       else if (inherits(cond, "condition")) {
[18:04:15.887]                         if (!is.null(pattern)) {
[18:04:15.887]                           computeRestarts <- base::computeRestarts
[18:04:15.887]                           grepl <- base::grepl
[18:04:15.887]                           restarts <- computeRestarts(cond)
[18:04:15.887]                           for (restart in restarts) {
[18:04:15.887]                             name <- restart$name
[18:04:15.887]                             if (is.null(name)) 
[18:04:15.887]                               next
[18:04:15.887]                             if (!grepl(pattern, name)) 
[18:04:15.887]                               next
[18:04:15.887]                             invokeRestart(restart)
[18:04:15.887]                             muffled <- TRUE
[18:04:15.887]                             break
[18:04:15.887]                           }
[18:04:15.887]                         }
[18:04:15.887]                       }
[18:04:15.887]                       invisible(muffled)
[18:04:15.887]                     }
[18:04:15.887]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.887]                   }
[18:04:15.887]                 }
[18:04:15.887]             }
[18:04:15.887]         }))
[18:04:15.887]     }, error = function(ex) {
[18:04:15.887]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.887]                 ...future.rng), started = ...future.startTime, 
[18:04:15.887]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.887]             version = "1.8"), class = "FutureResult")
[18:04:15.887]     }, finally = {
[18:04:15.887]         if (!identical(...future.workdir, getwd())) 
[18:04:15.887]             setwd(...future.workdir)
[18:04:15.887]         {
[18:04:15.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.887]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.887]             }
[18:04:15.887]             base::options(...future.oldOptions)
[18:04:15.887]             if (.Platform$OS.type == "windows") {
[18:04:15.887]                 old_names <- names(...future.oldEnvVars)
[18:04:15.887]                 envs <- base::Sys.getenv()
[18:04:15.887]                 names <- names(envs)
[18:04:15.887]                 common <- intersect(names, old_names)
[18:04:15.887]                 added <- setdiff(names, old_names)
[18:04:15.887]                 removed <- setdiff(old_names, names)
[18:04:15.887]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.887]                   envs[common]]
[18:04:15.887]                 NAMES <- toupper(changed)
[18:04:15.887]                 args <- list()
[18:04:15.887]                 for (kk in seq_along(NAMES)) {
[18:04:15.887]                   name <- changed[[kk]]
[18:04:15.887]                   NAME <- NAMES[[kk]]
[18:04:15.887]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.887]                     next
[18:04:15.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.887]                 }
[18:04:15.887]                 NAMES <- toupper(added)
[18:04:15.887]                 for (kk in seq_along(NAMES)) {
[18:04:15.887]                   name <- added[[kk]]
[18:04:15.887]                   NAME <- NAMES[[kk]]
[18:04:15.887]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.887]                     next
[18:04:15.887]                   args[[name]] <- ""
[18:04:15.887]                 }
[18:04:15.887]                 NAMES <- toupper(removed)
[18:04:15.887]                 for (kk in seq_along(NAMES)) {
[18:04:15.887]                   name <- removed[[kk]]
[18:04:15.887]                   NAME <- NAMES[[kk]]
[18:04:15.887]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.887]                     next
[18:04:15.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.887]                 }
[18:04:15.887]                 if (length(args) > 0) 
[18:04:15.887]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.887]             }
[18:04:15.887]             else {
[18:04:15.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.887]             }
[18:04:15.887]             {
[18:04:15.887]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.887]                   0L) {
[18:04:15.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.887]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.887]                   base::options(opts)
[18:04:15.887]                 }
[18:04:15.887]                 {
[18:04:15.887]                   {
[18:04:15.887]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:15.887]                     NULL
[18:04:15.887]                   }
[18:04:15.887]                   options(future.plan = NULL)
[18:04:15.887]                   if (is.na(NA_character_)) 
[18:04:15.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.887]                     .init = FALSE)
[18:04:15.887]                 }
[18:04:15.887]             }
[18:04:15.887]         }
[18:04:15.887]     })
[18:04:15.887]     if (TRUE) {
[18:04:15.887]         base::sink(type = "output", split = FALSE)
[18:04:15.887]         if (TRUE) {
[18:04:15.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.887]         }
[18:04:15.887]         else {
[18:04:15.887]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.887]         }
[18:04:15.887]         base::close(...future.stdout)
[18:04:15.887]         ...future.stdout <- NULL
[18:04:15.887]     }
[18:04:15.887]     ...future.result$conditions <- ...future.conditions
[18:04:15.887]     ...future.result$finished <- base::Sys.time()
[18:04:15.887]     ...future.result
[18:04:15.887] }
[18:04:15.891] requestCore(): workers = 2
[18:04:15.895] MulticoreFuture started
[18:04:15.896] - Launch lazy future ... done
[18:04:15.896] run() for ‘MulticoreFuture’ ... done
[18:04:15.897] getGlobalsAndPackages() ...
[18:04:15.897] Searching for globals...
[18:04:15.899] 
[18:04:15.900] Searching for globals ... DONE
[18:04:15.899] plan(): Setting new future strategy stack:
[18:04:15.900] - globals: [0] <none>
[18:04:15.900] getGlobalsAndPackages() ... DONE
[18:04:15.901] run() for ‘Future’ ...
[18:04:15.902] - state: ‘created’
[18:04:15.902] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:15.900] List of future strategies:
[18:04:15.900] 1. sequential:
[18:04:15.900]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.900]    - tweaked: FALSE
[18:04:15.900]    - call: NULL
[18:04:15.905] plan(): nbrOfWorkers() = 1
[18:04:15.913] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:15.913] plan(): Setting new future strategy stack:
[18:04:15.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:15.914]   - Field: ‘label’
[18:04:15.914]   - Field: ‘local’
[18:04:15.914]   - Field: ‘owner’
[18:04:15.915]   - Field: ‘envir’
[18:04:15.913] List of future strategies:
[18:04:15.913] 1. multicore:
[18:04:15.913]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:15.913]    - tweaked: FALSE
[18:04:15.913]    - call: plan(strategy)
[18:04:15.915]   - Field: ‘workers’
[18:04:15.916]   - Field: ‘packages’
[18:04:15.916]   - Field: ‘gc’
[18:04:15.916]   - Field: ‘job’
[18:04:15.917]   - Field: ‘conditions’
[18:04:15.917]   - Field: ‘expr’
[18:04:15.917]   - Field: ‘uuid’
[18:04:15.918]   - Field: ‘seed’
[18:04:15.918]   - Field: ‘version’
[18:04:15.918]   - Field: ‘result’
[18:04:15.919]   - Field: ‘asynchronous’
[18:04:15.919]   - Field: ‘calls’
[18:04:15.919]   - Field: ‘globals’
[18:04:15.921]   - Field: ‘stdout’
[18:04:15.921]   - Field: ‘earlySignal’
[18:04:15.922]   - Field: ‘lazy’
[18:04:15.922]   - Field: ‘state’
[18:04:15.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:15.923] - Launch lazy future ...
[18:04:15.924] Packages needed by the future expression (n = 0): <none>
[18:04:15.924] Packages needed by future strategies (n = 0): <none>
[18:04:15.928] plan(): nbrOfWorkers() = 2
[18:04:15.926] {
[18:04:15.926]     {
[18:04:15.926]         {
[18:04:15.926]             ...future.startTime <- base::Sys.time()
[18:04:15.926]             {
[18:04:15.926]                 {
[18:04:15.926]                   {
[18:04:15.926]                     {
[18:04:15.926]                       base::local({
[18:04:15.926]                         has_future <- base::requireNamespace("future", 
[18:04:15.926]                           quietly = TRUE)
[18:04:15.926]                         if (has_future) {
[18:04:15.926]                           ns <- base::getNamespace("future")
[18:04:15.926]                           version <- ns[[".package"]][["version"]]
[18:04:15.926]                           if (is.null(version)) 
[18:04:15.926]                             version <- utils::packageVersion("future")
[18:04:15.926]                         }
[18:04:15.926]                         else {
[18:04:15.926]                           version <- NULL
[18:04:15.926]                         }
[18:04:15.926]                         if (!has_future || version < "1.8.0") {
[18:04:15.926]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:15.926]                             "", base::R.version$version.string), 
[18:04:15.926]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:15.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:15.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:15.926]                               "release", "version")], collapse = " "), 
[18:04:15.926]                             hostname = base::Sys.info()[["nodename"]])
[18:04:15.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:15.926]                             info)
[18:04:15.926]                           info <- base::paste(info, collapse = "; ")
[18:04:15.926]                           if (!has_future) {
[18:04:15.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:15.926]                               info)
[18:04:15.926]                           }
[18:04:15.926]                           else {
[18:04:15.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:15.926]                               info, version)
[18:04:15.926]                           }
[18:04:15.926]                           base::stop(msg)
[18:04:15.926]                         }
[18:04:15.926]                       })
[18:04:15.926]                     }
[18:04:15.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:15.926]                     base::options(mc.cores = 1L)
[18:04:15.926]                   }
[18:04:15.926]                   ...future.strategy.old <- future::plan("list")
[18:04:15.926]                   options(future.plan = NULL)
[18:04:15.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:15.926]                 }
[18:04:15.926]                 ...future.workdir <- getwd()
[18:04:15.926]             }
[18:04:15.926]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:15.926]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:15.926]         }
[18:04:15.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:15.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:15.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:15.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:15.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:15.926]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:15.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:15.926]             base::names(...future.oldOptions))
[18:04:15.926]     }
[18:04:15.926]     if (FALSE) {
[18:04:15.926]     }
[18:04:15.926]     else {
[18:04:15.926]         if (TRUE) {
[18:04:15.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:15.926]                 open = "w")
[18:04:15.926]         }
[18:04:15.926]         else {
[18:04:15.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:15.926]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:15.926]         }
[18:04:15.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:15.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:15.926]             base::sink(type = "output", split = FALSE)
[18:04:15.926]             base::close(...future.stdout)
[18:04:15.926]         }, add = TRUE)
[18:04:15.926]     }
[18:04:15.926]     ...future.frame <- base::sys.nframe()
[18:04:15.926]     ...future.conditions <- base::list()
[18:04:15.926]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:15.926]     if (FALSE) {
[18:04:15.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:15.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:15.926]     }
[18:04:15.926]     ...future.result <- base::tryCatch({
[18:04:15.926]         base::withCallingHandlers({
[18:04:15.926]             ...future.value <- base::withVisible(base::local({
[18:04:15.926]                 withCallingHandlers({
[18:04:15.926]                   NULL
[18:04:15.926]                 }, immediateCondition = function(cond) {
[18:04:15.926]                   save_rds <- function (object, pathname, ...) 
[18:04:15.926]                   {
[18:04:15.926]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:15.926]                     if (file_test("-f", pathname_tmp)) {
[18:04:15.926]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.926]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:15.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.926]                         fi_tmp[["mtime"]])
[18:04:15.926]                     }
[18:04:15.926]                     tryCatch({
[18:04:15.926]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:15.926]                     }, error = function(ex) {
[18:04:15.926]                       msg <- conditionMessage(ex)
[18:04:15.926]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.926]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:15.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.926]                         fi_tmp[["mtime"]], msg)
[18:04:15.926]                       ex$message <- msg
[18:04:15.926]                       stop(ex)
[18:04:15.926]                     })
[18:04:15.926]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:15.926]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:15.926]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:15.926]                       fi_tmp <- file.info(pathname_tmp)
[18:04:15.926]                       fi <- file.info(pathname)
[18:04:15.926]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:15.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:15.926]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:15.926]                         fi[["size"]], fi[["mtime"]])
[18:04:15.926]                       stop(msg)
[18:04:15.926]                     }
[18:04:15.926]                     invisible(pathname)
[18:04:15.926]                   }
[18:04:15.926]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:15.926]                     rootPath = tempdir()) 
[18:04:15.926]                   {
[18:04:15.926]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:15.926]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:15.926]                       tmpdir = path, fileext = ".rds")
[18:04:15.926]                     save_rds(obj, file)
[18:04:15.926]                   }
[18:04:15.926]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:15.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.926]                   {
[18:04:15.926]                     inherits <- base::inherits
[18:04:15.926]                     invokeRestart <- base::invokeRestart
[18:04:15.926]                     is.null <- base::is.null
[18:04:15.926]                     muffled <- FALSE
[18:04:15.926]                     if (inherits(cond, "message")) {
[18:04:15.926]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:15.926]                       if (muffled) 
[18:04:15.926]                         invokeRestart("muffleMessage")
[18:04:15.926]                     }
[18:04:15.926]                     else if (inherits(cond, "warning")) {
[18:04:15.926]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:15.926]                       if (muffled) 
[18:04:15.926]                         invokeRestart("muffleWarning")
[18:04:15.926]                     }
[18:04:15.926]                     else if (inherits(cond, "condition")) {
[18:04:15.926]                       if (!is.null(pattern)) {
[18:04:15.926]                         computeRestarts <- base::computeRestarts
[18:04:15.926]                         grepl <- base::grepl
[18:04:15.926]                         restarts <- computeRestarts(cond)
[18:04:15.926]                         for (restart in restarts) {
[18:04:15.926]                           name <- restart$name
[18:04:15.926]                           if (is.null(name)) 
[18:04:15.926]                             next
[18:04:15.926]                           if (!grepl(pattern, name)) 
[18:04:15.926]                             next
[18:04:15.926]                           invokeRestart(restart)
[18:04:15.926]                           muffled <- TRUE
[18:04:15.926]                           break
[18:04:15.926]                         }
[18:04:15.926]                       }
[18:04:15.926]                     }
[18:04:15.926]                     invisible(muffled)
[18:04:15.926]                   }
[18:04:15.926]                   muffleCondition(cond)
[18:04:15.926]                 })
[18:04:15.926]             }))
[18:04:15.926]             future::FutureResult(value = ...future.value$value, 
[18:04:15.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.926]                   ...future.rng), globalenv = if (FALSE) 
[18:04:15.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:15.926]                     ...future.globalenv.names))
[18:04:15.926]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:15.926]         }, condition = base::local({
[18:04:15.926]             c <- base::c
[18:04:15.926]             inherits <- base::inherits
[18:04:15.926]             invokeRestart <- base::invokeRestart
[18:04:15.926]             length <- base::length
[18:04:15.926]             list <- base::list
[18:04:15.926]             seq.int <- base::seq.int
[18:04:15.926]             signalCondition <- base::signalCondition
[18:04:15.926]             sys.calls <- base::sys.calls
[18:04:15.926]             `[[` <- base::`[[`
[18:04:15.926]             `+` <- base::`+`
[18:04:15.926]             `<<-` <- base::`<<-`
[18:04:15.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:15.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:15.926]                   3L)]
[18:04:15.926]             }
[18:04:15.926]             function(cond) {
[18:04:15.926]                 is_error <- inherits(cond, "error")
[18:04:15.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:15.926]                   NULL)
[18:04:15.926]                 if (is_error) {
[18:04:15.926]                   sessionInformation <- function() {
[18:04:15.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:15.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:15.926]                       search = base::search(), system = base::Sys.info())
[18:04:15.926]                   }
[18:04:15.926]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:15.926]                     cond$call), session = sessionInformation(), 
[18:04:15.926]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:15.926]                   signalCondition(cond)
[18:04:15.926]                 }
[18:04:15.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:15.926]                 "immediateCondition"))) {
[18:04:15.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:15.926]                   ...future.conditions[[length(...future.conditions) + 
[18:04:15.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:15.926]                   if (TRUE && !signal) {
[18:04:15.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.926]                     {
[18:04:15.926]                       inherits <- base::inherits
[18:04:15.926]                       invokeRestart <- base::invokeRestart
[18:04:15.926]                       is.null <- base::is.null
[18:04:15.926]                       muffled <- FALSE
[18:04:15.926]                       if (inherits(cond, "message")) {
[18:04:15.926]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.926]                         if (muffled) 
[18:04:15.926]                           invokeRestart("muffleMessage")
[18:04:15.926]                       }
[18:04:15.926]                       else if (inherits(cond, "warning")) {
[18:04:15.926]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.926]                         if (muffled) 
[18:04:15.926]                           invokeRestart("muffleWarning")
[18:04:15.926]                       }
[18:04:15.926]                       else if (inherits(cond, "condition")) {
[18:04:15.926]                         if (!is.null(pattern)) {
[18:04:15.926]                           computeRestarts <- base::computeRestarts
[18:04:15.926]                           grepl <- base::grepl
[18:04:15.926]                           restarts <- computeRestarts(cond)
[18:04:15.926]                           for (restart in restarts) {
[18:04:15.926]                             name <- restart$name
[18:04:15.926]                             if (is.null(name)) 
[18:04:15.926]                               next
[18:04:15.926]                             if (!grepl(pattern, name)) 
[18:04:15.926]                               next
[18:04:15.926]                             invokeRestart(restart)
[18:04:15.926]                             muffled <- TRUE
[18:04:15.926]                             break
[18:04:15.926]                           }
[18:04:15.926]                         }
[18:04:15.926]                       }
[18:04:15.926]                       invisible(muffled)
[18:04:15.926]                     }
[18:04:15.926]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.926]                   }
[18:04:15.926]                 }
[18:04:15.926]                 else {
[18:04:15.926]                   if (TRUE) {
[18:04:15.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:15.926]                     {
[18:04:15.926]                       inherits <- base::inherits
[18:04:15.926]                       invokeRestart <- base::invokeRestart
[18:04:15.926]                       is.null <- base::is.null
[18:04:15.926]                       muffled <- FALSE
[18:04:15.926]                       if (inherits(cond, "message")) {
[18:04:15.926]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:15.926]                         if (muffled) 
[18:04:15.926]                           invokeRestart("muffleMessage")
[18:04:15.926]                       }
[18:04:15.926]                       else if (inherits(cond, "warning")) {
[18:04:15.926]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:15.926]                         if (muffled) 
[18:04:15.926]                           invokeRestart("muffleWarning")
[18:04:15.926]                       }
[18:04:15.926]                       else if (inherits(cond, "condition")) {
[18:04:15.926]                         if (!is.null(pattern)) {
[18:04:15.926]                           computeRestarts <- base::computeRestarts
[18:04:15.926]                           grepl <- base::grepl
[18:04:15.926]                           restarts <- computeRestarts(cond)
[18:04:15.926]                           for (restart in restarts) {
[18:04:15.926]                             name <- restart$name
[18:04:15.926]                             if (is.null(name)) 
[18:04:15.926]                               next
[18:04:15.926]                             if (!grepl(pattern, name)) 
[18:04:15.926]                               next
[18:04:15.926]                             invokeRestart(restart)
[18:04:15.926]                             muffled <- TRUE
[18:04:15.926]                             break
[18:04:15.926]                           }
[18:04:15.926]                         }
[18:04:15.926]                       }
[18:04:15.926]                       invisible(muffled)
[18:04:15.926]                     }
[18:04:15.926]                     muffleCondition(cond, pattern = "^muffle")
[18:04:15.926]                   }
[18:04:15.926]                 }
[18:04:15.926]             }
[18:04:15.926]         }))
[18:04:15.926]     }, error = function(ex) {
[18:04:15.926]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:15.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:15.926]                 ...future.rng), started = ...future.startTime, 
[18:04:15.926]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:15.926]             version = "1.8"), class = "FutureResult")
[18:04:15.926]     }, finally = {
[18:04:15.926]         if (!identical(...future.workdir, getwd())) 
[18:04:15.926]             setwd(...future.workdir)
[18:04:15.926]         {
[18:04:15.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:15.926]                 ...future.oldOptions$nwarnings <- NULL
[18:04:15.926]             }
[18:04:15.926]             base::options(...future.oldOptions)
[18:04:15.926]             if (.Platform$OS.type == "windows") {
[18:04:15.926]                 old_names <- names(...future.oldEnvVars)
[18:04:15.926]                 envs <- base::Sys.getenv()
[18:04:15.926]                 names <- names(envs)
[18:04:15.926]                 common <- intersect(names, old_names)
[18:04:15.926]                 added <- setdiff(names, old_names)
[18:04:15.926]                 removed <- setdiff(old_names, names)
[18:04:15.926]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:15.926]                   envs[common]]
[18:04:15.926]                 NAMES <- toupper(changed)
[18:04:15.926]                 args <- list()
[18:04:15.926]                 for (kk in seq_along(NAMES)) {
[18:04:15.926]                   name <- changed[[kk]]
[18:04:15.926]                   NAME <- NAMES[[kk]]
[18:04:15.926]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.926]                     next
[18:04:15.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.926]                 }
[18:04:15.926]                 NAMES <- toupper(added)
[18:04:15.926]                 for (kk in seq_along(NAMES)) {
[18:04:15.926]                   name <- added[[kk]]
[18:04:15.926]                   NAME <- NAMES[[kk]]
[18:04:15.926]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.926]                     next
[18:04:15.926]                   args[[name]] <- ""
[18:04:15.926]                 }
[18:04:15.926]                 NAMES <- toupper(removed)
[18:04:15.926]                 for (kk in seq_along(NAMES)) {
[18:04:15.926]                   name <- removed[[kk]]
[18:04:15.926]                   NAME <- NAMES[[kk]]
[18:04:15.926]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:15.926]                     next
[18:04:15.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:15.926]                 }
[18:04:15.926]                 if (length(args) > 0) 
[18:04:15.926]                   base::do.call(base::Sys.setenv, args = args)
[18:04:15.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:15.926]             }
[18:04:15.926]             else {
[18:04:15.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:15.926]             }
[18:04:15.926]             {
[18:04:15.926]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:15.926]                   0L) {
[18:04:15.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:15.926]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:15.926]                   base::options(opts)
[18:04:15.926]                 }
[18:04:15.926]                 {
[18:04:15.926]                   {
[18:04:15.926]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:15.926]                     NULL
[18:04:15.926]                   }
[18:04:15.926]                   options(future.plan = NULL)
[18:04:15.926]                   if (is.na(NA_character_)) 
[18:04:15.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:15.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:15.926]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:15.926]                     .init = FALSE)
[18:04:15.926]                 }
[18:04:15.926]             }
[18:04:15.926]         }
[18:04:15.926]     })
[18:04:15.926]     if (TRUE) {
[18:04:15.926]         base::sink(type = "output", split = FALSE)
[18:04:15.926]         if (TRUE) {
[18:04:15.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:15.926]         }
[18:04:15.926]         else {
[18:04:15.926]             ...future.result["stdout"] <- base::list(NULL)
[18:04:15.926]         }
[18:04:15.926]         base::close(...future.stdout)
[18:04:15.926]         ...future.stdout <- NULL
[18:04:15.926]     }
[18:04:15.926]     ...future.result$conditions <- ...future.conditions
[18:04:15.926]     ...future.result$finished <- base::Sys.time()
[18:04:15.926]     ...future.result
[18:04:15.926] }
[18:04:15.933] requestCore(): workers = 2
[18:04:15.937] MulticoreFuture started
[18:04:15.938] - Launch lazy future ... done
[18:04:15.939] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' [18:04:15.943] plan(): Setting new future strategy stack:
<environment: 0x5e3c2accb6e8> 
 $ c:[18:04:15.943] List of future strategies:
[18:04:15.943] 1. sequential:
[18:04:15.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:15.943]    - tweaked: FALSE
[18:04:15.943]    - call: NULL
[18:04:15.950] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b2ffa58> 
 $  : NULL
 $  : NULL
 $  :[18:04:15.961] plan(): Setting new future strategy stack:
 num 6
[18:04:15.961] List of future strategies:
[18:04:15.961] 1. multicore:
[18:04:15.961]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:15.961]    - tweaked: FALSE
[18:04:15.961]    - call: plan(strategy)
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2accb6e8> 
 $ c:[18:04:15.974] plan(): nbrOfWorkers() = 2
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b2ffa58> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:15.990] resolve() on list ...
[18:04:15.991]  recursive: 0
[18:04:15.992]  length: 6
[18:04:15.992]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:15.992] signalConditionsASAP(numeric, pos=1) ...
[18:04:15.993] - nx: 6
[18:04:15.993] - relay: TRUE
[18:04:15.994] - stdout: TRUE
[18:04:15.995] - signal: TRUE
[18:04:15.995] - resignal: FALSE
[18:04:15.995] - force: TRUE
[18:04:15.996] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.997] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:15.999]  - until=2
[18:04:16.000]  - relaying element #2
[18:04:16.000] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.001] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.001] signalConditionsASAP(NULL, pos=1) ... done
[18:04:16.001]  length: 5 (resolved future 1)
[18:04:16.002] Future #2
[18:04:16.002] result() for MulticoreFuture ...
[18:04:16.006] result() for MulticoreFuture ...
[18:04:16.007] result() for MulticoreFuture ... done
[18:04:16.007] result() for MulticoreFuture ... done
[18:04:16.007] result() for MulticoreFuture ...
[18:04:16.008] result() for MulticoreFuture ... done
[18:04:16.008] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:16.008] - nx: 6
[18:04:16.009] - relay: TRUE
[18:04:16.010] - stdout: TRUE
[18:04:16.010] - signal: TRUE
[18:04:16.011] - resignal: FALSE
[18:04:16.011] - force: TRUE
[18:04:16.011] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.012] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.012]  - until=2
[18:04:16.012]  - relaying element #2
[18:04:16.013] result() for MulticoreFuture ...
[18:04:16.013] result() for MulticoreFuture ... done
[18:04:16.013] result() for MulticoreFuture ...
[18:04:16.013] result() for MulticoreFuture ... done
[18:04:16.014] result() for MulticoreFuture ...
[18:04:16.014] result() for MulticoreFuture ... done
[18:04:16.014] result() for MulticoreFuture ...
[18:04:16.015] result() for MulticoreFuture ... done
[18:04:16.015] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.015] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.015] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:16.016]  length: 4 (resolved future 2)
[18:04:16.016] Future #3
[18:04:16.017] result() for MulticoreFuture ...
[18:04:16.020] result() for MulticoreFuture ...
[18:04:16.021] result() for MulticoreFuture ... done
[18:04:16.021] result() for MulticoreFuture ... done
[18:04:16.021] result() for MulticoreFuture ...
[18:04:16.021] result() for MulticoreFuture ... done
[18:04:16.022] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:16.022] - nx: 6
[18:04:16.022] - relay: TRUE
[18:04:16.022] - stdout: TRUE
[18:04:16.023] - signal: TRUE
[18:04:16.023] - resignal: FALSE
[18:04:16.023] - force: TRUE
[18:04:16.023] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.023] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.024]  - until=3
[18:04:16.025]  - relaying element #3
[18:04:16.026] result() for MulticoreFuture ...
[18:04:16.026] result() for MulticoreFuture ... done
[18:04:16.026] result() for MulticoreFuture ...
[18:04:16.026] result() for MulticoreFuture ... done
[18:04:16.027] result() for MulticoreFuture ...
[18:04:16.027] result() for MulticoreFuture ... done
[18:04:16.027] result() for MulticoreFuture ...
[18:04:16.027] result() for MulticoreFuture ... done
[18:04:16.027] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.028] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.028] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:16.028]  length: 3 (resolved future 3)
[18:04:16.028] signalConditionsASAP(NULL, pos=4) ...
[18:04:16.029] - nx: 6
[18:04:16.029] - relay: TRUE
[18:04:16.029] - stdout: TRUE
[18:04:16.029] - signal: TRUE
[18:04:16.029] - resignal: FALSE
[18:04:16.030] - force: TRUE
[18:04:16.030] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.030] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.030]  - until=5
[18:04:16.030]  - relaying element #5
[18:04:16.031] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:16.031] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.031] signalConditionsASAP(NULL, pos=4) ... done
[18:04:16.031]  length: 2 (resolved future 4)
[18:04:16.032] signalConditionsASAP(NULL, pos=5) ...
[18:04:16.032] - nx: 6
[18:04:16.032] - relay: TRUE
[18:04:16.032] - stdout: TRUE
[18:04:16.032] - signal: TRUE
[18:04:16.033] - resignal: FALSE
[18:04:16.033] - force: TRUE
[18:04:16.033] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:16.033] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.034]  - until=6
[18:04:16.034]  - relaying element #6
[18:04:16.034] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:16.034] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.034] signalConditionsASAP(NULL, pos=5) ... done
[18:04:16.035]  length: 1 (resolved future 5)
[18:04:16.035] signalConditionsASAP(numeric, pos=6) ...
[18:04:16.035] - nx: 6
[18:04:16.035] - relay: TRUE
[18:04:16.035] - stdout: TRUE
[18:04:16.036] - signal: TRUE
[18:04:16.036] - resignal: FALSE
[18:04:16.036] - force: TRUE
[18:04:16.036] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:16.036] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.037]  - until=6
[18:04:16.037] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:16.037] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.037] signalConditionsASAP(numeric, pos=6) ... done
[18:04:16.037]  length: 0 (resolved future 6)
[18:04:16.038] Relaying remaining futures
[18:04:16.038] signalConditionsASAP(NULL, pos=0) ...
[18:04:16.038] - nx: 6
[18:04:16.038] - relay: TRUE
[18:04:16.038] - stdout: TRUE
[18:04:16.039] - signal: TRUE
[18:04:16.039] - resignal: FALSE
[18:04:16.039] - force: TRUE
[18:04:16.039] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:16.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:16.040] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:16.040] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.040] signalConditionsASAP(NULL, pos=0) ... done
[18:04:16.040] resolve() on list ... DONE
[18:04:16.041] result() for MulticoreFuture ...
[18:04:16.041] result() for MulticoreFuture ... done
[18:04:16.041] result() for MulticoreFuture ...
[18:04:16.041] result() for MulticoreFuture ... done
[18:04:16.042] result() for MulticoreFuture ...
[18:04:16.042] result() for MulticoreFuture ... done
[18:04:16.042] result() for MulticoreFuture ...
[18:04:16.042] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[18:04:16.054] getGlobalsAndPackages() ...
[18:04:16.054] Searching for globals...
[18:04:16.057] 
[18:04:16.057] Searching for globals ... DONE
[18:04:16.057] - globals: [0] <none>
[18:04:16.058] getGlobalsAndPackages() ... DONE
[18:04:16.058] run() for ‘Future’ ...
[18:04:16.058] - state: ‘created’
[18:04:16.059] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:16.073] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:16.074] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:16.074]   - Field: ‘label’
[18:04:16.074]   - Field: ‘local’
[18:04:16.074]   - Field: ‘owner’
[18:04:16.075]   - Field: ‘envir’
[18:04:16.075]   - Field: ‘workers’
[18:04:16.075]   - Field: ‘packages’
[18:04:16.075]   - Field: ‘gc’
[18:04:16.075]   - Field: ‘job’
[18:04:16.076]   - Field: ‘conditions’
[18:04:16.076]   - Field: ‘expr’
[18:04:16.076]   - Field: ‘uuid’
[18:04:16.076]   - Field: ‘seed’
[18:04:16.077]   - Field: ‘version’
[18:04:16.077]   - Field: ‘result’
[18:04:16.077]   - Field: ‘asynchronous’
[18:04:16.078]   - Field: ‘calls’
[18:04:16.078]   - Field: ‘globals’
[18:04:16.078]   - Field: ‘stdout’
[18:04:16.078]   - Field: ‘earlySignal’
[18:04:16.078]   - Field: ‘lazy’
[18:04:16.079]   - Field: ‘state’
[18:04:16.079] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:16.079] - Launch lazy future ...
[18:04:16.080] Packages needed by the future expression (n = 0): <none>
[18:04:16.080] Packages needed by future strategies (n = 0): <none>
[18:04:16.081] {
[18:04:16.081]     {
[18:04:16.081]         {
[18:04:16.081]             ...future.startTime <- base::Sys.time()
[18:04:16.081]             {
[18:04:16.081]                 {
[18:04:16.081]                   {
[18:04:16.081]                     {
[18:04:16.081]                       base::local({
[18:04:16.081]                         has_future <- base::requireNamespace("future", 
[18:04:16.081]                           quietly = TRUE)
[18:04:16.081]                         if (has_future) {
[18:04:16.081]                           ns <- base::getNamespace("future")
[18:04:16.081]                           version <- ns[[".package"]][["version"]]
[18:04:16.081]                           if (is.null(version)) 
[18:04:16.081]                             version <- utils::packageVersion("future")
[18:04:16.081]                         }
[18:04:16.081]                         else {
[18:04:16.081]                           version <- NULL
[18:04:16.081]                         }
[18:04:16.081]                         if (!has_future || version < "1.8.0") {
[18:04:16.081]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:16.081]                             "", base::R.version$version.string), 
[18:04:16.081]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:16.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:16.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:16.081]                               "release", "version")], collapse = " "), 
[18:04:16.081]                             hostname = base::Sys.info()[["nodename"]])
[18:04:16.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:16.081]                             info)
[18:04:16.081]                           info <- base::paste(info, collapse = "; ")
[18:04:16.081]                           if (!has_future) {
[18:04:16.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:16.081]                               info)
[18:04:16.081]                           }
[18:04:16.081]                           else {
[18:04:16.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:16.081]                               info, version)
[18:04:16.081]                           }
[18:04:16.081]                           base::stop(msg)
[18:04:16.081]                         }
[18:04:16.081]                       })
[18:04:16.081]                     }
[18:04:16.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:16.081]                     base::options(mc.cores = 1L)
[18:04:16.081]                   }
[18:04:16.081]                   ...future.strategy.old <- future::plan("list")
[18:04:16.081]                   options(future.plan = NULL)
[18:04:16.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:16.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:16.081]                 }
[18:04:16.081]                 ...future.workdir <- getwd()
[18:04:16.081]             }
[18:04:16.081]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:16.081]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:16.081]         }
[18:04:16.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:16.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:16.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:16.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:16.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:16.081]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:16.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:16.081]             base::names(...future.oldOptions))
[18:04:16.081]     }
[18:04:16.081]     if (FALSE) {
[18:04:16.081]     }
[18:04:16.081]     else {
[18:04:16.081]         if (TRUE) {
[18:04:16.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:16.081]                 open = "w")
[18:04:16.081]         }
[18:04:16.081]         else {
[18:04:16.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:16.081]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:16.081]         }
[18:04:16.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:16.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:16.081]             base::sink(type = "output", split = FALSE)
[18:04:16.081]             base::close(...future.stdout)
[18:04:16.081]         }, add = TRUE)
[18:04:16.081]     }
[18:04:16.081]     ...future.frame <- base::sys.nframe()
[18:04:16.081]     ...future.conditions <- base::list()
[18:04:16.081]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:16.081]     if (FALSE) {
[18:04:16.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:16.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:16.081]     }
[18:04:16.081]     ...future.result <- base::tryCatch({
[18:04:16.081]         base::withCallingHandlers({
[18:04:16.081]             ...future.value <- base::withVisible(base::local({
[18:04:16.081]                 withCallingHandlers({
[18:04:16.081]                   2
[18:04:16.081]                 }, immediateCondition = function(cond) {
[18:04:16.081]                   save_rds <- function (object, pathname, ...) 
[18:04:16.081]                   {
[18:04:16.081]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:16.081]                     if (file_test("-f", pathname_tmp)) {
[18:04:16.081]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.081]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:16.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.081]                         fi_tmp[["mtime"]])
[18:04:16.081]                     }
[18:04:16.081]                     tryCatch({
[18:04:16.081]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:16.081]                     }, error = function(ex) {
[18:04:16.081]                       msg <- conditionMessage(ex)
[18:04:16.081]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.081]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:16.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.081]                         fi_tmp[["mtime"]], msg)
[18:04:16.081]                       ex$message <- msg
[18:04:16.081]                       stop(ex)
[18:04:16.081]                     })
[18:04:16.081]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:16.081]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:16.081]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:16.081]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.081]                       fi <- file.info(pathname)
[18:04:16.081]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:16.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.081]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:16.081]                         fi[["size"]], fi[["mtime"]])
[18:04:16.081]                       stop(msg)
[18:04:16.081]                     }
[18:04:16.081]                     invisible(pathname)
[18:04:16.081]                   }
[18:04:16.081]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:16.081]                     rootPath = tempdir()) 
[18:04:16.081]                   {
[18:04:16.081]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:16.081]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:16.081]                       tmpdir = path, fileext = ".rds")
[18:04:16.081]                     save_rds(obj, file)
[18:04:16.081]                   }
[18:04:16.081]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:16.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.081]                   {
[18:04:16.081]                     inherits <- base::inherits
[18:04:16.081]                     invokeRestart <- base::invokeRestart
[18:04:16.081]                     is.null <- base::is.null
[18:04:16.081]                     muffled <- FALSE
[18:04:16.081]                     if (inherits(cond, "message")) {
[18:04:16.081]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:16.081]                       if (muffled) 
[18:04:16.081]                         invokeRestart("muffleMessage")
[18:04:16.081]                     }
[18:04:16.081]                     else if (inherits(cond, "warning")) {
[18:04:16.081]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:16.081]                       if (muffled) 
[18:04:16.081]                         invokeRestart("muffleWarning")
[18:04:16.081]                     }
[18:04:16.081]                     else if (inherits(cond, "condition")) {
[18:04:16.081]                       if (!is.null(pattern)) {
[18:04:16.081]                         computeRestarts <- base::computeRestarts
[18:04:16.081]                         grepl <- base::grepl
[18:04:16.081]                         restarts <- computeRestarts(cond)
[18:04:16.081]                         for (restart in restarts) {
[18:04:16.081]                           name <- restart$name
[18:04:16.081]                           if (is.null(name)) 
[18:04:16.081]                             next
[18:04:16.081]                           if (!grepl(pattern, name)) 
[18:04:16.081]                             next
[18:04:16.081]                           invokeRestart(restart)
[18:04:16.081]                           muffled <- TRUE
[18:04:16.081]                           break
[18:04:16.081]                         }
[18:04:16.081]                       }
[18:04:16.081]                     }
[18:04:16.081]                     invisible(muffled)
[18:04:16.081]                   }
[18:04:16.081]                   muffleCondition(cond)
[18:04:16.081]                 })
[18:04:16.081]             }))
[18:04:16.081]             future::FutureResult(value = ...future.value$value, 
[18:04:16.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:16.081]                   ...future.rng), globalenv = if (FALSE) 
[18:04:16.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:16.081]                     ...future.globalenv.names))
[18:04:16.081]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:16.081]         }, condition = base::local({
[18:04:16.081]             c <- base::c
[18:04:16.081]             inherits <- base::inherits
[18:04:16.081]             invokeRestart <- base::invokeRestart
[18:04:16.081]             length <- base::length
[18:04:16.081]             list <- base::list
[18:04:16.081]             seq.int <- base::seq.int
[18:04:16.081]             signalCondition <- base::signalCondition
[18:04:16.081]             sys.calls <- base::sys.calls
[18:04:16.081]             `[[` <- base::`[[`
[18:04:16.081]             `+` <- base::`+`
[18:04:16.081]             `<<-` <- base::`<<-`
[18:04:16.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:16.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:16.081]                   3L)]
[18:04:16.081]             }
[18:04:16.081]             function(cond) {
[18:04:16.081]                 is_error <- inherits(cond, "error")
[18:04:16.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:16.081]                   NULL)
[18:04:16.081]                 if (is_error) {
[18:04:16.081]                   sessionInformation <- function() {
[18:04:16.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:16.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:16.081]                       search = base::search(), system = base::Sys.info())
[18:04:16.081]                   }
[18:04:16.081]                   ...future.conditions[[length(...future.conditions) + 
[18:04:16.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:16.081]                     cond$call), session = sessionInformation(), 
[18:04:16.081]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:16.081]                   signalCondition(cond)
[18:04:16.081]                 }
[18:04:16.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:16.081]                 "immediateCondition"))) {
[18:04:16.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:16.081]                   ...future.conditions[[length(...future.conditions) + 
[18:04:16.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:16.081]                   if (TRUE && !signal) {
[18:04:16.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.081]                     {
[18:04:16.081]                       inherits <- base::inherits
[18:04:16.081]                       invokeRestart <- base::invokeRestart
[18:04:16.081]                       is.null <- base::is.null
[18:04:16.081]                       muffled <- FALSE
[18:04:16.081]                       if (inherits(cond, "message")) {
[18:04:16.081]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:16.081]                         if (muffled) 
[18:04:16.081]                           invokeRestart("muffleMessage")
[18:04:16.081]                       }
[18:04:16.081]                       else if (inherits(cond, "warning")) {
[18:04:16.081]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:16.081]                         if (muffled) 
[18:04:16.081]                           invokeRestart("muffleWarning")
[18:04:16.081]                       }
[18:04:16.081]                       else if (inherits(cond, "condition")) {
[18:04:16.081]                         if (!is.null(pattern)) {
[18:04:16.081]                           computeRestarts <- base::computeRestarts
[18:04:16.081]                           grepl <- base::grepl
[18:04:16.081]                           restarts <- computeRestarts(cond)
[18:04:16.081]                           for (restart in restarts) {
[18:04:16.081]                             name <- restart$name
[18:04:16.081]                             if (is.null(name)) 
[18:04:16.081]                               next
[18:04:16.081]                             if (!grepl(pattern, name)) 
[18:04:16.081]                               next
[18:04:16.081]                             invokeRestart(restart)
[18:04:16.081]                             muffled <- TRUE
[18:04:16.081]                             break
[18:04:16.081]                           }
[18:04:16.081]                         }
[18:04:16.081]                       }
[18:04:16.081]                       invisible(muffled)
[18:04:16.081]                     }
[18:04:16.081]                     muffleCondition(cond, pattern = "^muffle")
[18:04:16.081]                   }
[18:04:16.081]                 }
[18:04:16.081]                 else {
[18:04:16.081]                   if (TRUE) {
[18:04:16.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.081]                     {
[18:04:16.081]                       inherits <- base::inherits
[18:04:16.081]                       invokeRestart <- base::invokeRestart
[18:04:16.081]                       is.null <- base::is.null
[18:04:16.081]                       muffled <- FALSE
[18:04:16.081]                       if (inherits(cond, "message")) {
[18:04:16.081]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:16.081]                         if (muffled) 
[18:04:16.081]                           invokeRestart("muffleMessage")
[18:04:16.081]                       }
[18:04:16.081]                       else if (inherits(cond, "warning")) {
[18:04:16.081]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:16.081]                         if (muffled) 
[18:04:16.081]                           invokeRestart("muffleWarning")
[18:04:16.081]                       }
[18:04:16.081]                       else if (inherits(cond, "condition")) {
[18:04:16.081]                         if (!is.null(pattern)) {
[18:04:16.081]                           computeRestarts <- base::computeRestarts
[18:04:16.081]                           grepl <- base::grepl
[18:04:16.081]                           restarts <- computeRestarts(cond)
[18:04:16.081]                           for (restart in restarts) {
[18:04:16.081]                             name <- restart$name
[18:04:16.081]                             if (is.null(name)) 
[18:04:16.081]                               next
[18:04:16.081]                             if (!grepl(pattern, name)) 
[18:04:16.081]                               next
[18:04:16.081]                             invokeRestart(restart)
[18:04:16.081]                             muffled <- TRUE
[18:04:16.081]                             break
[18:04:16.081]                           }
[18:04:16.081]                         }
[18:04:16.081]                       }
[18:04:16.081]                       invisible(muffled)
[18:04:16.081]                     }
[18:04:16.081]                     muffleCondition(cond, pattern = "^muffle")
[18:04:16.081]                   }
[18:04:16.081]                 }
[18:04:16.081]             }
[18:04:16.081]         }))
[18:04:16.081]     }, error = function(ex) {
[18:04:16.081]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:16.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:16.081]                 ...future.rng), started = ...future.startTime, 
[18:04:16.081]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:16.081]             version = "1.8"), class = "FutureResult")
[18:04:16.081]     }, finally = {
[18:04:16.081]         if (!identical(...future.workdir, getwd())) 
[18:04:16.081]             setwd(...future.workdir)
[18:04:16.081]         {
[18:04:16.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:16.081]                 ...future.oldOptions$nwarnings <- NULL
[18:04:16.081]             }
[18:04:16.081]             base::options(...future.oldOptions)
[18:04:16.081]             if (.Platform$OS.type == "windows") {
[18:04:16.081]                 old_names <- names(...future.oldEnvVars)
[18:04:16.081]                 envs <- base::Sys.getenv()
[18:04:16.081]                 names <- names(envs)
[18:04:16.081]                 common <- intersect(names, old_names)
[18:04:16.081]                 added <- setdiff(names, old_names)
[18:04:16.081]                 removed <- setdiff(old_names, names)
[18:04:16.081]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:16.081]                   envs[common]]
[18:04:16.081]                 NAMES <- toupper(changed)
[18:04:16.081]                 args <- list()
[18:04:16.081]                 for (kk in seq_along(NAMES)) {
[18:04:16.081]                   name <- changed[[kk]]
[18:04:16.081]                   NAME <- NAMES[[kk]]
[18:04:16.081]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.081]                     next
[18:04:16.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:16.081]                 }
[18:04:16.081]                 NAMES <- toupper(added)
[18:04:16.081]                 for (kk in seq_along(NAMES)) {
[18:04:16.081]                   name <- added[[kk]]
[18:04:16.081]                   NAME <- NAMES[[kk]]
[18:04:16.081]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.081]                     next
[18:04:16.081]                   args[[name]] <- ""
[18:04:16.081]                 }
[18:04:16.081]                 NAMES <- toupper(removed)
[18:04:16.081]                 for (kk in seq_along(NAMES)) {
[18:04:16.081]                   name <- removed[[kk]]
[18:04:16.081]                   NAME <- NAMES[[kk]]
[18:04:16.081]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.081]                     next
[18:04:16.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:16.081]                 }
[18:04:16.081]                 if (length(args) > 0) 
[18:04:16.081]                   base::do.call(base::Sys.setenv, args = args)
[18:04:16.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:16.081]             }
[18:04:16.081]             else {
[18:04:16.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:16.081]             }
[18:04:16.081]             {
[18:04:16.081]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:16.081]                   0L) {
[18:04:16.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:16.081]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:16.081]                   base::options(opts)
[18:04:16.081]                 }
[18:04:16.081]                 {
[18:04:16.081]                   {
[18:04:16.081]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:16.081]                     NULL
[18:04:16.081]                   }
[18:04:16.081]                   options(future.plan = NULL)
[18:04:16.081]                   if (is.na(NA_character_)) 
[18:04:16.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:16.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:16.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:16.081]                     .init = FALSE)
[18:04:16.081]                 }
[18:04:16.081]             }
[18:04:16.081]         }
[18:04:16.081]     })
[18:04:16.081]     if (TRUE) {
[18:04:16.081]         base::sink(type = "output", split = FALSE)
[18:04:16.081]         if (TRUE) {
[18:04:16.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:16.081]         }
[18:04:16.081]         else {
[18:04:16.081]             ...future.result["stdout"] <- base::list(NULL)
[18:04:16.081]         }
[18:04:16.081]         base::close(...future.stdout)
[18:04:16.081]         ...future.stdout <- NULL
[18:04:16.081]     }
[18:04:16.081]     ...future.result$conditions <- ...future.conditions
[18:04:16.081]     ...future.result$finished <- base::Sys.time()
[18:04:16.081]     ...future.result
[18:04:16.081] }
[18:04:16.085] requestCore(): workers = 2
[18:04:16.091] MulticoreFuture started
[18:04:16.092] - Launch lazy future ... done
[18:04:16.094] plan(): Setting new future strategy stack:
[18:04:16.092] run() for ‘MulticoreFuture’ ... done
[18:04:16.095] getGlobalsAndPackages() ...
[18:04:16.096] Searching for globals...
[18:04:16.094] List of future strategies:
[18:04:16.094] 1. sequential:
[18:04:16.094]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:16.094]    - tweaked: FALSE
[18:04:16.094]    - call: NULL
[18:04:16.099] 
[18:04:16.100] Searching for globals ... DONE
[18:04:16.101] plan(): nbrOfWorkers() = 1
[18:04:16.100] - globals: [0] <none>
[18:04:16.103] getGlobalsAndPackages() ... DONE
[18:04:16.104] run() for ‘Future’ ...
[18:04:16.105] - state: ‘created’
[18:04:16.107] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:16.107] plan(): Setting new future strategy stack:
[18:04:16.111] List of future strategies:
[18:04:16.111] 1. multicore:
[18:04:16.111]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:16.111]    - tweaked: FALSE
[18:04:16.111]    - call: plan(strategy)
[18:04:16.131] plan(): nbrOfWorkers() = 2
[18:04:16.132] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:16.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:16.134]   - Field: ‘label’
[18:04:16.134]   - Field: ‘local’
[18:04:16.135]   - Field: ‘owner’
[18:04:16.136]   - Field: ‘envir’
[18:04:16.137]   - Field: ‘workers’
[18:04:16.137]   - Field: ‘packages’
[18:04:16.138]   - Field: ‘gc’
[18:04:16.138]   - Field: ‘job’
[18:04:16.139]   - Field: ‘conditions’
[18:04:16.139]   - Field: ‘expr’
[18:04:16.139]   - Field: ‘uuid’
[18:04:16.140]   - Field: ‘seed’
[18:04:16.140]   - Field: ‘version’
[18:04:16.141]   - Field: ‘result’
[18:04:16.141]   - Field: ‘asynchronous’
[18:04:16.141]   - Field: ‘calls’
[18:04:16.142]   - Field: ‘globals’
[18:04:16.142]   - Field: ‘stdout’
[18:04:16.142]   - Field: ‘earlySignal’
[18:04:16.143]   - Field: ‘lazy’
[18:04:16.143]   - Field: ‘state’
[18:04:16.143] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:16.144] - Launch lazy future ...
[18:04:16.145] Packages needed by the future expression (n = 0): <none>
[18:04:16.145] Packages needed by future strategies (n = 0): <none>
[18:04:16.146] {
[18:04:16.146]     {
[18:04:16.146]         {
[18:04:16.146]             ...future.startTime <- base::Sys.time()
[18:04:16.146]             {
[18:04:16.146]                 {
[18:04:16.146]                   {
[18:04:16.146]                     {
[18:04:16.146]                       base::local({
[18:04:16.146]                         has_future <- base::requireNamespace("future", 
[18:04:16.146]                           quietly = TRUE)
[18:04:16.146]                         if (has_future) {
[18:04:16.146]                           ns <- base::getNamespace("future")
[18:04:16.146]                           version <- ns[[".package"]][["version"]]
[18:04:16.146]                           if (is.null(version)) 
[18:04:16.146]                             version <- utils::packageVersion("future")
[18:04:16.146]                         }
[18:04:16.146]                         else {
[18:04:16.146]                           version <- NULL
[18:04:16.146]                         }
[18:04:16.146]                         if (!has_future || version < "1.8.0") {
[18:04:16.146]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:16.146]                             "", base::R.version$version.string), 
[18:04:16.146]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:16.146]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:16.146]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:16.146]                               "release", "version")], collapse = " "), 
[18:04:16.146]                             hostname = base::Sys.info()[["nodename"]])
[18:04:16.146]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:16.146]                             info)
[18:04:16.146]                           info <- base::paste(info, collapse = "; ")
[18:04:16.146]                           if (!has_future) {
[18:04:16.146]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:16.146]                               info)
[18:04:16.146]                           }
[18:04:16.146]                           else {
[18:04:16.146]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:16.146]                               info, version)
[18:04:16.146]                           }
[18:04:16.146]                           base::stop(msg)
[18:04:16.146]                         }
[18:04:16.146]                       })
[18:04:16.146]                     }
[18:04:16.146]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:16.146]                     base::options(mc.cores = 1L)
[18:04:16.146]                   }
[18:04:16.146]                   ...future.strategy.old <- future::plan("list")
[18:04:16.146]                   options(future.plan = NULL)
[18:04:16.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:16.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:16.146]                 }
[18:04:16.146]                 ...future.workdir <- getwd()
[18:04:16.146]             }
[18:04:16.146]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:16.146]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:16.146]         }
[18:04:16.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:16.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:16.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:16.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:16.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:16.146]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:16.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:16.146]             base::names(...future.oldOptions))
[18:04:16.146]     }
[18:04:16.146]     if (FALSE) {
[18:04:16.146]     }
[18:04:16.146]     else {
[18:04:16.146]         if (TRUE) {
[18:04:16.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:16.146]                 open = "w")
[18:04:16.146]         }
[18:04:16.146]         else {
[18:04:16.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:16.146]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:16.146]         }
[18:04:16.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:16.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:16.146]             base::sink(type = "output", split = FALSE)
[18:04:16.146]             base::close(...future.stdout)
[18:04:16.146]         }, add = TRUE)
[18:04:16.146]     }
[18:04:16.146]     ...future.frame <- base::sys.nframe()
[18:04:16.146]     ...future.conditions <- base::list()
[18:04:16.146]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:16.146]     if (FALSE) {
[18:04:16.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:16.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:16.146]     }
[18:04:16.146]     ...future.result <- base::tryCatch({
[18:04:16.146]         base::withCallingHandlers({
[18:04:16.146]             ...future.value <- base::withVisible(base::local({
[18:04:16.146]                 withCallingHandlers({
[18:04:16.146]                   NULL
[18:04:16.146]                 }, immediateCondition = function(cond) {
[18:04:16.146]                   save_rds <- function (object, pathname, ...) 
[18:04:16.146]                   {
[18:04:16.146]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:16.146]                     if (file_test("-f", pathname_tmp)) {
[18:04:16.146]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.146]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:16.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.146]                         fi_tmp[["mtime"]])
[18:04:16.146]                     }
[18:04:16.146]                     tryCatch({
[18:04:16.146]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:16.146]                     }, error = function(ex) {
[18:04:16.146]                       msg <- conditionMessage(ex)
[18:04:16.146]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.146]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:16.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.146]                         fi_tmp[["mtime"]], msg)
[18:04:16.146]                       ex$message <- msg
[18:04:16.146]                       stop(ex)
[18:04:16.146]                     })
[18:04:16.146]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:16.146]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:16.146]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:16.146]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.146]                       fi <- file.info(pathname)
[18:04:16.146]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:16.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.146]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:16.146]                         fi[["size"]], fi[["mtime"]])
[18:04:16.146]                       stop(msg)
[18:04:16.146]                     }
[18:04:16.146]                     invisible(pathname)
[18:04:16.146]                   }
[18:04:16.146]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:16.146]                     rootPath = tempdir()) 
[18:04:16.146]                   {
[18:04:16.146]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:16.146]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:16.146]                       tmpdir = path, fileext = ".rds")
[18:04:16.146]                     save_rds(obj, file)
[18:04:16.146]                   }
[18:04:16.146]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:16.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.146]                   {
[18:04:16.146]                     inherits <- base::inherits
[18:04:16.146]                     invokeRestart <- base::invokeRestart
[18:04:16.146]                     is.null <- base::is.null
[18:04:16.146]                     muffled <- FALSE
[18:04:16.146]                     if (inherits(cond, "message")) {
[18:04:16.146]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:16.146]                       if (muffled) 
[18:04:16.146]                         invokeRestart("muffleMessage")
[18:04:16.146]                     }
[18:04:16.146]                     else if (inherits(cond, "warning")) {
[18:04:16.146]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:16.146]                       if (muffled) 
[18:04:16.146]                         invokeRestart("muffleWarning")
[18:04:16.146]                     }
[18:04:16.146]                     else if (inherits(cond, "condition")) {
[18:04:16.146]                       if (!is.null(pattern)) {
[18:04:16.146]                         computeRestarts <- base::computeRestarts
[18:04:16.146]                         grepl <- base::grepl
[18:04:16.146]                         restarts <- computeRestarts(cond)
[18:04:16.146]                         for (restart in restarts) {
[18:04:16.146]                           name <- restart$name
[18:04:16.146]                           if (is.null(name)) 
[18:04:16.146]                             next
[18:04:16.146]                           if (!grepl(pattern, name)) 
[18:04:16.146]                             next
[18:04:16.146]                           invokeRestart(restart)
[18:04:16.146]                           muffled <- TRUE
[18:04:16.146]                           break
[18:04:16.146]                         }
[18:04:16.146]                       }
[18:04:16.146]                     }
[18:04:16.146]                     invisible(muffled)
[18:04:16.146]                   }
[18:04:16.146]                   muffleCondition(cond)
[18:04:16.146]                 })
[18:04:16.146]             }))
[18:04:16.146]             future::FutureResult(value = ...future.value$value, 
[18:04:16.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:16.146]                   ...future.rng), globalenv = if (FALSE) 
[18:04:16.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:16.146]                     ...future.globalenv.names))
[18:04:16.146]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:16.146]         }, condition = base::local({
[18:04:16.146]             c <- base::c
[18:04:16.146]             inherits <- base::inherits
[18:04:16.146]             invokeRestart <- base::invokeRestart
[18:04:16.146]             length <- base::length
[18:04:16.146]             list <- base::list
[18:04:16.146]             seq.int <- base::seq.int
[18:04:16.146]             signalCondition <- base::signalCondition
[18:04:16.146]             sys.calls <- base::sys.calls
[18:04:16.146]             `[[` <- base::`[[`
[18:04:16.146]             `+` <- base::`+`
[18:04:16.146]             `<<-` <- base::`<<-`
[18:04:16.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:16.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:16.146]                   3L)]
[18:04:16.146]             }
[18:04:16.146]             function(cond) {
[18:04:16.146]                 is_error <- inherits(cond, "error")
[18:04:16.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:16.146]                   NULL)
[18:04:16.146]                 if (is_error) {
[18:04:16.146]                   sessionInformation <- function() {
[18:04:16.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:16.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:16.146]                       search = base::search(), system = base::Sys.info())
[18:04:16.146]                   }
[18:04:16.146]                   ...future.conditions[[length(...future.conditions) + 
[18:04:16.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:16.146]                     cond$call), session = sessionInformation(), 
[18:04:16.146]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:16.146]                   signalCondition(cond)
[18:04:16.146]                 }
[18:04:16.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:16.146]                 "immediateCondition"))) {
[18:04:16.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:16.146]                   ...future.conditions[[length(...future.conditions) + 
[18:04:16.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:16.146]                   if (TRUE && !signal) {
[18:04:16.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.146]                     {
[18:04:16.146]                       inherits <- base::inherits
[18:04:16.146]                       invokeRestart <- base::invokeRestart
[18:04:16.146]                       is.null <- base::is.null
[18:04:16.146]                       muffled <- FALSE
[18:04:16.146]                       if (inherits(cond, "message")) {
[18:04:16.146]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:16.146]                         if (muffled) 
[18:04:16.146]                           invokeRestart("muffleMessage")
[18:04:16.146]                       }
[18:04:16.146]                       else if (inherits(cond, "warning")) {
[18:04:16.146]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:16.146]                         if (muffled) 
[18:04:16.146]                           invokeRestart("muffleWarning")
[18:04:16.146]                       }
[18:04:16.146]                       else if (inherits(cond, "condition")) {
[18:04:16.146]                         if (!is.null(pattern)) {
[18:04:16.146]                           computeRestarts <- base::computeRestarts
[18:04:16.146]                           grepl <- base::grepl
[18:04:16.146]                           restarts <- computeRestarts(cond)
[18:04:16.146]                           for (restart in restarts) {
[18:04:16.146]                             name <- restart$name
[18:04:16.146]                             if (is.null(name)) 
[18:04:16.146]                               next
[18:04:16.146]                             if (!grepl(pattern, name)) 
[18:04:16.146]                               next
[18:04:16.146]                             invokeRestart(restart)
[18:04:16.146]                             muffled <- TRUE
[18:04:16.146]                             break
[18:04:16.146]                           }
[18:04:16.146]                         }
[18:04:16.146]                       }
[18:04:16.146]                       invisible(muffled)
[18:04:16.146]                     }
[18:04:16.146]                     muffleCondition(cond, pattern = "^muffle")
[18:04:16.146]                   }
[18:04:16.146]                 }
[18:04:16.146]                 else {
[18:04:16.146]                   if (TRUE) {
[18:04:16.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.146]                     {
[18:04:16.146]                       inherits <- base::inherits
[18:04:16.146]                       invokeRestart <- base::invokeRestart
[18:04:16.146]                       is.null <- base::is.null
[18:04:16.146]                       muffled <- FALSE
[18:04:16.146]                       if (inherits(cond, "message")) {
[18:04:16.146]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:16.146]                         if (muffled) 
[18:04:16.146]                           invokeRestart("muffleMessage")
[18:04:16.146]                       }
[18:04:16.146]                       else if (inherits(cond, "warning")) {
[18:04:16.146]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:16.146]                         if (muffled) 
[18:04:16.146]                           invokeRestart("muffleWarning")
[18:04:16.146]                       }
[18:04:16.146]                       else if (inherits(cond, "condition")) {
[18:04:16.146]                         if (!is.null(pattern)) {
[18:04:16.146]                           computeRestarts <- base::computeRestarts
[18:04:16.146]                           grepl <- base::grepl
[18:04:16.146]                           restarts <- computeRestarts(cond)
[18:04:16.146]                           for (restart in restarts) {
[18:04:16.146]                             name <- restart$name
[18:04:16.146]                             if (is.null(name)) 
[18:04:16.146]                               next
[18:04:16.146]                             if (!grepl(pattern, name)) 
[18:04:16.146]                               next
[18:04:16.146]                             invokeRestart(restart)
[18:04:16.146]                             muffled <- TRUE
[18:04:16.146]                             break
[18:04:16.146]                           }
[18:04:16.146]                         }
[18:04:16.146]                       }
[18:04:16.146]                       invisible(muffled)
[18:04:16.146]                     }
[18:04:16.146]                     muffleCondition(cond, pattern = "^muffle")
[18:04:16.146]                   }
[18:04:16.146]                 }
[18:04:16.146]             }
[18:04:16.146]         }))
[18:04:16.146]     }, error = function(ex) {
[18:04:16.146]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:16.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:16.146]                 ...future.rng), started = ...future.startTime, 
[18:04:16.146]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:16.146]             version = "1.8"), class = "FutureResult")
[18:04:16.146]     }, finally = {
[18:04:16.146]         if (!identical(...future.workdir, getwd())) 
[18:04:16.146]             setwd(...future.workdir)
[18:04:16.146]         {
[18:04:16.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:16.146]                 ...future.oldOptions$nwarnings <- NULL
[18:04:16.146]             }
[18:04:16.146]             base::options(...future.oldOptions)
[18:04:16.146]             if (.Platform$OS.type == "windows") {
[18:04:16.146]                 old_names <- names(...future.oldEnvVars)
[18:04:16.146]                 envs <- base::Sys.getenv()
[18:04:16.146]                 names <- names(envs)
[18:04:16.146]                 common <- intersect(names, old_names)
[18:04:16.146]                 added <- setdiff(names, old_names)
[18:04:16.146]                 removed <- setdiff(old_names, names)
[18:04:16.146]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:16.146]                   envs[common]]
[18:04:16.146]                 NAMES <- toupper(changed)
[18:04:16.146]                 args <- list()
[18:04:16.146]                 for (kk in seq_along(NAMES)) {
[18:04:16.146]                   name <- changed[[kk]]
[18:04:16.146]                   NAME <- NAMES[[kk]]
[18:04:16.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.146]                     next
[18:04:16.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:16.146]                 }
[18:04:16.146]                 NAMES <- toupper(added)
[18:04:16.146]                 for (kk in seq_along(NAMES)) {
[18:04:16.146]                   name <- added[[kk]]
[18:04:16.146]                   NAME <- NAMES[[kk]]
[18:04:16.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.146]                     next
[18:04:16.146]                   args[[name]] <- ""
[18:04:16.146]                 }
[18:04:16.146]                 NAMES <- toupper(removed)
[18:04:16.146]                 for (kk in seq_along(NAMES)) {
[18:04:16.146]                   name <- removed[[kk]]
[18:04:16.146]                   NAME <- NAMES[[kk]]
[18:04:16.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.146]                     next
[18:04:16.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:16.146]                 }
[18:04:16.146]                 if (length(args) > 0) 
[18:04:16.146]                   base::do.call(base::Sys.setenv, args = args)
[18:04:16.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:16.146]             }
[18:04:16.146]             else {
[18:04:16.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:16.146]             }
[18:04:16.146]             {
[18:04:16.146]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:16.146]                   0L) {
[18:04:16.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:16.146]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:16.146]                   base::options(opts)
[18:04:16.146]                 }
[18:04:16.146]                 {
[18:04:16.146]                   {
[18:04:16.146]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:16.146]                     NULL
[18:04:16.146]                   }
[18:04:16.146]                   options(future.plan = NULL)
[18:04:16.146]                   if (is.na(NA_character_)) 
[18:04:16.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:16.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:16.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:16.146]                     .init = FALSE)
[18:04:16.146]                 }
[18:04:16.146]             }
[18:04:16.146]         }
[18:04:16.146]     })
[18:04:16.146]     if (TRUE) {
[18:04:16.146]         base::sink(type = "output", split = FALSE)
[18:04:16.146]         if (TRUE) {
[18:04:16.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:16.146]         }
[18:04:16.146]         else {
[18:04:16.146]             ...future.result["stdout"] <- base::list(NULL)
[18:04:16.146]         }
[18:04:16.146]         base::close(...future.stdout)
[18:04:16.146]         ...future.stdout <- NULL
[18:04:16.146]     }
[18:04:16.146]     ...future.result$conditions <- ...future.conditions
[18:04:16.146]     ...future.result$finished <- base::Sys.time()
[18:04:16.146]     ...future.result
[18:04:16.146] }
[18:04:16.153] requestCore(): workers = 2
[18:04:16.157] MulticoreFuture started
[18:04:16.160] - Launch lazy future ... done
[18:04:16.161] run() for ‘MulticoreFuture’ ... done
[18:04:16.163] plan(): Setting new future strategy stack:
List of 6
 $ a:[18:04:16.163] List of future strategies:
[18:04:16.163] 1. sequential:
[18:04:16.163]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:16.163]    - tweaked: FALSE
[18:04:16.163]    - call: NULL
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b99d1e8> 
 $ c:[18:04:16.168] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c28e14480> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a:[18:04:16.178] plan(): Setting new future strategy stack:
[18:04:16.178] List of future strategies:
[18:04:16.178] 1. multicore:
[18:04:16.178]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:16.178]    - tweaked: FALSE
[18:04:16.178]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b99d1e8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c28e14480> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ :[18:04:16.197] plan(): nbrOfWorkers() = 2
 chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:16.216] resolve() on list ...
[18:04:16.216]  recursive: 0
[18:04:16.217]  length: 6
[18:04:16.217]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:16.217] signalConditionsASAP(numeric, pos=1) ...
[18:04:16.220] - nx: 6
[18:04:16.220] - relay: TRUE
[18:04:16.221] - stdout: TRUE
[18:04:16.221] - signal: TRUE
[18:04:16.221] - resignal: FALSE
[18:04:16.221] - force: TRUE
[18:04:16.224] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.224] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.225]  - until=2
[18:04:16.225]  - relaying element #2
[18:04:16.225] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.226] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.228] signalConditionsASAP(NULL, pos=1) ... done
[18:04:16.228]  length: 5 (resolved future 1)
[18:04:16.229] Future #2
[18:04:16.230] result() for MulticoreFuture ...
[18:04:16.234] result() for MulticoreFuture ...
[18:04:16.238] result() for MulticoreFuture ... done
[18:04:16.238] result() for MulticoreFuture ... done
[18:04:16.239] result() for MulticoreFuture ...
[18:04:16.239] result() for MulticoreFuture ... done
[18:04:16.240] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:16.243] - nx: 6
[18:04:16.243] - relay: TRUE
[18:04:16.244] - stdout: TRUE
[18:04:16.244] - signal: TRUE
[18:04:16.244] - resignal: FALSE
[18:04:16.245] - force: TRUE
[18:04:16.246] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.246] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.247]  - until=2
[18:04:16.248]  - relaying element #2
[18:04:16.248] result() for MulticoreFuture ...
[18:04:16.251] result() for MulticoreFuture ... done
[18:04:16.251] result() for MulticoreFuture ...
[18:04:16.252] result() for MulticoreFuture ... done
[18:04:16.255] result() for MulticoreFuture ...
[18:04:16.256] result() for MulticoreFuture ... done
[18:04:16.256] result() for MulticoreFuture ...
[18:04:16.256] result() for MulticoreFuture ... done
[18:04:16.256] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.257] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.257] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:16.257]  length: 4 (resolved future 2)
[18:04:16.260] Future #3
[18:04:16.261] result() for MulticoreFuture ...
[18:04:16.266] result() for MulticoreFuture ...
[18:04:16.275] result() for MulticoreFuture ... done
[18:04:16.278] result() for MulticoreFuture ... done
[18:04:16.279] result() for MulticoreFuture ...
[18:04:16.280] result() for MulticoreFuture ... done
[18:04:16.280] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:16.280] - nx: 6
[18:04:16.281] - relay: TRUE
[18:04:16.281] - stdout: TRUE
[18:04:16.281] - signal: TRUE
[18:04:16.281] - resignal: FALSE
[18:04:16.282] - force: TRUE
[18:04:16.282] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.282] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.283]  - until=3
[18:04:16.283]  - relaying element #3
[18:04:16.283] result() for MulticoreFuture ...
[18:04:16.283] result() for MulticoreFuture ... done
[18:04:16.284] result() for MulticoreFuture ...
[18:04:16.284] result() for MulticoreFuture ... done
[18:04:16.284] result() for MulticoreFuture ...
[18:04:16.285] result() for MulticoreFuture ... done
[18:04:16.285] result() for MulticoreFuture ...
[18:04:16.285] result() for MulticoreFuture ... done
[18:04:16.285] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.286] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.286] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:16.286]  length: 3 (resolved future 3)
[18:04:16.286] signalConditionsASAP(NULL, pos=4) ...
[18:04:16.287] - nx: 6
[18:04:16.287] - relay: TRUE
[18:04:16.287] - stdout: TRUE
[18:04:16.287] - signal: TRUE
[18:04:16.287] - resignal: FALSE
[18:04:16.288] - force: TRUE
[18:04:16.288] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.288] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.288]  - until=5
[18:04:16.289]  - relaying element #5
[18:04:16.289] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:16.289] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.289] signalConditionsASAP(NULL, pos=4) ... done
[18:04:16.290]  length: 2 (resolved future 4)
[18:04:16.290] signalConditionsASAP(NULL, pos=5) ...
[18:04:16.290] - nx: 6
[18:04:16.290] - relay: TRUE
[18:04:16.290] - stdout: TRUE
[18:04:16.291] - signal: TRUE
[18:04:16.291] - resignal: FALSE
[18:04:16.291] - force: TRUE
[18:04:16.291] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:16.291] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.292]  - until=6
[18:04:16.292]  - relaying element #6
[18:04:16.292] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:16.292] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.293] signalConditionsASAP(NULL, pos=5) ... done
[18:04:16.293]  length: 1 (resolved future 5)
[18:04:16.293] signalConditionsASAP(numeric, pos=6) ...
[18:04:16.293] - nx: 6
[18:04:16.294] - relay: TRUE
[18:04:16.294] - stdout: TRUE
[18:04:16.294] - signal: TRUE
[18:04:16.294] - resignal: FALSE
[18:04:16.294] - force: TRUE
[18:04:16.295] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:16.295] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.295]  - until=6
[18:04:16.295] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:16.296] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.296] signalConditionsASAP(numeric, pos=6) ... done
[18:04:16.296]  length: 0 (resolved future 6)
[18:04:16.296] Relaying remaining futures
[18:04:16.296] signalConditionsASAP(NULL, pos=0) ...
[18:04:16.297] - nx: 6
[18:04:16.297] - relay: TRUE
[18:04:16.297] - stdout: TRUE
[18:04:16.297] - signal: TRUE
[18:04:16.297] - resignal: FALSE
[18:04:16.298] - force: TRUE
[18:04:16.298] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:16.298] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:16.298] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:16.299] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.299] signalConditionsASAP(NULL, pos=0) ... done
[18:04:16.299] resolve() on list ... DONE
[18:04:16.299] result() for MulticoreFuture ...
[18:04:16.299] result() for MulticoreFuture ... done
[18:04:16.300] result() for MulticoreFuture ...
[18:04:16.300] result() for MulticoreFuture ... done
[18:04:16.300] result() for MulticoreFuture ...
[18:04:16.300] result() for MulticoreFuture ... done
[18:04:16.301] result() for MulticoreFuture ...
[18:04:16.301] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[18:04:16.309] getGlobalsAndPackages() ...
[18:04:16.309] Searching for globals...
[18:04:16.310] 
[18:04:16.310] Searching for globals ... DONE
[18:04:16.311] - globals: [0] <none>
[18:04:16.311] getGlobalsAndPackages() ... DONE
[18:04:16.311] run() for ‘Future’ ...
[18:04:16.312] - state: ‘created’
[18:04:16.312] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:16.324] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:16.325] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:16.325]   - Field: ‘label’
[18:04:16.325]   - Field: ‘local’
[18:04:16.325]   - Field: ‘owner’
[18:04:16.326]   - Field: ‘envir’
[18:04:16.326]   - Field: ‘workers’
[18:04:16.326]   - Field: ‘packages’
[18:04:16.326]   - Field: ‘gc’
[18:04:16.327]   - Field: ‘job’
[18:04:16.327]   - Field: ‘conditions’
[18:04:16.327]   - Field: ‘expr’
[18:04:16.327]   - Field: ‘uuid’
[18:04:16.327]   - Field: ‘seed’
[18:04:16.328]   - Field: ‘version’
[18:04:16.328]   - Field: ‘result’
[18:04:16.328]   - Field: ‘asynchronous’
[18:04:16.328]   - Field: ‘calls’
[18:04:16.328]   - Field: ‘globals’
[18:04:16.329]   - Field: ‘stdout’
[18:04:16.329]   - Field: ‘earlySignal’
[18:04:16.329]   - Field: ‘lazy’
[18:04:16.329]   - Field: ‘state’
[18:04:16.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:16.330] - Launch lazy future ...
[18:04:16.330] Packages needed by the future expression (n = 0): <none>
[18:04:16.331] Packages needed by future strategies (n = 0): <none>
[18:04:16.332] {
[18:04:16.332]     {
[18:04:16.332]         {
[18:04:16.332]             ...future.startTime <- base::Sys.time()
[18:04:16.332]             {
[18:04:16.332]                 {
[18:04:16.332]                   {
[18:04:16.332]                     {
[18:04:16.332]                       base::local({
[18:04:16.332]                         has_future <- base::requireNamespace("future", 
[18:04:16.332]                           quietly = TRUE)
[18:04:16.332]                         if (has_future) {
[18:04:16.332]                           ns <- base::getNamespace("future")
[18:04:16.332]                           version <- ns[[".package"]][["version"]]
[18:04:16.332]                           if (is.null(version)) 
[18:04:16.332]                             version <- utils::packageVersion("future")
[18:04:16.332]                         }
[18:04:16.332]                         else {
[18:04:16.332]                           version <- NULL
[18:04:16.332]                         }
[18:04:16.332]                         if (!has_future || version < "1.8.0") {
[18:04:16.332]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:16.332]                             "", base::R.version$version.string), 
[18:04:16.332]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:16.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:16.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:16.332]                               "release", "version")], collapse = " "), 
[18:04:16.332]                             hostname = base::Sys.info()[["nodename"]])
[18:04:16.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:16.332]                             info)
[18:04:16.332]                           info <- base::paste(info, collapse = "; ")
[18:04:16.332]                           if (!has_future) {
[18:04:16.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:16.332]                               info)
[18:04:16.332]                           }
[18:04:16.332]                           else {
[18:04:16.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:16.332]                               info, version)
[18:04:16.332]                           }
[18:04:16.332]                           base::stop(msg)
[18:04:16.332]                         }
[18:04:16.332]                       })
[18:04:16.332]                     }
[18:04:16.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:16.332]                     base::options(mc.cores = 1L)
[18:04:16.332]                   }
[18:04:16.332]                   ...future.strategy.old <- future::plan("list")
[18:04:16.332]                   options(future.plan = NULL)
[18:04:16.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:16.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:16.332]                 }
[18:04:16.332]                 ...future.workdir <- getwd()
[18:04:16.332]             }
[18:04:16.332]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:16.332]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:16.332]         }
[18:04:16.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:16.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:16.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:16.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:16.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:16.332]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:16.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:16.332]             base::names(...future.oldOptions))
[18:04:16.332]     }
[18:04:16.332]     if (FALSE) {
[18:04:16.332]     }
[18:04:16.332]     else {
[18:04:16.332]         if (TRUE) {
[18:04:16.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:16.332]                 open = "w")
[18:04:16.332]         }
[18:04:16.332]         else {
[18:04:16.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:16.332]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:16.332]         }
[18:04:16.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:16.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:16.332]             base::sink(type = "output", split = FALSE)
[18:04:16.332]             base::close(...future.stdout)
[18:04:16.332]         }, add = TRUE)
[18:04:16.332]     }
[18:04:16.332]     ...future.frame <- base::sys.nframe()
[18:04:16.332]     ...future.conditions <- base::list()
[18:04:16.332]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:16.332]     if (FALSE) {
[18:04:16.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:16.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:16.332]     }
[18:04:16.332]     ...future.result <- base::tryCatch({
[18:04:16.332]         base::withCallingHandlers({
[18:04:16.332]             ...future.value <- base::withVisible(base::local({
[18:04:16.332]                 withCallingHandlers({
[18:04:16.332]                   2
[18:04:16.332]                 }, immediateCondition = function(cond) {
[18:04:16.332]                   save_rds <- function (object, pathname, ...) 
[18:04:16.332]                   {
[18:04:16.332]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:16.332]                     if (file_test("-f", pathname_tmp)) {
[18:04:16.332]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.332]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:16.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.332]                         fi_tmp[["mtime"]])
[18:04:16.332]                     }
[18:04:16.332]                     tryCatch({
[18:04:16.332]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:16.332]                     }, error = function(ex) {
[18:04:16.332]                       msg <- conditionMessage(ex)
[18:04:16.332]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.332]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:16.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.332]                         fi_tmp[["mtime"]], msg)
[18:04:16.332]                       ex$message <- msg
[18:04:16.332]                       stop(ex)
[18:04:16.332]                     })
[18:04:16.332]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:16.332]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:16.332]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:16.332]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.332]                       fi <- file.info(pathname)
[18:04:16.332]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:16.332]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.332]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:16.332]                         fi[["size"]], fi[["mtime"]])
[18:04:16.332]                       stop(msg)
[18:04:16.332]                     }
[18:04:16.332]                     invisible(pathname)
[18:04:16.332]                   }
[18:04:16.332]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:16.332]                     rootPath = tempdir()) 
[18:04:16.332]                   {
[18:04:16.332]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:16.332]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:16.332]                       tmpdir = path, fileext = ".rds")
[18:04:16.332]                     save_rds(obj, file)
[18:04:16.332]                   }
[18:04:16.332]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:16.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.332]                   {
[18:04:16.332]                     inherits <- base::inherits
[18:04:16.332]                     invokeRestart <- base::invokeRestart
[18:04:16.332]                     is.null <- base::is.null
[18:04:16.332]                     muffled <- FALSE
[18:04:16.332]                     if (inherits(cond, "message")) {
[18:04:16.332]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:16.332]                       if (muffled) 
[18:04:16.332]                         invokeRestart("muffleMessage")
[18:04:16.332]                     }
[18:04:16.332]                     else if (inherits(cond, "warning")) {
[18:04:16.332]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:16.332]                       if (muffled) 
[18:04:16.332]                         invokeRestart("muffleWarning")
[18:04:16.332]                     }
[18:04:16.332]                     else if (inherits(cond, "condition")) {
[18:04:16.332]                       if (!is.null(pattern)) {
[18:04:16.332]                         computeRestarts <- base::computeRestarts
[18:04:16.332]                         grepl <- base::grepl
[18:04:16.332]                         restarts <- computeRestarts(cond)
[18:04:16.332]                         for (restart in restarts) {
[18:04:16.332]                           name <- restart$name
[18:04:16.332]                           if (is.null(name)) 
[18:04:16.332]                             next
[18:04:16.332]                           if (!grepl(pattern, name)) 
[18:04:16.332]                             next
[18:04:16.332]                           invokeRestart(restart)
[18:04:16.332]                           muffled <- TRUE
[18:04:16.332]                           break
[18:04:16.332]                         }
[18:04:16.332]                       }
[18:04:16.332]                     }
[18:04:16.332]                     invisible(muffled)
[18:04:16.332]                   }
[18:04:16.332]                   muffleCondition(cond)
[18:04:16.332]                 })
[18:04:16.332]             }))
[18:04:16.332]             future::FutureResult(value = ...future.value$value, 
[18:04:16.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:16.332]                   ...future.rng), globalenv = if (FALSE) 
[18:04:16.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:16.332]                     ...future.globalenv.names))
[18:04:16.332]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:16.332]         }, condition = base::local({
[18:04:16.332]             c <- base::c
[18:04:16.332]             inherits <- base::inherits
[18:04:16.332]             invokeRestart <- base::invokeRestart
[18:04:16.332]             length <- base::length
[18:04:16.332]             list <- base::list
[18:04:16.332]             seq.int <- base::seq.int
[18:04:16.332]             signalCondition <- base::signalCondition
[18:04:16.332]             sys.calls <- base::sys.calls
[18:04:16.332]             `[[` <- base::`[[`
[18:04:16.332]             `+` <- base::`+`
[18:04:16.332]             `<<-` <- base::`<<-`
[18:04:16.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:16.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:16.332]                   3L)]
[18:04:16.332]             }
[18:04:16.332]             function(cond) {
[18:04:16.332]                 is_error <- inherits(cond, "error")
[18:04:16.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:16.332]                   NULL)
[18:04:16.332]                 if (is_error) {
[18:04:16.332]                   sessionInformation <- function() {
[18:04:16.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:16.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:16.332]                       search = base::search(), system = base::Sys.info())
[18:04:16.332]                   }
[18:04:16.332]                   ...future.conditions[[length(...future.conditions) + 
[18:04:16.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:16.332]                     cond$call), session = sessionInformation(), 
[18:04:16.332]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:16.332]                   signalCondition(cond)
[18:04:16.332]                 }
[18:04:16.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:16.332]                 "immediateCondition"))) {
[18:04:16.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:16.332]                   ...future.conditions[[length(...future.conditions) + 
[18:04:16.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:16.332]                   if (TRUE && !signal) {
[18:04:16.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.332]                     {
[18:04:16.332]                       inherits <- base::inherits
[18:04:16.332]                       invokeRestart <- base::invokeRestart
[18:04:16.332]                       is.null <- base::is.null
[18:04:16.332]                       muffled <- FALSE
[18:04:16.332]                       if (inherits(cond, "message")) {
[18:04:16.332]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:16.332]                         if (muffled) 
[18:04:16.332]                           invokeRestart("muffleMessage")
[18:04:16.332]                       }
[18:04:16.332]                       else if (inherits(cond, "warning")) {
[18:04:16.332]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:16.332]                         if (muffled) 
[18:04:16.332]                           invokeRestart("muffleWarning")
[18:04:16.332]                       }
[18:04:16.332]                       else if (inherits(cond, "condition")) {
[18:04:16.332]                         if (!is.null(pattern)) {
[18:04:16.332]                           computeRestarts <- base::computeRestarts
[18:04:16.332]                           grepl <- base::grepl
[18:04:16.332]                           restarts <- computeRestarts(cond)
[18:04:16.332]                           for (restart in restarts) {
[18:04:16.332]                             name <- restart$name
[18:04:16.332]                             if (is.null(name)) 
[18:04:16.332]                               next
[18:04:16.332]                             if (!grepl(pattern, name)) 
[18:04:16.332]                               next
[18:04:16.332]                             invokeRestart(restart)
[18:04:16.332]                             muffled <- TRUE
[18:04:16.332]                             break
[18:04:16.332]                           }
[18:04:16.332]                         }
[18:04:16.332]                       }
[18:04:16.332]                       invisible(muffled)
[18:04:16.332]                     }
[18:04:16.332]                     muffleCondition(cond, pattern = "^muffle")
[18:04:16.332]                   }
[18:04:16.332]                 }
[18:04:16.332]                 else {
[18:04:16.332]                   if (TRUE) {
[18:04:16.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.332]                     {
[18:04:16.332]                       inherits <- base::inherits
[18:04:16.332]                       invokeRestart <- base::invokeRestart
[18:04:16.332]                       is.null <- base::is.null
[18:04:16.332]                       muffled <- FALSE
[18:04:16.332]                       if (inherits(cond, "message")) {
[18:04:16.332]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:16.332]                         if (muffled) 
[18:04:16.332]                           invokeRestart("muffleMessage")
[18:04:16.332]                       }
[18:04:16.332]                       else if (inherits(cond, "warning")) {
[18:04:16.332]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:16.332]                         if (muffled) 
[18:04:16.332]                           invokeRestart("muffleWarning")
[18:04:16.332]                       }
[18:04:16.332]                       else if (inherits(cond, "condition")) {
[18:04:16.332]                         if (!is.null(pattern)) {
[18:04:16.332]                           computeRestarts <- base::computeRestarts
[18:04:16.332]                           grepl <- base::grepl
[18:04:16.332]                           restarts <- computeRestarts(cond)
[18:04:16.332]                           for (restart in restarts) {
[18:04:16.332]                             name <- restart$name
[18:04:16.332]                             if (is.null(name)) 
[18:04:16.332]                               next
[18:04:16.332]                             if (!grepl(pattern, name)) 
[18:04:16.332]                               next
[18:04:16.332]                             invokeRestart(restart)
[18:04:16.332]                             muffled <- TRUE
[18:04:16.332]                             break
[18:04:16.332]                           }
[18:04:16.332]                         }
[18:04:16.332]                       }
[18:04:16.332]                       invisible(muffled)
[18:04:16.332]                     }
[18:04:16.332]                     muffleCondition(cond, pattern = "^muffle")
[18:04:16.332]                   }
[18:04:16.332]                 }
[18:04:16.332]             }
[18:04:16.332]         }))
[18:04:16.332]     }, error = function(ex) {
[18:04:16.332]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:16.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:16.332]                 ...future.rng), started = ...future.startTime, 
[18:04:16.332]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:16.332]             version = "1.8"), class = "FutureResult")
[18:04:16.332]     }, finally = {
[18:04:16.332]         if (!identical(...future.workdir, getwd())) 
[18:04:16.332]             setwd(...future.workdir)
[18:04:16.332]         {
[18:04:16.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:16.332]                 ...future.oldOptions$nwarnings <- NULL
[18:04:16.332]             }
[18:04:16.332]             base::options(...future.oldOptions)
[18:04:16.332]             if (.Platform$OS.type == "windows") {
[18:04:16.332]                 old_names <- names(...future.oldEnvVars)
[18:04:16.332]                 envs <- base::Sys.getenv()
[18:04:16.332]                 names <- names(envs)
[18:04:16.332]                 common <- intersect(names, old_names)
[18:04:16.332]                 added <- setdiff(names, old_names)
[18:04:16.332]                 removed <- setdiff(old_names, names)
[18:04:16.332]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:16.332]                   envs[common]]
[18:04:16.332]                 NAMES <- toupper(changed)
[18:04:16.332]                 args <- list()
[18:04:16.332]                 for (kk in seq_along(NAMES)) {
[18:04:16.332]                   name <- changed[[kk]]
[18:04:16.332]                   NAME <- NAMES[[kk]]
[18:04:16.332]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.332]                     next
[18:04:16.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:16.332]                 }
[18:04:16.332]                 NAMES <- toupper(added)
[18:04:16.332]                 for (kk in seq_along(NAMES)) {
[18:04:16.332]                   name <- added[[kk]]
[18:04:16.332]                   NAME <- NAMES[[kk]]
[18:04:16.332]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.332]                     next
[18:04:16.332]                   args[[name]] <- ""
[18:04:16.332]                 }
[18:04:16.332]                 NAMES <- toupper(removed)
[18:04:16.332]                 for (kk in seq_along(NAMES)) {
[18:04:16.332]                   name <- removed[[kk]]
[18:04:16.332]                   NAME <- NAMES[[kk]]
[18:04:16.332]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.332]                     next
[18:04:16.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:16.332]                 }
[18:04:16.332]                 if (length(args) > 0) 
[18:04:16.332]                   base::do.call(base::Sys.setenv, args = args)
[18:04:16.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:16.332]             }
[18:04:16.332]             else {
[18:04:16.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:16.332]             }
[18:04:16.332]             {
[18:04:16.332]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:16.332]                   0L) {
[18:04:16.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:16.332]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:16.332]                   base::options(opts)
[18:04:16.332]                 }
[18:04:16.332]                 {
[18:04:16.332]                   {
[18:04:16.332]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:16.332]                     NULL
[18:04:16.332]                   }
[18:04:16.332]                   options(future.plan = NULL)
[18:04:16.332]                   if (is.na(NA_character_)) 
[18:04:16.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:16.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:16.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:16.332]                     .init = FALSE)
[18:04:16.332]                 }
[18:04:16.332]             }
[18:04:16.332]         }
[18:04:16.332]     })
[18:04:16.332]     if (TRUE) {
[18:04:16.332]         base::sink(type = "output", split = FALSE)
[18:04:16.332]         if (TRUE) {
[18:04:16.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:16.332]         }
[18:04:16.332]         else {
[18:04:16.332]             ...future.result["stdout"] <- base::list(NULL)
[18:04:16.332]         }
[18:04:16.332]         base::close(...future.stdout)
[18:04:16.332]         ...future.stdout <- NULL
[18:04:16.332]     }
[18:04:16.332]     ...future.result$conditions <- ...future.conditions
[18:04:16.332]     ...future.result$finished <- base::Sys.time()
[18:04:16.332]     ...future.result
[18:04:16.332] }
[18:04:16.336] requestCore(): workers = 2
[18:04:16.340] MulticoreFuture started
[18:04:16.341] - Launch lazy future ... done
[18:04:16.341] run() for ‘MulticoreFuture’ ... done
[18:04:16.342] getGlobalsAndPackages() ...
[18:04:16.343] Searching for globals...
[18:04:16.344] 
[18:04:16.345] Searching for globals ... DONE
[18:04:16.345] - globals: [0] <none>
[18:04:16.346] getGlobalsAndPackages() ... DONE
[18:04:16.347] run() for ‘Future’ ...
[18:04:16.347] - state: ‘created’
[18:04:16.348] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:16.351] plan(): Setting new future strategy stack:
[18:04:16.355] List of future strategies:
[18:04:16.355] 1. sequential:
[18:04:16.355]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:16.355]    - tweaked: FALSE
[18:04:16.355]    - call: NULL
[18:04:16.358] plan(): nbrOfWorkers() = 1
[18:04:16.358] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:16.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:16.359]   - Field: ‘label’
[18:04:16.360]   - Field: ‘local’
[18:04:16.360]   - Field: ‘owner’
[18:04:16.360]   - Field: ‘envir’
[18:04:16.361]   - Field: ‘workers’
[18:04:16.361]   - Field: ‘packages’
[18:04:16.361]   - Field: ‘gc’
[18:04:16.362]   - Field: ‘job’
[18:04:16.362]   - Field: ‘conditions’
[18:04:16.362]   - Field: ‘expr’
[18:04:16.363]   - Field: ‘uuid’
[18:04:16.363]   - Field: ‘seed’
[18:04:16.363]   - Field: ‘version’
[18:04:16.364]   - Field: ‘result’
[18:04:16.364]   - Field: ‘asynchronous’
[18:04:16.364]   - Field: ‘calls’
[18:04:16.365] plan(): Setting new future strategy stack:
[18:04:16.365]   - Field: ‘globals’
[18:04:16.365]   - Field: ‘stdout’
[18:04:16.365]   - Field: ‘earlySignal’
[18:04:16.366]   - Field: ‘lazy’
[18:04:16.366]   - Field: ‘state’
[18:04:16.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:16.367] - Launch lazy future ...
[18:04:16.365] List of future strategies:
[18:04:16.365] 1. multicore:
[18:04:16.365]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:16.365]    - tweaked: FALSE
[18:04:16.365]    - call: plan(strategy)
[18:04:16.368] Packages needed by the future expression (n = 0): <none>
[18:04:16.368] Packages needed by future strategies (n = 0): <none>
[18:04:16.386] plan(): nbrOfWorkers() = 2
[18:04:16.378] {
[18:04:16.378]     {
[18:04:16.378]         {
[18:04:16.378]             ...future.startTime <- base::Sys.time()
[18:04:16.378]             {
[18:04:16.378]                 {
[18:04:16.378]                   {
[18:04:16.378]                     {
[18:04:16.378]                       base::local({
[18:04:16.378]                         has_future <- base::requireNamespace("future", 
[18:04:16.378]                           quietly = TRUE)
[18:04:16.378]                         if (has_future) {
[18:04:16.378]                           ns <- base::getNamespace("future")
[18:04:16.378]                           version <- ns[[".package"]][["version"]]
[18:04:16.378]                           if (is.null(version)) 
[18:04:16.378]                             version <- utils::packageVersion("future")
[18:04:16.378]                         }
[18:04:16.378]                         else {
[18:04:16.378]                           version <- NULL
[18:04:16.378]                         }
[18:04:16.378]                         if (!has_future || version < "1.8.0") {
[18:04:16.378]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:16.378]                             "", base::R.version$version.string), 
[18:04:16.378]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:16.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:16.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:16.378]                               "release", "version")], collapse = " "), 
[18:04:16.378]                             hostname = base::Sys.info()[["nodename"]])
[18:04:16.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:16.378]                             info)
[18:04:16.378]                           info <- base::paste(info, collapse = "; ")
[18:04:16.378]                           if (!has_future) {
[18:04:16.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:16.378]                               info)
[18:04:16.378]                           }
[18:04:16.378]                           else {
[18:04:16.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:16.378]                               info, version)
[18:04:16.378]                           }
[18:04:16.378]                           base::stop(msg)
[18:04:16.378]                         }
[18:04:16.378]                       })
[18:04:16.378]                     }
[18:04:16.378]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:16.378]                     base::options(mc.cores = 1L)
[18:04:16.378]                   }
[18:04:16.378]                   ...future.strategy.old <- future::plan("list")
[18:04:16.378]                   options(future.plan = NULL)
[18:04:16.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:16.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:16.378]                 }
[18:04:16.378]                 ...future.workdir <- getwd()
[18:04:16.378]             }
[18:04:16.378]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:16.378]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:16.378]         }
[18:04:16.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:16.378]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:16.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:16.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:16.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:16.378]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:16.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:16.378]             base::names(...future.oldOptions))
[18:04:16.378]     }
[18:04:16.378]     if (FALSE) {
[18:04:16.378]     }
[18:04:16.378]     else {
[18:04:16.378]         if (TRUE) {
[18:04:16.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:16.378]                 open = "w")
[18:04:16.378]         }
[18:04:16.378]         else {
[18:04:16.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:16.378]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:16.378]         }
[18:04:16.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:16.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:16.378]             base::sink(type = "output", split = FALSE)
[18:04:16.378]             base::close(...future.stdout)
[18:04:16.378]         }, add = TRUE)
[18:04:16.378]     }
[18:04:16.378]     ...future.frame <- base::sys.nframe()
[18:04:16.378]     ...future.conditions <- base::list()
[18:04:16.378]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:16.378]     if (FALSE) {
[18:04:16.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:16.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:16.378]     }
[18:04:16.378]     ...future.result <- base::tryCatch({
[18:04:16.378]         base::withCallingHandlers({
[18:04:16.378]             ...future.value <- base::withVisible(base::local({
[18:04:16.378]                 withCallingHandlers({
[18:04:16.378]                   NULL
[18:04:16.378]                 }, immediateCondition = function(cond) {
[18:04:16.378]                   save_rds <- function (object, pathname, ...) 
[18:04:16.378]                   {
[18:04:16.378]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:16.378]                     if (file_test("-f", pathname_tmp)) {
[18:04:16.378]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.378]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:16.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.378]                         fi_tmp[["mtime"]])
[18:04:16.378]                     }
[18:04:16.378]                     tryCatch({
[18:04:16.378]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:16.378]                     }, error = function(ex) {
[18:04:16.378]                       msg <- conditionMessage(ex)
[18:04:16.378]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.378]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:16.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.378]                         fi_tmp[["mtime"]], msg)
[18:04:16.378]                       ex$message <- msg
[18:04:16.378]                       stop(ex)
[18:04:16.378]                     })
[18:04:16.378]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:16.378]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:16.378]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:16.378]                       fi_tmp <- file.info(pathname_tmp)
[18:04:16.378]                       fi <- file.info(pathname)
[18:04:16.378]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:16.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:16.378]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:16.378]                         fi[["size"]], fi[["mtime"]])
[18:04:16.378]                       stop(msg)
[18:04:16.378]                     }
[18:04:16.378]                     invisible(pathname)
[18:04:16.378]                   }
[18:04:16.378]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:16.378]                     rootPath = tempdir()) 
[18:04:16.378]                   {
[18:04:16.378]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:16.378]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:16.378]                       tmpdir = path, fileext = ".rds")
[18:04:16.378]                     save_rds(obj, file)
[18:04:16.378]                   }
[18:04:16.378]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:16.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.378]                   {
[18:04:16.378]                     inherits <- base::inherits
[18:04:16.378]                     invokeRestart <- base::invokeRestart
[18:04:16.378]                     is.null <- base::is.null
[18:04:16.378]                     muffled <- FALSE
[18:04:16.378]                     if (inherits(cond, "message")) {
[18:04:16.378]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:16.378]                       if (muffled) 
[18:04:16.378]                         invokeRestart("muffleMessage")
[18:04:16.378]                     }
[18:04:16.378]                     else if (inherits(cond, "warning")) {
[18:04:16.378]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:16.378]                       if (muffled) 
[18:04:16.378]                         invokeRestart("muffleWarning")
[18:04:16.378]                     }
[18:04:16.378]                     else if (inherits(cond, "condition")) {
[18:04:16.378]                       if (!is.null(pattern)) {
[18:04:16.378]                         computeRestarts <- base::computeRestarts
[18:04:16.378]                         grepl <- base::grepl
[18:04:16.378]                         restarts <- computeRestarts(cond)
[18:04:16.378]                         for (restart in restarts) {
[18:04:16.378]                           name <- restart$name
[18:04:16.378]                           if (is.null(name)) 
[18:04:16.378]                             next
[18:04:16.378]                           if (!grepl(pattern, name)) 
[18:04:16.378]                             next
[18:04:16.378]                           invokeRestart(restart)
[18:04:16.378]                           muffled <- TRUE
[18:04:16.378]                           break
[18:04:16.378]                         }
[18:04:16.378]                       }
[18:04:16.378]                     }
[18:04:16.378]                     invisible(muffled)
[18:04:16.378]                   }
[18:04:16.378]                   muffleCondition(cond)
[18:04:16.378]                 })
[18:04:16.378]             }))
[18:04:16.378]             future::FutureResult(value = ...future.value$value, 
[18:04:16.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:16.378]                   ...future.rng), globalenv = if (FALSE) 
[18:04:16.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:16.378]                     ...future.globalenv.names))
[18:04:16.378]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:16.378]         }, condition = base::local({
[18:04:16.378]             c <- base::c
[18:04:16.378]             inherits <- base::inherits
[18:04:16.378]             invokeRestart <- base::invokeRestart
[18:04:16.378]             length <- base::length
[18:04:16.378]             list <- base::list
[18:04:16.378]             seq.int <- base::seq.int
[18:04:16.378]             signalCondition <- base::signalCondition
[18:04:16.378]             sys.calls <- base::sys.calls
[18:04:16.378]             `[[` <- base::`[[`
[18:04:16.378]             `+` <- base::`+`
[18:04:16.378]             `<<-` <- base::`<<-`
[18:04:16.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:16.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:16.378]                   3L)]
[18:04:16.378]             }
[18:04:16.378]             function(cond) {
[18:04:16.378]                 is_error <- inherits(cond, "error")
[18:04:16.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:16.378]                   NULL)
[18:04:16.378]                 if (is_error) {
[18:04:16.378]                   sessionInformation <- function() {
[18:04:16.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:16.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:16.378]                       search = base::search(), system = base::Sys.info())
[18:04:16.378]                   }
[18:04:16.378]                   ...future.conditions[[length(...future.conditions) + 
[18:04:16.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:16.378]                     cond$call), session = sessionInformation(), 
[18:04:16.378]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:16.378]                   signalCondition(cond)
[18:04:16.378]                 }
[18:04:16.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:16.378]                 "immediateCondition"))) {
[18:04:16.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:16.378]                   ...future.conditions[[length(...future.conditions) + 
[18:04:16.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:16.378]                   if (TRUE && !signal) {
[18:04:16.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.378]                     {
[18:04:16.378]                       inherits <- base::inherits
[18:04:16.378]                       invokeRestart <- base::invokeRestart
[18:04:16.378]                       is.null <- base::is.null
[18:04:16.378]                       muffled <- FALSE
[18:04:16.378]                       if (inherits(cond, "message")) {
[18:04:16.378]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:16.378]                         if (muffled) 
[18:04:16.378]                           invokeRestart("muffleMessage")
[18:04:16.378]                       }
[18:04:16.378]                       else if (inherits(cond, "warning")) {
[18:04:16.378]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:16.378]                         if (muffled) 
[18:04:16.378]                           invokeRestart("muffleWarning")
[18:04:16.378]                       }
[18:04:16.378]                       else if (inherits(cond, "condition")) {
[18:04:16.378]                         if (!is.null(pattern)) {
[18:04:16.378]                           computeRestarts <- base::computeRestarts
[18:04:16.378]                           grepl <- base::grepl
[18:04:16.378]                           restarts <- computeRestarts(cond)
[18:04:16.378]                           for (restart in restarts) {
[18:04:16.378]                             name <- restart$name
[18:04:16.378]                             if (is.null(name)) 
[18:04:16.378]                               next
[18:04:16.378]                             if (!grepl(pattern, name)) 
[18:04:16.378]                               next
[18:04:16.378]                             invokeRestart(restart)
[18:04:16.378]                             muffled <- TRUE
[18:04:16.378]                             break
[18:04:16.378]                           }
[18:04:16.378]                         }
[18:04:16.378]                       }
[18:04:16.378]                       invisible(muffled)
[18:04:16.378]                     }
[18:04:16.378]                     muffleCondition(cond, pattern = "^muffle")
[18:04:16.378]                   }
[18:04:16.378]                 }
[18:04:16.378]                 else {
[18:04:16.378]                   if (TRUE) {
[18:04:16.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:16.378]                     {
[18:04:16.378]                       inherits <- base::inherits
[18:04:16.378]                       invokeRestart <- base::invokeRestart
[18:04:16.378]                       is.null <- base::is.null
[18:04:16.378]                       muffled <- FALSE
[18:04:16.378]                       if (inherits(cond, "message")) {
[18:04:16.378]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:16.378]                         if (muffled) 
[18:04:16.378]                           invokeRestart("muffleMessage")
[18:04:16.378]                       }
[18:04:16.378]                       else if (inherits(cond, "warning")) {
[18:04:16.378]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:16.378]                         if (muffled) 
[18:04:16.378]                           invokeRestart("muffleWarning")
[18:04:16.378]                       }
[18:04:16.378]                       else if (inherits(cond, "condition")) {
[18:04:16.378]                         if (!is.null(pattern)) {
[18:04:16.378]                           computeRestarts <- base::computeRestarts
[18:04:16.378]                           grepl <- base::grepl
[18:04:16.378]                           restarts <- computeRestarts(cond)
[18:04:16.378]                           for (restart in restarts) {
[18:04:16.378]                             name <- restart$name
[18:04:16.378]                             if (is.null(name)) 
[18:04:16.378]                               next
[18:04:16.378]                             if (!grepl(pattern, name)) 
[18:04:16.378]                               next
[18:04:16.378]                             invokeRestart(restart)
[18:04:16.378]                             muffled <- TRUE
[18:04:16.378]                             break
[18:04:16.378]                           }
[18:04:16.378]                         }
[18:04:16.378]                       }
[18:04:16.378]                       invisible(muffled)
[18:04:16.378]                     }
[18:04:16.378]                     muffleCondition(cond, pattern = "^muffle")
[18:04:16.378]                   }
[18:04:16.378]                 }
[18:04:16.378]             }
[18:04:16.378]         }))
[18:04:16.378]     }, error = function(ex) {
[18:04:16.378]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:16.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:16.378]                 ...future.rng), started = ...future.startTime, 
[18:04:16.378]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:16.378]             version = "1.8"), class = "FutureResult")
[18:04:16.378]     }, finally = {
[18:04:16.378]         if (!identical(...future.workdir, getwd())) 
[18:04:16.378]             setwd(...future.workdir)
[18:04:16.378]         {
[18:04:16.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:16.378]                 ...future.oldOptions$nwarnings <- NULL
[18:04:16.378]             }
[18:04:16.378]             base::options(...future.oldOptions)
[18:04:16.378]             if (.Platform$OS.type == "windows") {
[18:04:16.378]                 old_names <- names(...future.oldEnvVars)
[18:04:16.378]                 envs <- base::Sys.getenv()
[18:04:16.378]                 names <- names(envs)
[18:04:16.378]                 common <- intersect(names, old_names)
[18:04:16.378]                 added <- setdiff(names, old_names)
[18:04:16.378]                 removed <- setdiff(old_names, names)
[18:04:16.378]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:16.378]                   envs[common]]
[18:04:16.378]                 NAMES <- toupper(changed)
[18:04:16.378]                 args <- list()
[18:04:16.378]                 for (kk in seq_along(NAMES)) {
[18:04:16.378]                   name <- changed[[kk]]
[18:04:16.378]                   NAME <- NAMES[[kk]]
[18:04:16.378]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.378]                     next
[18:04:16.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:16.378]                 }
[18:04:16.378]                 NAMES <- toupper(added)
[18:04:16.378]                 for (kk in seq_along(NAMES)) {
[18:04:16.378]                   name <- added[[kk]]
[18:04:16.378]                   NAME <- NAMES[[kk]]
[18:04:16.378]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.378]                     next
[18:04:16.378]                   args[[name]] <- ""
[18:04:16.378]                 }
[18:04:16.378]                 NAMES <- toupper(removed)
[18:04:16.378]                 for (kk in seq_along(NAMES)) {
[18:04:16.378]                   name <- removed[[kk]]
[18:04:16.378]                   NAME <- NAMES[[kk]]
[18:04:16.378]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:16.378]                     next
[18:04:16.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:16.378]                 }
[18:04:16.378]                 if (length(args) > 0) 
[18:04:16.378]                   base::do.call(base::Sys.setenv, args = args)
[18:04:16.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:16.378]             }
[18:04:16.378]             else {
[18:04:16.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:16.378]             }
[18:04:16.378]             {
[18:04:16.378]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:16.378]                   0L) {
[18:04:16.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:16.378]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:16.378]                   base::options(opts)
[18:04:16.378]                 }
[18:04:16.378]                 {
[18:04:16.378]                   {
[18:04:16.378]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:16.378]                     NULL
[18:04:16.378]                   }
[18:04:16.378]                   options(future.plan = NULL)
[18:04:16.378]                   if (is.na(NA_character_)) 
[18:04:16.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:16.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:16.378]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:16.378]                     .init = FALSE)
[18:04:16.378]                 }
[18:04:16.378]             }
[18:04:16.378]         }
[18:04:16.378]     })
[18:04:16.378]     if (TRUE) {
[18:04:16.378]         base::sink(type = "output", split = FALSE)
[18:04:16.378]         if (TRUE) {
[18:04:16.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:16.378]         }
[18:04:16.378]         else {
[18:04:16.378]             ...future.result["stdout"] <- base::list(NULL)
[18:04:16.378]         }
[18:04:16.378]         base::close(...future.stdout)
[18:04:16.378]         ...future.stdout <- NULL
[18:04:16.378]     }
[18:04:16.378]     ...future.result$conditions <- ...future.conditions
[18:04:16.378]     ...future.result$finished <- base::Sys.time()
[18:04:16.378]     ...future.result
[18:04:16.378] }
[18:04:16.396] requestCore(): workers = 2
[18:04:16.403] MulticoreFuture started
[18:04:16.404] - Launch lazy future ... done
[18:04:16.407] run() for ‘MulticoreFuture’ ... done
[18:04:16.409] plan(): Setting new future strategy stack:
List of 6
 $ a:[18:04:16.410] List of future strategies:
[18:04:16.410] 1. sequential:
[18:04:16.410]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:16.410]    - tweaked: FALSE
[18:04:16.410]    - call: NULL
[18:04:16.418] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2af72168> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b412520> 
 $  : NULL
 $  : NULL
 $  :[18:04:16.426] plan(): Setting new future strategy stack:
[18:04:16.429] List of future strategies:
[18:04:16.429] 1. multicore:
[18:04:16.429]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:16.429]    - tweaked: FALSE
[18:04:16.429]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2af72168> 
 $ c:[18:04:16.441] plan(): nbrOfWorkers() = 2
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b412520> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:16.459] resolve() on list ...
[18:04:16.459]  recursive: 0
[18:04:16.460]  length: 6
[18:04:16.460]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:16.460] signalConditionsASAP(numeric, pos=1) ...
[18:04:16.461] - nx: 6
[18:04:16.461] - relay: TRUE
[18:04:16.461] - stdout: TRUE
[18:04:16.462] - signal: TRUE
[18:04:16.462] - resignal: FALSE
[18:04:16.462] - force: TRUE
[18:04:16.463] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.463] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.463]  - until=2
[18:04:16.464]  - relaying element #2
[18:04:16.464] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.464] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.464] signalConditionsASAP(NULL, pos=1) ... done
[18:04:16.465]  length: 5 (resolved future 1)
[18:04:16.466] Future #2
[18:04:16.466] result() for MulticoreFuture ...
[18:04:16.468] result() for MulticoreFuture ...
[18:04:16.468] result() for MulticoreFuture ... done
[18:04:16.469] result() for MulticoreFuture ... done
[18:04:16.469] result() for MulticoreFuture ...
[18:04:16.469] result() for MulticoreFuture ... done
[18:04:16.470] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:16.472] - nx: 6
[18:04:16.472] - relay: TRUE
[18:04:16.473] - stdout: TRUE
[18:04:16.473] - signal: TRUE
[18:04:16.473] - resignal: FALSE
[18:04:16.473] - force: TRUE
[18:04:16.474] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.475] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:16.476]  - until=2
[18:04:16.476]  - relaying element #2
[18:04:16.476] result() for MulticoreFuture ...
[18:04:16.477] result() for MulticoreFuture ... done
[18:04:16.477] result() for MulticoreFuture ...
[18:04:16.477] result() for MulticoreFuture ... done
[18:04:16.477] result() for MulticoreFuture ...
[18:04:16.478] result() for MulticoreFuture ... done
[18:04:16.478] result() for MulticoreFuture ...
[18:04:16.478] result() for MulticoreFuture ... done
[18:04:16.478] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.479] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.479] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:16.479]  length: 4 (resolved future 2)
[18:04:16.480] Future #3
[18:04:16.480] result() for MulticoreFuture ...
[18:04:16.482] result() for MulticoreFuture ...
[18:04:16.482] result() for MulticoreFuture ... done
[18:04:16.482] result() for MulticoreFuture ... done
[18:04:16.483] result() for MulticoreFuture ...
[18:04:16.484] result() for MulticoreFuture ... done
[18:04:16.484] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:16.485] - nx: 6
[18:04:16.485] - relay: TRUE
[18:04:16.485] - stdout: TRUE
[18:04:16.486] - signal: TRUE
[18:04:16.486] - resignal: FALSE
[18:04:16.486] - force: TRUE
[18:04:16.486] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.486] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:16.487]  - until=3
[18:04:16.487]  - relaying element #3
[18:04:16.487] result() for MulticoreFuture ...
[18:04:16.487] result() for MulticoreFuture ... done
[18:04:16.488] result() for MulticoreFuture ...
[18:04:16.488] result() for MulticoreFuture ... done
[18:04:16.488] result() for MulticoreFuture ...
[18:04:16.488] result() for MulticoreFuture ... done
[18:04:16.489] result() for MulticoreFuture ...
[18:04:16.489] result() for MulticoreFuture ... done
[18:04:16.489] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.489] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.490] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:16.490]  length: 3 (resolved future 3)
[18:04:16.490] signalConditionsASAP(NULL, pos=4) ...
[18:04:16.490] - nx: 6
[18:04:16.490] - relay: TRUE
[18:04:16.491] - stdout: TRUE
[18:04:16.491] - signal: TRUE
[18:04:16.491] - resignal: FALSE
[18:04:16.491] - force: TRUE
[18:04:16.491] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.492] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.492]  - until=5
[18:04:16.492]  - relaying element #5
[18:04:16.492] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:16.493] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.493] signalConditionsASAP(NULL, pos=4) ... done
[18:04:16.493]  length: 2 (resolved future 4)
[18:04:16.493] signalConditionsASAP(NULL, pos=5) ...
[18:04:16.493] - nx: 6
[18:04:16.494] - relay: TRUE
[18:04:16.494] - stdout: TRUE
[18:04:16.494] - signal: TRUE
[18:04:16.494] - resignal: FALSE
[18:04:16.494] - force: TRUE
[18:04:16.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:16.495] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.495]  - until=6
[18:04:16.495]  - relaying element #6
[18:04:16.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:16.496] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.496] signalConditionsASAP(NULL, pos=5) ... done
[18:04:16.496]  length: 1 (resolved future 5)
[18:04:16.496] signalConditionsASAP(numeric, pos=6) ...
[18:04:16.497] - nx: 6
[18:04:16.497] - relay: TRUE
[18:04:16.497] - stdout: TRUE
[18:04:16.497] - signal: TRUE
[18:04:16.497] - resignal: FALSE
[18:04:16.498] - force: TRUE
[18:04:16.498] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:16.498] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.498]  - until=6
[18:04:16.498] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:16.499] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.499] signalConditionsASAP(numeric, pos=6) ... done
[18:04:16.499]  length: 0 (resolved future 6)
[18:04:16.499] Relaying remaining futures
[18:04:16.499] signalConditionsASAP(NULL, pos=0) ...
[18:04:16.500] - nx: 6
[18:04:16.500] - relay: TRUE
[18:04:16.500] - stdout: TRUE
[18:04:16.500] - signal: TRUE
[18:04:16.500] - resignal: FALSE
[18:04:16.501] - force: TRUE
[18:04:16.501] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:16.501] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:16.501] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:16.502] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:16.502] signalConditionsASAP(NULL, pos=0) ... done
[18:04:16.502] resolve() on list ... DONE
[18:04:16.502] result() for MulticoreFuture ...
[18:04:16.502] result() for MulticoreFuture ... done
[18:04:16.503] result() for MulticoreFuture ...
[18:04:16.503] result() for MulticoreFuture ... done
[18:04:16.503] result() for MulticoreFuture ...
[18:04:16.503] result() for MulticoreFuture ... done
[18:04:16.503] result() for MulticoreFuture ...
[18:04:16.504] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[18:04:16.515] plan(): Setting new future strategy stack:
[18:04:16.515] List of future strategies:
[18:04:16.515] 1. multisession:
[18:04:16.515]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:16.515]    - tweaked: FALSE
[18:04:16.515]    - call: plan(strategy)
[18:04:16.516] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:04:16.516] multisession:
[18:04:16.516] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:16.516] - tweaked: FALSE
[18:04:16.516] - call: plan(strategy)
[18:04:16.526] getGlobalsAndPackages() ...
[18:04:16.527] Not searching for globals
[18:04:16.527] - globals: [0] <none>
[18:04:16.527] getGlobalsAndPackages() ... DONE
[18:04:16.528] [local output] makeClusterPSOCK() ...
[18:04:16.591] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:04:16.593] [local output] Base port: 11180
[18:04:16.593] [local output] Getting setup options for 2 cluster nodes ...
[18:04:16.593] [local output]  - Node 1 of 2 ...
[18:04:16.594] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:16.596] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZUhzkP/worker.rank=1.parallelly.parent=322369.4eb4158480ae1.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpZUhzkP/worker.rank=1.parallelly.parent=322369.4eb4158480ae1.pid")'’
[18:04:16.873] - Possible to infer worker's PID: TRUE
[18:04:16.873] [local output] Rscript port: 11180

[18:04:16.874] [local output]  - Node 2 of 2 ...
[18:04:16.875] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:16.876] [local output] Rscript port: 11180

[18:04:16.876] [local output] Getting setup options for 2 cluster nodes ... done
[18:04:16.877] [local output]  - Parallel setup requested for some PSOCK nodes
[18:04:16.878] [local output] Setting up PSOCK nodes in parallel
[18:04:16.878] List of 36
[18:04:16.878]  $ worker          : chr "localhost"
[18:04:16.878]   ..- attr(*, "localhost")= logi TRUE
[18:04:16.878]  $ master          : chr "localhost"
[18:04:16.878]  $ port            : int 11180
[18:04:16.878]  $ connectTimeout  : num 120
[18:04:16.878]  $ timeout         : num 2592000
[18:04:16.878]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:04:16.878]  $ homogeneous     : logi TRUE
[18:04:16.878]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:04:16.878]  $ rscript_envs    : NULL
[18:04:16.878]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:16.878]  $ rscript_startup : NULL
[18:04:16.878]  $ rscript_sh      : chr "sh"
[18:04:16.878]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:16.878]  $ methods         : logi TRUE
[18:04:16.878]  $ socketOptions   : chr "no-delay"
[18:04:16.878]  $ useXDR          : logi FALSE
[18:04:16.878]  $ outfile         : chr "/dev/null"
[18:04:16.878]  $ renice          : int NA
[18:04:16.878]  $ rshcmd          : NULL
[18:04:16.878]  $ user            : chr(0) 
[18:04:16.878]  $ revtunnel       : logi FALSE
[18:04:16.878]  $ rshlogfile      : NULL
[18:04:16.878]  $ rshopts         : chr(0) 
[18:04:16.878]  $ rank            : int 1
[18:04:16.878]  $ manual          : logi FALSE
[18:04:16.878]  $ dryrun          : logi FALSE
[18:04:16.878]  $ quiet           : logi FALSE
[18:04:16.878]  $ setup_strategy  : chr "parallel"
[18:04:16.878]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:16.878]  $ pidfile         : chr "/tmp/RtmpZUhzkP/worker.rank=1.parallelly.parent=322369.4eb4158480ae1.pid"
[18:04:16.878]  $ rshcmd_label    : NULL
[18:04:16.878]  $ rsh_call        : NULL
[18:04:16.878]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:16.878]  $ localMachine    : logi TRUE
[18:04:16.878]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:04:16.878]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:04:16.878]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:04:16.878]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:04:16.878]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:04:16.878]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:04:16.878]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:04:16.878]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:04:16.878]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:04:16.878]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:04:16.878]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:04:16.878]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:04:16.878]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:04:16.878]  $ arguments       :List of 28
[18:04:16.878]   ..$ worker          : chr "localhost"
[18:04:16.878]   ..$ master          : NULL
[18:04:16.878]   ..$ port            : int 11180
[18:04:16.878]   ..$ connectTimeout  : num 120
[18:04:16.878]   ..$ timeout         : num 2592000
[18:04:16.878]   ..$ rscript         : NULL
[18:04:16.878]   ..$ homogeneous     : NULL
[18:04:16.878]   ..$ rscript_args    : NULL
[18:04:16.878]   ..$ rscript_envs    : NULL
[18:04:16.878]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:16.878]   ..$ rscript_startup : NULL
[18:04:16.878]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:04:16.878]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:16.878]   ..$ methods         : logi TRUE
[18:04:16.878]   ..$ socketOptions   : chr "no-delay"
[18:04:16.878]   ..$ useXDR          : logi FALSE
[18:04:16.878]   ..$ outfile         : chr "/dev/null"
[18:04:16.878]   ..$ renice          : int NA
[18:04:16.878]   ..$ rshcmd          : NULL
[18:04:16.878]   ..$ user            : NULL
[18:04:16.878]   ..$ revtunnel       : logi NA
[18:04:16.878]   ..$ rshlogfile      : NULL
[18:04:16.878]   ..$ rshopts         : NULL
[18:04:16.878]   ..$ rank            : int 1
[18:04:16.878]   ..$ manual          : logi FALSE
[18:04:16.878]   ..$ dryrun          : logi FALSE
[18:04:16.878]   ..$ quiet           : logi FALSE
[18:04:16.878]   ..$ setup_strategy  : chr "parallel"
[18:04:16.878]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:04:16.911] [local output] System call to launch all workers:
[18:04:16.911] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZUhzkP/worker.rank=1.parallelly.parent=322369.4eb4158480ae1.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11180 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:04:16.912] [local output] Starting PSOCK main server
[18:04:16.920] [local output] Workers launched
[18:04:16.920] [local output] Waiting for workers to connect back
[18:04:16.920]  - [local output] 0 workers out of 2 ready
[18:04:17.275]  - [local output] 0 workers out of 2 ready
[18:04:17.276]  - [local output] 1 workers out of 2 ready
[18:04:17.280]  - [local output] 1 workers out of 2 ready
[18:04:17.280]  - [local output] 2 workers out of 2 ready
[18:04:17.281] [local output] Launching of workers completed
[18:04:17.281] [local output] Collecting session information from workers
[18:04:17.282] [local output]  - Worker #1 of 2
[18:04:17.284] [local output]  - Worker #2 of 2
[18:04:17.284] [local output] makeClusterPSOCK() ... done
[18:04:17.303] Packages needed by the future expression (n = 0): <none>
[18:04:17.303] Packages needed by future strategies (n = 0): <none>
[18:04:17.304] {
[18:04:17.304]     {
[18:04:17.304]         {
[18:04:17.304]             ...future.startTime <- base::Sys.time()
[18:04:17.304]             {
[18:04:17.304]                 {
[18:04:17.304]                   {
[18:04:17.304]                     {
[18:04:17.304]                       base::local({
[18:04:17.304]                         has_future <- base::requireNamespace("future", 
[18:04:17.304]                           quietly = TRUE)
[18:04:17.304]                         if (has_future) {
[18:04:17.304]                           ns <- base::getNamespace("future")
[18:04:17.304]                           version <- ns[[".package"]][["version"]]
[18:04:17.304]                           if (is.null(version)) 
[18:04:17.304]                             version <- utils::packageVersion("future")
[18:04:17.304]                         }
[18:04:17.304]                         else {
[18:04:17.304]                           version <- NULL
[18:04:17.304]                         }
[18:04:17.304]                         if (!has_future || version < "1.8.0") {
[18:04:17.304]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:17.304]                             "", base::R.version$version.string), 
[18:04:17.304]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:17.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:17.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:17.304]                               "release", "version")], collapse = " "), 
[18:04:17.304]                             hostname = base::Sys.info()[["nodename"]])
[18:04:17.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:17.304]                             info)
[18:04:17.304]                           info <- base::paste(info, collapse = "; ")
[18:04:17.304]                           if (!has_future) {
[18:04:17.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:17.304]                               info)
[18:04:17.304]                           }
[18:04:17.304]                           else {
[18:04:17.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:17.304]                               info, version)
[18:04:17.304]                           }
[18:04:17.304]                           base::stop(msg)
[18:04:17.304]                         }
[18:04:17.304]                       })
[18:04:17.304]                     }
[18:04:17.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:17.304]                     base::options(mc.cores = 1L)
[18:04:17.304]                   }
[18:04:17.304]                   ...future.strategy.old <- future::plan("list")
[18:04:17.304]                   options(future.plan = NULL)
[18:04:17.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:17.304]                 }
[18:04:17.304]                 ...future.workdir <- getwd()
[18:04:17.304]             }
[18:04:17.304]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:17.304]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:17.304]         }
[18:04:17.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:17.304]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:17.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:17.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:17.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:17.304]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:17.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:17.304]             base::names(...future.oldOptions))
[18:04:17.304]     }
[18:04:17.304]     if (FALSE) {
[18:04:17.304]     }
[18:04:17.304]     else {
[18:04:17.304]         if (TRUE) {
[18:04:17.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:17.304]                 open = "w")
[18:04:17.304]         }
[18:04:17.304]         else {
[18:04:17.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:17.304]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:17.304]         }
[18:04:17.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:17.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:17.304]             base::sink(type = "output", split = FALSE)
[18:04:17.304]             base::close(...future.stdout)
[18:04:17.304]         }, add = TRUE)
[18:04:17.304]     }
[18:04:17.304]     ...future.frame <- base::sys.nframe()
[18:04:17.304]     ...future.conditions <- base::list()
[18:04:17.304]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:17.304]     if (FALSE) {
[18:04:17.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:17.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:17.304]     }
[18:04:17.304]     ...future.result <- base::tryCatch({
[18:04:17.304]         base::withCallingHandlers({
[18:04:17.304]             ...future.value <- base::withVisible(base::local({
[18:04:17.304]                 ...future.makeSendCondition <- base::local({
[18:04:17.304]                   sendCondition <- NULL
[18:04:17.304]                   function(frame = 1L) {
[18:04:17.304]                     if (is.function(sendCondition)) 
[18:04:17.304]                       return(sendCondition)
[18:04:17.304]                     ns <- getNamespace("parallel")
[18:04:17.304]                     if (exists("sendData", mode = "function", 
[18:04:17.304]                       envir = ns)) {
[18:04:17.304]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:17.304]                         envir = ns)
[18:04:17.304]                       envir <- sys.frame(frame)
[18:04:17.304]                       master <- NULL
[18:04:17.304]                       while (!identical(envir, .GlobalEnv) && 
[18:04:17.304]                         !identical(envir, emptyenv())) {
[18:04:17.304]                         if (exists("master", mode = "list", envir = envir, 
[18:04:17.304]                           inherits = FALSE)) {
[18:04:17.304]                           master <- get("master", mode = "list", 
[18:04:17.304]                             envir = envir, inherits = FALSE)
[18:04:17.304]                           if (inherits(master, c("SOCKnode", 
[18:04:17.304]                             "SOCK0node"))) {
[18:04:17.304]                             sendCondition <<- function(cond) {
[18:04:17.304]                               data <- list(type = "VALUE", value = cond, 
[18:04:17.304]                                 success = TRUE)
[18:04:17.304]                               parallel_sendData(master, data)
[18:04:17.304]                             }
[18:04:17.304]                             return(sendCondition)
[18:04:17.304]                           }
[18:04:17.304]                         }
[18:04:17.304]                         frame <- frame + 1L
[18:04:17.304]                         envir <- sys.frame(frame)
[18:04:17.304]                       }
[18:04:17.304]                     }
[18:04:17.304]                     sendCondition <<- function(cond) NULL
[18:04:17.304]                   }
[18:04:17.304]                 })
[18:04:17.304]                 withCallingHandlers({
[18:04:17.304]                   NA
[18:04:17.304]                 }, immediateCondition = function(cond) {
[18:04:17.304]                   sendCondition <- ...future.makeSendCondition()
[18:04:17.304]                   sendCondition(cond)
[18:04:17.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.304]                   {
[18:04:17.304]                     inherits <- base::inherits
[18:04:17.304]                     invokeRestart <- base::invokeRestart
[18:04:17.304]                     is.null <- base::is.null
[18:04:17.304]                     muffled <- FALSE
[18:04:17.304]                     if (inherits(cond, "message")) {
[18:04:17.304]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:17.304]                       if (muffled) 
[18:04:17.304]                         invokeRestart("muffleMessage")
[18:04:17.304]                     }
[18:04:17.304]                     else if (inherits(cond, "warning")) {
[18:04:17.304]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:17.304]                       if (muffled) 
[18:04:17.304]                         invokeRestart("muffleWarning")
[18:04:17.304]                     }
[18:04:17.304]                     else if (inherits(cond, "condition")) {
[18:04:17.304]                       if (!is.null(pattern)) {
[18:04:17.304]                         computeRestarts <- base::computeRestarts
[18:04:17.304]                         grepl <- base::grepl
[18:04:17.304]                         restarts <- computeRestarts(cond)
[18:04:17.304]                         for (restart in restarts) {
[18:04:17.304]                           name <- restart$name
[18:04:17.304]                           if (is.null(name)) 
[18:04:17.304]                             next
[18:04:17.304]                           if (!grepl(pattern, name)) 
[18:04:17.304]                             next
[18:04:17.304]                           invokeRestart(restart)
[18:04:17.304]                           muffled <- TRUE
[18:04:17.304]                           break
[18:04:17.304]                         }
[18:04:17.304]                       }
[18:04:17.304]                     }
[18:04:17.304]                     invisible(muffled)
[18:04:17.304]                   }
[18:04:17.304]                   muffleCondition(cond)
[18:04:17.304]                 })
[18:04:17.304]             }))
[18:04:17.304]             future::FutureResult(value = ...future.value$value, 
[18:04:17.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.304]                   ...future.rng), globalenv = if (FALSE) 
[18:04:17.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:17.304]                     ...future.globalenv.names))
[18:04:17.304]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:17.304]         }, condition = base::local({
[18:04:17.304]             c <- base::c
[18:04:17.304]             inherits <- base::inherits
[18:04:17.304]             invokeRestart <- base::invokeRestart
[18:04:17.304]             length <- base::length
[18:04:17.304]             list <- base::list
[18:04:17.304]             seq.int <- base::seq.int
[18:04:17.304]             signalCondition <- base::signalCondition
[18:04:17.304]             sys.calls <- base::sys.calls
[18:04:17.304]             `[[` <- base::`[[`
[18:04:17.304]             `+` <- base::`+`
[18:04:17.304]             `<<-` <- base::`<<-`
[18:04:17.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:17.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:17.304]                   3L)]
[18:04:17.304]             }
[18:04:17.304]             function(cond) {
[18:04:17.304]                 is_error <- inherits(cond, "error")
[18:04:17.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:17.304]                   NULL)
[18:04:17.304]                 if (is_error) {
[18:04:17.304]                   sessionInformation <- function() {
[18:04:17.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:17.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:17.304]                       search = base::search(), system = base::Sys.info())
[18:04:17.304]                   }
[18:04:17.304]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:17.304]                     cond$call), session = sessionInformation(), 
[18:04:17.304]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:17.304]                   signalCondition(cond)
[18:04:17.304]                 }
[18:04:17.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:17.304]                 "immediateCondition"))) {
[18:04:17.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:17.304]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:17.304]                   if (TRUE && !signal) {
[18:04:17.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.304]                     {
[18:04:17.304]                       inherits <- base::inherits
[18:04:17.304]                       invokeRestart <- base::invokeRestart
[18:04:17.304]                       is.null <- base::is.null
[18:04:17.304]                       muffled <- FALSE
[18:04:17.304]                       if (inherits(cond, "message")) {
[18:04:17.304]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.304]                         if (muffled) 
[18:04:17.304]                           invokeRestart("muffleMessage")
[18:04:17.304]                       }
[18:04:17.304]                       else if (inherits(cond, "warning")) {
[18:04:17.304]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.304]                         if (muffled) 
[18:04:17.304]                           invokeRestart("muffleWarning")
[18:04:17.304]                       }
[18:04:17.304]                       else if (inherits(cond, "condition")) {
[18:04:17.304]                         if (!is.null(pattern)) {
[18:04:17.304]                           computeRestarts <- base::computeRestarts
[18:04:17.304]                           grepl <- base::grepl
[18:04:17.304]                           restarts <- computeRestarts(cond)
[18:04:17.304]                           for (restart in restarts) {
[18:04:17.304]                             name <- restart$name
[18:04:17.304]                             if (is.null(name)) 
[18:04:17.304]                               next
[18:04:17.304]                             if (!grepl(pattern, name)) 
[18:04:17.304]                               next
[18:04:17.304]                             invokeRestart(restart)
[18:04:17.304]                             muffled <- TRUE
[18:04:17.304]                             break
[18:04:17.304]                           }
[18:04:17.304]                         }
[18:04:17.304]                       }
[18:04:17.304]                       invisible(muffled)
[18:04:17.304]                     }
[18:04:17.304]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.304]                   }
[18:04:17.304]                 }
[18:04:17.304]                 else {
[18:04:17.304]                   if (TRUE) {
[18:04:17.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.304]                     {
[18:04:17.304]                       inherits <- base::inherits
[18:04:17.304]                       invokeRestart <- base::invokeRestart
[18:04:17.304]                       is.null <- base::is.null
[18:04:17.304]                       muffled <- FALSE
[18:04:17.304]                       if (inherits(cond, "message")) {
[18:04:17.304]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.304]                         if (muffled) 
[18:04:17.304]                           invokeRestart("muffleMessage")
[18:04:17.304]                       }
[18:04:17.304]                       else if (inherits(cond, "warning")) {
[18:04:17.304]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.304]                         if (muffled) 
[18:04:17.304]                           invokeRestart("muffleWarning")
[18:04:17.304]                       }
[18:04:17.304]                       else if (inherits(cond, "condition")) {
[18:04:17.304]                         if (!is.null(pattern)) {
[18:04:17.304]                           computeRestarts <- base::computeRestarts
[18:04:17.304]                           grepl <- base::grepl
[18:04:17.304]                           restarts <- computeRestarts(cond)
[18:04:17.304]                           for (restart in restarts) {
[18:04:17.304]                             name <- restart$name
[18:04:17.304]                             if (is.null(name)) 
[18:04:17.304]                               next
[18:04:17.304]                             if (!grepl(pattern, name)) 
[18:04:17.304]                               next
[18:04:17.304]                             invokeRestart(restart)
[18:04:17.304]                             muffled <- TRUE
[18:04:17.304]                             break
[18:04:17.304]                           }
[18:04:17.304]                         }
[18:04:17.304]                       }
[18:04:17.304]                       invisible(muffled)
[18:04:17.304]                     }
[18:04:17.304]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.304]                   }
[18:04:17.304]                 }
[18:04:17.304]             }
[18:04:17.304]         }))
[18:04:17.304]     }, error = function(ex) {
[18:04:17.304]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:17.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.304]                 ...future.rng), started = ...future.startTime, 
[18:04:17.304]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:17.304]             version = "1.8"), class = "FutureResult")
[18:04:17.304]     }, finally = {
[18:04:17.304]         if (!identical(...future.workdir, getwd())) 
[18:04:17.304]             setwd(...future.workdir)
[18:04:17.304]         {
[18:04:17.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:17.304]                 ...future.oldOptions$nwarnings <- NULL
[18:04:17.304]             }
[18:04:17.304]             base::options(...future.oldOptions)
[18:04:17.304]             if (.Platform$OS.type == "windows") {
[18:04:17.304]                 old_names <- names(...future.oldEnvVars)
[18:04:17.304]                 envs <- base::Sys.getenv()
[18:04:17.304]                 names <- names(envs)
[18:04:17.304]                 common <- intersect(names, old_names)
[18:04:17.304]                 added <- setdiff(names, old_names)
[18:04:17.304]                 removed <- setdiff(old_names, names)
[18:04:17.304]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:17.304]                   envs[common]]
[18:04:17.304]                 NAMES <- toupper(changed)
[18:04:17.304]                 args <- list()
[18:04:17.304]                 for (kk in seq_along(NAMES)) {
[18:04:17.304]                   name <- changed[[kk]]
[18:04:17.304]                   NAME <- NAMES[[kk]]
[18:04:17.304]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.304]                     next
[18:04:17.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.304]                 }
[18:04:17.304]                 NAMES <- toupper(added)
[18:04:17.304]                 for (kk in seq_along(NAMES)) {
[18:04:17.304]                   name <- added[[kk]]
[18:04:17.304]                   NAME <- NAMES[[kk]]
[18:04:17.304]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.304]                     next
[18:04:17.304]                   args[[name]] <- ""
[18:04:17.304]                 }
[18:04:17.304]                 NAMES <- toupper(removed)
[18:04:17.304]                 for (kk in seq_along(NAMES)) {
[18:04:17.304]                   name <- removed[[kk]]
[18:04:17.304]                   NAME <- NAMES[[kk]]
[18:04:17.304]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.304]                     next
[18:04:17.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.304]                 }
[18:04:17.304]                 if (length(args) > 0) 
[18:04:17.304]                   base::do.call(base::Sys.setenv, args = args)
[18:04:17.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:17.304]             }
[18:04:17.304]             else {
[18:04:17.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:17.304]             }
[18:04:17.304]             {
[18:04:17.304]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:17.304]                   0L) {
[18:04:17.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:17.304]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:17.304]                   base::options(opts)
[18:04:17.304]                 }
[18:04:17.304]                 {
[18:04:17.304]                   {
[18:04:17.304]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:17.304]                     NULL
[18:04:17.304]                   }
[18:04:17.304]                   options(future.plan = NULL)
[18:04:17.304]                   if (is.na(NA_character_)) 
[18:04:17.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:17.304]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:17.304]                     .init = FALSE)
[18:04:17.304]                 }
[18:04:17.304]             }
[18:04:17.304]         }
[18:04:17.304]     })
[18:04:17.304]     if (TRUE) {
[18:04:17.304]         base::sink(type = "output", split = FALSE)
[18:04:17.304]         if (TRUE) {
[18:04:17.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:17.304]         }
[18:04:17.304]         else {
[18:04:17.304]             ...future.result["stdout"] <- base::list(NULL)
[18:04:17.304]         }
[18:04:17.304]         base::close(...future.stdout)
[18:04:17.304]         ...future.stdout <- NULL
[18:04:17.304]     }
[18:04:17.304]     ...future.result$conditions <- ...future.conditions
[18:04:17.304]     ...future.result$finished <- base::Sys.time()
[18:04:17.304]     ...future.result
[18:04:17.304] }
[18:04:17.406] MultisessionFuture started
[18:04:17.407] result() for ClusterFuture ...
[18:04:17.407] receiveMessageFromWorker() for ClusterFuture ...
[18:04:17.408] - Validating connection of MultisessionFuture
[18:04:17.475] - received message: FutureResult
[18:04:17.475] - Received FutureResult
[18:04:17.476] - Erased future from FutureRegistry
[18:04:17.476] result() for ClusterFuture ...
[18:04:17.476] - result already collected: FutureResult
[18:04:17.477] result() for ClusterFuture ... done
[18:04:17.477] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:17.477] result() for ClusterFuture ... done
[18:04:17.478] result() for ClusterFuture ...
[18:04:17.478] - result already collected: FutureResult
[18:04:17.478] result() for ClusterFuture ... done
[18:04:17.479] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:04:17.486] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[18:04:17.486] getGlobalsAndPackages() ...
[18:04:17.487] Searching for globals...
[18:04:17.488] 
[18:04:17.488] Searching for globals ... DONE
[18:04:17.488] - globals: [0] <none>
[18:04:17.488] getGlobalsAndPackages() ... DONE
[18:04:17.489] run() for ‘Future’ ...
[18:04:17.489] - state: ‘created’
[18:04:17.489] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:17.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:17.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:17.517]   - Field: ‘node’
[18:04:17.517]   - Field: ‘label’
[18:04:17.517]   - Field: ‘local’
[18:04:17.517]   - Field: ‘owner’
[18:04:17.518]   - Field: ‘envir’
[18:04:17.518]   - Field: ‘workers’
[18:04:17.518]   - Field: ‘packages’
[18:04:17.518]   - Field: ‘gc’
[18:04:17.519]   - Field: ‘conditions’
[18:04:17.519]   - Field: ‘persistent’
[18:04:17.519]   - Field: ‘expr’
[18:04:17.519]   - Field: ‘uuid’
[18:04:17.520]   - Field: ‘seed’
[18:04:17.520]   - Field: ‘version’
[18:04:17.520]   - Field: ‘result’
[18:04:17.520]   - Field: ‘asynchronous’
[18:04:17.520]   - Field: ‘calls’
[18:04:17.521]   - Field: ‘globals’
[18:04:17.521]   - Field: ‘stdout’
[18:04:17.522]   - Field: ‘earlySignal’
[18:04:17.522]   - Field: ‘lazy’
[18:04:17.522]   - Field: ‘state’
[18:04:17.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:17.523] - Launch lazy future ...
[18:04:17.523] Packages needed by the future expression (n = 0): <none>
[18:04:17.523] Packages needed by future strategies (n = 0): <none>
[18:04:17.524] {
[18:04:17.524]     {
[18:04:17.524]         {
[18:04:17.524]             ...future.startTime <- base::Sys.time()
[18:04:17.524]             {
[18:04:17.524]                 {
[18:04:17.524]                   {
[18:04:17.524]                     {
[18:04:17.524]                       base::local({
[18:04:17.524]                         has_future <- base::requireNamespace("future", 
[18:04:17.524]                           quietly = TRUE)
[18:04:17.524]                         if (has_future) {
[18:04:17.524]                           ns <- base::getNamespace("future")
[18:04:17.524]                           version <- ns[[".package"]][["version"]]
[18:04:17.524]                           if (is.null(version)) 
[18:04:17.524]                             version <- utils::packageVersion("future")
[18:04:17.524]                         }
[18:04:17.524]                         else {
[18:04:17.524]                           version <- NULL
[18:04:17.524]                         }
[18:04:17.524]                         if (!has_future || version < "1.8.0") {
[18:04:17.524]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:17.524]                             "", base::R.version$version.string), 
[18:04:17.524]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:17.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:17.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:17.524]                               "release", "version")], collapse = " "), 
[18:04:17.524]                             hostname = base::Sys.info()[["nodename"]])
[18:04:17.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:17.524]                             info)
[18:04:17.524]                           info <- base::paste(info, collapse = "; ")
[18:04:17.524]                           if (!has_future) {
[18:04:17.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:17.524]                               info)
[18:04:17.524]                           }
[18:04:17.524]                           else {
[18:04:17.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:17.524]                               info, version)
[18:04:17.524]                           }
[18:04:17.524]                           base::stop(msg)
[18:04:17.524]                         }
[18:04:17.524]                       })
[18:04:17.524]                     }
[18:04:17.524]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:17.524]                     base::options(mc.cores = 1L)
[18:04:17.524]                   }
[18:04:17.524]                   ...future.strategy.old <- future::plan("list")
[18:04:17.524]                   options(future.plan = NULL)
[18:04:17.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:17.524]                 }
[18:04:17.524]                 ...future.workdir <- getwd()
[18:04:17.524]             }
[18:04:17.524]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:17.524]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:17.524]         }
[18:04:17.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:17.524]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:17.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:17.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:17.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:17.524]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:17.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:17.524]             base::names(...future.oldOptions))
[18:04:17.524]     }
[18:04:17.524]     if (FALSE) {
[18:04:17.524]     }
[18:04:17.524]     else {
[18:04:17.524]         if (TRUE) {
[18:04:17.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:17.524]                 open = "w")
[18:04:17.524]         }
[18:04:17.524]         else {
[18:04:17.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:17.524]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:17.524]         }
[18:04:17.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:17.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:17.524]             base::sink(type = "output", split = FALSE)
[18:04:17.524]             base::close(...future.stdout)
[18:04:17.524]         }, add = TRUE)
[18:04:17.524]     }
[18:04:17.524]     ...future.frame <- base::sys.nframe()
[18:04:17.524]     ...future.conditions <- base::list()
[18:04:17.524]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:17.524]     if (FALSE) {
[18:04:17.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:17.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:17.524]     }
[18:04:17.524]     ...future.result <- base::tryCatch({
[18:04:17.524]         base::withCallingHandlers({
[18:04:17.524]             ...future.value <- base::withVisible(base::local({
[18:04:17.524]                 ...future.makeSendCondition <- base::local({
[18:04:17.524]                   sendCondition <- NULL
[18:04:17.524]                   function(frame = 1L) {
[18:04:17.524]                     if (is.function(sendCondition)) 
[18:04:17.524]                       return(sendCondition)
[18:04:17.524]                     ns <- getNamespace("parallel")
[18:04:17.524]                     if (exists("sendData", mode = "function", 
[18:04:17.524]                       envir = ns)) {
[18:04:17.524]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:17.524]                         envir = ns)
[18:04:17.524]                       envir <- sys.frame(frame)
[18:04:17.524]                       master <- NULL
[18:04:17.524]                       while (!identical(envir, .GlobalEnv) && 
[18:04:17.524]                         !identical(envir, emptyenv())) {
[18:04:17.524]                         if (exists("master", mode = "list", envir = envir, 
[18:04:17.524]                           inherits = FALSE)) {
[18:04:17.524]                           master <- get("master", mode = "list", 
[18:04:17.524]                             envir = envir, inherits = FALSE)
[18:04:17.524]                           if (inherits(master, c("SOCKnode", 
[18:04:17.524]                             "SOCK0node"))) {
[18:04:17.524]                             sendCondition <<- function(cond) {
[18:04:17.524]                               data <- list(type = "VALUE", value = cond, 
[18:04:17.524]                                 success = TRUE)
[18:04:17.524]                               parallel_sendData(master, data)
[18:04:17.524]                             }
[18:04:17.524]                             return(sendCondition)
[18:04:17.524]                           }
[18:04:17.524]                         }
[18:04:17.524]                         frame <- frame + 1L
[18:04:17.524]                         envir <- sys.frame(frame)
[18:04:17.524]                       }
[18:04:17.524]                     }
[18:04:17.524]                     sendCondition <<- function(cond) NULL
[18:04:17.524]                   }
[18:04:17.524]                 })
[18:04:17.524]                 withCallingHandlers({
[18:04:17.524]                   2
[18:04:17.524]                 }, immediateCondition = function(cond) {
[18:04:17.524]                   sendCondition <- ...future.makeSendCondition()
[18:04:17.524]                   sendCondition(cond)
[18:04:17.524]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.524]                   {
[18:04:17.524]                     inherits <- base::inherits
[18:04:17.524]                     invokeRestart <- base::invokeRestart
[18:04:17.524]                     is.null <- base::is.null
[18:04:17.524]                     muffled <- FALSE
[18:04:17.524]                     if (inherits(cond, "message")) {
[18:04:17.524]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:17.524]                       if (muffled) 
[18:04:17.524]                         invokeRestart("muffleMessage")
[18:04:17.524]                     }
[18:04:17.524]                     else if (inherits(cond, "warning")) {
[18:04:17.524]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:17.524]                       if (muffled) 
[18:04:17.524]                         invokeRestart("muffleWarning")
[18:04:17.524]                     }
[18:04:17.524]                     else if (inherits(cond, "condition")) {
[18:04:17.524]                       if (!is.null(pattern)) {
[18:04:17.524]                         computeRestarts <- base::computeRestarts
[18:04:17.524]                         grepl <- base::grepl
[18:04:17.524]                         restarts <- computeRestarts(cond)
[18:04:17.524]                         for (restart in restarts) {
[18:04:17.524]                           name <- restart$name
[18:04:17.524]                           if (is.null(name)) 
[18:04:17.524]                             next
[18:04:17.524]                           if (!grepl(pattern, name)) 
[18:04:17.524]                             next
[18:04:17.524]                           invokeRestart(restart)
[18:04:17.524]                           muffled <- TRUE
[18:04:17.524]                           break
[18:04:17.524]                         }
[18:04:17.524]                       }
[18:04:17.524]                     }
[18:04:17.524]                     invisible(muffled)
[18:04:17.524]                   }
[18:04:17.524]                   muffleCondition(cond)
[18:04:17.524]                 })
[18:04:17.524]             }))
[18:04:17.524]             future::FutureResult(value = ...future.value$value, 
[18:04:17.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.524]                   ...future.rng), globalenv = if (FALSE) 
[18:04:17.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:17.524]                     ...future.globalenv.names))
[18:04:17.524]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:17.524]         }, condition = base::local({
[18:04:17.524]             c <- base::c
[18:04:17.524]             inherits <- base::inherits
[18:04:17.524]             invokeRestart <- base::invokeRestart
[18:04:17.524]             length <- base::length
[18:04:17.524]             list <- base::list
[18:04:17.524]             seq.int <- base::seq.int
[18:04:17.524]             signalCondition <- base::signalCondition
[18:04:17.524]             sys.calls <- base::sys.calls
[18:04:17.524]             `[[` <- base::`[[`
[18:04:17.524]             `+` <- base::`+`
[18:04:17.524]             `<<-` <- base::`<<-`
[18:04:17.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:17.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:17.524]                   3L)]
[18:04:17.524]             }
[18:04:17.524]             function(cond) {
[18:04:17.524]                 is_error <- inherits(cond, "error")
[18:04:17.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:17.524]                   NULL)
[18:04:17.524]                 if (is_error) {
[18:04:17.524]                   sessionInformation <- function() {
[18:04:17.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:17.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:17.524]                       search = base::search(), system = base::Sys.info())
[18:04:17.524]                   }
[18:04:17.524]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:17.524]                     cond$call), session = sessionInformation(), 
[18:04:17.524]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:17.524]                   signalCondition(cond)
[18:04:17.524]                 }
[18:04:17.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:17.524]                 "immediateCondition"))) {
[18:04:17.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:17.524]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:17.524]                   if (TRUE && !signal) {
[18:04:17.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.524]                     {
[18:04:17.524]                       inherits <- base::inherits
[18:04:17.524]                       invokeRestart <- base::invokeRestart
[18:04:17.524]                       is.null <- base::is.null
[18:04:17.524]                       muffled <- FALSE
[18:04:17.524]                       if (inherits(cond, "message")) {
[18:04:17.524]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.524]                         if (muffled) 
[18:04:17.524]                           invokeRestart("muffleMessage")
[18:04:17.524]                       }
[18:04:17.524]                       else if (inherits(cond, "warning")) {
[18:04:17.524]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.524]                         if (muffled) 
[18:04:17.524]                           invokeRestart("muffleWarning")
[18:04:17.524]                       }
[18:04:17.524]                       else if (inherits(cond, "condition")) {
[18:04:17.524]                         if (!is.null(pattern)) {
[18:04:17.524]                           computeRestarts <- base::computeRestarts
[18:04:17.524]                           grepl <- base::grepl
[18:04:17.524]                           restarts <- computeRestarts(cond)
[18:04:17.524]                           for (restart in restarts) {
[18:04:17.524]                             name <- restart$name
[18:04:17.524]                             if (is.null(name)) 
[18:04:17.524]                               next
[18:04:17.524]                             if (!grepl(pattern, name)) 
[18:04:17.524]                               next
[18:04:17.524]                             invokeRestart(restart)
[18:04:17.524]                             muffled <- TRUE
[18:04:17.524]                             break
[18:04:17.524]                           }
[18:04:17.524]                         }
[18:04:17.524]                       }
[18:04:17.524]                       invisible(muffled)
[18:04:17.524]                     }
[18:04:17.524]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.524]                   }
[18:04:17.524]                 }
[18:04:17.524]                 else {
[18:04:17.524]                   if (TRUE) {
[18:04:17.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.524]                     {
[18:04:17.524]                       inherits <- base::inherits
[18:04:17.524]                       invokeRestart <- base::invokeRestart
[18:04:17.524]                       is.null <- base::is.null
[18:04:17.524]                       muffled <- FALSE
[18:04:17.524]                       if (inherits(cond, "message")) {
[18:04:17.524]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.524]                         if (muffled) 
[18:04:17.524]                           invokeRestart("muffleMessage")
[18:04:17.524]                       }
[18:04:17.524]                       else if (inherits(cond, "warning")) {
[18:04:17.524]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.524]                         if (muffled) 
[18:04:17.524]                           invokeRestart("muffleWarning")
[18:04:17.524]                       }
[18:04:17.524]                       else if (inherits(cond, "condition")) {
[18:04:17.524]                         if (!is.null(pattern)) {
[18:04:17.524]                           computeRestarts <- base::computeRestarts
[18:04:17.524]                           grepl <- base::grepl
[18:04:17.524]                           restarts <- computeRestarts(cond)
[18:04:17.524]                           for (restart in restarts) {
[18:04:17.524]                             name <- restart$name
[18:04:17.524]                             if (is.null(name)) 
[18:04:17.524]                               next
[18:04:17.524]                             if (!grepl(pattern, name)) 
[18:04:17.524]                               next
[18:04:17.524]                             invokeRestart(restart)
[18:04:17.524]                             muffled <- TRUE
[18:04:17.524]                             break
[18:04:17.524]                           }
[18:04:17.524]                         }
[18:04:17.524]                       }
[18:04:17.524]                       invisible(muffled)
[18:04:17.524]                     }
[18:04:17.524]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.524]                   }
[18:04:17.524]                 }
[18:04:17.524]             }
[18:04:17.524]         }))
[18:04:17.524]     }, error = function(ex) {
[18:04:17.524]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:17.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.524]                 ...future.rng), started = ...future.startTime, 
[18:04:17.524]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:17.524]             version = "1.8"), class = "FutureResult")
[18:04:17.524]     }, finally = {
[18:04:17.524]         if (!identical(...future.workdir, getwd())) 
[18:04:17.524]             setwd(...future.workdir)
[18:04:17.524]         {
[18:04:17.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:17.524]                 ...future.oldOptions$nwarnings <- NULL
[18:04:17.524]             }
[18:04:17.524]             base::options(...future.oldOptions)
[18:04:17.524]             if (.Platform$OS.type == "windows") {
[18:04:17.524]                 old_names <- names(...future.oldEnvVars)
[18:04:17.524]                 envs <- base::Sys.getenv()
[18:04:17.524]                 names <- names(envs)
[18:04:17.524]                 common <- intersect(names, old_names)
[18:04:17.524]                 added <- setdiff(names, old_names)
[18:04:17.524]                 removed <- setdiff(old_names, names)
[18:04:17.524]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:17.524]                   envs[common]]
[18:04:17.524]                 NAMES <- toupper(changed)
[18:04:17.524]                 args <- list()
[18:04:17.524]                 for (kk in seq_along(NAMES)) {
[18:04:17.524]                   name <- changed[[kk]]
[18:04:17.524]                   NAME <- NAMES[[kk]]
[18:04:17.524]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.524]                     next
[18:04:17.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.524]                 }
[18:04:17.524]                 NAMES <- toupper(added)
[18:04:17.524]                 for (kk in seq_along(NAMES)) {
[18:04:17.524]                   name <- added[[kk]]
[18:04:17.524]                   NAME <- NAMES[[kk]]
[18:04:17.524]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.524]                     next
[18:04:17.524]                   args[[name]] <- ""
[18:04:17.524]                 }
[18:04:17.524]                 NAMES <- toupper(removed)
[18:04:17.524]                 for (kk in seq_along(NAMES)) {
[18:04:17.524]                   name <- removed[[kk]]
[18:04:17.524]                   NAME <- NAMES[[kk]]
[18:04:17.524]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.524]                     next
[18:04:17.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.524]                 }
[18:04:17.524]                 if (length(args) > 0) 
[18:04:17.524]                   base::do.call(base::Sys.setenv, args = args)
[18:04:17.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:17.524]             }
[18:04:17.524]             else {
[18:04:17.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:17.524]             }
[18:04:17.524]             {
[18:04:17.524]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:17.524]                   0L) {
[18:04:17.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:17.524]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:17.524]                   base::options(opts)
[18:04:17.524]                 }
[18:04:17.524]                 {
[18:04:17.524]                   {
[18:04:17.524]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:17.524]                     NULL
[18:04:17.524]                   }
[18:04:17.524]                   options(future.plan = NULL)
[18:04:17.524]                   if (is.na(NA_character_)) 
[18:04:17.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:17.524]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:17.524]                     .init = FALSE)
[18:04:17.524]                 }
[18:04:17.524]             }
[18:04:17.524]         }
[18:04:17.524]     })
[18:04:17.524]     if (TRUE) {
[18:04:17.524]         base::sink(type = "output", split = FALSE)
[18:04:17.524]         if (TRUE) {
[18:04:17.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:17.524]         }
[18:04:17.524]         else {
[18:04:17.524]             ...future.result["stdout"] <- base::list(NULL)
[18:04:17.524]         }
[18:04:17.524]         base::close(...future.stdout)
[18:04:17.524]         ...future.stdout <- NULL
[18:04:17.524]     }
[18:04:17.524]     ...future.result$conditions <- ...future.conditions
[18:04:17.524]     ...future.result$finished <- base::Sys.time()
[18:04:17.524]     ...future.result
[18:04:17.524] }
[18:04:17.530] MultisessionFuture started
[18:04:17.531] - Launch lazy future ... done
[18:04:17.531] run() for ‘MultisessionFuture’ ... done
[18:04:17.531] getGlobalsAndPackages() ...
[18:04:17.532] Searching for globals...
[18:04:17.533] 
[18:04:17.533] Searching for globals ... DONE
[18:04:17.533] - globals: [0] <none>
[18:04:17.533] getGlobalsAndPackages() ... DONE
[18:04:17.534] run() for ‘Future’ ...
[18:04:17.534] - state: ‘created’
[18:04:17.534] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:17.562] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:17.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:17.563]   - Field: ‘node’
[18:04:17.563]   - Field: ‘label’
[18:04:17.563]   - Field: ‘local’
[18:04:17.564]   - Field: ‘owner’
[18:04:17.564]   - Field: ‘envir’
[18:04:17.564]   - Field: ‘workers’
[18:04:17.564]   - Field: ‘packages’
[18:04:17.564]   - Field: ‘gc’
[18:04:17.565]   - Field: ‘conditions’
[18:04:17.565]   - Field: ‘persistent’
[18:04:17.565]   - Field: ‘expr’
[18:04:17.565]   - Field: ‘uuid’
[18:04:17.566]   - Field: ‘seed’
[18:04:17.566]   - Field: ‘version’
[18:04:17.566]   - Field: ‘result’
[18:04:17.566]   - Field: ‘asynchronous’
[18:04:17.567]   - Field: ‘calls’
[18:04:17.567]   - Field: ‘globals’
[18:04:17.567]   - Field: ‘stdout’
[18:04:17.567]   - Field: ‘earlySignal’
[18:04:17.568]   - Field: ‘lazy’
[18:04:17.568]   - Field: ‘state’
[18:04:17.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:17.568] - Launch lazy future ...
[18:04:17.569] Packages needed by the future expression (n = 0): <none>
[18:04:17.569] Packages needed by future strategies (n = 0): <none>
[18:04:17.570] {
[18:04:17.570]     {
[18:04:17.570]         {
[18:04:17.570]             ...future.startTime <- base::Sys.time()
[18:04:17.570]             {
[18:04:17.570]                 {
[18:04:17.570]                   {
[18:04:17.570]                     {
[18:04:17.570]                       base::local({
[18:04:17.570]                         has_future <- base::requireNamespace("future", 
[18:04:17.570]                           quietly = TRUE)
[18:04:17.570]                         if (has_future) {
[18:04:17.570]                           ns <- base::getNamespace("future")
[18:04:17.570]                           version <- ns[[".package"]][["version"]]
[18:04:17.570]                           if (is.null(version)) 
[18:04:17.570]                             version <- utils::packageVersion("future")
[18:04:17.570]                         }
[18:04:17.570]                         else {
[18:04:17.570]                           version <- NULL
[18:04:17.570]                         }
[18:04:17.570]                         if (!has_future || version < "1.8.0") {
[18:04:17.570]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:17.570]                             "", base::R.version$version.string), 
[18:04:17.570]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:17.570]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:17.570]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:17.570]                               "release", "version")], collapse = " "), 
[18:04:17.570]                             hostname = base::Sys.info()[["nodename"]])
[18:04:17.570]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:17.570]                             info)
[18:04:17.570]                           info <- base::paste(info, collapse = "; ")
[18:04:17.570]                           if (!has_future) {
[18:04:17.570]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:17.570]                               info)
[18:04:17.570]                           }
[18:04:17.570]                           else {
[18:04:17.570]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:17.570]                               info, version)
[18:04:17.570]                           }
[18:04:17.570]                           base::stop(msg)
[18:04:17.570]                         }
[18:04:17.570]                       })
[18:04:17.570]                     }
[18:04:17.570]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:17.570]                     base::options(mc.cores = 1L)
[18:04:17.570]                   }
[18:04:17.570]                   ...future.strategy.old <- future::plan("list")
[18:04:17.570]                   options(future.plan = NULL)
[18:04:17.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:17.570]                 }
[18:04:17.570]                 ...future.workdir <- getwd()
[18:04:17.570]             }
[18:04:17.570]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:17.570]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:17.570]         }
[18:04:17.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:17.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:17.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:17.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:17.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:17.570]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:17.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:17.570]             base::names(...future.oldOptions))
[18:04:17.570]     }
[18:04:17.570]     if (FALSE) {
[18:04:17.570]     }
[18:04:17.570]     else {
[18:04:17.570]         if (TRUE) {
[18:04:17.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:17.570]                 open = "w")
[18:04:17.570]         }
[18:04:17.570]         else {
[18:04:17.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:17.570]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:17.570]         }
[18:04:17.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:17.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:17.570]             base::sink(type = "output", split = FALSE)
[18:04:17.570]             base::close(...future.stdout)
[18:04:17.570]         }, add = TRUE)
[18:04:17.570]     }
[18:04:17.570]     ...future.frame <- base::sys.nframe()
[18:04:17.570]     ...future.conditions <- base::list()
[18:04:17.570]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:17.570]     if (FALSE) {
[18:04:17.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:17.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:17.570]     }
[18:04:17.570]     ...future.result <- base::tryCatch({
[18:04:17.570]         base::withCallingHandlers({
[18:04:17.570]             ...future.value <- base::withVisible(base::local({
[18:04:17.570]                 ...future.makeSendCondition <- base::local({
[18:04:17.570]                   sendCondition <- NULL
[18:04:17.570]                   function(frame = 1L) {
[18:04:17.570]                     if (is.function(sendCondition)) 
[18:04:17.570]                       return(sendCondition)
[18:04:17.570]                     ns <- getNamespace("parallel")
[18:04:17.570]                     if (exists("sendData", mode = "function", 
[18:04:17.570]                       envir = ns)) {
[18:04:17.570]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:17.570]                         envir = ns)
[18:04:17.570]                       envir <- sys.frame(frame)
[18:04:17.570]                       master <- NULL
[18:04:17.570]                       while (!identical(envir, .GlobalEnv) && 
[18:04:17.570]                         !identical(envir, emptyenv())) {
[18:04:17.570]                         if (exists("master", mode = "list", envir = envir, 
[18:04:17.570]                           inherits = FALSE)) {
[18:04:17.570]                           master <- get("master", mode = "list", 
[18:04:17.570]                             envir = envir, inherits = FALSE)
[18:04:17.570]                           if (inherits(master, c("SOCKnode", 
[18:04:17.570]                             "SOCK0node"))) {
[18:04:17.570]                             sendCondition <<- function(cond) {
[18:04:17.570]                               data <- list(type = "VALUE", value = cond, 
[18:04:17.570]                                 success = TRUE)
[18:04:17.570]                               parallel_sendData(master, data)
[18:04:17.570]                             }
[18:04:17.570]                             return(sendCondition)
[18:04:17.570]                           }
[18:04:17.570]                         }
[18:04:17.570]                         frame <- frame + 1L
[18:04:17.570]                         envir <- sys.frame(frame)
[18:04:17.570]                       }
[18:04:17.570]                     }
[18:04:17.570]                     sendCondition <<- function(cond) NULL
[18:04:17.570]                   }
[18:04:17.570]                 })
[18:04:17.570]                 withCallingHandlers({
[18:04:17.570]                   NULL
[18:04:17.570]                 }, immediateCondition = function(cond) {
[18:04:17.570]                   sendCondition <- ...future.makeSendCondition()
[18:04:17.570]                   sendCondition(cond)
[18:04:17.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.570]                   {
[18:04:17.570]                     inherits <- base::inherits
[18:04:17.570]                     invokeRestart <- base::invokeRestart
[18:04:17.570]                     is.null <- base::is.null
[18:04:17.570]                     muffled <- FALSE
[18:04:17.570]                     if (inherits(cond, "message")) {
[18:04:17.570]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:17.570]                       if (muffled) 
[18:04:17.570]                         invokeRestart("muffleMessage")
[18:04:17.570]                     }
[18:04:17.570]                     else if (inherits(cond, "warning")) {
[18:04:17.570]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:17.570]                       if (muffled) 
[18:04:17.570]                         invokeRestart("muffleWarning")
[18:04:17.570]                     }
[18:04:17.570]                     else if (inherits(cond, "condition")) {
[18:04:17.570]                       if (!is.null(pattern)) {
[18:04:17.570]                         computeRestarts <- base::computeRestarts
[18:04:17.570]                         grepl <- base::grepl
[18:04:17.570]                         restarts <- computeRestarts(cond)
[18:04:17.570]                         for (restart in restarts) {
[18:04:17.570]                           name <- restart$name
[18:04:17.570]                           if (is.null(name)) 
[18:04:17.570]                             next
[18:04:17.570]                           if (!grepl(pattern, name)) 
[18:04:17.570]                             next
[18:04:17.570]                           invokeRestart(restart)
[18:04:17.570]                           muffled <- TRUE
[18:04:17.570]                           break
[18:04:17.570]                         }
[18:04:17.570]                       }
[18:04:17.570]                     }
[18:04:17.570]                     invisible(muffled)
[18:04:17.570]                   }
[18:04:17.570]                   muffleCondition(cond)
[18:04:17.570]                 })
[18:04:17.570]             }))
[18:04:17.570]             future::FutureResult(value = ...future.value$value, 
[18:04:17.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.570]                   ...future.rng), globalenv = if (FALSE) 
[18:04:17.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:17.570]                     ...future.globalenv.names))
[18:04:17.570]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:17.570]         }, condition = base::local({
[18:04:17.570]             c <- base::c
[18:04:17.570]             inherits <- base::inherits
[18:04:17.570]             invokeRestart <- base::invokeRestart
[18:04:17.570]             length <- base::length
[18:04:17.570]             list <- base::list
[18:04:17.570]             seq.int <- base::seq.int
[18:04:17.570]             signalCondition <- base::signalCondition
[18:04:17.570]             sys.calls <- base::sys.calls
[18:04:17.570]             `[[` <- base::`[[`
[18:04:17.570]             `+` <- base::`+`
[18:04:17.570]             `<<-` <- base::`<<-`
[18:04:17.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:17.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:17.570]                   3L)]
[18:04:17.570]             }
[18:04:17.570]             function(cond) {
[18:04:17.570]                 is_error <- inherits(cond, "error")
[18:04:17.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:17.570]                   NULL)
[18:04:17.570]                 if (is_error) {
[18:04:17.570]                   sessionInformation <- function() {
[18:04:17.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:17.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:17.570]                       search = base::search(), system = base::Sys.info())
[18:04:17.570]                   }
[18:04:17.570]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:17.570]                     cond$call), session = sessionInformation(), 
[18:04:17.570]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:17.570]                   signalCondition(cond)
[18:04:17.570]                 }
[18:04:17.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:17.570]                 "immediateCondition"))) {
[18:04:17.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:17.570]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:17.570]                   if (TRUE && !signal) {
[18:04:17.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.570]                     {
[18:04:17.570]                       inherits <- base::inherits
[18:04:17.570]                       invokeRestart <- base::invokeRestart
[18:04:17.570]                       is.null <- base::is.null
[18:04:17.570]                       muffled <- FALSE
[18:04:17.570]                       if (inherits(cond, "message")) {
[18:04:17.570]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.570]                         if (muffled) 
[18:04:17.570]                           invokeRestart("muffleMessage")
[18:04:17.570]                       }
[18:04:17.570]                       else if (inherits(cond, "warning")) {
[18:04:17.570]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.570]                         if (muffled) 
[18:04:17.570]                           invokeRestart("muffleWarning")
[18:04:17.570]                       }
[18:04:17.570]                       else if (inherits(cond, "condition")) {
[18:04:17.570]                         if (!is.null(pattern)) {
[18:04:17.570]                           computeRestarts <- base::computeRestarts
[18:04:17.570]                           grepl <- base::grepl
[18:04:17.570]                           restarts <- computeRestarts(cond)
[18:04:17.570]                           for (restart in restarts) {
[18:04:17.570]                             name <- restart$name
[18:04:17.570]                             if (is.null(name)) 
[18:04:17.570]                               next
[18:04:17.570]                             if (!grepl(pattern, name)) 
[18:04:17.570]                               next
[18:04:17.570]                             invokeRestart(restart)
[18:04:17.570]                             muffled <- TRUE
[18:04:17.570]                             break
[18:04:17.570]                           }
[18:04:17.570]                         }
[18:04:17.570]                       }
[18:04:17.570]                       invisible(muffled)
[18:04:17.570]                     }
[18:04:17.570]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.570]                   }
[18:04:17.570]                 }
[18:04:17.570]                 else {
[18:04:17.570]                   if (TRUE) {
[18:04:17.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.570]                     {
[18:04:17.570]                       inherits <- base::inherits
[18:04:17.570]                       invokeRestart <- base::invokeRestart
[18:04:17.570]                       is.null <- base::is.null
[18:04:17.570]                       muffled <- FALSE
[18:04:17.570]                       if (inherits(cond, "message")) {
[18:04:17.570]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.570]                         if (muffled) 
[18:04:17.570]                           invokeRestart("muffleMessage")
[18:04:17.570]                       }
[18:04:17.570]                       else if (inherits(cond, "warning")) {
[18:04:17.570]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.570]                         if (muffled) 
[18:04:17.570]                           invokeRestart("muffleWarning")
[18:04:17.570]                       }
[18:04:17.570]                       else if (inherits(cond, "condition")) {
[18:04:17.570]                         if (!is.null(pattern)) {
[18:04:17.570]                           computeRestarts <- base::computeRestarts
[18:04:17.570]                           grepl <- base::grepl
[18:04:17.570]                           restarts <- computeRestarts(cond)
[18:04:17.570]                           for (restart in restarts) {
[18:04:17.570]                             name <- restart$name
[18:04:17.570]                             if (is.null(name)) 
[18:04:17.570]                               next
[18:04:17.570]                             if (!grepl(pattern, name)) 
[18:04:17.570]                               next
[18:04:17.570]                             invokeRestart(restart)
[18:04:17.570]                             muffled <- TRUE
[18:04:17.570]                             break
[18:04:17.570]                           }
[18:04:17.570]                         }
[18:04:17.570]                       }
[18:04:17.570]                       invisible(muffled)
[18:04:17.570]                     }
[18:04:17.570]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.570]                   }
[18:04:17.570]                 }
[18:04:17.570]             }
[18:04:17.570]         }))
[18:04:17.570]     }, error = function(ex) {
[18:04:17.570]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:17.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.570]                 ...future.rng), started = ...future.startTime, 
[18:04:17.570]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:17.570]             version = "1.8"), class = "FutureResult")
[18:04:17.570]     }, finally = {
[18:04:17.570]         if (!identical(...future.workdir, getwd())) 
[18:04:17.570]             setwd(...future.workdir)
[18:04:17.570]         {
[18:04:17.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:17.570]                 ...future.oldOptions$nwarnings <- NULL
[18:04:17.570]             }
[18:04:17.570]             base::options(...future.oldOptions)
[18:04:17.570]             if (.Platform$OS.type == "windows") {
[18:04:17.570]                 old_names <- names(...future.oldEnvVars)
[18:04:17.570]                 envs <- base::Sys.getenv()
[18:04:17.570]                 names <- names(envs)
[18:04:17.570]                 common <- intersect(names, old_names)
[18:04:17.570]                 added <- setdiff(names, old_names)
[18:04:17.570]                 removed <- setdiff(old_names, names)
[18:04:17.570]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:17.570]                   envs[common]]
[18:04:17.570]                 NAMES <- toupper(changed)
[18:04:17.570]                 args <- list()
[18:04:17.570]                 for (kk in seq_along(NAMES)) {
[18:04:17.570]                   name <- changed[[kk]]
[18:04:17.570]                   NAME <- NAMES[[kk]]
[18:04:17.570]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.570]                     next
[18:04:17.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.570]                 }
[18:04:17.570]                 NAMES <- toupper(added)
[18:04:17.570]                 for (kk in seq_along(NAMES)) {
[18:04:17.570]                   name <- added[[kk]]
[18:04:17.570]                   NAME <- NAMES[[kk]]
[18:04:17.570]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.570]                     next
[18:04:17.570]                   args[[name]] <- ""
[18:04:17.570]                 }
[18:04:17.570]                 NAMES <- toupper(removed)
[18:04:17.570]                 for (kk in seq_along(NAMES)) {
[18:04:17.570]                   name <- removed[[kk]]
[18:04:17.570]                   NAME <- NAMES[[kk]]
[18:04:17.570]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.570]                     next
[18:04:17.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.570]                 }
[18:04:17.570]                 if (length(args) > 0) 
[18:04:17.570]                   base::do.call(base::Sys.setenv, args = args)
[18:04:17.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:17.570]             }
[18:04:17.570]             else {
[18:04:17.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:17.570]             }
[18:04:17.570]             {
[18:04:17.570]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:17.570]                   0L) {
[18:04:17.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:17.570]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:17.570]                   base::options(opts)
[18:04:17.570]                 }
[18:04:17.570]                 {
[18:04:17.570]                   {
[18:04:17.570]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:17.570]                     NULL
[18:04:17.570]                   }
[18:04:17.570]                   options(future.plan = NULL)
[18:04:17.570]                   if (is.na(NA_character_)) 
[18:04:17.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:17.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:17.570]                     .init = FALSE)
[18:04:17.570]                 }
[18:04:17.570]             }
[18:04:17.570]         }
[18:04:17.570]     })
[18:04:17.570]     if (TRUE) {
[18:04:17.570]         base::sink(type = "output", split = FALSE)
[18:04:17.570]         if (TRUE) {
[18:04:17.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:17.570]         }
[18:04:17.570]         else {
[18:04:17.570]             ...future.result["stdout"] <- base::list(NULL)
[18:04:17.570]         }
[18:04:17.570]         base::close(...future.stdout)
[18:04:17.570]         ...future.stdout <- NULL
[18:04:17.570]     }
[18:04:17.570]     ...future.result$conditions <- ...future.conditions
[18:04:17.570]     ...future.result$finished <- base::Sys.time()
[18:04:17.570]     ...future.result
[18:04:17.570] }
[18:04:17.669] MultisessionFuture started
[18:04:17.669] - Launch lazy future ... done
[18:04:17.670] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2c4032c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2c85e3c8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2c4032c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2c85e3c8> 
 $  : NULL
 $  : NULL
 $  : num 6
[18:04:17.680] receiveMessageFromWorker() for ClusterFuture ...
[18:04:17.681] - Validating connection of MultisessionFuture
[18:04:17.681] - received message: FutureResult
[18:04:17.682] - Received FutureResult
[18:04:17.682] - Erased future from FutureRegistry
[18:04:17.682] result() for ClusterFuture ...
[18:04:17.682] - result already collected: FutureResult
[18:04:17.682] result() for ClusterFuture ... done
[18:04:17.683] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:17.695] resolve() on list ...
[18:04:17.696]  recursive: 0
[18:04:17.696]  length: 6
[18:04:17.696]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:17.697] signalConditionsASAP(numeric, pos=1) ...
[18:04:17.697] - nx: 6
[18:04:17.697] - relay: TRUE
[18:04:17.697] - stdout: TRUE
[18:04:17.697] - signal: TRUE
[18:04:17.698] - resignal: FALSE
[18:04:17.698] - force: TRUE
[18:04:17.698] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.698] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.699]  - until=2
[18:04:17.699]  - relaying element #2
[18:04:17.699] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.699] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.699] signalConditionsASAP(NULL, pos=1) ... done
[18:04:17.700]  length: 5 (resolved future 1)
[18:04:17.700] Future #2
[18:04:17.700] result() for ClusterFuture ...
[18:04:17.701] - result already collected: FutureResult
[18:04:17.701] result() for ClusterFuture ... done
[18:04:17.701] result() for ClusterFuture ...
[18:04:17.701] - result already collected: FutureResult
[18:04:17.701] result() for ClusterFuture ... done
[18:04:17.702] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:17.702] - nx: 6
[18:04:17.702] - relay: TRUE
[18:04:17.702] - stdout: TRUE
[18:04:17.703] - signal: TRUE
[18:04:17.703] - resignal: FALSE
[18:04:17.703] - force: TRUE
[18:04:17.703] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.703] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.706]  - until=2
[18:04:17.706]  - relaying element #2
[18:04:17.707] result() for ClusterFuture ...
[18:04:17.707] - result already collected: FutureResult
[18:04:17.707] result() for ClusterFuture ... done
[18:04:17.707] result() for ClusterFuture ...
[18:04:17.708] - result already collected: FutureResult
[18:04:17.708] result() for ClusterFuture ... done
[18:04:17.708] result() for ClusterFuture ...
[18:04:17.708] - result already collected: FutureResult
[18:04:17.709] result() for ClusterFuture ... done
[18:04:17.709] result() for ClusterFuture ...
[18:04:17.709] - result already collected: FutureResult
[18:04:17.709] result() for ClusterFuture ... done
[18:04:17.710] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.712] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.712] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:17.712]  length: 4 (resolved future 2)
[18:04:17.726] signalConditionsASAP(NULL, pos=4) ...
[18:04:17.726] - nx: 6
[18:04:17.726] - relay: TRUE
[18:04:17.727] - stdout: TRUE
[18:04:17.727] - signal: TRUE
[18:04:17.727] - resignal: FALSE
[18:04:17.727] - force: TRUE
[18:04:17.728] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.730] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.730]  - until=5
[18:04:17.730]  - relaying element #3
[18:04:17.731]  - relaying element #5
[18:04:17.731] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[18:04:17.731] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.731] signalConditionsASAP(NULL, pos=4) ... done
[18:04:17.732]  length: 3 (resolved future 4)
[18:04:17.734] signalConditionsASAP(NULL, pos=5) ...
[18:04:17.734] - nx: 6
[18:04:17.734] - relay: TRUE
[18:04:17.735] - stdout: TRUE
[18:04:17.735] - signal: TRUE
[18:04:17.735] - resignal: FALSE
[18:04:17.735] - force: TRUE
[18:04:17.736] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[18:04:17.736] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.736]  - until=6
[18:04:17.736]  - relaying element #3
[18:04:17.737]  - relaying element #6
[18:04:17.737] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[18:04:17.737] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.737] signalConditionsASAP(NULL, pos=5) ... done
[18:04:17.738]  length: 2 (resolved future 5)
[18:04:17.738] signalConditionsASAP(numeric, pos=6) ...
[18:04:17.738] - nx: 6
[18:04:17.738] - relay: TRUE
[18:04:17.738] - stdout: TRUE
[18:04:17.739] - signal: TRUE
[18:04:17.739] - resignal: FALSE
[18:04:17.739] - force: TRUE
[18:04:17.739] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[18:04:17.739] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.740]  - until=6
[18:04:17.740]  - relaying element #3
[18:04:17.740] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[18:04:17.740] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.741] signalConditionsASAP(NULL, pos=6) ... done
[18:04:17.741]  length: 1 (resolved future 6)
[18:04:17.752] receiveMessageFromWorker() for ClusterFuture ...
[18:04:17.753] - Validating connection of MultisessionFuture
[18:04:17.753] - received message: FutureResult
[18:04:17.754] - Received FutureResult
[18:04:17.754] - Erased future from FutureRegistry
[18:04:17.754] result() for ClusterFuture ...
[18:04:17.754] - result already collected: FutureResult
[18:04:17.755] result() for ClusterFuture ... done
[18:04:17.755] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:17.755] Future #3
[18:04:17.756] result() for ClusterFuture ...
[18:04:17.756] - result already collected: FutureResult
[18:04:17.756] result() for ClusterFuture ... done
[18:04:17.756] result() for ClusterFuture ...
[18:04:17.757] - result already collected: FutureResult
[18:04:17.757] result() for ClusterFuture ... done
[18:04:17.757] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:17.757] - nx: 6
[18:04:17.758] - relay: TRUE
[18:04:17.758] - stdout: TRUE
[18:04:17.758] - signal: TRUE
[18:04:17.758] - resignal: FALSE
[18:04:17.758] - force: TRUE
[18:04:17.759] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[18:04:17.759] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.759]  - until=6
[18:04:17.759]  - relaying element #3
[18:04:17.760] result() for ClusterFuture ...
[18:04:17.760] - result already collected: FutureResult
[18:04:17.760] result() for ClusterFuture ... done
[18:04:17.760] result() for ClusterFuture ...
[18:04:17.761] - result already collected: FutureResult
[18:04:17.761] result() for ClusterFuture ... done
[18:04:17.761] result() for ClusterFuture ...
[18:04:17.761] - result already collected: FutureResult
[18:04:17.762] result() for ClusterFuture ... done
[18:04:17.762] result() for ClusterFuture ...
[18:04:17.762] - result already collected: FutureResult
[18:04:17.762] result() for ClusterFuture ... done
[18:04:17.762] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:17.763] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.763] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:17.763]  length: 0 (resolved future 3)
[18:04:17.763] Relaying remaining futures
[18:04:17.764] signalConditionsASAP(NULL, pos=0) ...
[18:04:17.764] - nx: 6
[18:04:17.764] - relay: TRUE
[18:04:17.764] - stdout: TRUE
[18:04:17.764] - signal: TRUE
[18:04:17.765] - resignal: FALSE
[18:04:17.765] - force: TRUE
[18:04:17.765] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:17.765] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:17.769] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:17.769] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.770] signalConditionsASAP(NULL, pos=0) ... done
[18:04:17.770] resolve() on list ... DONE
[18:04:17.770] result() for ClusterFuture ...
[18:04:17.770] - result already collected: FutureResult
[18:04:17.770] result() for ClusterFuture ... done
[18:04:17.771] result() for ClusterFuture ...
[18:04:17.771] - result already collected: FutureResult
[18:04:17.771] result() for ClusterFuture ... done
[18:04:17.771] result() for ClusterFuture ...
[18:04:17.771] - result already collected: FutureResult
[18:04:17.772] result() for ClusterFuture ... done
[18:04:17.772] result() for ClusterFuture ...
[18:04:17.772] - result already collected: FutureResult
[18:04:17.772] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[18:04:17.777] getGlobalsAndPackages() ...
[18:04:17.777] Searching for globals...
[18:04:17.778] 
[18:04:17.778] Searching for globals ... DONE
[18:04:17.779] - globals: [0] <none>
[18:04:17.779] getGlobalsAndPackages() ... DONE
[18:04:17.779] run() for ‘Future’ ...
[18:04:17.779] - state: ‘created’
[18:04:17.780] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:17.802] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:17.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:17.803]   - Field: ‘node’
[18:04:17.803]   - Field: ‘label’
[18:04:17.803]   - Field: ‘local’
[18:04:17.804]   - Field: ‘owner’
[18:04:17.804]   - Field: ‘envir’
[18:04:17.804]   - Field: ‘workers’
[18:04:17.804]   - Field: ‘packages’
[18:04:17.804]   - Field: ‘gc’
[18:04:17.805]   - Field: ‘conditions’
[18:04:17.805]   - Field: ‘persistent’
[18:04:17.805]   - Field: ‘expr’
[18:04:17.805]   - Field: ‘uuid’
[18:04:17.805]   - Field: ‘seed’
[18:04:17.806]   - Field: ‘version’
[18:04:17.806]   - Field: ‘result’
[18:04:17.806]   - Field: ‘asynchronous’
[18:04:17.806]   - Field: ‘calls’
[18:04:17.806]   - Field: ‘globals’
[18:04:17.807]   - Field: ‘stdout’
[18:04:17.807]   - Field: ‘earlySignal’
[18:04:17.807]   - Field: ‘lazy’
[18:04:17.807]   - Field: ‘state’
[18:04:17.807] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:17.808] - Launch lazy future ...
[18:04:17.808] Packages needed by the future expression (n = 0): <none>
[18:04:17.808] Packages needed by future strategies (n = 0): <none>
[18:04:17.809] {
[18:04:17.809]     {
[18:04:17.809]         {
[18:04:17.809]             ...future.startTime <- base::Sys.time()
[18:04:17.809]             {
[18:04:17.809]                 {
[18:04:17.809]                   {
[18:04:17.809]                     {
[18:04:17.809]                       base::local({
[18:04:17.809]                         has_future <- base::requireNamespace("future", 
[18:04:17.809]                           quietly = TRUE)
[18:04:17.809]                         if (has_future) {
[18:04:17.809]                           ns <- base::getNamespace("future")
[18:04:17.809]                           version <- ns[[".package"]][["version"]]
[18:04:17.809]                           if (is.null(version)) 
[18:04:17.809]                             version <- utils::packageVersion("future")
[18:04:17.809]                         }
[18:04:17.809]                         else {
[18:04:17.809]                           version <- NULL
[18:04:17.809]                         }
[18:04:17.809]                         if (!has_future || version < "1.8.0") {
[18:04:17.809]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:17.809]                             "", base::R.version$version.string), 
[18:04:17.809]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:17.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:17.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:17.809]                               "release", "version")], collapse = " "), 
[18:04:17.809]                             hostname = base::Sys.info()[["nodename"]])
[18:04:17.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:17.809]                             info)
[18:04:17.809]                           info <- base::paste(info, collapse = "; ")
[18:04:17.809]                           if (!has_future) {
[18:04:17.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:17.809]                               info)
[18:04:17.809]                           }
[18:04:17.809]                           else {
[18:04:17.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:17.809]                               info, version)
[18:04:17.809]                           }
[18:04:17.809]                           base::stop(msg)
[18:04:17.809]                         }
[18:04:17.809]                       })
[18:04:17.809]                     }
[18:04:17.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:17.809]                     base::options(mc.cores = 1L)
[18:04:17.809]                   }
[18:04:17.809]                   ...future.strategy.old <- future::plan("list")
[18:04:17.809]                   options(future.plan = NULL)
[18:04:17.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:17.809]                 }
[18:04:17.809]                 ...future.workdir <- getwd()
[18:04:17.809]             }
[18:04:17.809]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:17.809]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:17.809]         }
[18:04:17.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:17.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:17.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:17.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:17.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:17.809]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:17.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:17.809]             base::names(...future.oldOptions))
[18:04:17.809]     }
[18:04:17.809]     if (FALSE) {
[18:04:17.809]     }
[18:04:17.809]     else {
[18:04:17.809]         if (TRUE) {
[18:04:17.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:17.809]                 open = "w")
[18:04:17.809]         }
[18:04:17.809]         else {
[18:04:17.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:17.809]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:17.809]         }
[18:04:17.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:17.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:17.809]             base::sink(type = "output", split = FALSE)
[18:04:17.809]             base::close(...future.stdout)
[18:04:17.809]         }, add = TRUE)
[18:04:17.809]     }
[18:04:17.809]     ...future.frame <- base::sys.nframe()
[18:04:17.809]     ...future.conditions <- base::list()
[18:04:17.809]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:17.809]     if (FALSE) {
[18:04:17.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:17.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:17.809]     }
[18:04:17.809]     ...future.result <- base::tryCatch({
[18:04:17.809]         base::withCallingHandlers({
[18:04:17.809]             ...future.value <- base::withVisible(base::local({
[18:04:17.809]                 ...future.makeSendCondition <- base::local({
[18:04:17.809]                   sendCondition <- NULL
[18:04:17.809]                   function(frame = 1L) {
[18:04:17.809]                     if (is.function(sendCondition)) 
[18:04:17.809]                       return(sendCondition)
[18:04:17.809]                     ns <- getNamespace("parallel")
[18:04:17.809]                     if (exists("sendData", mode = "function", 
[18:04:17.809]                       envir = ns)) {
[18:04:17.809]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:17.809]                         envir = ns)
[18:04:17.809]                       envir <- sys.frame(frame)
[18:04:17.809]                       master <- NULL
[18:04:17.809]                       while (!identical(envir, .GlobalEnv) && 
[18:04:17.809]                         !identical(envir, emptyenv())) {
[18:04:17.809]                         if (exists("master", mode = "list", envir = envir, 
[18:04:17.809]                           inherits = FALSE)) {
[18:04:17.809]                           master <- get("master", mode = "list", 
[18:04:17.809]                             envir = envir, inherits = FALSE)
[18:04:17.809]                           if (inherits(master, c("SOCKnode", 
[18:04:17.809]                             "SOCK0node"))) {
[18:04:17.809]                             sendCondition <<- function(cond) {
[18:04:17.809]                               data <- list(type = "VALUE", value = cond, 
[18:04:17.809]                                 success = TRUE)
[18:04:17.809]                               parallel_sendData(master, data)
[18:04:17.809]                             }
[18:04:17.809]                             return(sendCondition)
[18:04:17.809]                           }
[18:04:17.809]                         }
[18:04:17.809]                         frame <- frame + 1L
[18:04:17.809]                         envir <- sys.frame(frame)
[18:04:17.809]                       }
[18:04:17.809]                     }
[18:04:17.809]                     sendCondition <<- function(cond) NULL
[18:04:17.809]                   }
[18:04:17.809]                 })
[18:04:17.809]                 withCallingHandlers({
[18:04:17.809]                   2
[18:04:17.809]                 }, immediateCondition = function(cond) {
[18:04:17.809]                   sendCondition <- ...future.makeSendCondition()
[18:04:17.809]                   sendCondition(cond)
[18:04:17.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.809]                   {
[18:04:17.809]                     inherits <- base::inherits
[18:04:17.809]                     invokeRestart <- base::invokeRestart
[18:04:17.809]                     is.null <- base::is.null
[18:04:17.809]                     muffled <- FALSE
[18:04:17.809]                     if (inherits(cond, "message")) {
[18:04:17.809]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:17.809]                       if (muffled) 
[18:04:17.809]                         invokeRestart("muffleMessage")
[18:04:17.809]                     }
[18:04:17.809]                     else if (inherits(cond, "warning")) {
[18:04:17.809]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:17.809]                       if (muffled) 
[18:04:17.809]                         invokeRestart("muffleWarning")
[18:04:17.809]                     }
[18:04:17.809]                     else if (inherits(cond, "condition")) {
[18:04:17.809]                       if (!is.null(pattern)) {
[18:04:17.809]                         computeRestarts <- base::computeRestarts
[18:04:17.809]                         grepl <- base::grepl
[18:04:17.809]                         restarts <- computeRestarts(cond)
[18:04:17.809]                         for (restart in restarts) {
[18:04:17.809]                           name <- restart$name
[18:04:17.809]                           if (is.null(name)) 
[18:04:17.809]                             next
[18:04:17.809]                           if (!grepl(pattern, name)) 
[18:04:17.809]                             next
[18:04:17.809]                           invokeRestart(restart)
[18:04:17.809]                           muffled <- TRUE
[18:04:17.809]                           break
[18:04:17.809]                         }
[18:04:17.809]                       }
[18:04:17.809]                     }
[18:04:17.809]                     invisible(muffled)
[18:04:17.809]                   }
[18:04:17.809]                   muffleCondition(cond)
[18:04:17.809]                 })
[18:04:17.809]             }))
[18:04:17.809]             future::FutureResult(value = ...future.value$value, 
[18:04:17.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.809]                   ...future.rng), globalenv = if (FALSE) 
[18:04:17.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:17.809]                     ...future.globalenv.names))
[18:04:17.809]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:17.809]         }, condition = base::local({
[18:04:17.809]             c <- base::c
[18:04:17.809]             inherits <- base::inherits
[18:04:17.809]             invokeRestart <- base::invokeRestart
[18:04:17.809]             length <- base::length
[18:04:17.809]             list <- base::list
[18:04:17.809]             seq.int <- base::seq.int
[18:04:17.809]             signalCondition <- base::signalCondition
[18:04:17.809]             sys.calls <- base::sys.calls
[18:04:17.809]             `[[` <- base::`[[`
[18:04:17.809]             `+` <- base::`+`
[18:04:17.809]             `<<-` <- base::`<<-`
[18:04:17.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:17.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:17.809]                   3L)]
[18:04:17.809]             }
[18:04:17.809]             function(cond) {
[18:04:17.809]                 is_error <- inherits(cond, "error")
[18:04:17.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:17.809]                   NULL)
[18:04:17.809]                 if (is_error) {
[18:04:17.809]                   sessionInformation <- function() {
[18:04:17.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:17.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:17.809]                       search = base::search(), system = base::Sys.info())
[18:04:17.809]                   }
[18:04:17.809]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:17.809]                     cond$call), session = sessionInformation(), 
[18:04:17.809]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:17.809]                   signalCondition(cond)
[18:04:17.809]                 }
[18:04:17.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:17.809]                 "immediateCondition"))) {
[18:04:17.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:17.809]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:17.809]                   if (TRUE && !signal) {
[18:04:17.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.809]                     {
[18:04:17.809]                       inherits <- base::inherits
[18:04:17.809]                       invokeRestart <- base::invokeRestart
[18:04:17.809]                       is.null <- base::is.null
[18:04:17.809]                       muffled <- FALSE
[18:04:17.809]                       if (inherits(cond, "message")) {
[18:04:17.809]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.809]                         if (muffled) 
[18:04:17.809]                           invokeRestart("muffleMessage")
[18:04:17.809]                       }
[18:04:17.809]                       else if (inherits(cond, "warning")) {
[18:04:17.809]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.809]                         if (muffled) 
[18:04:17.809]                           invokeRestart("muffleWarning")
[18:04:17.809]                       }
[18:04:17.809]                       else if (inherits(cond, "condition")) {
[18:04:17.809]                         if (!is.null(pattern)) {
[18:04:17.809]                           computeRestarts <- base::computeRestarts
[18:04:17.809]                           grepl <- base::grepl
[18:04:17.809]                           restarts <- computeRestarts(cond)
[18:04:17.809]                           for (restart in restarts) {
[18:04:17.809]                             name <- restart$name
[18:04:17.809]                             if (is.null(name)) 
[18:04:17.809]                               next
[18:04:17.809]                             if (!grepl(pattern, name)) 
[18:04:17.809]                               next
[18:04:17.809]                             invokeRestart(restart)
[18:04:17.809]                             muffled <- TRUE
[18:04:17.809]                             break
[18:04:17.809]                           }
[18:04:17.809]                         }
[18:04:17.809]                       }
[18:04:17.809]                       invisible(muffled)
[18:04:17.809]                     }
[18:04:17.809]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.809]                   }
[18:04:17.809]                 }
[18:04:17.809]                 else {
[18:04:17.809]                   if (TRUE) {
[18:04:17.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.809]                     {
[18:04:17.809]                       inherits <- base::inherits
[18:04:17.809]                       invokeRestart <- base::invokeRestart
[18:04:17.809]                       is.null <- base::is.null
[18:04:17.809]                       muffled <- FALSE
[18:04:17.809]                       if (inherits(cond, "message")) {
[18:04:17.809]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.809]                         if (muffled) 
[18:04:17.809]                           invokeRestart("muffleMessage")
[18:04:17.809]                       }
[18:04:17.809]                       else if (inherits(cond, "warning")) {
[18:04:17.809]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.809]                         if (muffled) 
[18:04:17.809]                           invokeRestart("muffleWarning")
[18:04:17.809]                       }
[18:04:17.809]                       else if (inherits(cond, "condition")) {
[18:04:17.809]                         if (!is.null(pattern)) {
[18:04:17.809]                           computeRestarts <- base::computeRestarts
[18:04:17.809]                           grepl <- base::grepl
[18:04:17.809]                           restarts <- computeRestarts(cond)
[18:04:17.809]                           for (restart in restarts) {
[18:04:17.809]                             name <- restart$name
[18:04:17.809]                             if (is.null(name)) 
[18:04:17.809]                               next
[18:04:17.809]                             if (!grepl(pattern, name)) 
[18:04:17.809]                               next
[18:04:17.809]                             invokeRestart(restart)
[18:04:17.809]                             muffled <- TRUE
[18:04:17.809]                             break
[18:04:17.809]                           }
[18:04:17.809]                         }
[18:04:17.809]                       }
[18:04:17.809]                       invisible(muffled)
[18:04:17.809]                     }
[18:04:17.809]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.809]                   }
[18:04:17.809]                 }
[18:04:17.809]             }
[18:04:17.809]         }))
[18:04:17.809]     }, error = function(ex) {
[18:04:17.809]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:17.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.809]                 ...future.rng), started = ...future.startTime, 
[18:04:17.809]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:17.809]             version = "1.8"), class = "FutureResult")
[18:04:17.809]     }, finally = {
[18:04:17.809]         if (!identical(...future.workdir, getwd())) 
[18:04:17.809]             setwd(...future.workdir)
[18:04:17.809]         {
[18:04:17.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:17.809]                 ...future.oldOptions$nwarnings <- NULL
[18:04:17.809]             }
[18:04:17.809]             base::options(...future.oldOptions)
[18:04:17.809]             if (.Platform$OS.type == "windows") {
[18:04:17.809]                 old_names <- names(...future.oldEnvVars)
[18:04:17.809]                 envs <- base::Sys.getenv()
[18:04:17.809]                 names <- names(envs)
[18:04:17.809]                 common <- intersect(names, old_names)
[18:04:17.809]                 added <- setdiff(names, old_names)
[18:04:17.809]                 removed <- setdiff(old_names, names)
[18:04:17.809]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:17.809]                   envs[common]]
[18:04:17.809]                 NAMES <- toupper(changed)
[18:04:17.809]                 args <- list()
[18:04:17.809]                 for (kk in seq_along(NAMES)) {
[18:04:17.809]                   name <- changed[[kk]]
[18:04:17.809]                   NAME <- NAMES[[kk]]
[18:04:17.809]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.809]                     next
[18:04:17.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.809]                 }
[18:04:17.809]                 NAMES <- toupper(added)
[18:04:17.809]                 for (kk in seq_along(NAMES)) {
[18:04:17.809]                   name <- added[[kk]]
[18:04:17.809]                   NAME <- NAMES[[kk]]
[18:04:17.809]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.809]                     next
[18:04:17.809]                   args[[name]] <- ""
[18:04:17.809]                 }
[18:04:17.809]                 NAMES <- toupper(removed)
[18:04:17.809]                 for (kk in seq_along(NAMES)) {
[18:04:17.809]                   name <- removed[[kk]]
[18:04:17.809]                   NAME <- NAMES[[kk]]
[18:04:17.809]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.809]                     next
[18:04:17.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.809]                 }
[18:04:17.809]                 if (length(args) > 0) 
[18:04:17.809]                   base::do.call(base::Sys.setenv, args = args)
[18:04:17.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:17.809]             }
[18:04:17.809]             else {
[18:04:17.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:17.809]             }
[18:04:17.809]             {
[18:04:17.809]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:17.809]                   0L) {
[18:04:17.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:17.809]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:17.809]                   base::options(opts)
[18:04:17.809]                 }
[18:04:17.809]                 {
[18:04:17.809]                   {
[18:04:17.809]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:17.809]                     NULL
[18:04:17.809]                   }
[18:04:17.809]                   options(future.plan = NULL)
[18:04:17.809]                   if (is.na(NA_character_)) 
[18:04:17.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:17.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:17.809]                     .init = FALSE)
[18:04:17.809]                 }
[18:04:17.809]             }
[18:04:17.809]         }
[18:04:17.809]     })
[18:04:17.809]     if (TRUE) {
[18:04:17.809]         base::sink(type = "output", split = FALSE)
[18:04:17.809]         if (TRUE) {
[18:04:17.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:17.809]         }
[18:04:17.809]         else {
[18:04:17.809]             ...future.result["stdout"] <- base::list(NULL)
[18:04:17.809]         }
[18:04:17.809]         base::close(...future.stdout)
[18:04:17.809]         ...future.stdout <- NULL
[18:04:17.809]     }
[18:04:17.809]     ...future.result$conditions <- ...future.conditions
[18:04:17.809]     ...future.result$finished <- base::Sys.time()
[18:04:17.809]     ...future.result
[18:04:17.809] }
[18:04:17.815] MultisessionFuture started
[18:04:17.815] - Launch lazy future ... done
[18:04:17.815] run() for ‘MultisessionFuture’ ... done
[18:04:17.815] getGlobalsAndPackages() ...
[18:04:17.816] Searching for globals...
[18:04:17.816] 
[18:04:17.816] Searching for globals ... DONE
[18:04:17.817] - globals: [0] <none>
[18:04:17.817] getGlobalsAndPackages() ... DONE
[18:04:17.817] run() for ‘Future’ ...
[18:04:17.817] - state: ‘created’
[18:04:17.818] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:17.841] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:17.841] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:17.842]   - Field: ‘node’
[18:04:17.842]   - Field: ‘label’
[18:04:17.842]   - Field: ‘local’
[18:04:17.842]   - Field: ‘owner’
[18:04:17.843]   - Field: ‘envir’
[18:04:17.843]   - Field: ‘workers’
[18:04:17.843]   - Field: ‘packages’
[18:04:17.843]   - Field: ‘gc’
[18:04:17.843]   - Field: ‘conditions’
[18:04:17.844]   - Field: ‘persistent’
[18:04:17.844]   - Field: ‘expr’
[18:04:17.844]   - Field: ‘uuid’
[18:04:17.844]   - Field: ‘seed’
[18:04:17.844]   - Field: ‘version’
[18:04:17.845]   - Field: ‘result’
[18:04:17.845]   - Field: ‘asynchronous’
[18:04:17.845]   - Field: ‘calls’
[18:04:17.845]   - Field: ‘globals’
[18:04:17.845]   - Field: ‘stdout’
[18:04:17.846]   - Field: ‘earlySignal’
[18:04:17.846]   - Field: ‘lazy’
[18:04:17.846]   - Field: ‘state’
[18:04:17.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:17.846] - Launch lazy future ...
[18:04:17.847] Packages needed by the future expression (n = 0): <none>
[18:04:17.847] Packages needed by future strategies (n = 0): <none>
[18:04:17.849] {
[18:04:17.849]     {
[18:04:17.849]         {
[18:04:17.849]             ...future.startTime <- base::Sys.time()
[18:04:17.849]             {
[18:04:17.849]                 {
[18:04:17.849]                   {
[18:04:17.849]                     {
[18:04:17.849]                       base::local({
[18:04:17.849]                         has_future <- base::requireNamespace("future", 
[18:04:17.849]                           quietly = TRUE)
[18:04:17.849]                         if (has_future) {
[18:04:17.849]                           ns <- base::getNamespace("future")
[18:04:17.849]                           version <- ns[[".package"]][["version"]]
[18:04:17.849]                           if (is.null(version)) 
[18:04:17.849]                             version <- utils::packageVersion("future")
[18:04:17.849]                         }
[18:04:17.849]                         else {
[18:04:17.849]                           version <- NULL
[18:04:17.849]                         }
[18:04:17.849]                         if (!has_future || version < "1.8.0") {
[18:04:17.849]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:17.849]                             "", base::R.version$version.string), 
[18:04:17.849]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:17.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:17.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:17.849]                               "release", "version")], collapse = " "), 
[18:04:17.849]                             hostname = base::Sys.info()[["nodename"]])
[18:04:17.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:17.849]                             info)
[18:04:17.849]                           info <- base::paste(info, collapse = "; ")
[18:04:17.849]                           if (!has_future) {
[18:04:17.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:17.849]                               info)
[18:04:17.849]                           }
[18:04:17.849]                           else {
[18:04:17.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:17.849]                               info, version)
[18:04:17.849]                           }
[18:04:17.849]                           base::stop(msg)
[18:04:17.849]                         }
[18:04:17.849]                       })
[18:04:17.849]                     }
[18:04:17.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:17.849]                     base::options(mc.cores = 1L)
[18:04:17.849]                   }
[18:04:17.849]                   ...future.strategy.old <- future::plan("list")
[18:04:17.849]                   options(future.plan = NULL)
[18:04:17.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:17.849]                 }
[18:04:17.849]                 ...future.workdir <- getwd()
[18:04:17.849]             }
[18:04:17.849]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:17.849]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:17.849]         }
[18:04:17.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:17.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:17.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:17.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:17.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:17.849]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:17.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:17.849]             base::names(...future.oldOptions))
[18:04:17.849]     }
[18:04:17.849]     if (FALSE) {
[18:04:17.849]     }
[18:04:17.849]     else {
[18:04:17.849]         if (TRUE) {
[18:04:17.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:17.849]                 open = "w")
[18:04:17.849]         }
[18:04:17.849]         else {
[18:04:17.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:17.849]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:17.849]         }
[18:04:17.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:17.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:17.849]             base::sink(type = "output", split = FALSE)
[18:04:17.849]             base::close(...future.stdout)
[18:04:17.849]         }, add = TRUE)
[18:04:17.849]     }
[18:04:17.849]     ...future.frame <- base::sys.nframe()
[18:04:17.849]     ...future.conditions <- base::list()
[18:04:17.849]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:17.849]     if (FALSE) {
[18:04:17.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:17.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:17.849]     }
[18:04:17.849]     ...future.result <- base::tryCatch({
[18:04:17.849]         base::withCallingHandlers({
[18:04:17.849]             ...future.value <- base::withVisible(base::local({
[18:04:17.849]                 ...future.makeSendCondition <- base::local({
[18:04:17.849]                   sendCondition <- NULL
[18:04:17.849]                   function(frame = 1L) {
[18:04:17.849]                     if (is.function(sendCondition)) 
[18:04:17.849]                       return(sendCondition)
[18:04:17.849]                     ns <- getNamespace("parallel")
[18:04:17.849]                     if (exists("sendData", mode = "function", 
[18:04:17.849]                       envir = ns)) {
[18:04:17.849]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:17.849]                         envir = ns)
[18:04:17.849]                       envir <- sys.frame(frame)
[18:04:17.849]                       master <- NULL
[18:04:17.849]                       while (!identical(envir, .GlobalEnv) && 
[18:04:17.849]                         !identical(envir, emptyenv())) {
[18:04:17.849]                         if (exists("master", mode = "list", envir = envir, 
[18:04:17.849]                           inherits = FALSE)) {
[18:04:17.849]                           master <- get("master", mode = "list", 
[18:04:17.849]                             envir = envir, inherits = FALSE)
[18:04:17.849]                           if (inherits(master, c("SOCKnode", 
[18:04:17.849]                             "SOCK0node"))) {
[18:04:17.849]                             sendCondition <<- function(cond) {
[18:04:17.849]                               data <- list(type = "VALUE", value = cond, 
[18:04:17.849]                                 success = TRUE)
[18:04:17.849]                               parallel_sendData(master, data)
[18:04:17.849]                             }
[18:04:17.849]                             return(sendCondition)
[18:04:17.849]                           }
[18:04:17.849]                         }
[18:04:17.849]                         frame <- frame + 1L
[18:04:17.849]                         envir <- sys.frame(frame)
[18:04:17.849]                       }
[18:04:17.849]                     }
[18:04:17.849]                     sendCondition <<- function(cond) NULL
[18:04:17.849]                   }
[18:04:17.849]                 })
[18:04:17.849]                 withCallingHandlers({
[18:04:17.849]                   NULL
[18:04:17.849]                 }, immediateCondition = function(cond) {
[18:04:17.849]                   sendCondition <- ...future.makeSendCondition()
[18:04:17.849]                   sendCondition(cond)
[18:04:17.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.849]                   {
[18:04:17.849]                     inherits <- base::inherits
[18:04:17.849]                     invokeRestart <- base::invokeRestart
[18:04:17.849]                     is.null <- base::is.null
[18:04:17.849]                     muffled <- FALSE
[18:04:17.849]                     if (inherits(cond, "message")) {
[18:04:17.849]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:17.849]                       if (muffled) 
[18:04:17.849]                         invokeRestart("muffleMessage")
[18:04:17.849]                     }
[18:04:17.849]                     else if (inherits(cond, "warning")) {
[18:04:17.849]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:17.849]                       if (muffled) 
[18:04:17.849]                         invokeRestart("muffleWarning")
[18:04:17.849]                     }
[18:04:17.849]                     else if (inherits(cond, "condition")) {
[18:04:17.849]                       if (!is.null(pattern)) {
[18:04:17.849]                         computeRestarts <- base::computeRestarts
[18:04:17.849]                         grepl <- base::grepl
[18:04:17.849]                         restarts <- computeRestarts(cond)
[18:04:17.849]                         for (restart in restarts) {
[18:04:17.849]                           name <- restart$name
[18:04:17.849]                           if (is.null(name)) 
[18:04:17.849]                             next
[18:04:17.849]                           if (!grepl(pattern, name)) 
[18:04:17.849]                             next
[18:04:17.849]                           invokeRestart(restart)
[18:04:17.849]                           muffled <- TRUE
[18:04:17.849]                           break
[18:04:17.849]                         }
[18:04:17.849]                       }
[18:04:17.849]                     }
[18:04:17.849]                     invisible(muffled)
[18:04:17.849]                   }
[18:04:17.849]                   muffleCondition(cond)
[18:04:17.849]                 })
[18:04:17.849]             }))
[18:04:17.849]             future::FutureResult(value = ...future.value$value, 
[18:04:17.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.849]                   ...future.rng), globalenv = if (FALSE) 
[18:04:17.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:17.849]                     ...future.globalenv.names))
[18:04:17.849]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:17.849]         }, condition = base::local({
[18:04:17.849]             c <- base::c
[18:04:17.849]             inherits <- base::inherits
[18:04:17.849]             invokeRestart <- base::invokeRestart
[18:04:17.849]             length <- base::length
[18:04:17.849]             list <- base::list
[18:04:17.849]             seq.int <- base::seq.int
[18:04:17.849]             signalCondition <- base::signalCondition
[18:04:17.849]             sys.calls <- base::sys.calls
[18:04:17.849]             `[[` <- base::`[[`
[18:04:17.849]             `+` <- base::`+`
[18:04:17.849]             `<<-` <- base::`<<-`
[18:04:17.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:17.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:17.849]                   3L)]
[18:04:17.849]             }
[18:04:17.849]             function(cond) {
[18:04:17.849]                 is_error <- inherits(cond, "error")
[18:04:17.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:17.849]                   NULL)
[18:04:17.849]                 if (is_error) {
[18:04:17.849]                   sessionInformation <- function() {
[18:04:17.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:17.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:17.849]                       search = base::search(), system = base::Sys.info())
[18:04:17.849]                   }
[18:04:17.849]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:17.849]                     cond$call), session = sessionInformation(), 
[18:04:17.849]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:17.849]                   signalCondition(cond)
[18:04:17.849]                 }
[18:04:17.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:17.849]                 "immediateCondition"))) {
[18:04:17.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:17.849]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:17.849]                   if (TRUE && !signal) {
[18:04:17.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.849]                     {
[18:04:17.849]                       inherits <- base::inherits
[18:04:17.849]                       invokeRestart <- base::invokeRestart
[18:04:17.849]                       is.null <- base::is.null
[18:04:17.849]                       muffled <- FALSE
[18:04:17.849]                       if (inherits(cond, "message")) {
[18:04:17.849]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.849]                         if (muffled) 
[18:04:17.849]                           invokeRestart("muffleMessage")
[18:04:17.849]                       }
[18:04:17.849]                       else if (inherits(cond, "warning")) {
[18:04:17.849]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.849]                         if (muffled) 
[18:04:17.849]                           invokeRestart("muffleWarning")
[18:04:17.849]                       }
[18:04:17.849]                       else if (inherits(cond, "condition")) {
[18:04:17.849]                         if (!is.null(pattern)) {
[18:04:17.849]                           computeRestarts <- base::computeRestarts
[18:04:17.849]                           grepl <- base::grepl
[18:04:17.849]                           restarts <- computeRestarts(cond)
[18:04:17.849]                           for (restart in restarts) {
[18:04:17.849]                             name <- restart$name
[18:04:17.849]                             if (is.null(name)) 
[18:04:17.849]                               next
[18:04:17.849]                             if (!grepl(pattern, name)) 
[18:04:17.849]                               next
[18:04:17.849]                             invokeRestart(restart)
[18:04:17.849]                             muffled <- TRUE
[18:04:17.849]                             break
[18:04:17.849]                           }
[18:04:17.849]                         }
[18:04:17.849]                       }
[18:04:17.849]                       invisible(muffled)
[18:04:17.849]                     }
[18:04:17.849]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.849]                   }
[18:04:17.849]                 }
[18:04:17.849]                 else {
[18:04:17.849]                   if (TRUE) {
[18:04:17.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.849]                     {
[18:04:17.849]                       inherits <- base::inherits
[18:04:17.849]                       invokeRestart <- base::invokeRestart
[18:04:17.849]                       is.null <- base::is.null
[18:04:17.849]                       muffled <- FALSE
[18:04:17.849]                       if (inherits(cond, "message")) {
[18:04:17.849]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.849]                         if (muffled) 
[18:04:17.849]                           invokeRestart("muffleMessage")
[18:04:17.849]                       }
[18:04:17.849]                       else if (inherits(cond, "warning")) {
[18:04:17.849]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.849]                         if (muffled) 
[18:04:17.849]                           invokeRestart("muffleWarning")
[18:04:17.849]                       }
[18:04:17.849]                       else if (inherits(cond, "condition")) {
[18:04:17.849]                         if (!is.null(pattern)) {
[18:04:17.849]                           computeRestarts <- base::computeRestarts
[18:04:17.849]                           grepl <- base::grepl
[18:04:17.849]                           restarts <- computeRestarts(cond)
[18:04:17.849]                           for (restart in restarts) {
[18:04:17.849]                             name <- restart$name
[18:04:17.849]                             if (is.null(name)) 
[18:04:17.849]                               next
[18:04:17.849]                             if (!grepl(pattern, name)) 
[18:04:17.849]                               next
[18:04:17.849]                             invokeRestart(restart)
[18:04:17.849]                             muffled <- TRUE
[18:04:17.849]                             break
[18:04:17.849]                           }
[18:04:17.849]                         }
[18:04:17.849]                       }
[18:04:17.849]                       invisible(muffled)
[18:04:17.849]                     }
[18:04:17.849]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.849]                   }
[18:04:17.849]                 }
[18:04:17.849]             }
[18:04:17.849]         }))
[18:04:17.849]     }, error = function(ex) {
[18:04:17.849]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:17.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.849]                 ...future.rng), started = ...future.startTime, 
[18:04:17.849]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:17.849]             version = "1.8"), class = "FutureResult")
[18:04:17.849]     }, finally = {
[18:04:17.849]         if (!identical(...future.workdir, getwd())) 
[18:04:17.849]             setwd(...future.workdir)
[18:04:17.849]         {
[18:04:17.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:17.849]                 ...future.oldOptions$nwarnings <- NULL
[18:04:17.849]             }
[18:04:17.849]             base::options(...future.oldOptions)
[18:04:17.849]             if (.Platform$OS.type == "windows") {
[18:04:17.849]                 old_names <- names(...future.oldEnvVars)
[18:04:17.849]                 envs <- base::Sys.getenv()
[18:04:17.849]                 names <- names(envs)
[18:04:17.849]                 common <- intersect(names, old_names)
[18:04:17.849]                 added <- setdiff(names, old_names)
[18:04:17.849]                 removed <- setdiff(old_names, names)
[18:04:17.849]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:17.849]                   envs[common]]
[18:04:17.849]                 NAMES <- toupper(changed)
[18:04:17.849]                 args <- list()
[18:04:17.849]                 for (kk in seq_along(NAMES)) {
[18:04:17.849]                   name <- changed[[kk]]
[18:04:17.849]                   NAME <- NAMES[[kk]]
[18:04:17.849]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.849]                     next
[18:04:17.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.849]                 }
[18:04:17.849]                 NAMES <- toupper(added)
[18:04:17.849]                 for (kk in seq_along(NAMES)) {
[18:04:17.849]                   name <- added[[kk]]
[18:04:17.849]                   NAME <- NAMES[[kk]]
[18:04:17.849]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.849]                     next
[18:04:17.849]                   args[[name]] <- ""
[18:04:17.849]                 }
[18:04:17.849]                 NAMES <- toupper(removed)
[18:04:17.849]                 for (kk in seq_along(NAMES)) {
[18:04:17.849]                   name <- removed[[kk]]
[18:04:17.849]                   NAME <- NAMES[[kk]]
[18:04:17.849]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.849]                     next
[18:04:17.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.849]                 }
[18:04:17.849]                 if (length(args) > 0) 
[18:04:17.849]                   base::do.call(base::Sys.setenv, args = args)
[18:04:17.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:17.849]             }
[18:04:17.849]             else {
[18:04:17.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:17.849]             }
[18:04:17.849]             {
[18:04:17.849]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:17.849]                   0L) {
[18:04:17.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:17.849]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:17.849]                   base::options(opts)
[18:04:17.849]                 }
[18:04:17.849]                 {
[18:04:17.849]                   {
[18:04:17.849]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:17.849]                     NULL
[18:04:17.849]                   }
[18:04:17.849]                   options(future.plan = NULL)
[18:04:17.849]                   if (is.na(NA_character_)) 
[18:04:17.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:17.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:17.849]                     .init = FALSE)
[18:04:17.849]                 }
[18:04:17.849]             }
[18:04:17.849]         }
[18:04:17.849]     })
[18:04:17.849]     if (TRUE) {
[18:04:17.849]         base::sink(type = "output", split = FALSE)
[18:04:17.849]         if (TRUE) {
[18:04:17.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:17.849]         }
[18:04:17.849]         else {
[18:04:17.849]             ...future.result["stdout"] <- base::list(NULL)
[18:04:17.849]         }
[18:04:17.849]         base::close(...future.stdout)
[18:04:17.849]         ...future.stdout <- NULL
[18:04:17.849]     }
[18:04:17.849]     ...future.result$conditions <- ...future.conditions
[18:04:17.849]     ...future.result$finished <- base::Sys.time()
[18:04:17.849]     ...future.result
[18:04:17.849] }
[18:04:17.854] MultisessionFuture started
[18:04:17.855] - Launch lazy future ... done
[18:04:17.855] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b9031c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b0957b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b9031c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b0957b0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[18:04:17.874] receiveMessageFromWorker() for ClusterFuture ...
[18:04:17.874] - Validating connection of MultisessionFuture
[18:04:17.874] - received message: FutureResult
[18:04:17.875] - Received FutureResult
[18:04:17.875] - Erased future from FutureRegistry
[18:04:17.875] result() for ClusterFuture ...
[18:04:17.875] - result already collected: FutureResult
[18:04:17.875] result() for ClusterFuture ... done
[18:04:17.875] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:17.889] resolve() on list ...
[18:04:17.890]  recursive: 0
[18:04:17.890]  length: 6
[18:04:17.890]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:17.890] signalConditionsASAP(numeric, pos=1) ...
[18:04:17.890] - nx: 6
[18:04:17.891] - relay: TRUE
[18:04:17.891] - stdout: TRUE
[18:04:17.891] - signal: TRUE
[18:04:17.891] - resignal: FALSE
[18:04:17.891] - force: TRUE
[18:04:17.892] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.892] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.892]  - until=2
[18:04:17.892]  - relaying element #2
[18:04:17.892] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.893] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.893] signalConditionsASAP(NULL, pos=1) ... done
[18:04:17.893]  length: 5 (resolved future 1)
[18:04:17.893] Future #2
[18:04:17.893] result() for ClusterFuture ...
[18:04:17.894] - result already collected: FutureResult
[18:04:17.894] result() for ClusterFuture ... done
[18:04:17.894] result() for ClusterFuture ...
[18:04:17.894] - result already collected: FutureResult
[18:04:17.894] result() for ClusterFuture ... done
[18:04:17.894] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:17.895] - nx: 6
[18:04:17.896] - relay: TRUE
[18:04:17.896] - stdout: TRUE
[18:04:17.896] - signal: TRUE
[18:04:17.897] - resignal: FALSE
[18:04:17.897] - force: TRUE
[18:04:17.897] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.897] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:17.897]  - until=2
[18:04:17.898]  - relaying element #2
[18:04:17.898] result() for ClusterFuture ...
[18:04:17.898] - result already collected: FutureResult
[18:04:17.898] result() for ClusterFuture ... done
[18:04:17.898] result() for ClusterFuture ...
[18:04:17.899] - result already collected: FutureResult
[18:04:17.899] result() for ClusterFuture ... done
[18:04:17.899] result() for ClusterFuture ...
[18:04:17.899] - result already collected: FutureResult
[18:04:17.899] result() for ClusterFuture ... done
[18:04:17.900] result() for ClusterFuture ...
[18:04:17.900] - result already collected: FutureResult
[18:04:17.900] result() for ClusterFuture ... done
[18:04:17.900] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.900] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.900] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:17.901]  length: 4 (resolved future 2)
[18:04:17.902] receiveMessageFromWorker() for ClusterFuture ...
[18:04:17.902] - Validating connection of MultisessionFuture
[18:04:17.902] - received message: FutureResult
[18:04:17.902] - Received FutureResult
[18:04:17.903] - Erased future from FutureRegistry
[18:04:17.903] result() for ClusterFuture ...
[18:04:17.903] - result already collected: FutureResult
[18:04:17.903] result() for ClusterFuture ... done
[18:04:17.903] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:17.904] Future #3
[18:04:17.904] result() for ClusterFuture ...
[18:04:17.904] - result already collected: FutureResult
[18:04:17.904] result() for ClusterFuture ... done
[18:04:17.904] result() for ClusterFuture ...
[18:04:17.905] - result already collected: FutureResult
[18:04:17.905] result() for ClusterFuture ... done
[18:04:17.905] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:17.905] - nx: 6
[18:04:17.905] - relay: TRUE
[18:04:17.905] - stdout: TRUE
[18:04:17.906] - signal: TRUE
[18:04:17.906] - resignal: FALSE
[18:04:17.906] - force: TRUE
[18:04:17.906] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.906] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:17.907]  - until=3
[18:04:17.907]  - relaying element #3
[18:04:17.907] result() for ClusterFuture ...
[18:04:17.907] - result already collected: FutureResult
[18:04:17.907] result() for ClusterFuture ... done
[18:04:17.908] result() for ClusterFuture ...
[18:04:17.908] - result already collected: FutureResult
[18:04:17.908] result() for ClusterFuture ... done
[18:04:17.908] result() for ClusterFuture ...
[18:04:17.908] - result already collected: FutureResult
[18:04:17.908] result() for ClusterFuture ... done
[18:04:17.909] result() for ClusterFuture ...
[18:04:17.909] - result already collected: FutureResult
[18:04:17.909] result() for ClusterFuture ... done
[18:04:17.909] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.909] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.910] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:17.910]  length: 3 (resolved future 3)
[18:04:17.910] signalConditionsASAP(NULL, pos=4) ...
[18:04:17.910] - nx: 6
[18:04:17.910] - relay: TRUE
[18:04:17.911] - stdout: TRUE
[18:04:17.911] - signal: TRUE
[18:04:17.911] - resignal: FALSE
[18:04:17.911] - force: TRUE
[18:04:17.911] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.911] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.912]  - until=5
[18:04:17.912]  - relaying element #5
[18:04:17.912] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:17.912] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.912] signalConditionsASAP(NULL, pos=4) ... done
[18:04:17.913]  length: 2 (resolved future 4)
[18:04:17.913] signalConditionsASAP(NULL, pos=5) ...
[18:04:17.913] - nx: 6
[18:04:17.913] - relay: TRUE
[18:04:17.913] - stdout: TRUE
[18:04:17.913] - signal: TRUE
[18:04:17.914] - resignal: FALSE
[18:04:17.914] - force: TRUE
[18:04:17.914] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:17.914] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.914]  - until=6
[18:04:17.914]  - relaying element #6
[18:04:17.915] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:17.915] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.915] signalConditionsASAP(NULL, pos=5) ... done
[18:04:17.915]  length: 1 (resolved future 5)
[18:04:17.915] signalConditionsASAP(numeric, pos=6) ...
[18:04:17.916] - nx: 6
[18:04:17.916] - relay: TRUE
[18:04:17.916] - stdout: TRUE
[18:04:17.916] - signal: TRUE
[18:04:17.916] - resignal: FALSE
[18:04:17.916] - force: TRUE
[18:04:17.917] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:17.917] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.917]  - until=6
[18:04:17.917] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:17.917] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.918] signalConditionsASAP(numeric, pos=6) ... done
[18:04:17.918]  length: 0 (resolved future 6)
[18:04:17.918] Relaying remaining futures
[18:04:17.918] signalConditionsASAP(NULL, pos=0) ...
[18:04:17.918] - nx: 6
[18:04:17.918] - relay: TRUE
[18:04:17.919] - stdout: TRUE
[18:04:17.919] - signal: TRUE
[18:04:17.919] - resignal: FALSE
[18:04:17.919] - force: TRUE
[18:04:17.919] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:17.919] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:17.920] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:17.920] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:17.920] signalConditionsASAP(NULL, pos=0) ... done
[18:04:17.920] resolve() on list ... DONE
[18:04:17.921] result() for ClusterFuture ...
[18:04:17.921] - result already collected: FutureResult
[18:04:17.921] result() for ClusterFuture ... done
[18:04:17.921] result() for ClusterFuture ...
[18:04:17.921] - result already collected: FutureResult
[18:04:17.921] result() for ClusterFuture ... done
[18:04:17.922] result() for ClusterFuture ...
[18:04:17.922] - result already collected: FutureResult
[18:04:17.922] result() for ClusterFuture ... done
[18:04:17.922] result() for ClusterFuture ...
[18:04:17.922] - result already collected: FutureResult
[18:04:17.923] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[18:04:17.929] getGlobalsAndPackages() ...
[18:04:17.929] Searching for globals...
[18:04:17.929] 
[18:04:17.930] Searching for globals ... DONE
[18:04:17.930] - globals: [0] <none>
[18:04:17.930] getGlobalsAndPackages() ... DONE
[18:04:17.930] run() for ‘Future’ ...
[18:04:17.931] - state: ‘created’
[18:04:17.931] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:17.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:17.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:17.955]   - Field: ‘node’
[18:04:17.955]   - Field: ‘label’
[18:04:17.956]   - Field: ‘local’
[18:04:17.956]   - Field: ‘owner’
[18:04:17.956]   - Field: ‘envir’
[18:04:17.956]   - Field: ‘workers’
[18:04:17.956]   - Field: ‘packages’
[18:04:17.957]   - Field: ‘gc’
[18:04:17.957]   - Field: ‘conditions’
[18:04:17.957]   - Field: ‘persistent’
[18:04:17.957]   - Field: ‘expr’
[18:04:17.957]   - Field: ‘uuid’
[18:04:17.958]   - Field: ‘seed’
[18:04:17.958]   - Field: ‘version’
[18:04:17.958]   - Field: ‘result’
[18:04:17.958]   - Field: ‘asynchronous’
[18:04:17.958]   - Field: ‘calls’
[18:04:17.959]   - Field: ‘globals’
[18:04:17.959]   - Field: ‘stdout’
[18:04:17.959]   - Field: ‘earlySignal’
[18:04:17.959]   - Field: ‘lazy’
[18:04:17.959]   - Field: ‘state’
[18:04:17.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:17.960] - Launch lazy future ...
[18:04:17.960] Packages needed by the future expression (n = 0): <none>
[18:04:17.961] Packages needed by future strategies (n = 0): <none>
[18:04:17.961] {
[18:04:17.961]     {
[18:04:17.961]         {
[18:04:17.961]             ...future.startTime <- base::Sys.time()
[18:04:17.961]             {
[18:04:17.961]                 {
[18:04:17.961]                   {
[18:04:17.961]                     {
[18:04:17.961]                       base::local({
[18:04:17.961]                         has_future <- base::requireNamespace("future", 
[18:04:17.961]                           quietly = TRUE)
[18:04:17.961]                         if (has_future) {
[18:04:17.961]                           ns <- base::getNamespace("future")
[18:04:17.961]                           version <- ns[[".package"]][["version"]]
[18:04:17.961]                           if (is.null(version)) 
[18:04:17.961]                             version <- utils::packageVersion("future")
[18:04:17.961]                         }
[18:04:17.961]                         else {
[18:04:17.961]                           version <- NULL
[18:04:17.961]                         }
[18:04:17.961]                         if (!has_future || version < "1.8.0") {
[18:04:17.961]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:17.961]                             "", base::R.version$version.string), 
[18:04:17.961]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:17.961]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:17.961]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:17.961]                               "release", "version")], collapse = " "), 
[18:04:17.961]                             hostname = base::Sys.info()[["nodename"]])
[18:04:17.961]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:17.961]                             info)
[18:04:17.961]                           info <- base::paste(info, collapse = "; ")
[18:04:17.961]                           if (!has_future) {
[18:04:17.961]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:17.961]                               info)
[18:04:17.961]                           }
[18:04:17.961]                           else {
[18:04:17.961]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:17.961]                               info, version)
[18:04:17.961]                           }
[18:04:17.961]                           base::stop(msg)
[18:04:17.961]                         }
[18:04:17.961]                       })
[18:04:17.961]                     }
[18:04:17.961]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:17.961]                     base::options(mc.cores = 1L)
[18:04:17.961]                   }
[18:04:17.961]                   ...future.strategy.old <- future::plan("list")
[18:04:17.961]                   options(future.plan = NULL)
[18:04:17.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:17.961]                 }
[18:04:17.961]                 ...future.workdir <- getwd()
[18:04:17.961]             }
[18:04:17.961]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:17.961]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:17.961]         }
[18:04:17.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:17.961]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:17.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:17.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:17.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:17.961]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:17.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:17.961]             base::names(...future.oldOptions))
[18:04:17.961]     }
[18:04:17.961]     if (FALSE) {
[18:04:17.961]     }
[18:04:17.961]     else {
[18:04:17.961]         if (TRUE) {
[18:04:17.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:17.961]                 open = "w")
[18:04:17.961]         }
[18:04:17.961]         else {
[18:04:17.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:17.961]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:17.961]         }
[18:04:17.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:17.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:17.961]             base::sink(type = "output", split = FALSE)
[18:04:17.961]             base::close(...future.stdout)
[18:04:17.961]         }, add = TRUE)
[18:04:17.961]     }
[18:04:17.961]     ...future.frame <- base::sys.nframe()
[18:04:17.961]     ...future.conditions <- base::list()
[18:04:17.961]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:17.961]     if (FALSE) {
[18:04:17.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:17.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:17.961]     }
[18:04:17.961]     ...future.result <- base::tryCatch({
[18:04:17.961]         base::withCallingHandlers({
[18:04:17.961]             ...future.value <- base::withVisible(base::local({
[18:04:17.961]                 ...future.makeSendCondition <- base::local({
[18:04:17.961]                   sendCondition <- NULL
[18:04:17.961]                   function(frame = 1L) {
[18:04:17.961]                     if (is.function(sendCondition)) 
[18:04:17.961]                       return(sendCondition)
[18:04:17.961]                     ns <- getNamespace("parallel")
[18:04:17.961]                     if (exists("sendData", mode = "function", 
[18:04:17.961]                       envir = ns)) {
[18:04:17.961]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:17.961]                         envir = ns)
[18:04:17.961]                       envir <- sys.frame(frame)
[18:04:17.961]                       master <- NULL
[18:04:17.961]                       while (!identical(envir, .GlobalEnv) && 
[18:04:17.961]                         !identical(envir, emptyenv())) {
[18:04:17.961]                         if (exists("master", mode = "list", envir = envir, 
[18:04:17.961]                           inherits = FALSE)) {
[18:04:17.961]                           master <- get("master", mode = "list", 
[18:04:17.961]                             envir = envir, inherits = FALSE)
[18:04:17.961]                           if (inherits(master, c("SOCKnode", 
[18:04:17.961]                             "SOCK0node"))) {
[18:04:17.961]                             sendCondition <<- function(cond) {
[18:04:17.961]                               data <- list(type = "VALUE", value = cond, 
[18:04:17.961]                                 success = TRUE)
[18:04:17.961]                               parallel_sendData(master, data)
[18:04:17.961]                             }
[18:04:17.961]                             return(sendCondition)
[18:04:17.961]                           }
[18:04:17.961]                         }
[18:04:17.961]                         frame <- frame + 1L
[18:04:17.961]                         envir <- sys.frame(frame)
[18:04:17.961]                       }
[18:04:17.961]                     }
[18:04:17.961]                     sendCondition <<- function(cond) NULL
[18:04:17.961]                   }
[18:04:17.961]                 })
[18:04:17.961]                 withCallingHandlers({
[18:04:17.961]                   2
[18:04:17.961]                 }, immediateCondition = function(cond) {
[18:04:17.961]                   sendCondition <- ...future.makeSendCondition()
[18:04:17.961]                   sendCondition(cond)
[18:04:17.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.961]                   {
[18:04:17.961]                     inherits <- base::inherits
[18:04:17.961]                     invokeRestart <- base::invokeRestart
[18:04:17.961]                     is.null <- base::is.null
[18:04:17.961]                     muffled <- FALSE
[18:04:17.961]                     if (inherits(cond, "message")) {
[18:04:17.961]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:17.961]                       if (muffled) 
[18:04:17.961]                         invokeRestart("muffleMessage")
[18:04:17.961]                     }
[18:04:17.961]                     else if (inherits(cond, "warning")) {
[18:04:17.961]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:17.961]                       if (muffled) 
[18:04:17.961]                         invokeRestart("muffleWarning")
[18:04:17.961]                     }
[18:04:17.961]                     else if (inherits(cond, "condition")) {
[18:04:17.961]                       if (!is.null(pattern)) {
[18:04:17.961]                         computeRestarts <- base::computeRestarts
[18:04:17.961]                         grepl <- base::grepl
[18:04:17.961]                         restarts <- computeRestarts(cond)
[18:04:17.961]                         for (restart in restarts) {
[18:04:17.961]                           name <- restart$name
[18:04:17.961]                           if (is.null(name)) 
[18:04:17.961]                             next
[18:04:17.961]                           if (!grepl(pattern, name)) 
[18:04:17.961]                             next
[18:04:17.961]                           invokeRestart(restart)
[18:04:17.961]                           muffled <- TRUE
[18:04:17.961]                           break
[18:04:17.961]                         }
[18:04:17.961]                       }
[18:04:17.961]                     }
[18:04:17.961]                     invisible(muffled)
[18:04:17.961]                   }
[18:04:17.961]                   muffleCondition(cond)
[18:04:17.961]                 })
[18:04:17.961]             }))
[18:04:17.961]             future::FutureResult(value = ...future.value$value, 
[18:04:17.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.961]                   ...future.rng), globalenv = if (FALSE) 
[18:04:17.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:17.961]                     ...future.globalenv.names))
[18:04:17.961]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:17.961]         }, condition = base::local({
[18:04:17.961]             c <- base::c
[18:04:17.961]             inherits <- base::inherits
[18:04:17.961]             invokeRestart <- base::invokeRestart
[18:04:17.961]             length <- base::length
[18:04:17.961]             list <- base::list
[18:04:17.961]             seq.int <- base::seq.int
[18:04:17.961]             signalCondition <- base::signalCondition
[18:04:17.961]             sys.calls <- base::sys.calls
[18:04:17.961]             `[[` <- base::`[[`
[18:04:17.961]             `+` <- base::`+`
[18:04:17.961]             `<<-` <- base::`<<-`
[18:04:17.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:17.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:17.961]                   3L)]
[18:04:17.961]             }
[18:04:17.961]             function(cond) {
[18:04:17.961]                 is_error <- inherits(cond, "error")
[18:04:17.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:17.961]                   NULL)
[18:04:17.961]                 if (is_error) {
[18:04:17.961]                   sessionInformation <- function() {
[18:04:17.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:17.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:17.961]                       search = base::search(), system = base::Sys.info())
[18:04:17.961]                   }
[18:04:17.961]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:17.961]                     cond$call), session = sessionInformation(), 
[18:04:17.961]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:17.961]                   signalCondition(cond)
[18:04:17.961]                 }
[18:04:17.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:17.961]                 "immediateCondition"))) {
[18:04:17.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:17.961]                   ...future.conditions[[length(...future.conditions) + 
[18:04:17.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:17.961]                   if (TRUE && !signal) {
[18:04:17.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.961]                     {
[18:04:17.961]                       inherits <- base::inherits
[18:04:17.961]                       invokeRestart <- base::invokeRestart
[18:04:17.961]                       is.null <- base::is.null
[18:04:17.961]                       muffled <- FALSE
[18:04:17.961]                       if (inherits(cond, "message")) {
[18:04:17.961]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.961]                         if (muffled) 
[18:04:17.961]                           invokeRestart("muffleMessage")
[18:04:17.961]                       }
[18:04:17.961]                       else if (inherits(cond, "warning")) {
[18:04:17.961]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.961]                         if (muffled) 
[18:04:17.961]                           invokeRestart("muffleWarning")
[18:04:17.961]                       }
[18:04:17.961]                       else if (inherits(cond, "condition")) {
[18:04:17.961]                         if (!is.null(pattern)) {
[18:04:17.961]                           computeRestarts <- base::computeRestarts
[18:04:17.961]                           grepl <- base::grepl
[18:04:17.961]                           restarts <- computeRestarts(cond)
[18:04:17.961]                           for (restart in restarts) {
[18:04:17.961]                             name <- restart$name
[18:04:17.961]                             if (is.null(name)) 
[18:04:17.961]                               next
[18:04:17.961]                             if (!grepl(pattern, name)) 
[18:04:17.961]                               next
[18:04:17.961]                             invokeRestart(restart)
[18:04:17.961]                             muffled <- TRUE
[18:04:17.961]                             break
[18:04:17.961]                           }
[18:04:17.961]                         }
[18:04:17.961]                       }
[18:04:17.961]                       invisible(muffled)
[18:04:17.961]                     }
[18:04:17.961]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.961]                   }
[18:04:17.961]                 }
[18:04:17.961]                 else {
[18:04:17.961]                   if (TRUE) {
[18:04:17.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:17.961]                     {
[18:04:17.961]                       inherits <- base::inherits
[18:04:17.961]                       invokeRestart <- base::invokeRestart
[18:04:17.961]                       is.null <- base::is.null
[18:04:17.961]                       muffled <- FALSE
[18:04:17.961]                       if (inherits(cond, "message")) {
[18:04:17.961]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:17.961]                         if (muffled) 
[18:04:17.961]                           invokeRestart("muffleMessage")
[18:04:17.961]                       }
[18:04:17.961]                       else if (inherits(cond, "warning")) {
[18:04:17.961]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:17.961]                         if (muffled) 
[18:04:17.961]                           invokeRestart("muffleWarning")
[18:04:17.961]                       }
[18:04:17.961]                       else if (inherits(cond, "condition")) {
[18:04:17.961]                         if (!is.null(pattern)) {
[18:04:17.961]                           computeRestarts <- base::computeRestarts
[18:04:17.961]                           grepl <- base::grepl
[18:04:17.961]                           restarts <- computeRestarts(cond)
[18:04:17.961]                           for (restart in restarts) {
[18:04:17.961]                             name <- restart$name
[18:04:17.961]                             if (is.null(name)) 
[18:04:17.961]                               next
[18:04:17.961]                             if (!grepl(pattern, name)) 
[18:04:17.961]                               next
[18:04:17.961]                             invokeRestart(restart)
[18:04:17.961]                             muffled <- TRUE
[18:04:17.961]                             break
[18:04:17.961]                           }
[18:04:17.961]                         }
[18:04:17.961]                       }
[18:04:17.961]                       invisible(muffled)
[18:04:17.961]                     }
[18:04:17.961]                     muffleCondition(cond, pattern = "^muffle")
[18:04:17.961]                   }
[18:04:17.961]                 }
[18:04:17.961]             }
[18:04:17.961]         }))
[18:04:17.961]     }, error = function(ex) {
[18:04:17.961]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:17.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:17.961]                 ...future.rng), started = ...future.startTime, 
[18:04:17.961]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:17.961]             version = "1.8"), class = "FutureResult")
[18:04:17.961]     }, finally = {
[18:04:17.961]         if (!identical(...future.workdir, getwd())) 
[18:04:17.961]             setwd(...future.workdir)
[18:04:17.961]         {
[18:04:17.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:17.961]                 ...future.oldOptions$nwarnings <- NULL
[18:04:17.961]             }
[18:04:17.961]             base::options(...future.oldOptions)
[18:04:17.961]             if (.Platform$OS.type == "windows") {
[18:04:17.961]                 old_names <- names(...future.oldEnvVars)
[18:04:17.961]                 envs <- base::Sys.getenv()
[18:04:17.961]                 names <- names(envs)
[18:04:17.961]                 common <- intersect(names, old_names)
[18:04:17.961]                 added <- setdiff(names, old_names)
[18:04:17.961]                 removed <- setdiff(old_names, names)
[18:04:17.961]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:17.961]                   envs[common]]
[18:04:17.961]                 NAMES <- toupper(changed)
[18:04:17.961]                 args <- list()
[18:04:17.961]                 for (kk in seq_along(NAMES)) {
[18:04:17.961]                   name <- changed[[kk]]
[18:04:17.961]                   NAME <- NAMES[[kk]]
[18:04:17.961]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.961]                     next
[18:04:17.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.961]                 }
[18:04:17.961]                 NAMES <- toupper(added)
[18:04:17.961]                 for (kk in seq_along(NAMES)) {
[18:04:17.961]                   name <- added[[kk]]
[18:04:17.961]                   NAME <- NAMES[[kk]]
[18:04:17.961]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.961]                     next
[18:04:17.961]                   args[[name]] <- ""
[18:04:17.961]                 }
[18:04:17.961]                 NAMES <- toupper(removed)
[18:04:17.961]                 for (kk in seq_along(NAMES)) {
[18:04:17.961]                   name <- removed[[kk]]
[18:04:17.961]                   NAME <- NAMES[[kk]]
[18:04:17.961]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:17.961]                     next
[18:04:17.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:17.961]                 }
[18:04:17.961]                 if (length(args) > 0) 
[18:04:17.961]                   base::do.call(base::Sys.setenv, args = args)
[18:04:17.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:17.961]             }
[18:04:17.961]             else {
[18:04:17.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:17.961]             }
[18:04:17.961]             {
[18:04:17.961]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:17.961]                   0L) {
[18:04:17.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:17.961]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:17.961]                   base::options(opts)
[18:04:17.961]                 }
[18:04:17.961]                 {
[18:04:17.961]                   {
[18:04:17.961]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:17.961]                     NULL
[18:04:17.961]                   }
[18:04:17.961]                   options(future.plan = NULL)
[18:04:17.961]                   if (is.na(NA_character_)) 
[18:04:17.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:17.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:17.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:17.961]                     .init = FALSE)
[18:04:17.961]                 }
[18:04:17.961]             }
[18:04:17.961]         }
[18:04:17.961]     })
[18:04:17.961]     if (TRUE) {
[18:04:17.961]         base::sink(type = "output", split = FALSE)
[18:04:17.961]         if (TRUE) {
[18:04:17.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:17.961]         }
[18:04:17.961]         else {
[18:04:17.961]             ...future.result["stdout"] <- base::list(NULL)
[18:04:17.961]         }
[18:04:17.961]         base::close(...future.stdout)
[18:04:17.961]         ...future.stdout <- NULL
[18:04:17.961]     }
[18:04:17.961]     ...future.result$conditions <- ...future.conditions
[18:04:17.961]     ...future.result$finished <- base::Sys.time()
[18:04:17.961]     ...future.result
[18:04:17.961] }
[18:04:17.967] MultisessionFuture started
[18:04:17.967] - Launch lazy future ... done
[18:04:17.968] run() for ‘MultisessionFuture’ ... done
[18:04:17.968] getGlobalsAndPackages() ...
[18:04:17.968] Searching for globals...
[18:04:17.969] 
[18:04:17.969] Searching for globals ... DONE
[18:04:17.969] - globals: [0] <none>
[18:04:17.969] getGlobalsAndPackages() ... DONE
[18:04:17.970] run() for ‘Future’ ...
[18:04:17.970] - state: ‘created’
[18:04:17.970] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:17.994] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:17.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:17.995]   - Field: ‘node’
[18:04:17.995]   - Field: ‘label’
[18:04:17.995]   - Field: ‘local’
[18:04:17.995]   - Field: ‘owner’
[18:04:17.995]   - Field: ‘envir’
[18:04:17.996]   - Field: ‘workers’
[18:04:17.996]   - Field: ‘packages’
[18:04:17.996]   - Field: ‘gc’
[18:04:17.996]   - Field: ‘conditions’
[18:04:17.996]   - Field: ‘persistent’
[18:04:17.997]   - Field: ‘expr’
[18:04:17.997]   - Field: ‘uuid’
[18:04:17.997]   - Field: ‘seed’
[18:04:17.997]   - Field: ‘version’
[18:04:17.997]   - Field: ‘result’
[18:04:17.998]   - Field: ‘asynchronous’
[18:04:17.998]   - Field: ‘calls’
[18:04:17.998]   - Field: ‘globals’
[18:04:17.998]   - Field: ‘stdout’
[18:04:17.998]   - Field: ‘earlySignal’
[18:04:17.999]   - Field: ‘lazy’
[18:04:17.999]   - Field: ‘state’
[18:04:17.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:17.999] - Launch lazy future ...
[18:04:18.000] Packages needed by the future expression (n = 0): <none>
[18:04:18.000] Packages needed by future strategies (n = 0): <none>
[18:04:18.001] {
[18:04:18.001]     {
[18:04:18.001]         {
[18:04:18.001]             ...future.startTime <- base::Sys.time()
[18:04:18.001]             {
[18:04:18.001]                 {
[18:04:18.001]                   {
[18:04:18.001]                     {
[18:04:18.001]                       base::local({
[18:04:18.001]                         has_future <- base::requireNamespace("future", 
[18:04:18.001]                           quietly = TRUE)
[18:04:18.001]                         if (has_future) {
[18:04:18.001]                           ns <- base::getNamespace("future")
[18:04:18.001]                           version <- ns[[".package"]][["version"]]
[18:04:18.001]                           if (is.null(version)) 
[18:04:18.001]                             version <- utils::packageVersion("future")
[18:04:18.001]                         }
[18:04:18.001]                         else {
[18:04:18.001]                           version <- NULL
[18:04:18.001]                         }
[18:04:18.001]                         if (!has_future || version < "1.8.0") {
[18:04:18.001]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.001]                             "", base::R.version$version.string), 
[18:04:18.001]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.001]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.001]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.001]                               "release", "version")], collapse = " "), 
[18:04:18.001]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.001]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.001]                             info)
[18:04:18.001]                           info <- base::paste(info, collapse = "; ")
[18:04:18.001]                           if (!has_future) {
[18:04:18.001]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.001]                               info)
[18:04:18.001]                           }
[18:04:18.001]                           else {
[18:04:18.001]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.001]                               info, version)
[18:04:18.001]                           }
[18:04:18.001]                           base::stop(msg)
[18:04:18.001]                         }
[18:04:18.001]                       })
[18:04:18.001]                     }
[18:04:18.001]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.001]                     base::options(mc.cores = 1L)
[18:04:18.001]                   }
[18:04:18.001]                   ...future.strategy.old <- future::plan("list")
[18:04:18.001]                   options(future.plan = NULL)
[18:04:18.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.001]                 }
[18:04:18.001]                 ...future.workdir <- getwd()
[18:04:18.001]             }
[18:04:18.001]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.001]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.001]         }
[18:04:18.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.001]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.001]             base::names(...future.oldOptions))
[18:04:18.001]     }
[18:04:18.001]     if (FALSE) {
[18:04:18.001]     }
[18:04:18.001]     else {
[18:04:18.001]         if (TRUE) {
[18:04:18.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.001]                 open = "w")
[18:04:18.001]         }
[18:04:18.001]         else {
[18:04:18.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.001]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.001]         }
[18:04:18.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.001]             base::sink(type = "output", split = FALSE)
[18:04:18.001]             base::close(...future.stdout)
[18:04:18.001]         }, add = TRUE)
[18:04:18.001]     }
[18:04:18.001]     ...future.frame <- base::sys.nframe()
[18:04:18.001]     ...future.conditions <- base::list()
[18:04:18.001]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.001]     if (FALSE) {
[18:04:18.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.001]     }
[18:04:18.001]     ...future.result <- base::tryCatch({
[18:04:18.001]         base::withCallingHandlers({
[18:04:18.001]             ...future.value <- base::withVisible(base::local({
[18:04:18.001]                 ...future.makeSendCondition <- base::local({
[18:04:18.001]                   sendCondition <- NULL
[18:04:18.001]                   function(frame = 1L) {
[18:04:18.001]                     if (is.function(sendCondition)) 
[18:04:18.001]                       return(sendCondition)
[18:04:18.001]                     ns <- getNamespace("parallel")
[18:04:18.001]                     if (exists("sendData", mode = "function", 
[18:04:18.001]                       envir = ns)) {
[18:04:18.001]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:18.001]                         envir = ns)
[18:04:18.001]                       envir <- sys.frame(frame)
[18:04:18.001]                       master <- NULL
[18:04:18.001]                       while (!identical(envir, .GlobalEnv) && 
[18:04:18.001]                         !identical(envir, emptyenv())) {
[18:04:18.001]                         if (exists("master", mode = "list", envir = envir, 
[18:04:18.001]                           inherits = FALSE)) {
[18:04:18.001]                           master <- get("master", mode = "list", 
[18:04:18.001]                             envir = envir, inherits = FALSE)
[18:04:18.001]                           if (inherits(master, c("SOCKnode", 
[18:04:18.001]                             "SOCK0node"))) {
[18:04:18.001]                             sendCondition <<- function(cond) {
[18:04:18.001]                               data <- list(type = "VALUE", value = cond, 
[18:04:18.001]                                 success = TRUE)
[18:04:18.001]                               parallel_sendData(master, data)
[18:04:18.001]                             }
[18:04:18.001]                             return(sendCondition)
[18:04:18.001]                           }
[18:04:18.001]                         }
[18:04:18.001]                         frame <- frame + 1L
[18:04:18.001]                         envir <- sys.frame(frame)
[18:04:18.001]                       }
[18:04:18.001]                     }
[18:04:18.001]                     sendCondition <<- function(cond) NULL
[18:04:18.001]                   }
[18:04:18.001]                 })
[18:04:18.001]                 withCallingHandlers({
[18:04:18.001]                   NULL
[18:04:18.001]                 }, immediateCondition = function(cond) {
[18:04:18.001]                   sendCondition <- ...future.makeSendCondition()
[18:04:18.001]                   sendCondition(cond)
[18:04:18.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.001]                   {
[18:04:18.001]                     inherits <- base::inherits
[18:04:18.001]                     invokeRestart <- base::invokeRestart
[18:04:18.001]                     is.null <- base::is.null
[18:04:18.001]                     muffled <- FALSE
[18:04:18.001]                     if (inherits(cond, "message")) {
[18:04:18.001]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.001]                       if (muffled) 
[18:04:18.001]                         invokeRestart("muffleMessage")
[18:04:18.001]                     }
[18:04:18.001]                     else if (inherits(cond, "warning")) {
[18:04:18.001]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.001]                       if (muffled) 
[18:04:18.001]                         invokeRestart("muffleWarning")
[18:04:18.001]                     }
[18:04:18.001]                     else if (inherits(cond, "condition")) {
[18:04:18.001]                       if (!is.null(pattern)) {
[18:04:18.001]                         computeRestarts <- base::computeRestarts
[18:04:18.001]                         grepl <- base::grepl
[18:04:18.001]                         restarts <- computeRestarts(cond)
[18:04:18.001]                         for (restart in restarts) {
[18:04:18.001]                           name <- restart$name
[18:04:18.001]                           if (is.null(name)) 
[18:04:18.001]                             next
[18:04:18.001]                           if (!grepl(pattern, name)) 
[18:04:18.001]                             next
[18:04:18.001]                           invokeRestart(restart)
[18:04:18.001]                           muffled <- TRUE
[18:04:18.001]                           break
[18:04:18.001]                         }
[18:04:18.001]                       }
[18:04:18.001]                     }
[18:04:18.001]                     invisible(muffled)
[18:04:18.001]                   }
[18:04:18.001]                   muffleCondition(cond)
[18:04:18.001]                 })
[18:04:18.001]             }))
[18:04:18.001]             future::FutureResult(value = ...future.value$value, 
[18:04:18.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.001]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.001]                     ...future.globalenv.names))
[18:04:18.001]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.001]         }, condition = base::local({
[18:04:18.001]             c <- base::c
[18:04:18.001]             inherits <- base::inherits
[18:04:18.001]             invokeRestart <- base::invokeRestart
[18:04:18.001]             length <- base::length
[18:04:18.001]             list <- base::list
[18:04:18.001]             seq.int <- base::seq.int
[18:04:18.001]             signalCondition <- base::signalCondition
[18:04:18.001]             sys.calls <- base::sys.calls
[18:04:18.001]             `[[` <- base::`[[`
[18:04:18.001]             `+` <- base::`+`
[18:04:18.001]             `<<-` <- base::`<<-`
[18:04:18.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.001]                   3L)]
[18:04:18.001]             }
[18:04:18.001]             function(cond) {
[18:04:18.001]                 is_error <- inherits(cond, "error")
[18:04:18.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.001]                   NULL)
[18:04:18.001]                 if (is_error) {
[18:04:18.001]                   sessionInformation <- function() {
[18:04:18.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.001]                       search = base::search(), system = base::Sys.info())
[18:04:18.001]                   }
[18:04:18.001]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.001]                     cond$call), session = sessionInformation(), 
[18:04:18.001]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.001]                   signalCondition(cond)
[18:04:18.001]                 }
[18:04:18.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.001]                 "immediateCondition"))) {
[18:04:18.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.001]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.001]                   if (TRUE && !signal) {
[18:04:18.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.001]                     {
[18:04:18.001]                       inherits <- base::inherits
[18:04:18.001]                       invokeRestart <- base::invokeRestart
[18:04:18.001]                       is.null <- base::is.null
[18:04:18.001]                       muffled <- FALSE
[18:04:18.001]                       if (inherits(cond, "message")) {
[18:04:18.001]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.001]                         if (muffled) 
[18:04:18.001]                           invokeRestart("muffleMessage")
[18:04:18.001]                       }
[18:04:18.001]                       else if (inherits(cond, "warning")) {
[18:04:18.001]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.001]                         if (muffled) 
[18:04:18.001]                           invokeRestart("muffleWarning")
[18:04:18.001]                       }
[18:04:18.001]                       else if (inherits(cond, "condition")) {
[18:04:18.001]                         if (!is.null(pattern)) {
[18:04:18.001]                           computeRestarts <- base::computeRestarts
[18:04:18.001]                           grepl <- base::grepl
[18:04:18.001]                           restarts <- computeRestarts(cond)
[18:04:18.001]                           for (restart in restarts) {
[18:04:18.001]                             name <- restart$name
[18:04:18.001]                             if (is.null(name)) 
[18:04:18.001]                               next
[18:04:18.001]                             if (!grepl(pattern, name)) 
[18:04:18.001]                               next
[18:04:18.001]                             invokeRestart(restart)
[18:04:18.001]                             muffled <- TRUE
[18:04:18.001]                             break
[18:04:18.001]                           }
[18:04:18.001]                         }
[18:04:18.001]                       }
[18:04:18.001]                       invisible(muffled)
[18:04:18.001]                     }
[18:04:18.001]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.001]                   }
[18:04:18.001]                 }
[18:04:18.001]                 else {
[18:04:18.001]                   if (TRUE) {
[18:04:18.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.001]                     {
[18:04:18.001]                       inherits <- base::inherits
[18:04:18.001]                       invokeRestart <- base::invokeRestart
[18:04:18.001]                       is.null <- base::is.null
[18:04:18.001]                       muffled <- FALSE
[18:04:18.001]                       if (inherits(cond, "message")) {
[18:04:18.001]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.001]                         if (muffled) 
[18:04:18.001]                           invokeRestart("muffleMessage")
[18:04:18.001]                       }
[18:04:18.001]                       else if (inherits(cond, "warning")) {
[18:04:18.001]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.001]                         if (muffled) 
[18:04:18.001]                           invokeRestart("muffleWarning")
[18:04:18.001]                       }
[18:04:18.001]                       else if (inherits(cond, "condition")) {
[18:04:18.001]                         if (!is.null(pattern)) {
[18:04:18.001]                           computeRestarts <- base::computeRestarts
[18:04:18.001]                           grepl <- base::grepl
[18:04:18.001]                           restarts <- computeRestarts(cond)
[18:04:18.001]                           for (restart in restarts) {
[18:04:18.001]                             name <- restart$name
[18:04:18.001]                             if (is.null(name)) 
[18:04:18.001]                               next
[18:04:18.001]                             if (!grepl(pattern, name)) 
[18:04:18.001]                               next
[18:04:18.001]                             invokeRestart(restart)
[18:04:18.001]                             muffled <- TRUE
[18:04:18.001]                             break
[18:04:18.001]                           }
[18:04:18.001]                         }
[18:04:18.001]                       }
[18:04:18.001]                       invisible(muffled)
[18:04:18.001]                     }
[18:04:18.001]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.001]                   }
[18:04:18.001]                 }
[18:04:18.001]             }
[18:04:18.001]         }))
[18:04:18.001]     }, error = function(ex) {
[18:04:18.001]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.001]                 ...future.rng), started = ...future.startTime, 
[18:04:18.001]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.001]             version = "1.8"), class = "FutureResult")
[18:04:18.001]     }, finally = {
[18:04:18.001]         if (!identical(...future.workdir, getwd())) 
[18:04:18.001]             setwd(...future.workdir)
[18:04:18.001]         {
[18:04:18.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.001]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.001]             }
[18:04:18.001]             base::options(...future.oldOptions)
[18:04:18.001]             if (.Platform$OS.type == "windows") {
[18:04:18.001]                 old_names <- names(...future.oldEnvVars)
[18:04:18.001]                 envs <- base::Sys.getenv()
[18:04:18.001]                 names <- names(envs)
[18:04:18.001]                 common <- intersect(names, old_names)
[18:04:18.001]                 added <- setdiff(names, old_names)
[18:04:18.001]                 removed <- setdiff(old_names, names)
[18:04:18.001]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.001]                   envs[common]]
[18:04:18.001]                 NAMES <- toupper(changed)
[18:04:18.001]                 args <- list()
[18:04:18.001]                 for (kk in seq_along(NAMES)) {
[18:04:18.001]                   name <- changed[[kk]]
[18:04:18.001]                   NAME <- NAMES[[kk]]
[18:04:18.001]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.001]                     next
[18:04:18.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.001]                 }
[18:04:18.001]                 NAMES <- toupper(added)
[18:04:18.001]                 for (kk in seq_along(NAMES)) {
[18:04:18.001]                   name <- added[[kk]]
[18:04:18.001]                   NAME <- NAMES[[kk]]
[18:04:18.001]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.001]                     next
[18:04:18.001]                   args[[name]] <- ""
[18:04:18.001]                 }
[18:04:18.001]                 NAMES <- toupper(removed)
[18:04:18.001]                 for (kk in seq_along(NAMES)) {
[18:04:18.001]                   name <- removed[[kk]]
[18:04:18.001]                   NAME <- NAMES[[kk]]
[18:04:18.001]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.001]                     next
[18:04:18.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.001]                 }
[18:04:18.001]                 if (length(args) > 0) 
[18:04:18.001]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.001]             }
[18:04:18.001]             else {
[18:04:18.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.001]             }
[18:04:18.001]             {
[18:04:18.001]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.001]                   0L) {
[18:04:18.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.001]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.001]                   base::options(opts)
[18:04:18.001]                 }
[18:04:18.001]                 {
[18:04:18.001]                   {
[18:04:18.001]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.001]                     NULL
[18:04:18.001]                   }
[18:04:18.001]                   options(future.plan = NULL)
[18:04:18.001]                   if (is.na(NA_character_)) 
[18:04:18.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.001]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.001]                     .init = FALSE)
[18:04:18.001]                 }
[18:04:18.001]             }
[18:04:18.001]         }
[18:04:18.001]     })
[18:04:18.001]     if (TRUE) {
[18:04:18.001]         base::sink(type = "output", split = FALSE)
[18:04:18.001]         if (TRUE) {
[18:04:18.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.001]         }
[18:04:18.001]         else {
[18:04:18.001]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.001]         }
[18:04:18.001]         base::close(...future.stdout)
[18:04:18.001]         ...future.stdout <- NULL
[18:04:18.001]     }
[18:04:18.001]     ...future.result$conditions <- ...future.conditions
[18:04:18.001]     ...future.result$finished <- base::Sys.time()
[18:04:18.001]     ...future.result
[18:04:18.001] }
[18:04:18.006] MultisessionFuture started
[18:04:18.007] - Launch lazy future ... done
[18:04:18.007] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2cb56a38> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2cf67fe8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2cb56a38> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2cf67fe8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[18:04:18.018] receiveMessageFromWorker() for ClusterFuture ...
[18:04:18.018] - Validating connection of MultisessionFuture
[18:04:18.018] - received message: FutureResult
[18:04:18.019] - Received FutureResult
[18:04:18.019] - Erased future from FutureRegistry
[18:04:18.019] result() for ClusterFuture ...
[18:04:18.019] - result already collected: FutureResult
[18:04:18.019] result() for ClusterFuture ... done
[18:04:18.020] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:18.036] resolve() on list ...
[18:04:18.036]  recursive: 0
[18:04:18.036]  length: 6
[18:04:18.037]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:18.037] signalConditionsASAP(numeric, pos=1) ...
[18:04:18.037] - nx: 6
[18:04:18.037] - relay: TRUE
[18:04:18.037] - stdout: TRUE
[18:04:18.038] - signal: TRUE
[18:04:18.038] - resignal: FALSE
[18:04:18.038] - force: TRUE
[18:04:18.038] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.038] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.039]  - until=2
[18:04:18.039]  - relaying element #2
[18:04:18.039] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.039] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.039] signalConditionsASAP(NULL, pos=1) ... done
[18:04:18.040]  length: 5 (resolved future 1)
[18:04:18.040] Future #2
[18:04:18.040] result() for ClusterFuture ...
[18:04:18.040] - result already collected: FutureResult
[18:04:18.040] result() for ClusterFuture ... done
[18:04:18.041] result() for ClusterFuture ...
[18:04:18.041] - result already collected: FutureResult
[18:04:18.041] result() for ClusterFuture ... done
[18:04:18.041] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:18.041] - nx: 6
[18:04:18.042] - relay: TRUE
[18:04:18.042] - stdout: TRUE
[18:04:18.042] - signal: TRUE
[18:04:18.042] - resignal: FALSE
[18:04:18.042] - force: TRUE
[18:04:18.042] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.043] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.043]  - until=2
[18:04:18.043]  - relaying element #2
[18:04:18.043] result() for ClusterFuture ...
[18:04:18.043] - result already collected: FutureResult
[18:04:18.044] result() for ClusterFuture ... done
[18:04:18.044] result() for ClusterFuture ...
[18:04:18.044] - result already collected: FutureResult
[18:04:18.044] result() for ClusterFuture ... done
[18:04:18.045] result() for ClusterFuture ...
[18:04:18.045] - result already collected: FutureResult
[18:04:18.045] result() for ClusterFuture ... done
[18:04:18.045] result() for ClusterFuture ...
[18:04:18.045] - result already collected: FutureResult
[18:04:18.045] result() for ClusterFuture ... done
[18:04:18.046] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.046] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.046] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:18.046]  length: 4 (resolved future 2)
[18:04:18.055] receiveMessageFromWorker() for ClusterFuture ...
[18:04:18.055] - Validating connection of MultisessionFuture
[18:04:18.056] - received message: FutureResult
[18:04:18.056] - Received FutureResult
[18:04:18.056] - Erased future from FutureRegistry
[18:04:18.057] result() for ClusterFuture ...
[18:04:18.057] - result already collected: FutureResult
[18:04:18.057] result() for ClusterFuture ... done
[18:04:18.057] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:18.057] Future #3
[18:04:18.058] result() for ClusterFuture ...
[18:04:18.058] - result already collected: FutureResult
[18:04:18.058] result() for ClusterFuture ... done
[18:04:18.058] result() for ClusterFuture ...
[18:04:18.058] - result already collected: FutureResult
[18:04:18.058] result() for ClusterFuture ... done
[18:04:18.059] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:18.059] - nx: 6
[18:04:18.059] - relay: TRUE
[18:04:18.059] - stdout: TRUE
[18:04:18.059] - signal: TRUE
[18:04:18.060] - resignal: FALSE
[18:04:18.060] - force: TRUE
[18:04:18.060] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.060] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.060]  - until=3
[18:04:18.061]  - relaying element #3
[18:04:18.061] result() for ClusterFuture ...
[18:04:18.061] - result already collected: FutureResult
[18:04:18.061] result() for ClusterFuture ... done
[18:04:18.061] result() for ClusterFuture ...
[18:04:18.061] - result already collected: FutureResult
[18:04:18.062] result() for ClusterFuture ... done
[18:04:18.062] result() for ClusterFuture ...
[18:04:18.062] - result already collected: FutureResult
[18:04:18.062] result() for ClusterFuture ... done
[18:04:18.062] result() for ClusterFuture ...
[18:04:18.063] - result already collected: FutureResult
[18:04:18.063] result() for ClusterFuture ... done
[18:04:18.063] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.063] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.063] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:18.064]  length: 3 (resolved future 3)
[18:04:18.064] signalConditionsASAP(NULL, pos=4) ...
[18:04:18.064] - nx: 6
[18:04:18.064] - relay: TRUE
[18:04:18.064] - stdout: TRUE
[18:04:18.065] - signal: TRUE
[18:04:18.065] - resignal: FALSE
[18:04:18.065] - force: TRUE
[18:04:18.065] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.065] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.065]  - until=5
[18:04:18.066]  - relaying element #5
[18:04:18.066] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:18.066] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.066] signalConditionsASAP(NULL, pos=4) ... done
[18:04:18.066]  length: 2 (resolved future 4)
[18:04:18.067] signalConditionsASAP(NULL, pos=5) ...
[18:04:18.067] - nx: 6
[18:04:18.067] - relay: TRUE
[18:04:18.067] - stdout: TRUE
[18:04:18.067] - signal: TRUE
[18:04:18.067] - resignal: FALSE
[18:04:18.068] - force: TRUE
[18:04:18.068] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:18.068] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.068]  - until=6
[18:04:18.068]  - relaying element #6
[18:04:18.069] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:18.069] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.069] signalConditionsASAP(NULL, pos=5) ... done
[18:04:18.069]  length: 1 (resolved future 5)
[18:04:18.069] signalConditionsASAP(numeric, pos=6) ...
[18:04:18.069] - nx: 6
[18:04:18.070] - relay: TRUE
[18:04:18.070] - stdout: TRUE
[18:04:18.070] - signal: TRUE
[18:04:18.070] - resignal: FALSE
[18:04:18.070] - force: TRUE
[18:04:18.070] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:18.071] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.071]  - until=6
[18:04:18.071] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:18.071] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.071] signalConditionsASAP(numeric, pos=6) ... done
[18:04:18.072]  length: 0 (resolved future 6)
[18:04:18.072] Relaying remaining futures
[18:04:18.072] signalConditionsASAP(NULL, pos=0) ...
[18:04:18.072] - nx: 6
[18:04:18.072] - relay: TRUE
[18:04:18.073] - stdout: TRUE
[18:04:18.073] - signal: TRUE
[18:04:18.073] - resignal: FALSE
[18:04:18.073] - force: TRUE
[18:04:18.073] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:18.073] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:18.074] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:18.074] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.074] signalConditionsASAP(NULL, pos=0) ... done
[18:04:18.074] resolve() on list ... DONE
[18:04:18.075] result() for ClusterFuture ...
[18:04:18.075] - result already collected: FutureResult
[18:04:18.075] result() for ClusterFuture ... done
[18:04:18.075] result() for ClusterFuture ...
[18:04:18.075] - result already collected: FutureResult
[18:04:18.075] result() for ClusterFuture ... done
[18:04:18.076] result() for ClusterFuture ...
[18:04:18.076] - result already collected: FutureResult
[18:04:18.076] result() for ClusterFuture ... done
[18:04:18.076] result() for ClusterFuture ...
[18:04:18.076] - result already collected: FutureResult
[18:04:18.077] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[18:04:18.083] getGlobalsAndPackages() ...
[18:04:18.084] Searching for globals...
[18:04:18.084] 
[18:04:18.085] Searching for globals ... DONE
[18:04:18.085] - globals: [0] <none>
[18:04:18.085] getGlobalsAndPackages() ... DONE
[18:04:18.085] run() for ‘Future’ ...
[18:04:18.086] - state: ‘created’
[18:04:18.086] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.109] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:18.110]   - Field: ‘node’
[18:04:18.110]   - Field: ‘label’
[18:04:18.110]   - Field: ‘local’
[18:04:18.111]   - Field: ‘owner’
[18:04:18.111]   - Field: ‘envir’
[18:04:18.111]   - Field: ‘workers’
[18:04:18.111]   - Field: ‘packages’
[18:04:18.111]   - Field: ‘gc’
[18:04:18.112]   - Field: ‘conditions’
[18:04:18.112]   - Field: ‘persistent’
[18:04:18.112]   - Field: ‘expr’
[18:04:18.112]   - Field: ‘uuid’
[18:04:18.112]   - Field: ‘seed’
[18:04:18.113]   - Field: ‘version’
[18:04:18.113]   - Field: ‘result’
[18:04:18.113]   - Field: ‘asynchronous’
[18:04:18.113]   - Field: ‘calls’
[18:04:18.113]   - Field: ‘globals’
[18:04:18.114]   - Field: ‘stdout’
[18:04:18.114]   - Field: ‘earlySignal’
[18:04:18.114]   - Field: ‘lazy’
[18:04:18.114]   - Field: ‘state’
[18:04:18.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:18.115] - Launch lazy future ...
[18:04:18.115] Packages needed by the future expression (n = 0): <none>
[18:04:18.115] Packages needed by future strategies (n = 0): <none>
[18:04:18.116] {
[18:04:18.116]     {
[18:04:18.116]         {
[18:04:18.116]             ...future.startTime <- base::Sys.time()
[18:04:18.116]             {
[18:04:18.116]                 {
[18:04:18.116]                   {
[18:04:18.116]                     {
[18:04:18.116]                       base::local({
[18:04:18.116]                         has_future <- base::requireNamespace("future", 
[18:04:18.116]                           quietly = TRUE)
[18:04:18.116]                         if (has_future) {
[18:04:18.116]                           ns <- base::getNamespace("future")
[18:04:18.116]                           version <- ns[[".package"]][["version"]]
[18:04:18.116]                           if (is.null(version)) 
[18:04:18.116]                             version <- utils::packageVersion("future")
[18:04:18.116]                         }
[18:04:18.116]                         else {
[18:04:18.116]                           version <- NULL
[18:04:18.116]                         }
[18:04:18.116]                         if (!has_future || version < "1.8.0") {
[18:04:18.116]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.116]                             "", base::R.version$version.string), 
[18:04:18.116]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.116]                               "release", "version")], collapse = " "), 
[18:04:18.116]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.116]                             info)
[18:04:18.116]                           info <- base::paste(info, collapse = "; ")
[18:04:18.116]                           if (!has_future) {
[18:04:18.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.116]                               info)
[18:04:18.116]                           }
[18:04:18.116]                           else {
[18:04:18.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.116]                               info, version)
[18:04:18.116]                           }
[18:04:18.116]                           base::stop(msg)
[18:04:18.116]                         }
[18:04:18.116]                       })
[18:04:18.116]                     }
[18:04:18.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.116]                     base::options(mc.cores = 1L)
[18:04:18.116]                   }
[18:04:18.116]                   ...future.strategy.old <- future::plan("list")
[18:04:18.116]                   options(future.plan = NULL)
[18:04:18.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.116]                 }
[18:04:18.116]                 ...future.workdir <- getwd()
[18:04:18.116]             }
[18:04:18.116]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.116]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.116]         }
[18:04:18.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.116]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.116]             base::names(...future.oldOptions))
[18:04:18.116]     }
[18:04:18.116]     if (FALSE) {
[18:04:18.116]     }
[18:04:18.116]     else {
[18:04:18.116]         if (TRUE) {
[18:04:18.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.116]                 open = "w")
[18:04:18.116]         }
[18:04:18.116]         else {
[18:04:18.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.116]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.116]         }
[18:04:18.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.116]             base::sink(type = "output", split = FALSE)
[18:04:18.116]             base::close(...future.stdout)
[18:04:18.116]         }, add = TRUE)
[18:04:18.116]     }
[18:04:18.116]     ...future.frame <- base::sys.nframe()
[18:04:18.116]     ...future.conditions <- base::list()
[18:04:18.116]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.116]     if (FALSE) {
[18:04:18.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.116]     }
[18:04:18.116]     ...future.result <- base::tryCatch({
[18:04:18.116]         base::withCallingHandlers({
[18:04:18.116]             ...future.value <- base::withVisible(base::local({
[18:04:18.116]                 ...future.makeSendCondition <- base::local({
[18:04:18.116]                   sendCondition <- NULL
[18:04:18.116]                   function(frame = 1L) {
[18:04:18.116]                     if (is.function(sendCondition)) 
[18:04:18.116]                       return(sendCondition)
[18:04:18.116]                     ns <- getNamespace("parallel")
[18:04:18.116]                     if (exists("sendData", mode = "function", 
[18:04:18.116]                       envir = ns)) {
[18:04:18.116]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:18.116]                         envir = ns)
[18:04:18.116]                       envir <- sys.frame(frame)
[18:04:18.116]                       master <- NULL
[18:04:18.116]                       while (!identical(envir, .GlobalEnv) && 
[18:04:18.116]                         !identical(envir, emptyenv())) {
[18:04:18.116]                         if (exists("master", mode = "list", envir = envir, 
[18:04:18.116]                           inherits = FALSE)) {
[18:04:18.116]                           master <- get("master", mode = "list", 
[18:04:18.116]                             envir = envir, inherits = FALSE)
[18:04:18.116]                           if (inherits(master, c("SOCKnode", 
[18:04:18.116]                             "SOCK0node"))) {
[18:04:18.116]                             sendCondition <<- function(cond) {
[18:04:18.116]                               data <- list(type = "VALUE", value = cond, 
[18:04:18.116]                                 success = TRUE)
[18:04:18.116]                               parallel_sendData(master, data)
[18:04:18.116]                             }
[18:04:18.116]                             return(sendCondition)
[18:04:18.116]                           }
[18:04:18.116]                         }
[18:04:18.116]                         frame <- frame + 1L
[18:04:18.116]                         envir <- sys.frame(frame)
[18:04:18.116]                       }
[18:04:18.116]                     }
[18:04:18.116]                     sendCondition <<- function(cond) NULL
[18:04:18.116]                   }
[18:04:18.116]                 })
[18:04:18.116]                 withCallingHandlers({
[18:04:18.116]                   2
[18:04:18.116]                 }, immediateCondition = function(cond) {
[18:04:18.116]                   sendCondition <- ...future.makeSendCondition()
[18:04:18.116]                   sendCondition(cond)
[18:04:18.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.116]                   {
[18:04:18.116]                     inherits <- base::inherits
[18:04:18.116]                     invokeRestart <- base::invokeRestart
[18:04:18.116]                     is.null <- base::is.null
[18:04:18.116]                     muffled <- FALSE
[18:04:18.116]                     if (inherits(cond, "message")) {
[18:04:18.116]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.116]                       if (muffled) 
[18:04:18.116]                         invokeRestart("muffleMessage")
[18:04:18.116]                     }
[18:04:18.116]                     else if (inherits(cond, "warning")) {
[18:04:18.116]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.116]                       if (muffled) 
[18:04:18.116]                         invokeRestart("muffleWarning")
[18:04:18.116]                     }
[18:04:18.116]                     else if (inherits(cond, "condition")) {
[18:04:18.116]                       if (!is.null(pattern)) {
[18:04:18.116]                         computeRestarts <- base::computeRestarts
[18:04:18.116]                         grepl <- base::grepl
[18:04:18.116]                         restarts <- computeRestarts(cond)
[18:04:18.116]                         for (restart in restarts) {
[18:04:18.116]                           name <- restart$name
[18:04:18.116]                           if (is.null(name)) 
[18:04:18.116]                             next
[18:04:18.116]                           if (!grepl(pattern, name)) 
[18:04:18.116]                             next
[18:04:18.116]                           invokeRestart(restart)
[18:04:18.116]                           muffled <- TRUE
[18:04:18.116]                           break
[18:04:18.116]                         }
[18:04:18.116]                       }
[18:04:18.116]                     }
[18:04:18.116]                     invisible(muffled)
[18:04:18.116]                   }
[18:04:18.116]                   muffleCondition(cond)
[18:04:18.116]                 })
[18:04:18.116]             }))
[18:04:18.116]             future::FutureResult(value = ...future.value$value, 
[18:04:18.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.116]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.116]                     ...future.globalenv.names))
[18:04:18.116]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.116]         }, condition = base::local({
[18:04:18.116]             c <- base::c
[18:04:18.116]             inherits <- base::inherits
[18:04:18.116]             invokeRestart <- base::invokeRestart
[18:04:18.116]             length <- base::length
[18:04:18.116]             list <- base::list
[18:04:18.116]             seq.int <- base::seq.int
[18:04:18.116]             signalCondition <- base::signalCondition
[18:04:18.116]             sys.calls <- base::sys.calls
[18:04:18.116]             `[[` <- base::`[[`
[18:04:18.116]             `+` <- base::`+`
[18:04:18.116]             `<<-` <- base::`<<-`
[18:04:18.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.116]                   3L)]
[18:04:18.116]             }
[18:04:18.116]             function(cond) {
[18:04:18.116]                 is_error <- inherits(cond, "error")
[18:04:18.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.116]                   NULL)
[18:04:18.116]                 if (is_error) {
[18:04:18.116]                   sessionInformation <- function() {
[18:04:18.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.116]                       search = base::search(), system = base::Sys.info())
[18:04:18.116]                   }
[18:04:18.116]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.116]                     cond$call), session = sessionInformation(), 
[18:04:18.116]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.116]                   signalCondition(cond)
[18:04:18.116]                 }
[18:04:18.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.116]                 "immediateCondition"))) {
[18:04:18.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.116]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.116]                   if (TRUE && !signal) {
[18:04:18.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.116]                     {
[18:04:18.116]                       inherits <- base::inherits
[18:04:18.116]                       invokeRestart <- base::invokeRestart
[18:04:18.116]                       is.null <- base::is.null
[18:04:18.116]                       muffled <- FALSE
[18:04:18.116]                       if (inherits(cond, "message")) {
[18:04:18.116]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.116]                         if (muffled) 
[18:04:18.116]                           invokeRestart("muffleMessage")
[18:04:18.116]                       }
[18:04:18.116]                       else if (inherits(cond, "warning")) {
[18:04:18.116]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.116]                         if (muffled) 
[18:04:18.116]                           invokeRestart("muffleWarning")
[18:04:18.116]                       }
[18:04:18.116]                       else if (inherits(cond, "condition")) {
[18:04:18.116]                         if (!is.null(pattern)) {
[18:04:18.116]                           computeRestarts <- base::computeRestarts
[18:04:18.116]                           grepl <- base::grepl
[18:04:18.116]                           restarts <- computeRestarts(cond)
[18:04:18.116]                           for (restart in restarts) {
[18:04:18.116]                             name <- restart$name
[18:04:18.116]                             if (is.null(name)) 
[18:04:18.116]                               next
[18:04:18.116]                             if (!grepl(pattern, name)) 
[18:04:18.116]                               next
[18:04:18.116]                             invokeRestart(restart)
[18:04:18.116]                             muffled <- TRUE
[18:04:18.116]                             break
[18:04:18.116]                           }
[18:04:18.116]                         }
[18:04:18.116]                       }
[18:04:18.116]                       invisible(muffled)
[18:04:18.116]                     }
[18:04:18.116]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.116]                   }
[18:04:18.116]                 }
[18:04:18.116]                 else {
[18:04:18.116]                   if (TRUE) {
[18:04:18.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.116]                     {
[18:04:18.116]                       inherits <- base::inherits
[18:04:18.116]                       invokeRestart <- base::invokeRestart
[18:04:18.116]                       is.null <- base::is.null
[18:04:18.116]                       muffled <- FALSE
[18:04:18.116]                       if (inherits(cond, "message")) {
[18:04:18.116]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.116]                         if (muffled) 
[18:04:18.116]                           invokeRestart("muffleMessage")
[18:04:18.116]                       }
[18:04:18.116]                       else if (inherits(cond, "warning")) {
[18:04:18.116]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.116]                         if (muffled) 
[18:04:18.116]                           invokeRestart("muffleWarning")
[18:04:18.116]                       }
[18:04:18.116]                       else if (inherits(cond, "condition")) {
[18:04:18.116]                         if (!is.null(pattern)) {
[18:04:18.116]                           computeRestarts <- base::computeRestarts
[18:04:18.116]                           grepl <- base::grepl
[18:04:18.116]                           restarts <- computeRestarts(cond)
[18:04:18.116]                           for (restart in restarts) {
[18:04:18.116]                             name <- restart$name
[18:04:18.116]                             if (is.null(name)) 
[18:04:18.116]                               next
[18:04:18.116]                             if (!grepl(pattern, name)) 
[18:04:18.116]                               next
[18:04:18.116]                             invokeRestart(restart)
[18:04:18.116]                             muffled <- TRUE
[18:04:18.116]                             break
[18:04:18.116]                           }
[18:04:18.116]                         }
[18:04:18.116]                       }
[18:04:18.116]                       invisible(muffled)
[18:04:18.116]                     }
[18:04:18.116]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.116]                   }
[18:04:18.116]                 }
[18:04:18.116]             }
[18:04:18.116]         }))
[18:04:18.116]     }, error = function(ex) {
[18:04:18.116]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.116]                 ...future.rng), started = ...future.startTime, 
[18:04:18.116]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.116]             version = "1.8"), class = "FutureResult")
[18:04:18.116]     }, finally = {
[18:04:18.116]         if (!identical(...future.workdir, getwd())) 
[18:04:18.116]             setwd(...future.workdir)
[18:04:18.116]         {
[18:04:18.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.116]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.116]             }
[18:04:18.116]             base::options(...future.oldOptions)
[18:04:18.116]             if (.Platform$OS.type == "windows") {
[18:04:18.116]                 old_names <- names(...future.oldEnvVars)
[18:04:18.116]                 envs <- base::Sys.getenv()
[18:04:18.116]                 names <- names(envs)
[18:04:18.116]                 common <- intersect(names, old_names)
[18:04:18.116]                 added <- setdiff(names, old_names)
[18:04:18.116]                 removed <- setdiff(old_names, names)
[18:04:18.116]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.116]                   envs[common]]
[18:04:18.116]                 NAMES <- toupper(changed)
[18:04:18.116]                 args <- list()
[18:04:18.116]                 for (kk in seq_along(NAMES)) {
[18:04:18.116]                   name <- changed[[kk]]
[18:04:18.116]                   NAME <- NAMES[[kk]]
[18:04:18.116]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.116]                     next
[18:04:18.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.116]                 }
[18:04:18.116]                 NAMES <- toupper(added)
[18:04:18.116]                 for (kk in seq_along(NAMES)) {
[18:04:18.116]                   name <- added[[kk]]
[18:04:18.116]                   NAME <- NAMES[[kk]]
[18:04:18.116]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.116]                     next
[18:04:18.116]                   args[[name]] <- ""
[18:04:18.116]                 }
[18:04:18.116]                 NAMES <- toupper(removed)
[18:04:18.116]                 for (kk in seq_along(NAMES)) {
[18:04:18.116]                   name <- removed[[kk]]
[18:04:18.116]                   NAME <- NAMES[[kk]]
[18:04:18.116]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.116]                     next
[18:04:18.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.116]                 }
[18:04:18.116]                 if (length(args) > 0) 
[18:04:18.116]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.116]             }
[18:04:18.116]             else {
[18:04:18.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.116]             }
[18:04:18.116]             {
[18:04:18.116]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.116]                   0L) {
[18:04:18.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.116]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.116]                   base::options(opts)
[18:04:18.116]                 }
[18:04:18.116]                 {
[18:04:18.116]                   {
[18:04:18.116]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.116]                     NULL
[18:04:18.116]                   }
[18:04:18.116]                   options(future.plan = NULL)
[18:04:18.116]                   if (is.na(NA_character_)) 
[18:04:18.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.116]                     .init = FALSE)
[18:04:18.116]                 }
[18:04:18.116]             }
[18:04:18.116]         }
[18:04:18.116]     })
[18:04:18.116]     if (TRUE) {
[18:04:18.116]         base::sink(type = "output", split = FALSE)
[18:04:18.116]         if (TRUE) {
[18:04:18.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.116]         }
[18:04:18.116]         else {
[18:04:18.116]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.116]         }
[18:04:18.116]         base::close(...future.stdout)
[18:04:18.116]         ...future.stdout <- NULL
[18:04:18.116]     }
[18:04:18.116]     ...future.result$conditions <- ...future.conditions
[18:04:18.116]     ...future.result$finished <- base::Sys.time()
[18:04:18.116]     ...future.result
[18:04:18.116] }
[18:04:18.122] MultisessionFuture started
[18:04:18.122] - Launch lazy future ... done
[18:04:18.122] run() for ‘MultisessionFuture’ ... done
[18:04:18.123] getGlobalsAndPackages() ...
[18:04:18.124] Searching for globals...
[18:04:18.124] 
[18:04:18.125] Searching for globals ... DONE
[18:04:18.125] - globals: [0] <none>
[18:04:18.125] getGlobalsAndPackages() ... DONE
[18:04:18.125] run() for ‘Future’ ...
[18:04:18.126] - state: ‘created’
[18:04:18.126] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.151] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.151] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:18.151]   - Field: ‘node’
[18:04:18.152]   - Field: ‘label’
[18:04:18.152]   - Field: ‘local’
[18:04:18.152]   - Field: ‘owner’
[18:04:18.152]   - Field: ‘envir’
[18:04:18.152]   - Field: ‘workers’
[18:04:18.153]   - Field: ‘packages’
[18:04:18.153]   - Field: ‘gc’
[18:04:18.153]   - Field: ‘conditions’
[18:04:18.153]   - Field: ‘persistent’
[18:04:18.153]   - Field: ‘expr’
[18:04:18.154]   - Field: ‘uuid’
[18:04:18.154]   - Field: ‘seed’
[18:04:18.154]   - Field: ‘version’
[18:04:18.154]   - Field: ‘result’
[18:04:18.154]   - Field: ‘asynchronous’
[18:04:18.155]   - Field: ‘calls’
[18:04:18.155]   - Field: ‘globals’
[18:04:18.155]   - Field: ‘stdout’
[18:04:18.155]   - Field: ‘earlySignal’
[18:04:18.155]   - Field: ‘lazy’
[18:04:18.156]   - Field: ‘state’
[18:04:18.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:18.156] - Launch lazy future ...
[18:04:18.157] Packages needed by the future expression (n = 0): <none>
[18:04:18.157] Packages needed by future strategies (n = 0): <none>
[18:04:18.158] {
[18:04:18.158]     {
[18:04:18.158]         {
[18:04:18.158]             ...future.startTime <- base::Sys.time()
[18:04:18.158]             {
[18:04:18.158]                 {
[18:04:18.158]                   {
[18:04:18.158]                     {
[18:04:18.158]                       base::local({
[18:04:18.158]                         has_future <- base::requireNamespace("future", 
[18:04:18.158]                           quietly = TRUE)
[18:04:18.158]                         if (has_future) {
[18:04:18.158]                           ns <- base::getNamespace("future")
[18:04:18.158]                           version <- ns[[".package"]][["version"]]
[18:04:18.158]                           if (is.null(version)) 
[18:04:18.158]                             version <- utils::packageVersion("future")
[18:04:18.158]                         }
[18:04:18.158]                         else {
[18:04:18.158]                           version <- NULL
[18:04:18.158]                         }
[18:04:18.158]                         if (!has_future || version < "1.8.0") {
[18:04:18.158]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.158]                             "", base::R.version$version.string), 
[18:04:18.158]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.158]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.158]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.158]                               "release", "version")], collapse = " "), 
[18:04:18.158]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.158]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.158]                             info)
[18:04:18.158]                           info <- base::paste(info, collapse = "; ")
[18:04:18.158]                           if (!has_future) {
[18:04:18.158]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.158]                               info)
[18:04:18.158]                           }
[18:04:18.158]                           else {
[18:04:18.158]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.158]                               info, version)
[18:04:18.158]                           }
[18:04:18.158]                           base::stop(msg)
[18:04:18.158]                         }
[18:04:18.158]                       })
[18:04:18.158]                     }
[18:04:18.158]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.158]                     base::options(mc.cores = 1L)
[18:04:18.158]                   }
[18:04:18.158]                   ...future.strategy.old <- future::plan("list")
[18:04:18.158]                   options(future.plan = NULL)
[18:04:18.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.158]                 }
[18:04:18.158]                 ...future.workdir <- getwd()
[18:04:18.158]             }
[18:04:18.158]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.158]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.158]         }
[18:04:18.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.158]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.158]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.158]             base::names(...future.oldOptions))
[18:04:18.158]     }
[18:04:18.158]     if (FALSE) {
[18:04:18.158]     }
[18:04:18.158]     else {
[18:04:18.158]         if (TRUE) {
[18:04:18.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.158]                 open = "w")
[18:04:18.158]         }
[18:04:18.158]         else {
[18:04:18.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.158]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.158]         }
[18:04:18.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.158]             base::sink(type = "output", split = FALSE)
[18:04:18.158]             base::close(...future.stdout)
[18:04:18.158]         }, add = TRUE)
[18:04:18.158]     }
[18:04:18.158]     ...future.frame <- base::sys.nframe()
[18:04:18.158]     ...future.conditions <- base::list()
[18:04:18.158]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.158]     if (FALSE) {
[18:04:18.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.158]     }
[18:04:18.158]     ...future.result <- base::tryCatch({
[18:04:18.158]         base::withCallingHandlers({
[18:04:18.158]             ...future.value <- base::withVisible(base::local({
[18:04:18.158]                 ...future.makeSendCondition <- base::local({
[18:04:18.158]                   sendCondition <- NULL
[18:04:18.158]                   function(frame = 1L) {
[18:04:18.158]                     if (is.function(sendCondition)) 
[18:04:18.158]                       return(sendCondition)
[18:04:18.158]                     ns <- getNamespace("parallel")
[18:04:18.158]                     if (exists("sendData", mode = "function", 
[18:04:18.158]                       envir = ns)) {
[18:04:18.158]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:18.158]                         envir = ns)
[18:04:18.158]                       envir <- sys.frame(frame)
[18:04:18.158]                       master <- NULL
[18:04:18.158]                       while (!identical(envir, .GlobalEnv) && 
[18:04:18.158]                         !identical(envir, emptyenv())) {
[18:04:18.158]                         if (exists("master", mode = "list", envir = envir, 
[18:04:18.158]                           inherits = FALSE)) {
[18:04:18.158]                           master <- get("master", mode = "list", 
[18:04:18.158]                             envir = envir, inherits = FALSE)
[18:04:18.158]                           if (inherits(master, c("SOCKnode", 
[18:04:18.158]                             "SOCK0node"))) {
[18:04:18.158]                             sendCondition <<- function(cond) {
[18:04:18.158]                               data <- list(type = "VALUE", value = cond, 
[18:04:18.158]                                 success = TRUE)
[18:04:18.158]                               parallel_sendData(master, data)
[18:04:18.158]                             }
[18:04:18.158]                             return(sendCondition)
[18:04:18.158]                           }
[18:04:18.158]                         }
[18:04:18.158]                         frame <- frame + 1L
[18:04:18.158]                         envir <- sys.frame(frame)
[18:04:18.158]                       }
[18:04:18.158]                     }
[18:04:18.158]                     sendCondition <<- function(cond) NULL
[18:04:18.158]                   }
[18:04:18.158]                 })
[18:04:18.158]                 withCallingHandlers({
[18:04:18.158]                   NULL
[18:04:18.158]                 }, immediateCondition = function(cond) {
[18:04:18.158]                   sendCondition <- ...future.makeSendCondition()
[18:04:18.158]                   sendCondition(cond)
[18:04:18.158]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.158]                   {
[18:04:18.158]                     inherits <- base::inherits
[18:04:18.158]                     invokeRestart <- base::invokeRestart
[18:04:18.158]                     is.null <- base::is.null
[18:04:18.158]                     muffled <- FALSE
[18:04:18.158]                     if (inherits(cond, "message")) {
[18:04:18.158]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.158]                       if (muffled) 
[18:04:18.158]                         invokeRestart("muffleMessage")
[18:04:18.158]                     }
[18:04:18.158]                     else if (inherits(cond, "warning")) {
[18:04:18.158]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.158]                       if (muffled) 
[18:04:18.158]                         invokeRestart("muffleWarning")
[18:04:18.158]                     }
[18:04:18.158]                     else if (inherits(cond, "condition")) {
[18:04:18.158]                       if (!is.null(pattern)) {
[18:04:18.158]                         computeRestarts <- base::computeRestarts
[18:04:18.158]                         grepl <- base::grepl
[18:04:18.158]                         restarts <- computeRestarts(cond)
[18:04:18.158]                         for (restart in restarts) {
[18:04:18.158]                           name <- restart$name
[18:04:18.158]                           if (is.null(name)) 
[18:04:18.158]                             next
[18:04:18.158]                           if (!grepl(pattern, name)) 
[18:04:18.158]                             next
[18:04:18.158]                           invokeRestart(restart)
[18:04:18.158]                           muffled <- TRUE
[18:04:18.158]                           break
[18:04:18.158]                         }
[18:04:18.158]                       }
[18:04:18.158]                     }
[18:04:18.158]                     invisible(muffled)
[18:04:18.158]                   }
[18:04:18.158]                   muffleCondition(cond)
[18:04:18.158]                 })
[18:04:18.158]             }))
[18:04:18.158]             future::FutureResult(value = ...future.value$value, 
[18:04:18.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.158]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.158]                     ...future.globalenv.names))
[18:04:18.158]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.158]         }, condition = base::local({
[18:04:18.158]             c <- base::c
[18:04:18.158]             inherits <- base::inherits
[18:04:18.158]             invokeRestart <- base::invokeRestart
[18:04:18.158]             length <- base::length
[18:04:18.158]             list <- base::list
[18:04:18.158]             seq.int <- base::seq.int
[18:04:18.158]             signalCondition <- base::signalCondition
[18:04:18.158]             sys.calls <- base::sys.calls
[18:04:18.158]             `[[` <- base::`[[`
[18:04:18.158]             `+` <- base::`+`
[18:04:18.158]             `<<-` <- base::`<<-`
[18:04:18.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.158]                   3L)]
[18:04:18.158]             }
[18:04:18.158]             function(cond) {
[18:04:18.158]                 is_error <- inherits(cond, "error")
[18:04:18.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.158]                   NULL)
[18:04:18.158]                 if (is_error) {
[18:04:18.158]                   sessionInformation <- function() {
[18:04:18.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.158]                       search = base::search(), system = base::Sys.info())
[18:04:18.158]                   }
[18:04:18.158]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.158]                     cond$call), session = sessionInformation(), 
[18:04:18.158]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.158]                   signalCondition(cond)
[18:04:18.158]                 }
[18:04:18.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.158]                 "immediateCondition"))) {
[18:04:18.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.158]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.158]                   if (TRUE && !signal) {
[18:04:18.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.158]                     {
[18:04:18.158]                       inherits <- base::inherits
[18:04:18.158]                       invokeRestart <- base::invokeRestart
[18:04:18.158]                       is.null <- base::is.null
[18:04:18.158]                       muffled <- FALSE
[18:04:18.158]                       if (inherits(cond, "message")) {
[18:04:18.158]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.158]                         if (muffled) 
[18:04:18.158]                           invokeRestart("muffleMessage")
[18:04:18.158]                       }
[18:04:18.158]                       else if (inherits(cond, "warning")) {
[18:04:18.158]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.158]                         if (muffled) 
[18:04:18.158]                           invokeRestart("muffleWarning")
[18:04:18.158]                       }
[18:04:18.158]                       else if (inherits(cond, "condition")) {
[18:04:18.158]                         if (!is.null(pattern)) {
[18:04:18.158]                           computeRestarts <- base::computeRestarts
[18:04:18.158]                           grepl <- base::grepl
[18:04:18.158]                           restarts <- computeRestarts(cond)
[18:04:18.158]                           for (restart in restarts) {
[18:04:18.158]                             name <- restart$name
[18:04:18.158]                             if (is.null(name)) 
[18:04:18.158]                               next
[18:04:18.158]                             if (!grepl(pattern, name)) 
[18:04:18.158]                               next
[18:04:18.158]                             invokeRestart(restart)
[18:04:18.158]                             muffled <- TRUE
[18:04:18.158]                             break
[18:04:18.158]                           }
[18:04:18.158]                         }
[18:04:18.158]                       }
[18:04:18.158]                       invisible(muffled)
[18:04:18.158]                     }
[18:04:18.158]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.158]                   }
[18:04:18.158]                 }
[18:04:18.158]                 else {
[18:04:18.158]                   if (TRUE) {
[18:04:18.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.158]                     {
[18:04:18.158]                       inherits <- base::inherits
[18:04:18.158]                       invokeRestart <- base::invokeRestart
[18:04:18.158]                       is.null <- base::is.null
[18:04:18.158]                       muffled <- FALSE
[18:04:18.158]                       if (inherits(cond, "message")) {
[18:04:18.158]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.158]                         if (muffled) 
[18:04:18.158]                           invokeRestart("muffleMessage")
[18:04:18.158]                       }
[18:04:18.158]                       else if (inherits(cond, "warning")) {
[18:04:18.158]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.158]                         if (muffled) 
[18:04:18.158]                           invokeRestart("muffleWarning")
[18:04:18.158]                       }
[18:04:18.158]                       else if (inherits(cond, "condition")) {
[18:04:18.158]                         if (!is.null(pattern)) {
[18:04:18.158]                           computeRestarts <- base::computeRestarts
[18:04:18.158]                           grepl <- base::grepl
[18:04:18.158]                           restarts <- computeRestarts(cond)
[18:04:18.158]                           for (restart in restarts) {
[18:04:18.158]                             name <- restart$name
[18:04:18.158]                             if (is.null(name)) 
[18:04:18.158]                               next
[18:04:18.158]                             if (!grepl(pattern, name)) 
[18:04:18.158]                               next
[18:04:18.158]                             invokeRestart(restart)
[18:04:18.158]                             muffled <- TRUE
[18:04:18.158]                             break
[18:04:18.158]                           }
[18:04:18.158]                         }
[18:04:18.158]                       }
[18:04:18.158]                       invisible(muffled)
[18:04:18.158]                     }
[18:04:18.158]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.158]                   }
[18:04:18.158]                 }
[18:04:18.158]             }
[18:04:18.158]         }))
[18:04:18.158]     }, error = function(ex) {
[18:04:18.158]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.158]                 ...future.rng), started = ...future.startTime, 
[18:04:18.158]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.158]             version = "1.8"), class = "FutureResult")
[18:04:18.158]     }, finally = {
[18:04:18.158]         if (!identical(...future.workdir, getwd())) 
[18:04:18.158]             setwd(...future.workdir)
[18:04:18.158]         {
[18:04:18.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.158]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.158]             }
[18:04:18.158]             base::options(...future.oldOptions)
[18:04:18.158]             if (.Platform$OS.type == "windows") {
[18:04:18.158]                 old_names <- names(...future.oldEnvVars)
[18:04:18.158]                 envs <- base::Sys.getenv()
[18:04:18.158]                 names <- names(envs)
[18:04:18.158]                 common <- intersect(names, old_names)
[18:04:18.158]                 added <- setdiff(names, old_names)
[18:04:18.158]                 removed <- setdiff(old_names, names)
[18:04:18.158]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.158]                   envs[common]]
[18:04:18.158]                 NAMES <- toupper(changed)
[18:04:18.158]                 args <- list()
[18:04:18.158]                 for (kk in seq_along(NAMES)) {
[18:04:18.158]                   name <- changed[[kk]]
[18:04:18.158]                   NAME <- NAMES[[kk]]
[18:04:18.158]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.158]                     next
[18:04:18.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.158]                 }
[18:04:18.158]                 NAMES <- toupper(added)
[18:04:18.158]                 for (kk in seq_along(NAMES)) {
[18:04:18.158]                   name <- added[[kk]]
[18:04:18.158]                   NAME <- NAMES[[kk]]
[18:04:18.158]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.158]                     next
[18:04:18.158]                   args[[name]] <- ""
[18:04:18.158]                 }
[18:04:18.158]                 NAMES <- toupper(removed)
[18:04:18.158]                 for (kk in seq_along(NAMES)) {
[18:04:18.158]                   name <- removed[[kk]]
[18:04:18.158]                   NAME <- NAMES[[kk]]
[18:04:18.158]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.158]                     next
[18:04:18.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.158]                 }
[18:04:18.158]                 if (length(args) > 0) 
[18:04:18.158]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.158]             }
[18:04:18.158]             else {
[18:04:18.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.158]             }
[18:04:18.158]             {
[18:04:18.158]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.158]                   0L) {
[18:04:18.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.158]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.158]                   base::options(opts)
[18:04:18.158]                 }
[18:04:18.158]                 {
[18:04:18.158]                   {
[18:04:18.158]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.158]                     NULL
[18:04:18.158]                   }
[18:04:18.158]                   options(future.plan = NULL)
[18:04:18.158]                   if (is.na(NA_character_)) 
[18:04:18.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.158]                     .init = FALSE)
[18:04:18.158]                 }
[18:04:18.158]             }
[18:04:18.158]         }
[18:04:18.158]     })
[18:04:18.158]     if (TRUE) {
[18:04:18.158]         base::sink(type = "output", split = FALSE)
[18:04:18.158]         if (TRUE) {
[18:04:18.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.158]         }
[18:04:18.158]         else {
[18:04:18.158]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.158]         }
[18:04:18.158]         base::close(...future.stdout)
[18:04:18.158]         ...future.stdout <- NULL
[18:04:18.158]     }
[18:04:18.158]     ...future.result$conditions <- ...future.conditions
[18:04:18.158]     ...future.result$finished <- base::Sys.time()
[18:04:18.158]     ...future.result
[18:04:18.158] }
[18:04:18.163] MultisessionFuture started
[18:04:18.163] - Launch lazy future ... done
[18:04:18.164] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c29c38600> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2bff68b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c29c38600> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2bff68b0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[18:04:18.175] receiveMessageFromWorker() for ClusterFuture ...
[18:04:18.175] - Validating connection of MultisessionFuture
[18:04:18.176] - received message: FutureResult
[18:04:18.176] - Received FutureResult
[18:04:18.176] - Erased future from FutureRegistry
[18:04:18.176] result() for ClusterFuture ...
[18:04:18.177] - result already collected: FutureResult
[18:04:18.177] result() for ClusterFuture ... done
[18:04:18.177] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:18.191] resolve() on list ...
[18:04:18.191]  recursive: 0
[18:04:18.192]  length: 6
[18:04:18.192]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:18.192] signalConditionsASAP(numeric, pos=1) ...
[18:04:18.192] - nx: 6
[18:04:18.192] - relay: TRUE
[18:04:18.193] - stdout: TRUE
[18:04:18.193] - signal: TRUE
[18:04:18.193] - resignal: FALSE
[18:04:18.193] - force: TRUE
[18:04:18.193] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.193] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.194]  - until=2
[18:04:18.194]  - relaying element #2
[18:04:18.194] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.194] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.194] signalConditionsASAP(NULL, pos=1) ... done
[18:04:18.195]  length: 5 (resolved future 1)
[18:04:18.195] Future #2
[18:04:18.195] result() for ClusterFuture ...
[18:04:18.195] - result already collected: FutureResult
[18:04:18.195] result() for ClusterFuture ... done
[18:04:18.196] result() for ClusterFuture ...
[18:04:18.196] - result already collected: FutureResult
[18:04:18.196] result() for ClusterFuture ... done
[18:04:18.196] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:18.196] - nx: 6
[18:04:18.197] - relay: TRUE
[18:04:18.197] - stdout: TRUE
[18:04:18.197] - signal: TRUE
[18:04:18.197] - resignal: FALSE
[18:04:18.197] - force: TRUE
[18:04:18.197] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.198] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.198]  - until=2
[18:04:18.198]  - relaying element #2
[18:04:18.198] result() for ClusterFuture ...
[18:04:18.198] - result already collected: FutureResult
[18:04:18.199] result() for ClusterFuture ... done
[18:04:18.199] result() for ClusterFuture ...
[18:04:18.199] - result already collected: FutureResult
[18:04:18.199] result() for ClusterFuture ... done
[18:04:18.199] result() for ClusterFuture ...
[18:04:18.200] - result already collected: FutureResult
[18:04:18.200] result() for ClusterFuture ... done
[18:04:18.200] result() for ClusterFuture ...
[18:04:18.200] - result already collected: FutureResult
[18:04:18.200] result() for ClusterFuture ... done
[18:04:18.200] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.201] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.201] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:18.201]  length: 4 (resolved future 2)
[18:04:18.206] receiveMessageFromWorker() for ClusterFuture ...
[18:04:18.206] - Validating connection of MultisessionFuture
[18:04:18.207] - received message: FutureResult
[18:04:18.207] - Received FutureResult
[18:04:18.207] - Erased future from FutureRegistry
[18:04:18.207] result() for ClusterFuture ...
[18:04:18.208] - result already collected: FutureResult
[18:04:18.208] result() for ClusterFuture ... done
[18:04:18.208] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:18.208] Future #3
[18:04:18.208] result() for ClusterFuture ...
[18:04:18.209] - result already collected: FutureResult
[18:04:18.209] result() for ClusterFuture ... done
[18:04:18.209] result() for ClusterFuture ...
[18:04:18.209] - result already collected: FutureResult
[18:04:18.209] result() for ClusterFuture ... done
[18:04:18.210] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:18.210] - nx: 6
[18:04:18.210] - relay: TRUE
[18:04:18.210] - stdout: TRUE
[18:04:18.210] - signal: TRUE
[18:04:18.211] - resignal: FALSE
[18:04:18.211] - force: TRUE
[18:04:18.211] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.211] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.211]  - until=3
[18:04:18.212]  - relaying element #3
[18:04:18.212] result() for ClusterFuture ...
[18:04:18.212] - result already collected: FutureResult
[18:04:18.212] result() for ClusterFuture ... done
[18:04:18.212] result() for ClusterFuture ...
[18:04:18.212] - result already collected: FutureResult
[18:04:18.213] result() for ClusterFuture ... done
[18:04:18.213] result() for ClusterFuture ...
[18:04:18.213] - result already collected: FutureResult
[18:04:18.213] result() for ClusterFuture ... done
[18:04:18.213] result() for ClusterFuture ...
[18:04:18.214] - result already collected: FutureResult
[18:04:18.214] result() for ClusterFuture ... done
[18:04:18.214] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.214] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.214] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:18.215]  length: 3 (resolved future 3)
[18:04:18.215] signalConditionsASAP(NULL, pos=4) ...
[18:04:18.215] - nx: 6
[18:04:18.215] - relay: TRUE
[18:04:18.215] - stdout: TRUE
[18:04:18.216] - signal: TRUE
[18:04:18.216] - resignal: FALSE
[18:04:18.216] - force: TRUE
[18:04:18.216] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.216] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.216]  - until=5
[18:04:18.217]  - relaying element #5
[18:04:18.217] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:18.217] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.217] signalConditionsASAP(NULL, pos=4) ... done
[18:04:18.217]  length: 2 (resolved future 4)
[18:04:18.218] signalConditionsASAP(NULL, pos=5) ...
[18:04:18.218] - nx: 6
[18:04:18.218] - relay: TRUE
[18:04:18.218] - stdout: TRUE
[18:04:18.218] - signal: TRUE
[18:04:18.218] - resignal: FALSE
[18:04:18.219] - force: TRUE
[18:04:18.219] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:18.219] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.219]  - until=6
[18:04:18.219]  - relaying element #6
[18:04:18.220] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:18.220] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.220] signalConditionsASAP(NULL, pos=5) ... done
[18:04:18.220]  length: 1 (resolved future 5)
[18:04:18.220] signalConditionsASAP(numeric, pos=6) ...
[18:04:18.221] - nx: 6
[18:04:18.221] - relay: TRUE
[18:04:18.221] - stdout: TRUE
[18:04:18.221] - signal: TRUE
[18:04:18.221] - resignal: FALSE
[18:04:18.221] - force: TRUE
[18:04:18.222] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:18.222] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.222]  - until=6
[18:04:18.222] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:18.222] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.222] signalConditionsASAP(numeric, pos=6) ... done
[18:04:18.223]  length: 0 (resolved future 6)
[18:04:18.223] Relaying remaining futures
[18:04:18.223] signalConditionsASAP(NULL, pos=0) ...
[18:04:18.223] - nx: 6
[18:04:18.223] - relay: TRUE
[18:04:18.224] - stdout: TRUE
[18:04:18.224] - signal: TRUE
[18:04:18.224] - resignal: FALSE
[18:04:18.224] - force: TRUE
[18:04:18.224] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:18.224] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:18.225] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:18.225] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.225] signalConditionsASAP(NULL, pos=0) ... done
[18:04:18.225] resolve() on list ... DONE
[18:04:18.225] result() for ClusterFuture ...
[18:04:18.226] - result already collected: FutureResult
[18:04:18.226] result() for ClusterFuture ... done
[18:04:18.226] result() for ClusterFuture ...
[18:04:18.226] - result already collected: FutureResult
[18:04:18.226] result() for ClusterFuture ... done
[18:04:18.227] result() for ClusterFuture ...
[18:04:18.227] - result already collected: FutureResult
[18:04:18.227] result() for ClusterFuture ... done
[18:04:18.227] result() for ClusterFuture ...
[18:04:18.227] - result already collected: FutureResult
[18:04:18.227] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[18:04:18.234] getGlobalsAndPackages() ...
[18:04:18.234] Searching for globals...
[18:04:18.235] 
[18:04:18.235] Searching for globals ... DONE
[18:04:18.235] - globals: [0] <none>
[18:04:18.236] getGlobalsAndPackages() ... DONE
[18:04:18.236] run() for ‘Future’ ...
[18:04:18.236] - state: ‘created’
[18:04:18.236] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.260] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:18.261]   - Field: ‘node’
[18:04:18.261]   - Field: ‘label’
[18:04:18.264]   - Field: ‘local’
[18:04:18.264]   - Field: ‘owner’
[18:04:18.264]   - Field: ‘envir’
[18:04:18.265]   - Field: ‘workers’
[18:04:18.265]   - Field: ‘packages’
[18:04:18.265]   - Field: ‘gc’
[18:04:18.265]   - Field: ‘conditions’
[18:04:18.265]   - Field: ‘persistent’
[18:04:18.265]   - Field: ‘expr’
[18:04:18.266]   - Field: ‘uuid’
[18:04:18.266]   - Field: ‘seed’
[18:04:18.266]   - Field: ‘version’
[18:04:18.266]   - Field: ‘result’
[18:04:18.266]   - Field: ‘asynchronous’
[18:04:18.267]   - Field: ‘calls’
[18:04:18.267]   - Field: ‘globals’
[18:04:18.267]   - Field: ‘stdout’
[18:04:18.267]   - Field: ‘earlySignal’
[18:04:18.267]   - Field: ‘lazy’
[18:04:18.268]   - Field: ‘state’
[18:04:18.268] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:18.268] - Launch lazy future ...
[18:04:18.269] Packages needed by the future expression (n = 0): <none>
[18:04:18.269] Packages needed by future strategies (n = 0): <none>
[18:04:18.270] {
[18:04:18.270]     {
[18:04:18.270]         {
[18:04:18.270]             ...future.startTime <- base::Sys.time()
[18:04:18.270]             {
[18:04:18.270]                 {
[18:04:18.270]                   {
[18:04:18.270]                     {
[18:04:18.270]                       base::local({
[18:04:18.270]                         has_future <- base::requireNamespace("future", 
[18:04:18.270]                           quietly = TRUE)
[18:04:18.270]                         if (has_future) {
[18:04:18.270]                           ns <- base::getNamespace("future")
[18:04:18.270]                           version <- ns[[".package"]][["version"]]
[18:04:18.270]                           if (is.null(version)) 
[18:04:18.270]                             version <- utils::packageVersion("future")
[18:04:18.270]                         }
[18:04:18.270]                         else {
[18:04:18.270]                           version <- NULL
[18:04:18.270]                         }
[18:04:18.270]                         if (!has_future || version < "1.8.0") {
[18:04:18.270]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.270]                             "", base::R.version$version.string), 
[18:04:18.270]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.270]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.270]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.270]                               "release", "version")], collapse = " "), 
[18:04:18.270]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.270]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.270]                             info)
[18:04:18.270]                           info <- base::paste(info, collapse = "; ")
[18:04:18.270]                           if (!has_future) {
[18:04:18.270]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.270]                               info)
[18:04:18.270]                           }
[18:04:18.270]                           else {
[18:04:18.270]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.270]                               info, version)
[18:04:18.270]                           }
[18:04:18.270]                           base::stop(msg)
[18:04:18.270]                         }
[18:04:18.270]                       })
[18:04:18.270]                     }
[18:04:18.270]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.270]                     base::options(mc.cores = 1L)
[18:04:18.270]                   }
[18:04:18.270]                   ...future.strategy.old <- future::plan("list")
[18:04:18.270]                   options(future.plan = NULL)
[18:04:18.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.270]                 }
[18:04:18.270]                 ...future.workdir <- getwd()
[18:04:18.270]             }
[18:04:18.270]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.270]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.270]         }
[18:04:18.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.270]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.270]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.270]             base::names(...future.oldOptions))
[18:04:18.270]     }
[18:04:18.270]     if (FALSE) {
[18:04:18.270]     }
[18:04:18.270]     else {
[18:04:18.270]         if (TRUE) {
[18:04:18.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.270]                 open = "w")
[18:04:18.270]         }
[18:04:18.270]         else {
[18:04:18.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.270]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.270]         }
[18:04:18.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.270]             base::sink(type = "output", split = FALSE)
[18:04:18.270]             base::close(...future.stdout)
[18:04:18.270]         }, add = TRUE)
[18:04:18.270]     }
[18:04:18.270]     ...future.frame <- base::sys.nframe()
[18:04:18.270]     ...future.conditions <- base::list()
[18:04:18.270]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.270]     if (FALSE) {
[18:04:18.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.270]     }
[18:04:18.270]     ...future.result <- base::tryCatch({
[18:04:18.270]         base::withCallingHandlers({
[18:04:18.270]             ...future.value <- base::withVisible(base::local({
[18:04:18.270]                 ...future.makeSendCondition <- base::local({
[18:04:18.270]                   sendCondition <- NULL
[18:04:18.270]                   function(frame = 1L) {
[18:04:18.270]                     if (is.function(sendCondition)) 
[18:04:18.270]                       return(sendCondition)
[18:04:18.270]                     ns <- getNamespace("parallel")
[18:04:18.270]                     if (exists("sendData", mode = "function", 
[18:04:18.270]                       envir = ns)) {
[18:04:18.270]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:18.270]                         envir = ns)
[18:04:18.270]                       envir <- sys.frame(frame)
[18:04:18.270]                       master <- NULL
[18:04:18.270]                       while (!identical(envir, .GlobalEnv) && 
[18:04:18.270]                         !identical(envir, emptyenv())) {
[18:04:18.270]                         if (exists("master", mode = "list", envir = envir, 
[18:04:18.270]                           inherits = FALSE)) {
[18:04:18.270]                           master <- get("master", mode = "list", 
[18:04:18.270]                             envir = envir, inherits = FALSE)
[18:04:18.270]                           if (inherits(master, c("SOCKnode", 
[18:04:18.270]                             "SOCK0node"))) {
[18:04:18.270]                             sendCondition <<- function(cond) {
[18:04:18.270]                               data <- list(type = "VALUE", value = cond, 
[18:04:18.270]                                 success = TRUE)
[18:04:18.270]                               parallel_sendData(master, data)
[18:04:18.270]                             }
[18:04:18.270]                             return(sendCondition)
[18:04:18.270]                           }
[18:04:18.270]                         }
[18:04:18.270]                         frame <- frame + 1L
[18:04:18.270]                         envir <- sys.frame(frame)
[18:04:18.270]                       }
[18:04:18.270]                     }
[18:04:18.270]                     sendCondition <<- function(cond) NULL
[18:04:18.270]                   }
[18:04:18.270]                 })
[18:04:18.270]                 withCallingHandlers({
[18:04:18.270]                   2
[18:04:18.270]                 }, immediateCondition = function(cond) {
[18:04:18.270]                   sendCondition <- ...future.makeSendCondition()
[18:04:18.270]                   sendCondition(cond)
[18:04:18.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.270]                   {
[18:04:18.270]                     inherits <- base::inherits
[18:04:18.270]                     invokeRestart <- base::invokeRestart
[18:04:18.270]                     is.null <- base::is.null
[18:04:18.270]                     muffled <- FALSE
[18:04:18.270]                     if (inherits(cond, "message")) {
[18:04:18.270]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.270]                       if (muffled) 
[18:04:18.270]                         invokeRestart("muffleMessage")
[18:04:18.270]                     }
[18:04:18.270]                     else if (inherits(cond, "warning")) {
[18:04:18.270]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.270]                       if (muffled) 
[18:04:18.270]                         invokeRestart("muffleWarning")
[18:04:18.270]                     }
[18:04:18.270]                     else if (inherits(cond, "condition")) {
[18:04:18.270]                       if (!is.null(pattern)) {
[18:04:18.270]                         computeRestarts <- base::computeRestarts
[18:04:18.270]                         grepl <- base::grepl
[18:04:18.270]                         restarts <- computeRestarts(cond)
[18:04:18.270]                         for (restart in restarts) {
[18:04:18.270]                           name <- restart$name
[18:04:18.270]                           if (is.null(name)) 
[18:04:18.270]                             next
[18:04:18.270]                           if (!grepl(pattern, name)) 
[18:04:18.270]                             next
[18:04:18.270]                           invokeRestart(restart)
[18:04:18.270]                           muffled <- TRUE
[18:04:18.270]                           break
[18:04:18.270]                         }
[18:04:18.270]                       }
[18:04:18.270]                     }
[18:04:18.270]                     invisible(muffled)
[18:04:18.270]                   }
[18:04:18.270]                   muffleCondition(cond)
[18:04:18.270]                 })
[18:04:18.270]             }))
[18:04:18.270]             future::FutureResult(value = ...future.value$value, 
[18:04:18.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.270]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.270]                     ...future.globalenv.names))
[18:04:18.270]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.270]         }, condition = base::local({
[18:04:18.270]             c <- base::c
[18:04:18.270]             inherits <- base::inherits
[18:04:18.270]             invokeRestart <- base::invokeRestart
[18:04:18.270]             length <- base::length
[18:04:18.270]             list <- base::list
[18:04:18.270]             seq.int <- base::seq.int
[18:04:18.270]             signalCondition <- base::signalCondition
[18:04:18.270]             sys.calls <- base::sys.calls
[18:04:18.270]             `[[` <- base::`[[`
[18:04:18.270]             `+` <- base::`+`
[18:04:18.270]             `<<-` <- base::`<<-`
[18:04:18.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.270]                   3L)]
[18:04:18.270]             }
[18:04:18.270]             function(cond) {
[18:04:18.270]                 is_error <- inherits(cond, "error")
[18:04:18.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.270]                   NULL)
[18:04:18.270]                 if (is_error) {
[18:04:18.270]                   sessionInformation <- function() {
[18:04:18.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.270]                       search = base::search(), system = base::Sys.info())
[18:04:18.270]                   }
[18:04:18.270]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.270]                     cond$call), session = sessionInformation(), 
[18:04:18.270]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.270]                   signalCondition(cond)
[18:04:18.270]                 }
[18:04:18.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.270]                 "immediateCondition"))) {
[18:04:18.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.270]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.270]                   if (TRUE && !signal) {
[18:04:18.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.270]                     {
[18:04:18.270]                       inherits <- base::inherits
[18:04:18.270]                       invokeRestart <- base::invokeRestart
[18:04:18.270]                       is.null <- base::is.null
[18:04:18.270]                       muffled <- FALSE
[18:04:18.270]                       if (inherits(cond, "message")) {
[18:04:18.270]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.270]                         if (muffled) 
[18:04:18.270]                           invokeRestart("muffleMessage")
[18:04:18.270]                       }
[18:04:18.270]                       else if (inherits(cond, "warning")) {
[18:04:18.270]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.270]                         if (muffled) 
[18:04:18.270]                           invokeRestart("muffleWarning")
[18:04:18.270]                       }
[18:04:18.270]                       else if (inherits(cond, "condition")) {
[18:04:18.270]                         if (!is.null(pattern)) {
[18:04:18.270]                           computeRestarts <- base::computeRestarts
[18:04:18.270]                           grepl <- base::grepl
[18:04:18.270]                           restarts <- computeRestarts(cond)
[18:04:18.270]                           for (restart in restarts) {
[18:04:18.270]                             name <- restart$name
[18:04:18.270]                             if (is.null(name)) 
[18:04:18.270]                               next
[18:04:18.270]                             if (!grepl(pattern, name)) 
[18:04:18.270]                               next
[18:04:18.270]                             invokeRestart(restart)
[18:04:18.270]                             muffled <- TRUE
[18:04:18.270]                             break
[18:04:18.270]                           }
[18:04:18.270]                         }
[18:04:18.270]                       }
[18:04:18.270]                       invisible(muffled)
[18:04:18.270]                     }
[18:04:18.270]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.270]                   }
[18:04:18.270]                 }
[18:04:18.270]                 else {
[18:04:18.270]                   if (TRUE) {
[18:04:18.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.270]                     {
[18:04:18.270]                       inherits <- base::inherits
[18:04:18.270]                       invokeRestart <- base::invokeRestart
[18:04:18.270]                       is.null <- base::is.null
[18:04:18.270]                       muffled <- FALSE
[18:04:18.270]                       if (inherits(cond, "message")) {
[18:04:18.270]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.270]                         if (muffled) 
[18:04:18.270]                           invokeRestart("muffleMessage")
[18:04:18.270]                       }
[18:04:18.270]                       else if (inherits(cond, "warning")) {
[18:04:18.270]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.270]                         if (muffled) 
[18:04:18.270]                           invokeRestart("muffleWarning")
[18:04:18.270]                       }
[18:04:18.270]                       else if (inherits(cond, "condition")) {
[18:04:18.270]                         if (!is.null(pattern)) {
[18:04:18.270]                           computeRestarts <- base::computeRestarts
[18:04:18.270]                           grepl <- base::grepl
[18:04:18.270]                           restarts <- computeRestarts(cond)
[18:04:18.270]                           for (restart in restarts) {
[18:04:18.270]                             name <- restart$name
[18:04:18.270]                             if (is.null(name)) 
[18:04:18.270]                               next
[18:04:18.270]                             if (!grepl(pattern, name)) 
[18:04:18.270]                               next
[18:04:18.270]                             invokeRestart(restart)
[18:04:18.270]                             muffled <- TRUE
[18:04:18.270]                             break
[18:04:18.270]                           }
[18:04:18.270]                         }
[18:04:18.270]                       }
[18:04:18.270]                       invisible(muffled)
[18:04:18.270]                     }
[18:04:18.270]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.270]                   }
[18:04:18.270]                 }
[18:04:18.270]             }
[18:04:18.270]         }))
[18:04:18.270]     }, error = function(ex) {
[18:04:18.270]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.270]                 ...future.rng), started = ...future.startTime, 
[18:04:18.270]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.270]             version = "1.8"), class = "FutureResult")
[18:04:18.270]     }, finally = {
[18:04:18.270]         if (!identical(...future.workdir, getwd())) 
[18:04:18.270]             setwd(...future.workdir)
[18:04:18.270]         {
[18:04:18.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.270]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.270]             }
[18:04:18.270]             base::options(...future.oldOptions)
[18:04:18.270]             if (.Platform$OS.type == "windows") {
[18:04:18.270]                 old_names <- names(...future.oldEnvVars)
[18:04:18.270]                 envs <- base::Sys.getenv()
[18:04:18.270]                 names <- names(envs)
[18:04:18.270]                 common <- intersect(names, old_names)
[18:04:18.270]                 added <- setdiff(names, old_names)
[18:04:18.270]                 removed <- setdiff(old_names, names)
[18:04:18.270]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.270]                   envs[common]]
[18:04:18.270]                 NAMES <- toupper(changed)
[18:04:18.270]                 args <- list()
[18:04:18.270]                 for (kk in seq_along(NAMES)) {
[18:04:18.270]                   name <- changed[[kk]]
[18:04:18.270]                   NAME <- NAMES[[kk]]
[18:04:18.270]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.270]                     next
[18:04:18.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.270]                 }
[18:04:18.270]                 NAMES <- toupper(added)
[18:04:18.270]                 for (kk in seq_along(NAMES)) {
[18:04:18.270]                   name <- added[[kk]]
[18:04:18.270]                   NAME <- NAMES[[kk]]
[18:04:18.270]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.270]                     next
[18:04:18.270]                   args[[name]] <- ""
[18:04:18.270]                 }
[18:04:18.270]                 NAMES <- toupper(removed)
[18:04:18.270]                 for (kk in seq_along(NAMES)) {
[18:04:18.270]                   name <- removed[[kk]]
[18:04:18.270]                   NAME <- NAMES[[kk]]
[18:04:18.270]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.270]                     next
[18:04:18.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.270]                 }
[18:04:18.270]                 if (length(args) > 0) 
[18:04:18.270]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.270]             }
[18:04:18.270]             else {
[18:04:18.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.270]             }
[18:04:18.270]             {
[18:04:18.270]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.270]                   0L) {
[18:04:18.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.270]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.270]                   base::options(opts)
[18:04:18.270]                 }
[18:04:18.270]                 {
[18:04:18.270]                   {
[18:04:18.270]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.270]                     NULL
[18:04:18.270]                   }
[18:04:18.270]                   options(future.plan = NULL)
[18:04:18.270]                   if (is.na(NA_character_)) 
[18:04:18.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.270]                     .init = FALSE)
[18:04:18.270]                 }
[18:04:18.270]             }
[18:04:18.270]         }
[18:04:18.270]     })
[18:04:18.270]     if (TRUE) {
[18:04:18.270]         base::sink(type = "output", split = FALSE)
[18:04:18.270]         if (TRUE) {
[18:04:18.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.270]         }
[18:04:18.270]         else {
[18:04:18.270]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.270]         }
[18:04:18.270]         base::close(...future.stdout)
[18:04:18.270]         ...future.stdout <- NULL
[18:04:18.270]     }
[18:04:18.270]     ...future.result$conditions <- ...future.conditions
[18:04:18.270]     ...future.result$finished <- base::Sys.time()
[18:04:18.270]     ...future.result
[18:04:18.270] }
[18:04:18.275] MultisessionFuture started
[18:04:18.276] - Launch lazy future ... done
[18:04:18.276] run() for ‘MultisessionFuture’ ... done
[18:04:18.276] getGlobalsAndPackages() ...
[18:04:18.276] Searching for globals...
[18:04:18.277] 
[18:04:18.277] Searching for globals ... DONE
[18:04:18.277] - globals: [0] <none>
[18:04:18.278] getGlobalsAndPackages() ... DONE
[18:04:18.278] run() for ‘Future’ ...
[18:04:18.278] - state: ‘created’
[18:04:18.278] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.301] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:18.302]   - Field: ‘node’
[18:04:18.302]   - Field: ‘label’
[18:04:18.302]   - Field: ‘local’
[18:04:18.303]   - Field: ‘owner’
[18:04:18.303]   - Field: ‘envir’
[18:04:18.303]   - Field: ‘workers’
[18:04:18.303]   - Field: ‘packages’
[18:04:18.303]   - Field: ‘gc’
[18:04:18.303]   - Field: ‘conditions’
[18:04:18.304]   - Field: ‘persistent’
[18:04:18.304]   - Field: ‘expr’
[18:04:18.304]   - Field: ‘uuid’
[18:04:18.304]   - Field: ‘seed’
[18:04:18.304]   - Field: ‘version’
[18:04:18.305]   - Field: ‘result’
[18:04:18.305]   - Field: ‘asynchronous’
[18:04:18.305]   - Field: ‘calls’
[18:04:18.305]   - Field: ‘globals’
[18:04:18.305]   - Field: ‘stdout’
[18:04:18.306]   - Field: ‘earlySignal’
[18:04:18.306]   - Field: ‘lazy’
[18:04:18.306]   - Field: ‘state’
[18:04:18.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:18.306] - Launch lazy future ...
[18:04:18.307] Packages needed by the future expression (n = 0): <none>
[18:04:18.307] Packages needed by future strategies (n = 0): <none>
[18:04:18.308] {
[18:04:18.308]     {
[18:04:18.308]         {
[18:04:18.308]             ...future.startTime <- base::Sys.time()
[18:04:18.308]             {
[18:04:18.308]                 {
[18:04:18.308]                   {
[18:04:18.308]                     {
[18:04:18.308]                       base::local({
[18:04:18.308]                         has_future <- base::requireNamespace("future", 
[18:04:18.308]                           quietly = TRUE)
[18:04:18.308]                         if (has_future) {
[18:04:18.308]                           ns <- base::getNamespace("future")
[18:04:18.308]                           version <- ns[[".package"]][["version"]]
[18:04:18.308]                           if (is.null(version)) 
[18:04:18.308]                             version <- utils::packageVersion("future")
[18:04:18.308]                         }
[18:04:18.308]                         else {
[18:04:18.308]                           version <- NULL
[18:04:18.308]                         }
[18:04:18.308]                         if (!has_future || version < "1.8.0") {
[18:04:18.308]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.308]                             "", base::R.version$version.string), 
[18:04:18.308]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.308]                               "release", "version")], collapse = " "), 
[18:04:18.308]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.308]                             info)
[18:04:18.308]                           info <- base::paste(info, collapse = "; ")
[18:04:18.308]                           if (!has_future) {
[18:04:18.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.308]                               info)
[18:04:18.308]                           }
[18:04:18.308]                           else {
[18:04:18.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.308]                               info, version)
[18:04:18.308]                           }
[18:04:18.308]                           base::stop(msg)
[18:04:18.308]                         }
[18:04:18.308]                       })
[18:04:18.308]                     }
[18:04:18.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.308]                     base::options(mc.cores = 1L)
[18:04:18.308]                   }
[18:04:18.308]                   ...future.strategy.old <- future::plan("list")
[18:04:18.308]                   options(future.plan = NULL)
[18:04:18.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.308]                 }
[18:04:18.308]                 ...future.workdir <- getwd()
[18:04:18.308]             }
[18:04:18.308]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.308]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.308]         }
[18:04:18.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.308]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.308]             base::names(...future.oldOptions))
[18:04:18.308]     }
[18:04:18.308]     if (FALSE) {
[18:04:18.308]     }
[18:04:18.308]     else {
[18:04:18.308]         if (TRUE) {
[18:04:18.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.308]                 open = "w")
[18:04:18.308]         }
[18:04:18.308]         else {
[18:04:18.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.308]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.308]         }
[18:04:18.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.308]             base::sink(type = "output", split = FALSE)
[18:04:18.308]             base::close(...future.stdout)
[18:04:18.308]         }, add = TRUE)
[18:04:18.308]     }
[18:04:18.308]     ...future.frame <- base::sys.nframe()
[18:04:18.308]     ...future.conditions <- base::list()
[18:04:18.308]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.308]     if (FALSE) {
[18:04:18.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.308]     }
[18:04:18.308]     ...future.result <- base::tryCatch({
[18:04:18.308]         base::withCallingHandlers({
[18:04:18.308]             ...future.value <- base::withVisible(base::local({
[18:04:18.308]                 ...future.makeSendCondition <- base::local({
[18:04:18.308]                   sendCondition <- NULL
[18:04:18.308]                   function(frame = 1L) {
[18:04:18.308]                     if (is.function(sendCondition)) 
[18:04:18.308]                       return(sendCondition)
[18:04:18.308]                     ns <- getNamespace("parallel")
[18:04:18.308]                     if (exists("sendData", mode = "function", 
[18:04:18.308]                       envir = ns)) {
[18:04:18.308]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:18.308]                         envir = ns)
[18:04:18.308]                       envir <- sys.frame(frame)
[18:04:18.308]                       master <- NULL
[18:04:18.308]                       while (!identical(envir, .GlobalEnv) && 
[18:04:18.308]                         !identical(envir, emptyenv())) {
[18:04:18.308]                         if (exists("master", mode = "list", envir = envir, 
[18:04:18.308]                           inherits = FALSE)) {
[18:04:18.308]                           master <- get("master", mode = "list", 
[18:04:18.308]                             envir = envir, inherits = FALSE)
[18:04:18.308]                           if (inherits(master, c("SOCKnode", 
[18:04:18.308]                             "SOCK0node"))) {
[18:04:18.308]                             sendCondition <<- function(cond) {
[18:04:18.308]                               data <- list(type = "VALUE", value = cond, 
[18:04:18.308]                                 success = TRUE)
[18:04:18.308]                               parallel_sendData(master, data)
[18:04:18.308]                             }
[18:04:18.308]                             return(sendCondition)
[18:04:18.308]                           }
[18:04:18.308]                         }
[18:04:18.308]                         frame <- frame + 1L
[18:04:18.308]                         envir <- sys.frame(frame)
[18:04:18.308]                       }
[18:04:18.308]                     }
[18:04:18.308]                     sendCondition <<- function(cond) NULL
[18:04:18.308]                   }
[18:04:18.308]                 })
[18:04:18.308]                 withCallingHandlers({
[18:04:18.308]                   NULL
[18:04:18.308]                 }, immediateCondition = function(cond) {
[18:04:18.308]                   sendCondition <- ...future.makeSendCondition()
[18:04:18.308]                   sendCondition(cond)
[18:04:18.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.308]                   {
[18:04:18.308]                     inherits <- base::inherits
[18:04:18.308]                     invokeRestart <- base::invokeRestart
[18:04:18.308]                     is.null <- base::is.null
[18:04:18.308]                     muffled <- FALSE
[18:04:18.308]                     if (inherits(cond, "message")) {
[18:04:18.308]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.308]                       if (muffled) 
[18:04:18.308]                         invokeRestart("muffleMessage")
[18:04:18.308]                     }
[18:04:18.308]                     else if (inherits(cond, "warning")) {
[18:04:18.308]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.308]                       if (muffled) 
[18:04:18.308]                         invokeRestart("muffleWarning")
[18:04:18.308]                     }
[18:04:18.308]                     else if (inherits(cond, "condition")) {
[18:04:18.308]                       if (!is.null(pattern)) {
[18:04:18.308]                         computeRestarts <- base::computeRestarts
[18:04:18.308]                         grepl <- base::grepl
[18:04:18.308]                         restarts <- computeRestarts(cond)
[18:04:18.308]                         for (restart in restarts) {
[18:04:18.308]                           name <- restart$name
[18:04:18.308]                           if (is.null(name)) 
[18:04:18.308]                             next
[18:04:18.308]                           if (!grepl(pattern, name)) 
[18:04:18.308]                             next
[18:04:18.308]                           invokeRestart(restart)
[18:04:18.308]                           muffled <- TRUE
[18:04:18.308]                           break
[18:04:18.308]                         }
[18:04:18.308]                       }
[18:04:18.308]                     }
[18:04:18.308]                     invisible(muffled)
[18:04:18.308]                   }
[18:04:18.308]                   muffleCondition(cond)
[18:04:18.308]                 })
[18:04:18.308]             }))
[18:04:18.308]             future::FutureResult(value = ...future.value$value, 
[18:04:18.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.308]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.308]                     ...future.globalenv.names))
[18:04:18.308]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.308]         }, condition = base::local({
[18:04:18.308]             c <- base::c
[18:04:18.308]             inherits <- base::inherits
[18:04:18.308]             invokeRestart <- base::invokeRestart
[18:04:18.308]             length <- base::length
[18:04:18.308]             list <- base::list
[18:04:18.308]             seq.int <- base::seq.int
[18:04:18.308]             signalCondition <- base::signalCondition
[18:04:18.308]             sys.calls <- base::sys.calls
[18:04:18.308]             `[[` <- base::`[[`
[18:04:18.308]             `+` <- base::`+`
[18:04:18.308]             `<<-` <- base::`<<-`
[18:04:18.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.308]                   3L)]
[18:04:18.308]             }
[18:04:18.308]             function(cond) {
[18:04:18.308]                 is_error <- inherits(cond, "error")
[18:04:18.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.308]                   NULL)
[18:04:18.308]                 if (is_error) {
[18:04:18.308]                   sessionInformation <- function() {
[18:04:18.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.308]                       search = base::search(), system = base::Sys.info())
[18:04:18.308]                   }
[18:04:18.308]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.308]                     cond$call), session = sessionInformation(), 
[18:04:18.308]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.308]                   signalCondition(cond)
[18:04:18.308]                 }
[18:04:18.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.308]                 "immediateCondition"))) {
[18:04:18.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.308]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.308]                   if (TRUE && !signal) {
[18:04:18.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.308]                     {
[18:04:18.308]                       inherits <- base::inherits
[18:04:18.308]                       invokeRestart <- base::invokeRestart
[18:04:18.308]                       is.null <- base::is.null
[18:04:18.308]                       muffled <- FALSE
[18:04:18.308]                       if (inherits(cond, "message")) {
[18:04:18.308]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.308]                         if (muffled) 
[18:04:18.308]                           invokeRestart("muffleMessage")
[18:04:18.308]                       }
[18:04:18.308]                       else if (inherits(cond, "warning")) {
[18:04:18.308]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.308]                         if (muffled) 
[18:04:18.308]                           invokeRestart("muffleWarning")
[18:04:18.308]                       }
[18:04:18.308]                       else if (inherits(cond, "condition")) {
[18:04:18.308]                         if (!is.null(pattern)) {
[18:04:18.308]                           computeRestarts <- base::computeRestarts
[18:04:18.308]                           grepl <- base::grepl
[18:04:18.308]                           restarts <- computeRestarts(cond)
[18:04:18.308]                           for (restart in restarts) {
[18:04:18.308]                             name <- restart$name
[18:04:18.308]                             if (is.null(name)) 
[18:04:18.308]                               next
[18:04:18.308]                             if (!grepl(pattern, name)) 
[18:04:18.308]                               next
[18:04:18.308]                             invokeRestart(restart)
[18:04:18.308]                             muffled <- TRUE
[18:04:18.308]                             break
[18:04:18.308]                           }
[18:04:18.308]                         }
[18:04:18.308]                       }
[18:04:18.308]                       invisible(muffled)
[18:04:18.308]                     }
[18:04:18.308]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.308]                   }
[18:04:18.308]                 }
[18:04:18.308]                 else {
[18:04:18.308]                   if (TRUE) {
[18:04:18.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.308]                     {
[18:04:18.308]                       inherits <- base::inherits
[18:04:18.308]                       invokeRestart <- base::invokeRestart
[18:04:18.308]                       is.null <- base::is.null
[18:04:18.308]                       muffled <- FALSE
[18:04:18.308]                       if (inherits(cond, "message")) {
[18:04:18.308]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.308]                         if (muffled) 
[18:04:18.308]                           invokeRestart("muffleMessage")
[18:04:18.308]                       }
[18:04:18.308]                       else if (inherits(cond, "warning")) {
[18:04:18.308]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.308]                         if (muffled) 
[18:04:18.308]                           invokeRestart("muffleWarning")
[18:04:18.308]                       }
[18:04:18.308]                       else if (inherits(cond, "condition")) {
[18:04:18.308]                         if (!is.null(pattern)) {
[18:04:18.308]                           computeRestarts <- base::computeRestarts
[18:04:18.308]                           grepl <- base::grepl
[18:04:18.308]                           restarts <- computeRestarts(cond)
[18:04:18.308]                           for (restart in restarts) {
[18:04:18.308]                             name <- restart$name
[18:04:18.308]                             if (is.null(name)) 
[18:04:18.308]                               next
[18:04:18.308]                             if (!grepl(pattern, name)) 
[18:04:18.308]                               next
[18:04:18.308]                             invokeRestart(restart)
[18:04:18.308]                             muffled <- TRUE
[18:04:18.308]                             break
[18:04:18.308]                           }
[18:04:18.308]                         }
[18:04:18.308]                       }
[18:04:18.308]                       invisible(muffled)
[18:04:18.308]                     }
[18:04:18.308]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.308]                   }
[18:04:18.308]                 }
[18:04:18.308]             }
[18:04:18.308]         }))
[18:04:18.308]     }, error = function(ex) {
[18:04:18.308]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.308]                 ...future.rng), started = ...future.startTime, 
[18:04:18.308]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.308]             version = "1.8"), class = "FutureResult")
[18:04:18.308]     }, finally = {
[18:04:18.308]         if (!identical(...future.workdir, getwd())) 
[18:04:18.308]             setwd(...future.workdir)
[18:04:18.308]         {
[18:04:18.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.308]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.308]             }
[18:04:18.308]             base::options(...future.oldOptions)
[18:04:18.308]             if (.Platform$OS.type == "windows") {
[18:04:18.308]                 old_names <- names(...future.oldEnvVars)
[18:04:18.308]                 envs <- base::Sys.getenv()
[18:04:18.308]                 names <- names(envs)
[18:04:18.308]                 common <- intersect(names, old_names)
[18:04:18.308]                 added <- setdiff(names, old_names)
[18:04:18.308]                 removed <- setdiff(old_names, names)
[18:04:18.308]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.308]                   envs[common]]
[18:04:18.308]                 NAMES <- toupper(changed)
[18:04:18.308]                 args <- list()
[18:04:18.308]                 for (kk in seq_along(NAMES)) {
[18:04:18.308]                   name <- changed[[kk]]
[18:04:18.308]                   NAME <- NAMES[[kk]]
[18:04:18.308]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.308]                     next
[18:04:18.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.308]                 }
[18:04:18.308]                 NAMES <- toupper(added)
[18:04:18.308]                 for (kk in seq_along(NAMES)) {
[18:04:18.308]                   name <- added[[kk]]
[18:04:18.308]                   NAME <- NAMES[[kk]]
[18:04:18.308]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.308]                     next
[18:04:18.308]                   args[[name]] <- ""
[18:04:18.308]                 }
[18:04:18.308]                 NAMES <- toupper(removed)
[18:04:18.308]                 for (kk in seq_along(NAMES)) {
[18:04:18.308]                   name <- removed[[kk]]
[18:04:18.308]                   NAME <- NAMES[[kk]]
[18:04:18.308]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.308]                     next
[18:04:18.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.308]                 }
[18:04:18.308]                 if (length(args) > 0) 
[18:04:18.308]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.308]             }
[18:04:18.308]             else {
[18:04:18.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.308]             }
[18:04:18.308]             {
[18:04:18.308]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.308]                   0L) {
[18:04:18.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.308]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.308]                   base::options(opts)
[18:04:18.308]                 }
[18:04:18.308]                 {
[18:04:18.308]                   {
[18:04:18.308]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.308]                     NULL
[18:04:18.308]                   }
[18:04:18.308]                   options(future.plan = NULL)
[18:04:18.308]                   if (is.na(NA_character_)) 
[18:04:18.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.308]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.308]                     .init = FALSE)
[18:04:18.308]                 }
[18:04:18.308]             }
[18:04:18.308]         }
[18:04:18.308]     })
[18:04:18.308]     if (TRUE) {
[18:04:18.308]         base::sink(type = "output", split = FALSE)
[18:04:18.308]         if (TRUE) {
[18:04:18.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.308]         }
[18:04:18.308]         else {
[18:04:18.308]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.308]         }
[18:04:18.308]         base::close(...future.stdout)
[18:04:18.308]         ...future.stdout <- NULL
[18:04:18.308]     }
[18:04:18.308]     ...future.result$conditions <- ...future.conditions
[18:04:18.308]     ...future.result$finished <- base::Sys.time()
[18:04:18.308]     ...future.result
[18:04:18.308] }
[18:04:18.314] MultisessionFuture started
[18:04:18.314] - Launch lazy future ... done
[18:04:18.314] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2d3d7390> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b8f4428> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2d3d7390> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5e3c2b8f4428> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[18:04:18.325] receiveMessageFromWorker() for ClusterFuture ...
[18:04:18.326] - Validating connection of MultisessionFuture
[18:04:18.326] - received message: FutureResult
[18:04:18.326] - Received FutureResult
[18:04:18.326] - Erased future from FutureRegistry
[18:04:18.327] result() for ClusterFuture ...
[18:04:18.327] - result already collected: FutureResult
[18:04:18.327] result() for ClusterFuture ... done
[18:04:18.327] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[18:04:18.342] resolve() on list ...
[18:04:18.342]  recursive: 0
[18:04:18.342]  length: 6
[18:04:18.343]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[18:04:18.343] signalConditionsASAP(numeric, pos=1) ...
[18:04:18.343] - nx: 6
[18:04:18.343] - relay: TRUE
[18:04:18.343] - stdout: TRUE
[18:04:18.344] - signal: TRUE
[18:04:18.344] - resignal: FALSE
[18:04:18.344] - force: TRUE
[18:04:18.344] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.344] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.345]  - until=2
[18:04:18.345]  - relaying element #2
[18:04:18.345] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.345] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.346] signalConditionsASAP(NULL, pos=1) ... done
[18:04:18.346]  length: 5 (resolved future 1)
[18:04:18.346] Future #2
[18:04:18.346] result() for ClusterFuture ...
[18:04:18.346] - result already collected: FutureResult
[18:04:18.347] result() for ClusterFuture ... done
[18:04:18.347] result() for ClusterFuture ...
[18:04:18.347] - result already collected: FutureResult
[18:04:18.347] result() for ClusterFuture ... done
[18:04:18.348] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:18.348] - nx: 6
[18:04:18.348] - relay: TRUE
[18:04:18.348] - stdout: TRUE
[18:04:18.348] - signal: TRUE
[18:04:18.348] - resignal: FALSE
[18:04:18.349] - force: TRUE
[18:04:18.349] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.349] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:18.349]  - until=2
[18:04:18.349]  - relaying element #2
[18:04:18.350] result() for ClusterFuture ...
[18:04:18.350] - result already collected: FutureResult
[18:04:18.350] result() for ClusterFuture ... done
[18:04:18.350] result() for ClusterFuture ...
[18:04:18.350] - result already collected: FutureResult
[18:04:18.351] result() for ClusterFuture ... done
[18:04:18.351] result() for ClusterFuture ...
[18:04:18.351] - result already collected: FutureResult
[18:04:18.351] result() for ClusterFuture ... done
[18:04:18.351] result() for ClusterFuture ...
[18:04:18.352] - result already collected: FutureResult
[18:04:18.352] result() for ClusterFuture ... done
[18:04:18.352] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.352] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.352] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:18.353]  length: 4 (resolved future 2)
[18:04:18.356] receiveMessageFromWorker() for ClusterFuture ...
[18:04:18.357] - Validating connection of MultisessionFuture
[18:04:18.357] - received message: FutureResult
[18:04:18.357] - Received FutureResult
[18:04:18.358] - Erased future from FutureRegistry
[18:04:18.358] result() for ClusterFuture ...
[18:04:18.358] - result already collected: FutureResult
[18:04:18.358] result() for ClusterFuture ... done
[18:04:18.359] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:18.359] Future #3
[18:04:18.359] result() for ClusterFuture ...
[18:04:18.359] - result already collected: FutureResult
[18:04:18.359] result() for ClusterFuture ... done
[18:04:18.360] result() for ClusterFuture ...
[18:04:18.360] - result already collected: FutureResult
[18:04:18.360] result() for ClusterFuture ... done
[18:04:18.360] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:18.360] - nx: 6
[18:04:18.361] - relay: TRUE
[18:04:18.361] - stdout: TRUE
[18:04:18.361] - signal: TRUE
[18:04:18.361] - resignal: FALSE
[18:04:18.361] - force: TRUE
[18:04:18.361] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.362] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:18.362]  - until=3
[18:04:18.362]  - relaying element #3
[18:04:18.363] result() for ClusterFuture ...
[18:04:18.363] - result already collected: FutureResult
[18:04:18.363] result() for ClusterFuture ... done
[18:04:18.363] result() for ClusterFuture ...
[18:04:18.363] - result already collected: FutureResult
[18:04:18.363] result() for ClusterFuture ... done
[18:04:18.364] result() for ClusterFuture ...
[18:04:18.364] - result already collected: FutureResult
[18:04:18.364] result() for ClusterFuture ... done
[18:04:18.364] result() for ClusterFuture ...
[18:04:18.364] - result already collected: FutureResult
[18:04:18.365] result() for ClusterFuture ... done
[18:04:18.365] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.365] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.366] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:18.366]  length: 3 (resolved future 3)
[18:04:18.366] signalConditionsASAP(NULL, pos=4) ...
[18:04:18.366] - nx: 6
[18:04:18.366] - relay: TRUE
[18:04:18.367] - stdout: TRUE
[18:04:18.367] - signal: TRUE
[18:04:18.367] - resignal: FALSE
[18:04:18.367] - force: TRUE
[18:04:18.367] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.368] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.368]  - until=5
[18:04:18.368]  - relaying element #5
[18:04:18.368] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:18.368] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.369] signalConditionsASAP(NULL, pos=4) ... done
[18:04:18.369]  length: 2 (resolved future 4)
[18:04:18.369] signalConditionsASAP(NULL, pos=5) ...
[18:04:18.369] - nx: 6
[18:04:18.369] - relay: TRUE
[18:04:18.370] - stdout: TRUE
[18:04:18.370] - signal: TRUE
[18:04:18.370] - resignal: FALSE
[18:04:18.370] - force: TRUE
[18:04:18.370] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:18.370] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.371]  - until=6
[18:04:18.371]  - relaying element #6
[18:04:18.371] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:18.371] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.371] signalConditionsASAP(NULL, pos=5) ... done
[18:04:18.372]  length: 1 (resolved future 5)
[18:04:18.372] signalConditionsASAP(numeric, pos=6) ...
[18:04:18.372] - nx: 6
[18:04:18.372] - relay: TRUE
[18:04:18.372] - stdout: TRUE
[18:04:18.373] - signal: TRUE
[18:04:18.373] - resignal: FALSE
[18:04:18.373] - force: TRUE
[18:04:18.373] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:18.373] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.374]  - until=6
[18:04:18.374] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:18.374] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.374] signalConditionsASAP(numeric, pos=6) ... done
[18:04:18.375]  length: 0 (resolved future 6)
[18:04:18.375] Relaying remaining futures
[18:04:18.375] signalConditionsASAP(NULL, pos=0) ...
[18:04:18.375] - nx: 6
[18:04:18.375] - relay: TRUE
[18:04:18.375] - stdout: TRUE
[18:04:18.376] - signal: TRUE
[18:04:18.376] - resignal: FALSE
[18:04:18.376] - force: TRUE
[18:04:18.376] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:18.377] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[18:04:18.377] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:18.377] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:18.378] signalConditionsASAP(NULL, pos=0) ... done
[18:04:18.378] resolve() on list ... DONE
[18:04:18.378] result() for ClusterFuture ...
[18:04:18.378] - result already collected: FutureResult
[18:04:18.378] result() for ClusterFuture ... done
[18:04:18.379] result() for ClusterFuture ...
[18:04:18.379] - result already collected: FutureResult
[18:04:18.379] result() for ClusterFuture ... done
[18:04:18.379] result() for ClusterFuture ...
[18:04:18.379] - result already collected: FutureResult
[18:04:18.379] result() for ClusterFuture ... done
[18:04:18.380] result() for ClusterFuture ...
[18:04:18.380] - result already collected: FutureResult
[18:04:18.380] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[18:04:18.389] plan(): Setting new future strategy stack:
[18:04:18.389] List of future strategies:
[18:04:18.389] 1. multicore:
[18:04:18.389]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:18.389]    - tweaked: FALSE
[18:04:18.389]    - call: plan(strategy)
[18:04:18.401] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[18:04:18.402] getGlobalsAndPackages() ...
[18:04:18.404] Searching for globals...
[18:04:18.405] 
[18:04:18.405] Searching for globals ... DONE
[18:04:18.405] - globals: [0] <none>
[18:04:18.405] getGlobalsAndPackages() ... DONE
[18:04:18.408] run() for ‘Future’ ...
[18:04:18.408] - state: ‘created’
[18:04:18.408] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.415] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.415] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:18.416]   - Field: ‘label’
[18:04:18.416]   - Field: ‘local’
[18:04:18.416]   - Field: ‘owner’
[18:04:18.416]   - Field: ‘envir’
[18:04:18.417]   - Field: ‘workers’
[18:04:18.417]   - Field: ‘packages’
[18:04:18.417]   - Field: ‘gc’
[18:04:18.417]   - Field: ‘job’
[18:04:18.417]   - Field: ‘conditions’
[18:04:18.418]   - Field: ‘expr’
[18:04:18.418]   - Field: ‘uuid’
[18:04:18.418]   - Field: ‘seed’
[18:04:18.418]   - Field: ‘version’
[18:04:18.418]   - Field: ‘result’
[18:04:18.419]   - Field: ‘asynchronous’
[18:04:18.419]   - Field: ‘calls’
[18:04:18.419]   - Field: ‘globals’
[18:04:18.419]   - Field: ‘stdout’
[18:04:18.419]   - Field: ‘earlySignal’
[18:04:18.420]   - Field: ‘lazy’
[18:04:18.420]   - Field: ‘state’
[18:04:18.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:18.420] - Launch lazy future ...
[18:04:18.421] Packages needed by the future expression (n = 0): <none>
[18:04:18.421] Packages needed by future strategies (n = 0): <none>
[18:04:18.422] {
[18:04:18.422]     {
[18:04:18.422]         {
[18:04:18.422]             ...future.startTime <- base::Sys.time()
[18:04:18.422]             {
[18:04:18.422]                 {
[18:04:18.422]                   {
[18:04:18.422]                     {
[18:04:18.422]                       base::local({
[18:04:18.422]                         has_future <- base::requireNamespace("future", 
[18:04:18.422]                           quietly = TRUE)
[18:04:18.422]                         if (has_future) {
[18:04:18.422]                           ns <- base::getNamespace("future")
[18:04:18.422]                           version <- ns[[".package"]][["version"]]
[18:04:18.422]                           if (is.null(version)) 
[18:04:18.422]                             version <- utils::packageVersion("future")
[18:04:18.422]                         }
[18:04:18.422]                         else {
[18:04:18.422]                           version <- NULL
[18:04:18.422]                         }
[18:04:18.422]                         if (!has_future || version < "1.8.0") {
[18:04:18.422]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.422]                             "", base::R.version$version.string), 
[18:04:18.422]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.422]                               "release", "version")], collapse = " "), 
[18:04:18.422]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.422]                             info)
[18:04:18.422]                           info <- base::paste(info, collapse = "; ")
[18:04:18.422]                           if (!has_future) {
[18:04:18.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.422]                               info)
[18:04:18.422]                           }
[18:04:18.422]                           else {
[18:04:18.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.422]                               info, version)
[18:04:18.422]                           }
[18:04:18.422]                           base::stop(msg)
[18:04:18.422]                         }
[18:04:18.422]                       })
[18:04:18.422]                     }
[18:04:18.422]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.422]                     base::options(mc.cores = 1L)
[18:04:18.422]                   }
[18:04:18.422]                   ...future.strategy.old <- future::plan("list")
[18:04:18.422]                   options(future.plan = NULL)
[18:04:18.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.422]                 }
[18:04:18.422]                 ...future.workdir <- getwd()
[18:04:18.422]             }
[18:04:18.422]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.422]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.422]         }
[18:04:18.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.422]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.422]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.422]             base::names(...future.oldOptions))
[18:04:18.422]     }
[18:04:18.422]     if (FALSE) {
[18:04:18.422]     }
[18:04:18.422]     else {
[18:04:18.422]         if (TRUE) {
[18:04:18.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.422]                 open = "w")
[18:04:18.422]         }
[18:04:18.422]         else {
[18:04:18.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.422]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.422]         }
[18:04:18.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.422]             base::sink(type = "output", split = FALSE)
[18:04:18.422]             base::close(...future.stdout)
[18:04:18.422]         }, add = TRUE)
[18:04:18.422]     }
[18:04:18.422]     ...future.frame <- base::sys.nframe()
[18:04:18.422]     ...future.conditions <- base::list()
[18:04:18.422]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.422]     if (FALSE) {
[18:04:18.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.422]     }
[18:04:18.422]     ...future.result <- base::tryCatch({
[18:04:18.422]         base::withCallingHandlers({
[18:04:18.422]             ...future.value <- base::withVisible(base::local({
[18:04:18.422]                 withCallingHandlers({
[18:04:18.422]                   2
[18:04:18.422]                 }, immediateCondition = function(cond) {
[18:04:18.422]                   save_rds <- function (object, pathname, ...) 
[18:04:18.422]                   {
[18:04:18.422]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:18.422]                     if (file_test("-f", pathname_tmp)) {
[18:04:18.422]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.422]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:18.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.422]                         fi_tmp[["mtime"]])
[18:04:18.422]                     }
[18:04:18.422]                     tryCatch({
[18:04:18.422]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:18.422]                     }, error = function(ex) {
[18:04:18.422]                       msg <- conditionMessage(ex)
[18:04:18.422]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.422]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:18.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.422]                         fi_tmp[["mtime"]], msg)
[18:04:18.422]                       ex$message <- msg
[18:04:18.422]                       stop(ex)
[18:04:18.422]                     })
[18:04:18.422]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:18.422]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:18.422]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:18.422]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.422]                       fi <- file.info(pathname)
[18:04:18.422]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:18.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.422]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:18.422]                         fi[["size"]], fi[["mtime"]])
[18:04:18.422]                       stop(msg)
[18:04:18.422]                     }
[18:04:18.422]                     invisible(pathname)
[18:04:18.422]                   }
[18:04:18.422]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:18.422]                     rootPath = tempdir()) 
[18:04:18.422]                   {
[18:04:18.422]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:18.422]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:18.422]                       tmpdir = path, fileext = ".rds")
[18:04:18.422]                     save_rds(obj, file)
[18:04:18.422]                   }
[18:04:18.422]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:18.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.422]                   {
[18:04:18.422]                     inherits <- base::inherits
[18:04:18.422]                     invokeRestart <- base::invokeRestart
[18:04:18.422]                     is.null <- base::is.null
[18:04:18.422]                     muffled <- FALSE
[18:04:18.422]                     if (inherits(cond, "message")) {
[18:04:18.422]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.422]                       if (muffled) 
[18:04:18.422]                         invokeRestart("muffleMessage")
[18:04:18.422]                     }
[18:04:18.422]                     else if (inherits(cond, "warning")) {
[18:04:18.422]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.422]                       if (muffled) 
[18:04:18.422]                         invokeRestart("muffleWarning")
[18:04:18.422]                     }
[18:04:18.422]                     else if (inherits(cond, "condition")) {
[18:04:18.422]                       if (!is.null(pattern)) {
[18:04:18.422]                         computeRestarts <- base::computeRestarts
[18:04:18.422]                         grepl <- base::grepl
[18:04:18.422]                         restarts <- computeRestarts(cond)
[18:04:18.422]                         for (restart in restarts) {
[18:04:18.422]                           name <- restart$name
[18:04:18.422]                           if (is.null(name)) 
[18:04:18.422]                             next
[18:04:18.422]                           if (!grepl(pattern, name)) 
[18:04:18.422]                             next
[18:04:18.422]                           invokeRestart(restart)
[18:04:18.422]                           muffled <- TRUE
[18:04:18.422]                           break
[18:04:18.422]                         }
[18:04:18.422]                       }
[18:04:18.422]                     }
[18:04:18.422]                     invisible(muffled)
[18:04:18.422]                   }
[18:04:18.422]                   muffleCondition(cond)
[18:04:18.422]                 })
[18:04:18.422]             }))
[18:04:18.422]             future::FutureResult(value = ...future.value$value, 
[18:04:18.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.422]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.422]                     ...future.globalenv.names))
[18:04:18.422]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.422]         }, condition = base::local({
[18:04:18.422]             c <- base::c
[18:04:18.422]             inherits <- base::inherits
[18:04:18.422]             invokeRestart <- base::invokeRestart
[18:04:18.422]             length <- base::length
[18:04:18.422]             list <- base::list
[18:04:18.422]             seq.int <- base::seq.int
[18:04:18.422]             signalCondition <- base::signalCondition
[18:04:18.422]             sys.calls <- base::sys.calls
[18:04:18.422]             `[[` <- base::`[[`
[18:04:18.422]             `+` <- base::`+`
[18:04:18.422]             `<<-` <- base::`<<-`
[18:04:18.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.422]                   3L)]
[18:04:18.422]             }
[18:04:18.422]             function(cond) {
[18:04:18.422]                 is_error <- inherits(cond, "error")
[18:04:18.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.422]                   NULL)
[18:04:18.422]                 if (is_error) {
[18:04:18.422]                   sessionInformation <- function() {
[18:04:18.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.422]                       search = base::search(), system = base::Sys.info())
[18:04:18.422]                   }
[18:04:18.422]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.422]                     cond$call), session = sessionInformation(), 
[18:04:18.422]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.422]                   signalCondition(cond)
[18:04:18.422]                 }
[18:04:18.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.422]                 "immediateCondition"))) {
[18:04:18.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.422]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.422]                   if (TRUE && !signal) {
[18:04:18.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.422]                     {
[18:04:18.422]                       inherits <- base::inherits
[18:04:18.422]                       invokeRestart <- base::invokeRestart
[18:04:18.422]                       is.null <- base::is.null
[18:04:18.422]                       muffled <- FALSE
[18:04:18.422]                       if (inherits(cond, "message")) {
[18:04:18.422]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.422]                         if (muffled) 
[18:04:18.422]                           invokeRestart("muffleMessage")
[18:04:18.422]                       }
[18:04:18.422]                       else if (inherits(cond, "warning")) {
[18:04:18.422]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.422]                         if (muffled) 
[18:04:18.422]                           invokeRestart("muffleWarning")
[18:04:18.422]                       }
[18:04:18.422]                       else if (inherits(cond, "condition")) {
[18:04:18.422]                         if (!is.null(pattern)) {
[18:04:18.422]                           computeRestarts <- base::computeRestarts
[18:04:18.422]                           grepl <- base::grepl
[18:04:18.422]                           restarts <- computeRestarts(cond)
[18:04:18.422]                           for (restart in restarts) {
[18:04:18.422]                             name <- restart$name
[18:04:18.422]                             if (is.null(name)) 
[18:04:18.422]                               next
[18:04:18.422]                             if (!grepl(pattern, name)) 
[18:04:18.422]                               next
[18:04:18.422]                             invokeRestart(restart)
[18:04:18.422]                             muffled <- TRUE
[18:04:18.422]                             break
[18:04:18.422]                           }
[18:04:18.422]                         }
[18:04:18.422]                       }
[18:04:18.422]                       invisible(muffled)
[18:04:18.422]                     }
[18:04:18.422]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.422]                   }
[18:04:18.422]                 }
[18:04:18.422]                 else {
[18:04:18.422]                   if (TRUE) {
[18:04:18.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.422]                     {
[18:04:18.422]                       inherits <- base::inherits
[18:04:18.422]                       invokeRestart <- base::invokeRestart
[18:04:18.422]                       is.null <- base::is.null
[18:04:18.422]                       muffled <- FALSE
[18:04:18.422]                       if (inherits(cond, "message")) {
[18:04:18.422]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.422]                         if (muffled) 
[18:04:18.422]                           invokeRestart("muffleMessage")
[18:04:18.422]                       }
[18:04:18.422]                       else if (inherits(cond, "warning")) {
[18:04:18.422]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.422]                         if (muffled) 
[18:04:18.422]                           invokeRestart("muffleWarning")
[18:04:18.422]                       }
[18:04:18.422]                       else if (inherits(cond, "condition")) {
[18:04:18.422]                         if (!is.null(pattern)) {
[18:04:18.422]                           computeRestarts <- base::computeRestarts
[18:04:18.422]                           grepl <- base::grepl
[18:04:18.422]                           restarts <- computeRestarts(cond)
[18:04:18.422]                           for (restart in restarts) {
[18:04:18.422]                             name <- restart$name
[18:04:18.422]                             if (is.null(name)) 
[18:04:18.422]                               next
[18:04:18.422]                             if (!grepl(pattern, name)) 
[18:04:18.422]                               next
[18:04:18.422]                             invokeRestart(restart)
[18:04:18.422]                             muffled <- TRUE
[18:04:18.422]                             break
[18:04:18.422]                           }
[18:04:18.422]                         }
[18:04:18.422]                       }
[18:04:18.422]                       invisible(muffled)
[18:04:18.422]                     }
[18:04:18.422]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.422]                   }
[18:04:18.422]                 }
[18:04:18.422]             }
[18:04:18.422]         }))
[18:04:18.422]     }, error = function(ex) {
[18:04:18.422]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.422]                 ...future.rng), started = ...future.startTime, 
[18:04:18.422]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.422]             version = "1.8"), class = "FutureResult")
[18:04:18.422]     }, finally = {
[18:04:18.422]         if (!identical(...future.workdir, getwd())) 
[18:04:18.422]             setwd(...future.workdir)
[18:04:18.422]         {
[18:04:18.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.422]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.422]             }
[18:04:18.422]             base::options(...future.oldOptions)
[18:04:18.422]             if (.Platform$OS.type == "windows") {
[18:04:18.422]                 old_names <- names(...future.oldEnvVars)
[18:04:18.422]                 envs <- base::Sys.getenv()
[18:04:18.422]                 names <- names(envs)
[18:04:18.422]                 common <- intersect(names, old_names)
[18:04:18.422]                 added <- setdiff(names, old_names)
[18:04:18.422]                 removed <- setdiff(old_names, names)
[18:04:18.422]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.422]                   envs[common]]
[18:04:18.422]                 NAMES <- toupper(changed)
[18:04:18.422]                 args <- list()
[18:04:18.422]                 for (kk in seq_along(NAMES)) {
[18:04:18.422]                   name <- changed[[kk]]
[18:04:18.422]                   NAME <- NAMES[[kk]]
[18:04:18.422]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.422]                     next
[18:04:18.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.422]                 }
[18:04:18.422]                 NAMES <- toupper(added)
[18:04:18.422]                 for (kk in seq_along(NAMES)) {
[18:04:18.422]                   name <- added[[kk]]
[18:04:18.422]                   NAME <- NAMES[[kk]]
[18:04:18.422]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.422]                     next
[18:04:18.422]                   args[[name]] <- ""
[18:04:18.422]                 }
[18:04:18.422]                 NAMES <- toupper(removed)
[18:04:18.422]                 for (kk in seq_along(NAMES)) {
[18:04:18.422]                   name <- removed[[kk]]
[18:04:18.422]                   NAME <- NAMES[[kk]]
[18:04:18.422]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.422]                     next
[18:04:18.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.422]                 }
[18:04:18.422]                 if (length(args) > 0) 
[18:04:18.422]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.422]             }
[18:04:18.422]             else {
[18:04:18.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.422]             }
[18:04:18.422]             {
[18:04:18.422]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.422]                   0L) {
[18:04:18.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.422]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.422]                   base::options(opts)
[18:04:18.422]                 }
[18:04:18.422]                 {
[18:04:18.422]                   {
[18:04:18.422]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.422]                     NULL
[18:04:18.422]                   }
[18:04:18.422]                   options(future.plan = NULL)
[18:04:18.422]                   if (is.na(NA_character_)) 
[18:04:18.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.422]                     .init = FALSE)
[18:04:18.422]                 }
[18:04:18.422]             }
[18:04:18.422]         }
[18:04:18.422]     })
[18:04:18.422]     if (TRUE) {
[18:04:18.422]         base::sink(type = "output", split = FALSE)
[18:04:18.422]         if (TRUE) {
[18:04:18.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.422]         }
[18:04:18.422]         else {
[18:04:18.422]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.422]         }
[18:04:18.422]         base::close(...future.stdout)
[18:04:18.422]         ...future.stdout <- NULL
[18:04:18.422]     }
[18:04:18.422]     ...future.result$conditions <- ...future.conditions
[18:04:18.422]     ...future.result$finished <- base::Sys.time()
[18:04:18.422]     ...future.result
[18:04:18.422] }
[18:04:18.426] requestCore(): workers = 2
[18:04:18.435] plan(): Setting new future strategy stack:
[18:04:18.431] MulticoreFuture started
[18:04:18.436] - Launch lazy future ... done
[18:04:18.436] run() for ‘MulticoreFuture’ ... done
[18:04:18.437] getGlobalsAndPackages() ...
[18:04:18.437] Searching for globals...
[18:04:18.435] List of future strategies:
[18:04:18.435] 1. sequential:
[18:04:18.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:18.435]    - tweaked: FALSE
[18:04:18.435]    - call: NULL
[18:04:18.441] 
[18:04:18.441] Searching for globals ... DONE
[18:04:18.440] plan(): nbrOfWorkers() = 1
[18:04:18.442] - globals: [0] <none>
[18:04:18.444] getGlobalsAndPackages() ... DONE
[18:04:18.445] run() for ‘Future’ ...
[18:04:18.447] plan(): Setting new future strategy stack:
[18:04:18.446] - state: ‘created’
[18:04:18.448] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.448] List of future strategies:
[18:04:18.448] 1. multicore:
[18:04:18.448]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:18.448]    - tweaked: FALSE
[18:04:18.448]    - call: plan(strategy)
[18:04:18.462] plan(): nbrOfWorkers() = 2
[18:04:18.464] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.464] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:18.465]   - Field: ‘label’
[18:04:18.465]   - Field: ‘local’
[18:04:18.466]   - Field: ‘owner’
[18:04:18.466]   - Field: ‘envir’
[18:04:18.466]   - Field: ‘workers’
[18:04:18.467]   - Field: ‘packages’
[18:04:18.467]   - Field: ‘gc’
[18:04:18.467]   - Field: ‘job’
[18:04:18.468]   - Field: ‘conditions’
[18:04:18.468]   - Field: ‘expr’
[18:04:18.468]   - Field: ‘uuid’
[18:04:18.469]   - Field: ‘seed’
[18:04:18.469]   - Field: ‘version’
[18:04:18.469]   - Field: ‘result’
[18:04:18.469]   - Field: ‘asynchronous’
[18:04:18.470]   - Field: ‘calls’
[18:04:18.470]   - Field: ‘globals’
[18:04:18.470]   - Field: ‘stdout’
[18:04:18.471]   - Field: ‘earlySignal’
[18:04:18.471]   - Field: ‘lazy’
[18:04:18.471]   - Field: ‘state’
[18:04:18.471] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:18.472] - Launch lazy future ...
[18:04:18.473] Packages needed by the future expression (n = 0): <none>
[18:04:18.473] Packages needed by future strategies (n = 0): <none>
[18:04:18.475] {
[18:04:18.475]     {
[18:04:18.475]         {
[18:04:18.475]             ...future.startTime <- base::Sys.time()
[18:04:18.475]             {
[18:04:18.475]                 {
[18:04:18.475]                   {
[18:04:18.475]                     {
[18:04:18.475]                       base::local({
[18:04:18.475]                         has_future <- base::requireNamespace("future", 
[18:04:18.475]                           quietly = TRUE)
[18:04:18.475]                         if (has_future) {
[18:04:18.475]                           ns <- base::getNamespace("future")
[18:04:18.475]                           version <- ns[[".package"]][["version"]]
[18:04:18.475]                           if (is.null(version)) 
[18:04:18.475]                             version <- utils::packageVersion("future")
[18:04:18.475]                         }
[18:04:18.475]                         else {
[18:04:18.475]                           version <- NULL
[18:04:18.475]                         }
[18:04:18.475]                         if (!has_future || version < "1.8.0") {
[18:04:18.475]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.475]                             "", base::R.version$version.string), 
[18:04:18.475]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.475]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.475]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.475]                               "release", "version")], collapse = " "), 
[18:04:18.475]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.475]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.475]                             info)
[18:04:18.475]                           info <- base::paste(info, collapse = "; ")
[18:04:18.475]                           if (!has_future) {
[18:04:18.475]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.475]                               info)
[18:04:18.475]                           }
[18:04:18.475]                           else {
[18:04:18.475]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.475]                               info, version)
[18:04:18.475]                           }
[18:04:18.475]                           base::stop(msg)
[18:04:18.475]                         }
[18:04:18.475]                       })
[18:04:18.475]                     }
[18:04:18.475]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.475]                     base::options(mc.cores = 1L)
[18:04:18.475]                   }
[18:04:18.475]                   ...future.strategy.old <- future::plan("list")
[18:04:18.475]                   options(future.plan = NULL)
[18:04:18.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.475]                 }
[18:04:18.475]                 ...future.workdir <- getwd()
[18:04:18.475]             }
[18:04:18.475]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.475]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.475]         }
[18:04:18.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.475]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.475]             base::names(...future.oldOptions))
[18:04:18.475]     }
[18:04:18.475]     if (FALSE) {
[18:04:18.475]     }
[18:04:18.475]     else {
[18:04:18.475]         if (TRUE) {
[18:04:18.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.475]                 open = "w")
[18:04:18.475]         }
[18:04:18.475]         else {
[18:04:18.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.475]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.475]         }
[18:04:18.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.475]             base::sink(type = "output", split = FALSE)
[18:04:18.475]             base::close(...future.stdout)
[18:04:18.475]         }, add = TRUE)
[18:04:18.475]     }
[18:04:18.475]     ...future.frame <- base::sys.nframe()
[18:04:18.475]     ...future.conditions <- base::list()
[18:04:18.475]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.475]     if (FALSE) {
[18:04:18.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.475]     }
[18:04:18.475]     ...future.result <- base::tryCatch({
[18:04:18.475]         base::withCallingHandlers({
[18:04:18.475]             ...future.value <- base::withVisible(base::local({
[18:04:18.475]                 withCallingHandlers({
[18:04:18.475]                   NULL
[18:04:18.475]                 }, immediateCondition = function(cond) {
[18:04:18.475]                   save_rds <- function (object, pathname, ...) 
[18:04:18.475]                   {
[18:04:18.475]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:18.475]                     if (file_test("-f", pathname_tmp)) {
[18:04:18.475]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.475]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:18.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.475]                         fi_tmp[["mtime"]])
[18:04:18.475]                     }
[18:04:18.475]                     tryCatch({
[18:04:18.475]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:18.475]                     }, error = function(ex) {
[18:04:18.475]                       msg <- conditionMessage(ex)
[18:04:18.475]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.475]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:18.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.475]                         fi_tmp[["mtime"]], msg)
[18:04:18.475]                       ex$message <- msg
[18:04:18.475]                       stop(ex)
[18:04:18.475]                     })
[18:04:18.475]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:18.475]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:18.475]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:18.475]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.475]                       fi <- file.info(pathname)
[18:04:18.475]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:18.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.475]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:18.475]                         fi[["size"]], fi[["mtime"]])
[18:04:18.475]                       stop(msg)
[18:04:18.475]                     }
[18:04:18.475]                     invisible(pathname)
[18:04:18.475]                   }
[18:04:18.475]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:18.475]                     rootPath = tempdir()) 
[18:04:18.475]                   {
[18:04:18.475]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:18.475]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:18.475]                       tmpdir = path, fileext = ".rds")
[18:04:18.475]                     save_rds(obj, file)
[18:04:18.475]                   }
[18:04:18.475]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:18.475]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.475]                   {
[18:04:18.475]                     inherits <- base::inherits
[18:04:18.475]                     invokeRestart <- base::invokeRestart
[18:04:18.475]                     is.null <- base::is.null
[18:04:18.475]                     muffled <- FALSE
[18:04:18.475]                     if (inherits(cond, "message")) {
[18:04:18.475]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.475]                       if (muffled) 
[18:04:18.475]                         invokeRestart("muffleMessage")
[18:04:18.475]                     }
[18:04:18.475]                     else if (inherits(cond, "warning")) {
[18:04:18.475]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.475]                       if (muffled) 
[18:04:18.475]                         invokeRestart("muffleWarning")
[18:04:18.475]                     }
[18:04:18.475]                     else if (inherits(cond, "condition")) {
[18:04:18.475]                       if (!is.null(pattern)) {
[18:04:18.475]                         computeRestarts <- base::computeRestarts
[18:04:18.475]                         grepl <- base::grepl
[18:04:18.475]                         restarts <- computeRestarts(cond)
[18:04:18.475]                         for (restart in restarts) {
[18:04:18.475]                           name <- restart$name
[18:04:18.475]                           if (is.null(name)) 
[18:04:18.475]                             next
[18:04:18.475]                           if (!grepl(pattern, name)) 
[18:04:18.475]                             next
[18:04:18.475]                           invokeRestart(restart)
[18:04:18.475]                           muffled <- TRUE
[18:04:18.475]                           break
[18:04:18.475]                         }
[18:04:18.475]                       }
[18:04:18.475]                     }
[18:04:18.475]                     invisible(muffled)
[18:04:18.475]                   }
[18:04:18.475]                   muffleCondition(cond)
[18:04:18.475]                 })
[18:04:18.475]             }))
[18:04:18.475]             future::FutureResult(value = ...future.value$value, 
[18:04:18.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.475]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.475]                     ...future.globalenv.names))
[18:04:18.475]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.475]         }, condition = base::local({
[18:04:18.475]             c <- base::c
[18:04:18.475]             inherits <- base::inherits
[18:04:18.475]             invokeRestart <- base::invokeRestart
[18:04:18.475]             length <- base::length
[18:04:18.475]             list <- base::list
[18:04:18.475]             seq.int <- base::seq.int
[18:04:18.475]             signalCondition <- base::signalCondition
[18:04:18.475]             sys.calls <- base::sys.calls
[18:04:18.475]             `[[` <- base::`[[`
[18:04:18.475]             `+` <- base::`+`
[18:04:18.475]             `<<-` <- base::`<<-`
[18:04:18.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.475]                   3L)]
[18:04:18.475]             }
[18:04:18.475]             function(cond) {
[18:04:18.475]                 is_error <- inherits(cond, "error")
[18:04:18.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.475]                   NULL)
[18:04:18.475]                 if (is_error) {
[18:04:18.475]                   sessionInformation <- function() {
[18:04:18.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.475]                       search = base::search(), system = base::Sys.info())
[18:04:18.475]                   }
[18:04:18.475]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.475]                     cond$call), session = sessionInformation(), 
[18:04:18.475]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.475]                   signalCondition(cond)
[18:04:18.475]                 }
[18:04:18.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.475]                 "immediateCondition"))) {
[18:04:18.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.475]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.475]                   if (TRUE && !signal) {
[18:04:18.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.475]                     {
[18:04:18.475]                       inherits <- base::inherits
[18:04:18.475]                       invokeRestart <- base::invokeRestart
[18:04:18.475]                       is.null <- base::is.null
[18:04:18.475]                       muffled <- FALSE
[18:04:18.475]                       if (inherits(cond, "message")) {
[18:04:18.475]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.475]                         if (muffled) 
[18:04:18.475]                           invokeRestart("muffleMessage")
[18:04:18.475]                       }
[18:04:18.475]                       else if (inherits(cond, "warning")) {
[18:04:18.475]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.475]                         if (muffled) 
[18:04:18.475]                           invokeRestart("muffleWarning")
[18:04:18.475]                       }
[18:04:18.475]                       else if (inherits(cond, "condition")) {
[18:04:18.475]                         if (!is.null(pattern)) {
[18:04:18.475]                           computeRestarts <- base::computeRestarts
[18:04:18.475]                           grepl <- base::grepl
[18:04:18.475]                           restarts <- computeRestarts(cond)
[18:04:18.475]                           for (restart in restarts) {
[18:04:18.475]                             name <- restart$name
[18:04:18.475]                             if (is.null(name)) 
[18:04:18.475]                               next
[18:04:18.475]                             if (!grepl(pattern, name)) 
[18:04:18.475]                               next
[18:04:18.475]                             invokeRestart(restart)
[18:04:18.475]                             muffled <- TRUE
[18:04:18.475]                             break
[18:04:18.475]                           }
[18:04:18.475]                         }
[18:04:18.475]                       }
[18:04:18.475]                       invisible(muffled)
[18:04:18.475]                     }
[18:04:18.475]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.475]                   }
[18:04:18.475]                 }
[18:04:18.475]                 else {
[18:04:18.475]                   if (TRUE) {
[18:04:18.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.475]                     {
[18:04:18.475]                       inherits <- base::inherits
[18:04:18.475]                       invokeRestart <- base::invokeRestart
[18:04:18.475]                       is.null <- base::is.null
[18:04:18.475]                       muffled <- FALSE
[18:04:18.475]                       if (inherits(cond, "message")) {
[18:04:18.475]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.475]                         if (muffled) 
[18:04:18.475]                           invokeRestart("muffleMessage")
[18:04:18.475]                       }
[18:04:18.475]                       else if (inherits(cond, "warning")) {
[18:04:18.475]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.475]                         if (muffled) 
[18:04:18.475]                           invokeRestart("muffleWarning")
[18:04:18.475]                       }
[18:04:18.475]                       else if (inherits(cond, "condition")) {
[18:04:18.475]                         if (!is.null(pattern)) {
[18:04:18.475]                           computeRestarts <- base::computeRestarts
[18:04:18.475]                           grepl <- base::grepl
[18:04:18.475]                           restarts <- computeRestarts(cond)
[18:04:18.475]                           for (restart in restarts) {
[18:04:18.475]                             name <- restart$name
[18:04:18.475]                             if (is.null(name)) 
[18:04:18.475]                               next
[18:04:18.475]                             if (!grepl(pattern, name)) 
[18:04:18.475]                               next
[18:04:18.475]                             invokeRestart(restart)
[18:04:18.475]                             muffled <- TRUE
[18:04:18.475]                             break
[18:04:18.475]                           }
[18:04:18.475]                         }
[18:04:18.475]                       }
[18:04:18.475]                       invisible(muffled)
[18:04:18.475]                     }
[18:04:18.475]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.475]                   }
[18:04:18.475]                 }
[18:04:18.475]             }
[18:04:18.475]         }))
[18:04:18.475]     }, error = function(ex) {
[18:04:18.475]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.475]                 ...future.rng), started = ...future.startTime, 
[18:04:18.475]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.475]             version = "1.8"), class = "FutureResult")
[18:04:18.475]     }, finally = {
[18:04:18.475]         if (!identical(...future.workdir, getwd())) 
[18:04:18.475]             setwd(...future.workdir)
[18:04:18.475]         {
[18:04:18.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.475]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.475]             }
[18:04:18.475]             base::options(...future.oldOptions)
[18:04:18.475]             if (.Platform$OS.type == "windows") {
[18:04:18.475]                 old_names <- names(...future.oldEnvVars)
[18:04:18.475]                 envs <- base::Sys.getenv()
[18:04:18.475]                 names <- names(envs)
[18:04:18.475]                 common <- intersect(names, old_names)
[18:04:18.475]                 added <- setdiff(names, old_names)
[18:04:18.475]                 removed <- setdiff(old_names, names)
[18:04:18.475]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.475]                   envs[common]]
[18:04:18.475]                 NAMES <- toupper(changed)
[18:04:18.475]                 args <- list()
[18:04:18.475]                 for (kk in seq_along(NAMES)) {
[18:04:18.475]                   name <- changed[[kk]]
[18:04:18.475]                   NAME <- NAMES[[kk]]
[18:04:18.475]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.475]                     next
[18:04:18.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.475]                 }
[18:04:18.475]                 NAMES <- toupper(added)
[18:04:18.475]                 for (kk in seq_along(NAMES)) {
[18:04:18.475]                   name <- added[[kk]]
[18:04:18.475]                   NAME <- NAMES[[kk]]
[18:04:18.475]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.475]                     next
[18:04:18.475]                   args[[name]] <- ""
[18:04:18.475]                 }
[18:04:18.475]                 NAMES <- toupper(removed)
[18:04:18.475]                 for (kk in seq_along(NAMES)) {
[18:04:18.475]                   name <- removed[[kk]]
[18:04:18.475]                   NAME <- NAMES[[kk]]
[18:04:18.475]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.475]                     next
[18:04:18.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.475]                 }
[18:04:18.475]                 if (length(args) > 0) 
[18:04:18.475]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.475]             }
[18:04:18.475]             else {
[18:04:18.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.475]             }
[18:04:18.475]             {
[18:04:18.475]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.475]                   0L) {
[18:04:18.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.475]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.475]                   base::options(opts)
[18:04:18.475]                 }
[18:04:18.475]                 {
[18:04:18.475]                   {
[18:04:18.475]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.475]                     NULL
[18:04:18.475]                   }
[18:04:18.475]                   options(future.plan = NULL)
[18:04:18.475]                   if (is.na(NA_character_)) 
[18:04:18.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.475]                     .init = FALSE)
[18:04:18.475]                 }
[18:04:18.475]             }
[18:04:18.475]         }
[18:04:18.475]     })
[18:04:18.475]     if (TRUE) {
[18:04:18.475]         base::sink(type = "output", split = FALSE)
[18:04:18.475]         if (TRUE) {
[18:04:18.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.475]         }
[18:04:18.475]         else {
[18:04:18.475]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.475]         }
[18:04:18.475]         base::close(...future.stdout)
[18:04:18.475]         ...future.stdout <- NULL
[18:04:18.475]     }
[18:04:18.475]     ...future.result$conditions <- ...future.conditions
[18:04:18.475]     ...future.result$finished <- base::Sys.time()
[18:04:18.475]     ...future.result
[18:04:18.475] }
[18:04:18.483] requestCore(): workers = 2
[18:04:18.487] MulticoreFuture started
[18:04:18.488] - Launch lazy future ... done
[18:04:18.489] run() for ‘MulticoreFuture’ ... done
[18:04:18.490] getGlobalsAndPackages() ...
[18:04:18.491] Searching for globals...
[18:04:18.492] plan(): Setting new future strategy stack:
[18:04:18.493] - globals found: [1] ‘{’
[18:04:18.494] Searching for globals ... DONE
[18:04:18.494] Resolving globals: FALSE
[18:04:18.495] 
[18:04:18.496] 
[18:04:18.496] getGlobalsAndPackages() ... DONE
[18:04:18.497] run() for ‘Future’ ...
[18:04:18.493] List of future strategies:
[18:04:18.493] 1. sequential:
[18:04:18.493]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:18.493]    - tweaked: FALSE
[18:04:18.493]    - call: NULL
[18:04:18.497] - state: ‘created’
[18:04:18.498] plan(): nbrOfWorkers() = 1
[18:04:18.498] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.505] plan(): Setting new future strategy stack:
[18:04:18.507] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.508] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:18.506] List of future strategies:
[18:04:18.506] 1. multicore:
[18:04:18.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:18.506]    - tweaked: FALSE
[18:04:18.506]    - call: plan(strategy)
[18:04:18.508]   - Field: ‘label’
[18:04:18.508]   - Field: ‘local’
[18:04:18.509]   - Field: ‘owner’
[18:04:18.509]   - Field: ‘envir’
[18:04:18.509]   - Field: ‘workers’
[18:04:18.509]   - Field: ‘packages’
[18:04:18.510]   - Field: ‘gc’
[18:04:18.510]   - Field: ‘job’
[18:04:18.510]   - Field: ‘conditions’
[18:04:18.511]   - Field: ‘expr’
[18:04:18.511]   - Field: ‘uuid’
[18:04:18.511]   - Field: ‘seed’
[18:04:18.512]   - Field: ‘version’
[18:04:18.512]   - Field: ‘result’
[18:04:18.512]   - Field: ‘asynchronous’
[18:04:18.513]   - Field: ‘calls’
[18:04:18.513]   - Field: ‘globals’
[18:04:18.513]   - Field: ‘stdout’
[18:04:18.513]   - Field: ‘earlySignal’
[18:04:18.514]   - Field: ‘lazy’
[18:04:18.515]   - Field: ‘state’
[18:04:18.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:18.516] - Launch lazy future ...
[18:04:18.517] Packages needed by the future expression (n = 0): <none>
[18:04:18.517] Packages needed by future strategies (n = 0): <none>
[18:04:18.523] plan(): nbrOfWorkers() = 2
[18:04:18.519] {
[18:04:18.519]     {
[18:04:18.519]         {
[18:04:18.519]             ...future.startTime <- base::Sys.time()
[18:04:18.519]             {
[18:04:18.519]                 {
[18:04:18.519]                   {
[18:04:18.519]                     {
[18:04:18.519]                       base::local({
[18:04:18.519]                         has_future <- base::requireNamespace("future", 
[18:04:18.519]                           quietly = TRUE)
[18:04:18.519]                         if (has_future) {
[18:04:18.519]                           ns <- base::getNamespace("future")
[18:04:18.519]                           version <- ns[[".package"]][["version"]]
[18:04:18.519]                           if (is.null(version)) 
[18:04:18.519]                             version <- utils::packageVersion("future")
[18:04:18.519]                         }
[18:04:18.519]                         else {
[18:04:18.519]                           version <- NULL
[18:04:18.519]                         }
[18:04:18.519]                         if (!has_future || version < "1.8.0") {
[18:04:18.519]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.519]                             "", base::R.version$version.string), 
[18:04:18.519]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.519]                               "release", "version")], collapse = " "), 
[18:04:18.519]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.519]                             info)
[18:04:18.519]                           info <- base::paste(info, collapse = "; ")
[18:04:18.519]                           if (!has_future) {
[18:04:18.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.519]                               info)
[18:04:18.519]                           }
[18:04:18.519]                           else {
[18:04:18.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.519]                               info, version)
[18:04:18.519]                           }
[18:04:18.519]                           base::stop(msg)
[18:04:18.519]                         }
[18:04:18.519]                       })
[18:04:18.519]                     }
[18:04:18.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.519]                     base::options(mc.cores = 1L)
[18:04:18.519]                   }
[18:04:18.519]                   ...future.strategy.old <- future::plan("list")
[18:04:18.519]                   options(future.plan = NULL)
[18:04:18.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.519]                 }
[18:04:18.519]                 ...future.workdir <- getwd()
[18:04:18.519]             }
[18:04:18.519]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.519]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.519]         }
[18:04:18.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.519]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.519]             base::names(...future.oldOptions))
[18:04:18.519]     }
[18:04:18.519]     if (FALSE) {
[18:04:18.519]     }
[18:04:18.519]     else {
[18:04:18.519]         if (TRUE) {
[18:04:18.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.519]                 open = "w")
[18:04:18.519]         }
[18:04:18.519]         else {
[18:04:18.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.519]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.519]         }
[18:04:18.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.519]             base::sink(type = "output", split = FALSE)
[18:04:18.519]             base::close(...future.stdout)
[18:04:18.519]         }, add = TRUE)
[18:04:18.519]     }
[18:04:18.519]     ...future.frame <- base::sys.nframe()
[18:04:18.519]     ...future.conditions <- base::list()
[18:04:18.519]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.519]     if (FALSE) {
[18:04:18.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.519]     }
[18:04:18.519]     ...future.result <- base::tryCatch({
[18:04:18.519]         base::withCallingHandlers({
[18:04:18.519]             ...future.value <- base::withVisible(base::local({
[18:04:18.519]                 withCallingHandlers({
[18:04:18.519]                   {
[18:04:18.519]                     4
[18:04:18.519]                   }
[18:04:18.519]                 }, immediateCondition = function(cond) {
[18:04:18.519]                   save_rds <- function (object, pathname, ...) 
[18:04:18.519]                   {
[18:04:18.519]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:18.519]                     if (file_test("-f", pathname_tmp)) {
[18:04:18.519]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.519]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:18.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.519]                         fi_tmp[["mtime"]])
[18:04:18.519]                     }
[18:04:18.519]                     tryCatch({
[18:04:18.519]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:18.519]                     }, error = function(ex) {
[18:04:18.519]                       msg <- conditionMessage(ex)
[18:04:18.519]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.519]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:18.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.519]                         fi_tmp[["mtime"]], msg)
[18:04:18.519]                       ex$message <- msg
[18:04:18.519]                       stop(ex)
[18:04:18.519]                     })
[18:04:18.519]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:18.519]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:18.519]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:18.519]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.519]                       fi <- file.info(pathname)
[18:04:18.519]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:18.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.519]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:18.519]                         fi[["size"]], fi[["mtime"]])
[18:04:18.519]                       stop(msg)
[18:04:18.519]                     }
[18:04:18.519]                     invisible(pathname)
[18:04:18.519]                   }
[18:04:18.519]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:18.519]                     rootPath = tempdir()) 
[18:04:18.519]                   {
[18:04:18.519]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:18.519]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:18.519]                       tmpdir = path, fileext = ".rds")
[18:04:18.519]                     save_rds(obj, file)
[18:04:18.519]                   }
[18:04:18.519]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:18.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.519]                   {
[18:04:18.519]                     inherits <- base::inherits
[18:04:18.519]                     invokeRestart <- base::invokeRestart
[18:04:18.519]                     is.null <- base::is.null
[18:04:18.519]                     muffled <- FALSE
[18:04:18.519]                     if (inherits(cond, "message")) {
[18:04:18.519]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.519]                       if (muffled) 
[18:04:18.519]                         invokeRestart("muffleMessage")
[18:04:18.519]                     }
[18:04:18.519]                     else if (inherits(cond, "warning")) {
[18:04:18.519]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.519]                       if (muffled) 
[18:04:18.519]                         invokeRestart("muffleWarning")
[18:04:18.519]                     }
[18:04:18.519]                     else if (inherits(cond, "condition")) {
[18:04:18.519]                       if (!is.null(pattern)) {
[18:04:18.519]                         computeRestarts <- base::computeRestarts
[18:04:18.519]                         grepl <- base::grepl
[18:04:18.519]                         restarts <- computeRestarts(cond)
[18:04:18.519]                         for (restart in restarts) {
[18:04:18.519]                           name <- restart$name
[18:04:18.519]                           if (is.null(name)) 
[18:04:18.519]                             next
[18:04:18.519]                           if (!grepl(pattern, name)) 
[18:04:18.519]                             next
[18:04:18.519]                           invokeRestart(restart)
[18:04:18.519]                           muffled <- TRUE
[18:04:18.519]                           break
[18:04:18.519]                         }
[18:04:18.519]                       }
[18:04:18.519]                     }
[18:04:18.519]                     invisible(muffled)
[18:04:18.519]                   }
[18:04:18.519]                   muffleCondition(cond)
[18:04:18.519]                 })
[18:04:18.519]             }))
[18:04:18.519]             future::FutureResult(value = ...future.value$value, 
[18:04:18.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.519]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.519]                     ...future.globalenv.names))
[18:04:18.519]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.519]         }, condition = base::local({
[18:04:18.519]             c <- base::c
[18:04:18.519]             inherits <- base::inherits
[18:04:18.519]             invokeRestart <- base::invokeRestart
[18:04:18.519]             length <- base::length
[18:04:18.519]             list <- base::list
[18:04:18.519]             seq.int <- base::seq.int
[18:04:18.519]             signalCondition <- base::signalCondition
[18:04:18.519]             sys.calls <- base::sys.calls
[18:04:18.519]             `[[` <- base::`[[`
[18:04:18.519]             `+` <- base::`+`
[18:04:18.519]             `<<-` <- base::`<<-`
[18:04:18.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.519]                   3L)]
[18:04:18.519]             }
[18:04:18.519]             function(cond) {
[18:04:18.519]                 is_error <- inherits(cond, "error")
[18:04:18.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.519]                   NULL)
[18:04:18.519]                 if (is_error) {
[18:04:18.519]                   sessionInformation <- function() {
[18:04:18.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.519]                       search = base::search(), system = base::Sys.info())
[18:04:18.519]                   }
[18:04:18.519]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.519]                     cond$call), session = sessionInformation(), 
[18:04:18.519]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.519]                   signalCondition(cond)
[18:04:18.519]                 }
[18:04:18.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.519]                 "immediateCondition"))) {
[18:04:18.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.519]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.519]                   if (TRUE && !signal) {
[18:04:18.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.519]                     {
[18:04:18.519]                       inherits <- base::inherits
[18:04:18.519]                       invokeRestart <- base::invokeRestart
[18:04:18.519]                       is.null <- base::is.null
[18:04:18.519]                       muffled <- FALSE
[18:04:18.519]                       if (inherits(cond, "message")) {
[18:04:18.519]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.519]                         if (muffled) 
[18:04:18.519]                           invokeRestart("muffleMessage")
[18:04:18.519]                       }
[18:04:18.519]                       else if (inherits(cond, "warning")) {
[18:04:18.519]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.519]                         if (muffled) 
[18:04:18.519]                           invokeRestart("muffleWarning")
[18:04:18.519]                       }
[18:04:18.519]                       else if (inherits(cond, "condition")) {
[18:04:18.519]                         if (!is.null(pattern)) {
[18:04:18.519]                           computeRestarts <- base::computeRestarts
[18:04:18.519]                           grepl <- base::grepl
[18:04:18.519]                           restarts <- computeRestarts(cond)
[18:04:18.519]                           for (restart in restarts) {
[18:04:18.519]                             name <- restart$name
[18:04:18.519]                             if (is.null(name)) 
[18:04:18.519]                               next
[18:04:18.519]                             if (!grepl(pattern, name)) 
[18:04:18.519]                               next
[18:04:18.519]                             invokeRestart(restart)
[18:04:18.519]                             muffled <- TRUE
[18:04:18.519]                             break
[18:04:18.519]                           }
[18:04:18.519]                         }
[18:04:18.519]                       }
[18:04:18.519]                       invisible(muffled)
[18:04:18.519]                     }
[18:04:18.519]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.519]                   }
[18:04:18.519]                 }
[18:04:18.519]                 else {
[18:04:18.519]                   if (TRUE) {
[18:04:18.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.519]                     {
[18:04:18.519]                       inherits <- base::inherits
[18:04:18.519]                       invokeRestart <- base::invokeRestart
[18:04:18.519]                       is.null <- base::is.null
[18:04:18.519]                       muffled <- FALSE
[18:04:18.519]                       if (inherits(cond, "message")) {
[18:04:18.519]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.519]                         if (muffled) 
[18:04:18.519]                           invokeRestart("muffleMessage")
[18:04:18.519]                       }
[18:04:18.519]                       else if (inherits(cond, "warning")) {
[18:04:18.519]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.519]                         if (muffled) 
[18:04:18.519]                           invokeRestart("muffleWarning")
[18:04:18.519]                       }
[18:04:18.519]                       else if (inherits(cond, "condition")) {
[18:04:18.519]                         if (!is.null(pattern)) {
[18:04:18.519]                           computeRestarts <- base::computeRestarts
[18:04:18.519]                           grepl <- base::grepl
[18:04:18.519]                           restarts <- computeRestarts(cond)
[18:04:18.519]                           for (restart in restarts) {
[18:04:18.519]                             name <- restart$name
[18:04:18.519]                             if (is.null(name)) 
[18:04:18.519]                               next
[18:04:18.519]                             if (!grepl(pattern, name)) 
[18:04:18.519]                               next
[18:04:18.519]                             invokeRestart(restart)
[18:04:18.519]                             muffled <- TRUE
[18:04:18.519]                             break
[18:04:18.519]                           }
[18:04:18.519]                         }
[18:04:18.519]                       }
[18:04:18.519]                       invisible(muffled)
[18:04:18.519]                     }
[18:04:18.519]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.519]                   }
[18:04:18.519]                 }
[18:04:18.519]             }
[18:04:18.519]         }))
[18:04:18.519]     }, error = function(ex) {
[18:04:18.519]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.519]                 ...future.rng), started = ...future.startTime, 
[18:04:18.519]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.519]             version = "1.8"), class = "FutureResult")
[18:04:18.519]     }, finally = {
[18:04:18.519]         if (!identical(...future.workdir, getwd())) 
[18:04:18.519]             setwd(...future.workdir)
[18:04:18.519]         {
[18:04:18.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.519]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.519]             }
[18:04:18.519]             base::options(...future.oldOptions)
[18:04:18.519]             if (.Platform$OS.type == "windows") {
[18:04:18.519]                 old_names <- names(...future.oldEnvVars)
[18:04:18.519]                 envs <- base::Sys.getenv()
[18:04:18.519]                 names <- names(envs)
[18:04:18.519]                 common <- intersect(names, old_names)
[18:04:18.519]                 added <- setdiff(names, old_names)
[18:04:18.519]                 removed <- setdiff(old_names, names)
[18:04:18.519]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.519]                   envs[common]]
[18:04:18.519]                 NAMES <- toupper(changed)
[18:04:18.519]                 args <- list()
[18:04:18.519]                 for (kk in seq_along(NAMES)) {
[18:04:18.519]                   name <- changed[[kk]]
[18:04:18.519]                   NAME <- NAMES[[kk]]
[18:04:18.519]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.519]                     next
[18:04:18.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.519]                 }
[18:04:18.519]                 NAMES <- toupper(added)
[18:04:18.519]                 for (kk in seq_along(NAMES)) {
[18:04:18.519]                   name <- added[[kk]]
[18:04:18.519]                   NAME <- NAMES[[kk]]
[18:04:18.519]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.519]                     next
[18:04:18.519]                   args[[name]] <- ""
[18:04:18.519]                 }
[18:04:18.519]                 NAMES <- toupper(removed)
[18:04:18.519]                 for (kk in seq_along(NAMES)) {
[18:04:18.519]                   name <- removed[[kk]]
[18:04:18.519]                   NAME <- NAMES[[kk]]
[18:04:18.519]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.519]                     next
[18:04:18.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.519]                 }
[18:04:18.519]                 if (length(args) > 0) 
[18:04:18.519]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.519]             }
[18:04:18.519]             else {
[18:04:18.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.519]             }
[18:04:18.519]             {
[18:04:18.519]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.519]                   0L) {
[18:04:18.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.519]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.519]                   base::options(opts)
[18:04:18.519]                 }
[18:04:18.519]                 {
[18:04:18.519]                   {
[18:04:18.519]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.519]                     NULL
[18:04:18.519]                   }
[18:04:18.519]                   options(future.plan = NULL)
[18:04:18.519]                   if (is.na(NA_character_)) 
[18:04:18.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.519]                     .init = FALSE)
[18:04:18.519]                 }
[18:04:18.519]             }
[18:04:18.519]         }
[18:04:18.519]     })
[18:04:18.519]     if (TRUE) {
[18:04:18.519]         base::sink(type = "output", split = FALSE)
[18:04:18.519]         if (TRUE) {
[18:04:18.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.519]         }
[18:04:18.519]         else {
[18:04:18.519]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.519]         }
[18:04:18.519]         base::close(...future.stdout)
[18:04:18.519]         ...future.stdout <- NULL
[18:04:18.519]     }
[18:04:18.519]     ...future.result$conditions <- ...future.conditions
[18:04:18.519]     ...future.result$finished <- base::Sys.time()
[18:04:18.519]     ...future.result
[18:04:18.519] }
[18:04:18.526] requestCore(): workers = 2
[18:04:18.527] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:18.538] result() for MulticoreFuture ...
[18:04:18.542] result() for MulticoreFuture ...
[18:04:18.542] result() for MulticoreFuture ... done
[18:04:18.542] result() for MulticoreFuture ... done
[18:04:18.543] result() for MulticoreFuture ...
[18:04:18.543] result() for MulticoreFuture ... done
[18:04:18.548] MulticoreFuture started
[18:04:18.549] - Launch lazy future ... done
[18:04:18.549] run() for ‘MulticoreFuture’ ... done
[18:04:18.550] plan(): Setting new future strategy stack:
<environment: 0x5e3c2c8c4130> 
[18:04:18.550] List of future strategies:
[18:04:18.550] 1. sequential:
[18:04:18.550]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:18.550]    - tweaked: FALSE
[18:04:18.550]    - call: NULL
[18:04:18.553] plan(): nbrOfWorkers() = 1
<environment: 0x5e3c2d368f90> 
[18:04:18.557] plan(): Setting new future strategy stack:
[18:04:18.557] List of future strategies:
[18:04:18.557] 1. multicore:
[18:04:18.557]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:18.557]    - tweaked: FALSE
[18:04:18.557]    - call: plan(strategy)
[18:04:18.567] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:18.572] resolve() on environment ...
[18:04:18.572]  recursive: 0
[18:04:18.574]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:18.574] signalConditionsASAP(numeric, pos=1) ...
[18:04:18.574] - nx: 4
[18:04:18.575] - relay: TRUE
[18:04:18.575] - stdout: TRUE
[18:04:18.575] - signal: TRUE
[18:04:18.576] - resignal: FALSE
[18:04:18.576] - force: TRUE
[18:04:18.576] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:18.576] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:18.577]  - until=2
[18:04:18.577]  - relaying element #2
[18:04:18.577] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:18.578] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:18.588] signalConditionsASAP(NULL, pos=1) ... done
[18:04:18.588]  length: 3 (resolved future 1)
[18:04:18.588] Future #2
[18:04:18.589] result() for MulticoreFuture ...
[18:04:18.589] result() for MulticoreFuture ... done
[18:04:18.589] result() for MulticoreFuture ...
[18:04:18.590] result() for MulticoreFuture ... done
[18:04:18.590] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:18.590] - nx: 4
[18:04:18.591] - relay: TRUE
[18:04:18.591] - stdout: TRUE
[18:04:18.591] - signal: TRUE
[18:04:18.591] - resignal: FALSE
[18:04:18.592] - force: TRUE
[18:04:18.592] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:18.592] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:18.593]  - until=2
[18:04:18.593]  - relaying element #2
[18:04:18.593] result() for MulticoreFuture ...
[18:04:18.593] result() for MulticoreFuture ... done
[18:04:18.594] result() for MulticoreFuture ...
[18:04:18.594] result() for MulticoreFuture ... done
[18:04:18.594] result() for MulticoreFuture ...
[18:04:18.595] result() for MulticoreFuture ... done
[18:04:18.595] result() for MulticoreFuture ...
[18:04:18.595] result() for MulticoreFuture ... done
[18:04:18.596] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:18.596] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:18.596] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:18.597]  length: 2 (resolved future 2)
[18:04:18.597] Future #3
[18:04:18.598] result() for MulticoreFuture ...
[18:04:18.599] result() for MulticoreFuture ...
[18:04:18.600] result() for MulticoreFuture ... done
[18:04:18.600] result() for MulticoreFuture ... done
[18:04:18.600] result() for MulticoreFuture ...
[18:04:18.601] result() for MulticoreFuture ... done
[18:04:18.601] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:18.601] - nx: 4
[18:04:18.602] - relay: TRUE
[18:04:18.602] - stdout: TRUE
[18:04:18.602] - signal: TRUE
[18:04:18.602] - resignal: FALSE
[18:04:18.603] - force: TRUE
[18:04:18.603] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:18.603] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:18.603]  - until=3
[18:04:18.604]  - relaying element #3
[18:04:18.604] result() for MulticoreFuture ...
[18:04:18.604] result() for MulticoreFuture ... done
[18:04:18.605] result() for MulticoreFuture ...
[18:04:18.605] result() for MulticoreFuture ... done
[18:04:18.605] result() for MulticoreFuture ...
[18:04:18.606] result() for MulticoreFuture ... done
[18:04:18.606] result() for MulticoreFuture ...
[18:04:18.606] result() for MulticoreFuture ... done
[18:04:18.606] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:18.607] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:18.607] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:18.607]  length: 1 (resolved future 3)
[18:04:18.608] Future #4
[18:04:18.608] result() for MulticoreFuture ...
[18:04:18.609] result() for MulticoreFuture ...
[18:04:18.610] result() for MulticoreFuture ... done
[18:04:18.611] result() for MulticoreFuture ... done
[18:04:18.612] result() for MulticoreFuture ...
[18:04:18.612] result() for MulticoreFuture ... done
[18:04:18.612] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:18.612] - nx: 4
[18:04:18.613] - relay: TRUE
[18:04:18.613] - stdout: TRUE
[18:04:18.613] - signal: TRUE
[18:04:18.613] - resignal: FALSE
[18:04:18.613] - force: TRUE
[18:04:18.614] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:18.614] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:18.614]  - until=4
[18:04:18.614]  - relaying element #4
[18:04:18.615] result() for MulticoreFuture ...
[18:04:18.615] result() for MulticoreFuture ... done
[18:04:18.615] result() for MulticoreFuture ...
[18:04:18.615] result() for MulticoreFuture ... done
[18:04:18.616] result() for MulticoreFuture ...
[18:04:18.616] result() for MulticoreFuture ... done
[18:04:18.616] result() for MulticoreFuture ...
[18:04:18.616] result() for MulticoreFuture ... done
[18:04:18.616] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:18.617] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:18.617] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:18.617]  length: 0 (resolved future 4)
[18:04:18.617] Relaying remaining futures
[18:04:18.618] signalConditionsASAP(NULL, pos=0) ...
[18:04:18.618] - nx: 4
[18:04:18.618] - relay: TRUE
[18:04:18.618] - stdout: TRUE
[18:04:18.618] - signal: TRUE
[18:04:18.619] - resignal: FALSE
[18:04:18.619] - force: TRUE
[18:04:18.619] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:18.619] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:18.620] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:18.620] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:18.620] signalConditionsASAP(NULL, pos=0) ... done
[18:04:18.620] resolve() on environment ... DONE
[18:04:18.620] result() for MulticoreFuture ...
[18:04:18.621] result() for MulticoreFuture ... done
[18:04:18.621] result() for MulticoreFuture ...
[18:04:18.621] result() for MulticoreFuture ... done
[18:04:18.621] result() for MulticoreFuture ...
[18:04:18.622] result() for MulticoreFuture ... done
[18:04:18.622] result() for MulticoreFuture ...
[18:04:18.622] result() for MulticoreFuture ... done
[18:04:18.622] result() for MulticoreFuture ...
[18:04:18.622] result() for MulticoreFuture ... done
[18:04:18.623] result() for MulticoreFuture ...
[18:04:18.623] result() for MulticoreFuture ... done
<environment: 0x5e3c2d422958> 
Dimensions: c(1, 6)
[18:04:18.624] getGlobalsAndPackages() ...
[18:04:18.624] Searching for globals...
[18:04:18.625] 
[18:04:18.625] Searching for globals ... DONE
[18:04:18.625] - globals: [0] <none>
[18:04:18.626] getGlobalsAndPackages() ... DONE
[18:04:18.626] run() for ‘Future’ ...
[18:04:18.626] - state: ‘created’
[18:04:18.627] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.634] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:18.634]   - Field: ‘label’
[18:04:18.635]   - Field: ‘local’
[18:04:18.635]   - Field: ‘owner’
[18:04:18.635]   - Field: ‘envir’
[18:04:18.635]   - Field: ‘workers’
[18:04:18.635]   - Field: ‘packages’
[18:04:18.636]   - Field: ‘gc’
[18:04:18.636]   - Field: ‘job’
[18:04:18.636]   - Field: ‘conditions’
[18:04:18.636]   - Field: ‘expr’
[18:04:18.637]   - Field: ‘uuid’
[18:04:18.637]   - Field: ‘seed’
[18:04:18.637]   - Field: ‘version’
[18:04:18.637]   - Field: ‘result’
[18:04:18.638]   - Field: ‘asynchronous’
[18:04:18.638]   - Field: ‘calls’
[18:04:18.638]   - Field: ‘globals’
[18:04:18.638]   - Field: ‘stdout’
[18:04:18.638]   - Field: ‘earlySignal’
[18:04:18.639]   - Field: ‘lazy’
[18:04:18.639]   - Field: ‘state’
[18:04:18.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:18.639] - Launch lazy future ...
[18:04:18.640] Packages needed by the future expression (n = 0): <none>
[18:04:18.640] Packages needed by future strategies (n = 0): <none>
[18:04:18.641] {
[18:04:18.641]     {
[18:04:18.641]         {
[18:04:18.641]             ...future.startTime <- base::Sys.time()
[18:04:18.641]             {
[18:04:18.641]                 {
[18:04:18.641]                   {
[18:04:18.641]                     {
[18:04:18.641]                       base::local({
[18:04:18.641]                         has_future <- base::requireNamespace("future", 
[18:04:18.641]                           quietly = TRUE)
[18:04:18.641]                         if (has_future) {
[18:04:18.641]                           ns <- base::getNamespace("future")
[18:04:18.641]                           version <- ns[[".package"]][["version"]]
[18:04:18.641]                           if (is.null(version)) 
[18:04:18.641]                             version <- utils::packageVersion("future")
[18:04:18.641]                         }
[18:04:18.641]                         else {
[18:04:18.641]                           version <- NULL
[18:04:18.641]                         }
[18:04:18.641]                         if (!has_future || version < "1.8.0") {
[18:04:18.641]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.641]                             "", base::R.version$version.string), 
[18:04:18.641]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.641]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.641]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.641]                               "release", "version")], collapse = " "), 
[18:04:18.641]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.641]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.641]                             info)
[18:04:18.641]                           info <- base::paste(info, collapse = "; ")
[18:04:18.641]                           if (!has_future) {
[18:04:18.641]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.641]                               info)
[18:04:18.641]                           }
[18:04:18.641]                           else {
[18:04:18.641]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.641]                               info, version)
[18:04:18.641]                           }
[18:04:18.641]                           base::stop(msg)
[18:04:18.641]                         }
[18:04:18.641]                       })
[18:04:18.641]                     }
[18:04:18.641]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.641]                     base::options(mc.cores = 1L)
[18:04:18.641]                   }
[18:04:18.641]                   ...future.strategy.old <- future::plan("list")
[18:04:18.641]                   options(future.plan = NULL)
[18:04:18.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.641]                 }
[18:04:18.641]                 ...future.workdir <- getwd()
[18:04:18.641]             }
[18:04:18.641]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.641]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.641]         }
[18:04:18.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.641]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.641]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.641]             base::names(...future.oldOptions))
[18:04:18.641]     }
[18:04:18.641]     if (FALSE) {
[18:04:18.641]     }
[18:04:18.641]     else {
[18:04:18.641]         if (TRUE) {
[18:04:18.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.641]                 open = "w")
[18:04:18.641]         }
[18:04:18.641]         else {
[18:04:18.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.641]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.641]         }
[18:04:18.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.641]             base::sink(type = "output", split = FALSE)
[18:04:18.641]             base::close(...future.stdout)
[18:04:18.641]         }, add = TRUE)
[18:04:18.641]     }
[18:04:18.641]     ...future.frame <- base::sys.nframe()
[18:04:18.641]     ...future.conditions <- base::list()
[18:04:18.641]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.641]     if (FALSE) {
[18:04:18.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.641]     }
[18:04:18.641]     ...future.result <- base::tryCatch({
[18:04:18.641]         base::withCallingHandlers({
[18:04:18.641]             ...future.value <- base::withVisible(base::local({
[18:04:18.641]                 withCallingHandlers({
[18:04:18.641]                   2
[18:04:18.641]                 }, immediateCondition = function(cond) {
[18:04:18.641]                   save_rds <- function (object, pathname, ...) 
[18:04:18.641]                   {
[18:04:18.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:18.641]                     if (file_test("-f", pathname_tmp)) {
[18:04:18.641]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:18.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.641]                         fi_tmp[["mtime"]])
[18:04:18.641]                     }
[18:04:18.641]                     tryCatch({
[18:04:18.641]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:18.641]                     }, error = function(ex) {
[18:04:18.641]                       msg <- conditionMessage(ex)
[18:04:18.641]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:18.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.641]                         fi_tmp[["mtime"]], msg)
[18:04:18.641]                       ex$message <- msg
[18:04:18.641]                       stop(ex)
[18:04:18.641]                     })
[18:04:18.641]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:18.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:18.641]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:18.641]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.641]                       fi <- file.info(pathname)
[18:04:18.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:18.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:18.641]                         fi[["size"]], fi[["mtime"]])
[18:04:18.641]                       stop(msg)
[18:04:18.641]                     }
[18:04:18.641]                     invisible(pathname)
[18:04:18.641]                   }
[18:04:18.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:18.641]                     rootPath = tempdir()) 
[18:04:18.641]                   {
[18:04:18.641]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:18.641]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:18.641]                       tmpdir = path, fileext = ".rds")
[18:04:18.641]                     save_rds(obj, file)
[18:04:18.641]                   }
[18:04:18.641]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:18.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.641]                   {
[18:04:18.641]                     inherits <- base::inherits
[18:04:18.641]                     invokeRestart <- base::invokeRestart
[18:04:18.641]                     is.null <- base::is.null
[18:04:18.641]                     muffled <- FALSE
[18:04:18.641]                     if (inherits(cond, "message")) {
[18:04:18.641]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.641]                       if (muffled) 
[18:04:18.641]                         invokeRestart("muffleMessage")
[18:04:18.641]                     }
[18:04:18.641]                     else if (inherits(cond, "warning")) {
[18:04:18.641]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.641]                       if (muffled) 
[18:04:18.641]                         invokeRestart("muffleWarning")
[18:04:18.641]                     }
[18:04:18.641]                     else if (inherits(cond, "condition")) {
[18:04:18.641]                       if (!is.null(pattern)) {
[18:04:18.641]                         computeRestarts <- base::computeRestarts
[18:04:18.641]                         grepl <- base::grepl
[18:04:18.641]                         restarts <- computeRestarts(cond)
[18:04:18.641]                         for (restart in restarts) {
[18:04:18.641]                           name <- restart$name
[18:04:18.641]                           if (is.null(name)) 
[18:04:18.641]                             next
[18:04:18.641]                           if (!grepl(pattern, name)) 
[18:04:18.641]                             next
[18:04:18.641]                           invokeRestart(restart)
[18:04:18.641]                           muffled <- TRUE
[18:04:18.641]                           break
[18:04:18.641]                         }
[18:04:18.641]                       }
[18:04:18.641]                     }
[18:04:18.641]                     invisible(muffled)
[18:04:18.641]                   }
[18:04:18.641]                   muffleCondition(cond)
[18:04:18.641]                 })
[18:04:18.641]             }))
[18:04:18.641]             future::FutureResult(value = ...future.value$value, 
[18:04:18.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.641]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.641]                     ...future.globalenv.names))
[18:04:18.641]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.641]         }, condition = base::local({
[18:04:18.641]             c <- base::c
[18:04:18.641]             inherits <- base::inherits
[18:04:18.641]             invokeRestart <- base::invokeRestart
[18:04:18.641]             length <- base::length
[18:04:18.641]             list <- base::list
[18:04:18.641]             seq.int <- base::seq.int
[18:04:18.641]             signalCondition <- base::signalCondition
[18:04:18.641]             sys.calls <- base::sys.calls
[18:04:18.641]             `[[` <- base::`[[`
[18:04:18.641]             `+` <- base::`+`
[18:04:18.641]             `<<-` <- base::`<<-`
[18:04:18.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.641]                   3L)]
[18:04:18.641]             }
[18:04:18.641]             function(cond) {
[18:04:18.641]                 is_error <- inherits(cond, "error")
[18:04:18.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.641]                   NULL)
[18:04:18.641]                 if (is_error) {
[18:04:18.641]                   sessionInformation <- function() {
[18:04:18.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.641]                       search = base::search(), system = base::Sys.info())
[18:04:18.641]                   }
[18:04:18.641]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.641]                     cond$call), session = sessionInformation(), 
[18:04:18.641]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.641]                   signalCondition(cond)
[18:04:18.641]                 }
[18:04:18.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.641]                 "immediateCondition"))) {
[18:04:18.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.641]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.641]                   if (TRUE && !signal) {
[18:04:18.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.641]                     {
[18:04:18.641]                       inherits <- base::inherits
[18:04:18.641]                       invokeRestart <- base::invokeRestart
[18:04:18.641]                       is.null <- base::is.null
[18:04:18.641]                       muffled <- FALSE
[18:04:18.641]                       if (inherits(cond, "message")) {
[18:04:18.641]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.641]                         if (muffled) 
[18:04:18.641]                           invokeRestart("muffleMessage")
[18:04:18.641]                       }
[18:04:18.641]                       else if (inherits(cond, "warning")) {
[18:04:18.641]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.641]                         if (muffled) 
[18:04:18.641]                           invokeRestart("muffleWarning")
[18:04:18.641]                       }
[18:04:18.641]                       else if (inherits(cond, "condition")) {
[18:04:18.641]                         if (!is.null(pattern)) {
[18:04:18.641]                           computeRestarts <- base::computeRestarts
[18:04:18.641]                           grepl <- base::grepl
[18:04:18.641]                           restarts <- computeRestarts(cond)
[18:04:18.641]                           for (restart in restarts) {
[18:04:18.641]                             name <- restart$name
[18:04:18.641]                             if (is.null(name)) 
[18:04:18.641]                               next
[18:04:18.641]                             if (!grepl(pattern, name)) 
[18:04:18.641]                               next
[18:04:18.641]                             invokeRestart(restart)
[18:04:18.641]                             muffled <- TRUE
[18:04:18.641]                             break
[18:04:18.641]                           }
[18:04:18.641]                         }
[18:04:18.641]                       }
[18:04:18.641]                       invisible(muffled)
[18:04:18.641]                     }
[18:04:18.641]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.641]                   }
[18:04:18.641]                 }
[18:04:18.641]                 else {
[18:04:18.641]                   if (TRUE) {
[18:04:18.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.641]                     {
[18:04:18.641]                       inherits <- base::inherits
[18:04:18.641]                       invokeRestart <- base::invokeRestart
[18:04:18.641]                       is.null <- base::is.null
[18:04:18.641]                       muffled <- FALSE
[18:04:18.641]                       if (inherits(cond, "message")) {
[18:04:18.641]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.641]                         if (muffled) 
[18:04:18.641]                           invokeRestart("muffleMessage")
[18:04:18.641]                       }
[18:04:18.641]                       else if (inherits(cond, "warning")) {
[18:04:18.641]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.641]                         if (muffled) 
[18:04:18.641]                           invokeRestart("muffleWarning")
[18:04:18.641]                       }
[18:04:18.641]                       else if (inherits(cond, "condition")) {
[18:04:18.641]                         if (!is.null(pattern)) {
[18:04:18.641]                           computeRestarts <- base::computeRestarts
[18:04:18.641]                           grepl <- base::grepl
[18:04:18.641]                           restarts <- computeRestarts(cond)
[18:04:18.641]                           for (restart in restarts) {
[18:04:18.641]                             name <- restart$name
[18:04:18.641]                             if (is.null(name)) 
[18:04:18.641]                               next
[18:04:18.641]                             if (!grepl(pattern, name)) 
[18:04:18.641]                               next
[18:04:18.641]                             invokeRestart(restart)
[18:04:18.641]                             muffled <- TRUE
[18:04:18.641]                             break
[18:04:18.641]                           }
[18:04:18.641]                         }
[18:04:18.641]                       }
[18:04:18.641]                       invisible(muffled)
[18:04:18.641]                     }
[18:04:18.641]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.641]                   }
[18:04:18.641]                 }
[18:04:18.641]             }
[18:04:18.641]         }))
[18:04:18.641]     }, error = function(ex) {
[18:04:18.641]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.641]                 ...future.rng), started = ...future.startTime, 
[18:04:18.641]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.641]             version = "1.8"), class = "FutureResult")
[18:04:18.641]     }, finally = {
[18:04:18.641]         if (!identical(...future.workdir, getwd())) 
[18:04:18.641]             setwd(...future.workdir)
[18:04:18.641]         {
[18:04:18.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.641]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.641]             }
[18:04:18.641]             base::options(...future.oldOptions)
[18:04:18.641]             if (.Platform$OS.type == "windows") {
[18:04:18.641]                 old_names <- names(...future.oldEnvVars)
[18:04:18.641]                 envs <- base::Sys.getenv()
[18:04:18.641]                 names <- names(envs)
[18:04:18.641]                 common <- intersect(names, old_names)
[18:04:18.641]                 added <- setdiff(names, old_names)
[18:04:18.641]                 removed <- setdiff(old_names, names)
[18:04:18.641]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.641]                   envs[common]]
[18:04:18.641]                 NAMES <- toupper(changed)
[18:04:18.641]                 args <- list()
[18:04:18.641]                 for (kk in seq_along(NAMES)) {
[18:04:18.641]                   name <- changed[[kk]]
[18:04:18.641]                   NAME <- NAMES[[kk]]
[18:04:18.641]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.641]                     next
[18:04:18.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.641]                 }
[18:04:18.641]                 NAMES <- toupper(added)
[18:04:18.641]                 for (kk in seq_along(NAMES)) {
[18:04:18.641]                   name <- added[[kk]]
[18:04:18.641]                   NAME <- NAMES[[kk]]
[18:04:18.641]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.641]                     next
[18:04:18.641]                   args[[name]] <- ""
[18:04:18.641]                 }
[18:04:18.641]                 NAMES <- toupper(removed)
[18:04:18.641]                 for (kk in seq_along(NAMES)) {
[18:04:18.641]                   name <- removed[[kk]]
[18:04:18.641]                   NAME <- NAMES[[kk]]
[18:04:18.641]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.641]                     next
[18:04:18.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.641]                 }
[18:04:18.641]                 if (length(args) > 0) 
[18:04:18.641]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.641]             }
[18:04:18.641]             else {
[18:04:18.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.641]             }
[18:04:18.641]             {
[18:04:18.641]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.641]                   0L) {
[18:04:18.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.641]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.641]                   base::options(opts)
[18:04:18.641]                 }
[18:04:18.641]                 {
[18:04:18.641]                   {
[18:04:18.641]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.641]                     NULL
[18:04:18.641]                   }
[18:04:18.641]                   options(future.plan = NULL)
[18:04:18.641]                   if (is.na(NA_character_)) 
[18:04:18.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.641]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.641]                     .init = FALSE)
[18:04:18.641]                 }
[18:04:18.641]             }
[18:04:18.641]         }
[18:04:18.641]     })
[18:04:18.641]     if (TRUE) {
[18:04:18.641]         base::sink(type = "output", split = FALSE)
[18:04:18.641]         if (TRUE) {
[18:04:18.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.641]         }
[18:04:18.641]         else {
[18:04:18.641]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.641]         }
[18:04:18.641]         base::close(...future.stdout)
[18:04:18.641]         ...future.stdout <- NULL
[18:04:18.641]     }
[18:04:18.641]     ...future.result$conditions <- ...future.conditions
[18:04:18.641]     ...future.result$finished <- base::Sys.time()
[18:04:18.641]     ...future.result
[18:04:18.641] }
[18:04:18.646] requestCore(): workers = 2
[18:04:18.650] MulticoreFuture started
[18:04:18.651] - Launch lazy future ... done
[18:04:18.651] run() for ‘MulticoreFuture’ ... done
[18:04:18.652] getGlobalsAndPackages() ...
[18:04:18.652] plan(): Setting new future strategy stack:
[18:04:18.652] Searching for globals...
[18:04:18.652] List of future strategies:
[18:04:18.652] 1. sequential:
[18:04:18.652]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:18.652]    - tweaked: FALSE
[18:04:18.652]    - call: NULL
[18:04:18.654] 
[18:04:18.654] Searching for globals ... DONE
[18:04:18.654] plan(): nbrOfWorkers() = 1
[18:04:18.655] - globals: [0] <none>
[18:04:18.655] getGlobalsAndPackages() ... DONE
[18:04:18.656] run() for ‘Future’ ...
[18:04:18.656] - state: ‘created’
[18:04:18.657] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.658] plan(): Setting new future strategy stack:
[18:04:18.658] List of future strategies:
[18:04:18.658] 1. multicore:
[18:04:18.658]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:18.658]    - tweaked: FALSE
[18:04:18.658]    - call: plan(strategy)
[18:04:18.666] plan(): nbrOfWorkers() = 2
[18:04:18.666] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:18.667]   - Field: ‘label’
[18:04:18.668]   - Field: ‘local’
[18:04:18.668]   - Field: ‘owner’
[18:04:18.668]   - Field: ‘envir’
[18:04:18.669]   - Field: ‘workers’
[18:04:18.669]   - Field: ‘packages’
[18:04:18.670]   - Field: ‘gc’
[18:04:18.670]   - Field: ‘job’
[18:04:18.670]   - Field: ‘conditions’
[18:04:18.671]   - Field: ‘expr’
[18:04:18.671]   - Field: ‘uuid’
[18:04:18.672]   - Field: ‘seed’
[18:04:18.672]   - Field: ‘version’
[18:04:18.672]   - Field: ‘result’
[18:04:18.673]   - Field: ‘asynchronous’
[18:04:18.673]   - Field: ‘calls’
[18:04:18.674]   - Field: ‘globals’
[18:04:18.674]   - Field: ‘stdout’
[18:04:18.674]   - Field: ‘earlySignal’
[18:04:18.675]   - Field: ‘lazy’
[18:04:18.675]   - Field: ‘state’
[18:04:18.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:18.676] - Launch lazy future ...
[18:04:18.677] Packages needed by the future expression (n = 0): <none>
[18:04:18.677] Packages needed by future strategies (n = 0): <none>
[18:04:18.679] {
[18:04:18.679]     {
[18:04:18.679]         {
[18:04:18.679]             ...future.startTime <- base::Sys.time()
[18:04:18.679]             {
[18:04:18.679]                 {
[18:04:18.679]                   {
[18:04:18.679]                     {
[18:04:18.679]                       base::local({
[18:04:18.679]                         has_future <- base::requireNamespace("future", 
[18:04:18.679]                           quietly = TRUE)
[18:04:18.679]                         if (has_future) {
[18:04:18.679]                           ns <- base::getNamespace("future")
[18:04:18.679]                           version <- ns[[".package"]][["version"]]
[18:04:18.679]                           if (is.null(version)) 
[18:04:18.679]                             version <- utils::packageVersion("future")
[18:04:18.679]                         }
[18:04:18.679]                         else {
[18:04:18.679]                           version <- NULL
[18:04:18.679]                         }
[18:04:18.679]                         if (!has_future || version < "1.8.0") {
[18:04:18.679]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.679]                             "", base::R.version$version.string), 
[18:04:18.679]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.679]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.679]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.679]                               "release", "version")], collapse = " "), 
[18:04:18.679]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.679]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.679]                             info)
[18:04:18.679]                           info <- base::paste(info, collapse = "; ")
[18:04:18.679]                           if (!has_future) {
[18:04:18.679]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.679]                               info)
[18:04:18.679]                           }
[18:04:18.679]                           else {
[18:04:18.679]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.679]                               info, version)
[18:04:18.679]                           }
[18:04:18.679]                           base::stop(msg)
[18:04:18.679]                         }
[18:04:18.679]                       })
[18:04:18.679]                     }
[18:04:18.679]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.679]                     base::options(mc.cores = 1L)
[18:04:18.679]                   }
[18:04:18.679]                   ...future.strategy.old <- future::plan("list")
[18:04:18.679]                   options(future.plan = NULL)
[18:04:18.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.679]                 }
[18:04:18.679]                 ...future.workdir <- getwd()
[18:04:18.679]             }
[18:04:18.679]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.679]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.679]         }
[18:04:18.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.679]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.679]             base::names(...future.oldOptions))
[18:04:18.679]     }
[18:04:18.679]     if (FALSE) {
[18:04:18.679]     }
[18:04:18.679]     else {
[18:04:18.679]         if (TRUE) {
[18:04:18.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.679]                 open = "w")
[18:04:18.679]         }
[18:04:18.679]         else {
[18:04:18.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.679]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.679]         }
[18:04:18.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.679]             base::sink(type = "output", split = FALSE)
[18:04:18.679]             base::close(...future.stdout)
[18:04:18.679]         }, add = TRUE)
[18:04:18.679]     }
[18:04:18.679]     ...future.frame <- base::sys.nframe()
[18:04:18.679]     ...future.conditions <- base::list()
[18:04:18.679]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.679]     if (FALSE) {
[18:04:18.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.679]     }
[18:04:18.679]     ...future.result <- base::tryCatch({
[18:04:18.679]         base::withCallingHandlers({
[18:04:18.679]             ...future.value <- base::withVisible(base::local({
[18:04:18.679]                 withCallingHandlers({
[18:04:18.679]                   NULL
[18:04:18.679]                 }, immediateCondition = function(cond) {
[18:04:18.679]                   save_rds <- function (object, pathname, ...) 
[18:04:18.679]                   {
[18:04:18.679]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:18.679]                     if (file_test("-f", pathname_tmp)) {
[18:04:18.679]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.679]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:18.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.679]                         fi_tmp[["mtime"]])
[18:04:18.679]                     }
[18:04:18.679]                     tryCatch({
[18:04:18.679]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:18.679]                     }, error = function(ex) {
[18:04:18.679]                       msg <- conditionMessage(ex)
[18:04:18.679]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.679]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:18.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.679]                         fi_tmp[["mtime"]], msg)
[18:04:18.679]                       ex$message <- msg
[18:04:18.679]                       stop(ex)
[18:04:18.679]                     })
[18:04:18.679]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:18.679]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:18.679]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:18.679]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.679]                       fi <- file.info(pathname)
[18:04:18.679]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:18.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.679]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:18.679]                         fi[["size"]], fi[["mtime"]])
[18:04:18.679]                       stop(msg)
[18:04:18.679]                     }
[18:04:18.679]                     invisible(pathname)
[18:04:18.679]                   }
[18:04:18.679]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:18.679]                     rootPath = tempdir()) 
[18:04:18.679]                   {
[18:04:18.679]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:18.679]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:18.679]                       tmpdir = path, fileext = ".rds")
[18:04:18.679]                     save_rds(obj, file)
[18:04:18.679]                   }
[18:04:18.679]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:18.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.679]                   {
[18:04:18.679]                     inherits <- base::inherits
[18:04:18.679]                     invokeRestart <- base::invokeRestart
[18:04:18.679]                     is.null <- base::is.null
[18:04:18.679]                     muffled <- FALSE
[18:04:18.679]                     if (inherits(cond, "message")) {
[18:04:18.679]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.679]                       if (muffled) 
[18:04:18.679]                         invokeRestart("muffleMessage")
[18:04:18.679]                     }
[18:04:18.679]                     else if (inherits(cond, "warning")) {
[18:04:18.679]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.679]                       if (muffled) 
[18:04:18.679]                         invokeRestart("muffleWarning")
[18:04:18.679]                     }
[18:04:18.679]                     else if (inherits(cond, "condition")) {
[18:04:18.679]                       if (!is.null(pattern)) {
[18:04:18.679]                         computeRestarts <- base::computeRestarts
[18:04:18.679]                         grepl <- base::grepl
[18:04:18.679]                         restarts <- computeRestarts(cond)
[18:04:18.679]                         for (restart in restarts) {
[18:04:18.679]                           name <- restart$name
[18:04:18.679]                           if (is.null(name)) 
[18:04:18.679]                             next
[18:04:18.679]                           if (!grepl(pattern, name)) 
[18:04:18.679]                             next
[18:04:18.679]                           invokeRestart(restart)
[18:04:18.679]                           muffled <- TRUE
[18:04:18.679]                           break
[18:04:18.679]                         }
[18:04:18.679]                       }
[18:04:18.679]                     }
[18:04:18.679]                     invisible(muffled)
[18:04:18.679]                   }
[18:04:18.679]                   muffleCondition(cond)
[18:04:18.679]                 })
[18:04:18.679]             }))
[18:04:18.679]             future::FutureResult(value = ...future.value$value, 
[18:04:18.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.679]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.679]                     ...future.globalenv.names))
[18:04:18.679]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.679]         }, condition = base::local({
[18:04:18.679]             c <- base::c
[18:04:18.679]             inherits <- base::inherits
[18:04:18.679]             invokeRestart <- base::invokeRestart
[18:04:18.679]             length <- base::length
[18:04:18.679]             list <- base::list
[18:04:18.679]             seq.int <- base::seq.int
[18:04:18.679]             signalCondition <- base::signalCondition
[18:04:18.679]             sys.calls <- base::sys.calls
[18:04:18.679]             `[[` <- base::`[[`
[18:04:18.679]             `+` <- base::`+`
[18:04:18.679]             `<<-` <- base::`<<-`
[18:04:18.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.679]                   3L)]
[18:04:18.679]             }
[18:04:18.679]             function(cond) {
[18:04:18.679]                 is_error <- inherits(cond, "error")
[18:04:18.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.679]                   NULL)
[18:04:18.679]                 if (is_error) {
[18:04:18.679]                   sessionInformation <- function() {
[18:04:18.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.679]                       search = base::search(), system = base::Sys.info())
[18:04:18.679]                   }
[18:04:18.679]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.679]                     cond$call), session = sessionInformation(), 
[18:04:18.679]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.679]                   signalCondition(cond)
[18:04:18.679]                 }
[18:04:18.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.679]                 "immediateCondition"))) {
[18:04:18.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.679]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.679]                   if (TRUE && !signal) {
[18:04:18.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.679]                     {
[18:04:18.679]                       inherits <- base::inherits
[18:04:18.679]                       invokeRestart <- base::invokeRestart
[18:04:18.679]                       is.null <- base::is.null
[18:04:18.679]                       muffled <- FALSE
[18:04:18.679]                       if (inherits(cond, "message")) {
[18:04:18.679]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.679]                         if (muffled) 
[18:04:18.679]                           invokeRestart("muffleMessage")
[18:04:18.679]                       }
[18:04:18.679]                       else if (inherits(cond, "warning")) {
[18:04:18.679]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.679]                         if (muffled) 
[18:04:18.679]                           invokeRestart("muffleWarning")
[18:04:18.679]                       }
[18:04:18.679]                       else if (inherits(cond, "condition")) {
[18:04:18.679]                         if (!is.null(pattern)) {
[18:04:18.679]                           computeRestarts <- base::computeRestarts
[18:04:18.679]                           grepl <- base::grepl
[18:04:18.679]                           restarts <- computeRestarts(cond)
[18:04:18.679]                           for (restart in restarts) {
[18:04:18.679]                             name <- restart$name
[18:04:18.679]                             if (is.null(name)) 
[18:04:18.679]                               next
[18:04:18.679]                             if (!grepl(pattern, name)) 
[18:04:18.679]                               next
[18:04:18.679]                             invokeRestart(restart)
[18:04:18.679]                             muffled <- TRUE
[18:04:18.679]                             break
[18:04:18.679]                           }
[18:04:18.679]                         }
[18:04:18.679]                       }
[18:04:18.679]                       invisible(muffled)
[18:04:18.679]                     }
[18:04:18.679]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.679]                   }
[18:04:18.679]                 }
[18:04:18.679]                 else {
[18:04:18.679]                   if (TRUE) {
[18:04:18.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.679]                     {
[18:04:18.679]                       inherits <- base::inherits
[18:04:18.679]                       invokeRestart <- base::invokeRestart
[18:04:18.679]                       is.null <- base::is.null
[18:04:18.679]                       muffled <- FALSE
[18:04:18.679]                       if (inherits(cond, "message")) {
[18:04:18.679]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.679]                         if (muffled) 
[18:04:18.679]                           invokeRestart("muffleMessage")
[18:04:18.679]                       }
[18:04:18.679]                       else if (inherits(cond, "warning")) {
[18:04:18.679]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.679]                         if (muffled) 
[18:04:18.679]                           invokeRestart("muffleWarning")
[18:04:18.679]                       }
[18:04:18.679]                       else if (inherits(cond, "condition")) {
[18:04:18.679]                         if (!is.null(pattern)) {
[18:04:18.679]                           computeRestarts <- base::computeRestarts
[18:04:18.679]                           grepl <- base::grepl
[18:04:18.679]                           restarts <- computeRestarts(cond)
[18:04:18.679]                           for (restart in restarts) {
[18:04:18.679]                             name <- restart$name
[18:04:18.679]                             if (is.null(name)) 
[18:04:18.679]                               next
[18:04:18.679]                             if (!grepl(pattern, name)) 
[18:04:18.679]                               next
[18:04:18.679]                             invokeRestart(restart)
[18:04:18.679]                             muffled <- TRUE
[18:04:18.679]                             break
[18:04:18.679]                           }
[18:04:18.679]                         }
[18:04:18.679]                       }
[18:04:18.679]                       invisible(muffled)
[18:04:18.679]                     }
[18:04:18.679]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.679]                   }
[18:04:18.679]                 }
[18:04:18.679]             }
[18:04:18.679]         }))
[18:04:18.679]     }, error = function(ex) {
[18:04:18.679]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.679]                 ...future.rng), started = ...future.startTime, 
[18:04:18.679]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.679]             version = "1.8"), class = "FutureResult")
[18:04:18.679]     }, finally = {
[18:04:18.679]         if (!identical(...future.workdir, getwd())) 
[18:04:18.679]             setwd(...future.workdir)
[18:04:18.679]         {
[18:04:18.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.679]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.679]             }
[18:04:18.679]             base::options(...future.oldOptions)
[18:04:18.679]             if (.Platform$OS.type == "windows") {
[18:04:18.679]                 old_names <- names(...future.oldEnvVars)
[18:04:18.679]                 envs <- base::Sys.getenv()
[18:04:18.679]                 names <- names(envs)
[18:04:18.679]                 common <- intersect(names, old_names)
[18:04:18.679]                 added <- setdiff(names, old_names)
[18:04:18.679]                 removed <- setdiff(old_names, names)
[18:04:18.679]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.679]                   envs[common]]
[18:04:18.679]                 NAMES <- toupper(changed)
[18:04:18.679]                 args <- list()
[18:04:18.679]                 for (kk in seq_along(NAMES)) {
[18:04:18.679]                   name <- changed[[kk]]
[18:04:18.679]                   NAME <- NAMES[[kk]]
[18:04:18.679]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.679]                     next
[18:04:18.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.679]                 }
[18:04:18.679]                 NAMES <- toupper(added)
[18:04:18.679]                 for (kk in seq_along(NAMES)) {
[18:04:18.679]                   name <- added[[kk]]
[18:04:18.679]                   NAME <- NAMES[[kk]]
[18:04:18.679]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.679]                     next
[18:04:18.679]                   args[[name]] <- ""
[18:04:18.679]                 }
[18:04:18.679]                 NAMES <- toupper(removed)
[18:04:18.679]                 for (kk in seq_along(NAMES)) {
[18:04:18.679]                   name <- removed[[kk]]
[18:04:18.679]                   NAME <- NAMES[[kk]]
[18:04:18.679]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.679]                     next
[18:04:18.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.679]                 }
[18:04:18.679]                 if (length(args) > 0) 
[18:04:18.679]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.679]             }
[18:04:18.679]             else {
[18:04:18.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.679]             }
[18:04:18.679]             {
[18:04:18.679]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.679]                   0L) {
[18:04:18.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.679]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.679]                   base::options(opts)
[18:04:18.679]                 }
[18:04:18.679]                 {
[18:04:18.679]                   {
[18:04:18.679]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.679]                     NULL
[18:04:18.679]                   }
[18:04:18.679]                   options(future.plan = NULL)
[18:04:18.679]                   if (is.na(NA_character_)) 
[18:04:18.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.679]                     .init = FALSE)
[18:04:18.679]                 }
[18:04:18.679]             }
[18:04:18.679]         }
[18:04:18.679]     })
[18:04:18.679]     if (TRUE) {
[18:04:18.679]         base::sink(type = "output", split = FALSE)
[18:04:18.679]         if (TRUE) {
[18:04:18.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.679]         }
[18:04:18.679]         else {
[18:04:18.679]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.679]         }
[18:04:18.679]         base::close(...future.stdout)
[18:04:18.679]         ...future.stdout <- NULL
[18:04:18.679]     }
[18:04:18.679]     ...future.result$conditions <- ...future.conditions
[18:04:18.679]     ...future.result$finished <- base::Sys.time()
[18:04:18.679]     ...future.result
[18:04:18.679] }
[18:04:18.685] requestCore(): workers = 2
[18:04:18.690] MulticoreFuture started
[18:04:18.691] - Launch lazy future ... done
[18:04:18.691] run() for ‘MulticoreFuture’ ... done
[18:04:18.692] plan(): Setting new future strategy stack:
[18:04:18.693] getGlobalsAndPackages() ...
[18:04:18.694] Searching for globals...
[18:04:18.693] List of future strategies:
[18:04:18.693] 1. sequential:
[18:04:18.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:18.693]    - tweaked: FALSE
[18:04:18.693]    - call: NULL
[18:04:18.695] plan(): nbrOfWorkers() = 1
[18:04:18.697] - globals found: [1] ‘{’
[18:04:18.697] Searching for globals ... DONE
[18:04:18.697] Resolving globals: FALSE
[18:04:18.699] 
[18:04:18.699] 
[18:04:18.699] getGlobalsAndPackages() ... DONE
[18:04:18.699] plan(): Setting new future strategy stack:
[18:04:18.700] run() for ‘Future’ ...
[18:04:18.700] List of future strategies:
[18:04:18.700] 1. multicore:
[18:04:18.700]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:18.700]    - tweaked: FALSE
[18:04:18.700]    - call: plan(strategy)
[18:04:18.701] - state: ‘created’
[18:04:18.701] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.709] plan(): nbrOfWorkers() = 2
[18:04:18.710] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:18.710]   - Field: ‘label’
[18:04:18.711]   - Field: ‘local’
[18:04:18.711]   - Field: ‘owner’
[18:04:18.711]   - Field: ‘envir’
[18:04:18.712]   - Field: ‘workers’
[18:04:18.712]   - Field: ‘packages’
[18:04:18.712]   - Field: ‘gc’
[18:04:18.713]   - Field: ‘job’
[18:04:18.713]   - Field: ‘conditions’
[18:04:18.713]   - Field: ‘expr’
[18:04:18.714]   - Field: ‘uuid’
[18:04:18.714]   - Field: ‘seed’
[18:04:18.714]   - Field: ‘version’
[18:04:18.714]   - Field: ‘result’
[18:04:18.715]   - Field: ‘asynchronous’
[18:04:18.715]   - Field: ‘calls’
[18:04:18.715]   - Field: ‘globals’
[18:04:18.716]   - Field: ‘stdout’
[18:04:18.716]   - Field: ‘earlySignal’
[18:04:18.716]   - Field: ‘lazy’
[18:04:18.717]   - Field: ‘state’
[18:04:18.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:18.717] - Launch lazy future ...
[18:04:18.718] Packages needed by the future expression (n = 0): <none>
[18:04:18.718] Packages needed by future strategies (n = 0): <none>
[18:04:18.720] {
[18:04:18.720]     {
[18:04:18.720]         {
[18:04:18.720]             ...future.startTime <- base::Sys.time()
[18:04:18.720]             {
[18:04:18.720]                 {
[18:04:18.720]                   {
[18:04:18.720]                     {
[18:04:18.720]                       base::local({
[18:04:18.720]                         has_future <- base::requireNamespace("future", 
[18:04:18.720]                           quietly = TRUE)
[18:04:18.720]                         if (has_future) {
[18:04:18.720]                           ns <- base::getNamespace("future")
[18:04:18.720]                           version <- ns[[".package"]][["version"]]
[18:04:18.720]                           if (is.null(version)) 
[18:04:18.720]                             version <- utils::packageVersion("future")
[18:04:18.720]                         }
[18:04:18.720]                         else {
[18:04:18.720]                           version <- NULL
[18:04:18.720]                         }
[18:04:18.720]                         if (!has_future || version < "1.8.0") {
[18:04:18.720]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.720]                             "", base::R.version$version.string), 
[18:04:18.720]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.720]                               "release", "version")], collapse = " "), 
[18:04:18.720]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.720]                             info)
[18:04:18.720]                           info <- base::paste(info, collapse = "; ")
[18:04:18.720]                           if (!has_future) {
[18:04:18.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.720]                               info)
[18:04:18.720]                           }
[18:04:18.720]                           else {
[18:04:18.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.720]                               info, version)
[18:04:18.720]                           }
[18:04:18.720]                           base::stop(msg)
[18:04:18.720]                         }
[18:04:18.720]                       })
[18:04:18.720]                     }
[18:04:18.720]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.720]                     base::options(mc.cores = 1L)
[18:04:18.720]                   }
[18:04:18.720]                   ...future.strategy.old <- future::plan("list")
[18:04:18.720]                   options(future.plan = NULL)
[18:04:18.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.720]                 }
[18:04:18.720]                 ...future.workdir <- getwd()
[18:04:18.720]             }
[18:04:18.720]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.720]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.720]         }
[18:04:18.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.720]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.720]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.720]             base::names(...future.oldOptions))
[18:04:18.720]     }
[18:04:18.720]     if (FALSE) {
[18:04:18.720]     }
[18:04:18.720]     else {
[18:04:18.720]         if (TRUE) {
[18:04:18.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.720]                 open = "w")
[18:04:18.720]         }
[18:04:18.720]         else {
[18:04:18.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.720]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.720]         }
[18:04:18.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.720]             base::sink(type = "output", split = FALSE)
[18:04:18.720]             base::close(...future.stdout)
[18:04:18.720]         }, add = TRUE)
[18:04:18.720]     }
[18:04:18.720]     ...future.frame <- base::sys.nframe()
[18:04:18.720]     ...future.conditions <- base::list()
[18:04:18.720]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.720]     if (FALSE) {
[18:04:18.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.720]     }
[18:04:18.720]     ...future.result <- base::tryCatch({
[18:04:18.720]         base::withCallingHandlers({
[18:04:18.720]             ...future.value <- base::withVisible(base::local({
[18:04:18.720]                 withCallingHandlers({
[18:04:18.720]                   {
[18:04:18.720]                     4
[18:04:18.720]                   }
[18:04:18.720]                 }, immediateCondition = function(cond) {
[18:04:18.720]                   save_rds <- function (object, pathname, ...) 
[18:04:18.720]                   {
[18:04:18.720]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:18.720]                     if (file_test("-f", pathname_tmp)) {
[18:04:18.720]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.720]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:18.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.720]                         fi_tmp[["mtime"]])
[18:04:18.720]                     }
[18:04:18.720]                     tryCatch({
[18:04:18.720]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:18.720]                     }, error = function(ex) {
[18:04:18.720]                       msg <- conditionMessage(ex)
[18:04:18.720]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.720]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:18.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.720]                         fi_tmp[["mtime"]], msg)
[18:04:18.720]                       ex$message <- msg
[18:04:18.720]                       stop(ex)
[18:04:18.720]                     })
[18:04:18.720]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:18.720]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:18.720]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:18.720]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.720]                       fi <- file.info(pathname)
[18:04:18.720]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:18.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.720]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:18.720]                         fi[["size"]], fi[["mtime"]])
[18:04:18.720]                       stop(msg)
[18:04:18.720]                     }
[18:04:18.720]                     invisible(pathname)
[18:04:18.720]                   }
[18:04:18.720]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:18.720]                     rootPath = tempdir()) 
[18:04:18.720]                   {
[18:04:18.720]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:18.720]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:18.720]                       tmpdir = path, fileext = ".rds")
[18:04:18.720]                     save_rds(obj, file)
[18:04:18.720]                   }
[18:04:18.720]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:18.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.720]                   {
[18:04:18.720]                     inherits <- base::inherits
[18:04:18.720]                     invokeRestart <- base::invokeRestart
[18:04:18.720]                     is.null <- base::is.null
[18:04:18.720]                     muffled <- FALSE
[18:04:18.720]                     if (inherits(cond, "message")) {
[18:04:18.720]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.720]                       if (muffled) 
[18:04:18.720]                         invokeRestart("muffleMessage")
[18:04:18.720]                     }
[18:04:18.720]                     else if (inherits(cond, "warning")) {
[18:04:18.720]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.720]                       if (muffled) 
[18:04:18.720]                         invokeRestart("muffleWarning")
[18:04:18.720]                     }
[18:04:18.720]                     else if (inherits(cond, "condition")) {
[18:04:18.720]                       if (!is.null(pattern)) {
[18:04:18.720]                         computeRestarts <- base::computeRestarts
[18:04:18.720]                         grepl <- base::grepl
[18:04:18.720]                         restarts <- computeRestarts(cond)
[18:04:18.720]                         for (restart in restarts) {
[18:04:18.720]                           name <- restart$name
[18:04:18.720]                           if (is.null(name)) 
[18:04:18.720]                             next
[18:04:18.720]                           if (!grepl(pattern, name)) 
[18:04:18.720]                             next
[18:04:18.720]                           invokeRestart(restart)
[18:04:18.720]                           muffled <- TRUE
[18:04:18.720]                           break
[18:04:18.720]                         }
[18:04:18.720]                       }
[18:04:18.720]                     }
[18:04:18.720]                     invisible(muffled)
[18:04:18.720]                   }
[18:04:18.720]                   muffleCondition(cond)
[18:04:18.720]                 })
[18:04:18.720]             }))
[18:04:18.720]             future::FutureResult(value = ...future.value$value, 
[18:04:18.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.720]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.720]                     ...future.globalenv.names))
[18:04:18.720]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.720]         }, condition = base::local({
[18:04:18.720]             c <- base::c
[18:04:18.720]             inherits <- base::inherits
[18:04:18.720]             invokeRestart <- base::invokeRestart
[18:04:18.720]             length <- base::length
[18:04:18.720]             list <- base::list
[18:04:18.720]             seq.int <- base::seq.int
[18:04:18.720]             signalCondition <- base::signalCondition
[18:04:18.720]             sys.calls <- base::sys.calls
[18:04:18.720]             `[[` <- base::`[[`
[18:04:18.720]             `+` <- base::`+`
[18:04:18.720]             `<<-` <- base::`<<-`
[18:04:18.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.720]                   3L)]
[18:04:18.720]             }
[18:04:18.720]             function(cond) {
[18:04:18.720]                 is_error <- inherits(cond, "error")
[18:04:18.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.720]                   NULL)
[18:04:18.720]                 if (is_error) {
[18:04:18.720]                   sessionInformation <- function() {
[18:04:18.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.720]                       search = base::search(), system = base::Sys.info())
[18:04:18.720]                   }
[18:04:18.720]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.720]                     cond$call), session = sessionInformation(), 
[18:04:18.720]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.720]                   signalCondition(cond)
[18:04:18.720]                 }
[18:04:18.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.720]                 "immediateCondition"))) {
[18:04:18.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.720]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.720]                   if (TRUE && !signal) {
[18:04:18.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.720]                     {
[18:04:18.720]                       inherits <- base::inherits
[18:04:18.720]                       invokeRestart <- base::invokeRestart
[18:04:18.720]                       is.null <- base::is.null
[18:04:18.720]                       muffled <- FALSE
[18:04:18.720]                       if (inherits(cond, "message")) {
[18:04:18.720]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.720]                         if (muffled) 
[18:04:18.720]                           invokeRestart("muffleMessage")
[18:04:18.720]                       }
[18:04:18.720]                       else if (inherits(cond, "warning")) {
[18:04:18.720]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.720]                         if (muffled) 
[18:04:18.720]                           invokeRestart("muffleWarning")
[18:04:18.720]                       }
[18:04:18.720]                       else if (inherits(cond, "condition")) {
[18:04:18.720]                         if (!is.null(pattern)) {
[18:04:18.720]                           computeRestarts <- base::computeRestarts
[18:04:18.720]                           grepl <- base::grepl
[18:04:18.720]                           restarts <- computeRestarts(cond)
[18:04:18.720]                           for (restart in restarts) {
[18:04:18.720]                             name <- restart$name
[18:04:18.720]                             if (is.null(name)) 
[18:04:18.720]                               next
[18:04:18.720]                             if (!grepl(pattern, name)) 
[18:04:18.720]                               next
[18:04:18.720]                             invokeRestart(restart)
[18:04:18.720]                             muffled <- TRUE
[18:04:18.720]                             break
[18:04:18.720]                           }
[18:04:18.720]                         }
[18:04:18.720]                       }
[18:04:18.720]                       invisible(muffled)
[18:04:18.720]                     }
[18:04:18.720]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.720]                   }
[18:04:18.720]                 }
[18:04:18.720]                 else {
[18:04:18.720]                   if (TRUE) {
[18:04:18.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.720]                     {
[18:04:18.720]                       inherits <- base::inherits
[18:04:18.720]                       invokeRestart <- base::invokeRestart
[18:04:18.720]                       is.null <- base::is.null
[18:04:18.720]                       muffled <- FALSE
[18:04:18.720]                       if (inherits(cond, "message")) {
[18:04:18.720]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.720]                         if (muffled) 
[18:04:18.720]                           invokeRestart("muffleMessage")
[18:04:18.720]                       }
[18:04:18.720]                       else if (inherits(cond, "warning")) {
[18:04:18.720]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.720]                         if (muffled) 
[18:04:18.720]                           invokeRestart("muffleWarning")
[18:04:18.720]                       }
[18:04:18.720]                       else if (inherits(cond, "condition")) {
[18:04:18.720]                         if (!is.null(pattern)) {
[18:04:18.720]                           computeRestarts <- base::computeRestarts
[18:04:18.720]                           grepl <- base::grepl
[18:04:18.720]                           restarts <- computeRestarts(cond)
[18:04:18.720]                           for (restart in restarts) {
[18:04:18.720]                             name <- restart$name
[18:04:18.720]                             if (is.null(name)) 
[18:04:18.720]                               next
[18:04:18.720]                             if (!grepl(pattern, name)) 
[18:04:18.720]                               next
[18:04:18.720]                             invokeRestart(restart)
[18:04:18.720]                             muffled <- TRUE
[18:04:18.720]                             break
[18:04:18.720]                           }
[18:04:18.720]                         }
[18:04:18.720]                       }
[18:04:18.720]                       invisible(muffled)
[18:04:18.720]                     }
[18:04:18.720]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.720]                   }
[18:04:18.720]                 }
[18:04:18.720]             }
[18:04:18.720]         }))
[18:04:18.720]     }, error = function(ex) {
[18:04:18.720]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.720]                 ...future.rng), started = ...future.startTime, 
[18:04:18.720]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.720]             version = "1.8"), class = "FutureResult")
[18:04:18.720]     }, finally = {
[18:04:18.720]         if (!identical(...future.workdir, getwd())) 
[18:04:18.720]             setwd(...future.workdir)
[18:04:18.720]         {
[18:04:18.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.720]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.720]             }
[18:04:18.720]             base::options(...future.oldOptions)
[18:04:18.720]             if (.Platform$OS.type == "windows") {
[18:04:18.720]                 old_names <- names(...future.oldEnvVars)
[18:04:18.720]                 envs <- base::Sys.getenv()
[18:04:18.720]                 names <- names(envs)
[18:04:18.720]                 common <- intersect(names, old_names)
[18:04:18.720]                 added <- setdiff(names, old_names)
[18:04:18.720]                 removed <- setdiff(old_names, names)
[18:04:18.720]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.720]                   envs[common]]
[18:04:18.720]                 NAMES <- toupper(changed)
[18:04:18.720]                 args <- list()
[18:04:18.720]                 for (kk in seq_along(NAMES)) {
[18:04:18.720]                   name <- changed[[kk]]
[18:04:18.720]                   NAME <- NAMES[[kk]]
[18:04:18.720]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.720]                     next
[18:04:18.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.720]                 }
[18:04:18.720]                 NAMES <- toupper(added)
[18:04:18.720]                 for (kk in seq_along(NAMES)) {
[18:04:18.720]                   name <- added[[kk]]
[18:04:18.720]                   NAME <- NAMES[[kk]]
[18:04:18.720]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.720]                     next
[18:04:18.720]                   args[[name]] <- ""
[18:04:18.720]                 }
[18:04:18.720]                 NAMES <- toupper(removed)
[18:04:18.720]                 for (kk in seq_along(NAMES)) {
[18:04:18.720]                   name <- removed[[kk]]
[18:04:18.720]                   NAME <- NAMES[[kk]]
[18:04:18.720]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.720]                     next
[18:04:18.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.720]                 }
[18:04:18.720]                 if (length(args) > 0) 
[18:04:18.720]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.720]             }
[18:04:18.720]             else {
[18:04:18.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.720]             }
[18:04:18.720]             {
[18:04:18.720]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.720]                   0L) {
[18:04:18.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.720]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.720]                   base::options(opts)
[18:04:18.720]                 }
[18:04:18.720]                 {
[18:04:18.720]                   {
[18:04:18.720]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.720]                     NULL
[18:04:18.720]                   }
[18:04:18.720]                   options(future.plan = NULL)
[18:04:18.720]                   if (is.na(NA_character_)) 
[18:04:18.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.720]                     .init = FALSE)
[18:04:18.720]                 }
[18:04:18.720]             }
[18:04:18.720]         }
[18:04:18.720]     })
[18:04:18.720]     if (TRUE) {
[18:04:18.720]         base::sink(type = "output", split = FALSE)
[18:04:18.720]         if (TRUE) {
[18:04:18.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.720]         }
[18:04:18.720]         else {
[18:04:18.720]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.720]         }
[18:04:18.720]         base::close(...future.stdout)
[18:04:18.720]         ...future.stdout <- NULL
[18:04:18.720]     }
[18:04:18.720]     ...future.result$conditions <- ...future.conditions
[18:04:18.720]     ...future.result$finished <- base::Sys.time()
[18:04:18.720]     ...future.result
[18:04:18.720] }
[18:04:18.726] requestCore(): workers = 2
[18:04:18.727] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:18.765] result() for MulticoreFuture ...
[18:04:18.767] result() for MulticoreFuture ...
[18:04:18.767] result() for MulticoreFuture ... done
[18:04:18.767] result() for MulticoreFuture ... done
[18:04:18.768] result() for MulticoreFuture ...
[18:04:18.768] result() for MulticoreFuture ... done
[18:04:18.773] MulticoreFuture started
[18:04:18.773] - Launch lazy future ... done
[18:04:18.774] run() for ‘MulticoreFuture’ ... done
[18:04:18.775] plan(): Setting new future strategy stack:
<environment: 0x5e3c2b06e678> 
[18:04:18.775] List of future strategies:
[18:04:18.775] 1. sequential:
[18:04:18.775]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:18.775]    - tweaked: FALSE
[18:04:18.775]    - call: NULL
<environment: 0x5e3c2c9aadf0> 
[18:04:18.778] plan(): nbrOfWorkers() = 1
[18:04:18.782] plan(): Setting new future strategy stack:
[18:04:18.782] List of future strategies:
[18:04:18.782] 1. multicore:
[18:04:18.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:18.782]    - tweaked: FALSE
[18:04:18.782]    - call: plan(strategy)
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")=[18:04:18.792] plan(): nbrOfWorkers() = 2
 chr [1:4] "a" "b" "c" "d"
[18:04:18.795] resolve() on environment ...
[18:04:18.795]  recursive: 0
[18:04:18.797]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:18.797] signalConditionsASAP(numeric, pos=1) ...
[18:04:18.798] - nx: 4
[18:04:18.798] - relay: TRUE
[18:04:18.798] - stdout: TRUE
[18:04:18.799] - signal: TRUE
[18:04:18.799] - resignal: FALSE
[18:04:18.799] - force: TRUE
[18:04:18.799] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:18.800] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:18.800]  - until=2
[18:04:18.800]  - relaying element #2
[18:04:18.801] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:18.801] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:18.801] signalConditionsASAP(NULL, pos=1) ... done
[18:04:18.802]  length: 3 (resolved future 1)
[18:04:18.802] Future #2
[18:04:18.802] result() for MulticoreFuture ...
[18:04:18.803] result() for MulticoreFuture ... done
[18:04:18.803] result() for MulticoreFuture ...
[18:04:18.803] result() for MulticoreFuture ... done
[18:04:18.804] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:18.804] - nx: 4
[18:04:18.804] - relay: TRUE
[18:04:18.804] - stdout: TRUE
[18:04:18.805] - signal: TRUE
[18:04:18.805] - resignal: FALSE
[18:04:18.805] - force: TRUE
[18:04:18.806] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:18.806] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:18.806]  - until=2
[18:04:18.806]  - relaying element #2
[18:04:18.807] result() for MulticoreFuture ...
[18:04:18.807] result() for MulticoreFuture ... done
[18:04:18.807] result() for MulticoreFuture ...
[18:04:18.808] result() for MulticoreFuture ... done
[18:04:18.808] result() for MulticoreFuture ...
[18:04:18.808] result() for MulticoreFuture ... done
[18:04:18.809] result() for MulticoreFuture ...
[18:04:18.809] result() for MulticoreFuture ... done
[18:04:18.809] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:18.810] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:18.810] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:18.810]  length: 2 (resolved future 2)
[18:04:18.811] Future #3
[18:04:18.811] result() for MulticoreFuture ...
[18:04:18.813] result() for MulticoreFuture ...
[18:04:18.813] result() for MulticoreFuture ... done
[18:04:18.814] result() for MulticoreFuture ... done
[18:04:18.814] result() for MulticoreFuture ...
[18:04:18.814] result() for MulticoreFuture ... done
[18:04:18.815] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:18.815] - nx: 4
[18:04:18.815] - relay: TRUE
[18:04:18.815] - stdout: TRUE
[18:04:18.816] - signal: TRUE
[18:04:18.816] - resignal: FALSE
[18:04:18.816] - force: TRUE
[18:04:18.816] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:18.817] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:18.817]  - until=3
[18:04:18.817]  - relaying element #3
[18:04:18.818] result() for MulticoreFuture ...
[18:04:18.818] result() for MulticoreFuture ... done
[18:04:18.818] result() for MulticoreFuture ...
[18:04:18.818] result() for MulticoreFuture ... done
[18:04:18.819] result() for MulticoreFuture ...
[18:04:18.819] result() for MulticoreFuture ... done
[18:04:18.819] result() for MulticoreFuture ...
[18:04:18.820] result() for MulticoreFuture ... done
[18:04:18.820] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:18.820] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:18.821] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:18.821]  length: 1 (resolved future 3)
[18:04:18.822] Future #4
[18:04:18.822] result() for MulticoreFuture ...
[18:04:18.823] result() for MulticoreFuture ...
[18:04:18.824] result() for MulticoreFuture ... done
[18:04:18.824] result() for MulticoreFuture ... done
[18:04:18.824] result() for MulticoreFuture ...
[18:04:18.825] result() for MulticoreFuture ... done
[18:04:18.825] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:18.825] - nx: 4
[18:04:18.826] - relay: TRUE
[18:04:18.826] - stdout: TRUE
[18:04:18.826] - signal: TRUE
[18:04:18.826] - resignal: FALSE
[18:04:18.827] - force: TRUE
[18:04:18.827] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:18.827] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:18.827]  - until=4
[18:04:18.828]  - relaying element #4
[18:04:18.828] result() for MulticoreFuture ...
[18:04:18.828] result() for MulticoreFuture ... done
[18:04:18.828] result() for MulticoreFuture ...
[18:04:18.829] result() for MulticoreFuture ... done
[18:04:18.829] result() for MulticoreFuture ...
[18:04:18.829] result() for MulticoreFuture ... done
[18:04:18.829] result() for MulticoreFuture ...
[18:04:18.830] result() for MulticoreFuture ... done
[18:04:18.830] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:18.830] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:18.830] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:18.831]  length: 0 (resolved future 4)
[18:04:18.831] Relaying remaining futures
[18:04:18.831] signalConditionsASAP(NULL, pos=0) ...
[18:04:18.831] - nx: 4
[18:04:18.831] - relay: TRUE
[18:04:18.832] - stdout: TRUE
[18:04:18.832] - signal: TRUE
[18:04:18.832] - resignal: FALSE
[18:04:18.832] - force: TRUE
[18:04:18.832] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:18.833] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:18.833] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:18.833] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:18.833] signalConditionsASAP(NULL, pos=0) ... done
[18:04:18.834] resolve() on environment ... DONE
[18:04:18.834] result() for MulticoreFuture ...
[18:04:18.834] result() for MulticoreFuture ... done
[18:04:18.834] result() for MulticoreFuture ...
[18:04:18.835] result() for MulticoreFuture ... done
[18:04:18.835] result() for MulticoreFuture ...
[18:04:18.835] result() for MulticoreFuture ... done
[18:04:18.835] result() for MulticoreFuture ...
[18:04:18.836] result() for MulticoreFuture ... done
[18:04:18.836] result() for MulticoreFuture ...
[18:04:18.836] result() for MulticoreFuture ... done
[18:04:18.836] result() for MulticoreFuture ...
[18:04:18.837] result() for MulticoreFuture ... done
<environment: 0x5e3c2cad8cc8> 
Dimensions: c(2, 3)
[18:04:18.838] getGlobalsAndPackages() ...
[18:04:18.838] Searching for globals...
[18:04:18.839] 
[18:04:18.839] Searching for globals ... DONE
[18:04:18.839] - globals: [0] <none>
[18:04:18.839] getGlobalsAndPackages() ... DONE
[18:04:18.840] run() for ‘Future’ ...
[18:04:18.840] - state: ‘created’
[18:04:18.841] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.849] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.849] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:18.850]   - Field: ‘label’
[18:04:18.850]   - Field: ‘local’
[18:04:18.850]   - Field: ‘owner’
[18:04:18.851]   - Field: ‘envir’
[18:04:18.851]   - Field: ‘workers’
[18:04:18.851]   - Field: ‘packages’
[18:04:18.851]   - Field: ‘gc’
[18:04:18.852]   - Field: ‘job’
[18:04:18.852]   - Field: ‘conditions’
[18:04:18.852]   - Field: ‘expr’
[18:04:18.852]   - Field: ‘uuid’
[18:04:18.853]   - Field: ‘seed’
[18:04:18.853]   - Field: ‘version’
[18:04:18.853]   - Field: ‘result’
[18:04:18.853]   - Field: ‘asynchronous’
[18:04:18.853]   - Field: ‘calls’
[18:04:18.854]   - Field: ‘globals’
[18:04:18.854]   - Field: ‘stdout’
[18:04:18.854]   - Field: ‘earlySignal’
[18:04:18.854]   - Field: ‘lazy’
[18:04:18.855]   - Field: ‘state’
[18:04:18.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:18.855] - Launch lazy future ...
[18:04:18.856] Packages needed by the future expression (n = 0): <none>
[18:04:18.856] Packages needed by future strategies (n = 0): <none>
[18:04:18.857] {
[18:04:18.857]     {
[18:04:18.857]         {
[18:04:18.857]             ...future.startTime <- base::Sys.time()
[18:04:18.857]             {
[18:04:18.857]                 {
[18:04:18.857]                   {
[18:04:18.857]                     {
[18:04:18.857]                       base::local({
[18:04:18.857]                         has_future <- base::requireNamespace("future", 
[18:04:18.857]                           quietly = TRUE)
[18:04:18.857]                         if (has_future) {
[18:04:18.857]                           ns <- base::getNamespace("future")
[18:04:18.857]                           version <- ns[[".package"]][["version"]]
[18:04:18.857]                           if (is.null(version)) 
[18:04:18.857]                             version <- utils::packageVersion("future")
[18:04:18.857]                         }
[18:04:18.857]                         else {
[18:04:18.857]                           version <- NULL
[18:04:18.857]                         }
[18:04:18.857]                         if (!has_future || version < "1.8.0") {
[18:04:18.857]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.857]                             "", base::R.version$version.string), 
[18:04:18.857]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.857]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.857]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.857]                               "release", "version")], collapse = " "), 
[18:04:18.857]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.857]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.857]                             info)
[18:04:18.857]                           info <- base::paste(info, collapse = "; ")
[18:04:18.857]                           if (!has_future) {
[18:04:18.857]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.857]                               info)
[18:04:18.857]                           }
[18:04:18.857]                           else {
[18:04:18.857]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.857]                               info, version)
[18:04:18.857]                           }
[18:04:18.857]                           base::stop(msg)
[18:04:18.857]                         }
[18:04:18.857]                       })
[18:04:18.857]                     }
[18:04:18.857]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.857]                     base::options(mc.cores = 1L)
[18:04:18.857]                   }
[18:04:18.857]                   ...future.strategy.old <- future::plan("list")
[18:04:18.857]                   options(future.plan = NULL)
[18:04:18.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.857]                 }
[18:04:18.857]                 ...future.workdir <- getwd()
[18:04:18.857]             }
[18:04:18.857]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.857]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.857]         }
[18:04:18.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.857]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.857]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.857]             base::names(...future.oldOptions))
[18:04:18.857]     }
[18:04:18.857]     if (FALSE) {
[18:04:18.857]     }
[18:04:18.857]     else {
[18:04:18.857]         if (TRUE) {
[18:04:18.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.857]                 open = "w")
[18:04:18.857]         }
[18:04:18.857]         else {
[18:04:18.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.857]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.857]         }
[18:04:18.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.857]             base::sink(type = "output", split = FALSE)
[18:04:18.857]             base::close(...future.stdout)
[18:04:18.857]         }, add = TRUE)
[18:04:18.857]     }
[18:04:18.857]     ...future.frame <- base::sys.nframe()
[18:04:18.857]     ...future.conditions <- base::list()
[18:04:18.857]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.857]     if (FALSE) {
[18:04:18.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.857]     }
[18:04:18.857]     ...future.result <- base::tryCatch({
[18:04:18.857]         base::withCallingHandlers({
[18:04:18.857]             ...future.value <- base::withVisible(base::local({
[18:04:18.857]                 withCallingHandlers({
[18:04:18.857]                   2
[18:04:18.857]                 }, immediateCondition = function(cond) {
[18:04:18.857]                   save_rds <- function (object, pathname, ...) 
[18:04:18.857]                   {
[18:04:18.857]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:18.857]                     if (file_test("-f", pathname_tmp)) {
[18:04:18.857]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.857]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:18.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.857]                         fi_tmp[["mtime"]])
[18:04:18.857]                     }
[18:04:18.857]                     tryCatch({
[18:04:18.857]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:18.857]                     }, error = function(ex) {
[18:04:18.857]                       msg <- conditionMessage(ex)
[18:04:18.857]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.857]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:18.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.857]                         fi_tmp[["mtime"]], msg)
[18:04:18.857]                       ex$message <- msg
[18:04:18.857]                       stop(ex)
[18:04:18.857]                     })
[18:04:18.857]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:18.857]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:18.857]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:18.857]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.857]                       fi <- file.info(pathname)
[18:04:18.857]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:18.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.857]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:18.857]                         fi[["size"]], fi[["mtime"]])
[18:04:18.857]                       stop(msg)
[18:04:18.857]                     }
[18:04:18.857]                     invisible(pathname)
[18:04:18.857]                   }
[18:04:18.857]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:18.857]                     rootPath = tempdir()) 
[18:04:18.857]                   {
[18:04:18.857]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:18.857]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:18.857]                       tmpdir = path, fileext = ".rds")
[18:04:18.857]                     save_rds(obj, file)
[18:04:18.857]                   }
[18:04:18.857]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:18.857]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.857]                   {
[18:04:18.857]                     inherits <- base::inherits
[18:04:18.857]                     invokeRestart <- base::invokeRestart
[18:04:18.857]                     is.null <- base::is.null
[18:04:18.857]                     muffled <- FALSE
[18:04:18.857]                     if (inherits(cond, "message")) {
[18:04:18.857]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.857]                       if (muffled) 
[18:04:18.857]                         invokeRestart("muffleMessage")
[18:04:18.857]                     }
[18:04:18.857]                     else if (inherits(cond, "warning")) {
[18:04:18.857]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.857]                       if (muffled) 
[18:04:18.857]                         invokeRestart("muffleWarning")
[18:04:18.857]                     }
[18:04:18.857]                     else if (inherits(cond, "condition")) {
[18:04:18.857]                       if (!is.null(pattern)) {
[18:04:18.857]                         computeRestarts <- base::computeRestarts
[18:04:18.857]                         grepl <- base::grepl
[18:04:18.857]                         restarts <- computeRestarts(cond)
[18:04:18.857]                         for (restart in restarts) {
[18:04:18.857]                           name <- restart$name
[18:04:18.857]                           if (is.null(name)) 
[18:04:18.857]                             next
[18:04:18.857]                           if (!grepl(pattern, name)) 
[18:04:18.857]                             next
[18:04:18.857]                           invokeRestart(restart)
[18:04:18.857]                           muffled <- TRUE
[18:04:18.857]                           break
[18:04:18.857]                         }
[18:04:18.857]                       }
[18:04:18.857]                     }
[18:04:18.857]                     invisible(muffled)
[18:04:18.857]                   }
[18:04:18.857]                   muffleCondition(cond)
[18:04:18.857]                 })
[18:04:18.857]             }))
[18:04:18.857]             future::FutureResult(value = ...future.value$value, 
[18:04:18.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.857]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.857]                     ...future.globalenv.names))
[18:04:18.857]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.857]         }, condition = base::local({
[18:04:18.857]             c <- base::c
[18:04:18.857]             inherits <- base::inherits
[18:04:18.857]             invokeRestart <- base::invokeRestart
[18:04:18.857]             length <- base::length
[18:04:18.857]             list <- base::list
[18:04:18.857]             seq.int <- base::seq.int
[18:04:18.857]             signalCondition <- base::signalCondition
[18:04:18.857]             sys.calls <- base::sys.calls
[18:04:18.857]             `[[` <- base::`[[`
[18:04:18.857]             `+` <- base::`+`
[18:04:18.857]             `<<-` <- base::`<<-`
[18:04:18.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.857]                   3L)]
[18:04:18.857]             }
[18:04:18.857]             function(cond) {
[18:04:18.857]                 is_error <- inherits(cond, "error")
[18:04:18.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.857]                   NULL)
[18:04:18.857]                 if (is_error) {
[18:04:18.857]                   sessionInformation <- function() {
[18:04:18.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.857]                       search = base::search(), system = base::Sys.info())
[18:04:18.857]                   }
[18:04:18.857]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.857]                     cond$call), session = sessionInformation(), 
[18:04:18.857]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.857]                   signalCondition(cond)
[18:04:18.857]                 }
[18:04:18.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.857]                 "immediateCondition"))) {
[18:04:18.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.857]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.857]                   if (TRUE && !signal) {
[18:04:18.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.857]                     {
[18:04:18.857]                       inherits <- base::inherits
[18:04:18.857]                       invokeRestart <- base::invokeRestart
[18:04:18.857]                       is.null <- base::is.null
[18:04:18.857]                       muffled <- FALSE
[18:04:18.857]                       if (inherits(cond, "message")) {
[18:04:18.857]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.857]                         if (muffled) 
[18:04:18.857]                           invokeRestart("muffleMessage")
[18:04:18.857]                       }
[18:04:18.857]                       else if (inherits(cond, "warning")) {
[18:04:18.857]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.857]                         if (muffled) 
[18:04:18.857]                           invokeRestart("muffleWarning")
[18:04:18.857]                       }
[18:04:18.857]                       else if (inherits(cond, "condition")) {
[18:04:18.857]                         if (!is.null(pattern)) {
[18:04:18.857]                           computeRestarts <- base::computeRestarts
[18:04:18.857]                           grepl <- base::grepl
[18:04:18.857]                           restarts <- computeRestarts(cond)
[18:04:18.857]                           for (restart in restarts) {
[18:04:18.857]                             name <- restart$name
[18:04:18.857]                             if (is.null(name)) 
[18:04:18.857]                               next
[18:04:18.857]                             if (!grepl(pattern, name)) 
[18:04:18.857]                               next
[18:04:18.857]                             invokeRestart(restart)
[18:04:18.857]                             muffled <- TRUE
[18:04:18.857]                             break
[18:04:18.857]                           }
[18:04:18.857]                         }
[18:04:18.857]                       }
[18:04:18.857]                       invisible(muffled)
[18:04:18.857]                     }
[18:04:18.857]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.857]                   }
[18:04:18.857]                 }
[18:04:18.857]                 else {
[18:04:18.857]                   if (TRUE) {
[18:04:18.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.857]                     {
[18:04:18.857]                       inherits <- base::inherits
[18:04:18.857]                       invokeRestart <- base::invokeRestart
[18:04:18.857]                       is.null <- base::is.null
[18:04:18.857]                       muffled <- FALSE
[18:04:18.857]                       if (inherits(cond, "message")) {
[18:04:18.857]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.857]                         if (muffled) 
[18:04:18.857]                           invokeRestart("muffleMessage")
[18:04:18.857]                       }
[18:04:18.857]                       else if (inherits(cond, "warning")) {
[18:04:18.857]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.857]                         if (muffled) 
[18:04:18.857]                           invokeRestart("muffleWarning")
[18:04:18.857]                       }
[18:04:18.857]                       else if (inherits(cond, "condition")) {
[18:04:18.857]                         if (!is.null(pattern)) {
[18:04:18.857]                           computeRestarts <- base::computeRestarts
[18:04:18.857]                           grepl <- base::grepl
[18:04:18.857]                           restarts <- computeRestarts(cond)
[18:04:18.857]                           for (restart in restarts) {
[18:04:18.857]                             name <- restart$name
[18:04:18.857]                             if (is.null(name)) 
[18:04:18.857]                               next
[18:04:18.857]                             if (!grepl(pattern, name)) 
[18:04:18.857]                               next
[18:04:18.857]                             invokeRestart(restart)
[18:04:18.857]                             muffled <- TRUE
[18:04:18.857]                             break
[18:04:18.857]                           }
[18:04:18.857]                         }
[18:04:18.857]                       }
[18:04:18.857]                       invisible(muffled)
[18:04:18.857]                     }
[18:04:18.857]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.857]                   }
[18:04:18.857]                 }
[18:04:18.857]             }
[18:04:18.857]         }))
[18:04:18.857]     }, error = function(ex) {
[18:04:18.857]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.857]                 ...future.rng), started = ...future.startTime, 
[18:04:18.857]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.857]             version = "1.8"), class = "FutureResult")
[18:04:18.857]     }, finally = {
[18:04:18.857]         if (!identical(...future.workdir, getwd())) 
[18:04:18.857]             setwd(...future.workdir)
[18:04:18.857]         {
[18:04:18.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.857]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.857]             }
[18:04:18.857]             base::options(...future.oldOptions)
[18:04:18.857]             if (.Platform$OS.type == "windows") {
[18:04:18.857]                 old_names <- names(...future.oldEnvVars)
[18:04:18.857]                 envs <- base::Sys.getenv()
[18:04:18.857]                 names <- names(envs)
[18:04:18.857]                 common <- intersect(names, old_names)
[18:04:18.857]                 added <- setdiff(names, old_names)
[18:04:18.857]                 removed <- setdiff(old_names, names)
[18:04:18.857]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.857]                   envs[common]]
[18:04:18.857]                 NAMES <- toupper(changed)
[18:04:18.857]                 args <- list()
[18:04:18.857]                 for (kk in seq_along(NAMES)) {
[18:04:18.857]                   name <- changed[[kk]]
[18:04:18.857]                   NAME <- NAMES[[kk]]
[18:04:18.857]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.857]                     next
[18:04:18.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.857]                 }
[18:04:18.857]                 NAMES <- toupper(added)
[18:04:18.857]                 for (kk in seq_along(NAMES)) {
[18:04:18.857]                   name <- added[[kk]]
[18:04:18.857]                   NAME <- NAMES[[kk]]
[18:04:18.857]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.857]                     next
[18:04:18.857]                   args[[name]] <- ""
[18:04:18.857]                 }
[18:04:18.857]                 NAMES <- toupper(removed)
[18:04:18.857]                 for (kk in seq_along(NAMES)) {
[18:04:18.857]                   name <- removed[[kk]]
[18:04:18.857]                   NAME <- NAMES[[kk]]
[18:04:18.857]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.857]                     next
[18:04:18.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.857]                 }
[18:04:18.857]                 if (length(args) > 0) 
[18:04:18.857]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.857]             }
[18:04:18.857]             else {
[18:04:18.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.857]             }
[18:04:18.857]             {
[18:04:18.857]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.857]                   0L) {
[18:04:18.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.857]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.857]                   base::options(opts)
[18:04:18.857]                 }
[18:04:18.857]                 {
[18:04:18.857]                   {
[18:04:18.857]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.857]                     NULL
[18:04:18.857]                   }
[18:04:18.857]                   options(future.plan = NULL)
[18:04:18.857]                   if (is.na(NA_character_)) 
[18:04:18.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.857]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.857]                     .init = FALSE)
[18:04:18.857]                 }
[18:04:18.857]             }
[18:04:18.857]         }
[18:04:18.857]     })
[18:04:18.857]     if (TRUE) {
[18:04:18.857]         base::sink(type = "output", split = FALSE)
[18:04:18.857]         if (TRUE) {
[18:04:18.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.857]         }
[18:04:18.857]         else {
[18:04:18.857]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.857]         }
[18:04:18.857]         base::close(...future.stdout)
[18:04:18.857]         ...future.stdout <- NULL
[18:04:18.857]     }
[18:04:18.857]     ...future.result$conditions <- ...future.conditions
[18:04:18.857]     ...future.result$finished <- base::Sys.time()
[18:04:18.857]     ...future.result
[18:04:18.857] }
[18:04:18.862] requestCore(): workers = 2
[18:04:18.867] MulticoreFuture started
[18:04:18.868] - Launch lazy future ... done
[18:04:18.868] run() for ‘MulticoreFuture’ ... done
[18:04:18.869] getGlobalsAndPackages() ...
[18:04:18.869] Searching for globals...
[18:04:18.871] 
[18:04:18.871] Searching for globals ... DONE
[18:04:18.871] - globals: [0] <none>
[18:04:18.871] plan(): Setting new future strategy stack:
[18:04:18.872] List of future strategies:
[18:04:18.872] 1. sequential:
[18:04:18.872]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:18.872]    - tweaked: FALSE
[18:04:18.872]    - call: NULL
[18:04:18.878] plan(): nbrOfWorkers() = 1
[18:04:18.872] getGlobalsAndPackages() ... DONE
[18:04:18.883] run() for ‘Future’ ...
[18:04:18.883] - state: ‘created’
[18:04:18.884] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.893] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.893] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:18.893]   - Field: ‘label’
[18:04:18.894]   - Field: ‘local’
[18:04:18.894]   - Field: ‘owner’
[18:04:18.894]   - Field: ‘envir’
[18:04:18.895]   - Field: ‘workers’
[18:04:18.895]   - Field: ‘packages’
[18:04:18.895]   - Field: ‘gc’
[18:04:18.896]   - Field: ‘job’
[18:04:18.896]   - Field: ‘conditions’
[18:04:18.896]   - Field: ‘expr’
[18:04:18.897]   - Field: ‘uuid’
[18:04:18.897]   - Field: ‘seed’
[18:04:18.897]   - Field: ‘version’
[18:04:18.898]   - Field: ‘result’
[18:04:18.898]   - Field: ‘asynchronous’
[18:04:18.898]   - Field: ‘calls’
[18:04:18.898]   - Field: ‘globals’
[18:04:18.899]   - Field: ‘stdout’
[18:04:18.899] plan(): Setting new future strategy stack:
[18:04:18.899]   - Field: ‘earlySignal’
[18:04:18.899]   - Field: ‘lazy’
[18:04:18.899] List of future strategies:
[18:04:18.899] 1. multicore:
[18:04:18.899]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:18.899]    - tweaked: FALSE
[18:04:18.899]    - call: plan(strategy)
[18:04:18.900]   - Field: ‘state’
[18:04:18.900] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:18.900] - Launch lazy future ...
[18:04:18.901] Packages needed by the future expression (n = 0): <none>
[18:04:18.902] Packages needed by future strategies (n = 0): <none>
[18:04:18.903] {
[18:04:18.903]     {
[18:04:18.903]         {
[18:04:18.903]             ...future.startTime <- base::Sys.time()
[18:04:18.903]             {
[18:04:18.903]                 {
[18:04:18.903]                   {
[18:04:18.903]                     {
[18:04:18.903]                       base::local({
[18:04:18.903]                         has_future <- base::requireNamespace("future", 
[18:04:18.903]                           quietly = TRUE)
[18:04:18.903]                         if (has_future) {
[18:04:18.903]                           ns <- base::getNamespace("future")
[18:04:18.903]                           version <- ns[[".package"]][["version"]]
[18:04:18.903]                           if (is.null(version)) 
[18:04:18.903]                             version <- utils::packageVersion("future")
[18:04:18.903]                         }
[18:04:18.903]                         else {
[18:04:18.903]                           version <- NULL
[18:04:18.903]                         }
[18:04:18.903]                         if (!has_future || version < "1.8.0") {
[18:04:18.903]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.903]                             "", base::R.version$version.string), 
[18:04:18.903]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.903]                               "release", "version")], collapse = " "), 
[18:04:18.903]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.903]                             info)
[18:04:18.903]                           info <- base::paste(info, collapse = "; ")
[18:04:18.903]                           if (!has_future) {
[18:04:18.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.903]                               info)
[18:04:18.903]                           }
[18:04:18.903]                           else {
[18:04:18.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.903]                               info, version)
[18:04:18.903]                           }
[18:04:18.903]                           base::stop(msg)
[18:04:18.903]                         }
[18:04:18.903]                       })
[18:04:18.903]                     }
[18:04:18.903]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.903]                     base::options(mc.cores = 1L)
[18:04:18.903]                   }
[18:04:18.903]                   ...future.strategy.old <- future::plan("list")
[18:04:18.903]                   options(future.plan = NULL)
[18:04:18.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.903]                 }
[18:04:18.903]                 ...future.workdir <- getwd()
[18:04:18.903]             }
[18:04:18.903]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.903]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.903]         }
[18:04:18.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.903]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.903]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.903]             base::names(...future.oldOptions))
[18:04:18.903]     }
[18:04:18.903]     if (FALSE) {
[18:04:18.903]     }
[18:04:18.903]     else {
[18:04:18.903]         if (TRUE) {
[18:04:18.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.903]                 open = "w")
[18:04:18.903]         }
[18:04:18.903]         else {
[18:04:18.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.903]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.903]         }
[18:04:18.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.903]             base::sink(type = "output", split = FALSE)
[18:04:18.903]             base::close(...future.stdout)
[18:04:18.903]         }, add = TRUE)
[18:04:18.903]     }
[18:04:18.903]     ...future.frame <- base::sys.nframe()
[18:04:18.903]     ...future.conditions <- base::list()
[18:04:18.903]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.903]     if (FALSE) {
[18:04:18.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.903]     }
[18:04:18.903]     ...future.result <- base::tryCatch({
[18:04:18.903]         base::withCallingHandlers({
[18:04:18.903]             ...future.value <- base::withVisible(base::local({
[18:04:18.903]                 withCallingHandlers({
[18:04:18.903]                   NULL
[18:04:18.903]                 }, immediateCondition = function(cond) {
[18:04:18.903]                   save_rds <- function (object, pathname, ...) 
[18:04:18.903]                   {
[18:04:18.903]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:18.903]                     if (file_test("-f", pathname_tmp)) {
[18:04:18.903]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.903]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:18.903]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.903]                         fi_tmp[["mtime"]])
[18:04:18.903]                     }
[18:04:18.903]                     tryCatch({
[18:04:18.903]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:18.903]                     }, error = function(ex) {
[18:04:18.903]                       msg <- conditionMessage(ex)
[18:04:18.903]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.903]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:18.903]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.903]                         fi_tmp[["mtime"]], msg)
[18:04:18.903]                       ex$message <- msg
[18:04:18.903]                       stop(ex)
[18:04:18.903]                     })
[18:04:18.903]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:18.903]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:18.903]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:18.903]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.903]                       fi <- file.info(pathname)
[18:04:18.903]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:18.903]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.903]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:18.903]                         fi[["size"]], fi[["mtime"]])
[18:04:18.903]                       stop(msg)
[18:04:18.903]                     }
[18:04:18.903]                     invisible(pathname)
[18:04:18.903]                   }
[18:04:18.903]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:18.903]                     rootPath = tempdir()) 
[18:04:18.903]                   {
[18:04:18.903]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:18.903]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:18.903]                       tmpdir = path, fileext = ".rds")
[18:04:18.903]                     save_rds(obj, file)
[18:04:18.903]                   }
[18:04:18.903]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:18.903]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.903]                   {
[18:04:18.903]                     inherits <- base::inherits
[18:04:18.903]                     invokeRestart <- base::invokeRestart
[18:04:18.903]                     is.null <- base::is.null
[18:04:18.903]                     muffled <- FALSE
[18:04:18.903]                     if (inherits(cond, "message")) {
[18:04:18.903]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.903]                       if (muffled) 
[18:04:18.903]                         invokeRestart("muffleMessage")
[18:04:18.903]                     }
[18:04:18.903]                     else if (inherits(cond, "warning")) {
[18:04:18.903]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.903]                       if (muffled) 
[18:04:18.903]                         invokeRestart("muffleWarning")
[18:04:18.903]                     }
[18:04:18.903]                     else if (inherits(cond, "condition")) {
[18:04:18.903]                       if (!is.null(pattern)) {
[18:04:18.903]                         computeRestarts <- base::computeRestarts
[18:04:18.903]                         grepl <- base::grepl
[18:04:18.903]                         restarts <- computeRestarts(cond)
[18:04:18.903]                         for (restart in restarts) {
[18:04:18.903]                           name <- restart$name
[18:04:18.903]                           if (is.null(name)) 
[18:04:18.903]                             next
[18:04:18.903]                           if (!grepl(pattern, name)) 
[18:04:18.903]                             next
[18:04:18.903]                           invokeRestart(restart)
[18:04:18.903]                           muffled <- TRUE
[18:04:18.903]                           break
[18:04:18.903]                         }
[18:04:18.903]                       }
[18:04:18.903]                     }
[18:04:18.903]                     invisible(muffled)
[18:04:18.903]                   }
[18:04:18.903]                   muffleCondition(cond)
[18:04:18.903]                 })
[18:04:18.903]             }))
[18:04:18.903]             future::FutureResult(value = ...future.value$value, 
[18:04:18.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.903]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.903]                     ...future.globalenv.names))
[18:04:18.903]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.903]         }, condition = base::local({
[18:04:18.903]             c <- base::c
[18:04:18.903]             inherits <- base::inherits
[18:04:18.903]             invokeRestart <- base::invokeRestart
[18:04:18.903]             length <- base::length
[18:04:18.903]             list <- base::list
[18:04:18.903]             seq.int <- base::seq.int
[18:04:18.903]             signalCondition <- base::signalCondition
[18:04:18.903]             sys.calls <- base::sys.calls
[18:04:18.903]             `[[` <- base::`[[`
[18:04:18.903]             `+` <- base::`+`
[18:04:18.903]             `<<-` <- base::`<<-`
[18:04:18.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.903]                   3L)]
[18:04:18.903]             }
[18:04:18.903]             function(cond) {
[18:04:18.903]                 is_error <- inherits(cond, "error")
[18:04:18.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.903]                   NULL)
[18:04:18.903]                 if (is_error) {
[18:04:18.903]                   sessionInformation <- function() {
[18:04:18.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.903]                       search = base::search(), system = base::Sys.info())
[18:04:18.903]                   }
[18:04:18.903]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.903]                     cond$call), session = sessionInformation(), 
[18:04:18.903]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.903]                   signalCondition(cond)
[18:04:18.903]                 }
[18:04:18.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.903]                 "immediateCondition"))) {
[18:04:18.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.903]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.903]                   if (TRUE && !signal) {
[18:04:18.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.903]                     {
[18:04:18.903]                       inherits <- base::inherits
[18:04:18.903]                       invokeRestart <- base::invokeRestart
[18:04:18.903]                       is.null <- base::is.null
[18:04:18.903]                       muffled <- FALSE
[18:04:18.903]                       if (inherits(cond, "message")) {
[18:04:18.903]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.903]                         if (muffled) 
[18:04:18.903]                           invokeRestart("muffleMessage")
[18:04:18.903]                       }
[18:04:18.903]                       else if (inherits(cond, "warning")) {
[18:04:18.903]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.903]                         if (muffled) 
[18:04:18.903]                           invokeRestart("muffleWarning")
[18:04:18.903]                       }
[18:04:18.903]                       else if (inherits(cond, "condition")) {
[18:04:18.903]                         if (!is.null(pattern)) {
[18:04:18.903]                           computeRestarts <- base::computeRestarts
[18:04:18.903]                           grepl <- base::grepl
[18:04:18.903]                           restarts <- computeRestarts(cond)
[18:04:18.903]                           for (restart in restarts) {
[18:04:18.903]                             name <- restart$name
[18:04:18.903]                             if (is.null(name)) 
[18:04:18.903]                               next
[18:04:18.903]                             if (!grepl(pattern, name)) 
[18:04:18.903]                               next
[18:04:18.903]                             invokeRestart(restart)
[18:04:18.903]                             muffled <- TRUE
[18:04:18.903]                             break
[18:04:18.903]                           }
[18:04:18.903]                         }
[18:04:18.903]                       }
[18:04:18.903]                       invisible(muffled)
[18:04:18.903]                     }
[18:04:18.903]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.903]                   }
[18:04:18.903]                 }
[18:04:18.903]                 else {
[18:04:18.903]                   if (TRUE) {
[18:04:18.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.903]                     {
[18:04:18.903]                       inherits <- base::inherits
[18:04:18.903]                       invokeRestart <- base::invokeRestart
[18:04:18.903]                       is.null <- base::is.null
[18:04:18.903]                       muffled <- FALSE
[18:04:18.903]                       if (inherits(cond, "message")) {
[18:04:18.903]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.903]                         if (muffled) 
[18:04:18.903]                           invokeRestart("muffleMessage")
[18:04:18.903]                       }
[18:04:18.903]                       else if (inherits(cond, "warning")) {
[18:04:18.903]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.903]                         if (muffled) 
[18:04:18.903]                           invokeRestart("muffleWarning")
[18:04:18.903]                       }
[18:04:18.903]                       else if (inherits(cond, "condition")) {
[18:04:18.903]                         if (!is.null(pattern)) {
[18:04:18.903]                           computeRestarts <- base::computeRestarts
[18:04:18.903]                           grepl <- base::grepl
[18:04:18.903]                           restarts <- computeRestarts(cond)
[18:04:18.903]                           for (restart in restarts) {
[18:04:18.903]                             name <- restart$name
[18:04:18.903]                             if (is.null(name)) 
[18:04:18.903]                               next
[18:04:18.903]                             if (!grepl(pattern, name)) 
[18:04:18.903]                               next
[18:04:18.903]                             invokeRestart(restart)
[18:04:18.903]                             muffled <- TRUE
[18:04:18.903]                             break
[18:04:18.903]                           }
[18:04:18.903]                         }
[18:04:18.903]                       }
[18:04:18.903]                       invisible(muffled)
[18:04:18.903]                     }
[18:04:18.903]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.903]                   }
[18:04:18.903]                 }
[18:04:18.903]             }
[18:04:18.903]         }))
[18:04:18.903]     }, error = function(ex) {
[18:04:18.903]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.903]                 ...future.rng), started = ...future.startTime, 
[18:04:18.903]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.903]             version = "1.8"), class = "FutureResult")
[18:04:18.903]     }, finally = {
[18:04:18.903]         if (!identical(...future.workdir, getwd())) 
[18:04:18.903]             setwd(...future.workdir)
[18:04:18.903]         {
[18:04:18.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.903]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.903]             }
[18:04:18.903]             base::options(...future.oldOptions)
[18:04:18.903]             if (.Platform$OS.type == "windows") {
[18:04:18.903]                 old_names <- names(...future.oldEnvVars)
[18:04:18.903]                 envs <- base::Sys.getenv()
[18:04:18.903]                 names <- names(envs)
[18:04:18.903]                 common <- intersect(names, old_names)
[18:04:18.903]                 added <- setdiff(names, old_names)
[18:04:18.903]                 removed <- setdiff(old_names, names)
[18:04:18.903]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.903]                   envs[common]]
[18:04:18.903]                 NAMES <- toupper(changed)
[18:04:18.903]                 args <- list()
[18:04:18.903]                 for (kk in seq_along(NAMES)) {
[18:04:18.903]                   name <- changed[[kk]]
[18:04:18.903]                   NAME <- NAMES[[kk]]
[18:04:18.903]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.903]                     next
[18:04:18.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.903]                 }
[18:04:18.903]                 NAMES <- toupper(added)
[18:04:18.903]                 for (kk in seq_along(NAMES)) {
[18:04:18.903]                   name <- added[[kk]]
[18:04:18.903]                   NAME <- NAMES[[kk]]
[18:04:18.903]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.903]                     next
[18:04:18.903]                   args[[name]] <- ""
[18:04:18.903]                 }
[18:04:18.903]                 NAMES <- toupper(removed)
[18:04:18.903]                 for (kk in seq_along(NAMES)) {
[18:04:18.903]                   name <- removed[[kk]]
[18:04:18.903]                   NAME <- NAMES[[kk]]
[18:04:18.903]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.903]                     next
[18:04:18.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.903]                 }
[18:04:18.903]                 if (length(args) > 0) 
[18:04:18.903]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.903]             }
[18:04:18.903]             else {
[18:04:18.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.903]             }
[18:04:18.903]             {
[18:04:18.903]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.903]                   0L) {
[18:04:18.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.903]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.903]                   base::options(opts)
[18:04:18.903]                 }
[18:04:18.903]                 {
[18:04:18.903]                   {
[18:04:18.903]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.903]                     NULL
[18:04:18.903]                   }
[18:04:18.903]                   options(future.plan = NULL)
[18:04:18.903]                   if (is.na(NA_character_)) 
[18:04:18.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.903]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.903]                     .init = FALSE)
[18:04:18.903]                 }
[18:04:18.903]             }
[18:04:18.903]         }
[18:04:18.903]     })
[18:04:18.903]     if (TRUE) {
[18:04:18.903]         base::sink(type = "output", split = FALSE)
[18:04:18.903]         if (TRUE) {
[18:04:18.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.903]         }
[18:04:18.903]         else {
[18:04:18.903]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.903]         }
[18:04:18.903]         base::close(...future.stdout)
[18:04:18.903]         ...future.stdout <- NULL
[18:04:18.903]     }
[18:04:18.903]     ...future.result$conditions <- ...future.conditions
[18:04:18.903]     ...future.result$finished <- base::Sys.time()
[18:04:18.903]     ...future.result
[18:04:18.903] }
[18:04:18.910] requestCore(): workers = 2
[18:04:18.913] plan(): nbrOfWorkers() = 2
[18:04:18.915] MulticoreFuture started
[18:04:18.916] - Launch lazy future ... done
[18:04:18.918] run() for ‘MulticoreFuture’ ... done
[18:04:18.921] plan(): Setting new future strategy stack:
[18:04:18.922] getGlobalsAndPackages() ...
[18:04:18.922] Searching for globals...
[18:04:18.921] List of future strategies:
[18:04:18.921] 1. sequential:
[18:04:18.921]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:18.921]    - tweaked: FALSE
[18:04:18.921]    - call: NULL
[18:04:18.926] plan(): nbrOfWorkers() = 1
[18:04:18.927] - globals found: [1] ‘{’
[18:04:18.930] Searching for globals ... DONE
[18:04:18.930] Resolving globals: FALSE
[18:04:18.932] 
[18:04:18.934] 
[18:04:18.934] getGlobalsAndPackages() ... DONE
[18:04:18.935] run() for ‘Future’ ...
[18:04:18.936] plan(): Setting new future strategy stack:
[18:04:18.936] List of future strategies:
[18:04:18.936] 1. multicore:
[18:04:18.936]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:18.936]    - tweaked: FALSE
[18:04:18.936]    - call: plan(strategy)
[18:04:18.938] - state: ‘created’
[18:04:18.938] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:18.951] plan(): nbrOfWorkers() = 2
[18:04:18.954] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:18.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:18.955]   - Field: ‘label’
[18:04:18.955]   - Field: ‘local’
[18:04:18.955]   - Field: ‘owner’
[18:04:18.956]   - Field: ‘envir’
[18:04:18.956]   - Field: ‘workers’
[18:04:18.956]   - Field: ‘packages’
[18:04:18.957]   - Field: ‘gc’
[18:04:18.957]   - Field: ‘job’
[18:04:18.957]   - Field: ‘conditions’
[18:04:18.958]   - Field: ‘expr’
[18:04:18.958]   - Field: ‘uuid’
[18:04:18.958]   - Field: ‘seed’
[18:04:18.959]   - Field: ‘version’
[18:04:18.959]   - Field: ‘result’
[18:04:18.959]   - Field: ‘asynchronous’
[18:04:18.960]   - Field: ‘calls’
[18:04:18.960]   - Field: ‘globals’
[18:04:18.960]   - Field: ‘stdout’
[18:04:18.961]   - Field: ‘earlySignal’
[18:04:18.961]   - Field: ‘lazy’
[18:04:18.961]   - Field: ‘state’
[18:04:18.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:18.962] - Launch lazy future ...
[18:04:18.963] Packages needed by the future expression (n = 0): <none>
[18:04:18.963] Packages needed by future strategies (n = 0): <none>
[18:04:18.965] {
[18:04:18.965]     {
[18:04:18.965]         {
[18:04:18.965]             ...future.startTime <- base::Sys.time()
[18:04:18.965]             {
[18:04:18.965]                 {
[18:04:18.965]                   {
[18:04:18.965]                     {
[18:04:18.965]                       base::local({
[18:04:18.965]                         has_future <- base::requireNamespace("future", 
[18:04:18.965]                           quietly = TRUE)
[18:04:18.965]                         if (has_future) {
[18:04:18.965]                           ns <- base::getNamespace("future")
[18:04:18.965]                           version <- ns[[".package"]][["version"]]
[18:04:18.965]                           if (is.null(version)) 
[18:04:18.965]                             version <- utils::packageVersion("future")
[18:04:18.965]                         }
[18:04:18.965]                         else {
[18:04:18.965]                           version <- NULL
[18:04:18.965]                         }
[18:04:18.965]                         if (!has_future || version < "1.8.0") {
[18:04:18.965]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:18.965]                             "", base::R.version$version.string), 
[18:04:18.965]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:18.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:18.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:18.965]                               "release", "version")], collapse = " "), 
[18:04:18.965]                             hostname = base::Sys.info()[["nodename"]])
[18:04:18.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:18.965]                             info)
[18:04:18.965]                           info <- base::paste(info, collapse = "; ")
[18:04:18.965]                           if (!has_future) {
[18:04:18.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:18.965]                               info)
[18:04:18.965]                           }
[18:04:18.965]                           else {
[18:04:18.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:18.965]                               info, version)
[18:04:18.965]                           }
[18:04:18.965]                           base::stop(msg)
[18:04:18.965]                         }
[18:04:18.965]                       })
[18:04:18.965]                     }
[18:04:18.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:18.965]                     base::options(mc.cores = 1L)
[18:04:18.965]                   }
[18:04:18.965]                   ...future.strategy.old <- future::plan("list")
[18:04:18.965]                   options(future.plan = NULL)
[18:04:18.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:18.965]                 }
[18:04:18.965]                 ...future.workdir <- getwd()
[18:04:18.965]             }
[18:04:18.965]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:18.965]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:18.965]         }
[18:04:18.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:18.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:18.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:18.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:18.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:18.965]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:18.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:18.965]             base::names(...future.oldOptions))
[18:04:18.965]     }
[18:04:18.965]     if (FALSE) {
[18:04:18.965]     }
[18:04:18.965]     else {
[18:04:18.965]         if (TRUE) {
[18:04:18.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:18.965]                 open = "w")
[18:04:18.965]         }
[18:04:18.965]         else {
[18:04:18.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:18.965]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:18.965]         }
[18:04:18.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:18.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:18.965]             base::sink(type = "output", split = FALSE)
[18:04:18.965]             base::close(...future.stdout)
[18:04:18.965]         }, add = TRUE)
[18:04:18.965]     }
[18:04:18.965]     ...future.frame <- base::sys.nframe()
[18:04:18.965]     ...future.conditions <- base::list()
[18:04:18.965]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:18.965]     if (FALSE) {
[18:04:18.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:18.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:18.965]     }
[18:04:18.965]     ...future.result <- base::tryCatch({
[18:04:18.965]         base::withCallingHandlers({
[18:04:18.965]             ...future.value <- base::withVisible(base::local({
[18:04:18.965]                 withCallingHandlers({
[18:04:18.965]                   {
[18:04:18.965]                     4
[18:04:18.965]                   }
[18:04:18.965]                 }, immediateCondition = function(cond) {
[18:04:18.965]                   save_rds <- function (object, pathname, ...) 
[18:04:18.965]                   {
[18:04:18.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:18.965]                     if (file_test("-f", pathname_tmp)) {
[18:04:18.965]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:18.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.965]                         fi_tmp[["mtime"]])
[18:04:18.965]                     }
[18:04:18.965]                     tryCatch({
[18:04:18.965]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:18.965]                     }, error = function(ex) {
[18:04:18.965]                       msg <- conditionMessage(ex)
[18:04:18.965]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:18.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.965]                         fi_tmp[["mtime"]], msg)
[18:04:18.965]                       ex$message <- msg
[18:04:18.965]                       stop(ex)
[18:04:18.965]                     })
[18:04:18.965]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:18.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:18.965]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:18.965]                       fi_tmp <- file.info(pathname_tmp)
[18:04:18.965]                       fi <- file.info(pathname)
[18:04:18.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:18.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:18.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:18.965]                         fi[["size"]], fi[["mtime"]])
[18:04:18.965]                       stop(msg)
[18:04:18.965]                     }
[18:04:18.965]                     invisible(pathname)
[18:04:18.965]                   }
[18:04:18.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:18.965]                     rootPath = tempdir()) 
[18:04:18.965]                   {
[18:04:18.965]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:18.965]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:18.965]                       tmpdir = path, fileext = ".rds")
[18:04:18.965]                     save_rds(obj, file)
[18:04:18.965]                   }
[18:04:18.965]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:18.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.965]                   {
[18:04:18.965]                     inherits <- base::inherits
[18:04:18.965]                     invokeRestart <- base::invokeRestart
[18:04:18.965]                     is.null <- base::is.null
[18:04:18.965]                     muffled <- FALSE
[18:04:18.965]                     if (inherits(cond, "message")) {
[18:04:18.965]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:18.965]                       if (muffled) 
[18:04:18.965]                         invokeRestart("muffleMessage")
[18:04:18.965]                     }
[18:04:18.965]                     else if (inherits(cond, "warning")) {
[18:04:18.965]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:18.965]                       if (muffled) 
[18:04:18.965]                         invokeRestart("muffleWarning")
[18:04:18.965]                     }
[18:04:18.965]                     else if (inherits(cond, "condition")) {
[18:04:18.965]                       if (!is.null(pattern)) {
[18:04:18.965]                         computeRestarts <- base::computeRestarts
[18:04:18.965]                         grepl <- base::grepl
[18:04:18.965]                         restarts <- computeRestarts(cond)
[18:04:18.965]                         for (restart in restarts) {
[18:04:18.965]                           name <- restart$name
[18:04:18.965]                           if (is.null(name)) 
[18:04:18.965]                             next
[18:04:18.965]                           if (!grepl(pattern, name)) 
[18:04:18.965]                             next
[18:04:18.965]                           invokeRestart(restart)
[18:04:18.965]                           muffled <- TRUE
[18:04:18.965]                           break
[18:04:18.965]                         }
[18:04:18.965]                       }
[18:04:18.965]                     }
[18:04:18.965]                     invisible(muffled)
[18:04:18.965]                   }
[18:04:18.965]                   muffleCondition(cond)
[18:04:18.965]                 })
[18:04:18.965]             }))
[18:04:18.965]             future::FutureResult(value = ...future.value$value, 
[18:04:18.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.965]                   ...future.rng), globalenv = if (FALSE) 
[18:04:18.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:18.965]                     ...future.globalenv.names))
[18:04:18.965]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:18.965]         }, condition = base::local({
[18:04:18.965]             c <- base::c
[18:04:18.965]             inherits <- base::inherits
[18:04:18.965]             invokeRestart <- base::invokeRestart
[18:04:18.965]             length <- base::length
[18:04:18.965]             list <- base::list
[18:04:18.965]             seq.int <- base::seq.int
[18:04:18.965]             signalCondition <- base::signalCondition
[18:04:18.965]             sys.calls <- base::sys.calls
[18:04:18.965]             `[[` <- base::`[[`
[18:04:18.965]             `+` <- base::`+`
[18:04:18.965]             `<<-` <- base::`<<-`
[18:04:18.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:18.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:18.965]                   3L)]
[18:04:18.965]             }
[18:04:18.965]             function(cond) {
[18:04:18.965]                 is_error <- inherits(cond, "error")
[18:04:18.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:18.965]                   NULL)
[18:04:18.965]                 if (is_error) {
[18:04:18.965]                   sessionInformation <- function() {
[18:04:18.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:18.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:18.965]                       search = base::search(), system = base::Sys.info())
[18:04:18.965]                   }
[18:04:18.965]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:18.965]                     cond$call), session = sessionInformation(), 
[18:04:18.965]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:18.965]                   signalCondition(cond)
[18:04:18.965]                 }
[18:04:18.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:18.965]                 "immediateCondition"))) {
[18:04:18.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:18.965]                   ...future.conditions[[length(...future.conditions) + 
[18:04:18.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:18.965]                   if (TRUE && !signal) {
[18:04:18.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.965]                     {
[18:04:18.965]                       inherits <- base::inherits
[18:04:18.965]                       invokeRestart <- base::invokeRestart
[18:04:18.965]                       is.null <- base::is.null
[18:04:18.965]                       muffled <- FALSE
[18:04:18.965]                       if (inherits(cond, "message")) {
[18:04:18.965]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.965]                         if (muffled) 
[18:04:18.965]                           invokeRestart("muffleMessage")
[18:04:18.965]                       }
[18:04:18.965]                       else if (inherits(cond, "warning")) {
[18:04:18.965]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.965]                         if (muffled) 
[18:04:18.965]                           invokeRestart("muffleWarning")
[18:04:18.965]                       }
[18:04:18.965]                       else if (inherits(cond, "condition")) {
[18:04:18.965]                         if (!is.null(pattern)) {
[18:04:18.965]                           computeRestarts <- base::computeRestarts
[18:04:18.965]                           grepl <- base::grepl
[18:04:18.965]                           restarts <- computeRestarts(cond)
[18:04:18.965]                           for (restart in restarts) {
[18:04:18.965]                             name <- restart$name
[18:04:18.965]                             if (is.null(name)) 
[18:04:18.965]                               next
[18:04:18.965]                             if (!grepl(pattern, name)) 
[18:04:18.965]                               next
[18:04:18.965]                             invokeRestart(restart)
[18:04:18.965]                             muffled <- TRUE
[18:04:18.965]                             break
[18:04:18.965]                           }
[18:04:18.965]                         }
[18:04:18.965]                       }
[18:04:18.965]                       invisible(muffled)
[18:04:18.965]                     }
[18:04:18.965]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.965]                   }
[18:04:18.965]                 }
[18:04:18.965]                 else {
[18:04:18.965]                   if (TRUE) {
[18:04:18.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:18.965]                     {
[18:04:18.965]                       inherits <- base::inherits
[18:04:18.965]                       invokeRestart <- base::invokeRestart
[18:04:18.965]                       is.null <- base::is.null
[18:04:18.965]                       muffled <- FALSE
[18:04:18.965]                       if (inherits(cond, "message")) {
[18:04:18.965]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:18.965]                         if (muffled) 
[18:04:18.965]                           invokeRestart("muffleMessage")
[18:04:18.965]                       }
[18:04:18.965]                       else if (inherits(cond, "warning")) {
[18:04:18.965]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:18.965]                         if (muffled) 
[18:04:18.965]                           invokeRestart("muffleWarning")
[18:04:18.965]                       }
[18:04:18.965]                       else if (inherits(cond, "condition")) {
[18:04:18.965]                         if (!is.null(pattern)) {
[18:04:18.965]                           computeRestarts <- base::computeRestarts
[18:04:18.965]                           grepl <- base::grepl
[18:04:18.965]                           restarts <- computeRestarts(cond)
[18:04:18.965]                           for (restart in restarts) {
[18:04:18.965]                             name <- restart$name
[18:04:18.965]                             if (is.null(name)) 
[18:04:18.965]                               next
[18:04:18.965]                             if (!grepl(pattern, name)) 
[18:04:18.965]                               next
[18:04:18.965]                             invokeRestart(restart)
[18:04:18.965]                             muffled <- TRUE
[18:04:18.965]                             break
[18:04:18.965]                           }
[18:04:18.965]                         }
[18:04:18.965]                       }
[18:04:18.965]                       invisible(muffled)
[18:04:18.965]                     }
[18:04:18.965]                     muffleCondition(cond, pattern = "^muffle")
[18:04:18.965]                   }
[18:04:18.965]                 }
[18:04:18.965]             }
[18:04:18.965]         }))
[18:04:18.965]     }, error = function(ex) {
[18:04:18.965]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:18.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:18.965]                 ...future.rng), started = ...future.startTime, 
[18:04:18.965]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:18.965]             version = "1.8"), class = "FutureResult")
[18:04:18.965]     }, finally = {
[18:04:18.965]         if (!identical(...future.workdir, getwd())) 
[18:04:18.965]             setwd(...future.workdir)
[18:04:18.965]         {
[18:04:18.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:18.965]                 ...future.oldOptions$nwarnings <- NULL
[18:04:18.965]             }
[18:04:18.965]             base::options(...future.oldOptions)
[18:04:18.965]             if (.Platform$OS.type == "windows") {
[18:04:18.965]                 old_names <- names(...future.oldEnvVars)
[18:04:18.965]                 envs <- base::Sys.getenv()
[18:04:18.965]                 names <- names(envs)
[18:04:18.965]                 common <- intersect(names, old_names)
[18:04:18.965]                 added <- setdiff(names, old_names)
[18:04:18.965]                 removed <- setdiff(old_names, names)
[18:04:18.965]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:18.965]                   envs[common]]
[18:04:18.965]                 NAMES <- toupper(changed)
[18:04:18.965]                 args <- list()
[18:04:18.965]                 for (kk in seq_along(NAMES)) {
[18:04:18.965]                   name <- changed[[kk]]
[18:04:18.965]                   NAME <- NAMES[[kk]]
[18:04:18.965]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.965]                     next
[18:04:18.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.965]                 }
[18:04:18.965]                 NAMES <- toupper(added)
[18:04:18.965]                 for (kk in seq_along(NAMES)) {
[18:04:18.965]                   name <- added[[kk]]
[18:04:18.965]                   NAME <- NAMES[[kk]]
[18:04:18.965]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.965]                     next
[18:04:18.965]                   args[[name]] <- ""
[18:04:18.965]                 }
[18:04:18.965]                 NAMES <- toupper(removed)
[18:04:18.965]                 for (kk in seq_along(NAMES)) {
[18:04:18.965]                   name <- removed[[kk]]
[18:04:18.965]                   NAME <- NAMES[[kk]]
[18:04:18.965]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:18.965]                     next
[18:04:18.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:18.965]                 }
[18:04:18.965]                 if (length(args) > 0) 
[18:04:18.965]                   base::do.call(base::Sys.setenv, args = args)
[18:04:18.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:18.965]             }
[18:04:18.965]             else {
[18:04:18.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:18.965]             }
[18:04:18.965]             {
[18:04:18.965]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:18.965]                   0L) {
[18:04:18.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:18.965]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:18.965]                   base::options(opts)
[18:04:18.965]                 }
[18:04:18.965]                 {
[18:04:18.965]                   {
[18:04:18.965]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:18.965]                     NULL
[18:04:18.965]                   }
[18:04:18.965]                   options(future.plan = NULL)
[18:04:18.965]                   if (is.na(NA_character_)) 
[18:04:18.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:18.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:18.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:18.965]                     .init = FALSE)
[18:04:18.965]                 }
[18:04:18.965]             }
[18:04:18.965]         }
[18:04:18.965]     })
[18:04:18.965]     if (TRUE) {
[18:04:18.965]         base::sink(type = "output", split = FALSE)
[18:04:18.965]         if (TRUE) {
[18:04:18.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:18.965]         }
[18:04:18.965]         else {
[18:04:18.965]             ...future.result["stdout"] <- base::list(NULL)
[18:04:18.965]         }
[18:04:18.965]         base::close(...future.stdout)
[18:04:18.965]         ...future.stdout <- NULL
[18:04:18.965]     }
[18:04:18.965]     ...future.result$conditions <- ...future.conditions
[18:04:18.965]     ...future.result$finished <- base::Sys.time()
[18:04:18.965]     ...future.result
[18:04:18.965] }
[18:04:18.972] requestCore(): workers = 2
[18:04:18.973] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:18.985] result() for MulticoreFuture ...
[18:04:18.987] result() for MulticoreFuture ...
[18:04:18.987] result() for MulticoreFuture ... done
[18:04:18.987] result() for MulticoreFuture ... done
[18:04:18.988] result() for MulticoreFuture ...
[18:04:18.988] result() for MulticoreFuture ... done
[18:04:18.993] MulticoreFuture started
[18:04:18.994] - Launch lazy future ... done
[18:04:18.994] run() for ‘MulticoreFuture’ ... done
[18:04:18.995] plan(): Setting new future strategy stack:
<environment: 0x5e3c2d1c8b40> 
[18:04:18.995] List of future strategies:
[18:04:18.995] 1. sequential:
[18:04:18.995]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:18.995]    - tweaked: FALSE
[18:04:18.995]    - call: NULL
<environment: 0x5e3c2ad5ff58> [18:04:18.998] plan(): nbrOfWorkers() = 1

[18:04:19.002] plan(): Setting new future strategy stack:
[18:04:19.002] List of future strategies:
[18:04:19.002] 1. multicore:
[18:04:19.002]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:19.002]    - tweaked: FALSE
[18:04:19.002]    - call: plan(strategy)
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:19.016] plan(): nbrOfWorkers() = 2
[18:04:19.019] resolve() on environment ...
[18:04:19.019]  recursive: 0
[18:04:19.021]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:19.022] signalConditionsASAP(numeric, pos=1) ...
[18:04:19.022] - nx: 4
[18:04:19.022] - relay: TRUE
[18:04:19.023] - stdout: TRUE
[18:04:19.023] - signal: TRUE
[18:04:19.023] - resignal: FALSE
[18:04:19.024] - force: TRUE
[18:04:19.024] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.024] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.025]  - until=2
[18:04:19.025]  - relaying element #2
[18:04:19.025] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:19.026] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.026] signalConditionsASAP(NULL, pos=1) ... done
[18:04:19.026]  length: 3 (resolved future 1)
[18:04:19.027] Future #2
[18:04:19.027] result() for MulticoreFuture ...
[18:04:19.028] result() for MulticoreFuture ... done
[18:04:19.028] result() for MulticoreFuture ...
[18:04:19.028] result() for MulticoreFuture ... done
[18:04:19.029] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:19.029] - nx: 4
[18:04:19.029] - relay: TRUE
[18:04:19.030] - stdout: TRUE
[18:04:19.030] - signal: TRUE
[18:04:19.030] - resignal: FALSE
[18:04:19.031] - force: TRUE
[18:04:19.031] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:19.031] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.032]  - until=2
[18:04:19.032]  - relaying element #2
[18:04:19.032] result() for MulticoreFuture ...
[18:04:19.032] result() for MulticoreFuture ... done
[18:04:19.033] result() for MulticoreFuture ...
[18:04:19.033] result() for MulticoreFuture ... done
[18:04:19.034] result() for MulticoreFuture ...
[18:04:19.034] result() for MulticoreFuture ... done
[18:04:19.034] result() for MulticoreFuture ...
[18:04:19.035] result() for MulticoreFuture ... done
[18:04:19.035] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:19.035] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:19.036] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:19.036]  length: 2 (resolved future 2)
[18:04:19.037] Future #3
[18:04:19.037] result() for MulticoreFuture ...
[18:04:19.041] result() for MulticoreFuture ...
[18:04:19.042] result() for MulticoreFuture ... done
[18:04:19.042] result() for MulticoreFuture ... done
[18:04:19.044] result() for MulticoreFuture ...
[18:04:19.045] result() for MulticoreFuture ... done
[18:04:19.045] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:19.046] - nx: 4
[18:04:19.046] - relay: TRUE
[18:04:19.046] - stdout: TRUE
[18:04:19.047] - signal: TRUE
[18:04:19.047] - resignal: FALSE
[18:04:19.047] - force: TRUE
[18:04:19.048] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:19.048] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:19.048]  - until=3
[18:04:19.048]  - relaying element #3
[18:04:19.049] result() for MulticoreFuture ...
[18:04:19.049] result() for MulticoreFuture ... done
[18:04:19.049] result() for MulticoreFuture ...
[18:04:19.050] result() for MulticoreFuture ... done
[18:04:19.050] result() for MulticoreFuture ...
[18:04:19.051] result() for MulticoreFuture ... done
[18:04:19.051] result() for MulticoreFuture ...
[18:04:19.051] result() for MulticoreFuture ... done
[18:04:19.052] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:19.052] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:19.052] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:19.053]  length: 1 (resolved future 3)
[18:04:19.053] Future #4
[18:04:19.054] result() for MulticoreFuture ...
[18:04:19.055] result() for MulticoreFuture ...
[18:04:19.056] result() for MulticoreFuture ... done
[18:04:19.056] result() for MulticoreFuture ... done
[18:04:19.056] result() for MulticoreFuture ...
[18:04:19.056] result() for MulticoreFuture ... done
[18:04:19.057] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:19.057] - nx: 4
[18:04:19.058] - relay: TRUE
[18:04:19.058] - stdout: TRUE
[18:04:19.058] - signal: TRUE
[18:04:19.058] - resignal: FALSE
[18:04:19.058] - force: TRUE
[18:04:19.059] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:19.059] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:19.059]  - until=4
[18:04:19.059]  - relaying element #4
[18:04:19.060] result() for MulticoreFuture ...
[18:04:19.060] result() for MulticoreFuture ... done
[18:04:19.060] result() for MulticoreFuture ...
[18:04:19.061] result() for MulticoreFuture ... done
[18:04:19.061] result() for MulticoreFuture ...
[18:04:19.061] result() for MulticoreFuture ... done
[18:04:19.061] result() for MulticoreFuture ...
[18:04:19.062] result() for MulticoreFuture ... done
[18:04:19.062] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:19.062] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:19.063] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:19.063]  length: 0 (resolved future 4)
[18:04:19.063] Relaying remaining futures
[18:04:19.063] signalConditionsASAP(NULL, pos=0) ...
[18:04:19.064] - nx: 4
[18:04:19.064] - relay: TRUE
[18:04:19.064] - stdout: TRUE
[18:04:19.064] - signal: TRUE
[18:04:19.064] - resignal: FALSE
[18:04:19.065] - force: TRUE
[18:04:19.065] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:19.065] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:19.065] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:19.066] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:19.066] signalConditionsASAP(NULL, pos=0) ... done
[18:04:19.066] resolve() on environment ... DONE
[18:04:19.066] result() for MulticoreFuture ...
[18:04:19.066] result() for MulticoreFuture ... done
[18:04:19.067] result() for MulticoreFuture ...
[18:04:19.067] result() for MulticoreFuture ... done
[18:04:19.067] result() for MulticoreFuture ...
[18:04:19.067] result() for MulticoreFuture ... done
[18:04:19.068] result() for MulticoreFuture ...
[18:04:19.068] result() for MulticoreFuture ... done
[18:04:19.068] result() for MulticoreFuture ...
[18:04:19.068] result() for MulticoreFuture ... done
[18:04:19.069] result() for MulticoreFuture ...
[18:04:19.069] result() for MulticoreFuture ... done
<environment: 0x5e3c2ac4d800> 
Dimensions: c(2, 3, 1)
[18:04:19.070] getGlobalsAndPackages() ...
[18:04:19.070] Searching for globals...
[18:04:19.071] 
[18:04:19.071] Searching for globals ... DONE
[18:04:19.071] - globals: [0] <none>
[18:04:19.071] getGlobalsAndPackages() ... DONE
[18:04:19.072] run() for ‘Future’ ...
[18:04:19.072] - state: ‘created’
[18:04:19.073] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:19.080] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:19.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:19.080]   - Field: ‘label’
[18:04:19.080]   - Field: ‘local’
[18:04:19.081]   - Field: ‘owner’
[18:04:19.081]   - Field: ‘envir’
[18:04:19.081]   - Field: ‘workers’
[18:04:19.081]   - Field: ‘packages’
[18:04:19.082]   - Field: ‘gc’
[18:04:19.082]   - Field: ‘job’
[18:04:19.082]   - Field: ‘conditions’
[18:04:19.082]   - Field: ‘expr’
[18:04:19.083]   - Field: ‘uuid’
[18:04:19.083]   - Field: ‘seed’
[18:04:19.083]   - Field: ‘version’
[18:04:19.083]   - Field: ‘result’
[18:04:19.083]   - Field: ‘asynchronous’
[18:04:19.084]   - Field: ‘calls’
[18:04:19.084]   - Field: ‘globals’
[18:04:19.084]   - Field: ‘stdout’
[18:04:19.084]   - Field: ‘earlySignal’
[18:04:19.085]   - Field: ‘lazy’
[18:04:19.085]   - Field: ‘state’
[18:04:19.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:19.085] - Launch lazy future ...
[18:04:19.086] Packages needed by the future expression (n = 0): <none>
[18:04:19.086] Packages needed by future strategies (n = 0): <none>
[18:04:19.087] {
[18:04:19.087]     {
[18:04:19.087]         {
[18:04:19.087]             ...future.startTime <- base::Sys.time()
[18:04:19.087]             {
[18:04:19.087]                 {
[18:04:19.087]                   {
[18:04:19.087]                     {
[18:04:19.087]                       base::local({
[18:04:19.087]                         has_future <- base::requireNamespace("future", 
[18:04:19.087]                           quietly = TRUE)
[18:04:19.087]                         if (has_future) {
[18:04:19.087]                           ns <- base::getNamespace("future")
[18:04:19.087]                           version <- ns[[".package"]][["version"]]
[18:04:19.087]                           if (is.null(version)) 
[18:04:19.087]                             version <- utils::packageVersion("future")
[18:04:19.087]                         }
[18:04:19.087]                         else {
[18:04:19.087]                           version <- NULL
[18:04:19.087]                         }
[18:04:19.087]                         if (!has_future || version < "1.8.0") {
[18:04:19.087]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:19.087]                             "", base::R.version$version.string), 
[18:04:19.087]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:19.087]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:19.087]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:19.087]                               "release", "version")], collapse = " "), 
[18:04:19.087]                             hostname = base::Sys.info()[["nodename"]])
[18:04:19.087]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:19.087]                             info)
[18:04:19.087]                           info <- base::paste(info, collapse = "; ")
[18:04:19.087]                           if (!has_future) {
[18:04:19.087]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:19.087]                               info)
[18:04:19.087]                           }
[18:04:19.087]                           else {
[18:04:19.087]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:19.087]                               info, version)
[18:04:19.087]                           }
[18:04:19.087]                           base::stop(msg)
[18:04:19.087]                         }
[18:04:19.087]                       })
[18:04:19.087]                     }
[18:04:19.087]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:19.087]                     base::options(mc.cores = 1L)
[18:04:19.087]                   }
[18:04:19.087]                   ...future.strategy.old <- future::plan("list")
[18:04:19.087]                   options(future.plan = NULL)
[18:04:19.087]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.087]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:19.087]                 }
[18:04:19.087]                 ...future.workdir <- getwd()
[18:04:19.087]             }
[18:04:19.087]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:19.087]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:19.087]         }
[18:04:19.087]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:19.087]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:19.087]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:19.087]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:19.087]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:19.087]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:19.087]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:19.087]             base::names(...future.oldOptions))
[18:04:19.087]     }
[18:04:19.087]     if (FALSE) {
[18:04:19.087]     }
[18:04:19.087]     else {
[18:04:19.087]         if (TRUE) {
[18:04:19.087]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:19.087]                 open = "w")
[18:04:19.087]         }
[18:04:19.087]         else {
[18:04:19.087]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:19.087]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:19.087]         }
[18:04:19.087]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:19.087]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:19.087]             base::sink(type = "output", split = FALSE)
[18:04:19.087]             base::close(...future.stdout)
[18:04:19.087]         }, add = TRUE)
[18:04:19.087]     }
[18:04:19.087]     ...future.frame <- base::sys.nframe()
[18:04:19.087]     ...future.conditions <- base::list()
[18:04:19.087]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:19.087]     if (FALSE) {
[18:04:19.087]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:19.087]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:19.087]     }
[18:04:19.087]     ...future.result <- base::tryCatch({
[18:04:19.087]         base::withCallingHandlers({
[18:04:19.087]             ...future.value <- base::withVisible(base::local({
[18:04:19.087]                 withCallingHandlers({
[18:04:19.087]                   2
[18:04:19.087]                 }, immediateCondition = function(cond) {
[18:04:19.087]                   save_rds <- function (object, pathname, ...) 
[18:04:19.087]                   {
[18:04:19.087]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:19.087]                     if (file_test("-f", pathname_tmp)) {
[18:04:19.087]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.087]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:19.087]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.087]                         fi_tmp[["mtime"]])
[18:04:19.087]                     }
[18:04:19.087]                     tryCatch({
[18:04:19.087]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:19.087]                     }, error = function(ex) {
[18:04:19.087]                       msg <- conditionMessage(ex)
[18:04:19.087]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.087]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:19.087]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.087]                         fi_tmp[["mtime"]], msg)
[18:04:19.087]                       ex$message <- msg
[18:04:19.087]                       stop(ex)
[18:04:19.087]                     })
[18:04:19.087]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:19.087]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:19.087]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:19.087]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.087]                       fi <- file.info(pathname)
[18:04:19.087]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:19.087]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.087]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:19.087]                         fi[["size"]], fi[["mtime"]])
[18:04:19.087]                       stop(msg)
[18:04:19.087]                     }
[18:04:19.087]                     invisible(pathname)
[18:04:19.087]                   }
[18:04:19.087]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:19.087]                     rootPath = tempdir()) 
[18:04:19.087]                   {
[18:04:19.087]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:19.087]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:19.087]                       tmpdir = path, fileext = ".rds")
[18:04:19.087]                     save_rds(obj, file)
[18:04:19.087]                   }
[18:04:19.087]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:19.087]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.087]                   {
[18:04:19.087]                     inherits <- base::inherits
[18:04:19.087]                     invokeRestart <- base::invokeRestart
[18:04:19.087]                     is.null <- base::is.null
[18:04:19.087]                     muffled <- FALSE
[18:04:19.087]                     if (inherits(cond, "message")) {
[18:04:19.087]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:19.087]                       if (muffled) 
[18:04:19.087]                         invokeRestart("muffleMessage")
[18:04:19.087]                     }
[18:04:19.087]                     else if (inherits(cond, "warning")) {
[18:04:19.087]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:19.087]                       if (muffled) 
[18:04:19.087]                         invokeRestart("muffleWarning")
[18:04:19.087]                     }
[18:04:19.087]                     else if (inherits(cond, "condition")) {
[18:04:19.087]                       if (!is.null(pattern)) {
[18:04:19.087]                         computeRestarts <- base::computeRestarts
[18:04:19.087]                         grepl <- base::grepl
[18:04:19.087]                         restarts <- computeRestarts(cond)
[18:04:19.087]                         for (restart in restarts) {
[18:04:19.087]                           name <- restart$name
[18:04:19.087]                           if (is.null(name)) 
[18:04:19.087]                             next
[18:04:19.087]                           if (!grepl(pattern, name)) 
[18:04:19.087]                             next
[18:04:19.087]                           invokeRestart(restart)
[18:04:19.087]                           muffled <- TRUE
[18:04:19.087]                           break
[18:04:19.087]                         }
[18:04:19.087]                       }
[18:04:19.087]                     }
[18:04:19.087]                     invisible(muffled)
[18:04:19.087]                   }
[18:04:19.087]                   muffleCondition(cond)
[18:04:19.087]                 })
[18:04:19.087]             }))
[18:04:19.087]             future::FutureResult(value = ...future.value$value, 
[18:04:19.087]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.087]                   ...future.rng), globalenv = if (FALSE) 
[18:04:19.087]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:19.087]                     ...future.globalenv.names))
[18:04:19.087]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:19.087]         }, condition = base::local({
[18:04:19.087]             c <- base::c
[18:04:19.087]             inherits <- base::inherits
[18:04:19.087]             invokeRestart <- base::invokeRestart
[18:04:19.087]             length <- base::length
[18:04:19.087]             list <- base::list
[18:04:19.087]             seq.int <- base::seq.int
[18:04:19.087]             signalCondition <- base::signalCondition
[18:04:19.087]             sys.calls <- base::sys.calls
[18:04:19.087]             `[[` <- base::`[[`
[18:04:19.087]             `+` <- base::`+`
[18:04:19.087]             `<<-` <- base::`<<-`
[18:04:19.087]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:19.087]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:19.087]                   3L)]
[18:04:19.087]             }
[18:04:19.087]             function(cond) {
[18:04:19.087]                 is_error <- inherits(cond, "error")
[18:04:19.087]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:19.087]                   NULL)
[18:04:19.087]                 if (is_error) {
[18:04:19.087]                   sessionInformation <- function() {
[18:04:19.087]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:19.087]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:19.087]                       search = base::search(), system = base::Sys.info())
[18:04:19.087]                   }
[18:04:19.087]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.087]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:19.087]                     cond$call), session = sessionInformation(), 
[18:04:19.087]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:19.087]                   signalCondition(cond)
[18:04:19.087]                 }
[18:04:19.087]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:19.087]                 "immediateCondition"))) {
[18:04:19.087]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:19.087]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.087]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:19.087]                   if (TRUE && !signal) {
[18:04:19.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.087]                     {
[18:04:19.087]                       inherits <- base::inherits
[18:04:19.087]                       invokeRestart <- base::invokeRestart
[18:04:19.087]                       is.null <- base::is.null
[18:04:19.087]                       muffled <- FALSE
[18:04:19.087]                       if (inherits(cond, "message")) {
[18:04:19.087]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.087]                         if (muffled) 
[18:04:19.087]                           invokeRestart("muffleMessage")
[18:04:19.087]                       }
[18:04:19.087]                       else if (inherits(cond, "warning")) {
[18:04:19.087]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.087]                         if (muffled) 
[18:04:19.087]                           invokeRestart("muffleWarning")
[18:04:19.087]                       }
[18:04:19.087]                       else if (inherits(cond, "condition")) {
[18:04:19.087]                         if (!is.null(pattern)) {
[18:04:19.087]                           computeRestarts <- base::computeRestarts
[18:04:19.087]                           grepl <- base::grepl
[18:04:19.087]                           restarts <- computeRestarts(cond)
[18:04:19.087]                           for (restart in restarts) {
[18:04:19.087]                             name <- restart$name
[18:04:19.087]                             if (is.null(name)) 
[18:04:19.087]                               next
[18:04:19.087]                             if (!grepl(pattern, name)) 
[18:04:19.087]                               next
[18:04:19.087]                             invokeRestart(restart)
[18:04:19.087]                             muffled <- TRUE
[18:04:19.087]                             break
[18:04:19.087]                           }
[18:04:19.087]                         }
[18:04:19.087]                       }
[18:04:19.087]                       invisible(muffled)
[18:04:19.087]                     }
[18:04:19.087]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.087]                   }
[18:04:19.087]                 }
[18:04:19.087]                 else {
[18:04:19.087]                   if (TRUE) {
[18:04:19.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.087]                     {
[18:04:19.087]                       inherits <- base::inherits
[18:04:19.087]                       invokeRestart <- base::invokeRestart
[18:04:19.087]                       is.null <- base::is.null
[18:04:19.087]                       muffled <- FALSE
[18:04:19.087]                       if (inherits(cond, "message")) {
[18:04:19.087]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.087]                         if (muffled) 
[18:04:19.087]                           invokeRestart("muffleMessage")
[18:04:19.087]                       }
[18:04:19.087]                       else if (inherits(cond, "warning")) {
[18:04:19.087]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.087]                         if (muffled) 
[18:04:19.087]                           invokeRestart("muffleWarning")
[18:04:19.087]                       }
[18:04:19.087]                       else if (inherits(cond, "condition")) {
[18:04:19.087]                         if (!is.null(pattern)) {
[18:04:19.087]                           computeRestarts <- base::computeRestarts
[18:04:19.087]                           grepl <- base::grepl
[18:04:19.087]                           restarts <- computeRestarts(cond)
[18:04:19.087]                           for (restart in restarts) {
[18:04:19.087]                             name <- restart$name
[18:04:19.087]                             if (is.null(name)) 
[18:04:19.087]                               next
[18:04:19.087]                             if (!grepl(pattern, name)) 
[18:04:19.087]                               next
[18:04:19.087]                             invokeRestart(restart)
[18:04:19.087]                             muffled <- TRUE
[18:04:19.087]                             break
[18:04:19.087]                           }
[18:04:19.087]                         }
[18:04:19.087]                       }
[18:04:19.087]                       invisible(muffled)
[18:04:19.087]                     }
[18:04:19.087]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.087]                   }
[18:04:19.087]                 }
[18:04:19.087]             }
[18:04:19.087]         }))
[18:04:19.087]     }, error = function(ex) {
[18:04:19.087]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:19.087]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.087]                 ...future.rng), started = ...future.startTime, 
[18:04:19.087]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:19.087]             version = "1.8"), class = "FutureResult")
[18:04:19.087]     }, finally = {
[18:04:19.087]         if (!identical(...future.workdir, getwd())) 
[18:04:19.087]             setwd(...future.workdir)
[18:04:19.087]         {
[18:04:19.087]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:19.087]                 ...future.oldOptions$nwarnings <- NULL
[18:04:19.087]             }
[18:04:19.087]             base::options(...future.oldOptions)
[18:04:19.087]             if (.Platform$OS.type == "windows") {
[18:04:19.087]                 old_names <- names(...future.oldEnvVars)
[18:04:19.087]                 envs <- base::Sys.getenv()
[18:04:19.087]                 names <- names(envs)
[18:04:19.087]                 common <- intersect(names, old_names)
[18:04:19.087]                 added <- setdiff(names, old_names)
[18:04:19.087]                 removed <- setdiff(old_names, names)
[18:04:19.087]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:19.087]                   envs[common]]
[18:04:19.087]                 NAMES <- toupper(changed)
[18:04:19.087]                 args <- list()
[18:04:19.087]                 for (kk in seq_along(NAMES)) {
[18:04:19.087]                   name <- changed[[kk]]
[18:04:19.087]                   NAME <- NAMES[[kk]]
[18:04:19.087]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.087]                     next
[18:04:19.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.087]                 }
[18:04:19.087]                 NAMES <- toupper(added)
[18:04:19.087]                 for (kk in seq_along(NAMES)) {
[18:04:19.087]                   name <- added[[kk]]
[18:04:19.087]                   NAME <- NAMES[[kk]]
[18:04:19.087]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.087]                     next
[18:04:19.087]                   args[[name]] <- ""
[18:04:19.087]                 }
[18:04:19.087]                 NAMES <- toupper(removed)
[18:04:19.087]                 for (kk in seq_along(NAMES)) {
[18:04:19.087]                   name <- removed[[kk]]
[18:04:19.087]                   NAME <- NAMES[[kk]]
[18:04:19.087]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.087]                     next
[18:04:19.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.087]                 }
[18:04:19.087]                 if (length(args) > 0) 
[18:04:19.087]                   base::do.call(base::Sys.setenv, args = args)
[18:04:19.087]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:19.087]             }
[18:04:19.087]             else {
[18:04:19.087]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:19.087]             }
[18:04:19.087]             {
[18:04:19.087]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:19.087]                   0L) {
[18:04:19.087]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:19.087]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:19.087]                   base::options(opts)
[18:04:19.087]                 }
[18:04:19.087]                 {
[18:04:19.087]                   {
[18:04:19.087]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:19.087]                     NULL
[18:04:19.087]                   }
[18:04:19.087]                   options(future.plan = NULL)
[18:04:19.087]                   if (is.na(NA_character_)) 
[18:04:19.087]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.087]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:19.087]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:19.087]                     .init = FALSE)
[18:04:19.087]                 }
[18:04:19.087]             }
[18:04:19.087]         }
[18:04:19.087]     })
[18:04:19.087]     if (TRUE) {
[18:04:19.087]         base::sink(type = "output", split = FALSE)
[18:04:19.087]         if (TRUE) {
[18:04:19.087]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:19.087]         }
[18:04:19.087]         else {
[18:04:19.087]             ...future.result["stdout"] <- base::list(NULL)
[18:04:19.087]         }
[18:04:19.087]         base::close(...future.stdout)
[18:04:19.087]         ...future.stdout <- NULL
[18:04:19.087]     }
[18:04:19.087]     ...future.result$conditions <- ...future.conditions
[18:04:19.087]     ...future.result$finished <- base::Sys.time()
[18:04:19.087]     ...future.result
[18:04:19.087] }
[18:04:19.092] requestCore(): workers = 2
[18:04:19.096] MulticoreFuture started
[18:04:19.097] - Launch lazy future ... done
[18:04:19.097] run() for ‘MulticoreFuture’ ... done
[18:04:19.098] getGlobalsAndPackages() ...
[18:04:19.098] plan(): Setting new future strategy stack:
[18:04:19.098] Searching for globals...
[18:04:19.100] 
[18:04:19.098] List of future strategies:
[18:04:19.098] 1. sequential:
[18:04:19.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:19.098]    - tweaked: FALSE
[18:04:19.098]    - call: NULL
[18:04:19.100] Searching for globals ... DONE
[18:04:19.101] - globals: [0] <none>
[18:04:19.101] plan(): nbrOfWorkers() = 1
[18:04:19.101] getGlobalsAndPackages() ... DONE
[18:04:19.102] run() for ‘Future’ ...
[18:04:19.103] - state: ‘created’
[18:04:19.103] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:19.104] plan(): Setting new future strategy stack:
[18:04:19.105] List of future strategies:
[18:04:19.105] 1. multicore:
[18:04:19.105]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:19.105]    - tweaked: FALSE
[18:04:19.105]    - call: plan(strategy)
[18:04:19.112] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:19.112] plan(): nbrOfWorkers() = 2
[18:04:19.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:19.113]   - Field: ‘label’
[18:04:19.113]   - Field: ‘local’
[18:04:19.114]   - Field: ‘owner’
[18:04:19.114]   - Field: ‘envir’
[18:04:19.114]   - Field: ‘workers’
[18:04:19.114]   - Field: ‘packages’
[18:04:19.115]   - Field: ‘gc’
[18:04:19.115]   - Field: ‘job’
[18:04:19.115]   - Field: ‘conditions’
[18:04:19.116]   - Field: ‘expr’
[18:04:19.116]   - Field: ‘uuid’
[18:04:19.116]   - Field: ‘seed’
[18:04:19.117]   - Field: ‘version’
[18:04:19.117]   - Field: ‘result’
[18:04:19.117]   - Field: ‘asynchronous’
[18:04:19.117]   - Field: ‘calls’
[18:04:19.118]   - Field: ‘globals’
[18:04:19.118]   - Field: ‘stdout’
[18:04:19.118]   - Field: ‘earlySignal’
[18:04:19.119]   - Field: ‘lazy’
[18:04:19.119]   - Field: ‘state’
[18:04:19.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:19.120] - Launch lazy future ...
[18:04:19.121] Packages needed by the future expression (n = 0): <none>
[18:04:19.121] Packages needed by future strategies (n = 0): <none>
[18:04:19.122] {
[18:04:19.122]     {
[18:04:19.122]         {
[18:04:19.122]             ...future.startTime <- base::Sys.time()
[18:04:19.122]             {
[18:04:19.122]                 {
[18:04:19.122]                   {
[18:04:19.122]                     {
[18:04:19.122]                       base::local({
[18:04:19.122]                         has_future <- base::requireNamespace("future", 
[18:04:19.122]                           quietly = TRUE)
[18:04:19.122]                         if (has_future) {
[18:04:19.122]                           ns <- base::getNamespace("future")
[18:04:19.122]                           version <- ns[[".package"]][["version"]]
[18:04:19.122]                           if (is.null(version)) 
[18:04:19.122]                             version <- utils::packageVersion("future")
[18:04:19.122]                         }
[18:04:19.122]                         else {
[18:04:19.122]                           version <- NULL
[18:04:19.122]                         }
[18:04:19.122]                         if (!has_future || version < "1.8.0") {
[18:04:19.122]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:19.122]                             "", base::R.version$version.string), 
[18:04:19.122]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:19.122]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:19.122]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:19.122]                               "release", "version")], collapse = " "), 
[18:04:19.122]                             hostname = base::Sys.info()[["nodename"]])
[18:04:19.122]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:19.122]                             info)
[18:04:19.122]                           info <- base::paste(info, collapse = "; ")
[18:04:19.122]                           if (!has_future) {
[18:04:19.122]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:19.122]                               info)
[18:04:19.122]                           }
[18:04:19.122]                           else {
[18:04:19.122]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:19.122]                               info, version)
[18:04:19.122]                           }
[18:04:19.122]                           base::stop(msg)
[18:04:19.122]                         }
[18:04:19.122]                       })
[18:04:19.122]                     }
[18:04:19.122]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:19.122]                     base::options(mc.cores = 1L)
[18:04:19.122]                   }
[18:04:19.122]                   ...future.strategy.old <- future::plan("list")
[18:04:19.122]                   options(future.plan = NULL)
[18:04:19.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:19.122]                 }
[18:04:19.122]                 ...future.workdir <- getwd()
[18:04:19.122]             }
[18:04:19.122]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:19.122]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:19.122]         }
[18:04:19.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:19.122]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:19.122]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:19.122]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:19.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:19.122]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:19.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:19.122]             base::names(...future.oldOptions))
[18:04:19.122]     }
[18:04:19.122]     if (FALSE) {
[18:04:19.122]     }
[18:04:19.122]     else {
[18:04:19.122]         if (TRUE) {
[18:04:19.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:19.122]                 open = "w")
[18:04:19.122]         }
[18:04:19.122]         else {
[18:04:19.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:19.122]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:19.122]         }
[18:04:19.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:19.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:19.122]             base::sink(type = "output", split = FALSE)
[18:04:19.122]             base::close(...future.stdout)
[18:04:19.122]         }, add = TRUE)
[18:04:19.122]     }
[18:04:19.122]     ...future.frame <- base::sys.nframe()
[18:04:19.122]     ...future.conditions <- base::list()
[18:04:19.122]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:19.122]     if (FALSE) {
[18:04:19.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:19.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:19.122]     }
[18:04:19.122]     ...future.result <- base::tryCatch({
[18:04:19.122]         base::withCallingHandlers({
[18:04:19.122]             ...future.value <- base::withVisible(base::local({
[18:04:19.122]                 withCallingHandlers({
[18:04:19.122]                   NULL
[18:04:19.122]                 }, immediateCondition = function(cond) {
[18:04:19.122]                   save_rds <- function (object, pathname, ...) 
[18:04:19.122]                   {
[18:04:19.122]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:19.122]                     if (file_test("-f", pathname_tmp)) {
[18:04:19.122]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.122]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:19.122]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.122]                         fi_tmp[["mtime"]])
[18:04:19.122]                     }
[18:04:19.122]                     tryCatch({
[18:04:19.122]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:19.122]                     }, error = function(ex) {
[18:04:19.122]                       msg <- conditionMessage(ex)
[18:04:19.122]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.122]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:19.122]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.122]                         fi_tmp[["mtime"]], msg)
[18:04:19.122]                       ex$message <- msg
[18:04:19.122]                       stop(ex)
[18:04:19.122]                     })
[18:04:19.122]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:19.122]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:19.122]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:19.122]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.122]                       fi <- file.info(pathname)
[18:04:19.122]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:19.122]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.122]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:19.122]                         fi[["size"]], fi[["mtime"]])
[18:04:19.122]                       stop(msg)
[18:04:19.122]                     }
[18:04:19.122]                     invisible(pathname)
[18:04:19.122]                   }
[18:04:19.122]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:19.122]                     rootPath = tempdir()) 
[18:04:19.122]                   {
[18:04:19.122]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:19.122]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:19.122]                       tmpdir = path, fileext = ".rds")
[18:04:19.122]                     save_rds(obj, file)
[18:04:19.122]                   }
[18:04:19.122]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:19.122]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.122]                   {
[18:04:19.122]                     inherits <- base::inherits
[18:04:19.122]                     invokeRestart <- base::invokeRestart
[18:04:19.122]                     is.null <- base::is.null
[18:04:19.122]                     muffled <- FALSE
[18:04:19.122]                     if (inherits(cond, "message")) {
[18:04:19.122]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:19.122]                       if (muffled) 
[18:04:19.122]                         invokeRestart("muffleMessage")
[18:04:19.122]                     }
[18:04:19.122]                     else if (inherits(cond, "warning")) {
[18:04:19.122]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:19.122]                       if (muffled) 
[18:04:19.122]                         invokeRestart("muffleWarning")
[18:04:19.122]                     }
[18:04:19.122]                     else if (inherits(cond, "condition")) {
[18:04:19.122]                       if (!is.null(pattern)) {
[18:04:19.122]                         computeRestarts <- base::computeRestarts
[18:04:19.122]                         grepl <- base::grepl
[18:04:19.122]                         restarts <- computeRestarts(cond)
[18:04:19.122]                         for (restart in restarts) {
[18:04:19.122]                           name <- restart$name
[18:04:19.122]                           if (is.null(name)) 
[18:04:19.122]                             next
[18:04:19.122]                           if (!grepl(pattern, name)) 
[18:04:19.122]                             next
[18:04:19.122]                           invokeRestart(restart)
[18:04:19.122]                           muffled <- TRUE
[18:04:19.122]                           break
[18:04:19.122]                         }
[18:04:19.122]                       }
[18:04:19.122]                     }
[18:04:19.122]                     invisible(muffled)
[18:04:19.122]                   }
[18:04:19.122]                   muffleCondition(cond)
[18:04:19.122]                 })
[18:04:19.122]             }))
[18:04:19.122]             future::FutureResult(value = ...future.value$value, 
[18:04:19.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.122]                   ...future.rng), globalenv = if (FALSE) 
[18:04:19.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:19.122]                     ...future.globalenv.names))
[18:04:19.122]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:19.122]         }, condition = base::local({
[18:04:19.122]             c <- base::c
[18:04:19.122]             inherits <- base::inherits
[18:04:19.122]             invokeRestart <- base::invokeRestart
[18:04:19.122]             length <- base::length
[18:04:19.122]             list <- base::list
[18:04:19.122]             seq.int <- base::seq.int
[18:04:19.122]             signalCondition <- base::signalCondition
[18:04:19.122]             sys.calls <- base::sys.calls
[18:04:19.122]             `[[` <- base::`[[`
[18:04:19.122]             `+` <- base::`+`
[18:04:19.122]             `<<-` <- base::`<<-`
[18:04:19.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:19.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:19.122]                   3L)]
[18:04:19.122]             }
[18:04:19.122]             function(cond) {
[18:04:19.122]                 is_error <- inherits(cond, "error")
[18:04:19.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:19.122]                   NULL)
[18:04:19.122]                 if (is_error) {
[18:04:19.122]                   sessionInformation <- function() {
[18:04:19.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:19.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:19.122]                       search = base::search(), system = base::Sys.info())
[18:04:19.122]                   }
[18:04:19.122]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:19.122]                     cond$call), session = sessionInformation(), 
[18:04:19.122]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:19.122]                   signalCondition(cond)
[18:04:19.122]                 }
[18:04:19.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:19.122]                 "immediateCondition"))) {
[18:04:19.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:19.122]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:19.122]                   if (TRUE && !signal) {
[18:04:19.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.122]                     {
[18:04:19.122]                       inherits <- base::inherits
[18:04:19.122]                       invokeRestart <- base::invokeRestart
[18:04:19.122]                       is.null <- base::is.null
[18:04:19.122]                       muffled <- FALSE
[18:04:19.122]                       if (inherits(cond, "message")) {
[18:04:19.122]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.122]                         if (muffled) 
[18:04:19.122]                           invokeRestart("muffleMessage")
[18:04:19.122]                       }
[18:04:19.122]                       else if (inherits(cond, "warning")) {
[18:04:19.122]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.122]                         if (muffled) 
[18:04:19.122]                           invokeRestart("muffleWarning")
[18:04:19.122]                       }
[18:04:19.122]                       else if (inherits(cond, "condition")) {
[18:04:19.122]                         if (!is.null(pattern)) {
[18:04:19.122]                           computeRestarts <- base::computeRestarts
[18:04:19.122]                           grepl <- base::grepl
[18:04:19.122]                           restarts <- computeRestarts(cond)
[18:04:19.122]                           for (restart in restarts) {
[18:04:19.122]                             name <- restart$name
[18:04:19.122]                             if (is.null(name)) 
[18:04:19.122]                               next
[18:04:19.122]                             if (!grepl(pattern, name)) 
[18:04:19.122]                               next
[18:04:19.122]                             invokeRestart(restart)
[18:04:19.122]                             muffled <- TRUE
[18:04:19.122]                             break
[18:04:19.122]                           }
[18:04:19.122]                         }
[18:04:19.122]                       }
[18:04:19.122]                       invisible(muffled)
[18:04:19.122]                     }
[18:04:19.122]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.122]                   }
[18:04:19.122]                 }
[18:04:19.122]                 else {
[18:04:19.122]                   if (TRUE) {
[18:04:19.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.122]                     {
[18:04:19.122]                       inherits <- base::inherits
[18:04:19.122]                       invokeRestart <- base::invokeRestart
[18:04:19.122]                       is.null <- base::is.null
[18:04:19.122]                       muffled <- FALSE
[18:04:19.122]                       if (inherits(cond, "message")) {
[18:04:19.122]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.122]                         if (muffled) 
[18:04:19.122]                           invokeRestart("muffleMessage")
[18:04:19.122]                       }
[18:04:19.122]                       else if (inherits(cond, "warning")) {
[18:04:19.122]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.122]                         if (muffled) 
[18:04:19.122]                           invokeRestart("muffleWarning")
[18:04:19.122]                       }
[18:04:19.122]                       else if (inherits(cond, "condition")) {
[18:04:19.122]                         if (!is.null(pattern)) {
[18:04:19.122]                           computeRestarts <- base::computeRestarts
[18:04:19.122]                           grepl <- base::grepl
[18:04:19.122]                           restarts <- computeRestarts(cond)
[18:04:19.122]                           for (restart in restarts) {
[18:04:19.122]                             name <- restart$name
[18:04:19.122]                             if (is.null(name)) 
[18:04:19.122]                               next
[18:04:19.122]                             if (!grepl(pattern, name)) 
[18:04:19.122]                               next
[18:04:19.122]                             invokeRestart(restart)
[18:04:19.122]                             muffled <- TRUE
[18:04:19.122]                             break
[18:04:19.122]                           }
[18:04:19.122]                         }
[18:04:19.122]                       }
[18:04:19.122]                       invisible(muffled)
[18:04:19.122]                     }
[18:04:19.122]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.122]                   }
[18:04:19.122]                 }
[18:04:19.122]             }
[18:04:19.122]         }))
[18:04:19.122]     }, error = function(ex) {
[18:04:19.122]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:19.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.122]                 ...future.rng), started = ...future.startTime, 
[18:04:19.122]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:19.122]             version = "1.8"), class = "FutureResult")
[18:04:19.122]     }, finally = {
[18:04:19.122]         if (!identical(...future.workdir, getwd())) 
[18:04:19.122]             setwd(...future.workdir)
[18:04:19.122]         {
[18:04:19.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:19.122]                 ...future.oldOptions$nwarnings <- NULL
[18:04:19.122]             }
[18:04:19.122]             base::options(...future.oldOptions)
[18:04:19.122]             if (.Platform$OS.type == "windows") {
[18:04:19.122]                 old_names <- names(...future.oldEnvVars)
[18:04:19.122]                 envs <- base::Sys.getenv()
[18:04:19.122]                 names <- names(envs)
[18:04:19.122]                 common <- intersect(names, old_names)
[18:04:19.122]                 added <- setdiff(names, old_names)
[18:04:19.122]                 removed <- setdiff(old_names, names)
[18:04:19.122]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:19.122]                   envs[common]]
[18:04:19.122]                 NAMES <- toupper(changed)
[18:04:19.122]                 args <- list()
[18:04:19.122]                 for (kk in seq_along(NAMES)) {
[18:04:19.122]                   name <- changed[[kk]]
[18:04:19.122]                   NAME <- NAMES[[kk]]
[18:04:19.122]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.122]                     next
[18:04:19.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.122]                 }
[18:04:19.122]                 NAMES <- toupper(added)
[18:04:19.122]                 for (kk in seq_along(NAMES)) {
[18:04:19.122]                   name <- added[[kk]]
[18:04:19.122]                   NAME <- NAMES[[kk]]
[18:04:19.122]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.122]                     next
[18:04:19.122]                   args[[name]] <- ""
[18:04:19.122]                 }
[18:04:19.122]                 NAMES <- toupper(removed)
[18:04:19.122]                 for (kk in seq_along(NAMES)) {
[18:04:19.122]                   name <- removed[[kk]]
[18:04:19.122]                   NAME <- NAMES[[kk]]
[18:04:19.122]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.122]                     next
[18:04:19.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.122]                 }
[18:04:19.122]                 if (length(args) > 0) 
[18:04:19.122]                   base::do.call(base::Sys.setenv, args = args)
[18:04:19.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:19.122]             }
[18:04:19.122]             else {
[18:04:19.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:19.122]             }
[18:04:19.122]             {
[18:04:19.122]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:19.122]                   0L) {
[18:04:19.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:19.122]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:19.122]                   base::options(opts)
[18:04:19.122]                 }
[18:04:19.122]                 {
[18:04:19.122]                   {
[18:04:19.122]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:19.122]                     NULL
[18:04:19.122]                   }
[18:04:19.122]                   options(future.plan = NULL)
[18:04:19.122]                   if (is.na(NA_character_)) 
[18:04:19.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:19.122]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:19.122]                     .init = FALSE)
[18:04:19.122]                 }
[18:04:19.122]             }
[18:04:19.122]         }
[18:04:19.122]     })
[18:04:19.122]     if (TRUE) {
[18:04:19.122]         base::sink(type = "output", split = FALSE)
[18:04:19.122]         if (TRUE) {
[18:04:19.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:19.122]         }
[18:04:19.122]         else {
[18:04:19.122]             ...future.result["stdout"] <- base::list(NULL)
[18:04:19.122]         }
[18:04:19.122]         base::close(...future.stdout)
[18:04:19.122]         ...future.stdout <- NULL
[18:04:19.122]     }
[18:04:19.122]     ...future.result$conditions <- ...future.conditions
[18:04:19.122]     ...future.result$finished <- base::Sys.time()
[18:04:19.122]     ...future.result
[18:04:19.122] }
[18:04:19.129] requestCore(): workers = 2
[18:04:19.133] MulticoreFuture started
[18:04:19.134] - Launch lazy future ... done
[18:04:19.134] run() for ‘MulticoreFuture’ ... done
[18:04:19.135] plan(): Setting new future strategy stack:
[18:04:19.136] getGlobalsAndPackages() ...
[18:04:19.136] Searching for globals...
[18:04:19.136] List of future strategies:
[18:04:19.136] 1. sequential:
[18:04:19.136]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:19.136]    - tweaked: FALSE
[18:04:19.136]    - call: NULL
[18:04:19.138] plan(): nbrOfWorkers() = 1
[18:04:19.139] - globals found: [1] ‘{’
[18:04:19.140] Searching for globals ... DONE
[18:04:19.140] Resolving globals: FALSE
[18:04:19.141] 
[18:04:19.141] 
[18:04:19.142] getGlobalsAndPackages() ... DONE
[18:04:19.142] plan(): Setting new future strategy stack:
[18:04:19.143] run() for ‘Future’ ...
[18:04:19.143] - state: ‘created’
[18:04:19.142] List of future strategies:
[18:04:19.142] 1. multicore:
[18:04:19.142]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:19.142]    - tweaked: FALSE
[18:04:19.142]    - call: plan(strategy)
[18:04:19.143] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:19.151] plan(): nbrOfWorkers() = 2
[18:04:19.152] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:19.152] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:19.153]   - Field: ‘label’
[18:04:19.153]   - Field: ‘local’
[18:04:19.153]   - Field: ‘owner’
[18:04:19.154]   - Field: ‘envir’
[18:04:19.154]   - Field: ‘workers’
[18:04:19.154]   - Field: ‘packages’
[18:04:19.155]   - Field: ‘gc’
[18:04:19.155]   - Field: ‘job’
[18:04:19.155]   - Field: ‘conditions’
[18:04:19.155]   - Field: ‘expr’
[18:04:19.156]   - Field: ‘uuid’
[18:04:19.156]   - Field: ‘seed’
[18:04:19.156]   - Field: ‘version’
[18:04:19.157]   - Field: ‘result’
[18:04:19.157]   - Field: ‘asynchronous’
[18:04:19.157]   - Field: ‘calls’
[18:04:19.158]   - Field: ‘globals’
[18:04:19.158]   - Field: ‘stdout’
[18:04:19.158]   - Field: ‘earlySignal’
[18:04:19.158]   - Field: ‘lazy’
[18:04:19.159]   - Field: ‘state’
[18:04:19.159] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:19.159] - Launch lazy future ...
[18:04:19.160] Packages needed by the future expression (n = 0): <none>
[18:04:19.161] Packages needed by future strategies (n = 0): <none>
[18:04:19.162] {
[18:04:19.162]     {
[18:04:19.162]         {
[18:04:19.162]             ...future.startTime <- base::Sys.time()
[18:04:19.162]             {
[18:04:19.162]                 {
[18:04:19.162]                   {
[18:04:19.162]                     {
[18:04:19.162]                       base::local({
[18:04:19.162]                         has_future <- base::requireNamespace("future", 
[18:04:19.162]                           quietly = TRUE)
[18:04:19.162]                         if (has_future) {
[18:04:19.162]                           ns <- base::getNamespace("future")
[18:04:19.162]                           version <- ns[[".package"]][["version"]]
[18:04:19.162]                           if (is.null(version)) 
[18:04:19.162]                             version <- utils::packageVersion("future")
[18:04:19.162]                         }
[18:04:19.162]                         else {
[18:04:19.162]                           version <- NULL
[18:04:19.162]                         }
[18:04:19.162]                         if (!has_future || version < "1.8.0") {
[18:04:19.162]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:19.162]                             "", base::R.version$version.string), 
[18:04:19.162]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:19.162]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:19.162]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:19.162]                               "release", "version")], collapse = " "), 
[18:04:19.162]                             hostname = base::Sys.info()[["nodename"]])
[18:04:19.162]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:19.162]                             info)
[18:04:19.162]                           info <- base::paste(info, collapse = "; ")
[18:04:19.162]                           if (!has_future) {
[18:04:19.162]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:19.162]                               info)
[18:04:19.162]                           }
[18:04:19.162]                           else {
[18:04:19.162]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:19.162]                               info, version)
[18:04:19.162]                           }
[18:04:19.162]                           base::stop(msg)
[18:04:19.162]                         }
[18:04:19.162]                       })
[18:04:19.162]                     }
[18:04:19.162]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:19.162]                     base::options(mc.cores = 1L)
[18:04:19.162]                   }
[18:04:19.162]                   ...future.strategy.old <- future::plan("list")
[18:04:19.162]                   options(future.plan = NULL)
[18:04:19.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:19.162]                 }
[18:04:19.162]                 ...future.workdir <- getwd()
[18:04:19.162]             }
[18:04:19.162]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:19.162]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:19.162]         }
[18:04:19.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:19.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:19.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:19.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:19.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:19.162]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:19.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:19.162]             base::names(...future.oldOptions))
[18:04:19.162]     }
[18:04:19.162]     if (FALSE) {
[18:04:19.162]     }
[18:04:19.162]     else {
[18:04:19.162]         if (TRUE) {
[18:04:19.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:19.162]                 open = "w")
[18:04:19.162]         }
[18:04:19.162]         else {
[18:04:19.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:19.162]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:19.162]         }
[18:04:19.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:19.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:19.162]             base::sink(type = "output", split = FALSE)
[18:04:19.162]             base::close(...future.stdout)
[18:04:19.162]         }, add = TRUE)
[18:04:19.162]     }
[18:04:19.162]     ...future.frame <- base::sys.nframe()
[18:04:19.162]     ...future.conditions <- base::list()
[18:04:19.162]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:19.162]     if (FALSE) {
[18:04:19.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:19.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:19.162]     }
[18:04:19.162]     ...future.result <- base::tryCatch({
[18:04:19.162]         base::withCallingHandlers({
[18:04:19.162]             ...future.value <- base::withVisible(base::local({
[18:04:19.162]                 withCallingHandlers({
[18:04:19.162]                   {
[18:04:19.162]                     4
[18:04:19.162]                   }
[18:04:19.162]                 }, immediateCondition = function(cond) {
[18:04:19.162]                   save_rds <- function (object, pathname, ...) 
[18:04:19.162]                   {
[18:04:19.162]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:19.162]                     if (file_test("-f", pathname_tmp)) {
[18:04:19.162]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.162]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:19.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.162]                         fi_tmp[["mtime"]])
[18:04:19.162]                     }
[18:04:19.162]                     tryCatch({
[18:04:19.162]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:19.162]                     }, error = function(ex) {
[18:04:19.162]                       msg <- conditionMessage(ex)
[18:04:19.162]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.162]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:19.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.162]                         fi_tmp[["mtime"]], msg)
[18:04:19.162]                       ex$message <- msg
[18:04:19.162]                       stop(ex)
[18:04:19.162]                     })
[18:04:19.162]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:19.162]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:19.162]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:19.162]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.162]                       fi <- file.info(pathname)
[18:04:19.162]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:19.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.162]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:19.162]                         fi[["size"]], fi[["mtime"]])
[18:04:19.162]                       stop(msg)
[18:04:19.162]                     }
[18:04:19.162]                     invisible(pathname)
[18:04:19.162]                   }
[18:04:19.162]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:19.162]                     rootPath = tempdir()) 
[18:04:19.162]                   {
[18:04:19.162]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:19.162]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:19.162]                       tmpdir = path, fileext = ".rds")
[18:04:19.162]                     save_rds(obj, file)
[18:04:19.162]                   }
[18:04:19.162]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:19.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.162]                   {
[18:04:19.162]                     inherits <- base::inherits
[18:04:19.162]                     invokeRestart <- base::invokeRestart
[18:04:19.162]                     is.null <- base::is.null
[18:04:19.162]                     muffled <- FALSE
[18:04:19.162]                     if (inherits(cond, "message")) {
[18:04:19.162]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:19.162]                       if (muffled) 
[18:04:19.162]                         invokeRestart("muffleMessage")
[18:04:19.162]                     }
[18:04:19.162]                     else if (inherits(cond, "warning")) {
[18:04:19.162]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:19.162]                       if (muffled) 
[18:04:19.162]                         invokeRestart("muffleWarning")
[18:04:19.162]                     }
[18:04:19.162]                     else if (inherits(cond, "condition")) {
[18:04:19.162]                       if (!is.null(pattern)) {
[18:04:19.162]                         computeRestarts <- base::computeRestarts
[18:04:19.162]                         grepl <- base::grepl
[18:04:19.162]                         restarts <- computeRestarts(cond)
[18:04:19.162]                         for (restart in restarts) {
[18:04:19.162]                           name <- restart$name
[18:04:19.162]                           if (is.null(name)) 
[18:04:19.162]                             next
[18:04:19.162]                           if (!grepl(pattern, name)) 
[18:04:19.162]                             next
[18:04:19.162]                           invokeRestart(restart)
[18:04:19.162]                           muffled <- TRUE
[18:04:19.162]                           break
[18:04:19.162]                         }
[18:04:19.162]                       }
[18:04:19.162]                     }
[18:04:19.162]                     invisible(muffled)
[18:04:19.162]                   }
[18:04:19.162]                   muffleCondition(cond)
[18:04:19.162]                 })
[18:04:19.162]             }))
[18:04:19.162]             future::FutureResult(value = ...future.value$value, 
[18:04:19.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.162]                   ...future.rng), globalenv = if (FALSE) 
[18:04:19.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:19.162]                     ...future.globalenv.names))
[18:04:19.162]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:19.162]         }, condition = base::local({
[18:04:19.162]             c <- base::c
[18:04:19.162]             inherits <- base::inherits
[18:04:19.162]             invokeRestart <- base::invokeRestart
[18:04:19.162]             length <- base::length
[18:04:19.162]             list <- base::list
[18:04:19.162]             seq.int <- base::seq.int
[18:04:19.162]             signalCondition <- base::signalCondition
[18:04:19.162]             sys.calls <- base::sys.calls
[18:04:19.162]             `[[` <- base::`[[`
[18:04:19.162]             `+` <- base::`+`
[18:04:19.162]             `<<-` <- base::`<<-`
[18:04:19.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:19.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:19.162]                   3L)]
[18:04:19.162]             }
[18:04:19.162]             function(cond) {
[18:04:19.162]                 is_error <- inherits(cond, "error")
[18:04:19.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:19.162]                   NULL)
[18:04:19.162]                 if (is_error) {
[18:04:19.162]                   sessionInformation <- function() {
[18:04:19.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:19.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:19.162]                       search = base::search(), system = base::Sys.info())
[18:04:19.162]                   }
[18:04:19.162]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:19.162]                     cond$call), session = sessionInformation(), 
[18:04:19.162]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:19.162]                   signalCondition(cond)
[18:04:19.162]                 }
[18:04:19.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:19.162]                 "immediateCondition"))) {
[18:04:19.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:19.162]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:19.162]                   if (TRUE && !signal) {
[18:04:19.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.162]                     {
[18:04:19.162]                       inherits <- base::inherits
[18:04:19.162]                       invokeRestart <- base::invokeRestart
[18:04:19.162]                       is.null <- base::is.null
[18:04:19.162]                       muffled <- FALSE
[18:04:19.162]                       if (inherits(cond, "message")) {
[18:04:19.162]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.162]                         if (muffled) 
[18:04:19.162]                           invokeRestart("muffleMessage")
[18:04:19.162]                       }
[18:04:19.162]                       else if (inherits(cond, "warning")) {
[18:04:19.162]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.162]                         if (muffled) 
[18:04:19.162]                           invokeRestart("muffleWarning")
[18:04:19.162]                       }
[18:04:19.162]                       else if (inherits(cond, "condition")) {
[18:04:19.162]                         if (!is.null(pattern)) {
[18:04:19.162]                           computeRestarts <- base::computeRestarts
[18:04:19.162]                           grepl <- base::grepl
[18:04:19.162]                           restarts <- computeRestarts(cond)
[18:04:19.162]                           for (restart in restarts) {
[18:04:19.162]                             name <- restart$name
[18:04:19.162]                             if (is.null(name)) 
[18:04:19.162]                               next
[18:04:19.162]                             if (!grepl(pattern, name)) 
[18:04:19.162]                               next
[18:04:19.162]                             invokeRestart(restart)
[18:04:19.162]                             muffled <- TRUE
[18:04:19.162]                             break
[18:04:19.162]                           }
[18:04:19.162]                         }
[18:04:19.162]                       }
[18:04:19.162]                       invisible(muffled)
[18:04:19.162]                     }
[18:04:19.162]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.162]                   }
[18:04:19.162]                 }
[18:04:19.162]                 else {
[18:04:19.162]                   if (TRUE) {
[18:04:19.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.162]                     {
[18:04:19.162]                       inherits <- base::inherits
[18:04:19.162]                       invokeRestart <- base::invokeRestart
[18:04:19.162]                       is.null <- base::is.null
[18:04:19.162]                       muffled <- FALSE
[18:04:19.162]                       if (inherits(cond, "message")) {
[18:04:19.162]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.162]                         if (muffled) 
[18:04:19.162]                           invokeRestart("muffleMessage")
[18:04:19.162]                       }
[18:04:19.162]                       else if (inherits(cond, "warning")) {
[18:04:19.162]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.162]                         if (muffled) 
[18:04:19.162]                           invokeRestart("muffleWarning")
[18:04:19.162]                       }
[18:04:19.162]                       else if (inherits(cond, "condition")) {
[18:04:19.162]                         if (!is.null(pattern)) {
[18:04:19.162]                           computeRestarts <- base::computeRestarts
[18:04:19.162]                           grepl <- base::grepl
[18:04:19.162]                           restarts <- computeRestarts(cond)
[18:04:19.162]                           for (restart in restarts) {
[18:04:19.162]                             name <- restart$name
[18:04:19.162]                             if (is.null(name)) 
[18:04:19.162]                               next
[18:04:19.162]                             if (!grepl(pattern, name)) 
[18:04:19.162]                               next
[18:04:19.162]                             invokeRestart(restart)
[18:04:19.162]                             muffled <- TRUE
[18:04:19.162]                             break
[18:04:19.162]                           }
[18:04:19.162]                         }
[18:04:19.162]                       }
[18:04:19.162]                       invisible(muffled)
[18:04:19.162]                     }
[18:04:19.162]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.162]                   }
[18:04:19.162]                 }
[18:04:19.162]             }
[18:04:19.162]         }))
[18:04:19.162]     }, error = function(ex) {
[18:04:19.162]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:19.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.162]                 ...future.rng), started = ...future.startTime, 
[18:04:19.162]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:19.162]             version = "1.8"), class = "FutureResult")
[18:04:19.162]     }, finally = {
[18:04:19.162]         if (!identical(...future.workdir, getwd())) 
[18:04:19.162]             setwd(...future.workdir)
[18:04:19.162]         {
[18:04:19.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:19.162]                 ...future.oldOptions$nwarnings <- NULL
[18:04:19.162]             }
[18:04:19.162]             base::options(...future.oldOptions)
[18:04:19.162]             if (.Platform$OS.type == "windows") {
[18:04:19.162]                 old_names <- names(...future.oldEnvVars)
[18:04:19.162]                 envs <- base::Sys.getenv()
[18:04:19.162]                 names <- names(envs)
[18:04:19.162]                 common <- intersect(names, old_names)
[18:04:19.162]                 added <- setdiff(names, old_names)
[18:04:19.162]                 removed <- setdiff(old_names, names)
[18:04:19.162]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:19.162]                   envs[common]]
[18:04:19.162]                 NAMES <- toupper(changed)
[18:04:19.162]                 args <- list()
[18:04:19.162]                 for (kk in seq_along(NAMES)) {
[18:04:19.162]                   name <- changed[[kk]]
[18:04:19.162]                   NAME <- NAMES[[kk]]
[18:04:19.162]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.162]                     next
[18:04:19.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.162]                 }
[18:04:19.162]                 NAMES <- toupper(added)
[18:04:19.162]                 for (kk in seq_along(NAMES)) {
[18:04:19.162]                   name <- added[[kk]]
[18:04:19.162]                   NAME <- NAMES[[kk]]
[18:04:19.162]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.162]                     next
[18:04:19.162]                   args[[name]] <- ""
[18:04:19.162]                 }
[18:04:19.162]                 NAMES <- toupper(removed)
[18:04:19.162]                 for (kk in seq_along(NAMES)) {
[18:04:19.162]                   name <- removed[[kk]]
[18:04:19.162]                   NAME <- NAMES[[kk]]
[18:04:19.162]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.162]                     next
[18:04:19.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.162]                 }
[18:04:19.162]                 if (length(args) > 0) 
[18:04:19.162]                   base::do.call(base::Sys.setenv, args = args)
[18:04:19.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:19.162]             }
[18:04:19.162]             else {
[18:04:19.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:19.162]             }
[18:04:19.162]             {
[18:04:19.162]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:19.162]                   0L) {
[18:04:19.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:19.162]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:19.162]                   base::options(opts)
[18:04:19.162]                 }
[18:04:19.162]                 {
[18:04:19.162]                   {
[18:04:19.162]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:19.162]                     NULL
[18:04:19.162]                   }
[18:04:19.162]                   options(future.plan = NULL)
[18:04:19.162]                   if (is.na(NA_character_)) 
[18:04:19.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:19.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:19.162]                     .init = FALSE)
[18:04:19.162]                 }
[18:04:19.162]             }
[18:04:19.162]         }
[18:04:19.162]     })
[18:04:19.162]     if (TRUE) {
[18:04:19.162]         base::sink(type = "output", split = FALSE)
[18:04:19.162]         if (TRUE) {
[18:04:19.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:19.162]         }
[18:04:19.162]         else {
[18:04:19.162]             ...future.result["stdout"] <- base::list(NULL)
[18:04:19.162]         }
[18:04:19.162]         base::close(...future.stdout)
[18:04:19.162]         ...future.stdout <- NULL
[18:04:19.162]     }
[18:04:19.162]     ...future.result$conditions <- ...future.conditions
[18:04:19.162]     ...future.result$finished <- base::Sys.time()
[18:04:19.162]     ...future.result
[18:04:19.162] }
[18:04:19.168] requestCore(): workers = 2
[18:04:19.169] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:19.180] result() for MulticoreFuture ...
[18:04:19.182] result() for MulticoreFuture ...
[18:04:19.183] result() for MulticoreFuture ... done
[18:04:19.183] result() for MulticoreFuture ... done
[18:04:19.183] result() for MulticoreFuture ...
[18:04:19.184] result() for MulticoreFuture ... done
[18:04:19.188] MulticoreFuture started
[18:04:19.189] - Launch lazy future ... done
[18:04:19.189] run() for ‘MulticoreFuture’ ... done
[18:04:19.190] plan(): Setting new future strategy stack:
<environment: 0x5e3c2c254990> 
[18:04:19.190] List of future strategies:
[18:04:19.190] 1. sequential:
[18:04:19.190]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:19.190]    - tweaked: FALSE
[18:04:19.190]    - call: NULL
[18:04:19.193] plan(): nbrOfWorkers() = 1
<environment: 0x5e3c2ce61f30> 
[18:04:19.196] plan(): Setting new future strategy stack:
[18:04:19.197] List of future strategies:
[18:04:19.197] 1. multicore:
[18:04:19.197]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:19.197]    - tweaked: FALSE
[18:04:19.197]    - call: plan(strategy)
[18:04:19.206] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:19.210] resolve() on environment ...
[18:04:19.210]  recursive: 0
[18:04:19.212]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:19.212] signalConditionsASAP(numeric, pos=1) ...
[18:04:19.212] - nx: 4
[18:04:19.213] - relay: TRUE
[18:04:19.213] - stdout: TRUE
[18:04:19.213] - signal: TRUE
[18:04:19.214] - resignal: FALSE
[18:04:19.214] - force: TRUE
[18:04:19.214] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.214] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.215]  - until=2
[18:04:19.215]  - relaying element #2
[18:04:19.215] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:19.216] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.216] signalConditionsASAP(NULL, pos=1) ... done
[18:04:19.216]  length: 3 (resolved future 1)
[18:04:19.216] Future #2
[18:04:19.217] result() for MulticoreFuture ...
[18:04:19.217] result() for MulticoreFuture ... done
[18:04:19.217] result() for MulticoreFuture ...
[18:04:19.218] result() for MulticoreFuture ... done
[18:04:19.218] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:19.218] - nx: 4
[18:04:19.219] - relay: TRUE
[18:04:19.219] - stdout: TRUE
[18:04:19.219] - signal: TRUE
[18:04:19.219] - resignal: FALSE
[18:04:19.220] - force: TRUE
[18:04:19.220] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:19.220] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.220]  - until=2
[18:04:19.221]  - relaying element #2
[18:04:19.221] result() for MulticoreFuture ...
[18:04:19.221] result() for MulticoreFuture ... done
[18:04:19.222] result() for MulticoreFuture ...
[18:04:19.222] result() for MulticoreFuture ... done
[18:04:19.222] result() for MulticoreFuture ...
[18:04:19.222] result() for MulticoreFuture ... done
[18:04:19.223] result() for MulticoreFuture ...
[18:04:19.223] result() for MulticoreFuture ... done
[18:04:19.223] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:19.224] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:19.224] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:19.224]  length: 2 (resolved future 2)
[18:04:19.225] Future #3
[18:04:19.225] result() for MulticoreFuture ...
[18:04:19.227] result() for MulticoreFuture ...
[18:04:19.227] result() for MulticoreFuture ... done
[18:04:19.227] result() for MulticoreFuture ... done
[18:04:19.228] result() for MulticoreFuture ...
[18:04:19.228] result() for MulticoreFuture ... done
[18:04:19.228] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:19.229] - nx: 4
[18:04:19.229] - relay: TRUE
[18:04:19.229] - stdout: TRUE
[18:04:19.230] - signal: TRUE
[18:04:19.230] - resignal: FALSE
[18:04:19.230] - force: TRUE
[18:04:19.230] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:19.231] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:19.231]  - until=3
[18:04:19.231]  - relaying element #3
[18:04:19.231] result() for MulticoreFuture ...
[18:04:19.232] result() for MulticoreFuture ... done
[18:04:19.232] result() for MulticoreFuture ...
[18:04:19.232] result() for MulticoreFuture ... done
[18:04:19.233] result() for MulticoreFuture ...
[18:04:19.233] result() for MulticoreFuture ... done
[18:04:19.233] result() for MulticoreFuture ...
[18:04:19.233] result() for MulticoreFuture ... done
[18:04:19.234] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:19.234] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:19.234] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:19.235]  length: 1 (resolved future 3)
[18:04:19.235] Future #4
[18:04:19.236] result() for MulticoreFuture ...
[18:04:19.237] result() for MulticoreFuture ...
[18:04:19.238] result() for MulticoreFuture ... done
[18:04:19.238] result() for MulticoreFuture ... done
[18:04:19.238] result() for MulticoreFuture ...
[18:04:19.238] result() for MulticoreFuture ... done
[18:04:19.239] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:19.239] - nx: 4
[18:04:19.239] - relay: TRUE
[18:04:19.240] - stdout: TRUE
[18:04:19.240] - signal: TRUE
[18:04:19.240] - resignal: FALSE
[18:04:19.240] - force: TRUE
[18:04:19.241] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:19.241] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:19.241]  - until=4
[18:04:19.242]  - relaying element #4
[18:04:19.242] result() for MulticoreFuture ...
[18:04:19.242] result() for MulticoreFuture ... done
[18:04:19.242] result() for MulticoreFuture ...
[18:04:19.243] result() for MulticoreFuture ... done
[18:04:19.243] result() for MulticoreFuture ...
[18:04:19.243] result() for MulticoreFuture ... done
[18:04:19.244] result() for MulticoreFuture ...
[18:04:19.244] result() for MulticoreFuture ... done
[18:04:19.244] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:19.244] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:19.245] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:19.245]  length: 0 (resolved future 4)
[18:04:19.245] Relaying remaining futures
[18:04:19.245] signalConditionsASAP(NULL, pos=0) ...
[18:04:19.246] - nx: 4
[18:04:19.246] - relay: TRUE
[18:04:19.246] - stdout: TRUE
[18:04:19.246] - signal: TRUE
[18:04:19.247] - resignal: FALSE
[18:04:19.247] - force: TRUE
[18:04:19.247] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:19.247] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:19.248] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:19.248] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:19.248] signalConditionsASAP(NULL, pos=0) ... done
[18:04:19.254] resolve() on environment ... DONE
[18:04:19.254] result() for MulticoreFuture ...
[18:04:19.255] result() for MulticoreFuture ... done
[18:04:19.255] result() for MulticoreFuture ...
[18:04:19.255] result() for MulticoreFuture ... done
[18:04:19.255] result() for MulticoreFuture ...
[18:04:19.256] result() for MulticoreFuture ... done
[18:04:19.256] result() for MulticoreFuture ...
[18:04:19.256] result() for MulticoreFuture ... done
[18:04:19.257] result() for MulticoreFuture ...
[18:04:19.257] result() for MulticoreFuture ... done
[18:04:19.257] result() for MulticoreFuture ...
[18:04:19.257] result() for MulticoreFuture ... done
<environment: 0x5e3c2cf131d8> 
Dimensions: c(2, 1, 3, 1)
[18:04:19.258] getGlobalsAndPackages() ...
[18:04:19.259] Searching for globals...
[18:04:19.259] 
[18:04:19.260] Searching for globals ... DONE
[18:04:19.260] - globals: [0] <none>
[18:04:19.260] getGlobalsAndPackages() ... DONE
[18:04:19.261] run() for ‘Future’ ...
[18:04:19.261] - state: ‘created’
[18:04:19.261] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:19.269] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:19.269] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:19.269]   - Field: ‘label’
[18:04:19.270]   - Field: ‘local’
[18:04:19.270]   - Field: ‘owner’
[18:04:19.270]   - Field: ‘envir’
[18:04:19.270]   - Field: ‘workers’
[18:04:19.270]   - Field: ‘packages’
[18:04:19.271]   - Field: ‘gc’
[18:04:19.271]   - Field: ‘job’
[18:04:19.271]   - Field: ‘conditions’
[18:04:19.271]   - Field: ‘expr’
[18:04:19.272]   - Field: ‘uuid’
[18:04:19.272]   - Field: ‘seed’
[18:04:19.272]   - Field: ‘version’
[18:04:19.272]   - Field: ‘result’
[18:04:19.273]   - Field: ‘asynchronous’
[18:04:19.273]   - Field: ‘calls’
[18:04:19.273]   - Field: ‘globals’
[18:04:19.273]   - Field: ‘stdout’
[18:04:19.274]   - Field: ‘earlySignal’
[18:04:19.274]   - Field: ‘lazy’
[18:04:19.274]   - Field: ‘state’
[18:04:19.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:19.275] - Launch lazy future ...
[18:04:19.275] Packages needed by the future expression (n = 0): <none>
[18:04:19.276] Packages needed by future strategies (n = 0): <none>
[18:04:19.277] {
[18:04:19.277]     {
[18:04:19.277]         {
[18:04:19.277]             ...future.startTime <- base::Sys.time()
[18:04:19.277]             {
[18:04:19.277]                 {
[18:04:19.277]                   {
[18:04:19.277]                     {
[18:04:19.277]                       base::local({
[18:04:19.277]                         has_future <- base::requireNamespace("future", 
[18:04:19.277]                           quietly = TRUE)
[18:04:19.277]                         if (has_future) {
[18:04:19.277]                           ns <- base::getNamespace("future")
[18:04:19.277]                           version <- ns[[".package"]][["version"]]
[18:04:19.277]                           if (is.null(version)) 
[18:04:19.277]                             version <- utils::packageVersion("future")
[18:04:19.277]                         }
[18:04:19.277]                         else {
[18:04:19.277]                           version <- NULL
[18:04:19.277]                         }
[18:04:19.277]                         if (!has_future || version < "1.8.0") {
[18:04:19.277]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:19.277]                             "", base::R.version$version.string), 
[18:04:19.277]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:19.277]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:19.277]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:19.277]                               "release", "version")], collapse = " "), 
[18:04:19.277]                             hostname = base::Sys.info()[["nodename"]])
[18:04:19.277]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:19.277]                             info)
[18:04:19.277]                           info <- base::paste(info, collapse = "; ")
[18:04:19.277]                           if (!has_future) {
[18:04:19.277]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:19.277]                               info)
[18:04:19.277]                           }
[18:04:19.277]                           else {
[18:04:19.277]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:19.277]                               info, version)
[18:04:19.277]                           }
[18:04:19.277]                           base::stop(msg)
[18:04:19.277]                         }
[18:04:19.277]                       })
[18:04:19.277]                     }
[18:04:19.277]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:19.277]                     base::options(mc.cores = 1L)
[18:04:19.277]                   }
[18:04:19.277]                   ...future.strategy.old <- future::plan("list")
[18:04:19.277]                   options(future.plan = NULL)
[18:04:19.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:19.277]                 }
[18:04:19.277]                 ...future.workdir <- getwd()
[18:04:19.277]             }
[18:04:19.277]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:19.277]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:19.277]         }
[18:04:19.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:19.277]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:19.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:19.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:19.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:19.277]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:19.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:19.277]             base::names(...future.oldOptions))
[18:04:19.277]     }
[18:04:19.277]     if (FALSE) {
[18:04:19.277]     }
[18:04:19.277]     else {
[18:04:19.277]         if (TRUE) {
[18:04:19.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:19.277]                 open = "w")
[18:04:19.277]         }
[18:04:19.277]         else {
[18:04:19.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:19.277]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:19.277]         }
[18:04:19.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:19.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:19.277]             base::sink(type = "output", split = FALSE)
[18:04:19.277]             base::close(...future.stdout)
[18:04:19.277]         }, add = TRUE)
[18:04:19.277]     }
[18:04:19.277]     ...future.frame <- base::sys.nframe()
[18:04:19.277]     ...future.conditions <- base::list()
[18:04:19.277]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:19.277]     if (FALSE) {
[18:04:19.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:19.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:19.277]     }
[18:04:19.277]     ...future.result <- base::tryCatch({
[18:04:19.277]         base::withCallingHandlers({
[18:04:19.277]             ...future.value <- base::withVisible(base::local({
[18:04:19.277]                 withCallingHandlers({
[18:04:19.277]                   2
[18:04:19.277]                 }, immediateCondition = function(cond) {
[18:04:19.277]                   save_rds <- function (object, pathname, ...) 
[18:04:19.277]                   {
[18:04:19.277]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:19.277]                     if (file_test("-f", pathname_tmp)) {
[18:04:19.277]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.277]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:19.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.277]                         fi_tmp[["mtime"]])
[18:04:19.277]                     }
[18:04:19.277]                     tryCatch({
[18:04:19.277]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:19.277]                     }, error = function(ex) {
[18:04:19.277]                       msg <- conditionMessage(ex)
[18:04:19.277]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.277]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:19.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.277]                         fi_tmp[["mtime"]], msg)
[18:04:19.277]                       ex$message <- msg
[18:04:19.277]                       stop(ex)
[18:04:19.277]                     })
[18:04:19.277]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:19.277]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:19.277]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:19.277]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.277]                       fi <- file.info(pathname)
[18:04:19.277]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:19.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.277]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:19.277]                         fi[["size"]], fi[["mtime"]])
[18:04:19.277]                       stop(msg)
[18:04:19.277]                     }
[18:04:19.277]                     invisible(pathname)
[18:04:19.277]                   }
[18:04:19.277]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:19.277]                     rootPath = tempdir()) 
[18:04:19.277]                   {
[18:04:19.277]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:19.277]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:19.277]                       tmpdir = path, fileext = ".rds")
[18:04:19.277]                     save_rds(obj, file)
[18:04:19.277]                   }
[18:04:19.277]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:19.277]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.277]                   {
[18:04:19.277]                     inherits <- base::inherits
[18:04:19.277]                     invokeRestart <- base::invokeRestart
[18:04:19.277]                     is.null <- base::is.null
[18:04:19.277]                     muffled <- FALSE
[18:04:19.277]                     if (inherits(cond, "message")) {
[18:04:19.277]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:19.277]                       if (muffled) 
[18:04:19.277]                         invokeRestart("muffleMessage")
[18:04:19.277]                     }
[18:04:19.277]                     else if (inherits(cond, "warning")) {
[18:04:19.277]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:19.277]                       if (muffled) 
[18:04:19.277]                         invokeRestart("muffleWarning")
[18:04:19.277]                     }
[18:04:19.277]                     else if (inherits(cond, "condition")) {
[18:04:19.277]                       if (!is.null(pattern)) {
[18:04:19.277]                         computeRestarts <- base::computeRestarts
[18:04:19.277]                         grepl <- base::grepl
[18:04:19.277]                         restarts <- computeRestarts(cond)
[18:04:19.277]                         for (restart in restarts) {
[18:04:19.277]                           name <- restart$name
[18:04:19.277]                           if (is.null(name)) 
[18:04:19.277]                             next
[18:04:19.277]                           if (!grepl(pattern, name)) 
[18:04:19.277]                             next
[18:04:19.277]                           invokeRestart(restart)
[18:04:19.277]                           muffled <- TRUE
[18:04:19.277]                           break
[18:04:19.277]                         }
[18:04:19.277]                       }
[18:04:19.277]                     }
[18:04:19.277]                     invisible(muffled)
[18:04:19.277]                   }
[18:04:19.277]                   muffleCondition(cond)
[18:04:19.277]                 })
[18:04:19.277]             }))
[18:04:19.277]             future::FutureResult(value = ...future.value$value, 
[18:04:19.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.277]                   ...future.rng), globalenv = if (FALSE) 
[18:04:19.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:19.277]                     ...future.globalenv.names))
[18:04:19.277]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:19.277]         }, condition = base::local({
[18:04:19.277]             c <- base::c
[18:04:19.277]             inherits <- base::inherits
[18:04:19.277]             invokeRestart <- base::invokeRestart
[18:04:19.277]             length <- base::length
[18:04:19.277]             list <- base::list
[18:04:19.277]             seq.int <- base::seq.int
[18:04:19.277]             signalCondition <- base::signalCondition
[18:04:19.277]             sys.calls <- base::sys.calls
[18:04:19.277]             `[[` <- base::`[[`
[18:04:19.277]             `+` <- base::`+`
[18:04:19.277]             `<<-` <- base::`<<-`
[18:04:19.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:19.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:19.277]                   3L)]
[18:04:19.277]             }
[18:04:19.277]             function(cond) {
[18:04:19.277]                 is_error <- inherits(cond, "error")
[18:04:19.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:19.277]                   NULL)
[18:04:19.277]                 if (is_error) {
[18:04:19.277]                   sessionInformation <- function() {
[18:04:19.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:19.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:19.277]                       search = base::search(), system = base::Sys.info())
[18:04:19.277]                   }
[18:04:19.277]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:19.277]                     cond$call), session = sessionInformation(), 
[18:04:19.277]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:19.277]                   signalCondition(cond)
[18:04:19.277]                 }
[18:04:19.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:19.277]                 "immediateCondition"))) {
[18:04:19.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:19.277]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:19.277]                   if (TRUE && !signal) {
[18:04:19.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.277]                     {
[18:04:19.277]                       inherits <- base::inherits
[18:04:19.277]                       invokeRestart <- base::invokeRestart
[18:04:19.277]                       is.null <- base::is.null
[18:04:19.277]                       muffled <- FALSE
[18:04:19.277]                       if (inherits(cond, "message")) {
[18:04:19.277]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.277]                         if (muffled) 
[18:04:19.277]                           invokeRestart("muffleMessage")
[18:04:19.277]                       }
[18:04:19.277]                       else if (inherits(cond, "warning")) {
[18:04:19.277]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.277]                         if (muffled) 
[18:04:19.277]                           invokeRestart("muffleWarning")
[18:04:19.277]                       }
[18:04:19.277]                       else if (inherits(cond, "condition")) {
[18:04:19.277]                         if (!is.null(pattern)) {
[18:04:19.277]                           computeRestarts <- base::computeRestarts
[18:04:19.277]                           grepl <- base::grepl
[18:04:19.277]                           restarts <- computeRestarts(cond)
[18:04:19.277]                           for (restart in restarts) {
[18:04:19.277]                             name <- restart$name
[18:04:19.277]                             if (is.null(name)) 
[18:04:19.277]                               next
[18:04:19.277]                             if (!grepl(pattern, name)) 
[18:04:19.277]                               next
[18:04:19.277]                             invokeRestart(restart)
[18:04:19.277]                             muffled <- TRUE
[18:04:19.277]                             break
[18:04:19.277]                           }
[18:04:19.277]                         }
[18:04:19.277]                       }
[18:04:19.277]                       invisible(muffled)
[18:04:19.277]                     }
[18:04:19.277]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.277]                   }
[18:04:19.277]                 }
[18:04:19.277]                 else {
[18:04:19.277]                   if (TRUE) {
[18:04:19.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.277]                     {
[18:04:19.277]                       inherits <- base::inherits
[18:04:19.277]                       invokeRestart <- base::invokeRestart
[18:04:19.277]                       is.null <- base::is.null
[18:04:19.277]                       muffled <- FALSE
[18:04:19.277]                       if (inherits(cond, "message")) {
[18:04:19.277]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.277]                         if (muffled) 
[18:04:19.277]                           invokeRestart("muffleMessage")
[18:04:19.277]                       }
[18:04:19.277]                       else if (inherits(cond, "warning")) {
[18:04:19.277]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.277]                         if (muffled) 
[18:04:19.277]                           invokeRestart("muffleWarning")
[18:04:19.277]                       }
[18:04:19.277]                       else if (inherits(cond, "condition")) {
[18:04:19.277]                         if (!is.null(pattern)) {
[18:04:19.277]                           computeRestarts <- base::computeRestarts
[18:04:19.277]                           grepl <- base::grepl
[18:04:19.277]                           restarts <- computeRestarts(cond)
[18:04:19.277]                           for (restart in restarts) {
[18:04:19.277]                             name <- restart$name
[18:04:19.277]                             if (is.null(name)) 
[18:04:19.277]                               next
[18:04:19.277]                             if (!grepl(pattern, name)) 
[18:04:19.277]                               next
[18:04:19.277]                             invokeRestart(restart)
[18:04:19.277]                             muffled <- TRUE
[18:04:19.277]                             break
[18:04:19.277]                           }
[18:04:19.277]                         }
[18:04:19.277]                       }
[18:04:19.277]                       invisible(muffled)
[18:04:19.277]                     }
[18:04:19.277]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.277]                   }
[18:04:19.277]                 }
[18:04:19.277]             }
[18:04:19.277]         }))
[18:04:19.277]     }, error = function(ex) {
[18:04:19.277]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:19.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.277]                 ...future.rng), started = ...future.startTime, 
[18:04:19.277]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:19.277]             version = "1.8"), class = "FutureResult")
[18:04:19.277]     }, finally = {
[18:04:19.277]         if (!identical(...future.workdir, getwd())) 
[18:04:19.277]             setwd(...future.workdir)
[18:04:19.277]         {
[18:04:19.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:19.277]                 ...future.oldOptions$nwarnings <- NULL
[18:04:19.277]             }
[18:04:19.277]             base::options(...future.oldOptions)
[18:04:19.277]             if (.Platform$OS.type == "windows") {
[18:04:19.277]                 old_names <- names(...future.oldEnvVars)
[18:04:19.277]                 envs <- base::Sys.getenv()
[18:04:19.277]                 names <- names(envs)
[18:04:19.277]                 common <- intersect(names, old_names)
[18:04:19.277]                 added <- setdiff(names, old_names)
[18:04:19.277]                 removed <- setdiff(old_names, names)
[18:04:19.277]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:19.277]                   envs[common]]
[18:04:19.277]                 NAMES <- toupper(changed)
[18:04:19.277]                 args <- list()
[18:04:19.277]                 for (kk in seq_along(NAMES)) {
[18:04:19.277]                   name <- changed[[kk]]
[18:04:19.277]                   NAME <- NAMES[[kk]]
[18:04:19.277]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.277]                     next
[18:04:19.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.277]                 }
[18:04:19.277]                 NAMES <- toupper(added)
[18:04:19.277]                 for (kk in seq_along(NAMES)) {
[18:04:19.277]                   name <- added[[kk]]
[18:04:19.277]                   NAME <- NAMES[[kk]]
[18:04:19.277]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.277]                     next
[18:04:19.277]                   args[[name]] <- ""
[18:04:19.277]                 }
[18:04:19.277]                 NAMES <- toupper(removed)
[18:04:19.277]                 for (kk in seq_along(NAMES)) {
[18:04:19.277]                   name <- removed[[kk]]
[18:04:19.277]                   NAME <- NAMES[[kk]]
[18:04:19.277]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.277]                     next
[18:04:19.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.277]                 }
[18:04:19.277]                 if (length(args) > 0) 
[18:04:19.277]                   base::do.call(base::Sys.setenv, args = args)
[18:04:19.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:19.277]             }
[18:04:19.277]             else {
[18:04:19.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:19.277]             }
[18:04:19.277]             {
[18:04:19.277]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:19.277]                   0L) {
[18:04:19.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:19.277]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:19.277]                   base::options(opts)
[18:04:19.277]                 }
[18:04:19.277]                 {
[18:04:19.277]                   {
[18:04:19.277]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:19.277]                     NULL
[18:04:19.277]                   }
[18:04:19.277]                   options(future.plan = NULL)
[18:04:19.277]                   if (is.na(NA_character_)) 
[18:04:19.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:19.277]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:19.277]                     .init = FALSE)
[18:04:19.277]                 }
[18:04:19.277]             }
[18:04:19.277]         }
[18:04:19.277]     })
[18:04:19.277]     if (TRUE) {
[18:04:19.277]         base::sink(type = "output", split = FALSE)
[18:04:19.277]         if (TRUE) {
[18:04:19.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:19.277]         }
[18:04:19.277]         else {
[18:04:19.277]             ...future.result["stdout"] <- base::list(NULL)
[18:04:19.277]         }
[18:04:19.277]         base::close(...future.stdout)
[18:04:19.277]         ...future.stdout <- NULL
[18:04:19.277]     }
[18:04:19.277]     ...future.result$conditions <- ...future.conditions
[18:04:19.277]     ...future.result$finished <- base::Sys.time()
[18:04:19.277]     ...future.result
[18:04:19.277] }
[18:04:19.281] requestCore(): workers = 2
[18:04:19.286] MulticoreFuture started
[18:04:19.287] - Launch lazy future ... done
[18:04:19.287] run() for ‘MulticoreFuture’ ... done
[18:04:19.288] getGlobalsAndPackages() ...
[18:04:19.288] Searching for globals...
[18:04:19.290] 
[18:04:19.290] Searching for globals ... DONE
[18:04:19.291] - globals: [0] <none>
[18:04:19.291] getGlobalsAndPackages() ... DONE
[18:04:19.291] plan(): Setting new future strategy stack:
[18:04:19.292] run() for ‘Future’ ...
[18:04:19.292] - state: ‘created’
[18:04:19.293] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:19.292] List of future strategies:
[18:04:19.292] 1. sequential:
[18:04:19.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:19.292]    - tweaked: FALSE
[18:04:19.292]    - call: NULL
[18:04:19.296] plan(): nbrOfWorkers() = 1
[18:04:19.303] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:19.303] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:19.303] plan(): Setting new future strategy stack:
[18:04:19.304]   - Field: ‘label’
[18:04:19.304]   - Field: ‘local’
[18:04:19.304] List of future strategies:
[18:04:19.304] 1. multicore:
[18:04:19.304]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:19.304]    - tweaked: FALSE
[18:04:19.304]    - call: plan(strategy)
[18:04:19.304]   - Field: ‘owner’
[18:04:19.305]   - Field: ‘envir’
[18:04:19.305]   - Field: ‘workers’
[18:04:19.305]   - Field: ‘packages’
[18:04:19.306]   - Field: ‘gc’
[18:04:19.306]   - Field: ‘job’
[18:04:19.306]   - Field: ‘conditions’
[18:04:19.307]   - Field: ‘expr’
[18:04:19.307]   - Field: ‘uuid’
[18:04:19.307]   - Field: ‘seed’
[18:04:19.308]   - Field: ‘version’
[18:04:19.308]   - Field: ‘result’
[18:04:19.308]   - Field: ‘asynchronous’
[18:04:19.310]   - Field: ‘calls’
[18:04:19.310]   - Field: ‘globals’
[18:04:19.311]   - Field: ‘stdout’
[18:04:19.311]   - Field: ‘earlySignal’
[18:04:19.311]   - Field: ‘lazy’
[18:04:19.312]   - Field: ‘state’
[18:04:19.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:19.312] - Launch lazy future ...
[18:04:19.313] Packages needed by the future expression (n = 0): <none>
[18:04:19.314] Packages needed by future strategies (n = 0): <none>
[18:04:19.319] plan(): nbrOfWorkers() = 2
[18:04:19.316] {
[18:04:19.316]     {
[18:04:19.316]         {
[18:04:19.316]             ...future.startTime <- base::Sys.time()
[18:04:19.316]             {
[18:04:19.316]                 {
[18:04:19.316]                   {
[18:04:19.316]                     {
[18:04:19.316]                       base::local({
[18:04:19.316]                         has_future <- base::requireNamespace("future", 
[18:04:19.316]                           quietly = TRUE)
[18:04:19.316]                         if (has_future) {
[18:04:19.316]                           ns <- base::getNamespace("future")
[18:04:19.316]                           version <- ns[[".package"]][["version"]]
[18:04:19.316]                           if (is.null(version)) 
[18:04:19.316]                             version <- utils::packageVersion("future")
[18:04:19.316]                         }
[18:04:19.316]                         else {
[18:04:19.316]                           version <- NULL
[18:04:19.316]                         }
[18:04:19.316]                         if (!has_future || version < "1.8.0") {
[18:04:19.316]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:19.316]                             "", base::R.version$version.string), 
[18:04:19.316]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:19.316]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:19.316]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:19.316]                               "release", "version")], collapse = " "), 
[18:04:19.316]                             hostname = base::Sys.info()[["nodename"]])
[18:04:19.316]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:19.316]                             info)
[18:04:19.316]                           info <- base::paste(info, collapse = "; ")
[18:04:19.316]                           if (!has_future) {
[18:04:19.316]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:19.316]                               info)
[18:04:19.316]                           }
[18:04:19.316]                           else {
[18:04:19.316]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:19.316]                               info, version)
[18:04:19.316]                           }
[18:04:19.316]                           base::stop(msg)
[18:04:19.316]                         }
[18:04:19.316]                       })
[18:04:19.316]                     }
[18:04:19.316]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:19.316]                     base::options(mc.cores = 1L)
[18:04:19.316]                   }
[18:04:19.316]                   ...future.strategy.old <- future::plan("list")
[18:04:19.316]                   options(future.plan = NULL)
[18:04:19.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:19.316]                 }
[18:04:19.316]                 ...future.workdir <- getwd()
[18:04:19.316]             }
[18:04:19.316]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:19.316]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:19.316]         }
[18:04:19.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:19.316]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:19.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:19.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:19.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:19.316]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:19.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:19.316]             base::names(...future.oldOptions))
[18:04:19.316]     }
[18:04:19.316]     if (FALSE) {
[18:04:19.316]     }
[18:04:19.316]     else {
[18:04:19.316]         if (TRUE) {
[18:04:19.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:19.316]                 open = "w")
[18:04:19.316]         }
[18:04:19.316]         else {
[18:04:19.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:19.316]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:19.316]         }
[18:04:19.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:19.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:19.316]             base::sink(type = "output", split = FALSE)
[18:04:19.316]             base::close(...future.stdout)
[18:04:19.316]         }, add = TRUE)
[18:04:19.316]     }
[18:04:19.316]     ...future.frame <- base::sys.nframe()
[18:04:19.316]     ...future.conditions <- base::list()
[18:04:19.316]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:19.316]     if (FALSE) {
[18:04:19.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:19.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:19.316]     }
[18:04:19.316]     ...future.result <- base::tryCatch({
[18:04:19.316]         base::withCallingHandlers({
[18:04:19.316]             ...future.value <- base::withVisible(base::local({
[18:04:19.316]                 withCallingHandlers({
[18:04:19.316]                   NULL
[18:04:19.316]                 }, immediateCondition = function(cond) {
[18:04:19.316]                   save_rds <- function (object, pathname, ...) 
[18:04:19.316]                   {
[18:04:19.316]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:19.316]                     if (file_test("-f", pathname_tmp)) {
[18:04:19.316]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.316]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:19.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.316]                         fi_tmp[["mtime"]])
[18:04:19.316]                     }
[18:04:19.316]                     tryCatch({
[18:04:19.316]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:19.316]                     }, error = function(ex) {
[18:04:19.316]                       msg <- conditionMessage(ex)
[18:04:19.316]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.316]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:19.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.316]                         fi_tmp[["mtime"]], msg)
[18:04:19.316]                       ex$message <- msg
[18:04:19.316]                       stop(ex)
[18:04:19.316]                     })
[18:04:19.316]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:19.316]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:19.316]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:19.316]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.316]                       fi <- file.info(pathname)
[18:04:19.316]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:19.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.316]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:19.316]                         fi[["size"]], fi[["mtime"]])
[18:04:19.316]                       stop(msg)
[18:04:19.316]                     }
[18:04:19.316]                     invisible(pathname)
[18:04:19.316]                   }
[18:04:19.316]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:19.316]                     rootPath = tempdir()) 
[18:04:19.316]                   {
[18:04:19.316]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:19.316]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:19.316]                       tmpdir = path, fileext = ".rds")
[18:04:19.316]                     save_rds(obj, file)
[18:04:19.316]                   }
[18:04:19.316]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:19.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.316]                   {
[18:04:19.316]                     inherits <- base::inherits
[18:04:19.316]                     invokeRestart <- base::invokeRestart
[18:04:19.316]                     is.null <- base::is.null
[18:04:19.316]                     muffled <- FALSE
[18:04:19.316]                     if (inherits(cond, "message")) {
[18:04:19.316]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:19.316]                       if (muffled) 
[18:04:19.316]                         invokeRestart("muffleMessage")
[18:04:19.316]                     }
[18:04:19.316]                     else if (inherits(cond, "warning")) {
[18:04:19.316]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:19.316]                       if (muffled) 
[18:04:19.316]                         invokeRestart("muffleWarning")
[18:04:19.316]                     }
[18:04:19.316]                     else if (inherits(cond, "condition")) {
[18:04:19.316]                       if (!is.null(pattern)) {
[18:04:19.316]                         computeRestarts <- base::computeRestarts
[18:04:19.316]                         grepl <- base::grepl
[18:04:19.316]                         restarts <- computeRestarts(cond)
[18:04:19.316]                         for (restart in restarts) {
[18:04:19.316]                           name <- restart$name
[18:04:19.316]                           if (is.null(name)) 
[18:04:19.316]                             next
[18:04:19.316]                           if (!grepl(pattern, name)) 
[18:04:19.316]                             next
[18:04:19.316]                           invokeRestart(restart)
[18:04:19.316]                           muffled <- TRUE
[18:04:19.316]                           break
[18:04:19.316]                         }
[18:04:19.316]                       }
[18:04:19.316]                     }
[18:04:19.316]                     invisible(muffled)
[18:04:19.316]                   }
[18:04:19.316]                   muffleCondition(cond)
[18:04:19.316]                 })
[18:04:19.316]             }))
[18:04:19.316]             future::FutureResult(value = ...future.value$value, 
[18:04:19.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.316]                   ...future.rng), globalenv = if (FALSE) 
[18:04:19.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:19.316]                     ...future.globalenv.names))
[18:04:19.316]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:19.316]         }, condition = base::local({
[18:04:19.316]             c <- base::c
[18:04:19.316]             inherits <- base::inherits
[18:04:19.316]             invokeRestart <- base::invokeRestart
[18:04:19.316]             length <- base::length
[18:04:19.316]             list <- base::list
[18:04:19.316]             seq.int <- base::seq.int
[18:04:19.316]             signalCondition <- base::signalCondition
[18:04:19.316]             sys.calls <- base::sys.calls
[18:04:19.316]             `[[` <- base::`[[`
[18:04:19.316]             `+` <- base::`+`
[18:04:19.316]             `<<-` <- base::`<<-`
[18:04:19.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:19.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:19.316]                   3L)]
[18:04:19.316]             }
[18:04:19.316]             function(cond) {
[18:04:19.316]                 is_error <- inherits(cond, "error")
[18:04:19.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:19.316]                   NULL)
[18:04:19.316]                 if (is_error) {
[18:04:19.316]                   sessionInformation <- function() {
[18:04:19.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:19.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:19.316]                       search = base::search(), system = base::Sys.info())
[18:04:19.316]                   }
[18:04:19.316]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:19.316]                     cond$call), session = sessionInformation(), 
[18:04:19.316]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:19.316]                   signalCondition(cond)
[18:04:19.316]                 }
[18:04:19.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:19.316]                 "immediateCondition"))) {
[18:04:19.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:19.316]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:19.316]                   if (TRUE && !signal) {
[18:04:19.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.316]                     {
[18:04:19.316]                       inherits <- base::inherits
[18:04:19.316]                       invokeRestart <- base::invokeRestart
[18:04:19.316]                       is.null <- base::is.null
[18:04:19.316]                       muffled <- FALSE
[18:04:19.316]                       if (inherits(cond, "message")) {
[18:04:19.316]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.316]                         if (muffled) 
[18:04:19.316]                           invokeRestart("muffleMessage")
[18:04:19.316]                       }
[18:04:19.316]                       else if (inherits(cond, "warning")) {
[18:04:19.316]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.316]                         if (muffled) 
[18:04:19.316]                           invokeRestart("muffleWarning")
[18:04:19.316]                       }
[18:04:19.316]                       else if (inherits(cond, "condition")) {
[18:04:19.316]                         if (!is.null(pattern)) {
[18:04:19.316]                           computeRestarts <- base::computeRestarts
[18:04:19.316]                           grepl <- base::grepl
[18:04:19.316]                           restarts <- computeRestarts(cond)
[18:04:19.316]                           for (restart in restarts) {
[18:04:19.316]                             name <- restart$name
[18:04:19.316]                             if (is.null(name)) 
[18:04:19.316]                               next
[18:04:19.316]                             if (!grepl(pattern, name)) 
[18:04:19.316]                               next
[18:04:19.316]                             invokeRestart(restart)
[18:04:19.316]                             muffled <- TRUE
[18:04:19.316]                             break
[18:04:19.316]                           }
[18:04:19.316]                         }
[18:04:19.316]                       }
[18:04:19.316]                       invisible(muffled)
[18:04:19.316]                     }
[18:04:19.316]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.316]                   }
[18:04:19.316]                 }
[18:04:19.316]                 else {
[18:04:19.316]                   if (TRUE) {
[18:04:19.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.316]                     {
[18:04:19.316]                       inherits <- base::inherits
[18:04:19.316]                       invokeRestart <- base::invokeRestart
[18:04:19.316]                       is.null <- base::is.null
[18:04:19.316]                       muffled <- FALSE
[18:04:19.316]                       if (inherits(cond, "message")) {
[18:04:19.316]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.316]                         if (muffled) 
[18:04:19.316]                           invokeRestart("muffleMessage")
[18:04:19.316]                       }
[18:04:19.316]                       else if (inherits(cond, "warning")) {
[18:04:19.316]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.316]                         if (muffled) 
[18:04:19.316]                           invokeRestart("muffleWarning")
[18:04:19.316]                       }
[18:04:19.316]                       else if (inherits(cond, "condition")) {
[18:04:19.316]                         if (!is.null(pattern)) {
[18:04:19.316]                           computeRestarts <- base::computeRestarts
[18:04:19.316]                           grepl <- base::grepl
[18:04:19.316]                           restarts <- computeRestarts(cond)
[18:04:19.316]                           for (restart in restarts) {
[18:04:19.316]                             name <- restart$name
[18:04:19.316]                             if (is.null(name)) 
[18:04:19.316]                               next
[18:04:19.316]                             if (!grepl(pattern, name)) 
[18:04:19.316]                               next
[18:04:19.316]                             invokeRestart(restart)
[18:04:19.316]                             muffled <- TRUE
[18:04:19.316]                             break
[18:04:19.316]                           }
[18:04:19.316]                         }
[18:04:19.316]                       }
[18:04:19.316]                       invisible(muffled)
[18:04:19.316]                     }
[18:04:19.316]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.316]                   }
[18:04:19.316]                 }
[18:04:19.316]             }
[18:04:19.316]         }))
[18:04:19.316]     }, error = function(ex) {
[18:04:19.316]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:19.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.316]                 ...future.rng), started = ...future.startTime, 
[18:04:19.316]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:19.316]             version = "1.8"), class = "FutureResult")
[18:04:19.316]     }, finally = {
[18:04:19.316]         if (!identical(...future.workdir, getwd())) 
[18:04:19.316]             setwd(...future.workdir)
[18:04:19.316]         {
[18:04:19.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:19.316]                 ...future.oldOptions$nwarnings <- NULL
[18:04:19.316]             }
[18:04:19.316]             base::options(...future.oldOptions)
[18:04:19.316]             if (.Platform$OS.type == "windows") {
[18:04:19.316]                 old_names <- names(...future.oldEnvVars)
[18:04:19.316]                 envs <- base::Sys.getenv()
[18:04:19.316]                 names <- names(envs)
[18:04:19.316]                 common <- intersect(names, old_names)
[18:04:19.316]                 added <- setdiff(names, old_names)
[18:04:19.316]                 removed <- setdiff(old_names, names)
[18:04:19.316]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:19.316]                   envs[common]]
[18:04:19.316]                 NAMES <- toupper(changed)
[18:04:19.316]                 args <- list()
[18:04:19.316]                 for (kk in seq_along(NAMES)) {
[18:04:19.316]                   name <- changed[[kk]]
[18:04:19.316]                   NAME <- NAMES[[kk]]
[18:04:19.316]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.316]                     next
[18:04:19.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.316]                 }
[18:04:19.316]                 NAMES <- toupper(added)
[18:04:19.316]                 for (kk in seq_along(NAMES)) {
[18:04:19.316]                   name <- added[[kk]]
[18:04:19.316]                   NAME <- NAMES[[kk]]
[18:04:19.316]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.316]                     next
[18:04:19.316]                   args[[name]] <- ""
[18:04:19.316]                 }
[18:04:19.316]                 NAMES <- toupper(removed)
[18:04:19.316]                 for (kk in seq_along(NAMES)) {
[18:04:19.316]                   name <- removed[[kk]]
[18:04:19.316]                   NAME <- NAMES[[kk]]
[18:04:19.316]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.316]                     next
[18:04:19.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.316]                 }
[18:04:19.316]                 if (length(args) > 0) 
[18:04:19.316]                   base::do.call(base::Sys.setenv, args = args)
[18:04:19.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:19.316]             }
[18:04:19.316]             else {
[18:04:19.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:19.316]             }
[18:04:19.316]             {
[18:04:19.316]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:19.316]                   0L) {
[18:04:19.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:19.316]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:19.316]                   base::options(opts)
[18:04:19.316]                 }
[18:04:19.316]                 {
[18:04:19.316]                   {
[18:04:19.316]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:19.316]                     NULL
[18:04:19.316]                   }
[18:04:19.316]                   options(future.plan = NULL)
[18:04:19.316]                   if (is.na(NA_character_)) 
[18:04:19.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:19.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:19.316]                     .init = FALSE)
[18:04:19.316]                 }
[18:04:19.316]             }
[18:04:19.316]         }
[18:04:19.316]     })
[18:04:19.316]     if (TRUE) {
[18:04:19.316]         base::sink(type = "output", split = FALSE)
[18:04:19.316]         if (TRUE) {
[18:04:19.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:19.316]         }
[18:04:19.316]         else {
[18:04:19.316]             ...future.result["stdout"] <- base::list(NULL)
[18:04:19.316]         }
[18:04:19.316]         base::close(...future.stdout)
[18:04:19.316]         ...future.stdout <- NULL
[18:04:19.316]     }
[18:04:19.316]     ...future.result$conditions <- ...future.conditions
[18:04:19.316]     ...future.result$finished <- base::Sys.time()
[18:04:19.316]     ...future.result
[18:04:19.316] }
[18:04:19.323] requestCore(): workers = 2
[18:04:19.330] MulticoreFuture started
[18:04:19.331] - Launch lazy future ... done
[18:04:19.331] run() for ‘MulticoreFuture’ ... done
[18:04:19.333] plan(): Setting new future strategy stack:
[18:04:19.335] getGlobalsAndPackages() ...
[18:04:19.335] Searching for globals...
[18:04:19.333] List of future strategies:
[18:04:19.333] 1. sequential:
[18:04:19.333]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:19.333]    - tweaked: FALSE
[18:04:19.333]    - call: NULL
[18:04:19.341] plan(): nbrOfWorkers() = 1
[18:04:19.345] - globals found: [1] ‘{’
[18:04:19.345] Searching for globals ... DONE
[18:04:19.346] Resolving globals: FALSE
[18:04:19.349] 
[18:04:19.351] 
[18:04:19.352] getGlobalsAndPackages() ... DONE
[18:04:19.353] plan(): Setting new future strategy stack:
[18:04:19.354] run() for ‘Future’ ...
[18:04:19.353] List of future strategies:
[18:04:19.353] 1. multicore:
[18:04:19.353]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:19.353]    - tweaked: FALSE
[18:04:19.353]    - call: plan(strategy)
[18:04:19.355] - state: ‘created’
[18:04:19.357] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:19.370] plan(): nbrOfWorkers() = 2
[18:04:19.374] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:19.374] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:19.378]   - Field: ‘label’
[18:04:19.378]   - Field: ‘local’
[18:04:19.379]   - Field: ‘owner’
[18:04:19.379]   - Field: ‘envir’
[18:04:19.379]   - Field: ‘workers’
[18:04:19.380]   - Field: ‘packages’
[18:04:19.380]   - Field: ‘gc’
[18:04:19.381]   - Field: ‘job’
[18:04:19.381]   - Field: ‘conditions’
[18:04:19.381]   - Field: ‘expr’
[18:04:19.382]   - Field: ‘uuid’
[18:04:19.382]   - Field: ‘seed’
[18:04:19.382]   - Field: ‘version’
[18:04:19.383]   - Field: ‘result’
[18:04:19.383]   - Field: ‘asynchronous’
[18:04:19.383]   - Field: ‘calls’
[18:04:19.384]   - Field: ‘globals’
[18:04:19.384]   - Field: ‘stdout’
[18:04:19.385]   - Field: ‘earlySignal’
[18:04:19.385]   - Field: ‘lazy’
[18:04:19.385]   - Field: ‘state’
[18:04:19.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:19.386] - Launch lazy future ...
[18:04:19.387] Packages needed by the future expression (n = 0): <none>
[18:04:19.388] Packages needed by future strategies (n = 0): <none>
[18:04:19.389] {
[18:04:19.389]     {
[18:04:19.389]         {
[18:04:19.389]             ...future.startTime <- base::Sys.time()
[18:04:19.389]             {
[18:04:19.389]                 {
[18:04:19.389]                   {
[18:04:19.389]                     {
[18:04:19.389]                       base::local({
[18:04:19.389]                         has_future <- base::requireNamespace("future", 
[18:04:19.389]                           quietly = TRUE)
[18:04:19.389]                         if (has_future) {
[18:04:19.389]                           ns <- base::getNamespace("future")
[18:04:19.389]                           version <- ns[[".package"]][["version"]]
[18:04:19.389]                           if (is.null(version)) 
[18:04:19.389]                             version <- utils::packageVersion("future")
[18:04:19.389]                         }
[18:04:19.389]                         else {
[18:04:19.389]                           version <- NULL
[18:04:19.389]                         }
[18:04:19.389]                         if (!has_future || version < "1.8.0") {
[18:04:19.389]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:19.389]                             "", base::R.version$version.string), 
[18:04:19.389]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:19.389]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:19.389]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:19.389]                               "release", "version")], collapse = " "), 
[18:04:19.389]                             hostname = base::Sys.info()[["nodename"]])
[18:04:19.389]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:19.389]                             info)
[18:04:19.389]                           info <- base::paste(info, collapse = "; ")
[18:04:19.389]                           if (!has_future) {
[18:04:19.389]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:19.389]                               info)
[18:04:19.389]                           }
[18:04:19.389]                           else {
[18:04:19.389]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:19.389]                               info, version)
[18:04:19.389]                           }
[18:04:19.389]                           base::stop(msg)
[18:04:19.389]                         }
[18:04:19.389]                       })
[18:04:19.389]                     }
[18:04:19.389]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:19.389]                     base::options(mc.cores = 1L)
[18:04:19.389]                   }
[18:04:19.389]                   ...future.strategy.old <- future::plan("list")
[18:04:19.389]                   options(future.plan = NULL)
[18:04:19.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:19.389]                 }
[18:04:19.389]                 ...future.workdir <- getwd()
[18:04:19.389]             }
[18:04:19.389]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:19.389]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:19.389]         }
[18:04:19.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:19.389]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:19.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:19.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:19.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:19.389]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:19.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:19.389]             base::names(...future.oldOptions))
[18:04:19.389]     }
[18:04:19.389]     if (FALSE) {
[18:04:19.389]     }
[18:04:19.389]     else {
[18:04:19.389]         if (TRUE) {
[18:04:19.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:19.389]                 open = "w")
[18:04:19.389]         }
[18:04:19.389]         else {
[18:04:19.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:19.389]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:19.389]         }
[18:04:19.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:19.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:19.389]             base::sink(type = "output", split = FALSE)
[18:04:19.389]             base::close(...future.stdout)
[18:04:19.389]         }, add = TRUE)
[18:04:19.389]     }
[18:04:19.389]     ...future.frame <- base::sys.nframe()
[18:04:19.389]     ...future.conditions <- base::list()
[18:04:19.389]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:19.389]     if (FALSE) {
[18:04:19.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:19.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:19.389]     }
[18:04:19.389]     ...future.result <- base::tryCatch({
[18:04:19.389]         base::withCallingHandlers({
[18:04:19.389]             ...future.value <- base::withVisible(base::local({
[18:04:19.389]                 withCallingHandlers({
[18:04:19.389]                   {
[18:04:19.389]                     4
[18:04:19.389]                   }
[18:04:19.389]                 }, immediateCondition = function(cond) {
[18:04:19.389]                   save_rds <- function (object, pathname, ...) 
[18:04:19.389]                   {
[18:04:19.389]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:19.389]                     if (file_test("-f", pathname_tmp)) {
[18:04:19.389]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.389]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:19.389]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.389]                         fi_tmp[["mtime"]])
[18:04:19.389]                     }
[18:04:19.389]                     tryCatch({
[18:04:19.389]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:19.389]                     }, error = function(ex) {
[18:04:19.389]                       msg <- conditionMessage(ex)
[18:04:19.389]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.389]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:19.389]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.389]                         fi_tmp[["mtime"]], msg)
[18:04:19.389]                       ex$message <- msg
[18:04:19.389]                       stop(ex)
[18:04:19.389]                     })
[18:04:19.389]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:19.389]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:19.389]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:19.389]                       fi_tmp <- file.info(pathname_tmp)
[18:04:19.389]                       fi <- file.info(pathname)
[18:04:19.389]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:19.389]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:19.389]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:19.389]                         fi[["size"]], fi[["mtime"]])
[18:04:19.389]                       stop(msg)
[18:04:19.389]                     }
[18:04:19.389]                     invisible(pathname)
[18:04:19.389]                   }
[18:04:19.389]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:19.389]                     rootPath = tempdir()) 
[18:04:19.389]                   {
[18:04:19.389]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:19.389]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:19.389]                       tmpdir = path, fileext = ".rds")
[18:04:19.389]                     save_rds(obj, file)
[18:04:19.389]                   }
[18:04:19.389]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:19.389]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.389]                   {
[18:04:19.389]                     inherits <- base::inherits
[18:04:19.389]                     invokeRestart <- base::invokeRestart
[18:04:19.389]                     is.null <- base::is.null
[18:04:19.389]                     muffled <- FALSE
[18:04:19.389]                     if (inherits(cond, "message")) {
[18:04:19.389]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:19.389]                       if (muffled) 
[18:04:19.389]                         invokeRestart("muffleMessage")
[18:04:19.389]                     }
[18:04:19.389]                     else if (inherits(cond, "warning")) {
[18:04:19.389]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:19.389]                       if (muffled) 
[18:04:19.389]                         invokeRestart("muffleWarning")
[18:04:19.389]                     }
[18:04:19.389]                     else if (inherits(cond, "condition")) {
[18:04:19.389]                       if (!is.null(pattern)) {
[18:04:19.389]                         computeRestarts <- base::computeRestarts
[18:04:19.389]                         grepl <- base::grepl
[18:04:19.389]                         restarts <- computeRestarts(cond)
[18:04:19.389]                         for (restart in restarts) {
[18:04:19.389]                           name <- restart$name
[18:04:19.389]                           if (is.null(name)) 
[18:04:19.389]                             next
[18:04:19.389]                           if (!grepl(pattern, name)) 
[18:04:19.389]                             next
[18:04:19.389]                           invokeRestart(restart)
[18:04:19.389]                           muffled <- TRUE
[18:04:19.389]                           break
[18:04:19.389]                         }
[18:04:19.389]                       }
[18:04:19.389]                     }
[18:04:19.389]                     invisible(muffled)
[18:04:19.389]                   }
[18:04:19.389]                   muffleCondition(cond)
[18:04:19.389]                 })
[18:04:19.389]             }))
[18:04:19.389]             future::FutureResult(value = ...future.value$value, 
[18:04:19.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.389]                   ...future.rng), globalenv = if (FALSE) 
[18:04:19.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:19.389]                     ...future.globalenv.names))
[18:04:19.389]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:19.389]         }, condition = base::local({
[18:04:19.389]             c <- base::c
[18:04:19.389]             inherits <- base::inherits
[18:04:19.389]             invokeRestart <- base::invokeRestart
[18:04:19.389]             length <- base::length
[18:04:19.389]             list <- base::list
[18:04:19.389]             seq.int <- base::seq.int
[18:04:19.389]             signalCondition <- base::signalCondition
[18:04:19.389]             sys.calls <- base::sys.calls
[18:04:19.389]             `[[` <- base::`[[`
[18:04:19.389]             `+` <- base::`+`
[18:04:19.389]             `<<-` <- base::`<<-`
[18:04:19.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:19.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:19.389]                   3L)]
[18:04:19.389]             }
[18:04:19.389]             function(cond) {
[18:04:19.389]                 is_error <- inherits(cond, "error")
[18:04:19.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:19.389]                   NULL)
[18:04:19.389]                 if (is_error) {
[18:04:19.389]                   sessionInformation <- function() {
[18:04:19.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:19.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:19.389]                       search = base::search(), system = base::Sys.info())
[18:04:19.389]                   }
[18:04:19.389]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:19.389]                     cond$call), session = sessionInformation(), 
[18:04:19.389]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:19.389]                   signalCondition(cond)
[18:04:19.389]                 }
[18:04:19.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:19.389]                 "immediateCondition"))) {
[18:04:19.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:19.389]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:19.389]                   if (TRUE && !signal) {
[18:04:19.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.389]                     {
[18:04:19.389]                       inherits <- base::inherits
[18:04:19.389]                       invokeRestart <- base::invokeRestart
[18:04:19.389]                       is.null <- base::is.null
[18:04:19.389]                       muffled <- FALSE
[18:04:19.389]                       if (inherits(cond, "message")) {
[18:04:19.389]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.389]                         if (muffled) 
[18:04:19.389]                           invokeRestart("muffleMessage")
[18:04:19.389]                       }
[18:04:19.389]                       else if (inherits(cond, "warning")) {
[18:04:19.389]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.389]                         if (muffled) 
[18:04:19.389]                           invokeRestart("muffleWarning")
[18:04:19.389]                       }
[18:04:19.389]                       else if (inherits(cond, "condition")) {
[18:04:19.389]                         if (!is.null(pattern)) {
[18:04:19.389]                           computeRestarts <- base::computeRestarts
[18:04:19.389]                           grepl <- base::grepl
[18:04:19.389]                           restarts <- computeRestarts(cond)
[18:04:19.389]                           for (restart in restarts) {
[18:04:19.389]                             name <- restart$name
[18:04:19.389]                             if (is.null(name)) 
[18:04:19.389]                               next
[18:04:19.389]                             if (!grepl(pattern, name)) 
[18:04:19.389]                               next
[18:04:19.389]                             invokeRestart(restart)
[18:04:19.389]                             muffled <- TRUE
[18:04:19.389]                             break
[18:04:19.389]                           }
[18:04:19.389]                         }
[18:04:19.389]                       }
[18:04:19.389]                       invisible(muffled)
[18:04:19.389]                     }
[18:04:19.389]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.389]                   }
[18:04:19.389]                 }
[18:04:19.389]                 else {
[18:04:19.389]                   if (TRUE) {
[18:04:19.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.389]                     {
[18:04:19.389]                       inherits <- base::inherits
[18:04:19.389]                       invokeRestart <- base::invokeRestart
[18:04:19.389]                       is.null <- base::is.null
[18:04:19.389]                       muffled <- FALSE
[18:04:19.389]                       if (inherits(cond, "message")) {
[18:04:19.389]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.389]                         if (muffled) 
[18:04:19.389]                           invokeRestart("muffleMessage")
[18:04:19.389]                       }
[18:04:19.389]                       else if (inherits(cond, "warning")) {
[18:04:19.389]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.389]                         if (muffled) 
[18:04:19.389]                           invokeRestart("muffleWarning")
[18:04:19.389]                       }
[18:04:19.389]                       else if (inherits(cond, "condition")) {
[18:04:19.389]                         if (!is.null(pattern)) {
[18:04:19.389]                           computeRestarts <- base::computeRestarts
[18:04:19.389]                           grepl <- base::grepl
[18:04:19.389]                           restarts <- computeRestarts(cond)
[18:04:19.389]                           for (restart in restarts) {
[18:04:19.389]                             name <- restart$name
[18:04:19.389]                             if (is.null(name)) 
[18:04:19.389]                               next
[18:04:19.389]                             if (!grepl(pattern, name)) 
[18:04:19.389]                               next
[18:04:19.389]                             invokeRestart(restart)
[18:04:19.389]                             muffled <- TRUE
[18:04:19.389]                             break
[18:04:19.389]                           }
[18:04:19.389]                         }
[18:04:19.389]                       }
[18:04:19.389]                       invisible(muffled)
[18:04:19.389]                     }
[18:04:19.389]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.389]                   }
[18:04:19.389]                 }
[18:04:19.389]             }
[18:04:19.389]         }))
[18:04:19.389]     }, error = function(ex) {
[18:04:19.389]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:19.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.389]                 ...future.rng), started = ...future.startTime, 
[18:04:19.389]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:19.389]             version = "1.8"), class = "FutureResult")
[18:04:19.389]     }, finally = {
[18:04:19.389]         if (!identical(...future.workdir, getwd())) 
[18:04:19.389]             setwd(...future.workdir)
[18:04:19.389]         {
[18:04:19.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:19.389]                 ...future.oldOptions$nwarnings <- NULL
[18:04:19.389]             }
[18:04:19.389]             base::options(...future.oldOptions)
[18:04:19.389]             if (.Platform$OS.type == "windows") {
[18:04:19.389]                 old_names <- names(...future.oldEnvVars)
[18:04:19.389]                 envs <- base::Sys.getenv()
[18:04:19.389]                 names <- names(envs)
[18:04:19.389]                 common <- intersect(names, old_names)
[18:04:19.389]                 added <- setdiff(names, old_names)
[18:04:19.389]                 removed <- setdiff(old_names, names)
[18:04:19.389]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:19.389]                   envs[common]]
[18:04:19.389]                 NAMES <- toupper(changed)
[18:04:19.389]                 args <- list()
[18:04:19.389]                 for (kk in seq_along(NAMES)) {
[18:04:19.389]                   name <- changed[[kk]]
[18:04:19.389]                   NAME <- NAMES[[kk]]
[18:04:19.389]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.389]                     next
[18:04:19.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.389]                 }
[18:04:19.389]                 NAMES <- toupper(added)
[18:04:19.389]                 for (kk in seq_along(NAMES)) {
[18:04:19.389]                   name <- added[[kk]]
[18:04:19.389]                   NAME <- NAMES[[kk]]
[18:04:19.389]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.389]                     next
[18:04:19.389]                   args[[name]] <- ""
[18:04:19.389]                 }
[18:04:19.389]                 NAMES <- toupper(removed)
[18:04:19.389]                 for (kk in seq_along(NAMES)) {
[18:04:19.389]                   name <- removed[[kk]]
[18:04:19.389]                   NAME <- NAMES[[kk]]
[18:04:19.389]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.389]                     next
[18:04:19.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.389]                 }
[18:04:19.389]                 if (length(args) > 0) 
[18:04:19.389]                   base::do.call(base::Sys.setenv, args = args)
[18:04:19.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:19.389]             }
[18:04:19.389]             else {
[18:04:19.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:19.389]             }
[18:04:19.389]             {
[18:04:19.389]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:19.389]                   0L) {
[18:04:19.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:19.389]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:19.389]                   base::options(opts)
[18:04:19.389]                 }
[18:04:19.389]                 {
[18:04:19.389]                   {
[18:04:19.389]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:19.389]                     NULL
[18:04:19.389]                   }
[18:04:19.389]                   options(future.plan = NULL)
[18:04:19.389]                   if (is.na(NA_character_)) 
[18:04:19.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:19.389]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:19.389]                     .init = FALSE)
[18:04:19.389]                 }
[18:04:19.389]             }
[18:04:19.389]         }
[18:04:19.389]     })
[18:04:19.389]     if (TRUE) {
[18:04:19.389]         base::sink(type = "output", split = FALSE)
[18:04:19.389]         if (TRUE) {
[18:04:19.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:19.389]         }
[18:04:19.389]         else {
[18:04:19.389]             ...future.result["stdout"] <- base::list(NULL)
[18:04:19.389]         }
[18:04:19.389]         base::close(...future.stdout)
[18:04:19.389]         ...future.stdout <- NULL
[18:04:19.389]     }
[18:04:19.389]     ...future.result$conditions <- ...future.conditions
[18:04:19.389]     ...future.result$finished <- base::Sys.time()
[18:04:19.389]     ...future.result
[18:04:19.389] }
[18:04:19.397] requestCore(): workers = 2
[18:04:19.398] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:19.410] result() for MulticoreFuture ...
[18:04:19.412] result() for MulticoreFuture ...
[18:04:19.412] result() for MulticoreFuture ... done
[18:04:19.413] result() for MulticoreFuture ... done
[18:04:19.413] result() for MulticoreFuture ...
[18:04:19.414] result() for MulticoreFuture ... done
[18:04:19.421] MulticoreFuture started
[18:04:19.422] - Launch lazy future ... done
[18:04:19.422] run() for ‘MulticoreFuture’ ... done
[18:04:19.424] plan(): Setting new future strategy stack:
<environment: 0x5e3c2bad70d0> 
<environment: 0x5e3c297046f8> [18:04:19.425] List of future strategies:
[18:04:19.425] 1. sequential:
[18:04:19.425]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:19.425]    - tweaked: FALSE
[18:04:19.425]    - call: NULL
[18:04:19.431] plan(): nbrOfWorkers() = 1

[18:04:19.439] plan(): Setting new future strategy stack:
[18:04:19.439] List of future strategies:
[18:04:19.439] 1. multicore:
[18:04:19.439]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:19.439]    - tweaked: FALSE
[18:04:19.439]    - call: plan(strategy)
 Named logi [1:4] TRUE TRUE TRUE FALSE
[18:04:19.451] plan(): nbrOfWorkers() = 2
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:19.456] resolve() on environment ...
[18:04:19.456]  recursive: 0
[18:04:19.458]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:19.459] signalConditionsASAP(numeric, pos=1) ...
[18:04:19.459] - nx: 4
[18:04:19.459] - relay: TRUE
[18:04:19.460] - stdout: TRUE
[18:04:19.460] - signal: TRUE
[18:04:19.460] - resignal: FALSE
[18:04:19.461] - force: TRUE
[18:04:19.461] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.461] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.462]  - until=2
[18:04:19.462]  - relaying element #2
[18:04:19.462] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:19.462] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.463] signalConditionsASAP(NULL, pos=1) ... done
[18:04:19.463]  length: 3 (resolved future 1)
[18:04:19.463] Future #2
[18:04:19.464] result() for MulticoreFuture ...
[18:04:19.464] result() for MulticoreFuture ... done
[18:04:19.465] result() for MulticoreFuture ...
[18:04:19.465] result() for MulticoreFuture ... done
[18:04:19.465] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:19.466] - nx: 4
[18:04:19.466] - relay: TRUE
[18:04:19.466] - stdout: TRUE
[18:04:19.467] - signal: TRUE
[18:04:19.467] - resignal: FALSE
[18:04:19.467] - force: TRUE
[18:04:19.468] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:19.468] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:19.468]  - until=2
[18:04:19.469]  - relaying element #2
[18:04:19.469] result() for MulticoreFuture ...
[18:04:19.469] result() for MulticoreFuture ... done
[18:04:19.470] result() for MulticoreFuture ...
[18:04:19.470] result() for MulticoreFuture ... done
[18:04:19.470] result() for MulticoreFuture ...
[18:04:19.471] result() for MulticoreFuture ... done
[18:04:19.471] result() for MulticoreFuture ...
[18:04:19.471] result() for MulticoreFuture ... done
[18:04:19.471] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:19.472] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:19.472] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:19.472]  length: 2 (resolved future 2)
[18:04:19.473] Future #3
[18:04:19.474] result() for MulticoreFuture ...
[18:04:19.478] result() for MulticoreFuture ...
[18:04:19.478] result() for MulticoreFuture ... done
[18:04:19.478] result() for MulticoreFuture ... done
[18:04:19.479] result() for MulticoreFuture ...
[18:04:19.479] result() for MulticoreFuture ... done
[18:04:19.479] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:19.480] - nx: 4
[18:04:19.482] - relay: TRUE
[18:04:19.482] - stdout: TRUE
[18:04:19.483] - signal: TRUE
[18:04:19.483] - resignal: FALSE
[18:04:19.483] - force: TRUE
[18:04:19.484] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:19.484] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:19.485]  - until=3
[18:04:19.485]  - relaying element #3
[18:04:19.485] result() for MulticoreFuture ...
[18:04:19.486] result() for MulticoreFuture ... done
[18:04:19.486] result() for MulticoreFuture ...
[18:04:19.486] result() for MulticoreFuture ... done
[18:04:19.487] result() for MulticoreFuture ...
[18:04:19.487] result() for MulticoreFuture ... done
[18:04:19.487] result() for MulticoreFuture ...
[18:04:19.488] result() for MulticoreFuture ... done
[18:04:19.488] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:19.488] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:19.489] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:19.489]  length: 1 (resolved future 3)
[18:04:19.490] Future #4
[18:04:19.490] result() for MulticoreFuture ...
[18:04:19.493] result() for MulticoreFuture ...
[18:04:19.496] result() for MulticoreFuture ... done
[18:04:19.496] result() for MulticoreFuture ... done
[18:04:19.497] result() for MulticoreFuture ...
[18:04:19.497] result() for MulticoreFuture ... done
[18:04:19.497] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:19.497] - nx: 4
[18:04:19.498] - relay: TRUE
[18:04:19.498] - stdout: TRUE
[18:04:19.499] - signal: TRUE
[18:04:19.499] - resignal: FALSE
[18:04:19.499] - force: TRUE
[18:04:19.499] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:19.499] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:19.500]  - until=4
[18:04:19.500]  - relaying element #4
[18:04:19.500] result() for MulticoreFuture ...
[18:04:19.500] result() for MulticoreFuture ... done
[18:04:19.501] result() for MulticoreFuture ...
[18:04:19.501] result() for MulticoreFuture ... done
[18:04:19.501] result() for MulticoreFuture ...
[18:04:19.501] result() for MulticoreFuture ... done
[18:04:19.502] result() for MulticoreFuture ...
[18:04:19.502] result() for MulticoreFuture ... done
[18:04:19.502] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:19.502] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:19.503] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:19.503]  length: 0 (resolved future 4)
[18:04:19.503] Relaying remaining futures
[18:04:19.503] signalConditionsASAP(NULL, pos=0) ...
[18:04:19.504] - nx: 4
[18:04:19.504] - relay: TRUE
[18:04:19.504] - stdout: TRUE
[18:04:19.504] - signal: TRUE
[18:04:19.504] - resignal: FALSE
[18:04:19.505] - force: TRUE
[18:04:19.505] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:19.505] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:19.505] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:19.506] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:19.506] signalConditionsASAP(NULL, pos=0) ... done
[18:04:19.506] resolve() on environment ... DONE
[18:04:19.506] result() for MulticoreFuture ...
[18:04:19.506] result() for MulticoreFuture ... done
[18:04:19.507] result() for MulticoreFuture ...
[18:04:19.507] result() for MulticoreFuture ... done
[18:04:19.507] result() for MulticoreFuture ...
[18:04:19.508] result() for MulticoreFuture ... done
[18:04:19.508] result() for MulticoreFuture ...
[18:04:19.508] result() for MulticoreFuture ... done
[18:04:19.508] result() for MulticoreFuture ...
[18:04:19.509] result() for MulticoreFuture ... done
[18:04:19.509] result() for MulticoreFuture ...
[18:04:19.509] result() for MulticoreFuture ... done
<environment: 0x5e3c2be51d18> 
Type of future: multisession
[18:04:19.510] plan(): Setting new future strategy stack:
[18:04:19.510] List of future strategies:
[18:04:19.510] 1. multisession:
[18:04:19.510]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:19.510]    - tweaked: FALSE
[18:04:19.510]    - call: plan(strategy)
[18:04:19.511] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:04:19.512] multisession:
[18:04:19.512] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:19.512] - tweaked: FALSE
[18:04:19.512] - call: plan(strategy)
[18:04:19.519] getGlobalsAndPackages() ...
[18:04:19.519] Not searching for globals
[18:04:19.519] - globals: [0] <none>
[18:04:19.520] getGlobalsAndPackages() ... DONE
[18:04:19.520] [local output] makeClusterPSOCK() ...
[18:04:19.527] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:04:19.528] [local output] Base port: 11968
[18:04:19.529] [local output] Getting setup options for 2 cluster nodes ...
[18:04:19.529] [local output]  - Node 1 of 2 ...
[18:04:19.530] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:19.532] [local output] Rscript port: 11968

[18:04:19.533] [local output]  - Node 2 of 2 ...
[18:04:19.534] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:19.535] [local output] Rscript port: 11968

[18:04:19.536] [local output] Getting setup options for 2 cluster nodes ... done
[18:04:19.536] [local output]  - Parallel setup requested for some PSOCK nodes
[18:04:19.537] [local output] Setting up PSOCK nodes in parallel
[18:04:19.537] List of 36
[18:04:19.537]  $ worker          : chr "localhost"
[18:04:19.537]   ..- attr(*, "localhost")= logi TRUE
[18:04:19.537]  $ master          : chr "localhost"
[18:04:19.537]  $ port            : int 11968
[18:04:19.537]  $ connectTimeout  : num 120
[18:04:19.537]  $ timeout         : num 2592000
[18:04:19.537]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:04:19.537]  $ homogeneous     : logi TRUE
[18:04:19.537]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:04:19.537]  $ rscript_envs    : NULL
[18:04:19.537]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:19.537]  $ rscript_startup : NULL
[18:04:19.537]  $ rscript_sh      : chr "sh"
[18:04:19.537]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:19.537]  $ methods         : logi TRUE
[18:04:19.537]  $ socketOptions   : chr "no-delay"
[18:04:19.537]  $ useXDR          : logi FALSE
[18:04:19.537]  $ outfile         : chr "/dev/null"
[18:04:19.537]  $ renice          : int NA
[18:04:19.537]  $ rshcmd          : NULL
[18:04:19.537]  $ user            : chr(0) 
[18:04:19.537]  $ revtunnel       : logi FALSE
[18:04:19.537]  $ rshlogfile      : NULL
[18:04:19.537]  $ rshopts         : chr(0) 
[18:04:19.537]  $ rank            : int 1
[18:04:19.537]  $ manual          : logi FALSE
[18:04:19.537]  $ dryrun          : logi FALSE
[18:04:19.537]  $ quiet           : logi FALSE
[18:04:19.537]  $ setup_strategy  : chr "parallel"
[18:04:19.537]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:19.537]  $ pidfile         : chr "/tmp/RtmpZUhzkP/worker.rank=1.parallelly.parent=322369.4eb414895944e.pid"
[18:04:19.537]  $ rshcmd_label    : NULL
[18:04:19.537]  $ rsh_call        : NULL
[18:04:19.537]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:19.537]  $ localMachine    : logi TRUE
[18:04:19.537]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:04:19.537]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:04:19.537]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:04:19.537]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:04:19.537]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:04:19.537]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:04:19.537]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:04:19.537]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:04:19.537]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:04:19.537]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:04:19.537]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:04:19.537]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:04:19.537]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:04:19.537]  $ arguments       :List of 28
[18:04:19.537]   ..$ worker          : chr "localhost"
[18:04:19.537]   ..$ master          : NULL
[18:04:19.537]   ..$ port            : int 11968
[18:04:19.537]   ..$ connectTimeout  : num 120
[18:04:19.537]   ..$ timeout         : num 2592000
[18:04:19.537]   ..$ rscript         : NULL
[18:04:19.537]   ..$ homogeneous     : NULL
[18:04:19.537]   ..$ rscript_args    : NULL
[18:04:19.537]   ..$ rscript_envs    : NULL
[18:04:19.537]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:19.537]   ..$ rscript_startup : NULL
[18:04:19.537]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:04:19.537]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:19.537]   ..$ methods         : logi TRUE
[18:04:19.537]   ..$ socketOptions   : chr "no-delay"
[18:04:19.537]   ..$ useXDR          : logi FALSE
[18:04:19.537]   ..$ outfile         : chr "/dev/null"
[18:04:19.537]   ..$ renice          : int NA
[18:04:19.537]   ..$ rshcmd          : NULL
[18:04:19.537]   ..$ user            : NULL
[18:04:19.537]   ..$ revtunnel       : logi NA
[18:04:19.537]   ..$ rshlogfile      : NULL
[18:04:19.537]   ..$ rshopts         : NULL
[18:04:19.537]   ..$ rank            : int 1
[18:04:19.537]   ..$ manual          : logi FALSE
[18:04:19.537]   ..$ dryrun          : logi FALSE
[18:04:19.537]   ..$ quiet           : logi FALSE
[18:04:19.537]   ..$ setup_strategy  : chr "parallel"
[18:04:19.537]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:04:19.585] [local output] System call to launch all workers:
[18:04:19.585] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZUhzkP/worker.rank=1.parallelly.parent=322369.4eb414895944e.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11968 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:04:19.585] [local output] Starting PSOCK main server
[18:04:19.587] [local output] Workers launched
[18:04:19.588] [local output] Waiting for workers to connect back
[18:04:19.588]  - [local output] 0 workers out of 2 ready
[18:04:19.963]  - [local output] 0 workers out of 2 ready
[18:04:19.964]  - [local output] 1 workers out of 2 ready
[18:04:19.968]  - [local output] 1 workers out of 2 ready
[18:04:19.969]  - [local output] 2 workers out of 2 ready
[18:04:19.969] [local output] Launching of workers completed
[18:04:19.969] [local output] Collecting session information from workers
[18:04:19.971] [local output]  - Worker #1 of 2
[18:04:19.976] [local output]  - Worker #2 of 2
[18:04:19.976] [local output] makeClusterPSOCK() ... done
[18:04:19.995] Packages needed by the future expression (n = 0): <none>
[18:04:19.995] Packages needed by future strategies (n = 0): <none>
[18:04:19.996] {
[18:04:19.996]     {
[18:04:19.996]         {
[18:04:19.996]             ...future.startTime <- base::Sys.time()
[18:04:19.996]             {
[18:04:19.996]                 {
[18:04:19.996]                   {
[18:04:19.996]                     {
[18:04:19.996]                       base::local({
[18:04:19.996]                         has_future <- base::requireNamespace("future", 
[18:04:19.996]                           quietly = TRUE)
[18:04:19.996]                         if (has_future) {
[18:04:19.996]                           ns <- base::getNamespace("future")
[18:04:19.996]                           version <- ns[[".package"]][["version"]]
[18:04:19.996]                           if (is.null(version)) 
[18:04:19.996]                             version <- utils::packageVersion("future")
[18:04:19.996]                         }
[18:04:19.996]                         else {
[18:04:19.996]                           version <- NULL
[18:04:19.996]                         }
[18:04:19.996]                         if (!has_future || version < "1.8.0") {
[18:04:19.996]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:19.996]                             "", base::R.version$version.string), 
[18:04:19.996]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:19.996]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:19.996]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:19.996]                               "release", "version")], collapse = " "), 
[18:04:19.996]                             hostname = base::Sys.info()[["nodename"]])
[18:04:19.996]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:19.996]                             info)
[18:04:19.996]                           info <- base::paste(info, collapse = "; ")
[18:04:19.996]                           if (!has_future) {
[18:04:19.996]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:19.996]                               info)
[18:04:19.996]                           }
[18:04:19.996]                           else {
[18:04:19.996]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:19.996]                               info, version)
[18:04:19.996]                           }
[18:04:19.996]                           base::stop(msg)
[18:04:19.996]                         }
[18:04:19.996]                       })
[18:04:19.996]                     }
[18:04:19.996]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:19.996]                     base::options(mc.cores = 1L)
[18:04:19.996]                   }
[18:04:19.996]                   ...future.strategy.old <- future::plan("list")
[18:04:19.996]                   options(future.plan = NULL)
[18:04:19.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:19.996]                 }
[18:04:19.996]                 ...future.workdir <- getwd()
[18:04:19.996]             }
[18:04:19.996]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:19.996]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:19.996]         }
[18:04:19.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:19.996]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:19.996]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:19.996]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:19.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:19.996]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:19.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:19.996]             base::names(...future.oldOptions))
[18:04:19.996]     }
[18:04:19.996]     if (FALSE) {
[18:04:19.996]     }
[18:04:19.996]     else {
[18:04:19.996]         if (TRUE) {
[18:04:19.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:19.996]                 open = "w")
[18:04:19.996]         }
[18:04:19.996]         else {
[18:04:19.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:19.996]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:19.996]         }
[18:04:19.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:19.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:19.996]             base::sink(type = "output", split = FALSE)
[18:04:19.996]             base::close(...future.stdout)
[18:04:19.996]         }, add = TRUE)
[18:04:19.996]     }
[18:04:19.996]     ...future.frame <- base::sys.nframe()
[18:04:19.996]     ...future.conditions <- base::list()
[18:04:19.996]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:19.996]     if (FALSE) {
[18:04:19.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:19.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:19.996]     }
[18:04:19.996]     ...future.result <- base::tryCatch({
[18:04:19.996]         base::withCallingHandlers({
[18:04:19.996]             ...future.value <- base::withVisible(base::local({
[18:04:19.996]                 ...future.makeSendCondition <- base::local({
[18:04:19.996]                   sendCondition <- NULL
[18:04:19.996]                   function(frame = 1L) {
[18:04:19.996]                     if (is.function(sendCondition)) 
[18:04:19.996]                       return(sendCondition)
[18:04:19.996]                     ns <- getNamespace("parallel")
[18:04:19.996]                     if (exists("sendData", mode = "function", 
[18:04:19.996]                       envir = ns)) {
[18:04:19.996]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:19.996]                         envir = ns)
[18:04:19.996]                       envir <- sys.frame(frame)
[18:04:19.996]                       master <- NULL
[18:04:19.996]                       while (!identical(envir, .GlobalEnv) && 
[18:04:19.996]                         !identical(envir, emptyenv())) {
[18:04:19.996]                         if (exists("master", mode = "list", envir = envir, 
[18:04:19.996]                           inherits = FALSE)) {
[18:04:19.996]                           master <- get("master", mode = "list", 
[18:04:19.996]                             envir = envir, inherits = FALSE)
[18:04:19.996]                           if (inherits(master, c("SOCKnode", 
[18:04:19.996]                             "SOCK0node"))) {
[18:04:19.996]                             sendCondition <<- function(cond) {
[18:04:19.996]                               data <- list(type = "VALUE", value = cond, 
[18:04:19.996]                                 success = TRUE)
[18:04:19.996]                               parallel_sendData(master, data)
[18:04:19.996]                             }
[18:04:19.996]                             return(sendCondition)
[18:04:19.996]                           }
[18:04:19.996]                         }
[18:04:19.996]                         frame <- frame + 1L
[18:04:19.996]                         envir <- sys.frame(frame)
[18:04:19.996]                       }
[18:04:19.996]                     }
[18:04:19.996]                     sendCondition <<- function(cond) NULL
[18:04:19.996]                   }
[18:04:19.996]                 })
[18:04:19.996]                 withCallingHandlers({
[18:04:19.996]                   NA
[18:04:19.996]                 }, immediateCondition = function(cond) {
[18:04:19.996]                   sendCondition <- ...future.makeSendCondition()
[18:04:19.996]                   sendCondition(cond)
[18:04:19.996]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.996]                   {
[18:04:19.996]                     inherits <- base::inherits
[18:04:19.996]                     invokeRestart <- base::invokeRestart
[18:04:19.996]                     is.null <- base::is.null
[18:04:19.996]                     muffled <- FALSE
[18:04:19.996]                     if (inherits(cond, "message")) {
[18:04:19.996]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:19.996]                       if (muffled) 
[18:04:19.996]                         invokeRestart("muffleMessage")
[18:04:19.996]                     }
[18:04:19.996]                     else if (inherits(cond, "warning")) {
[18:04:19.996]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:19.996]                       if (muffled) 
[18:04:19.996]                         invokeRestart("muffleWarning")
[18:04:19.996]                     }
[18:04:19.996]                     else if (inherits(cond, "condition")) {
[18:04:19.996]                       if (!is.null(pattern)) {
[18:04:19.996]                         computeRestarts <- base::computeRestarts
[18:04:19.996]                         grepl <- base::grepl
[18:04:19.996]                         restarts <- computeRestarts(cond)
[18:04:19.996]                         for (restart in restarts) {
[18:04:19.996]                           name <- restart$name
[18:04:19.996]                           if (is.null(name)) 
[18:04:19.996]                             next
[18:04:19.996]                           if (!grepl(pattern, name)) 
[18:04:19.996]                             next
[18:04:19.996]                           invokeRestart(restart)
[18:04:19.996]                           muffled <- TRUE
[18:04:19.996]                           break
[18:04:19.996]                         }
[18:04:19.996]                       }
[18:04:19.996]                     }
[18:04:19.996]                     invisible(muffled)
[18:04:19.996]                   }
[18:04:19.996]                   muffleCondition(cond)
[18:04:19.996]                 })
[18:04:19.996]             }))
[18:04:19.996]             future::FutureResult(value = ...future.value$value, 
[18:04:19.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.996]                   ...future.rng), globalenv = if (FALSE) 
[18:04:19.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:19.996]                     ...future.globalenv.names))
[18:04:19.996]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:19.996]         }, condition = base::local({
[18:04:19.996]             c <- base::c
[18:04:19.996]             inherits <- base::inherits
[18:04:19.996]             invokeRestart <- base::invokeRestart
[18:04:19.996]             length <- base::length
[18:04:19.996]             list <- base::list
[18:04:19.996]             seq.int <- base::seq.int
[18:04:19.996]             signalCondition <- base::signalCondition
[18:04:19.996]             sys.calls <- base::sys.calls
[18:04:19.996]             `[[` <- base::`[[`
[18:04:19.996]             `+` <- base::`+`
[18:04:19.996]             `<<-` <- base::`<<-`
[18:04:19.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:19.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:19.996]                   3L)]
[18:04:19.996]             }
[18:04:19.996]             function(cond) {
[18:04:19.996]                 is_error <- inherits(cond, "error")
[18:04:19.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:19.996]                   NULL)
[18:04:19.996]                 if (is_error) {
[18:04:19.996]                   sessionInformation <- function() {
[18:04:19.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:19.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:19.996]                       search = base::search(), system = base::Sys.info())
[18:04:19.996]                   }
[18:04:19.996]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:19.996]                     cond$call), session = sessionInformation(), 
[18:04:19.996]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:19.996]                   signalCondition(cond)
[18:04:19.996]                 }
[18:04:19.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:19.996]                 "immediateCondition"))) {
[18:04:19.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:19.996]                   ...future.conditions[[length(...future.conditions) + 
[18:04:19.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:19.996]                   if (TRUE && !signal) {
[18:04:19.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.996]                     {
[18:04:19.996]                       inherits <- base::inherits
[18:04:19.996]                       invokeRestart <- base::invokeRestart
[18:04:19.996]                       is.null <- base::is.null
[18:04:19.996]                       muffled <- FALSE
[18:04:19.996]                       if (inherits(cond, "message")) {
[18:04:19.996]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.996]                         if (muffled) 
[18:04:19.996]                           invokeRestart("muffleMessage")
[18:04:19.996]                       }
[18:04:19.996]                       else if (inherits(cond, "warning")) {
[18:04:19.996]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.996]                         if (muffled) 
[18:04:19.996]                           invokeRestart("muffleWarning")
[18:04:19.996]                       }
[18:04:19.996]                       else if (inherits(cond, "condition")) {
[18:04:19.996]                         if (!is.null(pattern)) {
[18:04:19.996]                           computeRestarts <- base::computeRestarts
[18:04:19.996]                           grepl <- base::grepl
[18:04:19.996]                           restarts <- computeRestarts(cond)
[18:04:19.996]                           for (restart in restarts) {
[18:04:19.996]                             name <- restart$name
[18:04:19.996]                             if (is.null(name)) 
[18:04:19.996]                               next
[18:04:19.996]                             if (!grepl(pattern, name)) 
[18:04:19.996]                               next
[18:04:19.996]                             invokeRestart(restart)
[18:04:19.996]                             muffled <- TRUE
[18:04:19.996]                             break
[18:04:19.996]                           }
[18:04:19.996]                         }
[18:04:19.996]                       }
[18:04:19.996]                       invisible(muffled)
[18:04:19.996]                     }
[18:04:19.996]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.996]                   }
[18:04:19.996]                 }
[18:04:19.996]                 else {
[18:04:19.996]                   if (TRUE) {
[18:04:19.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:19.996]                     {
[18:04:19.996]                       inherits <- base::inherits
[18:04:19.996]                       invokeRestart <- base::invokeRestart
[18:04:19.996]                       is.null <- base::is.null
[18:04:19.996]                       muffled <- FALSE
[18:04:19.996]                       if (inherits(cond, "message")) {
[18:04:19.996]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:19.996]                         if (muffled) 
[18:04:19.996]                           invokeRestart("muffleMessage")
[18:04:19.996]                       }
[18:04:19.996]                       else if (inherits(cond, "warning")) {
[18:04:19.996]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:19.996]                         if (muffled) 
[18:04:19.996]                           invokeRestart("muffleWarning")
[18:04:19.996]                       }
[18:04:19.996]                       else if (inherits(cond, "condition")) {
[18:04:19.996]                         if (!is.null(pattern)) {
[18:04:19.996]                           computeRestarts <- base::computeRestarts
[18:04:19.996]                           grepl <- base::grepl
[18:04:19.996]                           restarts <- computeRestarts(cond)
[18:04:19.996]                           for (restart in restarts) {
[18:04:19.996]                             name <- restart$name
[18:04:19.996]                             if (is.null(name)) 
[18:04:19.996]                               next
[18:04:19.996]                             if (!grepl(pattern, name)) 
[18:04:19.996]                               next
[18:04:19.996]                             invokeRestart(restart)
[18:04:19.996]                             muffled <- TRUE
[18:04:19.996]                             break
[18:04:19.996]                           }
[18:04:19.996]                         }
[18:04:19.996]                       }
[18:04:19.996]                       invisible(muffled)
[18:04:19.996]                     }
[18:04:19.996]                     muffleCondition(cond, pattern = "^muffle")
[18:04:19.996]                   }
[18:04:19.996]                 }
[18:04:19.996]             }
[18:04:19.996]         }))
[18:04:19.996]     }, error = function(ex) {
[18:04:19.996]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:19.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:19.996]                 ...future.rng), started = ...future.startTime, 
[18:04:19.996]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:19.996]             version = "1.8"), class = "FutureResult")
[18:04:19.996]     }, finally = {
[18:04:19.996]         if (!identical(...future.workdir, getwd())) 
[18:04:19.996]             setwd(...future.workdir)
[18:04:19.996]         {
[18:04:19.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:19.996]                 ...future.oldOptions$nwarnings <- NULL
[18:04:19.996]             }
[18:04:19.996]             base::options(...future.oldOptions)
[18:04:19.996]             if (.Platform$OS.type == "windows") {
[18:04:19.996]                 old_names <- names(...future.oldEnvVars)
[18:04:19.996]                 envs <- base::Sys.getenv()
[18:04:19.996]                 names <- names(envs)
[18:04:19.996]                 common <- intersect(names, old_names)
[18:04:19.996]                 added <- setdiff(names, old_names)
[18:04:19.996]                 removed <- setdiff(old_names, names)
[18:04:19.996]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:19.996]                   envs[common]]
[18:04:19.996]                 NAMES <- toupper(changed)
[18:04:19.996]                 args <- list()
[18:04:19.996]                 for (kk in seq_along(NAMES)) {
[18:04:19.996]                   name <- changed[[kk]]
[18:04:19.996]                   NAME <- NAMES[[kk]]
[18:04:19.996]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.996]                     next
[18:04:19.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.996]                 }
[18:04:19.996]                 NAMES <- toupper(added)
[18:04:19.996]                 for (kk in seq_along(NAMES)) {
[18:04:19.996]                   name <- added[[kk]]
[18:04:19.996]                   NAME <- NAMES[[kk]]
[18:04:19.996]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.996]                     next
[18:04:19.996]                   args[[name]] <- ""
[18:04:19.996]                 }
[18:04:19.996]                 NAMES <- toupper(removed)
[18:04:19.996]                 for (kk in seq_along(NAMES)) {
[18:04:19.996]                   name <- removed[[kk]]
[18:04:19.996]                   NAME <- NAMES[[kk]]
[18:04:19.996]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:19.996]                     next
[18:04:19.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:19.996]                 }
[18:04:19.996]                 if (length(args) > 0) 
[18:04:19.996]                   base::do.call(base::Sys.setenv, args = args)
[18:04:19.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:19.996]             }
[18:04:19.996]             else {
[18:04:19.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:19.996]             }
[18:04:19.996]             {
[18:04:19.996]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:19.996]                   0L) {
[18:04:19.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:19.996]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:19.996]                   base::options(opts)
[18:04:19.996]                 }
[18:04:19.996]                 {
[18:04:19.996]                   {
[18:04:19.996]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:19.996]                     NULL
[18:04:19.996]                   }
[18:04:19.996]                   options(future.plan = NULL)
[18:04:19.996]                   if (is.na(NA_character_)) 
[18:04:19.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:19.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:19.996]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:19.996]                     .init = FALSE)
[18:04:19.996]                 }
[18:04:19.996]             }
[18:04:19.996]         }
[18:04:19.996]     })
[18:04:19.996]     if (TRUE) {
[18:04:19.996]         base::sink(type = "output", split = FALSE)
[18:04:19.996]         if (TRUE) {
[18:04:19.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:19.996]         }
[18:04:19.996]         else {
[18:04:19.996]             ...future.result["stdout"] <- base::list(NULL)
[18:04:19.996]         }
[18:04:19.996]         base::close(...future.stdout)
[18:04:19.996]         ...future.stdout <- NULL
[18:04:19.996]     }
[18:04:19.996]     ...future.result$conditions <- ...future.conditions
[18:04:19.996]     ...future.result$finished <- base::Sys.time()
[18:04:19.996]     ...future.result
[18:04:19.996] }
[18:04:20.094] MultisessionFuture started
[18:04:20.095] result() for ClusterFuture ...
[18:04:20.095] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.095] - Validating connection of MultisessionFuture
[18:04:20.160] - received message: FutureResult
[18:04:20.160] - Received FutureResult
[18:04:20.161] - Erased future from FutureRegistry
[18:04:20.161] result() for ClusterFuture ...
[18:04:20.161] - result already collected: FutureResult
[18:04:20.161] result() for ClusterFuture ... done
[18:04:20.162] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:20.162] result() for ClusterFuture ... done
[18:04:20.162] result() for ClusterFuture ...
[18:04:20.162] - result already collected: FutureResult
[18:04:20.162] result() for ClusterFuture ... done
[18:04:20.163] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:04:20.169] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[18:04:20.169] getGlobalsAndPackages() ...
[18:04:20.170] Searching for globals...
[18:04:20.170] 
[18:04:20.171] Searching for globals ... DONE
[18:04:20.171] - globals: [0] <none>
[18:04:20.171] getGlobalsAndPackages() ... DONE
[18:04:20.172] run() for ‘Future’ ...
[18:04:20.172] - state: ‘created’
[18:04:20.172] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.197] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.197] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.197]   - Field: ‘node’
[18:04:20.198]   - Field: ‘label’
[18:04:20.198]   - Field: ‘local’
[18:04:20.198]   - Field: ‘owner’
[18:04:20.198]   - Field: ‘envir’
[18:04:20.199]   - Field: ‘workers’
[18:04:20.199]   - Field: ‘packages’
[18:04:20.199]   - Field: ‘gc’
[18:04:20.199]   - Field: ‘conditions’
[18:04:20.200]   - Field: ‘persistent’
[18:04:20.200]   - Field: ‘expr’
[18:04:20.200]   - Field: ‘uuid’
[18:04:20.200]   - Field: ‘seed’
[18:04:20.200]   - Field: ‘version’
[18:04:20.201]   - Field: ‘result’
[18:04:20.201]   - Field: ‘asynchronous’
[18:04:20.201]   - Field: ‘calls’
[18:04:20.201]   - Field: ‘globals’
[18:04:20.202]   - Field: ‘stdout’
[18:04:20.202]   - Field: ‘earlySignal’
[18:04:20.202]   - Field: ‘lazy’
[18:04:20.202]   - Field: ‘state’
[18:04:20.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.203] - Launch lazy future ...
[18:04:20.203] Packages needed by the future expression (n = 0): <none>
[18:04:20.204] Packages needed by future strategies (n = 0): <none>
[18:04:20.205] {
[18:04:20.205]     {
[18:04:20.205]         {
[18:04:20.205]             ...future.startTime <- base::Sys.time()
[18:04:20.205]             {
[18:04:20.205]                 {
[18:04:20.205]                   {
[18:04:20.205]                     {
[18:04:20.205]                       base::local({
[18:04:20.205]                         has_future <- base::requireNamespace("future", 
[18:04:20.205]                           quietly = TRUE)
[18:04:20.205]                         if (has_future) {
[18:04:20.205]                           ns <- base::getNamespace("future")
[18:04:20.205]                           version <- ns[[".package"]][["version"]]
[18:04:20.205]                           if (is.null(version)) 
[18:04:20.205]                             version <- utils::packageVersion("future")
[18:04:20.205]                         }
[18:04:20.205]                         else {
[18:04:20.205]                           version <- NULL
[18:04:20.205]                         }
[18:04:20.205]                         if (!has_future || version < "1.8.0") {
[18:04:20.205]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.205]                             "", base::R.version$version.string), 
[18:04:20.205]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.205]                               "release", "version")], collapse = " "), 
[18:04:20.205]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.205]                             info)
[18:04:20.205]                           info <- base::paste(info, collapse = "; ")
[18:04:20.205]                           if (!has_future) {
[18:04:20.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.205]                               info)
[18:04:20.205]                           }
[18:04:20.205]                           else {
[18:04:20.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.205]                               info, version)
[18:04:20.205]                           }
[18:04:20.205]                           base::stop(msg)
[18:04:20.205]                         }
[18:04:20.205]                       })
[18:04:20.205]                     }
[18:04:20.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.205]                     base::options(mc.cores = 1L)
[18:04:20.205]                   }
[18:04:20.205]                   ...future.strategy.old <- future::plan("list")
[18:04:20.205]                   options(future.plan = NULL)
[18:04:20.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.205]                 }
[18:04:20.205]                 ...future.workdir <- getwd()
[18:04:20.205]             }
[18:04:20.205]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.205]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.205]         }
[18:04:20.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.205]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.205]             base::names(...future.oldOptions))
[18:04:20.205]     }
[18:04:20.205]     if (FALSE) {
[18:04:20.205]     }
[18:04:20.205]     else {
[18:04:20.205]         if (TRUE) {
[18:04:20.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.205]                 open = "w")
[18:04:20.205]         }
[18:04:20.205]         else {
[18:04:20.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.205]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.205]         }
[18:04:20.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.205]             base::sink(type = "output", split = FALSE)
[18:04:20.205]             base::close(...future.stdout)
[18:04:20.205]         }, add = TRUE)
[18:04:20.205]     }
[18:04:20.205]     ...future.frame <- base::sys.nframe()
[18:04:20.205]     ...future.conditions <- base::list()
[18:04:20.205]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.205]     if (FALSE) {
[18:04:20.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.205]     }
[18:04:20.205]     ...future.result <- base::tryCatch({
[18:04:20.205]         base::withCallingHandlers({
[18:04:20.205]             ...future.value <- base::withVisible(base::local({
[18:04:20.205]                 ...future.makeSendCondition <- base::local({
[18:04:20.205]                   sendCondition <- NULL
[18:04:20.205]                   function(frame = 1L) {
[18:04:20.205]                     if (is.function(sendCondition)) 
[18:04:20.205]                       return(sendCondition)
[18:04:20.205]                     ns <- getNamespace("parallel")
[18:04:20.205]                     if (exists("sendData", mode = "function", 
[18:04:20.205]                       envir = ns)) {
[18:04:20.205]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.205]                         envir = ns)
[18:04:20.205]                       envir <- sys.frame(frame)
[18:04:20.205]                       master <- NULL
[18:04:20.205]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.205]                         !identical(envir, emptyenv())) {
[18:04:20.205]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.205]                           inherits = FALSE)) {
[18:04:20.205]                           master <- get("master", mode = "list", 
[18:04:20.205]                             envir = envir, inherits = FALSE)
[18:04:20.205]                           if (inherits(master, c("SOCKnode", 
[18:04:20.205]                             "SOCK0node"))) {
[18:04:20.205]                             sendCondition <<- function(cond) {
[18:04:20.205]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.205]                                 success = TRUE)
[18:04:20.205]                               parallel_sendData(master, data)
[18:04:20.205]                             }
[18:04:20.205]                             return(sendCondition)
[18:04:20.205]                           }
[18:04:20.205]                         }
[18:04:20.205]                         frame <- frame + 1L
[18:04:20.205]                         envir <- sys.frame(frame)
[18:04:20.205]                       }
[18:04:20.205]                     }
[18:04:20.205]                     sendCondition <<- function(cond) NULL
[18:04:20.205]                   }
[18:04:20.205]                 })
[18:04:20.205]                 withCallingHandlers({
[18:04:20.205]                   2
[18:04:20.205]                 }, immediateCondition = function(cond) {
[18:04:20.205]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.205]                   sendCondition(cond)
[18:04:20.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.205]                   {
[18:04:20.205]                     inherits <- base::inherits
[18:04:20.205]                     invokeRestart <- base::invokeRestart
[18:04:20.205]                     is.null <- base::is.null
[18:04:20.205]                     muffled <- FALSE
[18:04:20.205]                     if (inherits(cond, "message")) {
[18:04:20.205]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.205]                       if (muffled) 
[18:04:20.205]                         invokeRestart("muffleMessage")
[18:04:20.205]                     }
[18:04:20.205]                     else if (inherits(cond, "warning")) {
[18:04:20.205]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.205]                       if (muffled) 
[18:04:20.205]                         invokeRestart("muffleWarning")
[18:04:20.205]                     }
[18:04:20.205]                     else if (inherits(cond, "condition")) {
[18:04:20.205]                       if (!is.null(pattern)) {
[18:04:20.205]                         computeRestarts <- base::computeRestarts
[18:04:20.205]                         grepl <- base::grepl
[18:04:20.205]                         restarts <- computeRestarts(cond)
[18:04:20.205]                         for (restart in restarts) {
[18:04:20.205]                           name <- restart$name
[18:04:20.205]                           if (is.null(name)) 
[18:04:20.205]                             next
[18:04:20.205]                           if (!grepl(pattern, name)) 
[18:04:20.205]                             next
[18:04:20.205]                           invokeRestart(restart)
[18:04:20.205]                           muffled <- TRUE
[18:04:20.205]                           break
[18:04:20.205]                         }
[18:04:20.205]                       }
[18:04:20.205]                     }
[18:04:20.205]                     invisible(muffled)
[18:04:20.205]                   }
[18:04:20.205]                   muffleCondition(cond)
[18:04:20.205]                 })
[18:04:20.205]             }))
[18:04:20.205]             future::FutureResult(value = ...future.value$value, 
[18:04:20.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.205]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.205]                     ...future.globalenv.names))
[18:04:20.205]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.205]         }, condition = base::local({
[18:04:20.205]             c <- base::c
[18:04:20.205]             inherits <- base::inherits
[18:04:20.205]             invokeRestart <- base::invokeRestart
[18:04:20.205]             length <- base::length
[18:04:20.205]             list <- base::list
[18:04:20.205]             seq.int <- base::seq.int
[18:04:20.205]             signalCondition <- base::signalCondition
[18:04:20.205]             sys.calls <- base::sys.calls
[18:04:20.205]             `[[` <- base::`[[`
[18:04:20.205]             `+` <- base::`+`
[18:04:20.205]             `<<-` <- base::`<<-`
[18:04:20.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.205]                   3L)]
[18:04:20.205]             }
[18:04:20.205]             function(cond) {
[18:04:20.205]                 is_error <- inherits(cond, "error")
[18:04:20.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.205]                   NULL)
[18:04:20.205]                 if (is_error) {
[18:04:20.205]                   sessionInformation <- function() {
[18:04:20.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.205]                       search = base::search(), system = base::Sys.info())
[18:04:20.205]                   }
[18:04:20.205]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.205]                     cond$call), session = sessionInformation(), 
[18:04:20.205]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.205]                   signalCondition(cond)
[18:04:20.205]                 }
[18:04:20.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.205]                 "immediateCondition"))) {
[18:04:20.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.205]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.205]                   if (TRUE && !signal) {
[18:04:20.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.205]                     {
[18:04:20.205]                       inherits <- base::inherits
[18:04:20.205]                       invokeRestart <- base::invokeRestart
[18:04:20.205]                       is.null <- base::is.null
[18:04:20.205]                       muffled <- FALSE
[18:04:20.205]                       if (inherits(cond, "message")) {
[18:04:20.205]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.205]                         if (muffled) 
[18:04:20.205]                           invokeRestart("muffleMessage")
[18:04:20.205]                       }
[18:04:20.205]                       else if (inherits(cond, "warning")) {
[18:04:20.205]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.205]                         if (muffled) 
[18:04:20.205]                           invokeRestart("muffleWarning")
[18:04:20.205]                       }
[18:04:20.205]                       else if (inherits(cond, "condition")) {
[18:04:20.205]                         if (!is.null(pattern)) {
[18:04:20.205]                           computeRestarts <- base::computeRestarts
[18:04:20.205]                           grepl <- base::grepl
[18:04:20.205]                           restarts <- computeRestarts(cond)
[18:04:20.205]                           for (restart in restarts) {
[18:04:20.205]                             name <- restart$name
[18:04:20.205]                             if (is.null(name)) 
[18:04:20.205]                               next
[18:04:20.205]                             if (!grepl(pattern, name)) 
[18:04:20.205]                               next
[18:04:20.205]                             invokeRestart(restart)
[18:04:20.205]                             muffled <- TRUE
[18:04:20.205]                             break
[18:04:20.205]                           }
[18:04:20.205]                         }
[18:04:20.205]                       }
[18:04:20.205]                       invisible(muffled)
[18:04:20.205]                     }
[18:04:20.205]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.205]                   }
[18:04:20.205]                 }
[18:04:20.205]                 else {
[18:04:20.205]                   if (TRUE) {
[18:04:20.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.205]                     {
[18:04:20.205]                       inherits <- base::inherits
[18:04:20.205]                       invokeRestart <- base::invokeRestart
[18:04:20.205]                       is.null <- base::is.null
[18:04:20.205]                       muffled <- FALSE
[18:04:20.205]                       if (inherits(cond, "message")) {
[18:04:20.205]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.205]                         if (muffled) 
[18:04:20.205]                           invokeRestart("muffleMessage")
[18:04:20.205]                       }
[18:04:20.205]                       else if (inherits(cond, "warning")) {
[18:04:20.205]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.205]                         if (muffled) 
[18:04:20.205]                           invokeRestart("muffleWarning")
[18:04:20.205]                       }
[18:04:20.205]                       else if (inherits(cond, "condition")) {
[18:04:20.205]                         if (!is.null(pattern)) {
[18:04:20.205]                           computeRestarts <- base::computeRestarts
[18:04:20.205]                           grepl <- base::grepl
[18:04:20.205]                           restarts <- computeRestarts(cond)
[18:04:20.205]                           for (restart in restarts) {
[18:04:20.205]                             name <- restart$name
[18:04:20.205]                             if (is.null(name)) 
[18:04:20.205]                               next
[18:04:20.205]                             if (!grepl(pattern, name)) 
[18:04:20.205]                               next
[18:04:20.205]                             invokeRestart(restart)
[18:04:20.205]                             muffled <- TRUE
[18:04:20.205]                             break
[18:04:20.205]                           }
[18:04:20.205]                         }
[18:04:20.205]                       }
[18:04:20.205]                       invisible(muffled)
[18:04:20.205]                     }
[18:04:20.205]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.205]                   }
[18:04:20.205]                 }
[18:04:20.205]             }
[18:04:20.205]         }))
[18:04:20.205]     }, error = function(ex) {
[18:04:20.205]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.205]                 ...future.rng), started = ...future.startTime, 
[18:04:20.205]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.205]             version = "1.8"), class = "FutureResult")
[18:04:20.205]     }, finally = {
[18:04:20.205]         if (!identical(...future.workdir, getwd())) 
[18:04:20.205]             setwd(...future.workdir)
[18:04:20.205]         {
[18:04:20.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.205]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.205]             }
[18:04:20.205]             base::options(...future.oldOptions)
[18:04:20.205]             if (.Platform$OS.type == "windows") {
[18:04:20.205]                 old_names <- names(...future.oldEnvVars)
[18:04:20.205]                 envs <- base::Sys.getenv()
[18:04:20.205]                 names <- names(envs)
[18:04:20.205]                 common <- intersect(names, old_names)
[18:04:20.205]                 added <- setdiff(names, old_names)
[18:04:20.205]                 removed <- setdiff(old_names, names)
[18:04:20.205]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.205]                   envs[common]]
[18:04:20.205]                 NAMES <- toupper(changed)
[18:04:20.205]                 args <- list()
[18:04:20.205]                 for (kk in seq_along(NAMES)) {
[18:04:20.205]                   name <- changed[[kk]]
[18:04:20.205]                   NAME <- NAMES[[kk]]
[18:04:20.205]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.205]                     next
[18:04:20.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.205]                 }
[18:04:20.205]                 NAMES <- toupper(added)
[18:04:20.205]                 for (kk in seq_along(NAMES)) {
[18:04:20.205]                   name <- added[[kk]]
[18:04:20.205]                   NAME <- NAMES[[kk]]
[18:04:20.205]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.205]                     next
[18:04:20.205]                   args[[name]] <- ""
[18:04:20.205]                 }
[18:04:20.205]                 NAMES <- toupper(removed)
[18:04:20.205]                 for (kk in seq_along(NAMES)) {
[18:04:20.205]                   name <- removed[[kk]]
[18:04:20.205]                   NAME <- NAMES[[kk]]
[18:04:20.205]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.205]                     next
[18:04:20.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.205]                 }
[18:04:20.205]                 if (length(args) > 0) 
[18:04:20.205]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.205]             }
[18:04:20.205]             else {
[18:04:20.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.205]             }
[18:04:20.205]             {
[18:04:20.205]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.205]                   0L) {
[18:04:20.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.205]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.205]                   base::options(opts)
[18:04:20.205]                 }
[18:04:20.205]                 {
[18:04:20.205]                   {
[18:04:20.205]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.205]                     NULL
[18:04:20.205]                   }
[18:04:20.205]                   options(future.plan = NULL)
[18:04:20.205]                   if (is.na(NA_character_)) 
[18:04:20.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.205]                     .init = FALSE)
[18:04:20.205]                 }
[18:04:20.205]             }
[18:04:20.205]         }
[18:04:20.205]     })
[18:04:20.205]     if (TRUE) {
[18:04:20.205]         base::sink(type = "output", split = FALSE)
[18:04:20.205]         if (TRUE) {
[18:04:20.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.205]         }
[18:04:20.205]         else {
[18:04:20.205]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.205]         }
[18:04:20.205]         base::close(...future.stdout)
[18:04:20.205]         ...future.stdout <- NULL
[18:04:20.205]     }
[18:04:20.205]     ...future.result$conditions <- ...future.conditions
[18:04:20.205]     ...future.result$finished <- base::Sys.time()
[18:04:20.205]     ...future.result
[18:04:20.205] }
[18:04:20.211] MultisessionFuture started
[18:04:20.211] - Launch lazy future ... done
[18:04:20.212] run() for ‘MultisessionFuture’ ... done
[18:04:20.212] getGlobalsAndPackages() ...
[18:04:20.212] Searching for globals...
[18:04:20.213] 
[18:04:20.214] Searching for globals ... DONE
[18:04:20.214] - globals: [0] <none>
[18:04:20.214] getGlobalsAndPackages() ... DONE
[18:04:20.215] run() for ‘Future’ ...
[18:04:20.215] - state: ‘created’
[18:04:20.215] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.244] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.244] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.245]   - Field: ‘node’
[18:04:20.245]   - Field: ‘label’
[18:04:20.245]   - Field: ‘local’
[18:04:20.246]   - Field: ‘owner’
[18:04:20.246]   - Field: ‘envir’
[18:04:20.246]   - Field: ‘workers’
[18:04:20.246]   - Field: ‘packages’
[18:04:20.247]   - Field: ‘gc’
[18:04:20.247]   - Field: ‘conditions’
[18:04:20.247]   - Field: ‘persistent’
[18:04:20.247]   - Field: ‘expr’
[18:04:20.248]   - Field: ‘uuid’
[18:04:20.248]   - Field: ‘seed’
[18:04:20.248]   - Field: ‘version’
[18:04:20.248]   - Field: ‘result’
[18:04:20.249]   - Field: ‘asynchronous’
[18:04:20.249]   - Field: ‘calls’
[18:04:20.249]   - Field: ‘globals’
[18:04:20.249]   - Field: ‘stdout’
[18:04:20.250]   - Field: ‘earlySignal’
[18:04:20.250]   - Field: ‘lazy’
[18:04:20.250]   - Field: ‘state’
[18:04:20.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.250] - Launch lazy future ...
[18:04:20.251] Packages needed by the future expression (n = 0): <none>
[18:04:20.251] Packages needed by future strategies (n = 0): <none>
[18:04:20.253] {
[18:04:20.253]     {
[18:04:20.253]         {
[18:04:20.253]             ...future.startTime <- base::Sys.time()
[18:04:20.253]             {
[18:04:20.253]                 {
[18:04:20.253]                   {
[18:04:20.253]                     {
[18:04:20.253]                       base::local({
[18:04:20.253]                         has_future <- base::requireNamespace("future", 
[18:04:20.253]                           quietly = TRUE)
[18:04:20.253]                         if (has_future) {
[18:04:20.253]                           ns <- base::getNamespace("future")
[18:04:20.253]                           version <- ns[[".package"]][["version"]]
[18:04:20.253]                           if (is.null(version)) 
[18:04:20.253]                             version <- utils::packageVersion("future")
[18:04:20.253]                         }
[18:04:20.253]                         else {
[18:04:20.253]                           version <- NULL
[18:04:20.253]                         }
[18:04:20.253]                         if (!has_future || version < "1.8.0") {
[18:04:20.253]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.253]                             "", base::R.version$version.string), 
[18:04:20.253]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.253]                               "release", "version")], collapse = " "), 
[18:04:20.253]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.253]                             info)
[18:04:20.253]                           info <- base::paste(info, collapse = "; ")
[18:04:20.253]                           if (!has_future) {
[18:04:20.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.253]                               info)
[18:04:20.253]                           }
[18:04:20.253]                           else {
[18:04:20.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.253]                               info, version)
[18:04:20.253]                           }
[18:04:20.253]                           base::stop(msg)
[18:04:20.253]                         }
[18:04:20.253]                       })
[18:04:20.253]                     }
[18:04:20.253]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.253]                     base::options(mc.cores = 1L)
[18:04:20.253]                   }
[18:04:20.253]                   ...future.strategy.old <- future::plan("list")
[18:04:20.253]                   options(future.plan = NULL)
[18:04:20.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.253]                 }
[18:04:20.253]                 ...future.workdir <- getwd()
[18:04:20.253]             }
[18:04:20.253]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.253]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.253]         }
[18:04:20.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.253]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.253]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.253]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.253]             base::names(...future.oldOptions))
[18:04:20.253]     }
[18:04:20.253]     if (FALSE) {
[18:04:20.253]     }
[18:04:20.253]     else {
[18:04:20.253]         if (TRUE) {
[18:04:20.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.253]                 open = "w")
[18:04:20.253]         }
[18:04:20.253]         else {
[18:04:20.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.253]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.253]         }
[18:04:20.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.253]             base::sink(type = "output", split = FALSE)
[18:04:20.253]             base::close(...future.stdout)
[18:04:20.253]         }, add = TRUE)
[18:04:20.253]     }
[18:04:20.253]     ...future.frame <- base::sys.nframe()
[18:04:20.253]     ...future.conditions <- base::list()
[18:04:20.253]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.253]     if (FALSE) {
[18:04:20.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.253]     }
[18:04:20.253]     ...future.result <- base::tryCatch({
[18:04:20.253]         base::withCallingHandlers({
[18:04:20.253]             ...future.value <- base::withVisible(base::local({
[18:04:20.253]                 ...future.makeSendCondition <- base::local({
[18:04:20.253]                   sendCondition <- NULL
[18:04:20.253]                   function(frame = 1L) {
[18:04:20.253]                     if (is.function(sendCondition)) 
[18:04:20.253]                       return(sendCondition)
[18:04:20.253]                     ns <- getNamespace("parallel")
[18:04:20.253]                     if (exists("sendData", mode = "function", 
[18:04:20.253]                       envir = ns)) {
[18:04:20.253]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.253]                         envir = ns)
[18:04:20.253]                       envir <- sys.frame(frame)
[18:04:20.253]                       master <- NULL
[18:04:20.253]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.253]                         !identical(envir, emptyenv())) {
[18:04:20.253]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.253]                           inherits = FALSE)) {
[18:04:20.253]                           master <- get("master", mode = "list", 
[18:04:20.253]                             envir = envir, inherits = FALSE)
[18:04:20.253]                           if (inherits(master, c("SOCKnode", 
[18:04:20.253]                             "SOCK0node"))) {
[18:04:20.253]                             sendCondition <<- function(cond) {
[18:04:20.253]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.253]                                 success = TRUE)
[18:04:20.253]                               parallel_sendData(master, data)
[18:04:20.253]                             }
[18:04:20.253]                             return(sendCondition)
[18:04:20.253]                           }
[18:04:20.253]                         }
[18:04:20.253]                         frame <- frame + 1L
[18:04:20.253]                         envir <- sys.frame(frame)
[18:04:20.253]                       }
[18:04:20.253]                     }
[18:04:20.253]                     sendCondition <<- function(cond) NULL
[18:04:20.253]                   }
[18:04:20.253]                 })
[18:04:20.253]                 withCallingHandlers({
[18:04:20.253]                   NULL
[18:04:20.253]                 }, immediateCondition = function(cond) {
[18:04:20.253]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.253]                   sendCondition(cond)
[18:04:20.253]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.253]                   {
[18:04:20.253]                     inherits <- base::inherits
[18:04:20.253]                     invokeRestart <- base::invokeRestart
[18:04:20.253]                     is.null <- base::is.null
[18:04:20.253]                     muffled <- FALSE
[18:04:20.253]                     if (inherits(cond, "message")) {
[18:04:20.253]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.253]                       if (muffled) 
[18:04:20.253]                         invokeRestart("muffleMessage")
[18:04:20.253]                     }
[18:04:20.253]                     else if (inherits(cond, "warning")) {
[18:04:20.253]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.253]                       if (muffled) 
[18:04:20.253]                         invokeRestart("muffleWarning")
[18:04:20.253]                     }
[18:04:20.253]                     else if (inherits(cond, "condition")) {
[18:04:20.253]                       if (!is.null(pattern)) {
[18:04:20.253]                         computeRestarts <- base::computeRestarts
[18:04:20.253]                         grepl <- base::grepl
[18:04:20.253]                         restarts <- computeRestarts(cond)
[18:04:20.253]                         for (restart in restarts) {
[18:04:20.253]                           name <- restart$name
[18:04:20.253]                           if (is.null(name)) 
[18:04:20.253]                             next
[18:04:20.253]                           if (!grepl(pattern, name)) 
[18:04:20.253]                             next
[18:04:20.253]                           invokeRestart(restart)
[18:04:20.253]                           muffled <- TRUE
[18:04:20.253]                           break
[18:04:20.253]                         }
[18:04:20.253]                       }
[18:04:20.253]                     }
[18:04:20.253]                     invisible(muffled)
[18:04:20.253]                   }
[18:04:20.253]                   muffleCondition(cond)
[18:04:20.253]                 })
[18:04:20.253]             }))
[18:04:20.253]             future::FutureResult(value = ...future.value$value, 
[18:04:20.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.253]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.253]                     ...future.globalenv.names))
[18:04:20.253]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.253]         }, condition = base::local({
[18:04:20.253]             c <- base::c
[18:04:20.253]             inherits <- base::inherits
[18:04:20.253]             invokeRestart <- base::invokeRestart
[18:04:20.253]             length <- base::length
[18:04:20.253]             list <- base::list
[18:04:20.253]             seq.int <- base::seq.int
[18:04:20.253]             signalCondition <- base::signalCondition
[18:04:20.253]             sys.calls <- base::sys.calls
[18:04:20.253]             `[[` <- base::`[[`
[18:04:20.253]             `+` <- base::`+`
[18:04:20.253]             `<<-` <- base::`<<-`
[18:04:20.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.253]                   3L)]
[18:04:20.253]             }
[18:04:20.253]             function(cond) {
[18:04:20.253]                 is_error <- inherits(cond, "error")
[18:04:20.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.253]                   NULL)
[18:04:20.253]                 if (is_error) {
[18:04:20.253]                   sessionInformation <- function() {
[18:04:20.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.253]                       search = base::search(), system = base::Sys.info())
[18:04:20.253]                   }
[18:04:20.253]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.253]                     cond$call), session = sessionInformation(), 
[18:04:20.253]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.253]                   signalCondition(cond)
[18:04:20.253]                 }
[18:04:20.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.253]                 "immediateCondition"))) {
[18:04:20.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.253]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.253]                   if (TRUE && !signal) {
[18:04:20.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.253]                     {
[18:04:20.253]                       inherits <- base::inherits
[18:04:20.253]                       invokeRestart <- base::invokeRestart
[18:04:20.253]                       is.null <- base::is.null
[18:04:20.253]                       muffled <- FALSE
[18:04:20.253]                       if (inherits(cond, "message")) {
[18:04:20.253]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.253]                         if (muffled) 
[18:04:20.253]                           invokeRestart("muffleMessage")
[18:04:20.253]                       }
[18:04:20.253]                       else if (inherits(cond, "warning")) {
[18:04:20.253]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.253]                         if (muffled) 
[18:04:20.253]                           invokeRestart("muffleWarning")
[18:04:20.253]                       }
[18:04:20.253]                       else if (inherits(cond, "condition")) {
[18:04:20.253]                         if (!is.null(pattern)) {
[18:04:20.253]                           computeRestarts <- base::computeRestarts
[18:04:20.253]                           grepl <- base::grepl
[18:04:20.253]                           restarts <- computeRestarts(cond)
[18:04:20.253]                           for (restart in restarts) {
[18:04:20.253]                             name <- restart$name
[18:04:20.253]                             if (is.null(name)) 
[18:04:20.253]                               next
[18:04:20.253]                             if (!grepl(pattern, name)) 
[18:04:20.253]                               next
[18:04:20.253]                             invokeRestart(restart)
[18:04:20.253]                             muffled <- TRUE
[18:04:20.253]                             break
[18:04:20.253]                           }
[18:04:20.253]                         }
[18:04:20.253]                       }
[18:04:20.253]                       invisible(muffled)
[18:04:20.253]                     }
[18:04:20.253]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.253]                   }
[18:04:20.253]                 }
[18:04:20.253]                 else {
[18:04:20.253]                   if (TRUE) {
[18:04:20.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.253]                     {
[18:04:20.253]                       inherits <- base::inherits
[18:04:20.253]                       invokeRestart <- base::invokeRestart
[18:04:20.253]                       is.null <- base::is.null
[18:04:20.253]                       muffled <- FALSE
[18:04:20.253]                       if (inherits(cond, "message")) {
[18:04:20.253]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.253]                         if (muffled) 
[18:04:20.253]                           invokeRestart("muffleMessage")
[18:04:20.253]                       }
[18:04:20.253]                       else if (inherits(cond, "warning")) {
[18:04:20.253]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.253]                         if (muffled) 
[18:04:20.253]                           invokeRestart("muffleWarning")
[18:04:20.253]                       }
[18:04:20.253]                       else if (inherits(cond, "condition")) {
[18:04:20.253]                         if (!is.null(pattern)) {
[18:04:20.253]                           computeRestarts <- base::computeRestarts
[18:04:20.253]                           grepl <- base::grepl
[18:04:20.253]                           restarts <- computeRestarts(cond)
[18:04:20.253]                           for (restart in restarts) {
[18:04:20.253]                             name <- restart$name
[18:04:20.253]                             if (is.null(name)) 
[18:04:20.253]                               next
[18:04:20.253]                             if (!grepl(pattern, name)) 
[18:04:20.253]                               next
[18:04:20.253]                             invokeRestart(restart)
[18:04:20.253]                             muffled <- TRUE
[18:04:20.253]                             break
[18:04:20.253]                           }
[18:04:20.253]                         }
[18:04:20.253]                       }
[18:04:20.253]                       invisible(muffled)
[18:04:20.253]                     }
[18:04:20.253]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.253]                   }
[18:04:20.253]                 }
[18:04:20.253]             }
[18:04:20.253]         }))
[18:04:20.253]     }, error = function(ex) {
[18:04:20.253]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.253]                 ...future.rng), started = ...future.startTime, 
[18:04:20.253]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.253]             version = "1.8"), class = "FutureResult")
[18:04:20.253]     }, finally = {
[18:04:20.253]         if (!identical(...future.workdir, getwd())) 
[18:04:20.253]             setwd(...future.workdir)
[18:04:20.253]         {
[18:04:20.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.253]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.253]             }
[18:04:20.253]             base::options(...future.oldOptions)
[18:04:20.253]             if (.Platform$OS.type == "windows") {
[18:04:20.253]                 old_names <- names(...future.oldEnvVars)
[18:04:20.253]                 envs <- base::Sys.getenv()
[18:04:20.253]                 names <- names(envs)
[18:04:20.253]                 common <- intersect(names, old_names)
[18:04:20.253]                 added <- setdiff(names, old_names)
[18:04:20.253]                 removed <- setdiff(old_names, names)
[18:04:20.253]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.253]                   envs[common]]
[18:04:20.253]                 NAMES <- toupper(changed)
[18:04:20.253]                 args <- list()
[18:04:20.253]                 for (kk in seq_along(NAMES)) {
[18:04:20.253]                   name <- changed[[kk]]
[18:04:20.253]                   NAME <- NAMES[[kk]]
[18:04:20.253]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.253]                     next
[18:04:20.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.253]                 }
[18:04:20.253]                 NAMES <- toupper(added)
[18:04:20.253]                 for (kk in seq_along(NAMES)) {
[18:04:20.253]                   name <- added[[kk]]
[18:04:20.253]                   NAME <- NAMES[[kk]]
[18:04:20.253]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.253]                     next
[18:04:20.253]                   args[[name]] <- ""
[18:04:20.253]                 }
[18:04:20.253]                 NAMES <- toupper(removed)
[18:04:20.253]                 for (kk in seq_along(NAMES)) {
[18:04:20.253]                   name <- removed[[kk]]
[18:04:20.253]                   NAME <- NAMES[[kk]]
[18:04:20.253]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.253]                     next
[18:04:20.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.253]                 }
[18:04:20.253]                 if (length(args) > 0) 
[18:04:20.253]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.253]             }
[18:04:20.253]             else {
[18:04:20.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.253]             }
[18:04:20.253]             {
[18:04:20.253]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.253]                   0L) {
[18:04:20.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.253]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.253]                   base::options(opts)
[18:04:20.253]                 }
[18:04:20.253]                 {
[18:04:20.253]                   {
[18:04:20.253]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.253]                     NULL
[18:04:20.253]                   }
[18:04:20.253]                   options(future.plan = NULL)
[18:04:20.253]                   if (is.na(NA_character_)) 
[18:04:20.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.253]                     .init = FALSE)
[18:04:20.253]                 }
[18:04:20.253]             }
[18:04:20.253]         }
[18:04:20.253]     })
[18:04:20.253]     if (TRUE) {
[18:04:20.253]         base::sink(type = "output", split = FALSE)
[18:04:20.253]         if (TRUE) {
[18:04:20.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.253]         }
[18:04:20.253]         else {
[18:04:20.253]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.253]         }
[18:04:20.253]         base::close(...future.stdout)
[18:04:20.253]         ...future.stdout <- NULL
[18:04:20.253]     }
[18:04:20.253]     ...future.result$conditions <- ...future.conditions
[18:04:20.253]     ...future.result$finished <- base::Sys.time()
[18:04:20.253]     ...future.result
[18:04:20.253] }
[18:04:20.354] MultisessionFuture started
[18:04:20.354] - Launch lazy future ... done
[18:04:20.354] run() for ‘MultisessionFuture’ ... done
[18:04:20.355] getGlobalsAndPackages() ...
[18:04:20.355] Searching for globals...
[18:04:20.357] - globals found: [1] ‘{’
[18:04:20.357] Searching for globals ... DONE
[18:04:20.357] Resolving globals: FALSE
[18:04:20.358] 
[18:04:20.358] 
[18:04:20.359] getGlobalsAndPackages() ... DONE
[18:04:20.359] run() for ‘Future’ ...
[18:04:20.359] - state: ‘created’
[18:04:20.360] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.388] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.389]   - Field: ‘node’
[18:04:20.389]   - Field: ‘label’
[18:04:20.389]   - Field: ‘local’
[18:04:20.389]   - Field: ‘owner’
[18:04:20.390]   - Field: ‘envir’
[18:04:20.390]   - Field: ‘workers’
[18:04:20.390]   - Field: ‘packages’
[18:04:20.390]   - Field: ‘gc’
[18:04:20.390]   - Field: ‘conditions’
[18:04:20.391]   - Field: ‘persistent’
[18:04:20.391]   - Field: ‘expr’
[18:04:20.391]   - Field: ‘uuid’
[18:04:20.391]   - Field: ‘seed’
[18:04:20.391]   - Field: ‘version’
[18:04:20.392]   - Field: ‘result’
[18:04:20.392]   - Field: ‘asynchronous’
[18:04:20.392]   - Field: ‘calls’
[18:04:20.392]   - Field: ‘globals’
[18:04:20.392]   - Field: ‘stdout’
[18:04:20.393]   - Field: ‘earlySignal’
[18:04:20.393]   - Field: ‘lazy’
[18:04:20.393]   - Field: ‘state’
[18:04:20.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.394] - Launch lazy future ...
[18:04:20.394] Packages needed by the future expression (n = 0): <none>
[18:04:20.394] Packages needed by future strategies (n = 0): <none>
[18:04:20.395] {
[18:04:20.395]     {
[18:04:20.395]         {
[18:04:20.395]             ...future.startTime <- base::Sys.time()
[18:04:20.395]             {
[18:04:20.395]                 {
[18:04:20.395]                   {
[18:04:20.395]                     {
[18:04:20.395]                       base::local({
[18:04:20.395]                         has_future <- base::requireNamespace("future", 
[18:04:20.395]                           quietly = TRUE)
[18:04:20.395]                         if (has_future) {
[18:04:20.395]                           ns <- base::getNamespace("future")
[18:04:20.395]                           version <- ns[[".package"]][["version"]]
[18:04:20.395]                           if (is.null(version)) 
[18:04:20.395]                             version <- utils::packageVersion("future")
[18:04:20.395]                         }
[18:04:20.395]                         else {
[18:04:20.395]                           version <- NULL
[18:04:20.395]                         }
[18:04:20.395]                         if (!has_future || version < "1.8.0") {
[18:04:20.395]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.395]                             "", base::R.version$version.string), 
[18:04:20.395]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.395]                               "release", "version")], collapse = " "), 
[18:04:20.395]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.395]                             info)
[18:04:20.395]                           info <- base::paste(info, collapse = "; ")
[18:04:20.395]                           if (!has_future) {
[18:04:20.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.395]                               info)
[18:04:20.395]                           }
[18:04:20.395]                           else {
[18:04:20.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.395]                               info, version)
[18:04:20.395]                           }
[18:04:20.395]                           base::stop(msg)
[18:04:20.395]                         }
[18:04:20.395]                       })
[18:04:20.395]                     }
[18:04:20.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.395]                     base::options(mc.cores = 1L)
[18:04:20.395]                   }
[18:04:20.395]                   ...future.strategy.old <- future::plan("list")
[18:04:20.395]                   options(future.plan = NULL)
[18:04:20.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.395]                 }
[18:04:20.395]                 ...future.workdir <- getwd()
[18:04:20.395]             }
[18:04:20.395]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.395]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.395]         }
[18:04:20.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.395]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.395]             base::names(...future.oldOptions))
[18:04:20.395]     }
[18:04:20.395]     if (FALSE) {
[18:04:20.395]     }
[18:04:20.395]     else {
[18:04:20.395]         if (TRUE) {
[18:04:20.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.395]                 open = "w")
[18:04:20.395]         }
[18:04:20.395]         else {
[18:04:20.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.395]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.395]         }
[18:04:20.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.395]             base::sink(type = "output", split = FALSE)
[18:04:20.395]             base::close(...future.stdout)
[18:04:20.395]         }, add = TRUE)
[18:04:20.395]     }
[18:04:20.395]     ...future.frame <- base::sys.nframe()
[18:04:20.395]     ...future.conditions <- base::list()
[18:04:20.395]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.395]     if (FALSE) {
[18:04:20.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.395]     }
[18:04:20.395]     ...future.result <- base::tryCatch({
[18:04:20.395]         base::withCallingHandlers({
[18:04:20.395]             ...future.value <- base::withVisible(base::local({
[18:04:20.395]                 ...future.makeSendCondition <- base::local({
[18:04:20.395]                   sendCondition <- NULL
[18:04:20.395]                   function(frame = 1L) {
[18:04:20.395]                     if (is.function(sendCondition)) 
[18:04:20.395]                       return(sendCondition)
[18:04:20.395]                     ns <- getNamespace("parallel")
[18:04:20.395]                     if (exists("sendData", mode = "function", 
[18:04:20.395]                       envir = ns)) {
[18:04:20.395]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.395]                         envir = ns)
[18:04:20.395]                       envir <- sys.frame(frame)
[18:04:20.395]                       master <- NULL
[18:04:20.395]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.395]                         !identical(envir, emptyenv())) {
[18:04:20.395]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.395]                           inherits = FALSE)) {
[18:04:20.395]                           master <- get("master", mode = "list", 
[18:04:20.395]                             envir = envir, inherits = FALSE)
[18:04:20.395]                           if (inherits(master, c("SOCKnode", 
[18:04:20.395]                             "SOCK0node"))) {
[18:04:20.395]                             sendCondition <<- function(cond) {
[18:04:20.395]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.395]                                 success = TRUE)
[18:04:20.395]                               parallel_sendData(master, data)
[18:04:20.395]                             }
[18:04:20.395]                             return(sendCondition)
[18:04:20.395]                           }
[18:04:20.395]                         }
[18:04:20.395]                         frame <- frame + 1L
[18:04:20.395]                         envir <- sys.frame(frame)
[18:04:20.395]                       }
[18:04:20.395]                     }
[18:04:20.395]                     sendCondition <<- function(cond) NULL
[18:04:20.395]                   }
[18:04:20.395]                 })
[18:04:20.395]                 withCallingHandlers({
[18:04:20.395]                   {
[18:04:20.395]                     4
[18:04:20.395]                   }
[18:04:20.395]                 }, immediateCondition = function(cond) {
[18:04:20.395]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.395]                   sendCondition(cond)
[18:04:20.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.395]                   {
[18:04:20.395]                     inherits <- base::inherits
[18:04:20.395]                     invokeRestart <- base::invokeRestart
[18:04:20.395]                     is.null <- base::is.null
[18:04:20.395]                     muffled <- FALSE
[18:04:20.395]                     if (inherits(cond, "message")) {
[18:04:20.395]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.395]                       if (muffled) 
[18:04:20.395]                         invokeRestart("muffleMessage")
[18:04:20.395]                     }
[18:04:20.395]                     else if (inherits(cond, "warning")) {
[18:04:20.395]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.395]                       if (muffled) 
[18:04:20.395]                         invokeRestart("muffleWarning")
[18:04:20.395]                     }
[18:04:20.395]                     else if (inherits(cond, "condition")) {
[18:04:20.395]                       if (!is.null(pattern)) {
[18:04:20.395]                         computeRestarts <- base::computeRestarts
[18:04:20.395]                         grepl <- base::grepl
[18:04:20.395]                         restarts <- computeRestarts(cond)
[18:04:20.395]                         for (restart in restarts) {
[18:04:20.395]                           name <- restart$name
[18:04:20.395]                           if (is.null(name)) 
[18:04:20.395]                             next
[18:04:20.395]                           if (!grepl(pattern, name)) 
[18:04:20.395]                             next
[18:04:20.395]                           invokeRestart(restart)
[18:04:20.395]                           muffled <- TRUE
[18:04:20.395]                           break
[18:04:20.395]                         }
[18:04:20.395]                       }
[18:04:20.395]                     }
[18:04:20.395]                     invisible(muffled)
[18:04:20.395]                   }
[18:04:20.395]                   muffleCondition(cond)
[18:04:20.395]                 })
[18:04:20.395]             }))
[18:04:20.395]             future::FutureResult(value = ...future.value$value, 
[18:04:20.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.395]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.395]                     ...future.globalenv.names))
[18:04:20.395]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.395]         }, condition = base::local({
[18:04:20.395]             c <- base::c
[18:04:20.395]             inherits <- base::inherits
[18:04:20.395]             invokeRestart <- base::invokeRestart
[18:04:20.395]             length <- base::length
[18:04:20.395]             list <- base::list
[18:04:20.395]             seq.int <- base::seq.int
[18:04:20.395]             signalCondition <- base::signalCondition
[18:04:20.395]             sys.calls <- base::sys.calls
[18:04:20.395]             `[[` <- base::`[[`
[18:04:20.395]             `+` <- base::`+`
[18:04:20.395]             `<<-` <- base::`<<-`
[18:04:20.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.395]                   3L)]
[18:04:20.395]             }
[18:04:20.395]             function(cond) {
[18:04:20.395]                 is_error <- inherits(cond, "error")
[18:04:20.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.395]                   NULL)
[18:04:20.395]                 if (is_error) {
[18:04:20.395]                   sessionInformation <- function() {
[18:04:20.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.395]                       search = base::search(), system = base::Sys.info())
[18:04:20.395]                   }
[18:04:20.395]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.395]                     cond$call), session = sessionInformation(), 
[18:04:20.395]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.395]                   signalCondition(cond)
[18:04:20.395]                 }
[18:04:20.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.395]                 "immediateCondition"))) {
[18:04:20.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.395]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.395]                   if (TRUE && !signal) {
[18:04:20.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.395]                     {
[18:04:20.395]                       inherits <- base::inherits
[18:04:20.395]                       invokeRestart <- base::invokeRestart
[18:04:20.395]                       is.null <- base::is.null
[18:04:20.395]                       muffled <- FALSE
[18:04:20.395]                       if (inherits(cond, "message")) {
[18:04:20.395]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.395]                         if (muffled) 
[18:04:20.395]                           invokeRestart("muffleMessage")
[18:04:20.395]                       }
[18:04:20.395]                       else if (inherits(cond, "warning")) {
[18:04:20.395]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.395]                         if (muffled) 
[18:04:20.395]                           invokeRestart("muffleWarning")
[18:04:20.395]                       }
[18:04:20.395]                       else if (inherits(cond, "condition")) {
[18:04:20.395]                         if (!is.null(pattern)) {
[18:04:20.395]                           computeRestarts <- base::computeRestarts
[18:04:20.395]                           grepl <- base::grepl
[18:04:20.395]                           restarts <- computeRestarts(cond)
[18:04:20.395]                           for (restart in restarts) {
[18:04:20.395]                             name <- restart$name
[18:04:20.395]                             if (is.null(name)) 
[18:04:20.395]                               next
[18:04:20.395]                             if (!grepl(pattern, name)) 
[18:04:20.395]                               next
[18:04:20.395]                             invokeRestart(restart)
[18:04:20.395]                             muffled <- TRUE
[18:04:20.395]                             break
[18:04:20.395]                           }
[18:04:20.395]                         }
[18:04:20.395]                       }
[18:04:20.395]                       invisible(muffled)
[18:04:20.395]                     }
[18:04:20.395]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.395]                   }
[18:04:20.395]                 }
[18:04:20.395]                 else {
[18:04:20.395]                   if (TRUE) {
[18:04:20.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.395]                     {
[18:04:20.395]                       inherits <- base::inherits
[18:04:20.395]                       invokeRestart <- base::invokeRestart
[18:04:20.395]                       is.null <- base::is.null
[18:04:20.395]                       muffled <- FALSE
[18:04:20.395]                       if (inherits(cond, "message")) {
[18:04:20.395]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.395]                         if (muffled) 
[18:04:20.395]                           invokeRestart("muffleMessage")
[18:04:20.395]                       }
[18:04:20.395]                       else if (inherits(cond, "warning")) {
[18:04:20.395]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.395]                         if (muffled) 
[18:04:20.395]                           invokeRestart("muffleWarning")
[18:04:20.395]                       }
[18:04:20.395]                       else if (inherits(cond, "condition")) {
[18:04:20.395]                         if (!is.null(pattern)) {
[18:04:20.395]                           computeRestarts <- base::computeRestarts
[18:04:20.395]                           grepl <- base::grepl
[18:04:20.395]                           restarts <- computeRestarts(cond)
[18:04:20.395]                           for (restart in restarts) {
[18:04:20.395]                             name <- restart$name
[18:04:20.395]                             if (is.null(name)) 
[18:04:20.395]                               next
[18:04:20.395]                             if (!grepl(pattern, name)) 
[18:04:20.395]                               next
[18:04:20.395]                             invokeRestart(restart)
[18:04:20.395]                             muffled <- TRUE
[18:04:20.395]                             break
[18:04:20.395]                           }
[18:04:20.395]                         }
[18:04:20.395]                       }
[18:04:20.395]                       invisible(muffled)
[18:04:20.395]                     }
[18:04:20.395]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.395]                   }
[18:04:20.395]                 }
[18:04:20.395]             }
[18:04:20.395]         }))
[18:04:20.395]     }, error = function(ex) {
[18:04:20.395]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.395]                 ...future.rng), started = ...future.startTime, 
[18:04:20.395]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.395]             version = "1.8"), class = "FutureResult")
[18:04:20.395]     }, finally = {
[18:04:20.395]         if (!identical(...future.workdir, getwd())) 
[18:04:20.395]             setwd(...future.workdir)
[18:04:20.395]         {
[18:04:20.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.395]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.395]             }
[18:04:20.395]             base::options(...future.oldOptions)
[18:04:20.395]             if (.Platform$OS.type == "windows") {
[18:04:20.395]                 old_names <- names(...future.oldEnvVars)
[18:04:20.395]                 envs <- base::Sys.getenv()
[18:04:20.395]                 names <- names(envs)
[18:04:20.395]                 common <- intersect(names, old_names)
[18:04:20.395]                 added <- setdiff(names, old_names)
[18:04:20.395]                 removed <- setdiff(old_names, names)
[18:04:20.395]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.395]                   envs[common]]
[18:04:20.395]                 NAMES <- toupper(changed)
[18:04:20.395]                 args <- list()
[18:04:20.395]                 for (kk in seq_along(NAMES)) {
[18:04:20.395]                   name <- changed[[kk]]
[18:04:20.395]                   NAME <- NAMES[[kk]]
[18:04:20.395]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.395]                     next
[18:04:20.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.395]                 }
[18:04:20.395]                 NAMES <- toupper(added)
[18:04:20.395]                 for (kk in seq_along(NAMES)) {
[18:04:20.395]                   name <- added[[kk]]
[18:04:20.395]                   NAME <- NAMES[[kk]]
[18:04:20.395]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.395]                     next
[18:04:20.395]                   args[[name]] <- ""
[18:04:20.395]                 }
[18:04:20.395]                 NAMES <- toupper(removed)
[18:04:20.395]                 for (kk in seq_along(NAMES)) {
[18:04:20.395]                   name <- removed[[kk]]
[18:04:20.395]                   NAME <- NAMES[[kk]]
[18:04:20.395]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.395]                     next
[18:04:20.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.395]                 }
[18:04:20.395]                 if (length(args) > 0) 
[18:04:20.395]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.395]             }
[18:04:20.395]             else {
[18:04:20.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.395]             }
[18:04:20.395]             {
[18:04:20.395]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.395]                   0L) {
[18:04:20.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.395]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.395]                   base::options(opts)
[18:04:20.395]                 }
[18:04:20.395]                 {
[18:04:20.395]                   {
[18:04:20.395]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.395]                     NULL
[18:04:20.395]                   }
[18:04:20.395]                   options(future.plan = NULL)
[18:04:20.395]                   if (is.na(NA_character_)) 
[18:04:20.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.395]                     .init = FALSE)
[18:04:20.395]                 }
[18:04:20.395]             }
[18:04:20.395]         }
[18:04:20.395]     })
[18:04:20.395]     if (TRUE) {
[18:04:20.395]         base::sink(type = "output", split = FALSE)
[18:04:20.395]         if (TRUE) {
[18:04:20.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.395]         }
[18:04:20.395]         else {
[18:04:20.395]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.395]         }
[18:04:20.395]         base::close(...future.stdout)
[18:04:20.395]         ...future.stdout <- NULL
[18:04:20.395]     }
[18:04:20.395]     ...future.result$conditions <- ...future.conditions
[18:04:20.395]     ...future.result$finished <- base::Sys.time()
[18:04:20.395]     ...future.result
[18:04:20.395] }
[18:04:20.400] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:20.413] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.413] - Validating connection of MultisessionFuture
[18:04:20.413] - received message: FutureResult
[18:04:20.414] - Received FutureResult
[18:04:20.416] - Erased future from FutureRegistry
[18:04:20.416] result() for ClusterFuture ...
[18:04:20.416] - result already collected: FutureResult
[18:04:20.417] result() for ClusterFuture ... done
[18:04:20.417] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:20.417] result() for ClusterFuture ...
[18:04:20.417] - result already collected: FutureResult
[18:04:20.417] result() for ClusterFuture ... done
[18:04:20.418] result() for ClusterFuture ...
[18:04:20.420] - result already collected: FutureResult
[18:04:20.420] result() for ClusterFuture ... done
[18:04:20.422] MultisessionFuture started
[18:04:20.422] - Launch lazy future ... done
[18:04:20.423] run() for ‘MultisessionFuture’ ... done
<environment: 0x5e3c2b591370> 
<environment: 0x5e3c2c343ee8> 
[18:04:20.443] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.443] - Validating connection of MultisessionFuture
[18:04:20.443] - received message: FutureResult
[18:04:20.444] - Received FutureResult
[18:04:20.444] - Erased future from FutureRegistry
[18:04:20.444] result() for ClusterFuture ...
[18:04:20.444] - result already collected: FutureResult
[18:04:20.444] result() for ClusterFuture ... done
[18:04:20.445] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:20.446] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.446] - Validating connection of MultisessionFuture
[18:04:20.446] - received message: FutureResult
[18:04:20.447] - Received FutureResult
[18:04:20.447] - Erased future from FutureRegistry
[18:04:20.447] result() for ClusterFuture ...
[18:04:20.447] - result already collected: FutureResult
[18:04:20.447] result() for ClusterFuture ... done
[18:04:20.447] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:20.450] resolve() on environment ...
[18:04:20.450]  recursive: 0
[18:04:20.451]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:20.451] signalConditionsASAP(numeric, pos=1) ...
[18:04:20.452] - nx: 4
[18:04:20.452] - relay: TRUE
[18:04:20.452] - stdout: TRUE
[18:04:20.452] - signal: TRUE
[18:04:20.452] - resignal: FALSE
[18:04:20.452] - force: TRUE
[18:04:20.453] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.453] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.453]  - until=2
[18:04:20.453]  - relaying element #2
[18:04:20.453] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:20.454] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.454] signalConditionsASAP(NULL, pos=1) ... done
[18:04:20.454]  length: 3 (resolved future 1)
[18:04:20.454] Future #2
[18:04:20.454] result() for ClusterFuture ...
[18:04:20.455] - result already collected: FutureResult
[18:04:20.455] result() for ClusterFuture ... done
[18:04:20.455] result() for ClusterFuture ...
[18:04:20.455] - result already collected: FutureResult
[18:04:20.455] result() for ClusterFuture ... done
[18:04:20.456] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:20.456] - nx: 4
[18:04:20.456] - relay: TRUE
[18:04:20.456] - stdout: TRUE
[18:04:20.456] - signal: TRUE
[18:04:20.457] - resignal: FALSE
[18:04:20.457] - force: TRUE
[18:04:20.457] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:20.457] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.457]  - until=2
[18:04:20.457]  - relaying element #2
[18:04:20.458] result() for ClusterFuture ...
[18:04:20.458] - result already collected: FutureResult
[18:04:20.458] result() for ClusterFuture ... done
[18:04:20.458] result() for ClusterFuture ...
[18:04:20.458] - result already collected: FutureResult
[18:04:20.459] result() for ClusterFuture ... done
[18:04:20.459] result() for ClusterFuture ...
[18:04:20.459] - result already collected: FutureResult
[18:04:20.459] result() for ClusterFuture ... done
[18:04:20.459] result() for ClusterFuture ...
[18:04:20.460] - result already collected: FutureResult
[18:04:20.460] result() for ClusterFuture ... done
[18:04:20.460] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:20.460] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:20.460] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:20.461]  length: 2 (resolved future 2)
[18:04:20.461] Future #3
[18:04:20.461] result() for ClusterFuture ...
[18:04:20.461] - result already collected: FutureResult
[18:04:20.461] result() for ClusterFuture ... done
[18:04:20.461] result() for ClusterFuture ...
[18:04:20.462] - result already collected: FutureResult
[18:04:20.462] result() for ClusterFuture ... done
[18:04:20.462] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:20.462] - nx: 4
[18:04:20.462] - relay: TRUE
[18:04:20.463] - stdout: TRUE
[18:04:20.463] - signal: TRUE
[18:04:20.463] - resignal: FALSE
[18:04:20.463] - force: TRUE
[18:04:20.463] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:20.463] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:20.464]  - until=3
[18:04:20.464]  - relaying element #3
[18:04:20.464] result() for ClusterFuture ...
[18:04:20.464] - result already collected: FutureResult
[18:04:20.464] result() for ClusterFuture ... done
[18:04:20.465] result() for ClusterFuture ...
[18:04:20.465] - result already collected: FutureResult
[18:04:20.465] result() for ClusterFuture ... done
[18:04:20.465] result() for ClusterFuture ...
[18:04:20.465] - result already collected: FutureResult
[18:04:20.466] result() for ClusterFuture ... done
[18:04:20.466] result() for ClusterFuture ...
[18:04:20.466] - result already collected: FutureResult
[18:04:20.466] result() for ClusterFuture ... done
[18:04:20.466] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:20.466] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:20.467] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:20.467]  length: 1 (resolved future 3)
[18:04:20.467] Future #4
[18:04:20.467] result() for ClusterFuture ...
[18:04:20.467] - result already collected: FutureResult
[18:04:20.468] result() for ClusterFuture ... done
[18:04:20.468] result() for ClusterFuture ...
[18:04:20.468] - result already collected: FutureResult
[18:04:20.468] result() for ClusterFuture ... done
[18:04:20.468] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:20.469] - nx: 4
[18:04:20.469] - relay: TRUE
[18:04:20.469] - stdout: TRUE
[18:04:20.469] - signal: TRUE
[18:04:20.469] - resignal: FALSE
[18:04:20.469] - force: TRUE
[18:04:20.470] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:20.470] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:20.470]  - until=4
[18:04:20.470]  - relaying element #4
[18:04:20.470] result() for ClusterFuture ...
[18:04:20.471] - result already collected: FutureResult
[18:04:20.471] result() for ClusterFuture ... done
[18:04:20.471] result() for ClusterFuture ...
[18:04:20.471] - result already collected: FutureResult
[18:04:20.471] result() for ClusterFuture ... done
[18:04:20.472] result() for ClusterFuture ...
[18:04:20.472] - result already collected: FutureResult
[18:04:20.472] result() for ClusterFuture ... done
[18:04:20.472] result() for ClusterFuture ...
[18:04:20.472] - result already collected: FutureResult
[18:04:20.472] result() for ClusterFuture ... done
[18:04:20.473] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:20.473] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:20.473] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:20.473]  length: 0 (resolved future 4)
[18:04:20.473] Relaying remaining futures
[18:04:20.474] signalConditionsASAP(NULL, pos=0) ...
[18:04:20.474] - nx: 4
[18:04:20.474] - relay: TRUE
[18:04:20.474] - stdout: TRUE
[18:04:20.474] - signal: TRUE
[18:04:20.474] - resignal: FALSE
[18:04:20.475] - force: TRUE
[18:04:20.475] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:20.475] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:20.475] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:20.475] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:20.476] signalConditionsASAP(NULL, pos=0) ... done
[18:04:20.476] resolve() on environment ... DONE
[18:04:20.476] result() for ClusterFuture ...
[18:04:20.476] - result already collected: FutureResult
[18:04:20.476] result() for ClusterFuture ... done
[18:04:20.477] result() for ClusterFuture ...
[18:04:20.477] - result already collected: FutureResult
[18:04:20.477] result() for ClusterFuture ... done
[18:04:20.477] result() for ClusterFuture ...
[18:04:20.477] - result already collected: FutureResult
[18:04:20.478] result() for ClusterFuture ... done
[18:04:20.478] result() for ClusterFuture ...
[18:04:20.478] - result already collected: FutureResult
[18:04:20.478] result() for ClusterFuture ... done
[18:04:20.478] result() for ClusterFuture ...
[18:04:20.478] - result already collected: FutureResult
[18:04:20.479] result() for ClusterFuture ... done
[18:04:20.479] result() for ClusterFuture ...
[18:04:20.479] - result already collected: FutureResult
[18:04:20.479] result() for ClusterFuture ... done
<environment: 0x5e3c2c4f6be0> 
Dimensions: c(1, 6)
[18:04:20.480] getGlobalsAndPackages() ...
[18:04:20.480] Searching for globals...
[18:04:20.481] 
[18:04:20.481] Searching for globals ... DONE
[18:04:20.481] - globals: [0] <none>
[18:04:20.481] getGlobalsAndPackages() ... DONE
[18:04:20.482] run() for ‘Future’ ...
[18:04:20.482] - state: ‘created’
[18:04:20.482] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.507] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.508]   - Field: ‘node’
[18:04:20.508]   - Field: ‘label’
[18:04:20.508]   - Field: ‘local’
[18:04:20.508]   - Field: ‘owner’
[18:04:20.508]   - Field: ‘envir’
[18:04:20.509]   - Field: ‘workers’
[18:04:20.509]   - Field: ‘packages’
[18:04:20.509]   - Field: ‘gc’
[18:04:20.509]   - Field: ‘conditions’
[18:04:20.509]   - Field: ‘persistent’
[18:04:20.510]   - Field: ‘expr’
[18:04:20.510]   - Field: ‘uuid’
[18:04:20.510]   - Field: ‘seed’
[18:04:20.510]   - Field: ‘version’
[18:04:20.510]   - Field: ‘result’
[18:04:20.511]   - Field: ‘asynchronous’
[18:04:20.511]   - Field: ‘calls’
[18:04:20.511]   - Field: ‘globals’
[18:04:20.511]   - Field: ‘stdout’
[18:04:20.511]   - Field: ‘earlySignal’
[18:04:20.512]   - Field: ‘lazy’
[18:04:20.512]   - Field: ‘state’
[18:04:20.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.512] - Launch lazy future ...
[18:04:20.513] Packages needed by the future expression (n = 0): <none>
[18:04:20.513] Packages needed by future strategies (n = 0): <none>
[18:04:20.514] {
[18:04:20.514]     {
[18:04:20.514]         {
[18:04:20.514]             ...future.startTime <- base::Sys.time()
[18:04:20.514]             {
[18:04:20.514]                 {
[18:04:20.514]                   {
[18:04:20.514]                     {
[18:04:20.514]                       base::local({
[18:04:20.514]                         has_future <- base::requireNamespace("future", 
[18:04:20.514]                           quietly = TRUE)
[18:04:20.514]                         if (has_future) {
[18:04:20.514]                           ns <- base::getNamespace("future")
[18:04:20.514]                           version <- ns[[".package"]][["version"]]
[18:04:20.514]                           if (is.null(version)) 
[18:04:20.514]                             version <- utils::packageVersion("future")
[18:04:20.514]                         }
[18:04:20.514]                         else {
[18:04:20.514]                           version <- NULL
[18:04:20.514]                         }
[18:04:20.514]                         if (!has_future || version < "1.8.0") {
[18:04:20.514]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.514]                             "", base::R.version$version.string), 
[18:04:20.514]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.514]                               "release", "version")], collapse = " "), 
[18:04:20.514]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.514]                             info)
[18:04:20.514]                           info <- base::paste(info, collapse = "; ")
[18:04:20.514]                           if (!has_future) {
[18:04:20.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.514]                               info)
[18:04:20.514]                           }
[18:04:20.514]                           else {
[18:04:20.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.514]                               info, version)
[18:04:20.514]                           }
[18:04:20.514]                           base::stop(msg)
[18:04:20.514]                         }
[18:04:20.514]                       })
[18:04:20.514]                     }
[18:04:20.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.514]                     base::options(mc.cores = 1L)
[18:04:20.514]                   }
[18:04:20.514]                   ...future.strategy.old <- future::plan("list")
[18:04:20.514]                   options(future.plan = NULL)
[18:04:20.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.514]                 }
[18:04:20.514]                 ...future.workdir <- getwd()
[18:04:20.514]             }
[18:04:20.514]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.514]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.514]         }
[18:04:20.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.514]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.514]             base::names(...future.oldOptions))
[18:04:20.514]     }
[18:04:20.514]     if (FALSE) {
[18:04:20.514]     }
[18:04:20.514]     else {
[18:04:20.514]         if (TRUE) {
[18:04:20.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.514]                 open = "w")
[18:04:20.514]         }
[18:04:20.514]         else {
[18:04:20.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.514]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.514]         }
[18:04:20.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.514]             base::sink(type = "output", split = FALSE)
[18:04:20.514]             base::close(...future.stdout)
[18:04:20.514]         }, add = TRUE)
[18:04:20.514]     }
[18:04:20.514]     ...future.frame <- base::sys.nframe()
[18:04:20.514]     ...future.conditions <- base::list()
[18:04:20.514]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.514]     if (FALSE) {
[18:04:20.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.514]     }
[18:04:20.514]     ...future.result <- base::tryCatch({
[18:04:20.514]         base::withCallingHandlers({
[18:04:20.514]             ...future.value <- base::withVisible(base::local({
[18:04:20.514]                 ...future.makeSendCondition <- base::local({
[18:04:20.514]                   sendCondition <- NULL
[18:04:20.514]                   function(frame = 1L) {
[18:04:20.514]                     if (is.function(sendCondition)) 
[18:04:20.514]                       return(sendCondition)
[18:04:20.514]                     ns <- getNamespace("parallel")
[18:04:20.514]                     if (exists("sendData", mode = "function", 
[18:04:20.514]                       envir = ns)) {
[18:04:20.514]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.514]                         envir = ns)
[18:04:20.514]                       envir <- sys.frame(frame)
[18:04:20.514]                       master <- NULL
[18:04:20.514]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.514]                         !identical(envir, emptyenv())) {
[18:04:20.514]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.514]                           inherits = FALSE)) {
[18:04:20.514]                           master <- get("master", mode = "list", 
[18:04:20.514]                             envir = envir, inherits = FALSE)
[18:04:20.514]                           if (inherits(master, c("SOCKnode", 
[18:04:20.514]                             "SOCK0node"))) {
[18:04:20.514]                             sendCondition <<- function(cond) {
[18:04:20.514]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.514]                                 success = TRUE)
[18:04:20.514]                               parallel_sendData(master, data)
[18:04:20.514]                             }
[18:04:20.514]                             return(sendCondition)
[18:04:20.514]                           }
[18:04:20.514]                         }
[18:04:20.514]                         frame <- frame + 1L
[18:04:20.514]                         envir <- sys.frame(frame)
[18:04:20.514]                       }
[18:04:20.514]                     }
[18:04:20.514]                     sendCondition <<- function(cond) NULL
[18:04:20.514]                   }
[18:04:20.514]                 })
[18:04:20.514]                 withCallingHandlers({
[18:04:20.514]                   2
[18:04:20.514]                 }, immediateCondition = function(cond) {
[18:04:20.514]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.514]                   sendCondition(cond)
[18:04:20.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.514]                   {
[18:04:20.514]                     inherits <- base::inherits
[18:04:20.514]                     invokeRestart <- base::invokeRestart
[18:04:20.514]                     is.null <- base::is.null
[18:04:20.514]                     muffled <- FALSE
[18:04:20.514]                     if (inherits(cond, "message")) {
[18:04:20.514]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.514]                       if (muffled) 
[18:04:20.514]                         invokeRestart("muffleMessage")
[18:04:20.514]                     }
[18:04:20.514]                     else if (inherits(cond, "warning")) {
[18:04:20.514]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.514]                       if (muffled) 
[18:04:20.514]                         invokeRestart("muffleWarning")
[18:04:20.514]                     }
[18:04:20.514]                     else if (inherits(cond, "condition")) {
[18:04:20.514]                       if (!is.null(pattern)) {
[18:04:20.514]                         computeRestarts <- base::computeRestarts
[18:04:20.514]                         grepl <- base::grepl
[18:04:20.514]                         restarts <- computeRestarts(cond)
[18:04:20.514]                         for (restart in restarts) {
[18:04:20.514]                           name <- restart$name
[18:04:20.514]                           if (is.null(name)) 
[18:04:20.514]                             next
[18:04:20.514]                           if (!grepl(pattern, name)) 
[18:04:20.514]                             next
[18:04:20.514]                           invokeRestart(restart)
[18:04:20.514]                           muffled <- TRUE
[18:04:20.514]                           break
[18:04:20.514]                         }
[18:04:20.514]                       }
[18:04:20.514]                     }
[18:04:20.514]                     invisible(muffled)
[18:04:20.514]                   }
[18:04:20.514]                   muffleCondition(cond)
[18:04:20.514]                 })
[18:04:20.514]             }))
[18:04:20.514]             future::FutureResult(value = ...future.value$value, 
[18:04:20.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.514]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.514]                     ...future.globalenv.names))
[18:04:20.514]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.514]         }, condition = base::local({
[18:04:20.514]             c <- base::c
[18:04:20.514]             inherits <- base::inherits
[18:04:20.514]             invokeRestart <- base::invokeRestart
[18:04:20.514]             length <- base::length
[18:04:20.514]             list <- base::list
[18:04:20.514]             seq.int <- base::seq.int
[18:04:20.514]             signalCondition <- base::signalCondition
[18:04:20.514]             sys.calls <- base::sys.calls
[18:04:20.514]             `[[` <- base::`[[`
[18:04:20.514]             `+` <- base::`+`
[18:04:20.514]             `<<-` <- base::`<<-`
[18:04:20.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.514]                   3L)]
[18:04:20.514]             }
[18:04:20.514]             function(cond) {
[18:04:20.514]                 is_error <- inherits(cond, "error")
[18:04:20.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.514]                   NULL)
[18:04:20.514]                 if (is_error) {
[18:04:20.514]                   sessionInformation <- function() {
[18:04:20.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.514]                       search = base::search(), system = base::Sys.info())
[18:04:20.514]                   }
[18:04:20.514]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.514]                     cond$call), session = sessionInformation(), 
[18:04:20.514]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.514]                   signalCondition(cond)
[18:04:20.514]                 }
[18:04:20.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.514]                 "immediateCondition"))) {
[18:04:20.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.514]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.514]                   if (TRUE && !signal) {
[18:04:20.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.514]                     {
[18:04:20.514]                       inherits <- base::inherits
[18:04:20.514]                       invokeRestart <- base::invokeRestart
[18:04:20.514]                       is.null <- base::is.null
[18:04:20.514]                       muffled <- FALSE
[18:04:20.514]                       if (inherits(cond, "message")) {
[18:04:20.514]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.514]                         if (muffled) 
[18:04:20.514]                           invokeRestart("muffleMessage")
[18:04:20.514]                       }
[18:04:20.514]                       else if (inherits(cond, "warning")) {
[18:04:20.514]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.514]                         if (muffled) 
[18:04:20.514]                           invokeRestart("muffleWarning")
[18:04:20.514]                       }
[18:04:20.514]                       else if (inherits(cond, "condition")) {
[18:04:20.514]                         if (!is.null(pattern)) {
[18:04:20.514]                           computeRestarts <- base::computeRestarts
[18:04:20.514]                           grepl <- base::grepl
[18:04:20.514]                           restarts <- computeRestarts(cond)
[18:04:20.514]                           for (restart in restarts) {
[18:04:20.514]                             name <- restart$name
[18:04:20.514]                             if (is.null(name)) 
[18:04:20.514]                               next
[18:04:20.514]                             if (!grepl(pattern, name)) 
[18:04:20.514]                               next
[18:04:20.514]                             invokeRestart(restart)
[18:04:20.514]                             muffled <- TRUE
[18:04:20.514]                             break
[18:04:20.514]                           }
[18:04:20.514]                         }
[18:04:20.514]                       }
[18:04:20.514]                       invisible(muffled)
[18:04:20.514]                     }
[18:04:20.514]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.514]                   }
[18:04:20.514]                 }
[18:04:20.514]                 else {
[18:04:20.514]                   if (TRUE) {
[18:04:20.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.514]                     {
[18:04:20.514]                       inherits <- base::inherits
[18:04:20.514]                       invokeRestart <- base::invokeRestart
[18:04:20.514]                       is.null <- base::is.null
[18:04:20.514]                       muffled <- FALSE
[18:04:20.514]                       if (inherits(cond, "message")) {
[18:04:20.514]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.514]                         if (muffled) 
[18:04:20.514]                           invokeRestart("muffleMessage")
[18:04:20.514]                       }
[18:04:20.514]                       else if (inherits(cond, "warning")) {
[18:04:20.514]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.514]                         if (muffled) 
[18:04:20.514]                           invokeRestart("muffleWarning")
[18:04:20.514]                       }
[18:04:20.514]                       else if (inherits(cond, "condition")) {
[18:04:20.514]                         if (!is.null(pattern)) {
[18:04:20.514]                           computeRestarts <- base::computeRestarts
[18:04:20.514]                           grepl <- base::grepl
[18:04:20.514]                           restarts <- computeRestarts(cond)
[18:04:20.514]                           for (restart in restarts) {
[18:04:20.514]                             name <- restart$name
[18:04:20.514]                             if (is.null(name)) 
[18:04:20.514]                               next
[18:04:20.514]                             if (!grepl(pattern, name)) 
[18:04:20.514]                               next
[18:04:20.514]                             invokeRestart(restart)
[18:04:20.514]                             muffled <- TRUE
[18:04:20.514]                             break
[18:04:20.514]                           }
[18:04:20.514]                         }
[18:04:20.514]                       }
[18:04:20.514]                       invisible(muffled)
[18:04:20.514]                     }
[18:04:20.514]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.514]                   }
[18:04:20.514]                 }
[18:04:20.514]             }
[18:04:20.514]         }))
[18:04:20.514]     }, error = function(ex) {
[18:04:20.514]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.514]                 ...future.rng), started = ...future.startTime, 
[18:04:20.514]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.514]             version = "1.8"), class = "FutureResult")
[18:04:20.514]     }, finally = {
[18:04:20.514]         if (!identical(...future.workdir, getwd())) 
[18:04:20.514]             setwd(...future.workdir)
[18:04:20.514]         {
[18:04:20.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.514]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.514]             }
[18:04:20.514]             base::options(...future.oldOptions)
[18:04:20.514]             if (.Platform$OS.type == "windows") {
[18:04:20.514]                 old_names <- names(...future.oldEnvVars)
[18:04:20.514]                 envs <- base::Sys.getenv()
[18:04:20.514]                 names <- names(envs)
[18:04:20.514]                 common <- intersect(names, old_names)
[18:04:20.514]                 added <- setdiff(names, old_names)
[18:04:20.514]                 removed <- setdiff(old_names, names)
[18:04:20.514]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.514]                   envs[common]]
[18:04:20.514]                 NAMES <- toupper(changed)
[18:04:20.514]                 args <- list()
[18:04:20.514]                 for (kk in seq_along(NAMES)) {
[18:04:20.514]                   name <- changed[[kk]]
[18:04:20.514]                   NAME <- NAMES[[kk]]
[18:04:20.514]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.514]                     next
[18:04:20.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.514]                 }
[18:04:20.514]                 NAMES <- toupper(added)
[18:04:20.514]                 for (kk in seq_along(NAMES)) {
[18:04:20.514]                   name <- added[[kk]]
[18:04:20.514]                   NAME <- NAMES[[kk]]
[18:04:20.514]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.514]                     next
[18:04:20.514]                   args[[name]] <- ""
[18:04:20.514]                 }
[18:04:20.514]                 NAMES <- toupper(removed)
[18:04:20.514]                 for (kk in seq_along(NAMES)) {
[18:04:20.514]                   name <- removed[[kk]]
[18:04:20.514]                   NAME <- NAMES[[kk]]
[18:04:20.514]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.514]                     next
[18:04:20.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.514]                 }
[18:04:20.514]                 if (length(args) > 0) 
[18:04:20.514]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.514]             }
[18:04:20.514]             else {
[18:04:20.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.514]             }
[18:04:20.514]             {
[18:04:20.514]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.514]                   0L) {
[18:04:20.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.514]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.514]                   base::options(opts)
[18:04:20.514]                 }
[18:04:20.514]                 {
[18:04:20.514]                   {
[18:04:20.514]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.514]                     NULL
[18:04:20.514]                   }
[18:04:20.514]                   options(future.plan = NULL)
[18:04:20.514]                   if (is.na(NA_character_)) 
[18:04:20.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.514]                     .init = FALSE)
[18:04:20.514]                 }
[18:04:20.514]             }
[18:04:20.514]         }
[18:04:20.514]     })
[18:04:20.514]     if (TRUE) {
[18:04:20.514]         base::sink(type = "output", split = FALSE)
[18:04:20.514]         if (TRUE) {
[18:04:20.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.514]         }
[18:04:20.514]         else {
[18:04:20.514]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.514]         }
[18:04:20.514]         base::close(...future.stdout)
[18:04:20.514]         ...future.stdout <- NULL
[18:04:20.514]     }
[18:04:20.514]     ...future.result$conditions <- ...future.conditions
[18:04:20.514]     ...future.result$finished <- base::Sys.time()
[18:04:20.514]     ...future.result
[18:04:20.514] }
[18:04:20.520] MultisessionFuture started
[18:04:20.520] - Launch lazy future ... done
[18:04:20.520] run() for ‘MultisessionFuture’ ... done
[18:04:20.521] getGlobalsAndPackages() ...
[18:04:20.521] Searching for globals...
[18:04:20.522] 
[18:04:20.522] Searching for globals ... DONE
[18:04:20.522] - globals: [0] <none>
[18:04:20.522] getGlobalsAndPackages() ... DONE
[18:04:20.523] run() for ‘Future’ ...
[18:04:20.523] - state: ‘created’
[18:04:20.523] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.549]   - Field: ‘node’
[18:04:20.549]   - Field: ‘label’
[18:04:20.549]   - Field: ‘local’
[18:04:20.549]   - Field: ‘owner’
[18:04:20.549]   - Field: ‘envir’
[18:04:20.550]   - Field: ‘workers’
[18:04:20.550]   - Field: ‘packages’
[18:04:20.550]   - Field: ‘gc’
[18:04:20.550]   - Field: ‘conditions’
[18:04:20.550]   - Field: ‘persistent’
[18:04:20.551]   - Field: ‘expr’
[18:04:20.551]   - Field: ‘uuid’
[18:04:20.551]   - Field: ‘seed’
[18:04:20.552]   - Field: ‘version’
[18:04:20.552]   - Field: ‘result’
[18:04:20.552]   - Field: ‘asynchronous’
[18:04:20.552]   - Field: ‘calls’
[18:04:20.552]   - Field: ‘globals’
[18:04:20.553]   - Field: ‘stdout’
[18:04:20.553]   - Field: ‘earlySignal’
[18:04:20.553]   - Field: ‘lazy’
[18:04:20.553]   - Field: ‘state’
[18:04:20.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.554] - Launch lazy future ...
[18:04:20.554] Packages needed by the future expression (n = 0): <none>
[18:04:20.554] Packages needed by future strategies (n = 0): <none>
[18:04:20.562] {
[18:04:20.562]     {
[18:04:20.562]         {
[18:04:20.562]             ...future.startTime <- base::Sys.time()
[18:04:20.562]             {
[18:04:20.562]                 {
[18:04:20.562]                   {
[18:04:20.562]                     {
[18:04:20.562]                       base::local({
[18:04:20.562]                         has_future <- base::requireNamespace("future", 
[18:04:20.562]                           quietly = TRUE)
[18:04:20.562]                         if (has_future) {
[18:04:20.562]                           ns <- base::getNamespace("future")
[18:04:20.562]                           version <- ns[[".package"]][["version"]]
[18:04:20.562]                           if (is.null(version)) 
[18:04:20.562]                             version <- utils::packageVersion("future")
[18:04:20.562]                         }
[18:04:20.562]                         else {
[18:04:20.562]                           version <- NULL
[18:04:20.562]                         }
[18:04:20.562]                         if (!has_future || version < "1.8.0") {
[18:04:20.562]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.562]                             "", base::R.version$version.string), 
[18:04:20.562]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.562]                               "release", "version")], collapse = " "), 
[18:04:20.562]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.562]                             info)
[18:04:20.562]                           info <- base::paste(info, collapse = "; ")
[18:04:20.562]                           if (!has_future) {
[18:04:20.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.562]                               info)
[18:04:20.562]                           }
[18:04:20.562]                           else {
[18:04:20.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.562]                               info, version)
[18:04:20.562]                           }
[18:04:20.562]                           base::stop(msg)
[18:04:20.562]                         }
[18:04:20.562]                       })
[18:04:20.562]                     }
[18:04:20.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.562]                     base::options(mc.cores = 1L)
[18:04:20.562]                   }
[18:04:20.562]                   ...future.strategy.old <- future::plan("list")
[18:04:20.562]                   options(future.plan = NULL)
[18:04:20.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.562]                 }
[18:04:20.562]                 ...future.workdir <- getwd()
[18:04:20.562]             }
[18:04:20.562]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.562]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.562]         }
[18:04:20.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.562]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.562]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.562]             base::names(...future.oldOptions))
[18:04:20.562]     }
[18:04:20.562]     if (FALSE) {
[18:04:20.562]     }
[18:04:20.562]     else {
[18:04:20.562]         if (TRUE) {
[18:04:20.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.562]                 open = "w")
[18:04:20.562]         }
[18:04:20.562]         else {
[18:04:20.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.562]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.562]         }
[18:04:20.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.562]             base::sink(type = "output", split = FALSE)
[18:04:20.562]             base::close(...future.stdout)
[18:04:20.562]         }, add = TRUE)
[18:04:20.562]     }
[18:04:20.562]     ...future.frame <- base::sys.nframe()
[18:04:20.562]     ...future.conditions <- base::list()
[18:04:20.562]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.562]     if (FALSE) {
[18:04:20.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.562]     }
[18:04:20.562]     ...future.result <- base::tryCatch({
[18:04:20.562]         base::withCallingHandlers({
[18:04:20.562]             ...future.value <- base::withVisible(base::local({
[18:04:20.562]                 ...future.makeSendCondition <- base::local({
[18:04:20.562]                   sendCondition <- NULL
[18:04:20.562]                   function(frame = 1L) {
[18:04:20.562]                     if (is.function(sendCondition)) 
[18:04:20.562]                       return(sendCondition)
[18:04:20.562]                     ns <- getNamespace("parallel")
[18:04:20.562]                     if (exists("sendData", mode = "function", 
[18:04:20.562]                       envir = ns)) {
[18:04:20.562]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.562]                         envir = ns)
[18:04:20.562]                       envir <- sys.frame(frame)
[18:04:20.562]                       master <- NULL
[18:04:20.562]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.562]                         !identical(envir, emptyenv())) {
[18:04:20.562]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.562]                           inherits = FALSE)) {
[18:04:20.562]                           master <- get("master", mode = "list", 
[18:04:20.562]                             envir = envir, inherits = FALSE)
[18:04:20.562]                           if (inherits(master, c("SOCKnode", 
[18:04:20.562]                             "SOCK0node"))) {
[18:04:20.562]                             sendCondition <<- function(cond) {
[18:04:20.562]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.562]                                 success = TRUE)
[18:04:20.562]                               parallel_sendData(master, data)
[18:04:20.562]                             }
[18:04:20.562]                             return(sendCondition)
[18:04:20.562]                           }
[18:04:20.562]                         }
[18:04:20.562]                         frame <- frame + 1L
[18:04:20.562]                         envir <- sys.frame(frame)
[18:04:20.562]                       }
[18:04:20.562]                     }
[18:04:20.562]                     sendCondition <<- function(cond) NULL
[18:04:20.562]                   }
[18:04:20.562]                 })
[18:04:20.562]                 withCallingHandlers({
[18:04:20.562]                   NULL
[18:04:20.562]                 }, immediateCondition = function(cond) {
[18:04:20.562]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.562]                   sendCondition(cond)
[18:04:20.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.562]                   {
[18:04:20.562]                     inherits <- base::inherits
[18:04:20.562]                     invokeRestart <- base::invokeRestart
[18:04:20.562]                     is.null <- base::is.null
[18:04:20.562]                     muffled <- FALSE
[18:04:20.562]                     if (inherits(cond, "message")) {
[18:04:20.562]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.562]                       if (muffled) 
[18:04:20.562]                         invokeRestart("muffleMessage")
[18:04:20.562]                     }
[18:04:20.562]                     else if (inherits(cond, "warning")) {
[18:04:20.562]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.562]                       if (muffled) 
[18:04:20.562]                         invokeRestart("muffleWarning")
[18:04:20.562]                     }
[18:04:20.562]                     else if (inherits(cond, "condition")) {
[18:04:20.562]                       if (!is.null(pattern)) {
[18:04:20.562]                         computeRestarts <- base::computeRestarts
[18:04:20.562]                         grepl <- base::grepl
[18:04:20.562]                         restarts <- computeRestarts(cond)
[18:04:20.562]                         for (restart in restarts) {
[18:04:20.562]                           name <- restart$name
[18:04:20.562]                           if (is.null(name)) 
[18:04:20.562]                             next
[18:04:20.562]                           if (!grepl(pattern, name)) 
[18:04:20.562]                             next
[18:04:20.562]                           invokeRestart(restart)
[18:04:20.562]                           muffled <- TRUE
[18:04:20.562]                           break
[18:04:20.562]                         }
[18:04:20.562]                       }
[18:04:20.562]                     }
[18:04:20.562]                     invisible(muffled)
[18:04:20.562]                   }
[18:04:20.562]                   muffleCondition(cond)
[18:04:20.562]                 })
[18:04:20.562]             }))
[18:04:20.562]             future::FutureResult(value = ...future.value$value, 
[18:04:20.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.562]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.562]                     ...future.globalenv.names))
[18:04:20.562]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.562]         }, condition = base::local({
[18:04:20.562]             c <- base::c
[18:04:20.562]             inherits <- base::inherits
[18:04:20.562]             invokeRestart <- base::invokeRestart
[18:04:20.562]             length <- base::length
[18:04:20.562]             list <- base::list
[18:04:20.562]             seq.int <- base::seq.int
[18:04:20.562]             signalCondition <- base::signalCondition
[18:04:20.562]             sys.calls <- base::sys.calls
[18:04:20.562]             `[[` <- base::`[[`
[18:04:20.562]             `+` <- base::`+`
[18:04:20.562]             `<<-` <- base::`<<-`
[18:04:20.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.562]                   3L)]
[18:04:20.562]             }
[18:04:20.562]             function(cond) {
[18:04:20.562]                 is_error <- inherits(cond, "error")
[18:04:20.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.562]                   NULL)
[18:04:20.562]                 if (is_error) {
[18:04:20.562]                   sessionInformation <- function() {
[18:04:20.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.562]                       search = base::search(), system = base::Sys.info())
[18:04:20.562]                   }
[18:04:20.562]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.562]                     cond$call), session = sessionInformation(), 
[18:04:20.562]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.562]                   signalCondition(cond)
[18:04:20.562]                 }
[18:04:20.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.562]                 "immediateCondition"))) {
[18:04:20.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.562]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.562]                   if (TRUE && !signal) {
[18:04:20.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.562]                     {
[18:04:20.562]                       inherits <- base::inherits
[18:04:20.562]                       invokeRestart <- base::invokeRestart
[18:04:20.562]                       is.null <- base::is.null
[18:04:20.562]                       muffled <- FALSE
[18:04:20.562]                       if (inherits(cond, "message")) {
[18:04:20.562]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.562]                         if (muffled) 
[18:04:20.562]                           invokeRestart("muffleMessage")
[18:04:20.562]                       }
[18:04:20.562]                       else if (inherits(cond, "warning")) {
[18:04:20.562]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.562]                         if (muffled) 
[18:04:20.562]                           invokeRestart("muffleWarning")
[18:04:20.562]                       }
[18:04:20.562]                       else if (inherits(cond, "condition")) {
[18:04:20.562]                         if (!is.null(pattern)) {
[18:04:20.562]                           computeRestarts <- base::computeRestarts
[18:04:20.562]                           grepl <- base::grepl
[18:04:20.562]                           restarts <- computeRestarts(cond)
[18:04:20.562]                           for (restart in restarts) {
[18:04:20.562]                             name <- restart$name
[18:04:20.562]                             if (is.null(name)) 
[18:04:20.562]                               next
[18:04:20.562]                             if (!grepl(pattern, name)) 
[18:04:20.562]                               next
[18:04:20.562]                             invokeRestart(restart)
[18:04:20.562]                             muffled <- TRUE
[18:04:20.562]                             break
[18:04:20.562]                           }
[18:04:20.562]                         }
[18:04:20.562]                       }
[18:04:20.562]                       invisible(muffled)
[18:04:20.562]                     }
[18:04:20.562]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.562]                   }
[18:04:20.562]                 }
[18:04:20.562]                 else {
[18:04:20.562]                   if (TRUE) {
[18:04:20.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.562]                     {
[18:04:20.562]                       inherits <- base::inherits
[18:04:20.562]                       invokeRestart <- base::invokeRestart
[18:04:20.562]                       is.null <- base::is.null
[18:04:20.562]                       muffled <- FALSE
[18:04:20.562]                       if (inherits(cond, "message")) {
[18:04:20.562]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.562]                         if (muffled) 
[18:04:20.562]                           invokeRestart("muffleMessage")
[18:04:20.562]                       }
[18:04:20.562]                       else if (inherits(cond, "warning")) {
[18:04:20.562]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.562]                         if (muffled) 
[18:04:20.562]                           invokeRestart("muffleWarning")
[18:04:20.562]                       }
[18:04:20.562]                       else if (inherits(cond, "condition")) {
[18:04:20.562]                         if (!is.null(pattern)) {
[18:04:20.562]                           computeRestarts <- base::computeRestarts
[18:04:20.562]                           grepl <- base::grepl
[18:04:20.562]                           restarts <- computeRestarts(cond)
[18:04:20.562]                           for (restart in restarts) {
[18:04:20.562]                             name <- restart$name
[18:04:20.562]                             if (is.null(name)) 
[18:04:20.562]                               next
[18:04:20.562]                             if (!grepl(pattern, name)) 
[18:04:20.562]                               next
[18:04:20.562]                             invokeRestart(restart)
[18:04:20.562]                             muffled <- TRUE
[18:04:20.562]                             break
[18:04:20.562]                           }
[18:04:20.562]                         }
[18:04:20.562]                       }
[18:04:20.562]                       invisible(muffled)
[18:04:20.562]                     }
[18:04:20.562]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.562]                   }
[18:04:20.562]                 }
[18:04:20.562]             }
[18:04:20.562]         }))
[18:04:20.562]     }, error = function(ex) {
[18:04:20.562]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.562]                 ...future.rng), started = ...future.startTime, 
[18:04:20.562]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.562]             version = "1.8"), class = "FutureResult")
[18:04:20.562]     }, finally = {
[18:04:20.562]         if (!identical(...future.workdir, getwd())) 
[18:04:20.562]             setwd(...future.workdir)
[18:04:20.562]         {
[18:04:20.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.562]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.562]             }
[18:04:20.562]             base::options(...future.oldOptions)
[18:04:20.562]             if (.Platform$OS.type == "windows") {
[18:04:20.562]                 old_names <- names(...future.oldEnvVars)
[18:04:20.562]                 envs <- base::Sys.getenv()
[18:04:20.562]                 names <- names(envs)
[18:04:20.562]                 common <- intersect(names, old_names)
[18:04:20.562]                 added <- setdiff(names, old_names)
[18:04:20.562]                 removed <- setdiff(old_names, names)
[18:04:20.562]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.562]                   envs[common]]
[18:04:20.562]                 NAMES <- toupper(changed)
[18:04:20.562]                 args <- list()
[18:04:20.562]                 for (kk in seq_along(NAMES)) {
[18:04:20.562]                   name <- changed[[kk]]
[18:04:20.562]                   NAME <- NAMES[[kk]]
[18:04:20.562]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.562]                     next
[18:04:20.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.562]                 }
[18:04:20.562]                 NAMES <- toupper(added)
[18:04:20.562]                 for (kk in seq_along(NAMES)) {
[18:04:20.562]                   name <- added[[kk]]
[18:04:20.562]                   NAME <- NAMES[[kk]]
[18:04:20.562]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.562]                     next
[18:04:20.562]                   args[[name]] <- ""
[18:04:20.562]                 }
[18:04:20.562]                 NAMES <- toupper(removed)
[18:04:20.562]                 for (kk in seq_along(NAMES)) {
[18:04:20.562]                   name <- removed[[kk]]
[18:04:20.562]                   NAME <- NAMES[[kk]]
[18:04:20.562]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.562]                     next
[18:04:20.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.562]                 }
[18:04:20.562]                 if (length(args) > 0) 
[18:04:20.562]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.562]             }
[18:04:20.562]             else {
[18:04:20.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.562]             }
[18:04:20.562]             {
[18:04:20.562]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.562]                   0L) {
[18:04:20.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.562]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.562]                   base::options(opts)
[18:04:20.562]                 }
[18:04:20.562]                 {
[18:04:20.562]                   {
[18:04:20.562]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.562]                     NULL
[18:04:20.562]                   }
[18:04:20.562]                   options(future.plan = NULL)
[18:04:20.562]                   if (is.na(NA_character_)) 
[18:04:20.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.562]                     .init = FALSE)
[18:04:20.562]                 }
[18:04:20.562]             }
[18:04:20.562]         }
[18:04:20.562]     })
[18:04:20.562]     if (TRUE) {
[18:04:20.562]         base::sink(type = "output", split = FALSE)
[18:04:20.562]         if (TRUE) {
[18:04:20.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.562]         }
[18:04:20.562]         else {
[18:04:20.562]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.562]         }
[18:04:20.562]         base::close(...future.stdout)
[18:04:20.562]         ...future.stdout <- NULL
[18:04:20.562]     }
[18:04:20.562]     ...future.result$conditions <- ...future.conditions
[18:04:20.562]     ...future.result$finished <- base::Sys.time()
[18:04:20.562]     ...future.result
[18:04:20.562] }
[18:04:20.568] MultisessionFuture started
[18:04:20.568] - Launch lazy future ... done
[18:04:20.569] run() for ‘MultisessionFuture’ ... done
[18:04:20.569] getGlobalsAndPackages() ...
[18:04:20.569] Searching for globals...
[18:04:20.571] - globals found: [1] ‘{’
[18:04:20.571] Searching for globals ... DONE
[18:04:20.571] Resolving globals: FALSE
[18:04:20.572] 
[18:04:20.572] 
[18:04:20.572] getGlobalsAndPackages() ... DONE
[18:04:20.572] run() for ‘Future’ ...
[18:04:20.573] - state: ‘created’
[18:04:20.573] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.596] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.597]   - Field: ‘node’
[18:04:20.597]   - Field: ‘label’
[18:04:20.597]   - Field: ‘local’
[18:04:20.598]   - Field: ‘owner’
[18:04:20.598]   - Field: ‘envir’
[18:04:20.598]   - Field: ‘workers’
[18:04:20.598]   - Field: ‘packages’
[18:04:20.598]   - Field: ‘gc’
[18:04:20.599]   - Field: ‘conditions’
[18:04:20.599]   - Field: ‘persistent’
[18:04:20.599]   - Field: ‘expr’
[18:04:20.599]   - Field: ‘uuid’
[18:04:20.599]   - Field: ‘seed’
[18:04:20.600]   - Field: ‘version’
[18:04:20.600]   - Field: ‘result’
[18:04:20.600]   - Field: ‘asynchronous’
[18:04:20.600]   - Field: ‘calls’
[18:04:20.600]   - Field: ‘globals’
[18:04:20.601]   - Field: ‘stdout’
[18:04:20.601]   - Field: ‘earlySignal’
[18:04:20.601]   - Field: ‘lazy’
[18:04:20.601]   - Field: ‘state’
[18:04:20.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.602] - Launch lazy future ...
[18:04:20.602] Packages needed by the future expression (n = 0): <none>
[18:04:20.602] Packages needed by future strategies (n = 0): <none>
[18:04:20.603] {
[18:04:20.603]     {
[18:04:20.603]         {
[18:04:20.603]             ...future.startTime <- base::Sys.time()
[18:04:20.603]             {
[18:04:20.603]                 {
[18:04:20.603]                   {
[18:04:20.603]                     {
[18:04:20.603]                       base::local({
[18:04:20.603]                         has_future <- base::requireNamespace("future", 
[18:04:20.603]                           quietly = TRUE)
[18:04:20.603]                         if (has_future) {
[18:04:20.603]                           ns <- base::getNamespace("future")
[18:04:20.603]                           version <- ns[[".package"]][["version"]]
[18:04:20.603]                           if (is.null(version)) 
[18:04:20.603]                             version <- utils::packageVersion("future")
[18:04:20.603]                         }
[18:04:20.603]                         else {
[18:04:20.603]                           version <- NULL
[18:04:20.603]                         }
[18:04:20.603]                         if (!has_future || version < "1.8.0") {
[18:04:20.603]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.603]                             "", base::R.version$version.string), 
[18:04:20.603]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.603]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.603]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.603]                               "release", "version")], collapse = " "), 
[18:04:20.603]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.603]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.603]                             info)
[18:04:20.603]                           info <- base::paste(info, collapse = "; ")
[18:04:20.603]                           if (!has_future) {
[18:04:20.603]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.603]                               info)
[18:04:20.603]                           }
[18:04:20.603]                           else {
[18:04:20.603]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.603]                               info, version)
[18:04:20.603]                           }
[18:04:20.603]                           base::stop(msg)
[18:04:20.603]                         }
[18:04:20.603]                       })
[18:04:20.603]                     }
[18:04:20.603]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.603]                     base::options(mc.cores = 1L)
[18:04:20.603]                   }
[18:04:20.603]                   ...future.strategy.old <- future::plan("list")
[18:04:20.603]                   options(future.plan = NULL)
[18:04:20.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.603]                 }
[18:04:20.603]                 ...future.workdir <- getwd()
[18:04:20.603]             }
[18:04:20.603]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.603]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.603]         }
[18:04:20.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.603]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.603]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.603]             base::names(...future.oldOptions))
[18:04:20.603]     }
[18:04:20.603]     if (FALSE) {
[18:04:20.603]     }
[18:04:20.603]     else {
[18:04:20.603]         if (TRUE) {
[18:04:20.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.603]                 open = "w")
[18:04:20.603]         }
[18:04:20.603]         else {
[18:04:20.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.603]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.603]         }
[18:04:20.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.603]             base::sink(type = "output", split = FALSE)
[18:04:20.603]             base::close(...future.stdout)
[18:04:20.603]         }, add = TRUE)
[18:04:20.603]     }
[18:04:20.603]     ...future.frame <- base::sys.nframe()
[18:04:20.603]     ...future.conditions <- base::list()
[18:04:20.603]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.603]     if (FALSE) {
[18:04:20.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.603]     }
[18:04:20.603]     ...future.result <- base::tryCatch({
[18:04:20.603]         base::withCallingHandlers({
[18:04:20.603]             ...future.value <- base::withVisible(base::local({
[18:04:20.603]                 ...future.makeSendCondition <- base::local({
[18:04:20.603]                   sendCondition <- NULL
[18:04:20.603]                   function(frame = 1L) {
[18:04:20.603]                     if (is.function(sendCondition)) 
[18:04:20.603]                       return(sendCondition)
[18:04:20.603]                     ns <- getNamespace("parallel")
[18:04:20.603]                     if (exists("sendData", mode = "function", 
[18:04:20.603]                       envir = ns)) {
[18:04:20.603]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.603]                         envir = ns)
[18:04:20.603]                       envir <- sys.frame(frame)
[18:04:20.603]                       master <- NULL
[18:04:20.603]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.603]                         !identical(envir, emptyenv())) {
[18:04:20.603]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.603]                           inherits = FALSE)) {
[18:04:20.603]                           master <- get("master", mode = "list", 
[18:04:20.603]                             envir = envir, inherits = FALSE)
[18:04:20.603]                           if (inherits(master, c("SOCKnode", 
[18:04:20.603]                             "SOCK0node"))) {
[18:04:20.603]                             sendCondition <<- function(cond) {
[18:04:20.603]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.603]                                 success = TRUE)
[18:04:20.603]                               parallel_sendData(master, data)
[18:04:20.603]                             }
[18:04:20.603]                             return(sendCondition)
[18:04:20.603]                           }
[18:04:20.603]                         }
[18:04:20.603]                         frame <- frame + 1L
[18:04:20.603]                         envir <- sys.frame(frame)
[18:04:20.603]                       }
[18:04:20.603]                     }
[18:04:20.603]                     sendCondition <<- function(cond) NULL
[18:04:20.603]                   }
[18:04:20.603]                 })
[18:04:20.603]                 withCallingHandlers({
[18:04:20.603]                   {
[18:04:20.603]                     4
[18:04:20.603]                   }
[18:04:20.603]                 }, immediateCondition = function(cond) {
[18:04:20.603]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.603]                   sendCondition(cond)
[18:04:20.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.603]                   {
[18:04:20.603]                     inherits <- base::inherits
[18:04:20.603]                     invokeRestart <- base::invokeRestart
[18:04:20.603]                     is.null <- base::is.null
[18:04:20.603]                     muffled <- FALSE
[18:04:20.603]                     if (inherits(cond, "message")) {
[18:04:20.603]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.603]                       if (muffled) 
[18:04:20.603]                         invokeRestart("muffleMessage")
[18:04:20.603]                     }
[18:04:20.603]                     else if (inherits(cond, "warning")) {
[18:04:20.603]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.603]                       if (muffled) 
[18:04:20.603]                         invokeRestart("muffleWarning")
[18:04:20.603]                     }
[18:04:20.603]                     else if (inherits(cond, "condition")) {
[18:04:20.603]                       if (!is.null(pattern)) {
[18:04:20.603]                         computeRestarts <- base::computeRestarts
[18:04:20.603]                         grepl <- base::grepl
[18:04:20.603]                         restarts <- computeRestarts(cond)
[18:04:20.603]                         for (restart in restarts) {
[18:04:20.603]                           name <- restart$name
[18:04:20.603]                           if (is.null(name)) 
[18:04:20.603]                             next
[18:04:20.603]                           if (!grepl(pattern, name)) 
[18:04:20.603]                             next
[18:04:20.603]                           invokeRestart(restart)
[18:04:20.603]                           muffled <- TRUE
[18:04:20.603]                           break
[18:04:20.603]                         }
[18:04:20.603]                       }
[18:04:20.603]                     }
[18:04:20.603]                     invisible(muffled)
[18:04:20.603]                   }
[18:04:20.603]                   muffleCondition(cond)
[18:04:20.603]                 })
[18:04:20.603]             }))
[18:04:20.603]             future::FutureResult(value = ...future.value$value, 
[18:04:20.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.603]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.603]                     ...future.globalenv.names))
[18:04:20.603]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.603]         }, condition = base::local({
[18:04:20.603]             c <- base::c
[18:04:20.603]             inherits <- base::inherits
[18:04:20.603]             invokeRestart <- base::invokeRestart
[18:04:20.603]             length <- base::length
[18:04:20.603]             list <- base::list
[18:04:20.603]             seq.int <- base::seq.int
[18:04:20.603]             signalCondition <- base::signalCondition
[18:04:20.603]             sys.calls <- base::sys.calls
[18:04:20.603]             `[[` <- base::`[[`
[18:04:20.603]             `+` <- base::`+`
[18:04:20.603]             `<<-` <- base::`<<-`
[18:04:20.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.603]                   3L)]
[18:04:20.603]             }
[18:04:20.603]             function(cond) {
[18:04:20.603]                 is_error <- inherits(cond, "error")
[18:04:20.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.603]                   NULL)
[18:04:20.603]                 if (is_error) {
[18:04:20.603]                   sessionInformation <- function() {
[18:04:20.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.603]                       search = base::search(), system = base::Sys.info())
[18:04:20.603]                   }
[18:04:20.603]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.603]                     cond$call), session = sessionInformation(), 
[18:04:20.603]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.603]                   signalCondition(cond)
[18:04:20.603]                 }
[18:04:20.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.603]                 "immediateCondition"))) {
[18:04:20.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.603]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.603]                   if (TRUE && !signal) {
[18:04:20.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.603]                     {
[18:04:20.603]                       inherits <- base::inherits
[18:04:20.603]                       invokeRestart <- base::invokeRestart
[18:04:20.603]                       is.null <- base::is.null
[18:04:20.603]                       muffled <- FALSE
[18:04:20.603]                       if (inherits(cond, "message")) {
[18:04:20.603]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.603]                         if (muffled) 
[18:04:20.603]                           invokeRestart("muffleMessage")
[18:04:20.603]                       }
[18:04:20.603]                       else if (inherits(cond, "warning")) {
[18:04:20.603]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.603]                         if (muffled) 
[18:04:20.603]                           invokeRestart("muffleWarning")
[18:04:20.603]                       }
[18:04:20.603]                       else if (inherits(cond, "condition")) {
[18:04:20.603]                         if (!is.null(pattern)) {
[18:04:20.603]                           computeRestarts <- base::computeRestarts
[18:04:20.603]                           grepl <- base::grepl
[18:04:20.603]                           restarts <- computeRestarts(cond)
[18:04:20.603]                           for (restart in restarts) {
[18:04:20.603]                             name <- restart$name
[18:04:20.603]                             if (is.null(name)) 
[18:04:20.603]                               next
[18:04:20.603]                             if (!grepl(pattern, name)) 
[18:04:20.603]                               next
[18:04:20.603]                             invokeRestart(restart)
[18:04:20.603]                             muffled <- TRUE
[18:04:20.603]                             break
[18:04:20.603]                           }
[18:04:20.603]                         }
[18:04:20.603]                       }
[18:04:20.603]                       invisible(muffled)
[18:04:20.603]                     }
[18:04:20.603]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.603]                   }
[18:04:20.603]                 }
[18:04:20.603]                 else {
[18:04:20.603]                   if (TRUE) {
[18:04:20.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.603]                     {
[18:04:20.603]                       inherits <- base::inherits
[18:04:20.603]                       invokeRestart <- base::invokeRestart
[18:04:20.603]                       is.null <- base::is.null
[18:04:20.603]                       muffled <- FALSE
[18:04:20.603]                       if (inherits(cond, "message")) {
[18:04:20.603]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.603]                         if (muffled) 
[18:04:20.603]                           invokeRestart("muffleMessage")
[18:04:20.603]                       }
[18:04:20.603]                       else if (inherits(cond, "warning")) {
[18:04:20.603]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.603]                         if (muffled) 
[18:04:20.603]                           invokeRestart("muffleWarning")
[18:04:20.603]                       }
[18:04:20.603]                       else if (inherits(cond, "condition")) {
[18:04:20.603]                         if (!is.null(pattern)) {
[18:04:20.603]                           computeRestarts <- base::computeRestarts
[18:04:20.603]                           grepl <- base::grepl
[18:04:20.603]                           restarts <- computeRestarts(cond)
[18:04:20.603]                           for (restart in restarts) {
[18:04:20.603]                             name <- restart$name
[18:04:20.603]                             if (is.null(name)) 
[18:04:20.603]                               next
[18:04:20.603]                             if (!grepl(pattern, name)) 
[18:04:20.603]                               next
[18:04:20.603]                             invokeRestart(restart)
[18:04:20.603]                             muffled <- TRUE
[18:04:20.603]                             break
[18:04:20.603]                           }
[18:04:20.603]                         }
[18:04:20.603]                       }
[18:04:20.603]                       invisible(muffled)
[18:04:20.603]                     }
[18:04:20.603]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.603]                   }
[18:04:20.603]                 }
[18:04:20.603]             }
[18:04:20.603]         }))
[18:04:20.603]     }, error = function(ex) {
[18:04:20.603]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.603]                 ...future.rng), started = ...future.startTime, 
[18:04:20.603]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.603]             version = "1.8"), class = "FutureResult")
[18:04:20.603]     }, finally = {
[18:04:20.603]         if (!identical(...future.workdir, getwd())) 
[18:04:20.603]             setwd(...future.workdir)
[18:04:20.603]         {
[18:04:20.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.603]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.603]             }
[18:04:20.603]             base::options(...future.oldOptions)
[18:04:20.603]             if (.Platform$OS.type == "windows") {
[18:04:20.603]                 old_names <- names(...future.oldEnvVars)
[18:04:20.603]                 envs <- base::Sys.getenv()
[18:04:20.603]                 names <- names(envs)
[18:04:20.603]                 common <- intersect(names, old_names)
[18:04:20.603]                 added <- setdiff(names, old_names)
[18:04:20.603]                 removed <- setdiff(old_names, names)
[18:04:20.603]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.603]                   envs[common]]
[18:04:20.603]                 NAMES <- toupper(changed)
[18:04:20.603]                 args <- list()
[18:04:20.603]                 for (kk in seq_along(NAMES)) {
[18:04:20.603]                   name <- changed[[kk]]
[18:04:20.603]                   NAME <- NAMES[[kk]]
[18:04:20.603]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.603]                     next
[18:04:20.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.603]                 }
[18:04:20.603]                 NAMES <- toupper(added)
[18:04:20.603]                 for (kk in seq_along(NAMES)) {
[18:04:20.603]                   name <- added[[kk]]
[18:04:20.603]                   NAME <- NAMES[[kk]]
[18:04:20.603]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.603]                     next
[18:04:20.603]                   args[[name]] <- ""
[18:04:20.603]                 }
[18:04:20.603]                 NAMES <- toupper(removed)
[18:04:20.603]                 for (kk in seq_along(NAMES)) {
[18:04:20.603]                   name <- removed[[kk]]
[18:04:20.603]                   NAME <- NAMES[[kk]]
[18:04:20.603]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.603]                     next
[18:04:20.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.603]                 }
[18:04:20.603]                 if (length(args) > 0) 
[18:04:20.603]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.603]             }
[18:04:20.603]             else {
[18:04:20.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.603]             }
[18:04:20.603]             {
[18:04:20.603]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.603]                   0L) {
[18:04:20.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.603]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.603]                   base::options(opts)
[18:04:20.603]                 }
[18:04:20.603]                 {
[18:04:20.603]                   {
[18:04:20.603]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.603]                     NULL
[18:04:20.603]                   }
[18:04:20.603]                   options(future.plan = NULL)
[18:04:20.603]                   if (is.na(NA_character_)) 
[18:04:20.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.603]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.603]                     .init = FALSE)
[18:04:20.603]                 }
[18:04:20.603]             }
[18:04:20.603]         }
[18:04:20.603]     })
[18:04:20.603]     if (TRUE) {
[18:04:20.603]         base::sink(type = "output", split = FALSE)
[18:04:20.603]         if (TRUE) {
[18:04:20.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.603]         }
[18:04:20.603]         else {
[18:04:20.603]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.603]         }
[18:04:20.603]         base::close(...future.stdout)
[18:04:20.603]         ...future.stdout <- NULL
[18:04:20.603]     }
[18:04:20.603]     ...future.result$conditions <- ...future.conditions
[18:04:20.603]     ...future.result$finished <- base::Sys.time()
[18:04:20.603]     ...future.result
[18:04:20.603] }
[18:04:20.607] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:20.618] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.619] - Validating connection of MultisessionFuture
[18:04:20.619] - received message: FutureResult
[18:04:20.619] - Received FutureResult
[18:04:20.619] - Erased future from FutureRegistry
[18:04:20.620] result() for ClusterFuture ...
[18:04:20.620] - result already collected: FutureResult
[18:04:20.620] result() for ClusterFuture ... done
[18:04:20.620] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:20.620] result() for ClusterFuture ...
[18:04:20.621] - result already collected: FutureResult
[18:04:20.621] result() for ClusterFuture ... done
[18:04:20.621] result() for ClusterFuture ...
[18:04:20.621] - result already collected: FutureResult
[18:04:20.621] result() for ClusterFuture ... done
[18:04:20.623] MultisessionFuture started
[18:04:20.624] - Launch lazy future ... done
[18:04:20.624] run() for ‘MultisessionFuture’ ... done
<environment: 0x5e3c2cdcaec0> 
<environment: 0x5e3c2b0d5d08> 
[18:04:20.627] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.627] - Validating connection of MultisessionFuture
[18:04:20.628] - received message: FutureResult
[18:04:20.628] - Received FutureResult
[18:04:20.628] - Erased future from FutureRegistry
[18:04:20.628] result() for ClusterFuture ...
[18:04:20.628] - result already collected: FutureResult
[18:04:20.629] result() for ClusterFuture ... done
[18:04:20.629] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:20.642] resolve() on environment ...
[18:04:20.642]  recursive: 0
[18:04:20.643]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:20.644] signalConditionsASAP(numeric, pos=1) ...
[18:04:20.644] - nx: 4
[18:04:20.644] - relay: TRUE
[18:04:20.644] - stdout: TRUE
[18:04:20.644] - signal: TRUE
[18:04:20.644] - resignal: FALSE
[18:04:20.645] - force: TRUE
[18:04:20.645] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.645] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.645]  - until=2
[18:04:20.645]  - relaying element #2
[18:04:20.646] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:20.646] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.646] signalConditionsASAP(NULL, pos=1) ... done
[18:04:20.646]  length: 3 (resolved future 1)
[18:04:20.646] Future #2
[18:04:20.647] result() for ClusterFuture ...
[18:04:20.647] - result already collected: FutureResult
[18:04:20.647] result() for ClusterFuture ... done
[18:04:20.647] result() for ClusterFuture ...
[18:04:20.647] - result already collected: FutureResult
[18:04:20.648] result() for ClusterFuture ... done
[18:04:20.648] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:20.648] - nx: 4
[18:04:20.648] - relay: TRUE
[18:04:20.648] - stdout: TRUE
[18:04:20.649] - signal: TRUE
[18:04:20.649] - resignal: FALSE
[18:04:20.649] - force: TRUE
[18:04:20.649] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:20.649] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.649]  - until=2
[18:04:20.650]  - relaying element #2
[18:04:20.650] result() for ClusterFuture ...
[18:04:20.650] - result already collected: FutureResult
[18:04:20.650] result() for ClusterFuture ... done
[18:04:20.650] result() for ClusterFuture ...
[18:04:20.651] - result already collected: FutureResult
[18:04:20.651] result() for ClusterFuture ... done
[18:04:20.651] result() for ClusterFuture ...
[18:04:20.651] - result already collected: FutureResult
[18:04:20.651] result() for ClusterFuture ... done
[18:04:20.652] result() for ClusterFuture ...
[18:04:20.652] - result already collected: FutureResult
[18:04:20.652] result() for ClusterFuture ... done
[18:04:20.652] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:20.652] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:20.653] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:20.653]  length: 2 (resolved future 2)
[18:04:20.653] Future #3
[18:04:20.653] result() for ClusterFuture ...
[18:04:20.653] - result already collected: FutureResult
[18:04:20.654] result() for ClusterFuture ... done
[18:04:20.654] result() for ClusterFuture ...
[18:04:20.654] - result already collected: FutureResult
[18:04:20.654] result() for ClusterFuture ... done
[18:04:20.654] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:20.655] - nx: 4
[18:04:20.655] - relay: TRUE
[18:04:20.655] - stdout: TRUE
[18:04:20.655] - signal: TRUE
[18:04:20.655] - resignal: FALSE
[18:04:20.656] - force: TRUE
[18:04:20.656] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:20.656] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:20.656]  - until=3
[18:04:20.656]  - relaying element #3
[18:04:20.657] result() for ClusterFuture ...
[18:04:20.657] - result already collected: FutureResult
[18:04:20.657] result() for ClusterFuture ... done
[18:04:20.657] result() for ClusterFuture ...
[18:04:20.657] - result already collected: FutureResult
[18:04:20.657] result() for ClusterFuture ... done
[18:04:20.658] result() for ClusterFuture ...
[18:04:20.658] - result already collected: FutureResult
[18:04:20.658] result() for ClusterFuture ... done
[18:04:20.658] result() for ClusterFuture ...
[18:04:20.658] - result already collected: FutureResult
[18:04:20.659] result() for ClusterFuture ... done
[18:04:20.659] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:20.659] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:20.659] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:20.659]  length: 1 (resolved future 3)
[18:04:20.666] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.667] - Validating connection of MultisessionFuture
[18:04:20.667] - received message: FutureResult
[18:04:20.667] - Received FutureResult
[18:04:20.668] - Erased future from FutureRegistry
[18:04:20.668] result() for ClusterFuture ...
[18:04:20.668] - result already collected: FutureResult
[18:04:20.668] result() for ClusterFuture ... done
[18:04:20.668] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:20.669] Future #4
[18:04:20.669] result() for ClusterFuture ...
[18:04:20.669] - result already collected: FutureResult
[18:04:20.669] result() for ClusterFuture ... done
[18:04:20.669] result() for ClusterFuture ...
[18:04:20.670] - result already collected: FutureResult
[18:04:20.670] result() for ClusterFuture ... done
[18:04:20.670] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:20.670] - nx: 4
[18:04:20.671] - relay: TRUE
[18:04:20.671] - stdout: TRUE
[18:04:20.671] - signal: TRUE
[18:04:20.671] - resignal: FALSE
[18:04:20.671] - force: TRUE
[18:04:20.671] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:20.672] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:20.672]  - until=4
[18:04:20.672]  - relaying element #4
[18:04:20.672] result() for ClusterFuture ...
[18:04:20.672] - result already collected: FutureResult
[18:04:20.673] result() for ClusterFuture ... done
[18:04:20.673] result() for ClusterFuture ...
[18:04:20.673] - result already collected: FutureResult
[18:04:20.673] result() for ClusterFuture ... done
[18:04:20.673] result() for ClusterFuture ...
[18:04:20.674] - result already collected: FutureResult
[18:04:20.674] result() for ClusterFuture ... done
[18:04:20.674] result() for ClusterFuture ...
[18:04:20.674] - result already collected: FutureResult
[18:04:20.674] result() for ClusterFuture ... done
[18:04:20.674] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:20.675] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:20.675] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:20.675]  length: 0 (resolved future 4)
[18:04:20.675] Relaying remaining futures
[18:04:20.675] signalConditionsASAP(NULL, pos=0) ...
[18:04:20.676] - nx: 4
[18:04:20.676] - relay: TRUE
[18:04:20.676] - stdout: TRUE
[18:04:20.676] - signal: TRUE
[18:04:20.676] - resignal: FALSE
[18:04:20.676] - force: TRUE
[18:04:20.677] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:20.677] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:20.677] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:20.677] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:20.677] signalConditionsASAP(NULL, pos=0) ... done
[18:04:20.678] resolve() on environment ... DONE
[18:04:20.678] result() for ClusterFuture ...
[18:04:20.678] - result already collected: FutureResult
[18:04:20.678] result() for ClusterFuture ... done
[18:04:20.678] result() for ClusterFuture ...
[18:04:20.679] - result already collected: FutureResult
[18:04:20.679] result() for ClusterFuture ... done
[18:04:20.679] result() for ClusterFuture ...
[18:04:20.679] - result already collected: FutureResult
[18:04:20.679] result() for ClusterFuture ... done
[18:04:20.680] result() for ClusterFuture ...
[18:04:20.680] - result already collected: FutureResult
[18:04:20.680] result() for ClusterFuture ... done
[18:04:20.680] result() for ClusterFuture ...
[18:04:20.680] - result already collected: FutureResult
[18:04:20.680] result() for ClusterFuture ... done
[18:04:20.681] result() for ClusterFuture ...
[18:04:20.681] - result already collected: FutureResult
[18:04:20.681] result() for ClusterFuture ... done
<environment: 0x5e3c2ad65228> 
Dimensions: c(2, 3)
[18:04:20.682] getGlobalsAndPackages() ...
[18:04:20.682] Searching for globals...
[18:04:20.683] 
[18:04:20.683] Searching for globals ... DONE
[18:04:20.683] - globals: [0] <none>
[18:04:20.683] getGlobalsAndPackages() ... DONE
[18:04:20.684] run() for ‘Future’ ...
[18:04:20.684] - state: ‘created’
[18:04:20.684] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.708] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.708]   - Field: ‘node’
[18:04:20.709]   - Field: ‘label’
[18:04:20.709]   - Field: ‘local’
[18:04:20.709]   - Field: ‘owner’
[18:04:20.709]   - Field: ‘envir’
[18:04:20.709]   - Field: ‘workers’
[18:04:20.710]   - Field: ‘packages’
[18:04:20.710]   - Field: ‘gc’
[18:04:20.710]   - Field: ‘conditions’
[18:04:20.710]   - Field: ‘persistent’
[18:04:20.710]   - Field: ‘expr’
[18:04:20.711]   - Field: ‘uuid’
[18:04:20.711]   - Field: ‘seed’
[18:04:20.711]   - Field: ‘version’
[18:04:20.711]   - Field: ‘result’
[18:04:20.711]   - Field: ‘asynchronous’
[18:04:20.712]   - Field: ‘calls’
[18:04:20.712]   - Field: ‘globals’
[18:04:20.713]   - Field: ‘stdout’
[18:04:20.713]   - Field: ‘earlySignal’
[18:04:20.713]   - Field: ‘lazy’
[18:04:20.713]   - Field: ‘state’
[18:04:20.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.714] - Launch lazy future ...
[18:04:20.714] Packages needed by the future expression (n = 0): <none>
[18:04:20.714] Packages needed by future strategies (n = 0): <none>
[18:04:20.715] {
[18:04:20.715]     {
[18:04:20.715]         {
[18:04:20.715]             ...future.startTime <- base::Sys.time()
[18:04:20.715]             {
[18:04:20.715]                 {
[18:04:20.715]                   {
[18:04:20.715]                     {
[18:04:20.715]                       base::local({
[18:04:20.715]                         has_future <- base::requireNamespace("future", 
[18:04:20.715]                           quietly = TRUE)
[18:04:20.715]                         if (has_future) {
[18:04:20.715]                           ns <- base::getNamespace("future")
[18:04:20.715]                           version <- ns[[".package"]][["version"]]
[18:04:20.715]                           if (is.null(version)) 
[18:04:20.715]                             version <- utils::packageVersion("future")
[18:04:20.715]                         }
[18:04:20.715]                         else {
[18:04:20.715]                           version <- NULL
[18:04:20.715]                         }
[18:04:20.715]                         if (!has_future || version < "1.8.0") {
[18:04:20.715]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.715]                             "", base::R.version$version.string), 
[18:04:20.715]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.715]                               "release", "version")], collapse = " "), 
[18:04:20.715]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.715]                             info)
[18:04:20.715]                           info <- base::paste(info, collapse = "; ")
[18:04:20.715]                           if (!has_future) {
[18:04:20.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.715]                               info)
[18:04:20.715]                           }
[18:04:20.715]                           else {
[18:04:20.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.715]                               info, version)
[18:04:20.715]                           }
[18:04:20.715]                           base::stop(msg)
[18:04:20.715]                         }
[18:04:20.715]                       })
[18:04:20.715]                     }
[18:04:20.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.715]                     base::options(mc.cores = 1L)
[18:04:20.715]                   }
[18:04:20.715]                   ...future.strategy.old <- future::plan("list")
[18:04:20.715]                   options(future.plan = NULL)
[18:04:20.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.715]                 }
[18:04:20.715]                 ...future.workdir <- getwd()
[18:04:20.715]             }
[18:04:20.715]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.715]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.715]         }
[18:04:20.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.715]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.715]             base::names(...future.oldOptions))
[18:04:20.715]     }
[18:04:20.715]     if (FALSE) {
[18:04:20.715]     }
[18:04:20.715]     else {
[18:04:20.715]         if (TRUE) {
[18:04:20.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.715]                 open = "w")
[18:04:20.715]         }
[18:04:20.715]         else {
[18:04:20.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.715]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.715]         }
[18:04:20.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.715]             base::sink(type = "output", split = FALSE)
[18:04:20.715]             base::close(...future.stdout)
[18:04:20.715]         }, add = TRUE)
[18:04:20.715]     }
[18:04:20.715]     ...future.frame <- base::sys.nframe()
[18:04:20.715]     ...future.conditions <- base::list()
[18:04:20.715]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.715]     if (FALSE) {
[18:04:20.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.715]     }
[18:04:20.715]     ...future.result <- base::tryCatch({
[18:04:20.715]         base::withCallingHandlers({
[18:04:20.715]             ...future.value <- base::withVisible(base::local({
[18:04:20.715]                 ...future.makeSendCondition <- base::local({
[18:04:20.715]                   sendCondition <- NULL
[18:04:20.715]                   function(frame = 1L) {
[18:04:20.715]                     if (is.function(sendCondition)) 
[18:04:20.715]                       return(sendCondition)
[18:04:20.715]                     ns <- getNamespace("parallel")
[18:04:20.715]                     if (exists("sendData", mode = "function", 
[18:04:20.715]                       envir = ns)) {
[18:04:20.715]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.715]                         envir = ns)
[18:04:20.715]                       envir <- sys.frame(frame)
[18:04:20.715]                       master <- NULL
[18:04:20.715]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.715]                         !identical(envir, emptyenv())) {
[18:04:20.715]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.715]                           inherits = FALSE)) {
[18:04:20.715]                           master <- get("master", mode = "list", 
[18:04:20.715]                             envir = envir, inherits = FALSE)
[18:04:20.715]                           if (inherits(master, c("SOCKnode", 
[18:04:20.715]                             "SOCK0node"))) {
[18:04:20.715]                             sendCondition <<- function(cond) {
[18:04:20.715]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.715]                                 success = TRUE)
[18:04:20.715]                               parallel_sendData(master, data)
[18:04:20.715]                             }
[18:04:20.715]                             return(sendCondition)
[18:04:20.715]                           }
[18:04:20.715]                         }
[18:04:20.715]                         frame <- frame + 1L
[18:04:20.715]                         envir <- sys.frame(frame)
[18:04:20.715]                       }
[18:04:20.715]                     }
[18:04:20.715]                     sendCondition <<- function(cond) NULL
[18:04:20.715]                   }
[18:04:20.715]                 })
[18:04:20.715]                 withCallingHandlers({
[18:04:20.715]                   2
[18:04:20.715]                 }, immediateCondition = function(cond) {
[18:04:20.715]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.715]                   sendCondition(cond)
[18:04:20.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.715]                   {
[18:04:20.715]                     inherits <- base::inherits
[18:04:20.715]                     invokeRestart <- base::invokeRestart
[18:04:20.715]                     is.null <- base::is.null
[18:04:20.715]                     muffled <- FALSE
[18:04:20.715]                     if (inherits(cond, "message")) {
[18:04:20.715]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.715]                       if (muffled) 
[18:04:20.715]                         invokeRestart("muffleMessage")
[18:04:20.715]                     }
[18:04:20.715]                     else if (inherits(cond, "warning")) {
[18:04:20.715]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.715]                       if (muffled) 
[18:04:20.715]                         invokeRestart("muffleWarning")
[18:04:20.715]                     }
[18:04:20.715]                     else if (inherits(cond, "condition")) {
[18:04:20.715]                       if (!is.null(pattern)) {
[18:04:20.715]                         computeRestarts <- base::computeRestarts
[18:04:20.715]                         grepl <- base::grepl
[18:04:20.715]                         restarts <- computeRestarts(cond)
[18:04:20.715]                         for (restart in restarts) {
[18:04:20.715]                           name <- restart$name
[18:04:20.715]                           if (is.null(name)) 
[18:04:20.715]                             next
[18:04:20.715]                           if (!grepl(pattern, name)) 
[18:04:20.715]                             next
[18:04:20.715]                           invokeRestart(restart)
[18:04:20.715]                           muffled <- TRUE
[18:04:20.715]                           break
[18:04:20.715]                         }
[18:04:20.715]                       }
[18:04:20.715]                     }
[18:04:20.715]                     invisible(muffled)
[18:04:20.715]                   }
[18:04:20.715]                   muffleCondition(cond)
[18:04:20.715]                 })
[18:04:20.715]             }))
[18:04:20.715]             future::FutureResult(value = ...future.value$value, 
[18:04:20.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.715]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.715]                     ...future.globalenv.names))
[18:04:20.715]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.715]         }, condition = base::local({
[18:04:20.715]             c <- base::c
[18:04:20.715]             inherits <- base::inherits
[18:04:20.715]             invokeRestart <- base::invokeRestart
[18:04:20.715]             length <- base::length
[18:04:20.715]             list <- base::list
[18:04:20.715]             seq.int <- base::seq.int
[18:04:20.715]             signalCondition <- base::signalCondition
[18:04:20.715]             sys.calls <- base::sys.calls
[18:04:20.715]             `[[` <- base::`[[`
[18:04:20.715]             `+` <- base::`+`
[18:04:20.715]             `<<-` <- base::`<<-`
[18:04:20.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.715]                   3L)]
[18:04:20.715]             }
[18:04:20.715]             function(cond) {
[18:04:20.715]                 is_error <- inherits(cond, "error")
[18:04:20.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.715]                   NULL)
[18:04:20.715]                 if (is_error) {
[18:04:20.715]                   sessionInformation <- function() {
[18:04:20.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.715]                       search = base::search(), system = base::Sys.info())
[18:04:20.715]                   }
[18:04:20.715]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.715]                     cond$call), session = sessionInformation(), 
[18:04:20.715]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.715]                   signalCondition(cond)
[18:04:20.715]                 }
[18:04:20.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.715]                 "immediateCondition"))) {
[18:04:20.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.715]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.715]                   if (TRUE && !signal) {
[18:04:20.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.715]                     {
[18:04:20.715]                       inherits <- base::inherits
[18:04:20.715]                       invokeRestart <- base::invokeRestart
[18:04:20.715]                       is.null <- base::is.null
[18:04:20.715]                       muffled <- FALSE
[18:04:20.715]                       if (inherits(cond, "message")) {
[18:04:20.715]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.715]                         if (muffled) 
[18:04:20.715]                           invokeRestart("muffleMessage")
[18:04:20.715]                       }
[18:04:20.715]                       else if (inherits(cond, "warning")) {
[18:04:20.715]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.715]                         if (muffled) 
[18:04:20.715]                           invokeRestart("muffleWarning")
[18:04:20.715]                       }
[18:04:20.715]                       else if (inherits(cond, "condition")) {
[18:04:20.715]                         if (!is.null(pattern)) {
[18:04:20.715]                           computeRestarts <- base::computeRestarts
[18:04:20.715]                           grepl <- base::grepl
[18:04:20.715]                           restarts <- computeRestarts(cond)
[18:04:20.715]                           for (restart in restarts) {
[18:04:20.715]                             name <- restart$name
[18:04:20.715]                             if (is.null(name)) 
[18:04:20.715]                               next
[18:04:20.715]                             if (!grepl(pattern, name)) 
[18:04:20.715]                               next
[18:04:20.715]                             invokeRestart(restart)
[18:04:20.715]                             muffled <- TRUE
[18:04:20.715]                             break
[18:04:20.715]                           }
[18:04:20.715]                         }
[18:04:20.715]                       }
[18:04:20.715]                       invisible(muffled)
[18:04:20.715]                     }
[18:04:20.715]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.715]                   }
[18:04:20.715]                 }
[18:04:20.715]                 else {
[18:04:20.715]                   if (TRUE) {
[18:04:20.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.715]                     {
[18:04:20.715]                       inherits <- base::inherits
[18:04:20.715]                       invokeRestart <- base::invokeRestart
[18:04:20.715]                       is.null <- base::is.null
[18:04:20.715]                       muffled <- FALSE
[18:04:20.715]                       if (inherits(cond, "message")) {
[18:04:20.715]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.715]                         if (muffled) 
[18:04:20.715]                           invokeRestart("muffleMessage")
[18:04:20.715]                       }
[18:04:20.715]                       else if (inherits(cond, "warning")) {
[18:04:20.715]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.715]                         if (muffled) 
[18:04:20.715]                           invokeRestart("muffleWarning")
[18:04:20.715]                       }
[18:04:20.715]                       else if (inherits(cond, "condition")) {
[18:04:20.715]                         if (!is.null(pattern)) {
[18:04:20.715]                           computeRestarts <- base::computeRestarts
[18:04:20.715]                           grepl <- base::grepl
[18:04:20.715]                           restarts <- computeRestarts(cond)
[18:04:20.715]                           for (restart in restarts) {
[18:04:20.715]                             name <- restart$name
[18:04:20.715]                             if (is.null(name)) 
[18:04:20.715]                               next
[18:04:20.715]                             if (!grepl(pattern, name)) 
[18:04:20.715]                               next
[18:04:20.715]                             invokeRestart(restart)
[18:04:20.715]                             muffled <- TRUE
[18:04:20.715]                             break
[18:04:20.715]                           }
[18:04:20.715]                         }
[18:04:20.715]                       }
[18:04:20.715]                       invisible(muffled)
[18:04:20.715]                     }
[18:04:20.715]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.715]                   }
[18:04:20.715]                 }
[18:04:20.715]             }
[18:04:20.715]         }))
[18:04:20.715]     }, error = function(ex) {
[18:04:20.715]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.715]                 ...future.rng), started = ...future.startTime, 
[18:04:20.715]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.715]             version = "1.8"), class = "FutureResult")
[18:04:20.715]     }, finally = {
[18:04:20.715]         if (!identical(...future.workdir, getwd())) 
[18:04:20.715]             setwd(...future.workdir)
[18:04:20.715]         {
[18:04:20.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.715]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.715]             }
[18:04:20.715]             base::options(...future.oldOptions)
[18:04:20.715]             if (.Platform$OS.type == "windows") {
[18:04:20.715]                 old_names <- names(...future.oldEnvVars)
[18:04:20.715]                 envs <- base::Sys.getenv()
[18:04:20.715]                 names <- names(envs)
[18:04:20.715]                 common <- intersect(names, old_names)
[18:04:20.715]                 added <- setdiff(names, old_names)
[18:04:20.715]                 removed <- setdiff(old_names, names)
[18:04:20.715]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.715]                   envs[common]]
[18:04:20.715]                 NAMES <- toupper(changed)
[18:04:20.715]                 args <- list()
[18:04:20.715]                 for (kk in seq_along(NAMES)) {
[18:04:20.715]                   name <- changed[[kk]]
[18:04:20.715]                   NAME <- NAMES[[kk]]
[18:04:20.715]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.715]                     next
[18:04:20.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.715]                 }
[18:04:20.715]                 NAMES <- toupper(added)
[18:04:20.715]                 for (kk in seq_along(NAMES)) {
[18:04:20.715]                   name <- added[[kk]]
[18:04:20.715]                   NAME <- NAMES[[kk]]
[18:04:20.715]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.715]                     next
[18:04:20.715]                   args[[name]] <- ""
[18:04:20.715]                 }
[18:04:20.715]                 NAMES <- toupper(removed)
[18:04:20.715]                 for (kk in seq_along(NAMES)) {
[18:04:20.715]                   name <- removed[[kk]]
[18:04:20.715]                   NAME <- NAMES[[kk]]
[18:04:20.715]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.715]                     next
[18:04:20.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.715]                 }
[18:04:20.715]                 if (length(args) > 0) 
[18:04:20.715]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.715]             }
[18:04:20.715]             else {
[18:04:20.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.715]             }
[18:04:20.715]             {
[18:04:20.715]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.715]                   0L) {
[18:04:20.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.715]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.715]                   base::options(opts)
[18:04:20.715]                 }
[18:04:20.715]                 {
[18:04:20.715]                   {
[18:04:20.715]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.715]                     NULL
[18:04:20.715]                   }
[18:04:20.715]                   options(future.plan = NULL)
[18:04:20.715]                   if (is.na(NA_character_)) 
[18:04:20.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.715]                     .init = FALSE)
[18:04:20.715]                 }
[18:04:20.715]             }
[18:04:20.715]         }
[18:04:20.715]     })
[18:04:20.715]     if (TRUE) {
[18:04:20.715]         base::sink(type = "output", split = FALSE)
[18:04:20.715]         if (TRUE) {
[18:04:20.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.715]         }
[18:04:20.715]         else {
[18:04:20.715]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.715]         }
[18:04:20.715]         base::close(...future.stdout)
[18:04:20.715]         ...future.stdout <- NULL
[18:04:20.715]     }
[18:04:20.715]     ...future.result$conditions <- ...future.conditions
[18:04:20.715]     ...future.result$finished <- base::Sys.time()
[18:04:20.715]     ...future.result
[18:04:20.715] }
[18:04:20.721] MultisessionFuture started
[18:04:20.721] - Launch lazy future ... done
[18:04:20.721] run() for ‘MultisessionFuture’ ... done
[18:04:20.721] getGlobalsAndPackages() ...
[18:04:20.722] Searching for globals...
[18:04:20.722] 
[18:04:20.723] Searching for globals ... DONE
[18:04:20.723] - globals: [0] <none>
[18:04:20.723] getGlobalsAndPackages() ... DONE
[18:04:20.723] run() for ‘Future’ ...
[18:04:20.724] - state: ‘created’
[18:04:20.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.748] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.749]   - Field: ‘node’
[18:04:20.749]   - Field: ‘label’
[18:04:20.749]   - Field: ‘local’
[18:04:20.749]   - Field: ‘owner’
[18:04:20.749]   - Field: ‘envir’
[18:04:20.750]   - Field: ‘workers’
[18:04:20.750]   - Field: ‘packages’
[18:04:20.750]   - Field: ‘gc’
[18:04:20.750]   - Field: ‘conditions’
[18:04:20.750]   - Field: ‘persistent’
[18:04:20.751]   - Field: ‘expr’
[18:04:20.751]   - Field: ‘uuid’
[18:04:20.751]   - Field: ‘seed’
[18:04:20.751]   - Field: ‘version’
[18:04:20.751]   - Field: ‘result’
[18:04:20.752]   - Field: ‘asynchronous’
[18:04:20.752]   - Field: ‘calls’
[18:04:20.752]   - Field: ‘globals’
[18:04:20.752]   - Field: ‘stdout’
[18:04:20.752]   - Field: ‘earlySignal’
[18:04:20.753]   - Field: ‘lazy’
[18:04:20.753]   - Field: ‘state’
[18:04:20.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.754] - Launch lazy future ...
[18:04:20.754] Packages needed by the future expression (n = 0): <none>
[18:04:20.754] Packages needed by future strategies (n = 0): <none>
[18:04:20.755] {
[18:04:20.755]     {
[18:04:20.755]         {
[18:04:20.755]             ...future.startTime <- base::Sys.time()
[18:04:20.755]             {
[18:04:20.755]                 {
[18:04:20.755]                   {
[18:04:20.755]                     {
[18:04:20.755]                       base::local({
[18:04:20.755]                         has_future <- base::requireNamespace("future", 
[18:04:20.755]                           quietly = TRUE)
[18:04:20.755]                         if (has_future) {
[18:04:20.755]                           ns <- base::getNamespace("future")
[18:04:20.755]                           version <- ns[[".package"]][["version"]]
[18:04:20.755]                           if (is.null(version)) 
[18:04:20.755]                             version <- utils::packageVersion("future")
[18:04:20.755]                         }
[18:04:20.755]                         else {
[18:04:20.755]                           version <- NULL
[18:04:20.755]                         }
[18:04:20.755]                         if (!has_future || version < "1.8.0") {
[18:04:20.755]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.755]                             "", base::R.version$version.string), 
[18:04:20.755]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.755]                               "release", "version")], collapse = " "), 
[18:04:20.755]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.755]                             info)
[18:04:20.755]                           info <- base::paste(info, collapse = "; ")
[18:04:20.755]                           if (!has_future) {
[18:04:20.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.755]                               info)
[18:04:20.755]                           }
[18:04:20.755]                           else {
[18:04:20.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.755]                               info, version)
[18:04:20.755]                           }
[18:04:20.755]                           base::stop(msg)
[18:04:20.755]                         }
[18:04:20.755]                       })
[18:04:20.755]                     }
[18:04:20.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.755]                     base::options(mc.cores = 1L)
[18:04:20.755]                   }
[18:04:20.755]                   ...future.strategy.old <- future::plan("list")
[18:04:20.755]                   options(future.plan = NULL)
[18:04:20.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.755]                 }
[18:04:20.755]                 ...future.workdir <- getwd()
[18:04:20.755]             }
[18:04:20.755]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.755]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.755]         }
[18:04:20.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.755]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.755]             base::names(...future.oldOptions))
[18:04:20.755]     }
[18:04:20.755]     if (FALSE) {
[18:04:20.755]     }
[18:04:20.755]     else {
[18:04:20.755]         if (TRUE) {
[18:04:20.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.755]                 open = "w")
[18:04:20.755]         }
[18:04:20.755]         else {
[18:04:20.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.755]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.755]         }
[18:04:20.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.755]             base::sink(type = "output", split = FALSE)
[18:04:20.755]             base::close(...future.stdout)
[18:04:20.755]         }, add = TRUE)
[18:04:20.755]     }
[18:04:20.755]     ...future.frame <- base::sys.nframe()
[18:04:20.755]     ...future.conditions <- base::list()
[18:04:20.755]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.755]     if (FALSE) {
[18:04:20.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.755]     }
[18:04:20.755]     ...future.result <- base::tryCatch({
[18:04:20.755]         base::withCallingHandlers({
[18:04:20.755]             ...future.value <- base::withVisible(base::local({
[18:04:20.755]                 ...future.makeSendCondition <- base::local({
[18:04:20.755]                   sendCondition <- NULL
[18:04:20.755]                   function(frame = 1L) {
[18:04:20.755]                     if (is.function(sendCondition)) 
[18:04:20.755]                       return(sendCondition)
[18:04:20.755]                     ns <- getNamespace("parallel")
[18:04:20.755]                     if (exists("sendData", mode = "function", 
[18:04:20.755]                       envir = ns)) {
[18:04:20.755]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.755]                         envir = ns)
[18:04:20.755]                       envir <- sys.frame(frame)
[18:04:20.755]                       master <- NULL
[18:04:20.755]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.755]                         !identical(envir, emptyenv())) {
[18:04:20.755]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.755]                           inherits = FALSE)) {
[18:04:20.755]                           master <- get("master", mode = "list", 
[18:04:20.755]                             envir = envir, inherits = FALSE)
[18:04:20.755]                           if (inherits(master, c("SOCKnode", 
[18:04:20.755]                             "SOCK0node"))) {
[18:04:20.755]                             sendCondition <<- function(cond) {
[18:04:20.755]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.755]                                 success = TRUE)
[18:04:20.755]                               parallel_sendData(master, data)
[18:04:20.755]                             }
[18:04:20.755]                             return(sendCondition)
[18:04:20.755]                           }
[18:04:20.755]                         }
[18:04:20.755]                         frame <- frame + 1L
[18:04:20.755]                         envir <- sys.frame(frame)
[18:04:20.755]                       }
[18:04:20.755]                     }
[18:04:20.755]                     sendCondition <<- function(cond) NULL
[18:04:20.755]                   }
[18:04:20.755]                 })
[18:04:20.755]                 withCallingHandlers({
[18:04:20.755]                   NULL
[18:04:20.755]                 }, immediateCondition = function(cond) {
[18:04:20.755]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.755]                   sendCondition(cond)
[18:04:20.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.755]                   {
[18:04:20.755]                     inherits <- base::inherits
[18:04:20.755]                     invokeRestart <- base::invokeRestart
[18:04:20.755]                     is.null <- base::is.null
[18:04:20.755]                     muffled <- FALSE
[18:04:20.755]                     if (inherits(cond, "message")) {
[18:04:20.755]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.755]                       if (muffled) 
[18:04:20.755]                         invokeRestart("muffleMessage")
[18:04:20.755]                     }
[18:04:20.755]                     else if (inherits(cond, "warning")) {
[18:04:20.755]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.755]                       if (muffled) 
[18:04:20.755]                         invokeRestart("muffleWarning")
[18:04:20.755]                     }
[18:04:20.755]                     else if (inherits(cond, "condition")) {
[18:04:20.755]                       if (!is.null(pattern)) {
[18:04:20.755]                         computeRestarts <- base::computeRestarts
[18:04:20.755]                         grepl <- base::grepl
[18:04:20.755]                         restarts <- computeRestarts(cond)
[18:04:20.755]                         for (restart in restarts) {
[18:04:20.755]                           name <- restart$name
[18:04:20.755]                           if (is.null(name)) 
[18:04:20.755]                             next
[18:04:20.755]                           if (!grepl(pattern, name)) 
[18:04:20.755]                             next
[18:04:20.755]                           invokeRestart(restart)
[18:04:20.755]                           muffled <- TRUE
[18:04:20.755]                           break
[18:04:20.755]                         }
[18:04:20.755]                       }
[18:04:20.755]                     }
[18:04:20.755]                     invisible(muffled)
[18:04:20.755]                   }
[18:04:20.755]                   muffleCondition(cond)
[18:04:20.755]                 })
[18:04:20.755]             }))
[18:04:20.755]             future::FutureResult(value = ...future.value$value, 
[18:04:20.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.755]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.755]                     ...future.globalenv.names))
[18:04:20.755]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.755]         }, condition = base::local({
[18:04:20.755]             c <- base::c
[18:04:20.755]             inherits <- base::inherits
[18:04:20.755]             invokeRestart <- base::invokeRestart
[18:04:20.755]             length <- base::length
[18:04:20.755]             list <- base::list
[18:04:20.755]             seq.int <- base::seq.int
[18:04:20.755]             signalCondition <- base::signalCondition
[18:04:20.755]             sys.calls <- base::sys.calls
[18:04:20.755]             `[[` <- base::`[[`
[18:04:20.755]             `+` <- base::`+`
[18:04:20.755]             `<<-` <- base::`<<-`
[18:04:20.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.755]                   3L)]
[18:04:20.755]             }
[18:04:20.755]             function(cond) {
[18:04:20.755]                 is_error <- inherits(cond, "error")
[18:04:20.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.755]                   NULL)
[18:04:20.755]                 if (is_error) {
[18:04:20.755]                   sessionInformation <- function() {
[18:04:20.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.755]                       search = base::search(), system = base::Sys.info())
[18:04:20.755]                   }
[18:04:20.755]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.755]                     cond$call), session = sessionInformation(), 
[18:04:20.755]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.755]                   signalCondition(cond)
[18:04:20.755]                 }
[18:04:20.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.755]                 "immediateCondition"))) {
[18:04:20.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.755]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.755]                   if (TRUE && !signal) {
[18:04:20.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.755]                     {
[18:04:20.755]                       inherits <- base::inherits
[18:04:20.755]                       invokeRestart <- base::invokeRestart
[18:04:20.755]                       is.null <- base::is.null
[18:04:20.755]                       muffled <- FALSE
[18:04:20.755]                       if (inherits(cond, "message")) {
[18:04:20.755]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.755]                         if (muffled) 
[18:04:20.755]                           invokeRestart("muffleMessage")
[18:04:20.755]                       }
[18:04:20.755]                       else if (inherits(cond, "warning")) {
[18:04:20.755]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.755]                         if (muffled) 
[18:04:20.755]                           invokeRestart("muffleWarning")
[18:04:20.755]                       }
[18:04:20.755]                       else if (inherits(cond, "condition")) {
[18:04:20.755]                         if (!is.null(pattern)) {
[18:04:20.755]                           computeRestarts <- base::computeRestarts
[18:04:20.755]                           grepl <- base::grepl
[18:04:20.755]                           restarts <- computeRestarts(cond)
[18:04:20.755]                           for (restart in restarts) {
[18:04:20.755]                             name <- restart$name
[18:04:20.755]                             if (is.null(name)) 
[18:04:20.755]                               next
[18:04:20.755]                             if (!grepl(pattern, name)) 
[18:04:20.755]                               next
[18:04:20.755]                             invokeRestart(restart)
[18:04:20.755]                             muffled <- TRUE
[18:04:20.755]                             break
[18:04:20.755]                           }
[18:04:20.755]                         }
[18:04:20.755]                       }
[18:04:20.755]                       invisible(muffled)
[18:04:20.755]                     }
[18:04:20.755]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.755]                   }
[18:04:20.755]                 }
[18:04:20.755]                 else {
[18:04:20.755]                   if (TRUE) {
[18:04:20.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.755]                     {
[18:04:20.755]                       inherits <- base::inherits
[18:04:20.755]                       invokeRestart <- base::invokeRestart
[18:04:20.755]                       is.null <- base::is.null
[18:04:20.755]                       muffled <- FALSE
[18:04:20.755]                       if (inherits(cond, "message")) {
[18:04:20.755]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.755]                         if (muffled) 
[18:04:20.755]                           invokeRestart("muffleMessage")
[18:04:20.755]                       }
[18:04:20.755]                       else if (inherits(cond, "warning")) {
[18:04:20.755]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.755]                         if (muffled) 
[18:04:20.755]                           invokeRestart("muffleWarning")
[18:04:20.755]                       }
[18:04:20.755]                       else if (inherits(cond, "condition")) {
[18:04:20.755]                         if (!is.null(pattern)) {
[18:04:20.755]                           computeRestarts <- base::computeRestarts
[18:04:20.755]                           grepl <- base::grepl
[18:04:20.755]                           restarts <- computeRestarts(cond)
[18:04:20.755]                           for (restart in restarts) {
[18:04:20.755]                             name <- restart$name
[18:04:20.755]                             if (is.null(name)) 
[18:04:20.755]                               next
[18:04:20.755]                             if (!grepl(pattern, name)) 
[18:04:20.755]                               next
[18:04:20.755]                             invokeRestart(restart)
[18:04:20.755]                             muffled <- TRUE
[18:04:20.755]                             break
[18:04:20.755]                           }
[18:04:20.755]                         }
[18:04:20.755]                       }
[18:04:20.755]                       invisible(muffled)
[18:04:20.755]                     }
[18:04:20.755]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.755]                   }
[18:04:20.755]                 }
[18:04:20.755]             }
[18:04:20.755]         }))
[18:04:20.755]     }, error = function(ex) {
[18:04:20.755]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.755]                 ...future.rng), started = ...future.startTime, 
[18:04:20.755]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.755]             version = "1.8"), class = "FutureResult")
[18:04:20.755]     }, finally = {
[18:04:20.755]         if (!identical(...future.workdir, getwd())) 
[18:04:20.755]             setwd(...future.workdir)
[18:04:20.755]         {
[18:04:20.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.755]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.755]             }
[18:04:20.755]             base::options(...future.oldOptions)
[18:04:20.755]             if (.Platform$OS.type == "windows") {
[18:04:20.755]                 old_names <- names(...future.oldEnvVars)
[18:04:20.755]                 envs <- base::Sys.getenv()
[18:04:20.755]                 names <- names(envs)
[18:04:20.755]                 common <- intersect(names, old_names)
[18:04:20.755]                 added <- setdiff(names, old_names)
[18:04:20.755]                 removed <- setdiff(old_names, names)
[18:04:20.755]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.755]                   envs[common]]
[18:04:20.755]                 NAMES <- toupper(changed)
[18:04:20.755]                 args <- list()
[18:04:20.755]                 for (kk in seq_along(NAMES)) {
[18:04:20.755]                   name <- changed[[kk]]
[18:04:20.755]                   NAME <- NAMES[[kk]]
[18:04:20.755]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.755]                     next
[18:04:20.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.755]                 }
[18:04:20.755]                 NAMES <- toupper(added)
[18:04:20.755]                 for (kk in seq_along(NAMES)) {
[18:04:20.755]                   name <- added[[kk]]
[18:04:20.755]                   NAME <- NAMES[[kk]]
[18:04:20.755]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.755]                     next
[18:04:20.755]                   args[[name]] <- ""
[18:04:20.755]                 }
[18:04:20.755]                 NAMES <- toupper(removed)
[18:04:20.755]                 for (kk in seq_along(NAMES)) {
[18:04:20.755]                   name <- removed[[kk]]
[18:04:20.755]                   NAME <- NAMES[[kk]]
[18:04:20.755]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.755]                     next
[18:04:20.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.755]                 }
[18:04:20.755]                 if (length(args) > 0) 
[18:04:20.755]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.755]             }
[18:04:20.755]             else {
[18:04:20.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.755]             }
[18:04:20.755]             {
[18:04:20.755]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.755]                   0L) {
[18:04:20.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.755]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.755]                   base::options(opts)
[18:04:20.755]                 }
[18:04:20.755]                 {
[18:04:20.755]                   {
[18:04:20.755]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.755]                     NULL
[18:04:20.755]                   }
[18:04:20.755]                   options(future.plan = NULL)
[18:04:20.755]                   if (is.na(NA_character_)) 
[18:04:20.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.755]                     .init = FALSE)
[18:04:20.755]                 }
[18:04:20.755]             }
[18:04:20.755]         }
[18:04:20.755]     })
[18:04:20.755]     if (TRUE) {
[18:04:20.755]         base::sink(type = "output", split = FALSE)
[18:04:20.755]         if (TRUE) {
[18:04:20.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.755]         }
[18:04:20.755]         else {
[18:04:20.755]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.755]         }
[18:04:20.755]         base::close(...future.stdout)
[18:04:20.755]         ...future.stdout <- NULL
[18:04:20.755]     }
[18:04:20.755]     ...future.result$conditions <- ...future.conditions
[18:04:20.755]     ...future.result$finished <- base::Sys.time()
[18:04:20.755]     ...future.result
[18:04:20.755] }
[18:04:20.761] MultisessionFuture started
[18:04:20.761] - Launch lazy future ... done
[18:04:20.761] run() for ‘MultisessionFuture’ ... done
[18:04:20.762] getGlobalsAndPackages() ...
[18:04:20.762] Searching for globals...
[18:04:20.763] - globals found: [1] ‘{’
[18:04:20.764] Searching for globals ... DONE
[18:04:20.764] Resolving globals: FALSE
[18:04:20.764] 
[18:04:20.765] 
[18:04:20.765] getGlobalsAndPackages() ... DONE
[18:04:20.765] run() for ‘Future’ ...
[18:04:20.766] - state: ‘created’
[18:04:20.766] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.790] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.790] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.791]   - Field: ‘node’
[18:04:20.791]   - Field: ‘label’
[18:04:20.791]   - Field: ‘local’
[18:04:20.791]   - Field: ‘owner’
[18:04:20.791]   - Field: ‘envir’
[18:04:20.792]   - Field: ‘workers’
[18:04:20.792]   - Field: ‘packages’
[18:04:20.792]   - Field: ‘gc’
[18:04:20.792]   - Field: ‘conditions’
[18:04:20.792]   - Field: ‘persistent’
[18:04:20.793]   - Field: ‘expr’
[18:04:20.793]   - Field: ‘uuid’
[18:04:20.793]   - Field: ‘seed’
[18:04:20.793]   - Field: ‘version’
[18:04:20.793]   - Field: ‘result’
[18:04:20.794]   - Field: ‘asynchronous’
[18:04:20.794]   - Field: ‘calls’
[18:04:20.794]   - Field: ‘globals’
[18:04:20.794]   - Field: ‘stdout’
[18:04:20.794]   - Field: ‘earlySignal’
[18:04:20.795]   - Field: ‘lazy’
[18:04:20.795]   - Field: ‘state’
[18:04:20.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.795] - Launch lazy future ...
[18:04:20.796] Packages needed by the future expression (n = 0): <none>
[18:04:20.796] Packages needed by future strategies (n = 0): <none>
[18:04:20.797] {
[18:04:20.797]     {
[18:04:20.797]         {
[18:04:20.797]             ...future.startTime <- base::Sys.time()
[18:04:20.797]             {
[18:04:20.797]                 {
[18:04:20.797]                   {
[18:04:20.797]                     {
[18:04:20.797]                       base::local({
[18:04:20.797]                         has_future <- base::requireNamespace("future", 
[18:04:20.797]                           quietly = TRUE)
[18:04:20.797]                         if (has_future) {
[18:04:20.797]                           ns <- base::getNamespace("future")
[18:04:20.797]                           version <- ns[[".package"]][["version"]]
[18:04:20.797]                           if (is.null(version)) 
[18:04:20.797]                             version <- utils::packageVersion("future")
[18:04:20.797]                         }
[18:04:20.797]                         else {
[18:04:20.797]                           version <- NULL
[18:04:20.797]                         }
[18:04:20.797]                         if (!has_future || version < "1.8.0") {
[18:04:20.797]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.797]                             "", base::R.version$version.string), 
[18:04:20.797]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.797]                               "release", "version")], collapse = " "), 
[18:04:20.797]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.797]                             info)
[18:04:20.797]                           info <- base::paste(info, collapse = "; ")
[18:04:20.797]                           if (!has_future) {
[18:04:20.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.797]                               info)
[18:04:20.797]                           }
[18:04:20.797]                           else {
[18:04:20.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.797]                               info, version)
[18:04:20.797]                           }
[18:04:20.797]                           base::stop(msg)
[18:04:20.797]                         }
[18:04:20.797]                       })
[18:04:20.797]                     }
[18:04:20.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.797]                     base::options(mc.cores = 1L)
[18:04:20.797]                   }
[18:04:20.797]                   ...future.strategy.old <- future::plan("list")
[18:04:20.797]                   options(future.plan = NULL)
[18:04:20.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.797]                 }
[18:04:20.797]                 ...future.workdir <- getwd()
[18:04:20.797]             }
[18:04:20.797]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.797]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.797]         }
[18:04:20.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.797]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.797]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.797]             base::names(...future.oldOptions))
[18:04:20.797]     }
[18:04:20.797]     if (FALSE) {
[18:04:20.797]     }
[18:04:20.797]     else {
[18:04:20.797]         if (TRUE) {
[18:04:20.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.797]                 open = "w")
[18:04:20.797]         }
[18:04:20.797]         else {
[18:04:20.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.797]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.797]         }
[18:04:20.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.797]             base::sink(type = "output", split = FALSE)
[18:04:20.797]             base::close(...future.stdout)
[18:04:20.797]         }, add = TRUE)
[18:04:20.797]     }
[18:04:20.797]     ...future.frame <- base::sys.nframe()
[18:04:20.797]     ...future.conditions <- base::list()
[18:04:20.797]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.797]     if (FALSE) {
[18:04:20.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.797]     }
[18:04:20.797]     ...future.result <- base::tryCatch({
[18:04:20.797]         base::withCallingHandlers({
[18:04:20.797]             ...future.value <- base::withVisible(base::local({
[18:04:20.797]                 ...future.makeSendCondition <- base::local({
[18:04:20.797]                   sendCondition <- NULL
[18:04:20.797]                   function(frame = 1L) {
[18:04:20.797]                     if (is.function(sendCondition)) 
[18:04:20.797]                       return(sendCondition)
[18:04:20.797]                     ns <- getNamespace("parallel")
[18:04:20.797]                     if (exists("sendData", mode = "function", 
[18:04:20.797]                       envir = ns)) {
[18:04:20.797]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.797]                         envir = ns)
[18:04:20.797]                       envir <- sys.frame(frame)
[18:04:20.797]                       master <- NULL
[18:04:20.797]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.797]                         !identical(envir, emptyenv())) {
[18:04:20.797]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.797]                           inherits = FALSE)) {
[18:04:20.797]                           master <- get("master", mode = "list", 
[18:04:20.797]                             envir = envir, inherits = FALSE)
[18:04:20.797]                           if (inherits(master, c("SOCKnode", 
[18:04:20.797]                             "SOCK0node"))) {
[18:04:20.797]                             sendCondition <<- function(cond) {
[18:04:20.797]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.797]                                 success = TRUE)
[18:04:20.797]                               parallel_sendData(master, data)
[18:04:20.797]                             }
[18:04:20.797]                             return(sendCondition)
[18:04:20.797]                           }
[18:04:20.797]                         }
[18:04:20.797]                         frame <- frame + 1L
[18:04:20.797]                         envir <- sys.frame(frame)
[18:04:20.797]                       }
[18:04:20.797]                     }
[18:04:20.797]                     sendCondition <<- function(cond) NULL
[18:04:20.797]                   }
[18:04:20.797]                 })
[18:04:20.797]                 withCallingHandlers({
[18:04:20.797]                   {
[18:04:20.797]                     4
[18:04:20.797]                   }
[18:04:20.797]                 }, immediateCondition = function(cond) {
[18:04:20.797]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.797]                   sendCondition(cond)
[18:04:20.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.797]                   {
[18:04:20.797]                     inherits <- base::inherits
[18:04:20.797]                     invokeRestart <- base::invokeRestart
[18:04:20.797]                     is.null <- base::is.null
[18:04:20.797]                     muffled <- FALSE
[18:04:20.797]                     if (inherits(cond, "message")) {
[18:04:20.797]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.797]                       if (muffled) 
[18:04:20.797]                         invokeRestart("muffleMessage")
[18:04:20.797]                     }
[18:04:20.797]                     else if (inherits(cond, "warning")) {
[18:04:20.797]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.797]                       if (muffled) 
[18:04:20.797]                         invokeRestart("muffleWarning")
[18:04:20.797]                     }
[18:04:20.797]                     else if (inherits(cond, "condition")) {
[18:04:20.797]                       if (!is.null(pattern)) {
[18:04:20.797]                         computeRestarts <- base::computeRestarts
[18:04:20.797]                         grepl <- base::grepl
[18:04:20.797]                         restarts <- computeRestarts(cond)
[18:04:20.797]                         for (restart in restarts) {
[18:04:20.797]                           name <- restart$name
[18:04:20.797]                           if (is.null(name)) 
[18:04:20.797]                             next
[18:04:20.797]                           if (!grepl(pattern, name)) 
[18:04:20.797]                             next
[18:04:20.797]                           invokeRestart(restart)
[18:04:20.797]                           muffled <- TRUE
[18:04:20.797]                           break
[18:04:20.797]                         }
[18:04:20.797]                       }
[18:04:20.797]                     }
[18:04:20.797]                     invisible(muffled)
[18:04:20.797]                   }
[18:04:20.797]                   muffleCondition(cond)
[18:04:20.797]                 })
[18:04:20.797]             }))
[18:04:20.797]             future::FutureResult(value = ...future.value$value, 
[18:04:20.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.797]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.797]                     ...future.globalenv.names))
[18:04:20.797]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.797]         }, condition = base::local({
[18:04:20.797]             c <- base::c
[18:04:20.797]             inherits <- base::inherits
[18:04:20.797]             invokeRestart <- base::invokeRestart
[18:04:20.797]             length <- base::length
[18:04:20.797]             list <- base::list
[18:04:20.797]             seq.int <- base::seq.int
[18:04:20.797]             signalCondition <- base::signalCondition
[18:04:20.797]             sys.calls <- base::sys.calls
[18:04:20.797]             `[[` <- base::`[[`
[18:04:20.797]             `+` <- base::`+`
[18:04:20.797]             `<<-` <- base::`<<-`
[18:04:20.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.797]                   3L)]
[18:04:20.797]             }
[18:04:20.797]             function(cond) {
[18:04:20.797]                 is_error <- inherits(cond, "error")
[18:04:20.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.797]                   NULL)
[18:04:20.797]                 if (is_error) {
[18:04:20.797]                   sessionInformation <- function() {
[18:04:20.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.797]                       search = base::search(), system = base::Sys.info())
[18:04:20.797]                   }
[18:04:20.797]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.797]                     cond$call), session = sessionInformation(), 
[18:04:20.797]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.797]                   signalCondition(cond)
[18:04:20.797]                 }
[18:04:20.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.797]                 "immediateCondition"))) {
[18:04:20.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.797]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.797]                   if (TRUE && !signal) {
[18:04:20.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.797]                     {
[18:04:20.797]                       inherits <- base::inherits
[18:04:20.797]                       invokeRestart <- base::invokeRestart
[18:04:20.797]                       is.null <- base::is.null
[18:04:20.797]                       muffled <- FALSE
[18:04:20.797]                       if (inherits(cond, "message")) {
[18:04:20.797]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.797]                         if (muffled) 
[18:04:20.797]                           invokeRestart("muffleMessage")
[18:04:20.797]                       }
[18:04:20.797]                       else if (inherits(cond, "warning")) {
[18:04:20.797]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.797]                         if (muffled) 
[18:04:20.797]                           invokeRestart("muffleWarning")
[18:04:20.797]                       }
[18:04:20.797]                       else if (inherits(cond, "condition")) {
[18:04:20.797]                         if (!is.null(pattern)) {
[18:04:20.797]                           computeRestarts <- base::computeRestarts
[18:04:20.797]                           grepl <- base::grepl
[18:04:20.797]                           restarts <- computeRestarts(cond)
[18:04:20.797]                           for (restart in restarts) {
[18:04:20.797]                             name <- restart$name
[18:04:20.797]                             if (is.null(name)) 
[18:04:20.797]                               next
[18:04:20.797]                             if (!grepl(pattern, name)) 
[18:04:20.797]                               next
[18:04:20.797]                             invokeRestart(restart)
[18:04:20.797]                             muffled <- TRUE
[18:04:20.797]                             break
[18:04:20.797]                           }
[18:04:20.797]                         }
[18:04:20.797]                       }
[18:04:20.797]                       invisible(muffled)
[18:04:20.797]                     }
[18:04:20.797]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.797]                   }
[18:04:20.797]                 }
[18:04:20.797]                 else {
[18:04:20.797]                   if (TRUE) {
[18:04:20.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.797]                     {
[18:04:20.797]                       inherits <- base::inherits
[18:04:20.797]                       invokeRestart <- base::invokeRestart
[18:04:20.797]                       is.null <- base::is.null
[18:04:20.797]                       muffled <- FALSE
[18:04:20.797]                       if (inherits(cond, "message")) {
[18:04:20.797]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.797]                         if (muffled) 
[18:04:20.797]                           invokeRestart("muffleMessage")
[18:04:20.797]                       }
[18:04:20.797]                       else if (inherits(cond, "warning")) {
[18:04:20.797]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.797]                         if (muffled) 
[18:04:20.797]                           invokeRestart("muffleWarning")
[18:04:20.797]                       }
[18:04:20.797]                       else if (inherits(cond, "condition")) {
[18:04:20.797]                         if (!is.null(pattern)) {
[18:04:20.797]                           computeRestarts <- base::computeRestarts
[18:04:20.797]                           grepl <- base::grepl
[18:04:20.797]                           restarts <- computeRestarts(cond)
[18:04:20.797]                           for (restart in restarts) {
[18:04:20.797]                             name <- restart$name
[18:04:20.797]                             if (is.null(name)) 
[18:04:20.797]                               next
[18:04:20.797]                             if (!grepl(pattern, name)) 
[18:04:20.797]                               next
[18:04:20.797]                             invokeRestart(restart)
[18:04:20.797]                             muffled <- TRUE
[18:04:20.797]                             break
[18:04:20.797]                           }
[18:04:20.797]                         }
[18:04:20.797]                       }
[18:04:20.797]                       invisible(muffled)
[18:04:20.797]                     }
[18:04:20.797]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.797]                   }
[18:04:20.797]                 }
[18:04:20.797]             }
[18:04:20.797]         }))
[18:04:20.797]     }, error = function(ex) {
[18:04:20.797]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.797]                 ...future.rng), started = ...future.startTime, 
[18:04:20.797]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.797]             version = "1.8"), class = "FutureResult")
[18:04:20.797]     }, finally = {
[18:04:20.797]         if (!identical(...future.workdir, getwd())) 
[18:04:20.797]             setwd(...future.workdir)
[18:04:20.797]         {
[18:04:20.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.797]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.797]             }
[18:04:20.797]             base::options(...future.oldOptions)
[18:04:20.797]             if (.Platform$OS.type == "windows") {
[18:04:20.797]                 old_names <- names(...future.oldEnvVars)
[18:04:20.797]                 envs <- base::Sys.getenv()
[18:04:20.797]                 names <- names(envs)
[18:04:20.797]                 common <- intersect(names, old_names)
[18:04:20.797]                 added <- setdiff(names, old_names)
[18:04:20.797]                 removed <- setdiff(old_names, names)
[18:04:20.797]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.797]                   envs[common]]
[18:04:20.797]                 NAMES <- toupper(changed)
[18:04:20.797]                 args <- list()
[18:04:20.797]                 for (kk in seq_along(NAMES)) {
[18:04:20.797]                   name <- changed[[kk]]
[18:04:20.797]                   NAME <- NAMES[[kk]]
[18:04:20.797]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.797]                     next
[18:04:20.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.797]                 }
[18:04:20.797]                 NAMES <- toupper(added)
[18:04:20.797]                 for (kk in seq_along(NAMES)) {
[18:04:20.797]                   name <- added[[kk]]
[18:04:20.797]                   NAME <- NAMES[[kk]]
[18:04:20.797]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.797]                     next
[18:04:20.797]                   args[[name]] <- ""
[18:04:20.797]                 }
[18:04:20.797]                 NAMES <- toupper(removed)
[18:04:20.797]                 for (kk in seq_along(NAMES)) {
[18:04:20.797]                   name <- removed[[kk]]
[18:04:20.797]                   NAME <- NAMES[[kk]]
[18:04:20.797]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.797]                     next
[18:04:20.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.797]                 }
[18:04:20.797]                 if (length(args) > 0) 
[18:04:20.797]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.797]             }
[18:04:20.797]             else {
[18:04:20.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.797]             }
[18:04:20.797]             {
[18:04:20.797]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.797]                   0L) {
[18:04:20.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.797]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.797]                   base::options(opts)
[18:04:20.797]                 }
[18:04:20.797]                 {
[18:04:20.797]                   {
[18:04:20.797]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.797]                     NULL
[18:04:20.797]                   }
[18:04:20.797]                   options(future.plan = NULL)
[18:04:20.797]                   if (is.na(NA_character_)) 
[18:04:20.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.797]                     .init = FALSE)
[18:04:20.797]                 }
[18:04:20.797]             }
[18:04:20.797]         }
[18:04:20.797]     })
[18:04:20.797]     if (TRUE) {
[18:04:20.797]         base::sink(type = "output", split = FALSE)
[18:04:20.797]         if (TRUE) {
[18:04:20.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.797]         }
[18:04:20.797]         else {
[18:04:20.797]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.797]         }
[18:04:20.797]         base::close(...future.stdout)
[18:04:20.797]         ...future.stdout <- NULL
[18:04:20.797]     }
[18:04:20.797]     ...future.result$conditions <- ...future.conditions
[18:04:20.797]     ...future.result$finished <- base::Sys.time()
[18:04:20.797]     ...future.result
[18:04:20.797] }
[18:04:20.801] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:20.812] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.812] - Validating connection of MultisessionFuture
[18:04:20.813] - received message: FutureResult
[18:04:20.813] - Received FutureResult
[18:04:20.813] - Erased future from FutureRegistry
[18:04:20.813] result() for ClusterFuture ...
[18:04:20.814] - result already collected: FutureResult
[18:04:20.814] result() for ClusterFuture ... done
[18:04:20.814] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:20.814] result() for ClusterFuture ...
[18:04:20.814] - result already collected: FutureResult
[18:04:20.815] result() for ClusterFuture ... done
[18:04:20.815] result() for ClusterFuture ...
[18:04:20.815] - result already collected: FutureResult
[18:04:20.815] result() for ClusterFuture ... done
[18:04:20.817] MultisessionFuture started
[18:04:20.817] - Launch lazy future ... done
[18:04:20.818] run() for ‘MultisessionFuture’ ... done
<environment: 0x5e3c2c2e3478> 
<environment: 0x5e3c2d0b9eb0> 
[18:04:20.821] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.821] - Validating connection of MultisessionFuture
[18:04:20.821] - received message: FutureResult
[18:04:20.822] - Received FutureResult
[18:04:20.822] - Erased future from FutureRegistry
[18:04:20.822] result() for ClusterFuture ...
[18:04:20.822] - result already collected: FutureResult
[18:04:20.823] result() for ClusterFuture ... done
[18:04:20.823] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:20.836] resolve() on environment ...
[18:04:20.836]  recursive: 0
[18:04:20.837]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:20.837] signalConditionsASAP(numeric, pos=1) ...
[18:04:20.838] - nx: 4
[18:04:20.838] - relay: TRUE
[18:04:20.838] - stdout: TRUE
[18:04:20.838] - signal: TRUE
[18:04:20.838] - resignal: FALSE
[18:04:20.838] - force: TRUE
[18:04:20.839] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.839] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.839]  - until=2
[18:04:20.839]  - relaying element #2
[18:04:20.839] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:20.840] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.840] signalConditionsASAP(NULL, pos=1) ... done
[18:04:20.840]  length: 3 (resolved future 1)
[18:04:20.840] Future #2
[18:04:20.840] result() for ClusterFuture ...
[18:04:20.841] - result already collected: FutureResult
[18:04:20.841] result() for ClusterFuture ... done
[18:04:20.841] result() for ClusterFuture ...
[18:04:20.841] - result already collected: FutureResult
[18:04:20.841] result() for ClusterFuture ... done
[18:04:20.842] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:20.842] - nx: 4
[18:04:20.842] - relay: TRUE
[18:04:20.842] - stdout: TRUE
[18:04:20.842] - signal: TRUE
[18:04:20.843] - resignal: FALSE
[18:04:20.843] - force: TRUE
[18:04:20.843] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:20.843] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:20.843]  - until=2
[18:04:20.844]  - relaying element #2
[18:04:20.844] result() for ClusterFuture ...
[18:04:20.844] - result already collected: FutureResult
[18:04:20.844] result() for ClusterFuture ... done
[18:04:20.844] result() for ClusterFuture ...
[18:04:20.845] - result already collected: FutureResult
[18:04:20.845] result() for ClusterFuture ... done
[18:04:20.845] result() for ClusterFuture ...
[18:04:20.845] - result already collected: FutureResult
[18:04:20.845] result() for ClusterFuture ... done
[18:04:20.846] result() for ClusterFuture ...
[18:04:20.849] - result already collected: FutureResult
[18:04:20.849] result() for ClusterFuture ... done
[18:04:20.850] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:20.850] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:20.850] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:20.850]  length: 2 (resolved future 2)
[18:04:20.851] Future #3
[18:04:20.851] result() for ClusterFuture ...
[18:04:20.851] - result already collected: FutureResult
[18:04:20.851] result() for ClusterFuture ... done
[18:04:20.851] result() for ClusterFuture ...
[18:04:20.852] - result already collected: FutureResult
[18:04:20.852] result() for ClusterFuture ... done
[18:04:20.852] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:20.852] - nx: 4
[18:04:20.852] - relay: TRUE
[18:04:20.853] - stdout: TRUE
[18:04:20.853] - signal: TRUE
[18:04:20.853] - resignal: FALSE
[18:04:20.853] - force: TRUE
[18:04:20.853] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:20.854] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:20.854]  - until=3
[18:04:20.854]  - relaying element #3
[18:04:20.854] result() for ClusterFuture ...
[18:04:20.854] - result already collected: FutureResult
[18:04:20.855] result() for ClusterFuture ... done
[18:04:20.855] result() for ClusterFuture ...
[18:04:20.855] - result already collected: FutureResult
[18:04:20.855] result() for ClusterFuture ... done
[18:04:20.855] result() for ClusterFuture ...
[18:04:20.856] - result already collected: FutureResult
[18:04:20.856] result() for ClusterFuture ... done
[18:04:20.856] result() for ClusterFuture ...
[18:04:20.856] - result already collected: FutureResult
[18:04:20.856] result() for ClusterFuture ... done
[18:04:20.856] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:20.857] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:20.857] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:20.857]  length: 1 (resolved future 3)
[18:04:20.861] receiveMessageFromWorker() for ClusterFuture ...
[18:04:20.861] - Validating connection of MultisessionFuture
[18:04:20.862] - received message: FutureResult
[18:04:20.862] - Received FutureResult
[18:04:20.862] - Erased future from FutureRegistry
[18:04:20.862] result() for ClusterFuture ...
[18:04:20.863] - result already collected: FutureResult
[18:04:20.863] result() for ClusterFuture ... done
[18:04:20.863] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:20.863] Future #4
[18:04:20.863] result() for ClusterFuture ...
[18:04:20.863] - result already collected: FutureResult
[18:04:20.864] result() for ClusterFuture ... done
[18:04:20.864] result() for ClusterFuture ...
[18:04:20.864] - result already collected: FutureResult
[18:04:20.864] result() for ClusterFuture ... done
[18:04:20.864] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:20.865] - nx: 4
[18:04:20.865] - relay: TRUE
[18:04:20.865] - stdout: TRUE
[18:04:20.865] - signal: TRUE
[18:04:20.865] - resignal: FALSE
[18:04:20.866] - force: TRUE
[18:04:20.866] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:20.866] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:20.866]  - until=4
[18:04:20.866]  - relaying element #4
[18:04:20.867] result() for ClusterFuture ...
[18:04:20.867] - result already collected: FutureResult
[18:04:20.867] result() for ClusterFuture ... done
[18:04:20.867] result() for ClusterFuture ...
[18:04:20.867] - result already collected: FutureResult
[18:04:20.867] result() for ClusterFuture ... done
[18:04:20.868] result() for ClusterFuture ...
[18:04:20.868] - result already collected: FutureResult
[18:04:20.868] result() for ClusterFuture ... done
[18:04:20.868] result() for ClusterFuture ...
[18:04:20.869] - result already collected: FutureResult
[18:04:20.869] result() for ClusterFuture ... done
[18:04:20.869] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:20.869] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:20.869] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:20.870]  length: 0 (resolved future 4)
[18:04:20.870] Relaying remaining futures
[18:04:20.870] signalConditionsASAP(NULL, pos=0) ...
[18:04:20.870] - nx: 4
[18:04:20.870] - relay: TRUE
[18:04:20.871] - stdout: TRUE
[18:04:20.871] - signal: TRUE
[18:04:20.871] - resignal: FALSE
[18:04:20.871] - force: TRUE
[18:04:20.871] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:20.871] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:20.872] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:20.872] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:20.872] signalConditionsASAP(NULL, pos=0) ... done
[18:04:20.872] resolve() on environment ... DONE
[18:04:20.872] result() for ClusterFuture ...
[18:04:20.873] - result already collected: FutureResult
[18:04:20.873] result() for ClusterFuture ... done
[18:04:20.873] result() for ClusterFuture ...
[18:04:20.873] - result already collected: FutureResult
[18:04:20.873] result() for ClusterFuture ... done
[18:04:20.874] result() for ClusterFuture ...
[18:04:20.874] - result already collected: FutureResult
[18:04:20.874] result() for ClusterFuture ... done
[18:04:20.874] result() for ClusterFuture ...
[18:04:20.874] - result already collected: FutureResult
[18:04:20.875] result() for ClusterFuture ... done
[18:04:20.875] result() for ClusterFuture ...
[18:04:20.875] - result already collected: FutureResult
[18:04:20.875] result() for ClusterFuture ... done
[18:04:20.875] result() for ClusterFuture ...
[18:04:20.876] - result already collected: FutureResult
[18:04:20.876] result() for ClusterFuture ... done
<environment: 0x5e3c2d2018a8> 
Dimensions: c(2, 3, 1)
[18:04:20.877] getGlobalsAndPackages() ...
[18:04:20.877] Searching for globals...
[18:04:20.877] 
[18:04:20.878] Searching for globals ... DONE
[18:04:20.878] - globals: [0] <none>
[18:04:20.878] getGlobalsAndPackages() ... DONE
[18:04:20.879] run() for ‘Future’ ...
[18:04:20.879] - state: ‘created’
[18:04:20.879] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.903] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.903] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.903]   - Field: ‘node’
[18:04:20.904]   - Field: ‘label’
[18:04:20.904]   - Field: ‘local’
[18:04:20.904]   - Field: ‘owner’
[18:04:20.904]   - Field: ‘envir’
[18:04:20.904]   - Field: ‘workers’
[18:04:20.905]   - Field: ‘packages’
[18:04:20.905]   - Field: ‘gc’
[18:04:20.905]   - Field: ‘conditions’
[18:04:20.905]   - Field: ‘persistent’
[18:04:20.905]   - Field: ‘expr’
[18:04:20.906]   - Field: ‘uuid’
[18:04:20.906]   - Field: ‘seed’
[18:04:20.906]   - Field: ‘version’
[18:04:20.906]   - Field: ‘result’
[18:04:20.906]   - Field: ‘asynchronous’
[18:04:20.906]   - Field: ‘calls’
[18:04:20.907]   - Field: ‘globals’
[18:04:20.907]   - Field: ‘stdout’
[18:04:20.907]   - Field: ‘earlySignal’
[18:04:20.907]   - Field: ‘lazy’
[18:04:20.907]   - Field: ‘state’
[18:04:20.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.908] - Launch lazy future ...
[18:04:20.908] Packages needed by the future expression (n = 0): <none>
[18:04:20.909] Packages needed by future strategies (n = 0): <none>
[18:04:20.909] {
[18:04:20.909]     {
[18:04:20.909]         {
[18:04:20.909]             ...future.startTime <- base::Sys.time()
[18:04:20.909]             {
[18:04:20.909]                 {
[18:04:20.909]                   {
[18:04:20.909]                     {
[18:04:20.909]                       base::local({
[18:04:20.909]                         has_future <- base::requireNamespace("future", 
[18:04:20.909]                           quietly = TRUE)
[18:04:20.909]                         if (has_future) {
[18:04:20.909]                           ns <- base::getNamespace("future")
[18:04:20.909]                           version <- ns[[".package"]][["version"]]
[18:04:20.909]                           if (is.null(version)) 
[18:04:20.909]                             version <- utils::packageVersion("future")
[18:04:20.909]                         }
[18:04:20.909]                         else {
[18:04:20.909]                           version <- NULL
[18:04:20.909]                         }
[18:04:20.909]                         if (!has_future || version < "1.8.0") {
[18:04:20.909]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.909]                             "", base::R.version$version.string), 
[18:04:20.909]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.909]                               "release", "version")], collapse = " "), 
[18:04:20.909]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.909]                             info)
[18:04:20.909]                           info <- base::paste(info, collapse = "; ")
[18:04:20.909]                           if (!has_future) {
[18:04:20.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.909]                               info)
[18:04:20.909]                           }
[18:04:20.909]                           else {
[18:04:20.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.909]                               info, version)
[18:04:20.909]                           }
[18:04:20.909]                           base::stop(msg)
[18:04:20.909]                         }
[18:04:20.909]                       })
[18:04:20.909]                     }
[18:04:20.909]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.909]                     base::options(mc.cores = 1L)
[18:04:20.909]                   }
[18:04:20.909]                   ...future.strategy.old <- future::plan("list")
[18:04:20.909]                   options(future.plan = NULL)
[18:04:20.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.909]                 }
[18:04:20.909]                 ...future.workdir <- getwd()
[18:04:20.909]             }
[18:04:20.909]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.909]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.909]         }
[18:04:20.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.909]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.909]             base::names(...future.oldOptions))
[18:04:20.909]     }
[18:04:20.909]     if (FALSE) {
[18:04:20.909]     }
[18:04:20.909]     else {
[18:04:20.909]         if (TRUE) {
[18:04:20.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.909]                 open = "w")
[18:04:20.909]         }
[18:04:20.909]         else {
[18:04:20.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.909]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.909]         }
[18:04:20.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.909]             base::sink(type = "output", split = FALSE)
[18:04:20.909]             base::close(...future.stdout)
[18:04:20.909]         }, add = TRUE)
[18:04:20.909]     }
[18:04:20.909]     ...future.frame <- base::sys.nframe()
[18:04:20.909]     ...future.conditions <- base::list()
[18:04:20.909]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.909]     if (FALSE) {
[18:04:20.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.909]     }
[18:04:20.909]     ...future.result <- base::tryCatch({
[18:04:20.909]         base::withCallingHandlers({
[18:04:20.909]             ...future.value <- base::withVisible(base::local({
[18:04:20.909]                 ...future.makeSendCondition <- base::local({
[18:04:20.909]                   sendCondition <- NULL
[18:04:20.909]                   function(frame = 1L) {
[18:04:20.909]                     if (is.function(sendCondition)) 
[18:04:20.909]                       return(sendCondition)
[18:04:20.909]                     ns <- getNamespace("parallel")
[18:04:20.909]                     if (exists("sendData", mode = "function", 
[18:04:20.909]                       envir = ns)) {
[18:04:20.909]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.909]                         envir = ns)
[18:04:20.909]                       envir <- sys.frame(frame)
[18:04:20.909]                       master <- NULL
[18:04:20.909]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.909]                         !identical(envir, emptyenv())) {
[18:04:20.909]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.909]                           inherits = FALSE)) {
[18:04:20.909]                           master <- get("master", mode = "list", 
[18:04:20.909]                             envir = envir, inherits = FALSE)
[18:04:20.909]                           if (inherits(master, c("SOCKnode", 
[18:04:20.909]                             "SOCK0node"))) {
[18:04:20.909]                             sendCondition <<- function(cond) {
[18:04:20.909]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.909]                                 success = TRUE)
[18:04:20.909]                               parallel_sendData(master, data)
[18:04:20.909]                             }
[18:04:20.909]                             return(sendCondition)
[18:04:20.909]                           }
[18:04:20.909]                         }
[18:04:20.909]                         frame <- frame + 1L
[18:04:20.909]                         envir <- sys.frame(frame)
[18:04:20.909]                       }
[18:04:20.909]                     }
[18:04:20.909]                     sendCondition <<- function(cond) NULL
[18:04:20.909]                   }
[18:04:20.909]                 })
[18:04:20.909]                 withCallingHandlers({
[18:04:20.909]                   2
[18:04:20.909]                 }, immediateCondition = function(cond) {
[18:04:20.909]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.909]                   sendCondition(cond)
[18:04:20.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.909]                   {
[18:04:20.909]                     inherits <- base::inherits
[18:04:20.909]                     invokeRestart <- base::invokeRestart
[18:04:20.909]                     is.null <- base::is.null
[18:04:20.909]                     muffled <- FALSE
[18:04:20.909]                     if (inherits(cond, "message")) {
[18:04:20.909]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.909]                       if (muffled) 
[18:04:20.909]                         invokeRestart("muffleMessage")
[18:04:20.909]                     }
[18:04:20.909]                     else if (inherits(cond, "warning")) {
[18:04:20.909]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.909]                       if (muffled) 
[18:04:20.909]                         invokeRestart("muffleWarning")
[18:04:20.909]                     }
[18:04:20.909]                     else if (inherits(cond, "condition")) {
[18:04:20.909]                       if (!is.null(pattern)) {
[18:04:20.909]                         computeRestarts <- base::computeRestarts
[18:04:20.909]                         grepl <- base::grepl
[18:04:20.909]                         restarts <- computeRestarts(cond)
[18:04:20.909]                         for (restart in restarts) {
[18:04:20.909]                           name <- restart$name
[18:04:20.909]                           if (is.null(name)) 
[18:04:20.909]                             next
[18:04:20.909]                           if (!grepl(pattern, name)) 
[18:04:20.909]                             next
[18:04:20.909]                           invokeRestart(restart)
[18:04:20.909]                           muffled <- TRUE
[18:04:20.909]                           break
[18:04:20.909]                         }
[18:04:20.909]                       }
[18:04:20.909]                     }
[18:04:20.909]                     invisible(muffled)
[18:04:20.909]                   }
[18:04:20.909]                   muffleCondition(cond)
[18:04:20.909]                 })
[18:04:20.909]             }))
[18:04:20.909]             future::FutureResult(value = ...future.value$value, 
[18:04:20.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.909]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.909]                     ...future.globalenv.names))
[18:04:20.909]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.909]         }, condition = base::local({
[18:04:20.909]             c <- base::c
[18:04:20.909]             inherits <- base::inherits
[18:04:20.909]             invokeRestart <- base::invokeRestart
[18:04:20.909]             length <- base::length
[18:04:20.909]             list <- base::list
[18:04:20.909]             seq.int <- base::seq.int
[18:04:20.909]             signalCondition <- base::signalCondition
[18:04:20.909]             sys.calls <- base::sys.calls
[18:04:20.909]             `[[` <- base::`[[`
[18:04:20.909]             `+` <- base::`+`
[18:04:20.909]             `<<-` <- base::`<<-`
[18:04:20.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.909]                   3L)]
[18:04:20.909]             }
[18:04:20.909]             function(cond) {
[18:04:20.909]                 is_error <- inherits(cond, "error")
[18:04:20.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.909]                   NULL)
[18:04:20.909]                 if (is_error) {
[18:04:20.909]                   sessionInformation <- function() {
[18:04:20.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.909]                       search = base::search(), system = base::Sys.info())
[18:04:20.909]                   }
[18:04:20.909]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.909]                     cond$call), session = sessionInformation(), 
[18:04:20.909]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.909]                   signalCondition(cond)
[18:04:20.909]                 }
[18:04:20.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.909]                 "immediateCondition"))) {
[18:04:20.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.909]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.909]                   if (TRUE && !signal) {
[18:04:20.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.909]                     {
[18:04:20.909]                       inherits <- base::inherits
[18:04:20.909]                       invokeRestart <- base::invokeRestart
[18:04:20.909]                       is.null <- base::is.null
[18:04:20.909]                       muffled <- FALSE
[18:04:20.909]                       if (inherits(cond, "message")) {
[18:04:20.909]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.909]                         if (muffled) 
[18:04:20.909]                           invokeRestart("muffleMessage")
[18:04:20.909]                       }
[18:04:20.909]                       else if (inherits(cond, "warning")) {
[18:04:20.909]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.909]                         if (muffled) 
[18:04:20.909]                           invokeRestart("muffleWarning")
[18:04:20.909]                       }
[18:04:20.909]                       else if (inherits(cond, "condition")) {
[18:04:20.909]                         if (!is.null(pattern)) {
[18:04:20.909]                           computeRestarts <- base::computeRestarts
[18:04:20.909]                           grepl <- base::grepl
[18:04:20.909]                           restarts <- computeRestarts(cond)
[18:04:20.909]                           for (restart in restarts) {
[18:04:20.909]                             name <- restart$name
[18:04:20.909]                             if (is.null(name)) 
[18:04:20.909]                               next
[18:04:20.909]                             if (!grepl(pattern, name)) 
[18:04:20.909]                               next
[18:04:20.909]                             invokeRestart(restart)
[18:04:20.909]                             muffled <- TRUE
[18:04:20.909]                             break
[18:04:20.909]                           }
[18:04:20.909]                         }
[18:04:20.909]                       }
[18:04:20.909]                       invisible(muffled)
[18:04:20.909]                     }
[18:04:20.909]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.909]                   }
[18:04:20.909]                 }
[18:04:20.909]                 else {
[18:04:20.909]                   if (TRUE) {
[18:04:20.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.909]                     {
[18:04:20.909]                       inherits <- base::inherits
[18:04:20.909]                       invokeRestart <- base::invokeRestart
[18:04:20.909]                       is.null <- base::is.null
[18:04:20.909]                       muffled <- FALSE
[18:04:20.909]                       if (inherits(cond, "message")) {
[18:04:20.909]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.909]                         if (muffled) 
[18:04:20.909]                           invokeRestart("muffleMessage")
[18:04:20.909]                       }
[18:04:20.909]                       else if (inherits(cond, "warning")) {
[18:04:20.909]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.909]                         if (muffled) 
[18:04:20.909]                           invokeRestart("muffleWarning")
[18:04:20.909]                       }
[18:04:20.909]                       else if (inherits(cond, "condition")) {
[18:04:20.909]                         if (!is.null(pattern)) {
[18:04:20.909]                           computeRestarts <- base::computeRestarts
[18:04:20.909]                           grepl <- base::grepl
[18:04:20.909]                           restarts <- computeRestarts(cond)
[18:04:20.909]                           for (restart in restarts) {
[18:04:20.909]                             name <- restart$name
[18:04:20.909]                             if (is.null(name)) 
[18:04:20.909]                               next
[18:04:20.909]                             if (!grepl(pattern, name)) 
[18:04:20.909]                               next
[18:04:20.909]                             invokeRestart(restart)
[18:04:20.909]                             muffled <- TRUE
[18:04:20.909]                             break
[18:04:20.909]                           }
[18:04:20.909]                         }
[18:04:20.909]                       }
[18:04:20.909]                       invisible(muffled)
[18:04:20.909]                     }
[18:04:20.909]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.909]                   }
[18:04:20.909]                 }
[18:04:20.909]             }
[18:04:20.909]         }))
[18:04:20.909]     }, error = function(ex) {
[18:04:20.909]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.909]                 ...future.rng), started = ...future.startTime, 
[18:04:20.909]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.909]             version = "1.8"), class = "FutureResult")
[18:04:20.909]     }, finally = {
[18:04:20.909]         if (!identical(...future.workdir, getwd())) 
[18:04:20.909]             setwd(...future.workdir)
[18:04:20.909]         {
[18:04:20.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.909]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.909]             }
[18:04:20.909]             base::options(...future.oldOptions)
[18:04:20.909]             if (.Platform$OS.type == "windows") {
[18:04:20.909]                 old_names <- names(...future.oldEnvVars)
[18:04:20.909]                 envs <- base::Sys.getenv()
[18:04:20.909]                 names <- names(envs)
[18:04:20.909]                 common <- intersect(names, old_names)
[18:04:20.909]                 added <- setdiff(names, old_names)
[18:04:20.909]                 removed <- setdiff(old_names, names)
[18:04:20.909]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.909]                   envs[common]]
[18:04:20.909]                 NAMES <- toupper(changed)
[18:04:20.909]                 args <- list()
[18:04:20.909]                 for (kk in seq_along(NAMES)) {
[18:04:20.909]                   name <- changed[[kk]]
[18:04:20.909]                   NAME <- NAMES[[kk]]
[18:04:20.909]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.909]                     next
[18:04:20.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.909]                 }
[18:04:20.909]                 NAMES <- toupper(added)
[18:04:20.909]                 for (kk in seq_along(NAMES)) {
[18:04:20.909]                   name <- added[[kk]]
[18:04:20.909]                   NAME <- NAMES[[kk]]
[18:04:20.909]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.909]                     next
[18:04:20.909]                   args[[name]] <- ""
[18:04:20.909]                 }
[18:04:20.909]                 NAMES <- toupper(removed)
[18:04:20.909]                 for (kk in seq_along(NAMES)) {
[18:04:20.909]                   name <- removed[[kk]]
[18:04:20.909]                   NAME <- NAMES[[kk]]
[18:04:20.909]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.909]                     next
[18:04:20.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.909]                 }
[18:04:20.909]                 if (length(args) > 0) 
[18:04:20.909]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.909]             }
[18:04:20.909]             else {
[18:04:20.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.909]             }
[18:04:20.909]             {
[18:04:20.909]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.909]                   0L) {
[18:04:20.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.909]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.909]                   base::options(opts)
[18:04:20.909]                 }
[18:04:20.909]                 {
[18:04:20.909]                   {
[18:04:20.909]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.909]                     NULL
[18:04:20.909]                   }
[18:04:20.909]                   options(future.plan = NULL)
[18:04:20.909]                   if (is.na(NA_character_)) 
[18:04:20.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.909]                     .init = FALSE)
[18:04:20.909]                 }
[18:04:20.909]             }
[18:04:20.909]         }
[18:04:20.909]     })
[18:04:20.909]     if (TRUE) {
[18:04:20.909]         base::sink(type = "output", split = FALSE)
[18:04:20.909]         if (TRUE) {
[18:04:20.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.909]         }
[18:04:20.909]         else {
[18:04:20.909]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.909]         }
[18:04:20.909]         base::close(...future.stdout)
[18:04:20.909]         ...future.stdout <- NULL
[18:04:20.909]     }
[18:04:20.909]     ...future.result$conditions <- ...future.conditions
[18:04:20.909]     ...future.result$finished <- base::Sys.time()
[18:04:20.909]     ...future.result
[18:04:20.909] }
[18:04:20.915] MultisessionFuture started
[18:04:20.915] - Launch lazy future ... done
[18:04:20.916] run() for ‘MultisessionFuture’ ... done
[18:04:20.916] getGlobalsAndPackages() ...
[18:04:20.916] Searching for globals...
[18:04:20.917] 
[18:04:20.917] Searching for globals ... DONE
[18:04:20.917] - globals: [0] <none>
[18:04:20.917] getGlobalsAndPackages() ... DONE
[18:04:20.918] run() for ‘Future’ ...
[18:04:20.918] - state: ‘created’
[18:04:20.918] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.942] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.943] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.943]   - Field: ‘node’
[18:04:20.943]   - Field: ‘label’
[18:04:20.943]   - Field: ‘local’
[18:04:20.944]   - Field: ‘owner’
[18:04:20.944]   - Field: ‘envir’
[18:04:20.944]   - Field: ‘workers’
[18:04:20.944]   - Field: ‘packages’
[18:04:20.945]   - Field: ‘gc’
[18:04:20.945]   - Field: ‘conditions’
[18:04:20.945]   - Field: ‘persistent’
[18:04:20.945]   - Field: ‘expr’
[18:04:20.945]   - Field: ‘uuid’
[18:04:20.946]   - Field: ‘seed’
[18:04:20.946]   - Field: ‘version’
[18:04:20.946]   - Field: ‘result’
[18:04:20.946]   - Field: ‘asynchronous’
[18:04:20.946]   - Field: ‘calls’
[18:04:20.947]   - Field: ‘globals’
[18:04:20.947]   - Field: ‘stdout’
[18:04:20.947]   - Field: ‘earlySignal’
[18:04:20.947]   - Field: ‘lazy’
[18:04:20.948]   - Field: ‘state’
[18:04:20.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.948] - Launch lazy future ...
[18:04:20.949] Packages needed by the future expression (n = 0): <none>
[18:04:20.949] Packages needed by future strategies (n = 0): <none>
[18:04:20.950] {
[18:04:20.950]     {
[18:04:20.950]         {
[18:04:20.950]             ...future.startTime <- base::Sys.time()
[18:04:20.950]             {
[18:04:20.950]                 {
[18:04:20.950]                   {
[18:04:20.950]                     {
[18:04:20.950]                       base::local({
[18:04:20.950]                         has_future <- base::requireNamespace("future", 
[18:04:20.950]                           quietly = TRUE)
[18:04:20.950]                         if (has_future) {
[18:04:20.950]                           ns <- base::getNamespace("future")
[18:04:20.950]                           version <- ns[[".package"]][["version"]]
[18:04:20.950]                           if (is.null(version)) 
[18:04:20.950]                             version <- utils::packageVersion("future")
[18:04:20.950]                         }
[18:04:20.950]                         else {
[18:04:20.950]                           version <- NULL
[18:04:20.950]                         }
[18:04:20.950]                         if (!has_future || version < "1.8.0") {
[18:04:20.950]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.950]                             "", base::R.version$version.string), 
[18:04:20.950]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.950]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.950]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.950]                               "release", "version")], collapse = " "), 
[18:04:20.950]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.950]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.950]                             info)
[18:04:20.950]                           info <- base::paste(info, collapse = "; ")
[18:04:20.950]                           if (!has_future) {
[18:04:20.950]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.950]                               info)
[18:04:20.950]                           }
[18:04:20.950]                           else {
[18:04:20.950]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.950]                               info, version)
[18:04:20.950]                           }
[18:04:20.950]                           base::stop(msg)
[18:04:20.950]                         }
[18:04:20.950]                       })
[18:04:20.950]                     }
[18:04:20.950]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.950]                     base::options(mc.cores = 1L)
[18:04:20.950]                   }
[18:04:20.950]                   ...future.strategy.old <- future::plan("list")
[18:04:20.950]                   options(future.plan = NULL)
[18:04:20.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.950]                 }
[18:04:20.950]                 ...future.workdir <- getwd()
[18:04:20.950]             }
[18:04:20.950]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.950]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.950]         }
[18:04:20.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.950]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.950]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.950]             base::names(...future.oldOptions))
[18:04:20.950]     }
[18:04:20.950]     if (FALSE) {
[18:04:20.950]     }
[18:04:20.950]     else {
[18:04:20.950]         if (TRUE) {
[18:04:20.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.950]                 open = "w")
[18:04:20.950]         }
[18:04:20.950]         else {
[18:04:20.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.950]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.950]         }
[18:04:20.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.950]             base::sink(type = "output", split = FALSE)
[18:04:20.950]             base::close(...future.stdout)
[18:04:20.950]         }, add = TRUE)
[18:04:20.950]     }
[18:04:20.950]     ...future.frame <- base::sys.nframe()
[18:04:20.950]     ...future.conditions <- base::list()
[18:04:20.950]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.950]     if (FALSE) {
[18:04:20.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.950]     }
[18:04:20.950]     ...future.result <- base::tryCatch({
[18:04:20.950]         base::withCallingHandlers({
[18:04:20.950]             ...future.value <- base::withVisible(base::local({
[18:04:20.950]                 ...future.makeSendCondition <- base::local({
[18:04:20.950]                   sendCondition <- NULL
[18:04:20.950]                   function(frame = 1L) {
[18:04:20.950]                     if (is.function(sendCondition)) 
[18:04:20.950]                       return(sendCondition)
[18:04:20.950]                     ns <- getNamespace("parallel")
[18:04:20.950]                     if (exists("sendData", mode = "function", 
[18:04:20.950]                       envir = ns)) {
[18:04:20.950]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.950]                         envir = ns)
[18:04:20.950]                       envir <- sys.frame(frame)
[18:04:20.950]                       master <- NULL
[18:04:20.950]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.950]                         !identical(envir, emptyenv())) {
[18:04:20.950]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.950]                           inherits = FALSE)) {
[18:04:20.950]                           master <- get("master", mode = "list", 
[18:04:20.950]                             envir = envir, inherits = FALSE)
[18:04:20.950]                           if (inherits(master, c("SOCKnode", 
[18:04:20.950]                             "SOCK0node"))) {
[18:04:20.950]                             sendCondition <<- function(cond) {
[18:04:20.950]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.950]                                 success = TRUE)
[18:04:20.950]                               parallel_sendData(master, data)
[18:04:20.950]                             }
[18:04:20.950]                             return(sendCondition)
[18:04:20.950]                           }
[18:04:20.950]                         }
[18:04:20.950]                         frame <- frame + 1L
[18:04:20.950]                         envir <- sys.frame(frame)
[18:04:20.950]                       }
[18:04:20.950]                     }
[18:04:20.950]                     sendCondition <<- function(cond) NULL
[18:04:20.950]                   }
[18:04:20.950]                 })
[18:04:20.950]                 withCallingHandlers({
[18:04:20.950]                   NULL
[18:04:20.950]                 }, immediateCondition = function(cond) {
[18:04:20.950]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.950]                   sendCondition(cond)
[18:04:20.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.950]                   {
[18:04:20.950]                     inherits <- base::inherits
[18:04:20.950]                     invokeRestart <- base::invokeRestart
[18:04:20.950]                     is.null <- base::is.null
[18:04:20.950]                     muffled <- FALSE
[18:04:20.950]                     if (inherits(cond, "message")) {
[18:04:20.950]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.950]                       if (muffled) 
[18:04:20.950]                         invokeRestart("muffleMessage")
[18:04:20.950]                     }
[18:04:20.950]                     else if (inherits(cond, "warning")) {
[18:04:20.950]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.950]                       if (muffled) 
[18:04:20.950]                         invokeRestart("muffleWarning")
[18:04:20.950]                     }
[18:04:20.950]                     else if (inherits(cond, "condition")) {
[18:04:20.950]                       if (!is.null(pattern)) {
[18:04:20.950]                         computeRestarts <- base::computeRestarts
[18:04:20.950]                         grepl <- base::grepl
[18:04:20.950]                         restarts <- computeRestarts(cond)
[18:04:20.950]                         for (restart in restarts) {
[18:04:20.950]                           name <- restart$name
[18:04:20.950]                           if (is.null(name)) 
[18:04:20.950]                             next
[18:04:20.950]                           if (!grepl(pattern, name)) 
[18:04:20.950]                             next
[18:04:20.950]                           invokeRestart(restart)
[18:04:20.950]                           muffled <- TRUE
[18:04:20.950]                           break
[18:04:20.950]                         }
[18:04:20.950]                       }
[18:04:20.950]                     }
[18:04:20.950]                     invisible(muffled)
[18:04:20.950]                   }
[18:04:20.950]                   muffleCondition(cond)
[18:04:20.950]                 })
[18:04:20.950]             }))
[18:04:20.950]             future::FutureResult(value = ...future.value$value, 
[18:04:20.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.950]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.950]                     ...future.globalenv.names))
[18:04:20.950]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.950]         }, condition = base::local({
[18:04:20.950]             c <- base::c
[18:04:20.950]             inherits <- base::inherits
[18:04:20.950]             invokeRestart <- base::invokeRestart
[18:04:20.950]             length <- base::length
[18:04:20.950]             list <- base::list
[18:04:20.950]             seq.int <- base::seq.int
[18:04:20.950]             signalCondition <- base::signalCondition
[18:04:20.950]             sys.calls <- base::sys.calls
[18:04:20.950]             `[[` <- base::`[[`
[18:04:20.950]             `+` <- base::`+`
[18:04:20.950]             `<<-` <- base::`<<-`
[18:04:20.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.950]                   3L)]
[18:04:20.950]             }
[18:04:20.950]             function(cond) {
[18:04:20.950]                 is_error <- inherits(cond, "error")
[18:04:20.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.950]                   NULL)
[18:04:20.950]                 if (is_error) {
[18:04:20.950]                   sessionInformation <- function() {
[18:04:20.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.950]                       search = base::search(), system = base::Sys.info())
[18:04:20.950]                   }
[18:04:20.950]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.950]                     cond$call), session = sessionInformation(), 
[18:04:20.950]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.950]                   signalCondition(cond)
[18:04:20.950]                 }
[18:04:20.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.950]                 "immediateCondition"))) {
[18:04:20.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.950]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.950]                   if (TRUE && !signal) {
[18:04:20.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.950]                     {
[18:04:20.950]                       inherits <- base::inherits
[18:04:20.950]                       invokeRestart <- base::invokeRestart
[18:04:20.950]                       is.null <- base::is.null
[18:04:20.950]                       muffled <- FALSE
[18:04:20.950]                       if (inherits(cond, "message")) {
[18:04:20.950]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.950]                         if (muffled) 
[18:04:20.950]                           invokeRestart("muffleMessage")
[18:04:20.950]                       }
[18:04:20.950]                       else if (inherits(cond, "warning")) {
[18:04:20.950]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.950]                         if (muffled) 
[18:04:20.950]                           invokeRestart("muffleWarning")
[18:04:20.950]                       }
[18:04:20.950]                       else if (inherits(cond, "condition")) {
[18:04:20.950]                         if (!is.null(pattern)) {
[18:04:20.950]                           computeRestarts <- base::computeRestarts
[18:04:20.950]                           grepl <- base::grepl
[18:04:20.950]                           restarts <- computeRestarts(cond)
[18:04:20.950]                           for (restart in restarts) {
[18:04:20.950]                             name <- restart$name
[18:04:20.950]                             if (is.null(name)) 
[18:04:20.950]                               next
[18:04:20.950]                             if (!grepl(pattern, name)) 
[18:04:20.950]                               next
[18:04:20.950]                             invokeRestart(restart)
[18:04:20.950]                             muffled <- TRUE
[18:04:20.950]                             break
[18:04:20.950]                           }
[18:04:20.950]                         }
[18:04:20.950]                       }
[18:04:20.950]                       invisible(muffled)
[18:04:20.950]                     }
[18:04:20.950]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.950]                   }
[18:04:20.950]                 }
[18:04:20.950]                 else {
[18:04:20.950]                   if (TRUE) {
[18:04:20.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.950]                     {
[18:04:20.950]                       inherits <- base::inherits
[18:04:20.950]                       invokeRestart <- base::invokeRestart
[18:04:20.950]                       is.null <- base::is.null
[18:04:20.950]                       muffled <- FALSE
[18:04:20.950]                       if (inherits(cond, "message")) {
[18:04:20.950]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.950]                         if (muffled) 
[18:04:20.950]                           invokeRestart("muffleMessage")
[18:04:20.950]                       }
[18:04:20.950]                       else if (inherits(cond, "warning")) {
[18:04:20.950]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.950]                         if (muffled) 
[18:04:20.950]                           invokeRestart("muffleWarning")
[18:04:20.950]                       }
[18:04:20.950]                       else if (inherits(cond, "condition")) {
[18:04:20.950]                         if (!is.null(pattern)) {
[18:04:20.950]                           computeRestarts <- base::computeRestarts
[18:04:20.950]                           grepl <- base::grepl
[18:04:20.950]                           restarts <- computeRestarts(cond)
[18:04:20.950]                           for (restart in restarts) {
[18:04:20.950]                             name <- restart$name
[18:04:20.950]                             if (is.null(name)) 
[18:04:20.950]                               next
[18:04:20.950]                             if (!grepl(pattern, name)) 
[18:04:20.950]                               next
[18:04:20.950]                             invokeRestart(restart)
[18:04:20.950]                             muffled <- TRUE
[18:04:20.950]                             break
[18:04:20.950]                           }
[18:04:20.950]                         }
[18:04:20.950]                       }
[18:04:20.950]                       invisible(muffled)
[18:04:20.950]                     }
[18:04:20.950]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.950]                   }
[18:04:20.950]                 }
[18:04:20.950]             }
[18:04:20.950]         }))
[18:04:20.950]     }, error = function(ex) {
[18:04:20.950]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.950]                 ...future.rng), started = ...future.startTime, 
[18:04:20.950]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.950]             version = "1.8"), class = "FutureResult")
[18:04:20.950]     }, finally = {
[18:04:20.950]         if (!identical(...future.workdir, getwd())) 
[18:04:20.950]             setwd(...future.workdir)
[18:04:20.950]         {
[18:04:20.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.950]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.950]             }
[18:04:20.950]             base::options(...future.oldOptions)
[18:04:20.950]             if (.Platform$OS.type == "windows") {
[18:04:20.950]                 old_names <- names(...future.oldEnvVars)
[18:04:20.950]                 envs <- base::Sys.getenv()
[18:04:20.950]                 names <- names(envs)
[18:04:20.950]                 common <- intersect(names, old_names)
[18:04:20.950]                 added <- setdiff(names, old_names)
[18:04:20.950]                 removed <- setdiff(old_names, names)
[18:04:20.950]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.950]                   envs[common]]
[18:04:20.950]                 NAMES <- toupper(changed)
[18:04:20.950]                 args <- list()
[18:04:20.950]                 for (kk in seq_along(NAMES)) {
[18:04:20.950]                   name <- changed[[kk]]
[18:04:20.950]                   NAME <- NAMES[[kk]]
[18:04:20.950]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.950]                     next
[18:04:20.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.950]                 }
[18:04:20.950]                 NAMES <- toupper(added)
[18:04:20.950]                 for (kk in seq_along(NAMES)) {
[18:04:20.950]                   name <- added[[kk]]
[18:04:20.950]                   NAME <- NAMES[[kk]]
[18:04:20.950]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.950]                     next
[18:04:20.950]                   args[[name]] <- ""
[18:04:20.950]                 }
[18:04:20.950]                 NAMES <- toupper(removed)
[18:04:20.950]                 for (kk in seq_along(NAMES)) {
[18:04:20.950]                   name <- removed[[kk]]
[18:04:20.950]                   NAME <- NAMES[[kk]]
[18:04:20.950]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.950]                     next
[18:04:20.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.950]                 }
[18:04:20.950]                 if (length(args) > 0) 
[18:04:20.950]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.950]             }
[18:04:20.950]             else {
[18:04:20.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.950]             }
[18:04:20.950]             {
[18:04:20.950]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.950]                   0L) {
[18:04:20.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.950]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.950]                   base::options(opts)
[18:04:20.950]                 }
[18:04:20.950]                 {
[18:04:20.950]                   {
[18:04:20.950]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.950]                     NULL
[18:04:20.950]                   }
[18:04:20.950]                   options(future.plan = NULL)
[18:04:20.950]                   if (is.na(NA_character_)) 
[18:04:20.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.950]                     .init = FALSE)
[18:04:20.950]                 }
[18:04:20.950]             }
[18:04:20.950]         }
[18:04:20.950]     })
[18:04:20.950]     if (TRUE) {
[18:04:20.950]         base::sink(type = "output", split = FALSE)
[18:04:20.950]         if (TRUE) {
[18:04:20.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.950]         }
[18:04:20.950]         else {
[18:04:20.950]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.950]         }
[18:04:20.950]         base::close(...future.stdout)
[18:04:20.950]         ...future.stdout <- NULL
[18:04:20.950]     }
[18:04:20.950]     ...future.result$conditions <- ...future.conditions
[18:04:20.950]     ...future.result$finished <- base::Sys.time()
[18:04:20.950]     ...future.result
[18:04:20.950] }
[18:04:20.956] MultisessionFuture started
[18:04:20.956] - Launch lazy future ... done
[18:04:20.956] run() for ‘MultisessionFuture’ ... done
[18:04:20.958] getGlobalsAndPackages() ...
[18:04:20.958] Searching for globals...
[18:04:20.959] - globals found: [1] ‘{’
[18:04:20.959] Searching for globals ... DONE
[18:04:20.959] Resolving globals: FALSE
[18:04:20.960] 
[18:04:20.960] 
[18:04:20.960] getGlobalsAndPackages() ... DONE
[18:04:20.961] run() for ‘Future’ ...
[18:04:20.961] - state: ‘created’
[18:04:20.961] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:20.985] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:20.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:20.985]   - Field: ‘node’
[18:04:20.986]   - Field: ‘label’
[18:04:20.986]   - Field: ‘local’
[18:04:20.986]   - Field: ‘owner’
[18:04:20.986]   - Field: ‘envir’
[18:04:20.986]   - Field: ‘workers’
[18:04:20.987]   - Field: ‘packages’
[18:04:20.987]   - Field: ‘gc’
[18:04:20.987]   - Field: ‘conditions’
[18:04:20.987]   - Field: ‘persistent’
[18:04:20.987]   - Field: ‘expr’
[18:04:20.988]   - Field: ‘uuid’
[18:04:20.988]   - Field: ‘seed’
[18:04:20.988]   - Field: ‘version’
[18:04:20.988]   - Field: ‘result’
[18:04:20.988]   - Field: ‘asynchronous’
[18:04:20.989]   - Field: ‘calls’
[18:04:20.989]   - Field: ‘globals’
[18:04:20.989]   - Field: ‘stdout’
[18:04:20.989]   - Field: ‘earlySignal’
[18:04:20.989]   - Field: ‘lazy’
[18:04:20.990]   - Field: ‘state’
[18:04:20.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:20.990] - Launch lazy future ...
[18:04:20.991] Packages needed by the future expression (n = 0): <none>
[18:04:20.991] Packages needed by future strategies (n = 0): <none>
[18:04:20.992] {
[18:04:20.992]     {
[18:04:20.992]         {
[18:04:20.992]             ...future.startTime <- base::Sys.time()
[18:04:20.992]             {
[18:04:20.992]                 {
[18:04:20.992]                   {
[18:04:20.992]                     {
[18:04:20.992]                       base::local({
[18:04:20.992]                         has_future <- base::requireNamespace("future", 
[18:04:20.992]                           quietly = TRUE)
[18:04:20.992]                         if (has_future) {
[18:04:20.992]                           ns <- base::getNamespace("future")
[18:04:20.992]                           version <- ns[[".package"]][["version"]]
[18:04:20.992]                           if (is.null(version)) 
[18:04:20.992]                             version <- utils::packageVersion("future")
[18:04:20.992]                         }
[18:04:20.992]                         else {
[18:04:20.992]                           version <- NULL
[18:04:20.992]                         }
[18:04:20.992]                         if (!has_future || version < "1.8.0") {
[18:04:20.992]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:20.992]                             "", base::R.version$version.string), 
[18:04:20.992]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:20.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:20.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:20.992]                               "release", "version")], collapse = " "), 
[18:04:20.992]                             hostname = base::Sys.info()[["nodename"]])
[18:04:20.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:20.992]                             info)
[18:04:20.992]                           info <- base::paste(info, collapse = "; ")
[18:04:20.992]                           if (!has_future) {
[18:04:20.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:20.992]                               info)
[18:04:20.992]                           }
[18:04:20.992]                           else {
[18:04:20.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:20.992]                               info, version)
[18:04:20.992]                           }
[18:04:20.992]                           base::stop(msg)
[18:04:20.992]                         }
[18:04:20.992]                       })
[18:04:20.992]                     }
[18:04:20.992]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:20.992]                     base::options(mc.cores = 1L)
[18:04:20.992]                   }
[18:04:20.992]                   ...future.strategy.old <- future::plan("list")
[18:04:20.992]                   options(future.plan = NULL)
[18:04:20.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:20.992]                 }
[18:04:20.992]                 ...future.workdir <- getwd()
[18:04:20.992]             }
[18:04:20.992]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:20.992]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:20.992]         }
[18:04:20.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:20.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:20.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:20.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:20.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:20.992]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:20.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:20.992]             base::names(...future.oldOptions))
[18:04:20.992]     }
[18:04:20.992]     if (FALSE) {
[18:04:20.992]     }
[18:04:20.992]     else {
[18:04:20.992]         if (TRUE) {
[18:04:20.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:20.992]                 open = "w")
[18:04:20.992]         }
[18:04:20.992]         else {
[18:04:20.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:20.992]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:20.992]         }
[18:04:20.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:20.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:20.992]             base::sink(type = "output", split = FALSE)
[18:04:20.992]             base::close(...future.stdout)
[18:04:20.992]         }, add = TRUE)
[18:04:20.992]     }
[18:04:20.992]     ...future.frame <- base::sys.nframe()
[18:04:20.992]     ...future.conditions <- base::list()
[18:04:20.992]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:20.992]     if (FALSE) {
[18:04:20.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:20.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:20.992]     }
[18:04:20.992]     ...future.result <- base::tryCatch({
[18:04:20.992]         base::withCallingHandlers({
[18:04:20.992]             ...future.value <- base::withVisible(base::local({
[18:04:20.992]                 ...future.makeSendCondition <- base::local({
[18:04:20.992]                   sendCondition <- NULL
[18:04:20.992]                   function(frame = 1L) {
[18:04:20.992]                     if (is.function(sendCondition)) 
[18:04:20.992]                       return(sendCondition)
[18:04:20.992]                     ns <- getNamespace("parallel")
[18:04:20.992]                     if (exists("sendData", mode = "function", 
[18:04:20.992]                       envir = ns)) {
[18:04:20.992]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:20.992]                         envir = ns)
[18:04:20.992]                       envir <- sys.frame(frame)
[18:04:20.992]                       master <- NULL
[18:04:20.992]                       while (!identical(envir, .GlobalEnv) && 
[18:04:20.992]                         !identical(envir, emptyenv())) {
[18:04:20.992]                         if (exists("master", mode = "list", envir = envir, 
[18:04:20.992]                           inherits = FALSE)) {
[18:04:20.992]                           master <- get("master", mode = "list", 
[18:04:20.992]                             envir = envir, inherits = FALSE)
[18:04:20.992]                           if (inherits(master, c("SOCKnode", 
[18:04:20.992]                             "SOCK0node"))) {
[18:04:20.992]                             sendCondition <<- function(cond) {
[18:04:20.992]                               data <- list(type = "VALUE", value = cond, 
[18:04:20.992]                                 success = TRUE)
[18:04:20.992]                               parallel_sendData(master, data)
[18:04:20.992]                             }
[18:04:20.992]                             return(sendCondition)
[18:04:20.992]                           }
[18:04:20.992]                         }
[18:04:20.992]                         frame <- frame + 1L
[18:04:20.992]                         envir <- sys.frame(frame)
[18:04:20.992]                       }
[18:04:20.992]                     }
[18:04:20.992]                     sendCondition <<- function(cond) NULL
[18:04:20.992]                   }
[18:04:20.992]                 })
[18:04:20.992]                 withCallingHandlers({
[18:04:20.992]                   {
[18:04:20.992]                     4
[18:04:20.992]                   }
[18:04:20.992]                 }, immediateCondition = function(cond) {
[18:04:20.992]                   sendCondition <- ...future.makeSendCondition()
[18:04:20.992]                   sendCondition(cond)
[18:04:20.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.992]                   {
[18:04:20.992]                     inherits <- base::inherits
[18:04:20.992]                     invokeRestart <- base::invokeRestart
[18:04:20.992]                     is.null <- base::is.null
[18:04:20.992]                     muffled <- FALSE
[18:04:20.992]                     if (inherits(cond, "message")) {
[18:04:20.992]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:20.992]                       if (muffled) 
[18:04:20.992]                         invokeRestart("muffleMessage")
[18:04:20.992]                     }
[18:04:20.992]                     else if (inherits(cond, "warning")) {
[18:04:20.992]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:20.992]                       if (muffled) 
[18:04:20.992]                         invokeRestart("muffleWarning")
[18:04:20.992]                     }
[18:04:20.992]                     else if (inherits(cond, "condition")) {
[18:04:20.992]                       if (!is.null(pattern)) {
[18:04:20.992]                         computeRestarts <- base::computeRestarts
[18:04:20.992]                         grepl <- base::grepl
[18:04:20.992]                         restarts <- computeRestarts(cond)
[18:04:20.992]                         for (restart in restarts) {
[18:04:20.992]                           name <- restart$name
[18:04:20.992]                           if (is.null(name)) 
[18:04:20.992]                             next
[18:04:20.992]                           if (!grepl(pattern, name)) 
[18:04:20.992]                             next
[18:04:20.992]                           invokeRestart(restart)
[18:04:20.992]                           muffled <- TRUE
[18:04:20.992]                           break
[18:04:20.992]                         }
[18:04:20.992]                       }
[18:04:20.992]                     }
[18:04:20.992]                     invisible(muffled)
[18:04:20.992]                   }
[18:04:20.992]                   muffleCondition(cond)
[18:04:20.992]                 })
[18:04:20.992]             }))
[18:04:20.992]             future::FutureResult(value = ...future.value$value, 
[18:04:20.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.992]                   ...future.rng), globalenv = if (FALSE) 
[18:04:20.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:20.992]                     ...future.globalenv.names))
[18:04:20.992]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:20.992]         }, condition = base::local({
[18:04:20.992]             c <- base::c
[18:04:20.992]             inherits <- base::inherits
[18:04:20.992]             invokeRestart <- base::invokeRestart
[18:04:20.992]             length <- base::length
[18:04:20.992]             list <- base::list
[18:04:20.992]             seq.int <- base::seq.int
[18:04:20.992]             signalCondition <- base::signalCondition
[18:04:20.992]             sys.calls <- base::sys.calls
[18:04:20.992]             `[[` <- base::`[[`
[18:04:20.992]             `+` <- base::`+`
[18:04:20.992]             `<<-` <- base::`<<-`
[18:04:20.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:20.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:20.992]                   3L)]
[18:04:20.992]             }
[18:04:20.992]             function(cond) {
[18:04:20.992]                 is_error <- inherits(cond, "error")
[18:04:20.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:20.992]                   NULL)
[18:04:20.992]                 if (is_error) {
[18:04:20.992]                   sessionInformation <- function() {
[18:04:20.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:20.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:20.992]                       search = base::search(), system = base::Sys.info())
[18:04:20.992]                   }
[18:04:20.992]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:20.992]                     cond$call), session = sessionInformation(), 
[18:04:20.992]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:20.992]                   signalCondition(cond)
[18:04:20.992]                 }
[18:04:20.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:20.992]                 "immediateCondition"))) {
[18:04:20.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:20.992]                   ...future.conditions[[length(...future.conditions) + 
[18:04:20.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:20.992]                   if (TRUE && !signal) {
[18:04:20.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.992]                     {
[18:04:20.992]                       inherits <- base::inherits
[18:04:20.992]                       invokeRestart <- base::invokeRestart
[18:04:20.992]                       is.null <- base::is.null
[18:04:20.992]                       muffled <- FALSE
[18:04:20.992]                       if (inherits(cond, "message")) {
[18:04:20.992]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.992]                         if (muffled) 
[18:04:20.992]                           invokeRestart("muffleMessage")
[18:04:20.992]                       }
[18:04:20.992]                       else if (inherits(cond, "warning")) {
[18:04:20.992]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.992]                         if (muffled) 
[18:04:20.992]                           invokeRestart("muffleWarning")
[18:04:20.992]                       }
[18:04:20.992]                       else if (inherits(cond, "condition")) {
[18:04:20.992]                         if (!is.null(pattern)) {
[18:04:20.992]                           computeRestarts <- base::computeRestarts
[18:04:20.992]                           grepl <- base::grepl
[18:04:20.992]                           restarts <- computeRestarts(cond)
[18:04:20.992]                           for (restart in restarts) {
[18:04:20.992]                             name <- restart$name
[18:04:20.992]                             if (is.null(name)) 
[18:04:20.992]                               next
[18:04:20.992]                             if (!grepl(pattern, name)) 
[18:04:20.992]                               next
[18:04:20.992]                             invokeRestart(restart)
[18:04:20.992]                             muffled <- TRUE
[18:04:20.992]                             break
[18:04:20.992]                           }
[18:04:20.992]                         }
[18:04:20.992]                       }
[18:04:20.992]                       invisible(muffled)
[18:04:20.992]                     }
[18:04:20.992]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.992]                   }
[18:04:20.992]                 }
[18:04:20.992]                 else {
[18:04:20.992]                   if (TRUE) {
[18:04:20.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:20.992]                     {
[18:04:20.992]                       inherits <- base::inherits
[18:04:20.992]                       invokeRestart <- base::invokeRestart
[18:04:20.992]                       is.null <- base::is.null
[18:04:20.992]                       muffled <- FALSE
[18:04:20.992]                       if (inherits(cond, "message")) {
[18:04:20.992]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:20.992]                         if (muffled) 
[18:04:20.992]                           invokeRestart("muffleMessage")
[18:04:20.992]                       }
[18:04:20.992]                       else if (inherits(cond, "warning")) {
[18:04:20.992]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:20.992]                         if (muffled) 
[18:04:20.992]                           invokeRestart("muffleWarning")
[18:04:20.992]                       }
[18:04:20.992]                       else if (inherits(cond, "condition")) {
[18:04:20.992]                         if (!is.null(pattern)) {
[18:04:20.992]                           computeRestarts <- base::computeRestarts
[18:04:20.992]                           grepl <- base::grepl
[18:04:20.992]                           restarts <- computeRestarts(cond)
[18:04:20.992]                           for (restart in restarts) {
[18:04:20.992]                             name <- restart$name
[18:04:20.992]                             if (is.null(name)) 
[18:04:20.992]                               next
[18:04:20.992]                             if (!grepl(pattern, name)) 
[18:04:20.992]                               next
[18:04:20.992]                             invokeRestart(restart)
[18:04:20.992]                             muffled <- TRUE
[18:04:20.992]                             break
[18:04:20.992]                           }
[18:04:20.992]                         }
[18:04:20.992]                       }
[18:04:20.992]                       invisible(muffled)
[18:04:20.992]                     }
[18:04:20.992]                     muffleCondition(cond, pattern = "^muffle")
[18:04:20.992]                   }
[18:04:20.992]                 }
[18:04:20.992]             }
[18:04:20.992]         }))
[18:04:20.992]     }, error = function(ex) {
[18:04:20.992]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:20.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:20.992]                 ...future.rng), started = ...future.startTime, 
[18:04:20.992]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:20.992]             version = "1.8"), class = "FutureResult")
[18:04:20.992]     }, finally = {
[18:04:20.992]         if (!identical(...future.workdir, getwd())) 
[18:04:20.992]             setwd(...future.workdir)
[18:04:20.992]         {
[18:04:20.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:20.992]                 ...future.oldOptions$nwarnings <- NULL
[18:04:20.992]             }
[18:04:20.992]             base::options(...future.oldOptions)
[18:04:20.992]             if (.Platform$OS.type == "windows") {
[18:04:20.992]                 old_names <- names(...future.oldEnvVars)
[18:04:20.992]                 envs <- base::Sys.getenv()
[18:04:20.992]                 names <- names(envs)
[18:04:20.992]                 common <- intersect(names, old_names)
[18:04:20.992]                 added <- setdiff(names, old_names)
[18:04:20.992]                 removed <- setdiff(old_names, names)
[18:04:20.992]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:20.992]                   envs[common]]
[18:04:20.992]                 NAMES <- toupper(changed)
[18:04:20.992]                 args <- list()
[18:04:20.992]                 for (kk in seq_along(NAMES)) {
[18:04:20.992]                   name <- changed[[kk]]
[18:04:20.992]                   NAME <- NAMES[[kk]]
[18:04:20.992]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.992]                     next
[18:04:20.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.992]                 }
[18:04:20.992]                 NAMES <- toupper(added)
[18:04:20.992]                 for (kk in seq_along(NAMES)) {
[18:04:20.992]                   name <- added[[kk]]
[18:04:20.992]                   NAME <- NAMES[[kk]]
[18:04:20.992]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.992]                     next
[18:04:20.992]                   args[[name]] <- ""
[18:04:20.992]                 }
[18:04:20.992]                 NAMES <- toupper(removed)
[18:04:20.992]                 for (kk in seq_along(NAMES)) {
[18:04:20.992]                   name <- removed[[kk]]
[18:04:20.992]                   NAME <- NAMES[[kk]]
[18:04:20.992]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:20.992]                     next
[18:04:20.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:20.992]                 }
[18:04:20.992]                 if (length(args) > 0) 
[18:04:20.992]                   base::do.call(base::Sys.setenv, args = args)
[18:04:20.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:20.992]             }
[18:04:20.992]             else {
[18:04:20.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:20.992]             }
[18:04:20.992]             {
[18:04:20.992]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:20.992]                   0L) {
[18:04:20.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:20.992]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:20.992]                   base::options(opts)
[18:04:20.992]                 }
[18:04:20.992]                 {
[18:04:20.992]                   {
[18:04:20.992]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:20.992]                     NULL
[18:04:20.992]                   }
[18:04:20.992]                   options(future.plan = NULL)
[18:04:20.992]                   if (is.na(NA_character_)) 
[18:04:20.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:20.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:20.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:20.992]                     .init = FALSE)
[18:04:20.992]                 }
[18:04:20.992]             }
[18:04:20.992]         }
[18:04:20.992]     })
[18:04:20.992]     if (TRUE) {
[18:04:20.992]         base::sink(type = "output", split = FALSE)
[18:04:20.992]         if (TRUE) {
[18:04:20.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:20.992]         }
[18:04:20.992]         else {
[18:04:20.992]             ...future.result["stdout"] <- base::list(NULL)
[18:04:20.992]         }
[18:04:20.992]         base::close(...future.stdout)
[18:04:20.992]         ...future.stdout <- NULL
[18:04:20.992]     }
[18:04:20.992]     ...future.result$conditions <- ...future.conditions
[18:04:20.992]     ...future.result$finished <- base::Sys.time()
[18:04:20.992]     ...future.result
[18:04:20.992] }
[18:04:20.996] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:21.007] receiveMessageFromWorker() for ClusterFuture ...
[18:04:21.007] - Validating connection of MultisessionFuture
[18:04:21.008] - received message: FutureResult
[18:04:21.008] - Received FutureResult
[18:04:21.008] - Erased future from FutureRegistry
[18:04:21.008] result() for ClusterFuture ...
[18:04:21.008] - result already collected: FutureResult
[18:04:21.009] result() for ClusterFuture ... done
[18:04:21.009] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:21.009] result() for ClusterFuture ...
[18:04:21.009] - result already collected: FutureResult
[18:04:21.009] result() for ClusterFuture ... done
[18:04:21.010] result() for ClusterFuture ...
[18:04:21.010] - result already collected: FutureResult
[18:04:21.010] result() for ClusterFuture ... done
[18:04:21.012] MultisessionFuture started
[18:04:21.012] - Launch lazy future ... done
[18:04:21.013] run() for ‘MultisessionFuture’ ... done
<environment: 0x5e3c2b1190e8> 
<environment: 0x5e3c2c5de3c8> 
[18:04:21.016] receiveMessageFromWorker() for ClusterFuture ...
[18:04:21.016] - Validating connection of MultisessionFuture
[18:04:21.016] - received message: FutureResult
[18:04:21.017] - Received FutureResult
[18:04:21.017] - Erased future from FutureRegistry
[18:04:21.017] result() for ClusterFuture ...
[18:04:21.017] - result already collected: FutureResult
[18:04:21.017] result() for ClusterFuture ... done
[18:04:21.018] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:21.031] resolve() on environment ...
[18:04:21.031]  recursive: 0
[18:04:21.032]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:21.032] signalConditionsASAP(numeric, pos=1) ...
[18:04:21.032] - nx: 4
[18:04:21.033] - relay: TRUE
[18:04:21.033] - stdout: TRUE
[18:04:21.033] - signal: TRUE
[18:04:21.033] - resignal: FALSE
[18:04:21.033] - force: TRUE
[18:04:21.034] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:21.034] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:21.034]  - until=2
[18:04:21.034]  - relaying element #2
[18:04:21.034] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:21.035] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:21.035] signalConditionsASAP(NULL, pos=1) ... done
[18:04:21.035]  length: 3 (resolved future 1)
[18:04:21.035] Future #2
[18:04:21.035] result() for ClusterFuture ...
[18:04:21.036] - result already collected: FutureResult
[18:04:21.036] result() for ClusterFuture ... done
[18:04:21.036] result() for ClusterFuture ...
[18:04:21.036] - result already collected: FutureResult
[18:04:21.036] result() for ClusterFuture ... done
[18:04:21.037] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:21.037] - nx: 4
[18:04:21.037] - relay: TRUE
[18:04:21.037] - stdout: TRUE
[18:04:21.037] - signal: TRUE
[18:04:21.037] - resignal: FALSE
[18:04:21.038] - force: TRUE
[18:04:21.038] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:21.038] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:21.038]  - until=2
[18:04:21.038]  - relaying element #2
[18:04:21.039] result() for ClusterFuture ...
[18:04:21.039] - result already collected: FutureResult
[18:04:21.039] result() for ClusterFuture ... done
[18:04:21.039] result() for ClusterFuture ...
[18:04:21.039] - result already collected: FutureResult
[18:04:21.039] result() for ClusterFuture ... done
[18:04:21.040] result() for ClusterFuture ...
[18:04:21.040] - result already collected: FutureResult
[18:04:21.040] result() for ClusterFuture ... done
[18:04:21.040] result() for ClusterFuture ...
[18:04:21.040] - result already collected: FutureResult
[18:04:21.041] result() for ClusterFuture ... done
[18:04:21.041] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:21.041] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:21.041] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:21.041]  length: 2 (resolved future 2)
[18:04:21.042] Future #3
[18:04:21.042] result() for ClusterFuture ...
[18:04:21.042] - result already collected: FutureResult
[18:04:21.042] result() for ClusterFuture ... done
[18:04:21.042] result() for ClusterFuture ...
[18:04:21.043] - result already collected: FutureResult
[18:04:21.043] result() for ClusterFuture ... done
[18:04:21.043] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:21.043] - nx: 4
[18:04:21.043] - relay: TRUE
[18:04:21.043] - stdout: TRUE
[18:04:21.044] - signal: TRUE
[18:04:21.044] - resignal: FALSE
[18:04:21.044] - force: TRUE
[18:04:21.044] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:21.044] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:21.045]  - until=3
[18:04:21.045]  - relaying element #3
[18:04:21.045] result() for ClusterFuture ...
[18:04:21.045] - result already collected: FutureResult
[18:04:21.045] result() for ClusterFuture ... done
[18:04:21.045] result() for ClusterFuture ...
[18:04:21.046] - result already collected: FutureResult
[18:04:21.046] result() for ClusterFuture ... done
[18:04:21.046] result() for ClusterFuture ...
[18:04:21.046] - result already collected: FutureResult
[18:04:21.046] result() for ClusterFuture ... done
[18:04:21.047] result() for ClusterFuture ...
[18:04:21.047] - result already collected: FutureResult
[18:04:21.047] result() for ClusterFuture ... done
[18:04:21.047] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:21.047] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:21.047] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:21.048]  length: 1 (resolved future 3)
[18:04:21.056] receiveMessageFromWorker() for ClusterFuture ...
[18:04:21.057] - Validating connection of MultisessionFuture
[18:04:21.057] - received message: FutureResult
[18:04:21.057] - Received FutureResult
[18:04:21.058] - Erased future from FutureRegistry
[18:04:21.058] result() for ClusterFuture ...
[18:04:21.058] - result already collected: FutureResult
[18:04:21.058] result() for ClusterFuture ... done
[18:04:21.058] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:21.058] Future #4
[18:04:21.059] result() for ClusterFuture ...
[18:04:21.059] - result already collected: FutureResult
[18:04:21.059] result() for ClusterFuture ... done
[18:04:21.059] result() for ClusterFuture ...
[18:04:21.059] - result already collected: FutureResult
[18:04:21.060] result() for ClusterFuture ... done
[18:04:21.060] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:21.060] - nx: 4
[18:04:21.060] - relay: TRUE
[18:04:21.060] - stdout: TRUE
[18:04:21.061] - signal: TRUE
[18:04:21.061] - resignal: FALSE
[18:04:21.061] - force: TRUE
[18:04:21.061] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:21.061] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:21.061]  - until=4
[18:04:21.062]  - relaying element #4
[18:04:21.062] result() for ClusterFuture ...
[18:04:21.062] - result already collected: FutureResult
[18:04:21.062] result() for ClusterFuture ... done
[18:04:21.062] result() for ClusterFuture ...
[18:04:21.063] - result already collected: FutureResult
[18:04:21.063] result() for ClusterFuture ... done
[18:04:21.063] result() for ClusterFuture ...
[18:04:21.063] - result already collected: FutureResult
[18:04:21.063] result() for ClusterFuture ... done
[18:04:21.064] result() for ClusterFuture ...
[18:04:21.064] - result already collected: FutureResult
[18:04:21.064] result() for ClusterFuture ... done
[18:04:21.064] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:21.064] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:21.064] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:21.065]  length: 0 (resolved future 4)
[18:04:21.065] Relaying remaining futures
[18:04:21.065] signalConditionsASAP(NULL, pos=0) ...
[18:04:21.065] - nx: 4
[18:04:21.065] - relay: TRUE
[18:04:21.066] - stdout: TRUE
[18:04:21.066] - signal: TRUE
[18:04:21.066] - resignal: FALSE
[18:04:21.066] - force: TRUE
[18:04:21.066] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:21.066] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:21.067] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:21.067] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:21.067] signalConditionsASAP(NULL, pos=0) ... done
[18:04:21.067] resolve() on environment ... DONE
[18:04:21.068] result() for ClusterFuture ...
[18:04:21.068] - result already collected: FutureResult
[18:04:21.068] result() for ClusterFuture ... done
[18:04:21.068] result() for ClusterFuture ...
[18:04:21.068] - result already collected: FutureResult
[18:04:21.068] result() for ClusterFuture ... done
[18:04:21.069] result() for ClusterFuture ...
[18:04:21.069] - result already collected: FutureResult
[18:04:21.069] result() for ClusterFuture ... done
[18:04:21.069] result() for ClusterFuture ...
[18:04:21.069] - result already collected: FutureResult
[18:04:21.070] result() for ClusterFuture ... done
[18:04:21.070] result() for ClusterFuture ...
[18:04:21.070] - result already collected: FutureResult
[18:04:21.070] result() for ClusterFuture ... done
[18:04:21.070] result() for ClusterFuture ...
[18:04:21.071] - result already collected: FutureResult
[18:04:21.071] result() for ClusterFuture ... done
<environment: 0x5e3c2c7feab8> 
Dimensions: c(2, 1, 3, 1)
[18:04:21.072] getGlobalsAndPackages() ...
[18:04:21.072] Searching for globals...
[18:04:21.072] 
[18:04:21.073] Searching for globals ... DONE
[18:04:21.073] - globals: [0] <none>
[18:04:21.073] getGlobalsAndPackages() ... DONE
[18:04:21.073] run() for ‘Future’ ...
[18:04:21.074] - state: ‘created’
[18:04:21.074] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.098] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:21.098]   - Field: ‘node’
[18:04:21.099]   - Field: ‘label’
[18:04:21.099]   - Field: ‘local’
[18:04:21.099]   - Field: ‘owner’
[18:04:21.099]   - Field: ‘envir’
[18:04:21.100]   - Field: ‘workers’
[18:04:21.100]   - Field: ‘packages’
[18:04:21.100]   - Field: ‘gc’
[18:04:21.100]   - Field: ‘conditions’
[18:04:21.100]   - Field: ‘persistent’
[18:04:21.101]   - Field: ‘expr’
[18:04:21.101]   - Field: ‘uuid’
[18:04:21.101]   - Field: ‘seed’
[18:04:21.101]   - Field: ‘version’
[18:04:21.101]   - Field: ‘result’
[18:04:21.102]   - Field: ‘asynchronous’
[18:04:21.102]   - Field: ‘calls’
[18:04:21.102]   - Field: ‘globals’
[18:04:21.102]   - Field: ‘stdout’
[18:04:21.102]   - Field: ‘earlySignal’
[18:04:21.103]   - Field: ‘lazy’
[18:04:21.103]   - Field: ‘state’
[18:04:21.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:21.103] - Launch lazy future ...
[18:04:21.104] Packages needed by the future expression (n = 0): <none>
[18:04:21.104] Packages needed by future strategies (n = 0): <none>
[18:04:21.105] {
[18:04:21.105]     {
[18:04:21.105]         {
[18:04:21.105]             ...future.startTime <- base::Sys.time()
[18:04:21.105]             {
[18:04:21.105]                 {
[18:04:21.105]                   {
[18:04:21.105]                     {
[18:04:21.105]                       base::local({
[18:04:21.105]                         has_future <- base::requireNamespace("future", 
[18:04:21.105]                           quietly = TRUE)
[18:04:21.105]                         if (has_future) {
[18:04:21.105]                           ns <- base::getNamespace("future")
[18:04:21.105]                           version <- ns[[".package"]][["version"]]
[18:04:21.105]                           if (is.null(version)) 
[18:04:21.105]                             version <- utils::packageVersion("future")
[18:04:21.105]                         }
[18:04:21.105]                         else {
[18:04:21.105]                           version <- NULL
[18:04:21.105]                         }
[18:04:21.105]                         if (!has_future || version < "1.8.0") {
[18:04:21.105]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.105]                             "", base::R.version$version.string), 
[18:04:21.105]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.105]                               "release", "version")], collapse = " "), 
[18:04:21.105]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.105]                             info)
[18:04:21.105]                           info <- base::paste(info, collapse = "; ")
[18:04:21.105]                           if (!has_future) {
[18:04:21.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.105]                               info)
[18:04:21.105]                           }
[18:04:21.105]                           else {
[18:04:21.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.105]                               info, version)
[18:04:21.105]                           }
[18:04:21.105]                           base::stop(msg)
[18:04:21.105]                         }
[18:04:21.105]                       })
[18:04:21.105]                     }
[18:04:21.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.105]                     base::options(mc.cores = 1L)
[18:04:21.105]                   }
[18:04:21.105]                   ...future.strategy.old <- future::plan("list")
[18:04:21.105]                   options(future.plan = NULL)
[18:04:21.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.105]                 }
[18:04:21.105]                 ...future.workdir <- getwd()
[18:04:21.105]             }
[18:04:21.105]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.105]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.105]         }
[18:04:21.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.105]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.105]             base::names(...future.oldOptions))
[18:04:21.105]     }
[18:04:21.105]     if (FALSE) {
[18:04:21.105]     }
[18:04:21.105]     else {
[18:04:21.105]         if (TRUE) {
[18:04:21.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.105]                 open = "w")
[18:04:21.105]         }
[18:04:21.105]         else {
[18:04:21.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.105]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.105]         }
[18:04:21.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.105]             base::sink(type = "output", split = FALSE)
[18:04:21.105]             base::close(...future.stdout)
[18:04:21.105]         }, add = TRUE)
[18:04:21.105]     }
[18:04:21.105]     ...future.frame <- base::sys.nframe()
[18:04:21.105]     ...future.conditions <- base::list()
[18:04:21.105]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.105]     if (FALSE) {
[18:04:21.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.105]     }
[18:04:21.105]     ...future.result <- base::tryCatch({
[18:04:21.105]         base::withCallingHandlers({
[18:04:21.105]             ...future.value <- base::withVisible(base::local({
[18:04:21.105]                 ...future.makeSendCondition <- base::local({
[18:04:21.105]                   sendCondition <- NULL
[18:04:21.105]                   function(frame = 1L) {
[18:04:21.105]                     if (is.function(sendCondition)) 
[18:04:21.105]                       return(sendCondition)
[18:04:21.105]                     ns <- getNamespace("parallel")
[18:04:21.105]                     if (exists("sendData", mode = "function", 
[18:04:21.105]                       envir = ns)) {
[18:04:21.105]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:21.105]                         envir = ns)
[18:04:21.105]                       envir <- sys.frame(frame)
[18:04:21.105]                       master <- NULL
[18:04:21.105]                       while (!identical(envir, .GlobalEnv) && 
[18:04:21.105]                         !identical(envir, emptyenv())) {
[18:04:21.105]                         if (exists("master", mode = "list", envir = envir, 
[18:04:21.105]                           inherits = FALSE)) {
[18:04:21.105]                           master <- get("master", mode = "list", 
[18:04:21.105]                             envir = envir, inherits = FALSE)
[18:04:21.105]                           if (inherits(master, c("SOCKnode", 
[18:04:21.105]                             "SOCK0node"))) {
[18:04:21.105]                             sendCondition <<- function(cond) {
[18:04:21.105]                               data <- list(type = "VALUE", value = cond, 
[18:04:21.105]                                 success = TRUE)
[18:04:21.105]                               parallel_sendData(master, data)
[18:04:21.105]                             }
[18:04:21.105]                             return(sendCondition)
[18:04:21.105]                           }
[18:04:21.105]                         }
[18:04:21.105]                         frame <- frame + 1L
[18:04:21.105]                         envir <- sys.frame(frame)
[18:04:21.105]                       }
[18:04:21.105]                     }
[18:04:21.105]                     sendCondition <<- function(cond) NULL
[18:04:21.105]                   }
[18:04:21.105]                 })
[18:04:21.105]                 withCallingHandlers({
[18:04:21.105]                   2
[18:04:21.105]                 }, immediateCondition = function(cond) {
[18:04:21.105]                   sendCondition <- ...future.makeSendCondition()
[18:04:21.105]                   sendCondition(cond)
[18:04:21.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.105]                   {
[18:04:21.105]                     inherits <- base::inherits
[18:04:21.105]                     invokeRestart <- base::invokeRestart
[18:04:21.105]                     is.null <- base::is.null
[18:04:21.105]                     muffled <- FALSE
[18:04:21.105]                     if (inherits(cond, "message")) {
[18:04:21.105]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.105]                       if (muffled) 
[18:04:21.105]                         invokeRestart("muffleMessage")
[18:04:21.105]                     }
[18:04:21.105]                     else if (inherits(cond, "warning")) {
[18:04:21.105]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.105]                       if (muffled) 
[18:04:21.105]                         invokeRestart("muffleWarning")
[18:04:21.105]                     }
[18:04:21.105]                     else if (inherits(cond, "condition")) {
[18:04:21.105]                       if (!is.null(pattern)) {
[18:04:21.105]                         computeRestarts <- base::computeRestarts
[18:04:21.105]                         grepl <- base::grepl
[18:04:21.105]                         restarts <- computeRestarts(cond)
[18:04:21.105]                         for (restart in restarts) {
[18:04:21.105]                           name <- restart$name
[18:04:21.105]                           if (is.null(name)) 
[18:04:21.105]                             next
[18:04:21.105]                           if (!grepl(pattern, name)) 
[18:04:21.105]                             next
[18:04:21.105]                           invokeRestart(restart)
[18:04:21.105]                           muffled <- TRUE
[18:04:21.105]                           break
[18:04:21.105]                         }
[18:04:21.105]                       }
[18:04:21.105]                     }
[18:04:21.105]                     invisible(muffled)
[18:04:21.105]                   }
[18:04:21.105]                   muffleCondition(cond)
[18:04:21.105]                 })
[18:04:21.105]             }))
[18:04:21.105]             future::FutureResult(value = ...future.value$value, 
[18:04:21.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.105]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.105]                     ...future.globalenv.names))
[18:04:21.105]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.105]         }, condition = base::local({
[18:04:21.105]             c <- base::c
[18:04:21.105]             inherits <- base::inherits
[18:04:21.105]             invokeRestart <- base::invokeRestart
[18:04:21.105]             length <- base::length
[18:04:21.105]             list <- base::list
[18:04:21.105]             seq.int <- base::seq.int
[18:04:21.105]             signalCondition <- base::signalCondition
[18:04:21.105]             sys.calls <- base::sys.calls
[18:04:21.105]             `[[` <- base::`[[`
[18:04:21.105]             `+` <- base::`+`
[18:04:21.105]             `<<-` <- base::`<<-`
[18:04:21.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.105]                   3L)]
[18:04:21.105]             }
[18:04:21.105]             function(cond) {
[18:04:21.105]                 is_error <- inherits(cond, "error")
[18:04:21.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.105]                   NULL)
[18:04:21.105]                 if (is_error) {
[18:04:21.105]                   sessionInformation <- function() {
[18:04:21.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.105]                       search = base::search(), system = base::Sys.info())
[18:04:21.105]                   }
[18:04:21.105]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.105]                     cond$call), session = sessionInformation(), 
[18:04:21.105]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.105]                   signalCondition(cond)
[18:04:21.105]                 }
[18:04:21.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.105]                 "immediateCondition"))) {
[18:04:21.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.105]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.105]                   if (TRUE && !signal) {
[18:04:21.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.105]                     {
[18:04:21.105]                       inherits <- base::inherits
[18:04:21.105]                       invokeRestart <- base::invokeRestart
[18:04:21.105]                       is.null <- base::is.null
[18:04:21.105]                       muffled <- FALSE
[18:04:21.105]                       if (inherits(cond, "message")) {
[18:04:21.105]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.105]                         if (muffled) 
[18:04:21.105]                           invokeRestart("muffleMessage")
[18:04:21.105]                       }
[18:04:21.105]                       else if (inherits(cond, "warning")) {
[18:04:21.105]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.105]                         if (muffled) 
[18:04:21.105]                           invokeRestart("muffleWarning")
[18:04:21.105]                       }
[18:04:21.105]                       else if (inherits(cond, "condition")) {
[18:04:21.105]                         if (!is.null(pattern)) {
[18:04:21.105]                           computeRestarts <- base::computeRestarts
[18:04:21.105]                           grepl <- base::grepl
[18:04:21.105]                           restarts <- computeRestarts(cond)
[18:04:21.105]                           for (restart in restarts) {
[18:04:21.105]                             name <- restart$name
[18:04:21.105]                             if (is.null(name)) 
[18:04:21.105]                               next
[18:04:21.105]                             if (!grepl(pattern, name)) 
[18:04:21.105]                               next
[18:04:21.105]                             invokeRestart(restart)
[18:04:21.105]                             muffled <- TRUE
[18:04:21.105]                             break
[18:04:21.105]                           }
[18:04:21.105]                         }
[18:04:21.105]                       }
[18:04:21.105]                       invisible(muffled)
[18:04:21.105]                     }
[18:04:21.105]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.105]                   }
[18:04:21.105]                 }
[18:04:21.105]                 else {
[18:04:21.105]                   if (TRUE) {
[18:04:21.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.105]                     {
[18:04:21.105]                       inherits <- base::inherits
[18:04:21.105]                       invokeRestart <- base::invokeRestart
[18:04:21.105]                       is.null <- base::is.null
[18:04:21.105]                       muffled <- FALSE
[18:04:21.105]                       if (inherits(cond, "message")) {
[18:04:21.105]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.105]                         if (muffled) 
[18:04:21.105]                           invokeRestart("muffleMessage")
[18:04:21.105]                       }
[18:04:21.105]                       else if (inherits(cond, "warning")) {
[18:04:21.105]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.105]                         if (muffled) 
[18:04:21.105]                           invokeRestart("muffleWarning")
[18:04:21.105]                       }
[18:04:21.105]                       else if (inherits(cond, "condition")) {
[18:04:21.105]                         if (!is.null(pattern)) {
[18:04:21.105]                           computeRestarts <- base::computeRestarts
[18:04:21.105]                           grepl <- base::grepl
[18:04:21.105]                           restarts <- computeRestarts(cond)
[18:04:21.105]                           for (restart in restarts) {
[18:04:21.105]                             name <- restart$name
[18:04:21.105]                             if (is.null(name)) 
[18:04:21.105]                               next
[18:04:21.105]                             if (!grepl(pattern, name)) 
[18:04:21.105]                               next
[18:04:21.105]                             invokeRestart(restart)
[18:04:21.105]                             muffled <- TRUE
[18:04:21.105]                             break
[18:04:21.105]                           }
[18:04:21.105]                         }
[18:04:21.105]                       }
[18:04:21.105]                       invisible(muffled)
[18:04:21.105]                     }
[18:04:21.105]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.105]                   }
[18:04:21.105]                 }
[18:04:21.105]             }
[18:04:21.105]         }))
[18:04:21.105]     }, error = function(ex) {
[18:04:21.105]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.105]                 ...future.rng), started = ...future.startTime, 
[18:04:21.105]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.105]             version = "1.8"), class = "FutureResult")
[18:04:21.105]     }, finally = {
[18:04:21.105]         if (!identical(...future.workdir, getwd())) 
[18:04:21.105]             setwd(...future.workdir)
[18:04:21.105]         {
[18:04:21.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.105]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.105]             }
[18:04:21.105]             base::options(...future.oldOptions)
[18:04:21.105]             if (.Platform$OS.type == "windows") {
[18:04:21.105]                 old_names <- names(...future.oldEnvVars)
[18:04:21.105]                 envs <- base::Sys.getenv()
[18:04:21.105]                 names <- names(envs)
[18:04:21.105]                 common <- intersect(names, old_names)
[18:04:21.105]                 added <- setdiff(names, old_names)
[18:04:21.105]                 removed <- setdiff(old_names, names)
[18:04:21.105]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.105]                   envs[common]]
[18:04:21.105]                 NAMES <- toupper(changed)
[18:04:21.105]                 args <- list()
[18:04:21.105]                 for (kk in seq_along(NAMES)) {
[18:04:21.105]                   name <- changed[[kk]]
[18:04:21.105]                   NAME <- NAMES[[kk]]
[18:04:21.105]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.105]                     next
[18:04:21.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.105]                 }
[18:04:21.105]                 NAMES <- toupper(added)
[18:04:21.105]                 for (kk in seq_along(NAMES)) {
[18:04:21.105]                   name <- added[[kk]]
[18:04:21.105]                   NAME <- NAMES[[kk]]
[18:04:21.105]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.105]                     next
[18:04:21.105]                   args[[name]] <- ""
[18:04:21.105]                 }
[18:04:21.105]                 NAMES <- toupper(removed)
[18:04:21.105]                 for (kk in seq_along(NAMES)) {
[18:04:21.105]                   name <- removed[[kk]]
[18:04:21.105]                   NAME <- NAMES[[kk]]
[18:04:21.105]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.105]                     next
[18:04:21.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.105]                 }
[18:04:21.105]                 if (length(args) > 0) 
[18:04:21.105]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.105]             }
[18:04:21.105]             else {
[18:04:21.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.105]             }
[18:04:21.105]             {
[18:04:21.105]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.105]                   0L) {
[18:04:21.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.105]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.105]                   base::options(opts)
[18:04:21.105]                 }
[18:04:21.105]                 {
[18:04:21.105]                   {
[18:04:21.105]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.105]                     NULL
[18:04:21.105]                   }
[18:04:21.105]                   options(future.plan = NULL)
[18:04:21.105]                   if (is.na(NA_character_)) 
[18:04:21.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.105]                     .init = FALSE)
[18:04:21.105]                 }
[18:04:21.105]             }
[18:04:21.105]         }
[18:04:21.105]     })
[18:04:21.105]     if (TRUE) {
[18:04:21.105]         base::sink(type = "output", split = FALSE)
[18:04:21.105]         if (TRUE) {
[18:04:21.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.105]         }
[18:04:21.105]         else {
[18:04:21.105]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.105]         }
[18:04:21.105]         base::close(...future.stdout)
[18:04:21.105]         ...future.stdout <- NULL
[18:04:21.105]     }
[18:04:21.105]     ...future.result$conditions <- ...future.conditions
[18:04:21.105]     ...future.result$finished <- base::Sys.time()
[18:04:21.105]     ...future.result
[18:04:21.105] }
[18:04:21.110] MultisessionFuture started
[18:04:21.111] - Launch lazy future ... done
[18:04:21.111] run() for ‘MultisessionFuture’ ... done
[18:04:21.111] getGlobalsAndPackages() ...
[18:04:21.111] Searching for globals...
[18:04:21.112] 
[18:04:21.115] Searching for globals ... DONE
[18:04:21.116] - globals: [0] <none>
[18:04:21.116] getGlobalsAndPackages() ... DONE
[18:04:21.116] run() for ‘Future’ ...
[18:04:21.117] - state: ‘created’
[18:04:21.117] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.142] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:21.145]   - Field: ‘node’
[18:04:21.145]   - Field: ‘label’
[18:04:21.145]   - Field: ‘local’
[18:04:21.146]   - Field: ‘owner’
[18:04:21.146]   - Field: ‘envir’
[18:04:21.146]   - Field: ‘workers’
[18:04:21.146]   - Field: ‘packages’
[18:04:21.147]   - Field: ‘gc’
[18:04:21.147]   - Field: ‘conditions’
[18:04:21.150]   - Field: ‘persistent’
[18:04:21.151]   - Field: ‘expr’
[18:04:21.151]   - Field: ‘uuid’
[18:04:21.151]   - Field: ‘seed’
[18:04:21.153]   - Field: ‘version’
[18:04:21.153]   - Field: ‘result’
[18:04:21.153]   - Field: ‘asynchronous’
[18:04:21.154]   - Field: ‘calls’
[18:04:21.156]   - Field: ‘globals’
[18:04:21.156]   - Field: ‘stdout’
[18:04:21.156]   - Field: ‘earlySignal’
[18:04:21.157]   - Field: ‘lazy’
[18:04:21.158]   - Field: ‘state’
[18:04:21.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:21.160] - Launch lazy future ...
[18:04:21.160] Packages needed by the future expression (n = 0): <none>
[18:04:21.160] Packages needed by future strategies (n = 0): <none>
[18:04:21.164] {
[18:04:21.164]     {
[18:04:21.164]         {
[18:04:21.164]             ...future.startTime <- base::Sys.time()
[18:04:21.164]             {
[18:04:21.164]                 {
[18:04:21.164]                   {
[18:04:21.164]                     {
[18:04:21.164]                       base::local({
[18:04:21.164]                         has_future <- base::requireNamespace("future", 
[18:04:21.164]                           quietly = TRUE)
[18:04:21.164]                         if (has_future) {
[18:04:21.164]                           ns <- base::getNamespace("future")
[18:04:21.164]                           version <- ns[[".package"]][["version"]]
[18:04:21.164]                           if (is.null(version)) 
[18:04:21.164]                             version <- utils::packageVersion("future")
[18:04:21.164]                         }
[18:04:21.164]                         else {
[18:04:21.164]                           version <- NULL
[18:04:21.164]                         }
[18:04:21.164]                         if (!has_future || version < "1.8.0") {
[18:04:21.164]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.164]                             "", base::R.version$version.string), 
[18:04:21.164]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.164]                               "release", "version")], collapse = " "), 
[18:04:21.164]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.164]                             info)
[18:04:21.164]                           info <- base::paste(info, collapse = "; ")
[18:04:21.164]                           if (!has_future) {
[18:04:21.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.164]                               info)
[18:04:21.164]                           }
[18:04:21.164]                           else {
[18:04:21.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.164]                               info, version)
[18:04:21.164]                           }
[18:04:21.164]                           base::stop(msg)
[18:04:21.164]                         }
[18:04:21.164]                       })
[18:04:21.164]                     }
[18:04:21.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.164]                     base::options(mc.cores = 1L)
[18:04:21.164]                   }
[18:04:21.164]                   ...future.strategy.old <- future::plan("list")
[18:04:21.164]                   options(future.plan = NULL)
[18:04:21.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.164]                 }
[18:04:21.164]                 ...future.workdir <- getwd()
[18:04:21.164]             }
[18:04:21.164]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.164]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.164]         }
[18:04:21.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.164]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.164]             base::names(...future.oldOptions))
[18:04:21.164]     }
[18:04:21.164]     if (FALSE) {
[18:04:21.164]     }
[18:04:21.164]     else {
[18:04:21.164]         if (TRUE) {
[18:04:21.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.164]                 open = "w")
[18:04:21.164]         }
[18:04:21.164]         else {
[18:04:21.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.164]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.164]         }
[18:04:21.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.164]             base::sink(type = "output", split = FALSE)
[18:04:21.164]             base::close(...future.stdout)
[18:04:21.164]         }, add = TRUE)
[18:04:21.164]     }
[18:04:21.164]     ...future.frame <- base::sys.nframe()
[18:04:21.164]     ...future.conditions <- base::list()
[18:04:21.164]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.164]     if (FALSE) {
[18:04:21.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.164]     }
[18:04:21.164]     ...future.result <- base::tryCatch({
[18:04:21.164]         base::withCallingHandlers({
[18:04:21.164]             ...future.value <- base::withVisible(base::local({
[18:04:21.164]                 ...future.makeSendCondition <- base::local({
[18:04:21.164]                   sendCondition <- NULL
[18:04:21.164]                   function(frame = 1L) {
[18:04:21.164]                     if (is.function(sendCondition)) 
[18:04:21.164]                       return(sendCondition)
[18:04:21.164]                     ns <- getNamespace("parallel")
[18:04:21.164]                     if (exists("sendData", mode = "function", 
[18:04:21.164]                       envir = ns)) {
[18:04:21.164]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:21.164]                         envir = ns)
[18:04:21.164]                       envir <- sys.frame(frame)
[18:04:21.164]                       master <- NULL
[18:04:21.164]                       while (!identical(envir, .GlobalEnv) && 
[18:04:21.164]                         !identical(envir, emptyenv())) {
[18:04:21.164]                         if (exists("master", mode = "list", envir = envir, 
[18:04:21.164]                           inherits = FALSE)) {
[18:04:21.164]                           master <- get("master", mode = "list", 
[18:04:21.164]                             envir = envir, inherits = FALSE)
[18:04:21.164]                           if (inherits(master, c("SOCKnode", 
[18:04:21.164]                             "SOCK0node"))) {
[18:04:21.164]                             sendCondition <<- function(cond) {
[18:04:21.164]                               data <- list(type = "VALUE", value = cond, 
[18:04:21.164]                                 success = TRUE)
[18:04:21.164]                               parallel_sendData(master, data)
[18:04:21.164]                             }
[18:04:21.164]                             return(sendCondition)
[18:04:21.164]                           }
[18:04:21.164]                         }
[18:04:21.164]                         frame <- frame + 1L
[18:04:21.164]                         envir <- sys.frame(frame)
[18:04:21.164]                       }
[18:04:21.164]                     }
[18:04:21.164]                     sendCondition <<- function(cond) NULL
[18:04:21.164]                   }
[18:04:21.164]                 })
[18:04:21.164]                 withCallingHandlers({
[18:04:21.164]                   NULL
[18:04:21.164]                 }, immediateCondition = function(cond) {
[18:04:21.164]                   sendCondition <- ...future.makeSendCondition()
[18:04:21.164]                   sendCondition(cond)
[18:04:21.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.164]                   {
[18:04:21.164]                     inherits <- base::inherits
[18:04:21.164]                     invokeRestart <- base::invokeRestart
[18:04:21.164]                     is.null <- base::is.null
[18:04:21.164]                     muffled <- FALSE
[18:04:21.164]                     if (inherits(cond, "message")) {
[18:04:21.164]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.164]                       if (muffled) 
[18:04:21.164]                         invokeRestart("muffleMessage")
[18:04:21.164]                     }
[18:04:21.164]                     else if (inherits(cond, "warning")) {
[18:04:21.164]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.164]                       if (muffled) 
[18:04:21.164]                         invokeRestart("muffleWarning")
[18:04:21.164]                     }
[18:04:21.164]                     else if (inherits(cond, "condition")) {
[18:04:21.164]                       if (!is.null(pattern)) {
[18:04:21.164]                         computeRestarts <- base::computeRestarts
[18:04:21.164]                         grepl <- base::grepl
[18:04:21.164]                         restarts <- computeRestarts(cond)
[18:04:21.164]                         for (restart in restarts) {
[18:04:21.164]                           name <- restart$name
[18:04:21.164]                           if (is.null(name)) 
[18:04:21.164]                             next
[18:04:21.164]                           if (!grepl(pattern, name)) 
[18:04:21.164]                             next
[18:04:21.164]                           invokeRestart(restart)
[18:04:21.164]                           muffled <- TRUE
[18:04:21.164]                           break
[18:04:21.164]                         }
[18:04:21.164]                       }
[18:04:21.164]                     }
[18:04:21.164]                     invisible(muffled)
[18:04:21.164]                   }
[18:04:21.164]                   muffleCondition(cond)
[18:04:21.164]                 })
[18:04:21.164]             }))
[18:04:21.164]             future::FutureResult(value = ...future.value$value, 
[18:04:21.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.164]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.164]                     ...future.globalenv.names))
[18:04:21.164]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.164]         }, condition = base::local({
[18:04:21.164]             c <- base::c
[18:04:21.164]             inherits <- base::inherits
[18:04:21.164]             invokeRestart <- base::invokeRestart
[18:04:21.164]             length <- base::length
[18:04:21.164]             list <- base::list
[18:04:21.164]             seq.int <- base::seq.int
[18:04:21.164]             signalCondition <- base::signalCondition
[18:04:21.164]             sys.calls <- base::sys.calls
[18:04:21.164]             `[[` <- base::`[[`
[18:04:21.164]             `+` <- base::`+`
[18:04:21.164]             `<<-` <- base::`<<-`
[18:04:21.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.164]                   3L)]
[18:04:21.164]             }
[18:04:21.164]             function(cond) {
[18:04:21.164]                 is_error <- inherits(cond, "error")
[18:04:21.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.164]                   NULL)
[18:04:21.164]                 if (is_error) {
[18:04:21.164]                   sessionInformation <- function() {
[18:04:21.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.164]                       search = base::search(), system = base::Sys.info())
[18:04:21.164]                   }
[18:04:21.164]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.164]                     cond$call), session = sessionInformation(), 
[18:04:21.164]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.164]                   signalCondition(cond)
[18:04:21.164]                 }
[18:04:21.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.164]                 "immediateCondition"))) {
[18:04:21.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.164]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.164]                   if (TRUE && !signal) {
[18:04:21.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.164]                     {
[18:04:21.164]                       inherits <- base::inherits
[18:04:21.164]                       invokeRestart <- base::invokeRestart
[18:04:21.164]                       is.null <- base::is.null
[18:04:21.164]                       muffled <- FALSE
[18:04:21.164]                       if (inherits(cond, "message")) {
[18:04:21.164]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.164]                         if (muffled) 
[18:04:21.164]                           invokeRestart("muffleMessage")
[18:04:21.164]                       }
[18:04:21.164]                       else if (inherits(cond, "warning")) {
[18:04:21.164]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.164]                         if (muffled) 
[18:04:21.164]                           invokeRestart("muffleWarning")
[18:04:21.164]                       }
[18:04:21.164]                       else if (inherits(cond, "condition")) {
[18:04:21.164]                         if (!is.null(pattern)) {
[18:04:21.164]                           computeRestarts <- base::computeRestarts
[18:04:21.164]                           grepl <- base::grepl
[18:04:21.164]                           restarts <- computeRestarts(cond)
[18:04:21.164]                           for (restart in restarts) {
[18:04:21.164]                             name <- restart$name
[18:04:21.164]                             if (is.null(name)) 
[18:04:21.164]                               next
[18:04:21.164]                             if (!grepl(pattern, name)) 
[18:04:21.164]                               next
[18:04:21.164]                             invokeRestart(restart)
[18:04:21.164]                             muffled <- TRUE
[18:04:21.164]                             break
[18:04:21.164]                           }
[18:04:21.164]                         }
[18:04:21.164]                       }
[18:04:21.164]                       invisible(muffled)
[18:04:21.164]                     }
[18:04:21.164]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.164]                   }
[18:04:21.164]                 }
[18:04:21.164]                 else {
[18:04:21.164]                   if (TRUE) {
[18:04:21.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.164]                     {
[18:04:21.164]                       inherits <- base::inherits
[18:04:21.164]                       invokeRestart <- base::invokeRestart
[18:04:21.164]                       is.null <- base::is.null
[18:04:21.164]                       muffled <- FALSE
[18:04:21.164]                       if (inherits(cond, "message")) {
[18:04:21.164]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.164]                         if (muffled) 
[18:04:21.164]                           invokeRestart("muffleMessage")
[18:04:21.164]                       }
[18:04:21.164]                       else if (inherits(cond, "warning")) {
[18:04:21.164]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.164]                         if (muffled) 
[18:04:21.164]                           invokeRestart("muffleWarning")
[18:04:21.164]                       }
[18:04:21.164]                       else if (inherits(cond, "condition")) {
[18:04:21.164]                         if (!is.null(pattern)) {
[18:04:21.164]                           computeRestarts <- base::computeRestarts
[18:04:21.164]                           grepl <- base::grepl
[18:04:21.164]                           restarts <- computeRestarts(cond)
[18:04:21.164]                           for (restart in restarts) {
[18:04:21.164]                             name <- restart$name
[18:04:21.164]                             if (is.null(name)) 
[18:04:21.164]                               next
[18:04:21.164]                             if (!grepl(pattern, name)) 
[18:04:21.164]                               next
[18:04:21.164]                             invokeRestart(restart)
[18:04:21.164]                             muffled <- TRUE
[18:04:21.164]                             break
[18:04:21.164]                           }
[18:04:21.164]                         }
[18:04:21.164]                       }
[18:04:21.164]                       invisible(muffled)
[18:04:21.164]                     }
[18:04:21.164]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.164]                   }
[18:04:21.164]                 }
[18:04:21.164]             }
[18:04:21.164]         }))
[18:04:21.164]     }, error = function(ex) {
[18:04:21.164]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.164]                 ...future.rng), started = ...future.startTime, 
[18:04:21.164]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.164]             version = "1.8"), class = "FutureResult")
[18:04:21.164]     }, finally = {
[18:04:21.164]         if (!identical(...future.workdir, getwd())) 
[18:04:21.164]             setwd(...future.workdir)
[18:04:21.164]         {
[18:04:21.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.164]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.164]             }
[18:04:21.164]             base::options(...future.oldOptions)
[18:04:21.164]             if (.Platform$OS.type == "windows") {
[18:04:21.164]                 old_names <- names(...future.oldEnvVars)
[18:04:21.164]                 envs <- base::Sys.getenv()
[18:04:21.164]                 names <- names(envs)
[18:04:21.164]                 common <- intersect(names, old_names)
[18:04:21.164]                 added <- setdiff(names, old_names)
[18:04:21.164]                 removed <- setdiff(old_names, names)
[18:04:21.164]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.164]                   envs[common]]
[18:04:21.164]                 NAMES <- toupper(changed)
[18:04:21.164]                 args <- list()
[18:04:21.164]                 for (kk in seq_along(NAMES)) {
[18:04:21.164]                   name <- changed[[kk]]
[18:04:21.164]                   NAME <- NAMES[[kk]]
[18:04:21.164]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.164]                     next
[18:04:21.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.164]                 }
[18:04:21.164]                 NAMES <- toupper(added)
[18:04:21.164]                 for (kk in seq_along(NAMES)) {
[18:04:21.164]                   name <- added[[kk]]
[18:04:21.164]                   NAME <- NAMES[[kk]]
[18:04:21.164]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.164]                     next
[18:04:21.164]                   args[[name]] <- ""
[18:04:21.164]                 }
[18:04:21.164]                 NAMES <- toupper(removed)
[18:04:21.164]                 for (kk in seq_along(NAMES)) {
[18:04:21.164]                   name <- removed[[kk]]
[18:04:21.164]                   NAME <- NAMES[[kk]]
[18:04:21.164]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.164]                     next
[18:04:21.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.164]                 }
[18:04:21.164]                 if (length(args) > 0) 
[18:04:21.164]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.164]             }
[18:04:21.164]             else {
[18:04:21.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.164]             }
[18:04:21.164]             {
[18:04:21.164]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.164]                   0L) {
[18:04:21.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.164]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.164]                   base::options(opts)
[18:04:21.164]                 }
[18:04:21.164]                 {
[18:04:21.164]                   {
[18:04:21.164]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.164]                     NULL
[18:04:21.164]                   }
[18:04:21.164]                   options(future.plan = NULL)
[18:04:21.164]                   if (is.na(NA_character_)) 
[18:04:21.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.164]                     .init = FALSE)
[18:04:21.164]                 }
[18:04:21.164]             }
[18:04:21.164]         }
[18:04:21.164]     })
[18:04:21.164]     if (TRUE) {
[18:04:21.164]         base::sink(type = "output", split = FALSE)
[18:04:21.164]         if (TRUE) {
[18:04:21.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.164]         }
[18:04:21.164]         else {
[18:04:21.164]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.164]         }
[18:04:21.164]         base::close(...future.stdout)
[18:04:21.164]         ...future.stdout <- NULL
[18:04:21.164]     }
[18:04:21.164]     ...future.result$conditions <- ...future.conditions
[18:04:21.164]     ...future.result$finished <- base::Sys.time()
[18:04:21.164]     ...future.result
[18:04:21.164] }
[18:04:21.175] MultisessionFuture started
[18:04:21.175] - Launch lazy future ... done
[18:04:21.176] run() for ‘MultisessionFuture’ ... done
[18:04:21.176] getGlobalsAndPackages() ...
[18:04:21.176] Searching for globals...
[18:04:21.183] - globals found: [1] ‘{’
[18:04:21.183] Searching for globals ... DONE
[18:04:21.183] Resolving globals: FALSE
[18:04:21.187] 
[18:04:21.188] 
[18:04:21.188] getGlobalsAndPackages() ... DONE
[18:04:21.191] run() for ‘Future’ ...
[18:04:21.192] - state: ‘created’
[18:04:21.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.232] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.232] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:21.233]   - Field: ‘node’
[18:04:21.233]   - Field: ‘label’
[18:04:21.233]   - Field: ‘local’
[18:04:21.233]   - Field: ‘owner’
[18:04:21.234]   - Field: ‘envir’
[18:04:21.234]   - Field: ‘workers’
[18:04:21.234]   - Field: ‘packages’
[18:04:21.234]   - Field: ‘gc’
[18:04:21.234]   - Field: ‘conditions’
[18:04:21.235]   - Field: ‘persistent’
[18:04:21.235]   - Field: ‘expr’
[18:04:21.235]   - Field: ‘uuid’
[18:04:21.235]   - Field: ‘seed’
[18:04:21.235]   - Field: ‘version’
[18:04:21.236]   - Field: ‘result’
[18:04:21.236]   - Field: ‘asynchronous’
[18:04:21.236]   - Field: ‘calls’
[18:04:21.236]   - Field: ‘globals’
[18:04:21.236]   - Field: ‘stdout’
[18:04:21.237]   - Field: ‘earlySignal’
[18:04:21.237]   - Field: ‘lazy’
[18:04:21.237]   - Field: ‘state’
[18:04:21.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:21.237] - Launch lazy future ...
[18:04:21.238] Packages needed by the future expression (n = 0): <none>
[18:04:21.238] Packages needed by future strategies (n = 0): <none>
[18:04:21.239] {
[18:04:21.239]     {
[18:04:21.239]         {
[18:04:21.239]             ...future.startTime <- base::Sys.time()
[18:04:21.239]             {
[18:04:21.239]                 {
[18:04:21.239]                   {
[18:04:21.239]                     {
[18:04:21.239]                       base::local({
[18:04:21.239]                         has_future <- base::requireNamespace("future", 
[18:04:21.239]                           quietly = TRUE)
[18:04:21.239]                         if (has_future) {
[18:04:21.239]                           ns <- base::getNamespace("future")
[18:04:21.239]                           version <- ns[[".package"]][["version"]]
[18:04:21.239]                           if (is.null(version)) 
[18:04:21.239]                             version <- utils::packageVersion("future")
[18:04:21.239]                         }
[18:04:21.239]                         else {
[18:04:21.239]                           version <- NULL
[18:04:21.239]                         }
[18:04:21.239]                         if (!has_future || version < "1.8.0") {
[18:04:21.239]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.239]                             "", base::R.version$version.string), 
[18:04:21.239]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.239]                               "release", "version")], collapse = " "), 
[18:04:21.239]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.239]                             info)
[18:04:21.239]                           info <- base::paste(info, collapse = "; ")
[18:04:21.239]                           if (!has_future) {
[18:04:21.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.239]                               info)
[18:04:21.239]                           }
[18:04:21.239]                           else {
[18:04:21.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.239]                               info, version)
[18:04:21.239]                           }
[18:04:21.239]                           base::stop(msg)
[18:04:21.239]                         }
[18:04:21.239]                       })
[18:04:21.239]                     }
[18:04:21.239]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.239]                     base::options(mc.cores = 1L)
[18:04:21.239]                   }
[18:04:21.239]                   ...future.strategy.old <- future::plan("list")
[18:04:21.239]                   options(future.plan = NULL)
[18:04:21.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.239]                 }
[18:04:21.239]                 ...future.workdir <- getwd()
[18:04:21.239]             }
[18:04:21.239]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.239]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.239]         }
[18:04:21.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.239]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.239]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.239]             base::names(...future.oldOptions))
[18:04:21.239]     }
[18:04:21.239]     if (FALSE) {
[18:04:21.239]     }
[18:04:21.239]     else {
[18:04:21.239]         if (TRUE) {
[18:04:21.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.239]                 open = "w")
[18:04:21.239]         }
[18:04:21.239]         else {
[18:04:21.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.239]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.239]         }
[18:04:21.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.239]             base::sink(type = "output", split = FALSE)
[18:04:21.239]             base::close(...future.stdout)
[18:04:21.239]         }, add = TRUE)
[18:04:21.239]     }
[18:04:21.239]     ...future.frame <- base::sys.nframe()
[18:04:21.239]     ...future.conditions <- base::list()
[18:04:21.239]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.239]     if (FALSE) {
[18:04:21.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.239]     }
[18:04:21.239]     ...future.result <- base::tryCatch({
[18:04:21.239]         base::withCallingHandlers({
[18:04:21.239]             ...future.value <- base::withVisible(base::local({
[18:04:21.239]                 ...future.makeSendCondition <- base::local({
[18:04:21.239]                   sendCondition <- NULL
[18:04:21.239]                   function(frame = 1L) {
[18:04:21.239]                     if (is.function(sendCondition)) 
[18:04:21.239]                       return(sendCondition)
[18:04:21.239]                     ns <- getNamespace("parallel")
[18:04:21.239]                     if (exists("sendData", mode = "function", 
[18:04:21.239]                       envir = ns)) {
[18:04:21.239]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:21.239]                         envir = ns)
[18:04:21.239]                       envir <- sys.frame(frame)
[18:04:21.239]                       master <- NULL
[18:04:21.239]                       while (!identical(envir, .GlobalEnv) && 
[18:04:21.239]                         !identical(envir, emptyenv())) {
[18:04:21.239]                         if (exists("master", mode = "list", envir = envir, 
[18:04:21.239]                           inherits = FALSE)) {
[18:04:21.239]                           master <- get("master", mode = "list", 
[18:04:21.239]                             envir = envir, inherits = FALSE)
[18:04:21.239]                           if (inherits(master, c("SOCKnode", 
[18:04:21.239]                             "SOCK0node"))) {
[18:04:21.239]                             sendCondition <<- function(cond) {
[18:04:21.239]                               data <- list(type = "VALUE", value = cond, 
[18:04:21.239]                                 success = TRUE)
[18:04:21.239]                               parallel_sendData(master, data)
[18:04:21.239]                             }
[18:04:21.239]                             return(sendCondition)
[18:04:21.239]                           }
[18:04:21.239]                         }
[18:04:21.239]                         frame <- frame + 1L
[18:04:21.239]                         envir <- sys.frame(frame)
[18:04:21.239]                       }
[18:04:21.239]                     }
[18:04:21.239]                     sendCondition <<- function(cond) NULL
[18:04:21.239]                   }
[18:04:21.239]                 })
[18:04:21.239]                 withCallingHandlers({
[18:04:21.239]                   {
[18:04:21.239]                     4
[18:04:21.239]                   }
[18:04:21.239]                 }, immediateCondition = function(cond) {
[18:04:21.239]                   sendCondition <- ...future.makeSendCondition()
[18:04:21.239]                   sendCondition(cond)
[18:04:21.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.239]                   {
[18:04:21.239]                     inherits <- base::inherits
[18:04:21.239]                     invokeRestart <- base::invokeRestart
[18:04:21.239]                     is.null <- base::is.null
[18:04:21.239]                     muffled <- FALSE
[18:04:21.239]                     if (inherits(cond, "message")) {
[18:04:21.239]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.239]                       if (muffled) 
[18:04:21.239]                         invokeRestart("muffleMessage")
[18:04:21.239]                     }
[18:04:21.239]                     else if (inherits(cond, "warning")) {
[18:04:21.239]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.239]                       if (muffled) 
[18:04:21.239]                         invokeRestart("muffleWarning")
[18:04:21.239]                     }
[18:04:21.239]                     else if (inherits(cond, "condition")) {
[18:04:21.239]                       if (!is.null(pattern)) {
[18:04:21.239]                         computeRestarts <- base::computeRestarts
[18:04:21.239]                         grepl <- base::grepl
[18:04:21.239]                         restarts <- computeRestarts(cond)
[18:04:21.239]                         for (restart in restarts) {
[18:04:21.239]                           name <- restart$name
[18:04:21.239]                           if (is.null(name)) 
[18:04:21.239]                             next
[18:04:21.239]                           if (!grepl(pattern, name)) 
[18:04:21.239]                             next
[18:04:21.239]                           invokeRestart(restart)
[18:04:21.239]                           muffled <- TRUE
[18:04:21.239]                           break
[18:04:21.239]                         }
[18:04:21.239]                       }
[18:04:21.239]                     }
[18:04:21.239]                     invisible(muffled)
[18:04:21.239]                   }
[18:04:21.239]                   muffleCondition(cond)
[18:04:21.239]                 })
[18:04:21.239]             }))
[18:04:21.239]             future::FutureResult(value = ...future.value$value, 
[18:04:21.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.239]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.239]                     ...future.globalenv.names))
[18:04:21.239]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.239]         }, condition = base::local({
[18:04:21.239]             c <- base::c
[18:04:21.239]             inherits <- base::inherits
[18:04:21.239]             invokeRestart <- base::invokeRestart
[18:04:21.239]             length <- base::length
[18:04:21.239]             list <- base::list
[18:04:21.239]             seq.int <- base::seq.int
[18:04:21.239]             signalCondition <- base::signalCondition
[18:04:21.239]             sys.calls <- base::sys.calls
[18:04:21.239]             `[[` <- base::`[[`
[18:04:21.239]             `+` <- base::`+`
[18:04:21.239]             `<<-` <- base::`<<-`
[18:04:21.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.239]                   3L)]
[18:04:21.239]             }
[18:04:21.239]             function(cond) {
[18:04:21.239]                 is_error <- inherits(cond, "error")
[18:04:21.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.239]                   NULL)
[18:04:21.239]                 if (is_error) {
[18:04:21.239]                   sessionInformation <- function() {
[18:04:21.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.239]                       search = base::search(), system = base::Sys.info())
[18:04:21.239]                   }
[18:04:21.239]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.239]                     cond$call), session = sessionInformation(), 
[18:04:21.239]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.239]                   signalCondition(cond)
[18:04:21.239]                 }
[18:04:21.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.239]                 "immediateCondition"))) {
[18:04:21.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.239]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.239]                   if (TRUE && !signal) {
[18:04:21.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.239]                     {
[18:04:21.239]                       inherits <- base::inherits
[18:04:21.239]                       invokeRestart <- base::invokeRestart
[18:04:21.239]                       is.null <- base::is.null
[18:04:21.239]                       muffled <- FALSE
[18:04:21.239]                       if (inherits(cond, "message")) {
[18:04:21.239]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.239]                         if (muffled) 
[18:04:21.239]                           invokeRestart("muffleMessage")
[18:04:21.239]                       }
[18:04:21.239]                       else if (inherits(cond, "warning")) {
[18:04:21.239]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.239]                         if (muffled) 
[18:04:21.239]                           invokeRestart("muffleWarning")
[18:04:21.239]                       }
[18:04:21.239]                       else if (inherits(cond, "condition")) {
[18:04:21.239]                         if (!is.null(pattern)) {
[18:04:21.239]                           computeRestarts <- base::computeRestarts
[18:04:21.239]                           grepl <- base::grepl
[18:04:21.239]                           restarts <- computeRestarts(cond)
[18:04:21.239]                           for (restart in restarts) {
[18:04:21.239]                             name <- restart$name
[18:04:21.239]                             if (is.null(name)) 
[18:04:21.239]                               next
[18:04:21.239]                             if (!grepl(pattern, name)) 
[18:04:21.239]                               next
[18:04:21.239]                             invokeRestart(restart)
[18:04:21.239]                             muffled <- TRUE
[18:04:21.239]                             break
[18:04:21.239]                           }
[18:04:21.239]                         }
[18:04:21.239]                       }
[18:04:21.239]                       invisible(muffled)
[18:04:21.239]                     }
[18:04:21.239]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.239]                   }
[18:04:21.239]                 }
[18:04:21.239]                 else {
[18:04:21.239]                   if (TRUE) {
[18:04:21.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.239]                     {
[18:04:21.239]                       inherits <- base::inherits
[18:04:21.239]                       invokeRestart <- base::invokeRestart
[18:04:21.239]                       is.null <- base::is.null
[18:04:21.239]                       muffled <- FALSE
[18:04:21.239]                       if (inherits(cond, "message")) {
[18:04:21.239]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.239]                         if (muffled) 
[18:04:21.239]                           invokeRestart("muffleMessage")
[18:04:21.239]                       }
[18:04:21.239]                       else if (inherits(cond, "warning")) {
[18:04:21.239]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.239]                         if (muffled) 
[18:04:21.239]                           invokeRestart("muffleWarning")
[18:04:21.239]                       }
[18:04:21.239]                       else if (inherits(cond, "condition")) {
[18:04:21.239]                         if (!is.null(pattern)) {
[18:04:21.239]                           computeRestarts <- base::computeRestarts
[18:04:21.239]                           grepl <- base::grepl
[18:04:21.239]                           restarts <- computeRestarts(cond)
[18:04:21.239]                           for (restart in restarts) {
[18:04:21.239]                             name <- restart$name
[18:04:21.239]                             if (is.null(name)) 
[18:04:21.239]                               next
[18:04:21.239]                             if (!grepl(pattern, name)) 
[18:04:21.239]                               next
[18:04:21.239]                             invokeRestart(restart)
[18:04:21.239]                             muffled <- TRUE
[18:04:21.239]                             break
[18:04:21.239]                           }
[18:04:21.239]                         }
[18:04:21.239]                       }
[18:04:21.239]                       invisible(muffled)
[18:04:21.239]                     }
[18:04:21.239]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.239]                   }
[18:04:21.239]                 }
[18:04:21.239]             }
[18:04:21.239]         }))
[18:04:21.239]     }, error = function(ex) {
[18:04:21.239]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.239]                 ...future.rng), started = ...future.startTime, 
[18:04:21.239]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.239]             version = "1.8"), class = "FutureResult")
[18:04:21.239]     }, finally = {
[18:04:21.239]         if (!identical(...future.workdir, getwd())) 
[18:04:21.239]             setwd(...future.workdir)
[18:04:21.239]         {
[18:04:21.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.239]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.239]             }
[18:04:21.239]             base::options(...future.oldOptions)
[18:04:21.239]             if (.Platform$OS.type == "windows") {
[18:04:21.239]                 old_names <- names(...future.oldEnvVars)
[18:04:21.239]                 envs <- base::Sys.getenv()
[18:04:21.239]                 names <- names(envs)
[18:04:21.239]                 common <- intersect(names, old_names)
[18:04:21.239]                 added <- setdiff(names, old_names)
[18:04:21.239]                 removed <- setdiff(old_names, names)
[18:04:21.239]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.239]                   envs[common]]
[18:04:21.239]                 NAMES <- toupper(changed)
[18:04:21.239]                 args <- list()
[18:04:21.239]                 for (kk in seq_along(NAMES)) {
[18:04:21.239]                   name <- changed[[kk]]
[18:04:21.239]                   NAME <- NAMES[[kk]]
[18:04:21.239]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.239]                     next
[18:04:21.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.239]                 }
[18:04:21.239]                 NAMES <- toupper(added)
[18:04:21.239]                 for (kk in seq_along(NAMES)) {
[18:04:21.239]                   name <- added[[kk]]
[18:04:21.239]                   NAME <- NAMES[[kk]]
[18:04:21.239]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.239]                     next
[18:04:21.239]                   args[[name]] <- ""
[18:04:21.239]                 }
[18:04:21.239]                 NAMES <- toupper(removed)
[18:04:21.239]                 for (kk in seq_along(NAMES)) {
[18:04:21.239]                   name <- removed[[kk]]
[18:04:21.239]                   NAME <- NAMES[[kk]]
[18:04:21.239]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.239]                     next
[18:04:21.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.239]                 }
[18:04:21.239]                 if (length(args) > 0) 
[18:04:21.239]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.239]             }
[18:04:21.239]             else {
[18:04:21.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.239]             }
[18:04:21.239]             {
[18:04:21.239]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.239]                   0L) {
[18:04:21.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.239]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.239]                   base::options(opts)
[18:04:21.239]                 }
[18:04:21.239]                 {
[18:04:21.239]                   {
[18:04:21.239]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.239]                     NULL
[18:04:21.239]                   }
[18:04:21.239]                   options(future.plan = NULL)
[18:04:21.239]                   if (is.na(NA_character_)) 
[18:04:21.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.239]                     .init = FALSE)
[18:04:21.239]                 }
[18:04:21.239]             }
[18:04:21.239]         }
[18:04:21.239]     })
[18:04:21.239]     if (TRUE) {
[18:04:21.239]         base::sink(type = "output", split = FALSE)
[18:04:21.239]         if (TRUE) {
[18:04:21.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.239]         }
[18:04:21.239]         else {
[18:04:21.239]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.239]         }
[18:04:21.239]         base::close(...future.stdout)
[18:04:21.239]         ...future.stdout <- NULL
[18:04:21.239]     }
[18:04:21.239]     ...future.result$conditions <- ...future.conditions
[18:04:21.239]     ...future.result$finished <- base::Sys.time()
[18:04:21.239]     ...future.result
[18:04:21.239] }
[18:04:21.244] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:21.255] receiveMessageFromWorker() for ClusterFuture ...
[18:04:21.255] - Validating connection of MultisessionFuture
[18:04:21.256] - received message: FutureResult
[18:04:21.256] - Received FutureResult
[18:04:21.256] - Erased future from FutureRegistry
[18:04:21.256] result() for ClusterFuture ...
[18:04:21.257] - result already collected: FutureResult
[18:04:21.257] result() for ClusterFuture ... done
[18:04:21.257] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:21.257] result() for ClusterFuture ...
[18:04:21.257] - result already collected: FutureResult
[18:04:21.258] result() for ClusterFuture ... done
[18:04:21.258] result() for ClusterFuture ...
[18:04:21.258] - result already collected: FutureResult
[18:04:21.258] result() for ClusterFuture ... done
[18:04:21.263] MultisessionFuture started
[18:04:21.264] - Launch lazy future ... done
[18:04:21.264] run() for ‘MultisessionFuture’ ... done
<environment: 0x5e3c2d076370> 
<environment: 0x5e3c2ab4e6d8> 
[18:04:21.269] receiveMessageFromWorker() for ClusterFuture ...
[18:04:21.270] - Validating connection of MultisessionFuture
[18:04:21.270] - received message: FutureResult
[18:04:21.270] - Received FutureResult
[18:04:21.270] - Erased future from FutureRegistry
[18:04:21.271] result() for ClusterFuture ...
[18:04:21.271] - result already collected: FutureResult
[18:04:21.271] result() for ClusterFuture ... done
[18:04:21.271] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[18:04:21.285] resolve() on environment ...
[18:04:21.286]  recursive: 0
[18:04:21.287]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[18:04:21.287] signalConditionsASAP(numeric, pos=1) ...
[18:04:21.288] - nx: 4
[18:04:21.288] - relay: TRUE
[18:04:21.288] - stdout: TRUE
[18:04:21.288] - signal: TRUE
[18:04:21.288] - resignal: FALSE
[18:04:21.288] - force: TRUE
[18:04:21.289] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:21.289] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:21.289]  - until=2
[18:04:21.289]  - relaying element #2
[18:04:21.290] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:21.290] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:21.290] signalConditionsASAP(NULL, pos=1) ... done
[18:04:21.290]  length: 3 (resolved future 1)
[18:04:21.290] Future #2
[18:04:21.291] result() for ClusterFuture ...
[18:04:21.291] - result already collected: FutureResult
[18:04:21.291] result() for ClusterFuture ... done
[18:04:21.291] result() for ClusterFuture ...
[18:04:21.291] - result already collected: FutureResult
[18:04:21.292] result() for ClusterFuture ... done
[18:04:21.292] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:21.292] - nx: 4
[18:04:21.292] - relay: TRUE
[18:04:21.292] - stdout: TRUE
[18:04:21.293] - signal: TRUE
[18:04:21.293] - resignal: FALSE
[18:04:21.293] - force: TRUE
[18:04:21.293] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[18:04:21.294] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[18:04:21.294]  - until=2
[18:04:21.294]  - relaying element #2
[18:04:21.294] result() for ClusterFuture ...
[18:04:21.294] - result already collected: FutureResult
[18:04:21.295] result() for ClusterFuture ... done
[18:04:21.295] result() for ClusterFuture ...
[18:04:21.295] - result already collected: FutureResult
[18:04:21.295] result() for ClusterFuture ... done
[18:04:21.295] result() for ClusterFuture ...
[18:04:21.296] - result already collected: FutureResult
[18:04:21.296] result() for ClusterFuture ... done
[18:04:21.296] result() for ClusterFuture ...
[18:04:21.296] - result already collected: FutureResult
[18:04:21.296] result() for ClusterFuture ... done
[18:04:21.296] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:21.297] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:21.297] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:21.297]  length: 2 (resolved future 2)
[18:04:21.297] Future #3
[18:04:21.298] result() for ClusterFuture ...
[18:04:21.298] - result already collected: FutureResult
[18:04:21.298] result() for ClusterFuture ... done
[18:04:21.298] result() for ClusterFuture ...
[18:04:21.298] - result already collected: FutureResult
[18:04:21.298] result() for ClusterFuture ... done
[18:04:21.299] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:21.299] - nx: 4
[18:04:21.299] - relay: TRUE
[18:04:21.299] - stdout: TRUE
[18:04:21.299] - signal: TRUE
[18:04:21.300] - resignal: FALSE
[18:04:21.300] - force: TRUE
[18:04:21.300] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[18:04:21.300] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[18:04:21.300]  - until=3
[18:04:21.300]  - relaying element #3
[18:04:21.301] result() for ClusterFuture ...
[18:04:21.301] - result already collected: FutureResult
[18:04:21.301] result() for ClusterFuture ... done
[18:04:21.301] result() for ClusterFuture ...
[18:04:21.301] - result already collected: FutureResult
[18:04:21.302] result() for ClusterFuture ... done
[18:04:21.302] result() for ClusterFuture ...
[18:04:21.302] - result already collected: FutureResult
[18:04:21.302] result() for ClusterFuture ... done
[18:04:21.302] result() for ClusterFuture ...
[18:04:21.303] - result already collected: FutureResult
[18:04:21.303] result() for ClusterFuture ... done
[18:04:21.303] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:21.303] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:21.303] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:21.303]  length: 1 (resolved future 3)
[18:04:21.306] receiveMessageFromWorker() for ClusterFuture ...
[18:04:21.306] - Validating connection of MultisessionFuture
[18:04:21.307] - received message: FutureResult
[18:04:21.307] - Received FutureResult
[18:04:21.307] - Erased future from FutureRegistry
[18:04:21.307] result() for ClusterFuture ...
[18:04:21.308] - result already collected: FutureResult
[18:04:21.308] result() for ClusterFuture ... done
[18:04:21.308] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:21.308] Future #4
[18:04:21.308] result() for ClusterFuture ...
[18:04:21.309] - result already collected: FutureResult
[18:04:21.309] result() for ClusterFuture ... done
[18:04:21.309] result() for ClusterFuture ...
[18:04:21.309] - result already collected: FutureResult
[18:04:21.309] result() for ClusterFuture ... done
[18:04:21.310] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:21.310] - nx: 4
[18:04:21.310] - relay: TRUE
[18:04:21.310] - stdout: TRUE
[18:04:21.310] - signal: TRUE
[18:04:21.311] - resignal: FALSE
[18:04:21.311] - force: TRUE
[18:04:21.311] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[18:04:21.311] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[18:04:21.311]  - until=4
[18:04:21.311]  - relaying element #4
[18:04:21.312] result() for ClusterFuture ...
[18:04:21.312] - result already collected: FutureResult
[18:04:21.312] result() for ClusterFuture ... done
[18:04:21.312] result() for ClusterFuture ...
[18:04:21.312] - result already collected: FutureResult
[18:04:21.313] result() for ClusterFuture ... done
[18:04:21.313] result() for ClusterFuture ...
[18:04:21.313] - result already collected: FutureResult
[18:04:21.313] result() for ClusterFuture ... done
[18:04:21.313] result() for ClusterFuture ...
[18:04:21.314] - result already collected: FutureResult
[18:04:21.314] result() for ClusterFuture ... done
[18:04:21.314] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:21.314] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:21.314] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:21.315]  length: 0 (resolved future 4)
[18:04:21.315] Relaying remaining futures
[18:04:21.315] signalConditionsASAP(NULL, pos=0) ...
[18:04:21.315] - nx: 4
[18:04:21.315] - relay: TRUE
[18:04:21.315] - stdout: TRUE
[18:04:21.316] - signal: TRUE
[18:04:21.316] - resignal: FALSE
[18:04:21.316] - force: TRUE
[18:04:21.316] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:21.316] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[18:04:21.317] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[18:04:21.317] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[18:04:21.317] signalConditionsASAP(NULL, pos=0) ... done
[18:04:21.317] resolve() on environment ... DONE
[18:04:21.317] result() for ClusterFuture ...
[18:04:21.318] - result already collected: FutureResult
[18:04:21.318] result() for ClusterFuture ... done
[18:04:21.318] result() for ClusterFuture ...
[18:04:21.318] - result already collected: FutureResult
[18:04:21.318] result() for ClusterFuture ... done
[18:04:21.319] result() for ClusterFuture ...
[18:04:21.319] - result already collected: FutureResult
[18:04:21.319] result() for ClusterFuture ... done
[18:04:21.319] result() for ClusterFuture ...
[18:04:21.319] - result already collected: FutureResult
[18:04:21.319] result() for ClusterFuture ... done
[18:04:21.320] result() for ClusterFuture ...
[18:04:21.320] - result already collected: FutureResult
[18:04:21.320] result() for ClusterFuture ... done
[18:04:21.320] result() for ClusterFuture ...
[18:04:21.320] - result already collected: FutureResult
[18:04:21.321] result() for ClusterFuture ... done
<environment: 0x5e3c2989baa0> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[18:04:21.322] plan(): Setting new future strategy stack:
[18:04:21.322] List of future strategies:
[18:04:21.322] 1. multicore:
[18:04:21.322]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:21.322]    - tweaked: FALSE
[18:04:21.322]    - call: plan(strategy)
[18:04:21.330] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[18:04:21.330] getGlobalsAndPackages() ...
[18:04:21.330] Searching for globals...
[18:04:21.331] 
[18:04:21.331] Searching for globals ... DONE
[18:04:21.332] - globals: [0] <none>
[18:04:21.332] getGlobalsAndPackages() ... DONE
[18:04:21.332] run() for ‘Future’ ...
[18:04:21.333] - state: ‘created’
[18:04:21.333] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.341] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.341] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:21.341]   - Field: ‘label’
[18:04:21.342]   - Field: ‘local’
[18:04:21.342]   - Field: ‘owner’
[18:04:21.342]   - Field: ‘envir’
[18:04:21.342]   - Field: ‘workers’
[18:04:21.343]   - Field: ‘packages’
[18:04:21.343]   - Field: ‘gc’
[18:04:21.343]   - Field: ‘job’
[18:04:21.343]   - Field: ‘conditions’
[18:04:21.344]   - Field: ‘expr’
[18:04:21.344]   - Field: ‘uuid’
[18:04:21.344]   - Field: ‘seed’
[18:04:21.344]   - Field: ‘version’
[18:04:21.344]   - Field: ‘result’
[18:04:21.345]   - Field: ‘asynchronous’
[18:04:21.345]   - Field: ‘calls’
[18:04:21.346]   - Field: ‘globals’
[18:04:21.346]   - Field: ‘stdout’
[18:04:21.346]   - Field: ‘earlySignal’
[18:04:21.346]   - Field: ‘lazy’
[18:04:21.346]   - Field: ‘state’
[18:04:21.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:21.347] - Launch lazy future ...
[18:04:21.348] Packages needed by the future expression (n = 0): <none>
[18:04:21.348] Packages needed by future strategies (n = 0): <none>
[18:04:21.349] {
[18:04:21.349]     {
[18:04:21.349]         {
[18:04:21.349]             ...future.startTime <- base::Sys.time()
[18:04:21.349]             {
[18:04:21.349]                 {
[18:04:21.349]                   {
[18:04:21.349]                     {
[18:04:21.349]                       base::local({
[18:04:21.349]                         has_future <- base::requireNamespace("future", 
[18:04:21.349]                           quietly = TRUE)
[18:04:21.349]                         if (has_future) {
[18:04:21.349]                           ns <- base::getNamespace("future")
[18:04:21.349]                           version <- ns[[".package"]][["version"]]
[18:04:21.349]                           if (is.null(version)) 
[18:04:21.349]                             version <- utils::packageVersion("future")
[18:04:21.349]                         }
[18:04:21.349]                         else {
[18:04:21.349]                           version <- NULL
[18:04:21.349]                         }
[18:04:21.349]                         if (!has_future || version < "1.8.0") {
[18:04:21.349]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.349]                             "", base::R.version$version.string), 
[18:04:21.349]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.349]                               "release", "version")], collapse = " "), 
[18:04:21.349]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.349]                             info)
[18:04:21.349]                           info <- base::paste(info, collapse = "; ")
[18:04:21.349]                           if (!has_future) {
[18:04:21.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.349]                               info)
[18:04:21.349]                           }
[18:04:21.349]                           else {
[18:04:21.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.349]                               info, version)
[18:04:21.349]                           }
[18:04:21.349]                           base::stop(msg)
[18:04:21.349]                         }
[18:04:21.349]                       })
[18:04:21.349]                     }
[18:04:21.349]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.349]                     base::options(mc.cores = 1L)
[18:04:21.349]                   }
[18:04:21.349]                   ...future.strategy.old <- future::plan("list")
[18:04:21.349]                   options(future.plan = NULL)
[18:04:21.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.349]                 }
[18:04:21.349]                 ...future.workdir <- getwd()
[18:04:21.349]             }
[18:04:21.349]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.349]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.349]         }
[18:04:21.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.349]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.349]             base::names(...future.oldOptions))
[18:04:21.349]     }
[18:04:21.349]     if (FALSE) {
[18:04:21.349]     }
[18:04:21.349]     else {
[18:04:21.349]         if (TRUE) {
[18:04:21.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.349]                 open = "w")
[18:04:21.349]         }
[18:04:21.349]         else {
[18:04:21.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.349]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.349]         }
[18:04:21.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.349]             base::sink(type = "output", split = FALSE)
[18:04:21.349]             base::close(...future.stdout)
[18:04:21.349]         }, add = TRUE)
[18:04:21.349]     }
[18:04:21.349]     ...future.frame <- base::sys.nframe()
[18:04:21.349]     ...future.conditions <- base::list()
[18:04:21.349]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.349]     if (FALSE) {
[18:04:21.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.349]     }
[18:04:21.349]     ...future.result <- base::tryCatch({
[18:04:21.349]         base::withCallingHandlers({
[18:04:21.349]             ...future.value <- base::withVisible(base::local({
[18:04:21.349]                 withCallingHandlers({
[18:04:21.349]                   2
[18:04:21.349]                 }, immediateCondition = function(cond) {
[18:04:21.349]                   save_rds <- function (object, pathname, ...) 
[18:04:21.349]                   {
[18:04:21.349]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:21.349]                     if (file_test("-f", pathname_tmp)) {
[18:04:21.349]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.349]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:21.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.349]                         fi_tmp[["mtime"]])
[18:04:21.349]                     }
[18:04:21.349]                     tryCatch({
[18:04:21.349]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:21.349]                     }, error = function(ex) {
[18:04:21.349]                       msg <- conditionMessage(ex)
[18:04:21.349]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.349]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:21.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.349]                         fi_tmp[["mtime"]], msg)
[18:04:21.349]                       ex$message <- msg
[18:04:21.349]                       stop(ex)
[18:04:21.349]                     })
[18:04:21.349]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:21.349]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:21.349]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:21.349]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.349]                       fi <- file.info(pathname)
[18:04:21.349]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:21.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.349]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:21.349]                         fi[["size"]], fi[["mtime"]])
[18:04:21.349]                       stop(msg)
[18:04:21.349]                     }
[18:04:21.349]                     invisible(pathname)
[18:04:21.349]                   }
[18:04:21.349]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:21.349]                     rootPath = tempdir()) 
[18:04:21.349]                   {
[18:04:21.349]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:21.349]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:21.349]                       tmpdir = path, fileext = ".rds")
[18:04:21.349]                     save_rds(obj, file)
[18:04:21.349]                   }
[18:04:21.349]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:21.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.349]                   {
[18:04:21.349]                     inherits <- base::inherits
[18:04:21.349]                     invokeRestart <- base::invokeRestart
[18:04:21.349]                     is.null <- base::is.null
[18:04:21.349]                     muffled <- FALSE
[18:04:21.349]                     if (inherits(cond, "message")) {
[18:04:21.349]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.349]                       if (muffled) 
[18:04:21.349]                         invokeRestart("muffleMessage")
[18:04:21.349]                     }
[18:04:21.349]                     else if (inherits(cond, "warning")) {
[18:04:21.349]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.349]                       if (muffled) 
[18:04:21.349]                         invokeRestart("muffleWarning")
[18:04:21.349]                     }
[18:04:21.349]                     else if (inherits(cond, "condition")) {
[18:04:21.349]                       if (!is.null(pattern)) {
[18:04:21.349]                         computeRestarts <- base::computeRestarts
[18:04:21.349]                         grepl <- base::grepl
[18:04:21.349]                         restarts <- computeRestarts(cond)
[18:04:21.349]                         for (restart in restarts) {
[18:04:21.349]                           name <- restart$name
[18:04:21.349]                           if (is.null(name)) 
[18:04:21.349]                             next
[18:04:21.349]                           if (!grepl(pattern, name)) 
[18:04:21.349]                             next
[18:04:21.349]                           invokeRestart(restart)
[18:04:21.349]                           muffled <- TRUE
[18:04:21.349]                           break
[18:04:21.349]                         }
[18:04:21.349]                       }
[18:04:21.349]                     }
[18:04:21.349]                     invisible(muffled)
[18:04:21.349]                   }
[18:04:21.349]                   muffleCondition(cond)
[18:04:21.349]                 })
[18:04:21.349]             }))
[18:04:21.349]             future::FutureResult(value = ...future.value$value, 
[18:04:21.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.349]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.349]                     ...future.globalenv.names))
[18:04:21.349]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.349]         }, condition = base::local({
[18:04:21.349]             c <- base::c
[18:04:21.349]             inherits <- base::inherits
[18:04:21.349]             invokeRestart <- base::invokeRestart
[18:04:21.349]             length <- base::length
[18:04:21.349]             list <- base::list
[18:04:21.349]             seq.int <- base::seq.int
[18:04:21.349]             signalCondition <- base::signalCondition
[18:04:21.349]             sys.calls <- base::sys.calls
[18:04:21.349]             `[[` <- base::`[[`
[18:04:21.349]             `+` <- base::`+`
[18:04:21.349]             `<<-` <- base::`<<-`
[18:04:21.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.349]                   3L)]
[18:04:21.349]             }
[18:04:21.349]             function(cond) {
[18:04:21.349]                 is_error <- inherits(cond, "error")
[18:04:21.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.349]                   NULL)
[18:04:21.349]                 if (is_error) {
[18:04:21.349]                   sessionInformation <- function() {
[18:04:21.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.349]                       search = base::search(), system = base::Sys.info())
[18:04:21.349]                   }
[18:04:21.349]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.349]                     cond$call), session = sessionInformation(), 
[18:04:21.349]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.349]                   signalCondition(cond)
[18:04:21.349]                 }
[18:04:21.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.349]                 "immediateCondition"))) {
[18:04:21.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.349]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.349]                   if (TRUE && !signal) {
[18:04:21.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.349]                     {
[18:04:21.349]                       inherits <- base::inherits
[18:04:21.349]                       invokeRestart <- base::invokeRestart
[18:04:21.349]                       is.null <- base::is.null
[18:04:21.349]                       muffled <- FALSE
[18:04:21.349]                       if (inherits(cond, "message")) {
[18:04:21.349]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.349]                         if (muffled) 
[18:04:21.349]                           invokeRestart("muffleMessage")
[18:04:21.349]                       }
[18:04:21.349]                       else if (inherits(cond, "warning")) {
[18:04:21.349]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.349]                         if (muffled) 
[18:04:21.349]                           invokeRestart("muffleWarning")
[18:04:21.349]                       }
[18:04:21.349]                       else if (inherits(cond, "condition")) {
[18:04:21.349]                         if (!is.null(pattern)) {
[18:04:21.349]                           computeRestarts <- base::computeRestarts
[18:04:21.349]                           grepl <- base::grepl
[18:04:21.349]                           restarts <- computeRestarts(cond)
[18:04:21.349]                           for (restart in restarts) {
[18:04:21.349]                             name <- restart$name
[18:04:21.349]                             if (is.null(name)) 
[18:04:21.349]                               next
[18:04:21.349]                             if (!grepl(pattern, name)) 
[18:04:21.349]                               next
[18:04:21.349]                             invokeRestart(restart)
[18:04:21.349]                             muffled <- TRUE
[18:04:21.349]                             break
[18:04:21.349]                           }
[18:04:21.349]                         }
[18:04:21.349]                       }
[18:04:21.349]                       invisible(muffled)
[18:04:21.349]                     }
[18:04:21.349]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.349]                   }
[18:04:21.349]                 }
[18:04:21.349]                 else {
[18:04:21.349]                   if (TRUE) {
[18:04:21.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.349]                     {
[18:04:21.349]                       inherits <- base::inherits
[18:04:21.349]                       invokeRestart <- base::invokeRestart
[18:04:21.349]                       is.null <- base::is.null
[18:04:21.349]                       muffled <- FALSE
[18:04:21.349]                       if (inherits(cond, "message")) {
[18:04:21.349]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.349]                         if (muffled) 
[18:04:21.349]                           invokeRestart("muffleMessage")
[18:04:21.349]                       }
[18:04:21.349]                       else if (inherits(cond, "warning")) {
[18:04:21.349]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.349]                         if (muffled) 
[18:04:21.349]                           invokeRestart("muffleWarning")
[18:04:21.349]                       }
[18:04:21.349]                       else if (inherits(cond, "condition")) {
[18:04:21.349]                         if (!is.null(pattern)) {
[18:04:21.349]                           computeRestarts <- base::computeRestarts
[18:04:21.349]                           grepl <- base::grepl
[18:04:21.349]                           restarts <- computeRestarts(cond)
[18:04:21.349]                           for (restart in restarts) {
[18:04:21.349]                             name <- restart$name
[18:04:21.349]                             if (is.null(name)) 
[18:04:21.349]                               next
[18:04:21.349]                             if (!grepl(pattern, name)) 
[18:04:21.349]                               next
[18:04:21.349]                             invokeRestart(restart)
[18:04:21.349]                             muffled <- TRUE
[18:04:21.349]                             break
[18:04:21.349]                           }
[18:04:21.349]                         }
[18:04:21.349]                       }
[18:04:21.349]                       invisible(muffled)
[18:04:21.349]                     }
[18:04:21.349]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.349]                   }
[18:04:21.349]                 }
[18:04:21.349]             }
[18:04:21.349]         }))
[18:04:21.349]     }, error = function(ex) {
[18:04:21.349]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.349]                 ...future.rng), started = ...future.startTime, 
[18:04:21.349]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.349]             version = "1.8"), class = "FutureResult")
[18:04:21.349]     }, finally = {
[18:04:21.349]         if (!identical(...future.workdir, getwd())) 
[18:04:21.349]             setwd(...future.workdir)
[18:04:21.349]         {
[18:04:21.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.349]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.349]             }
[18:04:21.349]             base::options(...future.oldOptions)
[18:04:21.349]             if (.Platform$OS.type == "windows") {
[18:04:21.349]                 old_names <- names(...future.oldEnvVars)
[18:04:21.349]                 envs <- base::Sys.getenv()
[18:04:21.349]                 names <- names(envs)
[18:04:21.349]                 common <- intersect(names, old_names)
[18:04:21.349]                 added <- setdiff(names, old_names)
[18:04:21.349]                 removed <- setdiff(old_names, names)
[18:04:21.349]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.349]                   envs[common]]
[18:04:21.349]                 NAMES <- toupper(changed)
[18:04:21.349]                 args <- list()
[18:04:21.349]                 for (kk in seq_along(NAMES)) {
[18:04:21.349]                   name <- changed[[kk]]
[18:04:21.349]                   NAME <- NAMES[[kk]]
[18:04:21.349]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.349]                     next
[18:04:21.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.349]                 }
[18:04:21.349]                 NAMES <- toupper(added)
[18:04:21.349]                 for (kk in seq_along(NAMES)) {
[18:04:21.349]                   name <- added[[kk]]
[18:04:21.349]                   NAME <- NAMES[[kk]]
[18:04:21.349]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.349]                     next
[18:04:21.349]                   args[[name]] <- ""
[18:04:21.349]                 }
[18:04:21.349]                 NAMES <- toupper(removed)
[18:04:21.349]                 for (kk in seq_along(NAMES)) {
[18:04:21.349]                   name <- removed[[kk]]
[18:04:21.349]                   NAME <- NAMES[[kk]]
[18:04:21.349]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.349]                     next
[18:04:21.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.349]                 }
[18:04:21.349]                 if (length(args) > 0) 
[18:04:21.349]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.349]             }
[18:04:21.349]             else {
[18:04:21.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.349]             }
[18:04:21.349]             {
[18:04:21.349]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.349]                   0L) {
[18:04:21.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.349]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.349]                   base::options(opts)
[18:04:21.349]                 }
[18:04:21.349]                 {
[18:04:21.349]                   {
[18:04:21.349]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.349]                     NULL
[18:04:21.349]                   }
[18:04:21.349]                   options(future.plan = NULL)
[18:04:21.349]                   if (is.na(NA_character_)) 
[18:04:21.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.349]                     .init = FALSE)
[18:04:21.349]                 }
[18:04:21.349]             }
[18:04:21.349]         }
[18:04:21.349]     })
[18:04:21.349]     if (TRUE) {
[18:04:21.349]         base::sink(type = "output", split = FALSE)
[18:04:21.349]         if (TRUE) {
[18:04:21.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.349]         }
[18:04:21.349]         else {
[18:04:21.349]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.349]         }
[18:04:21.349]         base::close(...future.stdout)
[18:04:21.349]         ...future.stdout <- NULL
[18:04:21.349]     }
[18:04:21.349]     ...future.result$conditions <- ...future.conditions
[18:04:21.349]     ...future.result$finished <- base::Sys.time()
[18:04:21.349]     ...future.result
[18:04:21.349] }
[18:04:21.353] requestCore(): workers = 2
[18:04:21.357] MulticoreFuture started
[18:04:21.358] - Launch lazy future ... done
[18:04:21.359] run() for ‘MulticoreFuture’ ... done
[18:04:21.359] getGlobalsAndPackages() ...
[18:04:21.360] Searching for globals...
[18:04:21.360] plan(): Setting new future strategy stack:
[18:04:21.362] 
[18:04:21.363] Searching for globals ... DONE
[18:04:21.363] - globals: [0] <none>
[18:04:21.363] getGlobalsAndPackages() ... DONE
[18:04:21.362] List of future strategies:
[18:04:21.362] 1. sequential:
[18:04:21.362]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:21.362]    - tweaked: FALSE
[18:04:21.362]    - call: NULL
[18:04:21.365] plan(): nbrOfWorkers() = 1
[18:04:21.365] run() for ‘Future’ ...
[18:04:21.365] - state: ‘created’
[18:04:21.366] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.369] plan(): Setting new future strategy stack:
[18:04:21.369] List of future strategies:
[18:04:21.369] 1. multicore:
[18:04:21.369]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:21.369]    - tweaked: FALSE
[18:04:21.369]    - call: plan(strategy)
[18:04:21.380] plan(): nbrOfWorkers() = 2
[18:04:21.380] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.381] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:21.381]   - Field: ‘label’
[18:04:21.381]   - Field: ‘local’
[18:04:21.382]   - Field: ‘owner’
[18:04:21.382]   - Field: ‘envir’
[18:04:21.382]   - Field: ‘workers’
[18:04:21.383]   - Field: ‘packages’
[18:04:21.383]   - Field: ‘gc’
[18:04:21.383]   - Field: ‘job’
[18:04:21.383]   - Field: ‘conditions’
[18:04:21.384]   - Field: ‘expr’
[18:04:21.384]   - Field: ‘uuid’
[18:04:21.384]   - Field: ‘seed’
[18:04:21.385]   - Field: ‘version’
[18:04:21.385]   - Field: ‘result’
[18:04:21.385]   - Field: ‘asynchronous’
[18:04:21.386]   - Field: ‘calls’
[18:04:21.386]   - Field: ‘globals’
[18:04:21.386]   - Field: ‘stdout’
[18:04:21.386]   - Field: ‘earlySignal’
[18:04:21.387]   - Field: ‘lazy’
[18:04:21.387]   - Field: ‘state’
[18:04:21.387] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:21.388] - Launch lazy future ...
[18:04:21.389] Packages needed by the future expression (n = 0): <none>
[18:04:21.389] Packages needed by future strategies (n = 0): <none>
[18:04:21.391] {
[18:04:21.391]     {
[18:04:21.391]         {
[18:04:21.391]             ...future.startTime <- base::Sys.time()
[18:04:21.391]             {
[18:04:21.391]                 {
[18:04:21.391]                   {
[18:04:21.391]                     {
[18:04:21.391]                       base::local({
[18:04:21.391]                         has_future <- base::requireNamespace("future", 
[18:04:21.391]                           quietly = TRUE)
[18:04:21.391]                         if (has_future) {
[18:04:21.391]                           ns <- base::getNamespace("future")
[18:04:21.391]                           version <- ns[[".package"]][["version"]]
[18:04:21.391]                           if (is.null(version)) 
[18:04:21.391]                             version <- utils::packageVersion("future")
[18:04:21.391]                         }
[18:04:21.391]                         else {
[18:04:21.391]                           version <- NULL
[18:04:21.391]                         }
[18:04:21.391]                         if (!has_future || version < "1.8.0") {
[18:04:21.391]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.391]                             "", base::R.version$version.string), 
[18:04:21.391]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.391]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.391]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.391]                               "release", "version")], collapse = " "), 
[18:04:21.391]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.391]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.391]                             info)
[18:04:21.391]                           info <- base::paste(info, collapse = "; ")
[18:04:21.391]                           if (!has_future) {
[18:04:21.391]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.391]                               info)
[18:04:21.391]                           }
[18:04:21.391]                           else {
[18:04:21.391]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.391]                               info, version)
[18:04:21.391]                           }
[18:04:21.391]                           base::stop(msg)
[18:04:21.391]                         }
[18:04:21.391]                       })
[18:04:21.391]                     }
[18:04:21.391]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.391]                     base::options(mc.cores = 1L)
[18:04:21.391]                   }
[18:04:21.391]                   ...future.strategy.old <- future::plan("list")
[18:04:21.391]                   options(future.plan = NULL)
[18:04:21.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.391]                 }
[18:04:21.391]                 ...future.workdir <- getwd()
[18:04:21.391]             }
[18:04:21.391]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.391]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.391]         }
[18:04:21.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.391]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.391]             base::names(...future.oldOptions))
[18:04:21.391]     }
[18:04:21.391]     if (FALSE) {
[18:04:21.391]     }
[18:04:21.391]     else {
[18:04:21.391]         if (TRUE) {
[18:04:21.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.391]                 open = "w")
[18:04:21.391]         }
[18:04:21.391]         else {
[18:04:21.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.391]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.391]         }
[18:04:21.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.391]             base::sink(type = "output", split = FALSE)
[18:04:21.391]             base::close(...future.stdout)
[18:04:21.391]         }, add = TRUE)
[18:04:21.391]     }
[18:04:21.391]     ...future.frame <- base::sys.nframe()
[18:04:21.391]     ...future.conditions <- base::list()
[18:04:21.391]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.391]     if (FALSE) {
[18:04:21.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.391]     }
[18:04:21.391]     ...future.result <- base::tryCatch({
[18:04:21.391]         base::withCallingHandlers({
[18:04:21.391]             ...future.value <- base::withVisible(base::local({
[18:04:21.391]                 withCallingHandlers({
[18:04:21.391]                   NULL
[18:04:21.391]                 }, immediateCondition = function(cond) {
[18:04:21.391]                   save_rds <- function (object, pathname, ...) 
[18:04:21.391]                   {
[18:04:21.391]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:21.391]                     if (file_test("-f", pathname_tmp)) {
[18:04:21.391]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.391]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:21.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.391]                         fi_tmp[["mtime"]])
[18:04:21.391]                     }
[18:04:21.391]                     tryCatch({
[18:04:21.391]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:21.391]                     }, error = function(ex) {
[18:04:21.391]                       msg <- conditionMessage(ex)
[18:04:21.391]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.391]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:21.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.391]                         fi_tmp[["mtime"]], msg)
[18:04:21.391]                       ex$message <- msg
[18:04:21.391]                       stop(ex)
[18:04:21.391]                     })
[18:04:21.391]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:21.391]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:21.391]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:21.391]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.391]                       fi <- file.info(pathname)
[18:04:21.391]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:21.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.391]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:21.391]                         fi[["size"]], fi[["mtime"]])
[18:04:21.391]                       stop(msg)
[18:04:21.391]                     }
[18:04:21.391]                     invisible(pathname)
[18:04:21.391]                   }
[18:04:21.391]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:21.391]                     rootPath = tempdir()) 
[18:04:21.391]                   {
[18:04:21.391]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:21.391]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:21.391]                       tmpdir = path, fileext = ".rds")
[18:04:21.391]                     save_rds(obj, file)
[18:04:21.391]                   }
[18:04:21.391]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:21.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.391]                   {
[18:04:21.391]                     inherits <- base::inherits
[18:04:21.391]                     invokeRestart <- base::invokeRestart
[18:04:21.391]                     is.null <- base::is.null
[18:04:21.391]                     muffled <- FALSE
[18:04:21.391]                     if (inherits(cond, "message")) {
[18:04:21.391]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.391]                       if (muffled) 
[18:04:21.391]                         invokeRestart("muffleMessage")
[18:04:21.391]                     }
[18:04:21.391]                     else if (inherits(cond, "warning")) {
[18:04:21.391]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.391]                       if (muffled) 
[18:04:21.391]                         invokeRestart("muffleWarning")
[18:04:21.391]                     }
[18:04:21.391]                     else if (inherits(cond, "condition")) {
[18:04:21.391]                       if (!is.null(pattern)) {
[18:04:21.391]                         computeRestarts <- base::computeRestarts
[18:04:21.391]                         grepl <- base::grepl
[18:04:21.391]                         restarts <- computeRestarts(cond)
[18:04:21.391]                         for (restart in restarts) {
[18:04:21.391]                           name <- restart$name
[18:04:21.391]                           if (is.null(name)) 
[18:04:21.391]                             next
[18:04:21.391]                           if (!grepl(pattern, name)) 
[18:04:21.391]                             next
[18:04:21.391]                           invokeRestart(restart)
[18:04:21.391]                           muffled <- TRUE
[18:04:21.391]                           break
[18:04:21.391]                         }
[18:04:21.391]                       }
[18:04:21.391]                     }
[18:04:21.391]                     invisible(muffled)
[18:04:21.391]                   }
[18:04:21.391]                   muffleCondition(cond)
[18:04:21.391]                 })
[18:04:21.391]             }))
[18:04:21.391]             future::FutureResult(value = ...future.value$value, 
[18:04:21.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.391]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.391]                     ...future.globalenv.names))
[18:04:21.391]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.391]         }, condition = base::local({
[18:04:21.391]             c <- base::c
[18:04:21.391]             inherits <- base::inherits
[18:04:21.391]             invokeRestart <- base::invokeRestart
[18:04:21.391]             length <- base::length
[18:04:21.391]             list <- base::list
[18:04:21.391]             seq.int <- base::seq.int
[18:04:21.391]             signalCondition <- base::signalCondition
[18:04:21.391]             sys.calls <- base::sys.calls
[18:04:21.391]             `[[` <- base::`[[`
[18:04:21.391]             `+` <- base::`+`
[18:04:21.391]             `<<-` <- base::`<<-`
[18:04:21.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.391]                   3L)]
[18:04:21.391]             }
[18:04:21.391]             function(cond) {
[18:04:21.391]                 is_error <- inherits(cond, "error")
[18:04:21.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.391]                   NULL)
[18:04:21.391]                 if (is_error) {
[18:04:21.391]                   sessionInformation <- function() {
[18:04:21.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.391]                       search = base::search(), system = base::Sys.info())
[18:04:21.391]                   }
[18:04:21.391]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.391]                     cond$call), session = sessionInformation(), 
[18:04:21.391]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.391]                   signalCondition(cond)
[18:04:21.391]                 }
[18:04:21.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.391]                 "immediateCondition"))) {
[18:04:21.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.391]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.391]                   if (TRUE && !signal) {
[18:04:21.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.391]                     {
[18:04:21.391]                       inherits <- base::inherits
[18:04:21.391]                       invokeRestart <- base::invokeRestart
[18:04:21.391]                       is.null <- base::is.null
[18:04:21.391]                       muffled <- FALSE
[18:04:21.391]                       if (inherits(cond, "message")) {
[18:04:21.391]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.391]                         if (muffled) 
[18:04:21.391]                           invokeRestart("muffleMessage")
[18:04:21.391]                       }
[18:04:21.391]                       else if (inherits(cond, "warning")) {
[18:04:21.391]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.391]                         if (muffled) 
[18:04:21.391]                           invokeRestart("muffleWarning")
[18:04:21.391]                       }
[18:04:21.391]                       else if (inherits(cond, "condition")) {
[18:04:21.391]                         if (!is.null(pattern)) {
[18:04:21.391]                           computeRestarts <- base::computeRestarts
[18:04:21.391]                           grepl <- base::grepl
[18:04:21.391]                           restarts <- computeRestarts(cond)
[18:04:21.391]                           for (restart in restarts) {
[18:04:21.391]                             name <- restart$name
[18:04:21.391]                             if (is.null(name)) 
[18:04:21.391]                               next
[18:04:21.391]                             if (!grepl(pattern, name)) 
[18:04:21.391]                               next
[18:04:21.391]                             invokeRestart(restart)
[18:04:21.391]                             muffled <- TRUE
[18:04:21.391]                             break
[18:04:21.391]                           }
[18:04:21.391]                         }
[18:04:21.391]                       }
[18:04:21.391]                       invisible(muffled)
[18:04:21.391]                     }
[18:04:21.391]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.391]                   }
[18:04:21.391]                 }
[18:04:21.391]                 else {
[18:04:21.391]                   if (TRUE) {
[18:04:21.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.391]                     {
[18:04:21.391]                       inherits <- base::inherits
[18:04:21.391]                       invokeRestart <- base::invokeRestart
[18:04:21.391]                       is.null <- base::is.null
[18:04:21.391]                       muffled <- FALSE
[18:04:21.391]                       if (inherits(cond, "message")) {
[18:04:21.391]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.391]                         if (muffled) 
[18:04:21.391]                           invokeRestart("muffleMessage")
[18:04:21.391]                       }
[18:04:21.391]                       else if (inherits(cond, "warning")) {
[18:04:21.391]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.391]                         if (muffled) 
[18:04:21.391]                           invokeRestart("muffleWarning")
[18:04:21.391]                       }
[18:04:21.391]                       else if (inherits(cond, "condition")) {
[18:04:21.391]                         if (!is.null(pattern)) {
[18:04:21.391]                           computeRestarts <- base::computeRestarts
[18:04:21.391]                           grepl <- base::grepl
[18:04:21.391]                           restarts <- computeRestarts(cond)
[18:04:21.391]                           for (restart in restarts) {
[18:04:21.391]                             name <- restart$name
[18:04:21.391]                             if (is.null(name)) 
[18:04:21.391]                               next
[18:04:21.391]                             if (!grepl(pattern, name)) 
[18:04:21.391]                               next
[18:04:21.391]                             invokeRestart(restart)
[18:04:21.391]                             muffled <- TRUE
[18:04:21.391]                             break
[18:04:21.391]                           }
[18:04:21.391]                         }
[18:04:21.391]                       }
[18:04:21.391]                       invisible(muffled)
[18:04:21.391]                     }
[18:04:21.391]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.391]                   }
[18:04:21.391]                 }
[18:04:21.391]             }
[18:04:21.391]         }))
[18:04:21.391]     }, error = function(ex) {
[18:04:21.391]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.391]                 ...future.rng), started = ...future.startTime, 
[18:04:21.391]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.391]             version = "1.8"), class = "FutureResult")
[18:04:21.391]     }, finally = {
[18:04:21.391]         if (!identical(...future.workdir, getwd())) 
[18:04:21.391]             setwd(...future.workdir)
[18:04:21.391]         {
[18:04:21.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.391]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.391]             }
[18:04:21.391]             base::options(...future.oldOptions)
[18:04:21.391]             if (.Platform$OS.type == "windows") {
[18:04:21.391]                 old_names <- names(...future.oldEnvVars)
[18:04:21.391]                 envs <- base::Sys.getenv()
[18:04:21.391]                 names <- names(envs)
[18:04:21.391]                 common <- intersect(names, old_names)
[18:04:21.391]                 added <- setdiff(names, old_names)
[18:04:21.391]                 removed <- setdiff(old_names, names)
[18:04:21.391]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.391]                   envs[common]]
[18:04:21.391]                 NAMES <- toupper(changed)
[18:04:21.391]                 args <- list()
[18:04:21.391]                 for (kk in seq_along(NAMES)) {
[18:04:21.391]                   name <- changed[[kk]]
[18:04:21.391]                   NAME <- NAMES[[kk]]
[18:04:21.391]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.391]                     next
[18:04:21.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.391]                 }
[18:04:21.391]                 NAMES <- toupper(added)
[18:04:21.391]                 for (kk in seq_along(NAMES)) {
[18:04:21.391]                   name <- added[[kk]]
[18:04:21.391]                   NAME <- NAMES[[kk]]
[18:04:21.391]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.391]                     next
[18:04:21.391]                   args[[name]] <- ""
[18:04:21.391]                 }
[18:04:21.391]                 NAMES <- toupper(removed)
[18:04:21.391]                 for (kk in seq_along(NAMES)) {
[18:04:21.391]                   name <- removed[[kk]]
[18:04:21.391]                   NAME <- NAMES[[kk]]
[18:04:21.391]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.391]                     next
[18:04:21.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.391]                 }
[18:04:21.391]                 if (length(args) > 0) 
[18:04:21.391]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.391]             }
[18:04:21.391]             else {
[18:04:21.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.391]             }
[18:04:21.391]             {
[18:04:21.391]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.391]                   0L) {
[18:04:21.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.391]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.391]                   base::options(opts)
[18:04:21.391]                 }
[18:04:21.391]                 {
[18:04:21.391]                   {
[18:04:21.391]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.391]                     NULL
[18:04:21.391]                   }
[18:04:21.391]                   options(future.plan = NULL)
[18:04:21.391]                   if (is.na(NA_character_)) 
[18:04:21.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.391]                     .init = FALSE)
[18:04:21.391]                 }
[18:04:21.391]             }
[18:04:21.391]         }
[18:04:21.391]     })
[18:04:21.391]     if (TRUE) {
[18:04:21.391]         base::sink(type = "output", split = FALSE)
[18:04:21.391]         if (TRUE) {
[18:04:21.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.391]         }
[18:04:21.391]         else {
[18:04:21.391]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.391]         }
[18:04:21.391]         base::close(...future.stdout)
[18:04:21.391]         ...future.stdout <- NULL
[18:04:21.391]     }
[18:04:21.391]     ...future.result$conditions <- ...future.conditions
[18:04:21.391]     ...future.result$finished <- base::Sys.time()
[18:04:21.391]     ...future.result
[18:04:21.391] }
[18:04:21.397] requestCore(): workers = 2
[18:04:21.402] MulticoreFuture started
[18:04:21.402] - Launch lazy future ... done
[18:04:21.403] run() for ‘MulticoreFuture’ ... done
[18:04:21.404] plan(): Setting new future strategy stack:
[18:04:21.405] getGlobalsAndPackages() ...
[18:04:21.405] Searching for globals...
[18:04:21.404] List of future strategies:
[18:04:21.404] 1. sequential:
[18:04:21.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:21.404]    - tweaked: FALSE
[18:04:21.404]    - call: NULL
[18:04:21.406] plan(): nbrOfWorkers() = 1
[18:04:21.408] - globals found: [1] ‘{’
[18:04:21.408] Searching for globals ... DONE
[18:04:21.408] Resolving globals: FALSE
[18:04:21.410] 
[18:04:21.410] 
[18:04:21.410] getGlobalsAndPackages() ... DONE
[18:04:21.410] plan(): Setting new future strategy stack:
[18:04:21.411] run() for ‘Future’ ...
[18:04:21.410] List of future strategies:
[18:04:21.410] 1. multicore:
[18:04:21.410]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:21.410]    - tweaked: FALSE
[18:04:21.410]    - call: plan(strategy)
[18:04:21.411] - state: ‘created’
[18:04:21.412] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.419] plan(): nbrOfWorkers() = 2
[18:04:21.420] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:21.421]   - Field: ‘label’
[18:04:21.421]   - Field: ‘local’
[18:04:21.422]   - Field: ‘owner’
[18:04:21.422]   - Field: ‘envir’
[18:04:21.422]   - Field: ‘workers’
[18:04:21.422]   - Field: ‘packages’
[18:04:21.423]   - Field: ‘gc’
[18:04:21.423]   - Field: ‘job’
[18:04:21.423]   - Field: ‘conditions’
[18:04:21.424]   - Field: ‘expr’
[18:04:21.424]   - Field: ‘uuid’
[18:04:21.424]   - Field: ‘seed’
[18:04:21.424]   - Field: ‘version’
[18:04:21.425]   - Field: ‘result’
[18:04:21.425]   - Field: ‘asynchronous’
[18:04:21.425]   - Field: ‘calls’
[18:04:21.426]   - Field: ‘globals’
[18:04:21.426]   - Field: ‘stdout’
[18:04:21.426]   - Field: ‘earlySignal’
[18:04:21.427]   - Field: ‘lazy’
[18:04:21.427]   - Field: ‘state’
[18:04:21.427] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:21.427] - Launch lazy future ...
[18:04:21.428] Packages needed by the future expression (n = 0): <none>
[18:04:21.429] Packages needed by future strategies (n = 0): <none>
[18:04:21.430] {
[18:04:21.430]     {
[18:04:21.430]         {
[18:04:21.430]             ...future.startTime <- base::Sys.time()
[18:04:21.430]             {
[18:04:21.430]                 {
[18:04:21.430]                   {
[18:04:21.430]                     {
[18:04:21.430]                       base::local({
[18:04:21.430]                         has_future <- base::requireNamespace("future", 
[18:04:21.430]                           quietly = TRUE)
[18:04:21.430]                         if (has_future) {
[18:04:21.430]                           ns <- base::getNamespace("future")
[18:04:21.430]                           version <- ns[[".package"]][["version"]]
[18:04:21.430]                           if (is.null(version)) 
[18:04:21.430]                             version <- utils::packageVersion("future")
[18:04:21.430]                         }
[18:04:21.430]                         else {
[18:04:21.430]                           version <- NULL
[18:04:21.430]                         }
[18:04:21.430]                         if (!has_future || version < "1.8.0") {
[18:04:21.430]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.430]                             "", base::R.version$version.string), 
[18:04:21.430]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.430]                               "release", "version")], collapse = " "), 
[18:04:21.430]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.430]                             info)
[18:04:21.430]                           info <- base::paste(info, collapse = "; ")
[18:04:21.430]                           if (!has_future) {
[18:04:21.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.430]                               info)
[18:04:21.430]                           }
[18:04:21.430]                           else {
[18:04:21.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.430]                               info, version)
[18:04:21.430]                           }
[18:04:21.430]                           base::stop(msg)
[18:04:21.430]                         }
[18:04:21.430]                       })
[18:04:21.430]                     }
[18:04:21.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.430]                     base::options(mc.cores = 1L)
[18:04:21.430]                   }
[18:04:21.430]                   ...future.strategy.old <- future::plan("list")
[18:04:21.430]                   options(future.plan = NULL)
[18:04:21.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.430]                 }
[18:04:21.430]                 ...future.workdir <- getwd()
[18:04:21.430]             }
[18:04:21.430]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.430]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.430]         }
[18:04:21.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.430]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.430]             base::names(...future.oldOptions))
[18:04:21.430]     }
[18:04:21.430]     if (FALSE) {
[18:04:21.430]     }
[18:04:21.430]     else {
[18:04:21.430]         if (TRUE) {
[18:04:21.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.430]                 open = "w")
[18:04:21.430]         }
[18:04:21.430]         else {
[18:04:21.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.430]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.430]         }
[18:04:21.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.430]             base::sink(type = "output", split = FALSE)
[18:04:21.430]             base::close(...future.stdout)
[18:04:21.430]         }, add = TRUE)
[18:04:21.430]     }
[18:04:21.430]     ...future.frame <- base::sys.nframe()
[18:04:21.430]     ...future.conditions <- base::list()
[18:04:21.430]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.430]     if (FALSE) {
[18:04:21.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.430]     }
[18:04:21.430]     ...future.result <- base::tryCatch({
[18:04:21.430]         base::withCallingHandlers({
[18:04:21.430]             ...future.value <- base::withVisible(base::local({
[18:04:21.430]                 withCallingHandlers({
[18:04:21.430]                   {
[18:04:21.430]                     4
[18:04:21.430]                   }
[18:04:21.430]                 }, immediateCondition = function(cond) {
[18:04:21.430]                   save_rds <- function (object, pathname, ...) 
[18:04:21.430]                   {
[18:04:21.430]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:21.430]                     if (file_test("-f", pathname_tmp)) {
[18:04:21.430]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.430]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:21.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.430]                         fi_tmp[["mtime"]])
[18:04:21.430]                     }
[18:04:21.430]                     tryCatch({
[18:04:21.430]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:21.430]                     }, error = function(ex) {
[18:04:21.430]                       msg <- conditionMessage(ex)
[18:04:21.430]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.430]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:21.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.430]                         fi_tmp[["mtime"]], msg)
[18:04:21.430]                       ex$message <- msg
[18:04:21.430]                       stop(ex)
[18:04:21.430]                     })
[18:04:21.430]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:21.430]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:21.430]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:21.430]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.430]                       fi <- file.info(pathname)
[18:04:21.430]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:21.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.430]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:21.430]                         fi[["size"]], fi[["mtime"]])
[18:04:21.430]                       stop(msg)
[18:04:21.430]                     }
[18:04:21.430]                     invisible(pathname)
[18:04:21.430]                   }
[18:04:21.430]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:21.430]                     rootPath = tempdir()) 
[18:04:21.430]                   {
[18:04:21.430]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:21.430]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:21.430]                       tmpdir = path, fileext = ".rds")
[18:04:21.430]                     save_rds(obj, file)
[18:04:21.430]                   }
[18:04:21.430]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:21.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.430]                   {
[18:04:21.430]                     inherits <- base::inherits
[18:04:21.430]                     invokeRestart <- base::invokeRestart
[18:04:21.430]                     is.null <- base::is.null
[18:04:21.430]                     muffled <- FALSE
[18:04:21.430]                     if (inherits(cond, "message")) {
[18:04:21.430]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.430]                       if (muffled) 
[18:04:21.430]                         invokeRestart("muffleMessage")
[18:04:21.430]                     }
[18:04:21.430]                     else if (inherits(cond, "warning")) {
[18:04:21.430]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.430]                       if (muffled) 
[18:04:21.430]                         invokeRestart("muffleWarning")
[18:04:21.430]                     }
[18:04:21.430]                     else if (inherits(cond, "condition")) {
[18:04:21.430]                       if (!is.null(pattern)) {
[18:04:21.430]                         computeRestarts <- base::computeRestarts
[18:04:21.430]                         grepl <- base::grepl
[18:04:21.430]                         restarts <- computeRestarts(cond)
[18:04:21.430]                         for (restart in restarts) {
[18:04:21.430]                           name <- restart$name
[18:04:21.430]                           if (is.null(name)) 
[18:04:21.430]                             next
[18:04:21.430]                           if (!grepl(pattern, name)) 
[18:04:21.430]                             next
[18:04:21.430]                           invokeRestart(restart)
[18:04:21.430]                           muffled <- TRUE
[18:04:21.430]                           break
[18:04:21.430]                         }
[18:04:21.430]                       }
[18:04:21.430]                     }
[18:04:21.430]                     invisible(muffled)
[18:04:21.430]                   }
[18:04:21.430]                   muffleCondition(cond)
[18:04:21.430]                 })
[18:04:21.430]             }))
[18:04:21.430]             future::FutureResult(value = ...future.value$value, 
[18:04:21.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.430]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.430]                     ...future.globalenv.names))
[18:04:21.430]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.430]         }, condition = base::local({
[18:04:21.430]             c <- base::c
[18:04:21.430]             inherits <- base::inherits
[18:04:21.430]             invokeRestart <- base::invokeRestart
[18:04:21.430]             length <- base::length
[18:04:21.430]             list <- base::list
[18:04:21.430]             seq.int <- base::seq.int
[18:04:21.430]             signalCondition <- base::signalCondition
[18:04:21.430]             sys.calls <- base::sys.calls
[18:04:21.430]             `[[` <- base::`[[`
[18:04:21.430]             `+` <- base::`+`
[18:04:21.430]             `<<-` <- base::`<<-`
[18:04:21.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.430]                   3L)]
[18:04:21.430]             }
[18:04:21.430]             function(cond) {
[18:04:21.430]                 is_error <- inherits(cond, "error")
[18:04:21.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.430]                   NULL)
[18:04:21.430]                 if (is_error) {
[18:04:21.430]                   sessionInformation <- function() {
[18:04:21.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.430]                       search = base::search(), system = base::Sys.info())
[18:04:21.430]                   }
[18:04:21.430]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.430]                     cond$call), session = sessionInformation(), 
[18:04:21.430]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.430]                   signalCondition(cond)
[18:04:21.430]                 }
[18:04:21.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.430]                 "immediateCondition"))) {
[18:04:21.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.430]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.430]                   if (TRUE && !signal) {
[18:04:21.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.430]                     {
[18:04:21.430]                       inherits <- base::inherits
[18:04:21.430]                       invokeRestart <- base::invokeRestart
[18:04:21.430]                       is.null <- base::is.null
[18:04:21.430]                       muffled <- FALSE
[18:04:21.430]                       if (inherits(cond, "message")) {
[18:04:21.430]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.430]                         if (muffled) 
[18:04:21.430]                           invokeRestart("muffleMessage")
[18:04:21.430]                       }
[18:04:21.430]                       else if (inherits(cond, "warning")) {
[18:04:21.430]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.430]                         if (muffled) 
[18:04:21.430]                           invokeRestart("muffleWarning")
[18:04:21.430]                       }
[18:04:21.430]                       else if (inherits(cond, "condition")) {
[18:04:21.430]                         if (!is.null(pattern)) {
[18:04:21.430]                           computeRestarts <- base::computeRestarts
[18:04:21.430]                           grepl <- base::grepl
[18:04:21.430]                           restarts <- computeRestarts(cond)
[18:04:21.430]                           for (restart in restarts) {
[18:04:21.430]                             name <- restart$name
[18:04:21.430]                             if (is.null(name)) 
[18:04:21.430]                               next
[18:04:21.430]                             if (!grepl(pattern, name)) 
[18:04:21.430]                               next
[18:04:21.430]                             invokeRestart(restart)
[18:04:21.430]                             muffled <- TRUE
[18:04:21.430]                             break
[18:04:21.430]                           }
[18:04:21.430]                         }
[18:04:21.430]                       }
[18:04:21.430]                       invisible(muffled)
[18:04:21.430]                     }
[18:04:21.430]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.430]                   }
[18:04:21.430]                 }
[18:04:21.430]                 else {
[18:04:21.430]                   if (TRUE) {
[18:04:21.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.430]                     {
[18:04:21.430]                       inherits <- base::inherits
[18:04:21.430]                       invokeRestart <- base::invokeRestart
[18:04:21.430]                       is.null <- base::is.null
[18:04:21.430]                       muffled <- FALSE
[18:04:21.430]                       if (inherits(cond, "message")) {
[18:04:21.430]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.430]                         if (muffled) 
[18:04:21.430]                           invokeRestart("muffleMessage")
[18:04:21.430]                       }
[18:04:21.430]                       else if (inherits(cond, "warning")) {
[18:04:21.430]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.430]                         if (muffled) 
[18:04:21.430]                           invokeRestart("muffleWarning")
[18:04:21.430]                       }
[18:04:21.430]                       else if (inherits(cond, "condition")) {
[18:04:21.430]                         if (!is.null(pattern)) {
[18:04:21.430]                           computeRestarts <- base::computeRestarts
[18:04:21.430]                           grepl <- base::grepl
[18:04:21.430]                           restarts <- computeRestarts(cond)
[18:04:21.430]                           for (restart in restarts) {
[18:04:21.430]                             name <- restart$name
[18:04:21.430]                             if (is.null(name)) 
[18:04:21.430]                               next
[18:04:21.430]                             if (!grepl(pattern, name)) 
[18:04:21.430]                               next
[18:04:21.430]                             invokeRestart(restart)
[18:04:21.430]                             muffled <- TRUE
[18:04:21.430]                             break
[18:04:21.430]                           }
[18:04:21.430]                         }
[18:04:21.430]                       }
[18:04:21.430]                       invisible(muffled)
[18:04:21.430]                     }
[18:04:21.430]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.430]                   }
[18:04:21.430]                 }
[18:04:21.430]             }
[18:04:21.430]         }))
[18:04:21.430]     }, error = function(ex) {
[18:04:21.430]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.430]                 ...future.rng), started = ...future.startTime, 
[18:04:21.430]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.430]             version = "1.8"), class = "FutureResult")
[18:04:21.430]     }, finally = {
[18:04:21.430]         if (!identical(...future.workdir, getwd())) 
[18:04:21.430]             setwd(...future.workdir)
[18:04:21.430]         {
[18:04:21.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.430]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.430]             }
[18:04:21.430]             base::options(...future.oldOptions)
[18:04:21.430]             if (.Platform$OS.type == "windows") {
[18:04:21.430]                 old_names <- names(...future.oldEnvVars)
[18:04:21.430]                 envs <- base::Sys.getenv()
[18:04:21.430]                 names <- names(envs)
[18:04:21.430]                 common <- intersect(names, old_names)
[18:04:21.430]                 added <- setdiff(names, old_names)
[18:04:21.430]                 removed <- setdiff(old_names, names)
[18:04:21.430]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.430]                   envs[common]]
[18:04:21.430]                 NAMES <- toupper(changed)
[18:04:21.430]                 args <- list()
[18:04:21.430]                 for (kk in seq_along(NAMES)) {
[18:04:21.430]                   name <- changed[[kk]]
[18:04:21.430]                   NAME <- NAMES[[kk]]
[18:04:21.430]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.430]                     next
[18:04:21.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.430]                 }
[18:04:21.430]                 NAMES <- toupper(added)
[18:04:21.430]                 for (kk in seq_along(NAMES)) {
[18:04:21.430]                   name <- added[[kk]]
[18:04:21.430]                   NAME <- NAMES[[kk]]
[18:04:21.430]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.430]                     next
[18:04:21.430]                   args[[name]] <- ""
[18:04:21.430]                 }
[18:04:21.430]                 NAMES <- toupper(removed)
[18:04:21.430]                 for (kk in seq_along(NAMES)) {
[18:04:21.430]                   name <- removed[[kk]]
[18:04:21.430]                   NAME <- NAMES[[kk]]
[18:04:21.430]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.430]                     next
[18:04:21.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.430]                 }
[18:04:21.430]                 if (length(args) > 0) 
[18:04:21.430]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.430]             }
[18:04:21.430]             else {
[18:04:21.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.430]             }
[18:04:21.430]             {
[18:04:21.430]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.430]                   0L) {
[18:04:21.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.430]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.430]                   base::options(opts)
[18:04:21.430]                 }
[18:04:21.430]                 {
[18:04:21.430]                   {
[18:04:21.430]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.430]                     NULL
[18:04:21.430]                   }
[18:04:21.430]                   options(future.plan = NULL)
[18:04:21.430]                   if (is.na(NA_character_)) 
[18:04:21.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.430]                     .init = FALSE)
[18:04:21.430]                 }
[18:04:21.430]             }
[18:04:21.430]         }
[18:04:21.430]     })
[18:04:21.430]     if (TRUE) {
[18:04:21.430]         base::sink(type = "output", split = FALSE)
[18:04:21.430]         if (TRUE) {
[18:04:21.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.430]         }
[18:04:21.430]         else {
[18:04:21.430]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.430]         }
[18:04:21.430]         base::close(...future.stdout)
[18:04:21.430]         ...future.stdout <- NULL
[18:04:21.430]     }
[18:04:21.430]     ...future.result$conditions <- ...future.conditions
[18:04:21.430]     ...future.result$finished <- base::Sys.time()
[18:04:21.430]     ...future.result
[18:04:21.430] }
[18:04:21.437] requestCore(): workers = 2
[18:04:21.438] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:21.449] result() for MulticoreFuture ...
[18:04:21.451] result() for MulticoreFuture ...
[18:04:21.451] result() for MulticoreFuture ... done
[18:04:21.451] result() for MulticoreFuture ... done
[18:04:21.452] result() for MulticoreFuture ...
[18:04:21.452] result() for MulticoreFuture ... done
[18:04:21.457] MulticoreFuture started
[18:04:21.457] - Launch lazy future ... done
[18:04:21.458] run() for ‘MulticoreFuture’ ... done
[18:04:21.459] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5e3c2c6cc320> 
[18:04:21.459] List of future strategies:
[18:04:21.459] 1. sequential:
[18:04:21.459]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:21.459]    - tweaked: FALSE
[18:04:21.459]    - call: NULL
[18:04:21.461] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5e3c2d25e338> 
[18:04:21.465] plan(): Setting new future strategy stack:
[18:04:21.465] List of future strategies:
[18:04:21.465] 1. multicore:
[18:04:21.465]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:21.465]    - tweaked: FALSE
[18:04:21.465]    - call: plan(strategy)
[18:04:21.477] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:21.483] resolve() on list environment ...
[18:04:21.484]  recursive: 0
[18:04:21.502]  length: 6
[18:04:21.503]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:21.504] signalConditionsASAP(numeric, pos=1) ...
[18:04:21.504] - nx: 6
[18:04:21.504] - relay: TRUE
[18:04:21.505] - stdout: TRUE
[18:04:21.505] - signal: TRUE
[18:04:21.505] - resignal: FALSE
[18:04:21.506] - force: TRUE
[18:04:21.506] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.506] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.507]  - until=2
[18:04:21.507]  - relaying element #2
[18:04:21.507] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.508] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.508] signalConditionsASAP(NULL, pos=1) ... done
[18:04:21.508]  length: 5 (resolved future 1)
[18:04:21.509] Future #2
[18:04:21.509] result() for MulticoreFuture ...
[18:04:21.509] result() for MulticoreFuture ... done
[18:04:21.510] result() for MulticoreFuture ...
[18:04:21.510] result() for MulticoreFuture ... done
[18:04:21.510] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:21.511] - nx: 6
[18:04:21.511] - relay: TRUE
[18:04:21.511] - stdout: TRUE
[18:04:21.512] - signal: TRUE
[18:04:21.512] - resignal: FALSE
[18:04:21.512] - force: TRUE
[18:04:21.512] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.513] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.513]  - until=2
[18:04:21.513]  - relaying element #2
[18:04:21.514] result() for MulticoreFuture ...
[18:04:21.514] result() for MulticoreFuture ... done
[18:04:21.514] result() for MulticoreFuture ...
[18:04:21.514] result() for MulticoreFuture ... done
[18:04:21.515] result() for MulticoreFuture ...
[18:04:21.515] result() for MulticoreFuture ... done
[18:04:21.515] result() for MulticoreFuture ...
[18:04:21.516] result() for MulticoreFuture ... done
[18:04:21.516] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:21.516] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:21.517] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:21.517]  length: 4 (resolved future 2)
[18:04:21.518] Future #3
[18:04:21.518] result() for MulticoreFuture ...
[18:04:21.520] result() for MulticoreFuture ...
[18:04:21.521] result() for MulticoreFuture ... done
[18:04:21.521] result() for MulticoreFuture ... done
[18:04:21.521] result() for MulticoreFuture ...
[18:04:21.522] result() for MulticoreFuture ... done
[18:04:21.522] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:21.522] - nx: 6
[18:04:21.522] - relay: TRUE
[18:04:21.523] - stdout: TRUE
[18:04:21.523] - signal: TRUE
[18:04:21.523] - resignal: FALSE
[18:04:21.523] - force: TRUE
[18:04:21.524] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:21.524] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:21.524]  - until=3
[18:04:21.525]  - relaying element #3
[18:04:21.525] result() for MulticoreFuture ...
[18:04:21.525] result() for MulticoreFuture ... done
[18:04:21.526] result() for MulticoreFuture ...
[18:04:21.526] result() for MulticoreFuture ... done
[18:04:21.526] result() for MulticoreFuture ...
[18:04:21.526] result() for MulticoreFuture ... done
[18:04:21.527] result() for MulticoreFuture ...
[18:04:21.527] result() for MulticoreFuture ... done
[18:04:21.527] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:21.527] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:21.528] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:21.528]  length: 3 (resolved future 3)
[18:04:21.529] Future #4
[18:04:21.529] result() for MulticoreFuture ...
[18:04:21.530] result() for MulticoreFuture ...
[18:04:21.531] result() for MulticoreFuture ... done
[18:04:21.531] result() for MulticoreFuture ... done
[18:04:21.531] result() for MulticoreFuture ...
[18:04:21.531] result() for MulticoreFuture ... done
[18:04:21.532] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:21.532] - nx: 6
[18:04:21.532] - relay: TRUE
[18:04:21.533] - stdout: TRUE
[18:04:21.533] - signal: TRUE
[18:04:21.533] - resignal: FALSE
[18:04:21.534] - force: TRUE
[18:04:21.534] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:21.534] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:21.534]  - until=4
[18:04:21.534]  - relaying element #4
[18:04:21.535] result() for MulticoreFuture ...
[18:04:21.535] result() for MulticoreFuture ... done
[18:04:21.535] result() for MulticoreFuture ...
[18:04:21.535] result() for MulticoreFuture ... done
[18:04:21.536] result() for MulticoreFuture ...
[18:04:21.536] result() for MulticoreFuture ... done
[18:04:21.536] result() for MulticoreFuture ...
[18:04:21.536] result() for MulticoreFuture ... done
[18:04:21.537] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.537] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.537] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:21.537]  length: 2 (resolved future 4)
[18:04:21.538] signalConditionsASAP(NULL, pos=5) ...
[18:04:21.538] - nx: 6
[18:04:21.538] - relay: TRUE
[18:04:21.538] - stdout: TRUE
[18:04:21.538] - signal: TRUE
[18:04:21.538] - resignal: FALSE
[18:04:21.539] - force: TRUE
[18:04:21.539] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.539] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.539]  - until=6
[18:04:21.539]  - relaying element #6
[18:04:21.540] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:21.540] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.540] signalConditionsASAP(NULL, pos=5) ... done
[18:04:21.540]  length: 1 (resolved future 5)
[18:04:21.541] signalConditionsASAP(numeric, pos=6) ...
[18:04:21.541] - nx: 6
[18:04:21.541] - relay: TRUE
[18:04:21.541] - stdout: TRUE
[18:04:21.541] - signal: TRUE
[18:04:21.542] - resignal: FALSE
[18:04:21.542] - force: TRUE
[18:04:21.542] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:21.542] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.542]  - until=6
[18:04:21.543] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:21.543] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.543] signalConditionsASAP(numeric, pos=6) ... done
[18:04:21.543]  length: 0 (resolved future 6)
[18:04:21.543] Relaying remaining futures
[18:04:21.544] signalConditionsASAP(NULL, pos=0) ...
[18:04:21.544] - nx: 6
[18:04:21.544] - relay: TRUE
[18:04:21.544] - stdout: TRUE
[18:04:21.544] - signal: TRUE
[18:04:21.545] - resignal: FALSE
[18:04:21.545] - force: TRUE
[18:04:21.545] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:21.545] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:21.545] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:21.546] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.546] signalConditionsASAP(NULL, pos=0) ... done
[18:04:21.546] resolve() on list environment ... DONE
[18:04:21.546] result() for MulticoreFuture ...
[18:04:21.547] result() for MulticoreFuture ... done
[18:04:21.547] result() for MulticoreFuture ...
[18:04:21.547] result() for MulticoreFuture ... done
[18:04:21.547] result() for MulticoreFuture ...
[18:04:21.548] result() for MulticoreFuture ... done
[18:04:21.548] result() for MulticoreFuture ...
[18:04:21.548] result() for MulticoreFuture ... done
[18:04:21.548] result() for MulticoreFuture ...
[18:04:21.549] result() for MulticoreFuture ... done
[18:04:21.549] result() for MulticoreFuture ...
[18:04:21.549] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2d3aea88> 
Dimensions: c(1, 6)
[18:04:21.550] getGlobalsAndPackages() ...
[18:04:21.551] Searching for globals...
[18:04:21.551] 
[18:04:21.552] Searching for globals ... DONE
[18:04:21.552] - globals: [0] <none>
[18:04:21.552] getGlobalsAndPackages() ... DONE
[18:04:21.553] run() for ‘Future’ ...
[18:04:21.553] - state: ‘created’
[18:04:21.553] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.560] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:21.561]   - Field: ‘label’
[18:04:21.561]   - Field: ‘local’
[18:04:21.561]   - Field: ‘owner’
[18:04:21.562]   - Field: ‘envir’
[18:04:21.562]   - Field: ‘workers’
[18:04:21.562]   - Field: ‘packages’
[18:04:21.562]   - Field: ‘gc’
[18:04:21.563]   - Field: ‘job’
[18:04:21.563]   - Field: ‘conditions’
[18:04:21.563]   - Field: ‘expr’
[18:04:21.563]   - Field: ‘uuid’
[18:04:21.564]   - Field: ‘seed’
[18:04:21.564]   - Field: ‘version’
[18:04:21.564]   - Field: ‘result’
[18:04:21.564]   - Field: ‘asynchronous’
[18:04:21.565]   - Field: ‘calls’
[18:04:21.565]   - Field: ‘globals’
[18:04:21.565]   - Field: ‘stdout’
[18:04:21.565]   - Field: ‘earlySignal’
[18:04:21.566]   - Field: ‘lazy’
[18:04:21.566]   - Field: ‘state’
[18:04:21.566] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:21.566] - Launch lazy future ...
[18:04:21.567] Packages needed by the future expression (n = 0): <none>
[18:04:21.567] Packages needed by future strategies (n = 0): <none>
[18:04:21.569] {
[18:04:21.569]     {
[18:04:21.569]         {
[18:04:21.569]             ...future.startTime <- base::Sys.time()
[18:04:21.569]             {
[18:04:21.569]                 {
[18:04:21.569]                   {
[18:04:21.569]                     {
[18:04:21.569]                       base::local({
[18:04:21.569]                         has_future <- base::requireNamespace("future", 
[18:04:21.569]                           quietly = TRUE)
[18:04:21.569]                         if (has_future) {
[18:04:21.569]                           ns <- base::getNamespace("future")
[18:04:21.569]                           version <- ns[[".package"]][["version"]]
[18:04:21.569]                           if (is.null(version)) 
[18:04:21.569]                             version <- utils::packageVersion("future")
[18:04:21.569]                         }
[18:04:21.569]                         else {
[18:04:21.569]                           version <- NULL
[18:04:21.569]                         }
[18:04:21.569]                         if (!has_future || version < "1.8.0") {
[18:04:21.569]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.569]                             "", base::R.version$version.string), 
[18:04:21.569]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.569]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.569]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.569]                               "release", "version")], collapse = " "), 
[18:04:21.569]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.569]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.569]                             info)
[18:04:21.569]                           info <- base::paste(info, collapse = "; ")
[18:04:21.569]                           if (!has_future) {
[18:04:21.569]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.569]                               info)
[18:04:21.569]                           }
[18:04:21.569]                           else {
[18:04:21.569]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.569]                               info, version)
[18:04:21.569]                           }
[18:04:21.569]                           base::stop(msg)
[18:04:21.569]                         }
[18:04:21.569]                       })
[18:04:21.569]                     }
[18:04:21.569]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.569]                     base::options(mc.cores = 1L)
[18:04:21.569]                   }
[18:04:21.569]                   ...future.strategy.old <- future::plan("list")
[18:04:21.569]                   options(future.plan = NULL)
[18:04:21.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.569]                 }
[18:04:21.569]                 ...future.workdir <- getwd()
[18:04:21.569]             }
[18:04:21.569]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.569]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.569]         }
[18:04:21.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.569]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.569]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.569]             base::names(...future.oldOptions))
[18:04:21.569]     }
[18:04:21.569]     if (FALSE) {
[18:04:21.569]     }
[18:04:21.569]     else {
[18:04:21.569]         if (TRUE) {
[18:04:21.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.569]                 open = "w")
[18:04:21.569]         }
[18:04:21.569]         else {
[18:04:21.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.569]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.569]         }
[18:04:21.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.569]             base::sink(type = "output", split = FALSE)
[18:04:21.569]             base::close(...future.stdout)
[18:04:21.569]         }, add = TRUE)
[18:04:21.569]     }
[18:04:21.569]     ...future.frame <- base::sys.nframe()
[18:04:21.569]     ...future.conditions <- base::list()
[18:04:21.569]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.569]     if (FALSE) {
[18:04:21.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.569]     }
[18:04:21.569]     ...future.result <- base::tryCatch({
[18:04:21.569]         base::withCallingHandlers({
[18:04:21.569]             ...future.value <- base::withVisible(base::local({
[18:04:21.569]                 withCallingHandlers({
[18:04:21.569]                   2
[18:04:21.569]                 }, immediateCondition = function(cond) {
[18:04:21.569]                   save_rds <- function (object, pathname, ...) 
[18:04:21.569]                   {
[18:04:21.569]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:21.569]                     if (file_test("-f", pathname_tmp)) {
[18:04:21.569]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.569]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:21.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.569]                         fi_tmp[["mtime"]])
[18:04:21.569]                     }
[18:04:21.569]                     tryCatch({
[18:04:21.569]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:21.569]                     }, error = function(ex) {
[18:04:21.569]                       msg <- conditionMessage(ex)
[18:04:21.569]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.569]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:21.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.569]                         fi_tmp[["mtime"]], msg)
[18:04:21.569]                       ex$message <- msg
[18:04:21.569]                       stop(ex)
[18:04:21.569]                     })
[18:04:21.569]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:21.569]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:21.569]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:21.569]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.569]                       fi <- file.info(pathname)
[18:04:21.569]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:21.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.569]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:21.569]                         fi[["size"]], fi[["mtime"]])
[18:04:21.569]                       stop(msg)
[18:04:21.569]                     }
[18:04:21.569]                     invisible(pathname)
[18:04:21.569]                   }
[18:04:21.569]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:21.569]                     rootPath = tempdir()) 
[18:04:21.569]                   {
[18:04:21.569]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:21.569]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:21.569]                       tmpdir = path, fileext = ".rds")
[18:04:21.569]                     save_rds(obj, file)
[18:04:21.569]                   }
[18:04:21.569]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:21.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.569]                   {
[18:04:21.569]                     inherits <- base::inherits
[18:04:21.569]                     invokeRestart <- base::invokeRestart
[18:04:21.569]                     is.null <- base::is.null
[18:04:21.569]                     muffled <- FALSE
[18:04:21.569]                     if (inherits(cond, "message")) {
[18:04:21.569]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.569]                       if (muffled) 
[18:04:21.569]                         invokeRestart("muffleMessage")
[18:04:21.569]                     }
[18:04:21.569]                     else if (inherits(cond, "warning")) {
[18:04:21.569]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.569]                       if (muffled) 
[18:04:21.569]                         invokeRestart("muffleWarning")
[18:04:21.569]                     }
[18:04:21.569]                     else if (inherits(cond, "condition")) {
[18:04:21.569]                       if (!is.null(pattern)) {
[18:04:21.569]                         computeRestarts <- base::computeRestarts
[18:04:21.569]                         grepl <- base::grepl
[18:04:21.569]                         restarts <- computeRestarts(cond)
[18:04:21.569]                         for (restart in restarts) {
[18:04:21.569]                           name <- restart$name
[18:04:21.569]                           if (is.null(name)) 
[18:04:21.569]                             next
[18:04:21.569]                           if (!grepl(pattern, name)) 
[18:04:21.569]                             next
[18:04:21.569]                           invokeRestart(restart)
[18:04:21.569]                           muffled <- TRUE
[18:04:21.569]                           break
[18:04:21.569]                         }
[18:04:21.569]                       }
[18:04:21.569]                     }
[18:04:21.569]                     invisible(muffled)
[18:04:21.569]                   }
[18:04:21.569]                   muffleCondition(cond)
[18:04:21.569]                 })
[18:04:21.569]             }))
[18:04:21.569]             future::FutureResult(value = ...future.value$value, 
[18:04:21.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.569]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.569]                     ...future.globalenv.names))
[18:04:21.569]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.569]         }, condition = base::local({
[18:04:21.569]             c <- base::c
[18:04:21.569]             inherits <- base::inherits
[18:04:21.569]             invokeRestart <- base::invokeRestart
[18:04:21.569]             length <- base::length
[18:04:21.569]             list <- base::list
[18:04:21.569]             seq.int <- base::seq.int
[18:04:21.569]             signalCondition <- base::signalCondition
[18:04:21.569]             sys.calls <- base::sys.calls
[18:04:21.569]             `[[` <- base::`[[`
[18:04:21.569]             `+` <- base::`+`
[18:04:21.569]             `<<-` <- base::`<<-`
[18:04:21.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.569]                   3L)]
[18:04:21.569]             }
[18:04:21.569]             function(cond) {
[18:04:21.569]                 is_error <- inherits(cond, "error")
[18:04:21.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.569]                   NULL)
[18:04:21.569]                 if (is_error) {
[18:04:21.569]                   sessionInformation <- function() {
[18:04:21.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.569]                       search = base::search(), system = base::Sys.info())
[18:04:21.569]                   }
[18:04:21.569]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.569]                     cond$call), session = sessionInformation(), 
[18:04:21.569]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.569]                   signalCondition(cond)
[18:04:21.569]                 }
[18:04:21.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.569]                 "immediateCondition"))) {
[18:04:21.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.569]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.569]                   if (TRUE && !signal) {
[18:04:21.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.569]                     {
[18:04:21.569]                       inherits <- base::inherits
[18:04:21.569]                       invokeRestart <- base::invokeRestart
[18:04:21.569]                       is.null <- base::is.null
[18:04:21.569]                       muffled <- FALSE
[18:04:21.569]                       if (inherits(cond, "message")) {
[18:04:21.569]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.569]                         if (muffled) 
[18:04:21.569]                           invokeRestart("muffleMessage")
[18:04:21.569]                       }
[18:04:21.569]                       else if (inherits(cond, "warning")) {
[18:04:21.569]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.569]                         if (muffled) 
[18:04:21.569]                           invokeRestart("muffleWarning")
[18:04:21.569]                       }
[18:04:21.569]                       else if (inherits(cond, "condition")) {
[18:04:21.569]                         if (!is.null(pattern)) {
[18:04:21.569]                           computeRestarts <- base::computeRestarts
[18:04:21.569]                           grepl <- base::grepl
[18:04:21.569]                           restarts <- computeRestarts(cond)
[18:04:21.569]                           for (restart in restarts) {
[18:04:21.569]                             name <- restart$name
[18:04:21.569]                             if (is.null(name)) 
[18:04:21.569]                               next
[18:04:21.569]                             if (!grepl(pattern, name)) 
[18:04:21.569]                               next
[18:04:21.569]                             invokeRestart(restart)
[18:04:21.569]                             muffled <- TRUE
[18:04:21.569]                             break
[18:04:21.569]                           }
[18:04:21.569]                         }
[18:04:21.569]                       }
[18:04:21.569]                       invisible(muffled)
[18:04:21.569]                     }
[18:04:21.569]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.569]                   }
[18:04:21.569]                 }
[18:04:21.569]                 else {
[18:04:21.569]                   if (TRUE) {
[18:04:21.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.569]                     {
[18:04:21.569]                       inherits <- base::inherits
[18:04:21.569]                       invokeRestart <- base::invokeRestart
[18:04:21.569]                       is.null <- base::is.null
[18:04:21.569]                       muffled <- FALSE
[18:04:21.569]                       if (inherits(cond, "message")) {
[18:04:21.569]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.569]                         if (muffled) 
[18:04:21.569]                           invokeRestart("muffleMessage")
[18:04:21.569]                       }
[18:04:21.569]                       else if (inherits(cond, "warning")) {
[18:04:21.569]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.569]                         if (muffled) 
[18:04:21.569]                           invokeRestart("muffleWarning")
[18:04:21.569]                       }
[18:04:21.569]                       else if (inherits(cond, "condition")) {
[18:04:21.569]                         if (!is.null(pattern)) {
[18:04:21.569]                           computeRestarts <- base::computeRestarts
[18:04:21.569]                           grepl <- base::grepl
[18:04:21.569]                           restarts <- computeRestarts(cond)
[18:04:21.569]                           for (restart in restarts) {
[18:04:21.569]                             name <- restart$name
[18:04:21.569]                             if (is.null(name)) 
[18:04:21.569]                               next
[18:04:21.569]                             if (!grepl(pattern, name)) 
[18:04:21.569]                               next
[18:04:21.569]                             invokeRestart(restart)
[18:04:21.569]                             muffled <- TRUE
[18:04:21.569]                             break
[18:04:21.569]                           }
[18:04:21.569]                         }
[18:04:21.569]                       }
[18:04:21.569]                       invisible(muffled)
[18:04:21.569]                     }
[18:04:21.569]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.569]                   }
[18:04:21.569]                 }
[18:04:21.569]             }
[18:04:21.569]         }))
[18:04:21.569]     }, error = function(ex) {
[18:04:21.569]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.569]                 ...future.rng), started = ...future.startTime, 
[18:04:21.569]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.569]             version = "1.8"), class = "FutureResult")
[18:04:21.569]     }, finally = {
[18:04:21.569]         if (!identical(...future.workdir, getwd())) 
[18:04:21.569]             setwd(...future.workdir)
[18:04:21.569]         {
[18:04:21.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.569]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.569]             }
[18:04:21.569]             base::options(...future.oldOptions)
[18:04:21.569]             if (.Platform$OS.type == "windows") {
[18:04:21.569]                 old_names <- names(...future.oldEnvVars)
[18:04:21.569]                 envs <- base::Sys.getenv()
[18:04:21.569]                 names <- names(envs)
[18:04:21.569]                 common <- intersect(names, old_names)
[18:04:21.569]                 added <- setdiff(names, old_names)
[18:04:21.569]                 removed <- setdiff(old_names, names)
[18:04:21.569]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.569]                   envs[common]]
[18:04:21.569]                 NAMES <- toupper(changed)
[18:04:21.569]                 args <- list()
[18:04:21.569]                 for (kk in seq_along(NAMES)) {
[18:04:21.569]                   name <- changed[[kk]]
[18:04:21.569]                   NAME <- NAMES[[kk]]
[18:04:21.569]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.569]                     next
[18:04:21.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.569]                 }
[18:04:21.569]                 NAMES <- toupper(added)
[18:04:21.569]                 for (kk in seq_along(NAMES)) {
[18:04:21.569]                   name <- added[[kk]]
[18:04:21.569]                   NAME <- NAMES[[kk]]
[18:04:21.569]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.569]                     next
[18:04:21.569]                   args[[name]] <- ""
[18:04:21.569]                 }
[18:04:21.569]                 NAMES <- toupper(removed)
[18:04:21.569]                 for (kk in seq_along(NAMES)) {
[18:04:21.569]                   name <- removed[[kk]]
[18:04:21.569]                   NAME <- NAMES[[kk]]
[18:04:21.569]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.569]                     next
[18:04:21.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.569]                 }
[18:04:21.569]                 if (length(args) > 0) 
[18:04:21.569]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.569]             }
[18:04:21.569]             else {
[18:04:21.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.569]             }
[18:04:21.569]             {
[18:04:21.569]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.569]                   0L) {
[18:04:21.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.569]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.569]                   base::options(opts)
[18:04:21.569]                 }
[18:04:21.569]                 {
[18:04:21.569]                   {
[18:04:21.569]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.569]                     NULL
[18:04:21.569]                   }
[18:04:21.569]                   options(future.plan = NULL)
[18:04:21.569]                   if (is.na(NA_character_)) 
[18:04:21.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.569]                     .init = FALSE)
[18:04:21.569]                 }
[18:04:21.569]             }
[18:04:21.569]         }
[18:04:21.569]     })
[18:04:21.569]     if (TRUE) {
[18:04:21.569]         base::sink(type = "output", split = FALSE)
[18:04:21.569]         if (TRUE) {
[18:04:21.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.569]         }
[18:04:21.569]         else {
[18:04:21.569]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.569]         }
[18:04:21.569]         base::close(...future.stdout)
[18:04:21.569]         ...future.stdout <- NULL
[18:04:21.569]     }
[18:04:21.569]     ...future.result$conditions <- ...future.conditions
[18:04:21.569]     ...future.result$finished <- base::Sys.time()
[18:04:21.569]     ...future.result
[18:04:21.569] }
[18:04:21.573] requestCore(): workers = 2
[18:04:21.578] MulticoreFuture started
[18:04:21.579] - Launch lazy future ... done
[18:04:21.581] run() for ‘MulticoreFuture’ ... done
[18:04:21.581] plan(): Setting new future strategy stack:
[18:04:21.582] getGlobalsAndPackages() ...
[18:04:21.583] Searching for globals...
[18:04:21.582] List of future strategies:
[18:04:21.582] 1. sequential:
[18:04:21.582]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:21.582]    - tweaked: FALSE
[18:04:21.582]    - call: NULL
[18:04:21.584] plan(): nbrOfWorkers() = 1
[18:04:21.584] 
[18:04:21.585] Searching for globals ... DONE
[18:04:21.585] - globals: [0] <none>
[18:04:21.586] getGlobalsAndPackages() ... DONE
[18:04:21.587] run() for ‘Future’ ...
[18:04:21.587] - state: ‘created’
[18:04:21.588] plan(): Setting new future strategy stack:
[18:04:21.588] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.588] List of future strategies:
[18:04:21.588] 1. multicore:
[18:04:21.588]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:21.588]    - tweaked: FALSE
[18:04:21.588]    - call: plan(strategy)
[18:04:21.596] plan(): nbrOfWorkers() = 2
[18:04:21.597] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:21.598]   - Field: ‘label’
[18:04:21.598]   - Field: ‘local’
[18:04:21.598]   - Field: ‘owner’
[18:04:21.599]   - Field: ‘envir’
[18:04:21.599]   - Field: ‘workers’
[18:04:21.599]   - Field: ‘packages’
[18:04:21.600]   - Field: ‘gc’
[18:04:21.600]   - Field: ‘job’
[18:04:21.600]   - Field: ‘conditions’
[18:04:21.601]   - Field: ‘expr’
[18:04:21.601]   - Field: ‘uuid’
[18:04:21.601]   - Field: ‘seed’
[18:04:21.602]   - Field: ‘version’
[18:04:21.602]   - Field: ‘result’
[18:04:21.602]   - Field: ‘asynchronous’
[18:04:21.603]   - Field: ‘calls’
[18:04:21.603]   - Field: ‘globals’
[18:04:21.603]   - Field: ‘stdout’
[18:04:21.604]   - Field: ‘earlySignal’
[18:04:21.604]   - Field: ‘lazy’
[18:04:21.604]   - Field: ‘state’
[18:04:21.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:21.605] - Launch lazy future ...
[18:04:21.606] Packages needed by the future expression (n = 0): <none>
[18:04:21.606] Packages needed by future strategies (n = 0): <none>
[18:04:21.608] {
[18:04:21.608]     {
[18:04:21.608]         {
[18:04:21.608]             ...future.startTime <- base::Sys.time()
[18:04:21.608]             {
[18:04:21.608]                 {
[18:04:21.608]                   {
[18:04:21.608]                     {
[18:04:21.608]                       base::local({
[18:04:21.608]                         has_future <- base::requireNamespace("future", 
[18:04:21.608]                           quietly = TRUE)
[18:04:21.608]                         if (has_future) {
[18:04:21.608]                           ns <- base::getNamespace("future")
[18:04:21.608]                           version <- ns[[".package"]][["version"]]
[18:04:21.608]                           if (is.null(version)) 
[18:04:21.608]                             version <- utils::packageVersion("future")
[18:04:21.608]                         }
[18:04:21.608]                         else {
[18:04:21.608]                           version <- NULL
[18:04:21.608]                         }
[18:04:21.608]                         if (!has_future || version < "1.8.0") {
[18:04:21.608]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.608]                             "", base::R.version$version.string), 
[18:04:21.608]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.608]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.608]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.608]                               "release", "version")], collapse = " "), 
[18:04:21.608]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.608]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.608]                             info)
[18:04:21.608]                           info <- base::paste(info, collapse = "; ")
[18:04:21.608]                           if (!has_future) {
[18:04:21.608]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.608]                               info)
[18:04:21.608]                           }
[18:04:21.608]                           else {
[18:04:21.608]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.608]                               info, version)
[18:04:21.608]                           }
[18:04:21.608]                           base::stop(msg)
[18:04:21.608]                         }
[18:04:21.608]                       })
[18:04:21.608]                     }
[18:04:21.608]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.608]                     base::options(mc.cores = 1L)
[18:04:21.608]                   }
[18:04:21.608]                   ...future.strategy.old <- future::plan("list")
[18:04:21.608]                   options(future.plan = NULL)
[18:04:21.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.608]                 }
[18:04:21.608]                 ...future.workdir <- getwd()
[18:04:21.608]             }
[18:04:21.608]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.608]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.608]         }
[18:04:21.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.608]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.608]             base::names(...future.oldOptions))
[18:04:21.608]     }
[18:04:21.608]     if (FALSE) {
[18:04:21.608]     }
[18:04:21.608]     else {
[18:04:21.608]         if (TRUE) {
[18:04:21.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.608]                 open = "w")
[18:04:21.608]         }
[18:04:21.608]         else {
[18:04:21.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.608]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.608]         }
[18:04:21.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.608]             base::sink(type = "output", split = FALSE)
[18:04:21.608]             base::close(...future.stdout)
[18:04:21.608]         }, add = TRUE)
[18:04:21.608]     }
[18:04:21.608]     ...future.frame <- base::sys.nframe()
[18:04:21.608]     ...future.conditions <- base::list()
[18:04:21.608]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.608]     if (FALSE) {
[18:04:21.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.608]     }
[18:04:21.608]     ...future.result <- base::tryCatch({
[18:04:21.608]         base::withCallingHandlers({
[18:04:21.608]             ...future.value <- base::withVisible(base::local({
[18:04:21.608]                 withCallingHandlers({
[18:04:21.608]                   NULL
[18:04:21.608]                 }, immediateCondition = function(cond) {
[18:04:21.608]                   save_rds <- function (object, pathname, ...) 
[18:04:21.608]                   {
[18:04:21.608]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:21.608]                     if (file_test("-f", pathname_tmp)) {
[18:04:21.608]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.608]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:21.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.608]                         fi_tmp[["mtime"]])
[18:04:21.608]                     }
[18:04:21.608]                     tryCatch({
[18:04:21.608]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:21.608]                     }, error = function(ex) {
[18:04:21.608]                       msg <- conditionMessage(ex)
[18:04:21.608]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.608]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:21.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.608]                         fi_tmp[["mtime"]], msg)
[18:04:21.608]                       ex$message <- msg
[18:04:21.608]                       stop(ex)
[18:04:21.608]                     })
[18:04:21.608]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:21.608]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:21.608]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:21.608]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.608]                       fi <- file.info(pathname)
[18:04:21.608]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:21.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.608]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:21.608]                         fi[["size"]], fi[["mtime"]])
[18:04:21.608]                       stop(msg)
[18:04:21.608]                     }
[18:04:21.608]                     invisible(pathname)
[18:04:21.608]                   }
[18:04:21.608]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:21.608]                     rootPath = tempdir()) 
[18:04:21.608]                   {
[18:04:21.608]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:21.608]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:21.608]                       tmpdir = path, fileext = ".rds")
[18:04:21.608]                     save_rds(obj, file)
[18:04:21.608]                   }
[18:04:21.608]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:21.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.608]                   {
[18:04:21.608]                     inherits <- base::inherits
[18:04:21.608]                     invokeRestart <- base::invokeRestart
[18:04:21.608]                     is.null <- base::is.null
[18:04:21.608]                     muffled <- FALSE
[18:04:21.608]                     if (inherits(cond, "message")) {
[18:04:21.608]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.608]                       if (muffled) 
[18:04:21.608]                         invokeRestart("muffleMessage")
[18:04:21.608]                     }
[18:04:21.608]                     else if (inherits(cond, "warning")) {
[18:04:21.608]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.608]                       if (muffled) 
[18:04:21.608]                         invokeRestart("muffleWarning")
[18:04:21.608]                     }
[18:04:21.608]                     else if (inherits(cond, "condition")) {
[18:04:21.608]                       if (!is.null(pattern)) {
[18:04:21.608]                         computeRestarts <- base::computeRestarts
[18:04:21.608]                         grepl <- base::grepl
[18:04:21.608]                         restarts <- computeRestarts(cond)
[18:04:21.608]                         for (restart in restarts) {
[18:04:21.608]                           name <- restart$name
[18:04:21.608]                           if (is.null(name)) 
[18:04:21.608]                             next
[18:04:21.608]                           if (!grepl(pattern, name)) 
[18:04:21.608]                             next
[18:04:21.608]                           invokeRestart(restart)
[18:04:21.608]                           muffled <- TRUE
[18:04:21.608]                           break
[18:04:21.608]                         }
[18:04:21.608]                       }
[18:04:21.608]                     }
[18:04:21.608]                     invisible(muffled)
[18:04:21.608]                   }
[18:04:21.608]                   muffleCondition(cond)
[18:04:21.608]                 })
[18:04:21.608]             }))
[18:04:21.608]             future::FutureResult(value = ...future.value$value, 
[18:04:21.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.608]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.608]                     ...future.globalenv.names))
[18:04:21.608]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.608]         }, condition = base::local({
[18:04:21.608]             c <- base::c
[18:04:21.608]             inherits <- base::inherits
[18:04:21.608]             invokeRestart <- base::invokeRestart
[18:04:21.608]             length <- base::length
[18:04:21.608]             list <- base::list
[18:04:21.608]             seq.int <- base::seq.int
[18:04:21.608]             signalCondition <- base::signalCondition
[18:04:21.608]             sys.calls <- base::sys.calls
[18:04:21.608]             `[[` <- base::`[[`
[18:04:21.608]             `+` <- base::`+`
[18:04:21.608]             `<<-` <- base::`<<-`
[18:04:21.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.608]                   3L)]
[18:04:21.608]             }
[18:04:21.608]             function(cond) {
[18:04:21.608]                 is_error <- inherits(cond, "error")
[18:04:21.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.608]                   NULL)
[18:04:21.608]                 if (is_error) {
[18:04:21.608]                   sessionInformation <- function() {
[18:04:21.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.608]                       search = base::search(), system = base::Sys.info())
[18:04:21.608]                   }
[18:04:21.608]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.608]                     cond$call), session = sessionInformation(), 
[18:04:21.608]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.608]                   signalCondition(cond)
[18:04:21.608]                 }
[18:04:21.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.608]                 "immediateCondition"))) {
[18:04:21.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.608]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.608]                   if (TRUE && !signal) {
[18:04:21.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.608]                     {
[18:04:21.608]                       inherits <- base::inherits
[18:04:21.608]                       invokeRestart <- base::invokeRestart
[18:04:21.608]                       is.null <- base::is.null
[18:04:21.608]                       muffled <- FALSE
[18:04:21.608]                       if (inherits(cond, "message")) {
[18:04:21.608]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.608]                         if (muffled) 
[18:04:21.608]                           invokeRestart("muffleMessage")
[18:04:21.608]                       }
[18:04:21.608]                       else if (inherits(cond, "warning")) {
[18:04:21.608]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.608]                         if (muffled) 
[18:04:21.608]                           invokeRestart("muffleWarning")
[18:04:21.608]                       }
[18:04:21.608]                       else if (inherits(cond, "condition")) {
[18:04:21.608]                         if (!is.null(pattern)) {
[18:04:21.608]                           computeRestarts <- base::computeRestarts
[18:04:21.608]                           grepl <- base::grepl
[18:04:21.608]                           restarts <- computeRestarts(cond)
[18:04:21.608]                           for (restart in restarts) {
[18:04:21.608]                             name <- restart$name
[18:04:21.608]                             if (is.null(name)) 
[18:04:21.608]                               next
[18:04:21.608]                             if (!grepl(pattern, name)) 
[18:04:21.608]                               next
[18:04:21.608]                             invokeRestart(restart)
[18:04:21.608]                             muffled <- TRUE
[18:04:21.608]                             break
[18:04:21.608]                           }
[18:04:21.608]                         }
[18:04:21.608]                       }
[18:04:21.608]                       invisible(muffled)
[18:04:21.608]                     }
[18:04:21.608]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.608]                   }
[18:04:21.608]                 }
[18:04:21.608]                 else {
[18:04:21.608]                   if (TRUE) {
[18:04:21.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.608]                     {
[18:04:21.608]                       inherits <- base::inherits
[18:04:21.608]                       invokeRestart <- base::invokeRestart
[18:04:21.608]                       is.null <- base::is.null
[18:04:21.608]                       muffled <- FALSE
[18:04:21.608]                       if (inherits(cond, "message")) {
[18:04:21.608]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.608]                         if (muffled) 
[18:04:21.608]                           invokeRestart("muffleMessage")
[18:04:21.608]                       }
[18:04:21.608]                       else if (inherits(cond, "warning")) {
[18:04:21.608]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.608]                         if (muffled) 
[18:04:21.608]                           invokeRestart("muffleWarning")
[18:04:21.608]                       }
[18:04:21.608]                       else if (inherits(cond, "condition")) {
[18:04:21.608]                         if (!is.null(pattern)) {
[18:04:21.608]                           computeRestarts <- base::computeRestarts
[18:04:21.608]                           grepl <- base::grepl
[18:04:21.608]                           restarts <- computeRestarts(cond)
[18:04:21.608]                           for (restart in restarts) {
[18:04:21.608]                             name <- restart$name
[18:04:21.608]                             if (is.null(name)) 
[18:04:21.608]                               next
[18:04:21.608]                             if (!grepl(pattern, name)) 
[18:04:21.608]                               next
[18:04:21.608]                             invokeRestart(restart)
[18:04:21.608]                             muffled <- TRUE
[18:04:21.608]                             break
[18:04:21.608]                           }
[18:04:21.608]                         }
[18:04:21.608]                       }
[18:04:21.608]                       invisible(muffled)
[18:04:21.608]                     }
[18:04:21.608]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.608]                   }
[18:04:21.608]                 }
[18:04:21.608]             }
[18:04:21.608]         }))
[18:04:21.608]     }, error = function(ex) {
[18:04:21.608]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.608]                 ...future.rng), started = ...future.startTime, 
[18:04:21.608]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.608]             version = "1.8"), class = "FutureResult")
[18:04:21.608]     }, finally = {
[18:04:21.608]         if (!identical(...future.workdir, getwd())) 
[18:04:21.608]             setwd(...future.workdir)
[18:04:21.608]         {
[18:04:21.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.608]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.608]             }
[18:04:21.608]             base::options(...future.oldOptions)
[18:04:21.608]             if (.Platform$OS.type == "windows") {
[18:04:21.608]                 old_names <- names(...future.oldEnvVars)
[18:04:21.608]                 envs <- base::Sys.getenv()
[18:04:21.608]                 names <- names(envs)
[18:04:21.608]                 common <- intersect(names, old_names)
[18:04:21.608]                 added <- setdiff(names, old_names)
[18:04:21.608]                 removed <- setdiff(old_names, names)
[18:04:21.608]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.608]                   envs[common]]
[18:04:21.608]                 NAMES <- toupper(changed)
[18:04:21.608]                 args <- list()
[18:04:21.608]                 for (kk in seq_along(NAMES)) {
[18:04:21.608]                   name <- changed[[kk]]
[18:04:21.608]                   NAME <- NAMES[[kk]]
[18:04:21.608]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.608]                     next
[18:04:21.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.608]                 }
[18:04:21.608]                 NAMES <- toupper(added)
[18:04:21.608]                 for (kk in seq_along(NAMES)) {
[18:04:21.608]                   name <- added[[kk]]
[18:04:21.608]                   NAME <- NAMES[[kk]]
[18:04:21.608]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.608]                     next
[18:04:21.608]                   args[[name]] <- ""
[18:04:21.608]                 }
[18:04:21.608]                 NAMES <- toupper(removed)
[18:04:21.608]                 for (kk in seq_along(NAMES)) {
[18:04:21.608]                   name <- removed[[kk]]
[18:04:21.608]                   NAME <- NAMES[[kk]]
[18:04:21.608]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.608]                     next
[18:04:21.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.608]                 }
[18:04:21.608]                 if (length(args) > 0) 
[18:04:21.608]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.608]             }
[18:04:21.608]             else {
[18:04:21.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.608]             }
[18:04:21.608]             {
[18:04:21.608]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.608]                   0L) {
[18:04:21.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.608]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.608]                   base::options(opts)
[18:04:21.608]                 }
[18:04:21.608]                 {
[18:04:21.608]                   {
[18:04:21.608]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.608]                     NULL
[18:04:21.608]                   }
[18:04:21.608]                   options(future.plan = NULL)
[18:04:21.608]                   if (is.na(NA_character_)) 
[18:04:21.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.608]                     .init = FALSE)
[18:04:21.608]                 }
[18:04:21.608]             }
[18:04:21.608]         }
[18:04:21.608]     })
[18:04:21.608]     if (TRUE) {
[18:04:21.608]         base::sink(type = "output", split = FALSE)
[18:04:21.608]         if (TRUE) {
[18:04:21.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.608]         }
[18:04:21.608]         else {
[18:04:21.608]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.608]         }
[18:04:21.608]         base::close(...future.stdout)
[18:04:21.608]         ...future.stdout <- NULL
[18:04:21.608]     }
[18:04:21.608]     ...future.result$conditions <- ...future.conditions
[18:04:21.608]     ...future.result$finished <- base::Sys.time()
[18:04:21.608]     ...future.result
[18:04:21.608] }
[18:04:21.615] requestCore(): workers = 2
[18:04:21.619] MulticoreFuture started
[18:04:21.620] - Launch lazy future ... done
[18:04:21.620] run() for ‘MulticoreFuture’ ... done
[18:04:21.621] plan(): Setting new future strategy stack:
[18:04:21.622] getGlobalsAndPackages() ...
[18:04:21.623] Searching for globals...
[18:04:21.622] List of future strategies:
[18:04:21.622] 1. sequential:
[18:04:21.622]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:21.622]    - tweaked: FALSE
[18:04:21.622]    - call: NULL
[18:04:21.624] plan(): nbrOfWorkers() = 1
[18:04:21.625] - globals found: [1] ‘{’
[18:04:21.626] Searching for globals ... DONE
[18:04:21.626] Resolving globals: FALSE
[18:04:21.627] 
[18:04:21.628] 
[18:04:21.628] getGlobalsAndPackages() ... DONE
[18:04:21.628] plan(): Setting new future strategy stack:
[18:04:21.629] run() for ‘Future’ ...
[18:04:21.628] List of future strategies:
[18:04:21.628] 1. multicore:
[18:04:21.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:21.628]    - tweaked: FALSE
[18:04:21.628]    - call: plan(strategy)
[18:04:21.629] - state: ‘created’
[18:04:21.630] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.639] plan(): nbrOfWorkers() = 2
[18:04:21.647] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:21.648]   - Field: ‘label’
[18:04:21.648]   - Field: ‘local’
[18:04:21.648]   - Field: ‘owner’
[18:04:21.649]   - Field: ‘envir’
[18:04:21.649]   - Field: ‘workers’
[18:04:21.649]   - Field: ‘packages’
[18:04:21.650]   - Field: ‘gc’
[18:04:21.650]   - Field: ‘job’
[18:04:21.650]   - Field: ‘conditions’
[18:04:21.651]   - Field: ‘expr’
[18:04:21.651]   - Field: ‘uuid’
[18:04:21.651]   - Field: ‘seed’
[18:04:21.652]   - Field: ‘version’
[18:04:21.652]   - Field: ‘result’
[18:04:21.652]   - Field: ‘asynchronous’
[18:04:21.652]   - Field: ‘calls’
[18:04:21.653]   - Field: ‘globals’
[18:04:21.653]   - Field: ‘stdout’
[18:04:21.653]   - Field: ‘earlySignal’
[18:04:21.654]   - Field: ‘lazy’
[18:04:21.654]   - Field: ‘state’
[18:04:21.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:21.655] - Launch lazy future ...
[18:04:21.656] Packages needed by the future expression (n = 0): <none>
[18:04:21.656] Packages needed by future strategies (n = 0): <none>
[18:04:21.658] {
[18:04:21.658]     {
[18:04:21.658]         {
[18:04:21.658]             ...future.startTime <- base::Sys.time()
[18:04:21.658]             {
[18:04:21.658]                 {
[18:04:21.658]                   {
[18:04:21.658]                     {
[18:04:21.658]                       base::local({
[18:04:21.658]                         has_future <- base::requireNamespace("future", 
[18:04:21.658]                           quietly = TRUE)
[18:04:21.658]                         if (has_future) {
[18:04:21.658]                           ns <- base::getNamespace("future")
[18:04:21.658]                           version <- ns[[".package"]][["version"]]
[18:04:21.658]                           if (is.null(version)) 
[18:04:21.658]                             version <- utils::packageVersion("future")
[18:04:21.658]                         }
[18:04:21.658]                         else {
[18:04:21.658]                           version <- NULL
[18:04:21.658]                         }
[18:04:21.658]                         if (!has_future || version < "1.8.0") {
[18:04:21.658]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.658]                             "", base::R.version$version.string), 
[18:04:21.658]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.658]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.658]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.658]                               "release", "version")], collapse = " "), 
[18:04:21.658]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.658]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.658]                             info)
[18:04:21.658]                           info <- base::paste(info, collapse = "; ")
[18:04:21.658]                           if (!has_future) {
[18:04:21.658]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.658]                               info)
[18:04:21.658]                           }
[18:04:21.658]                           else {
[18:04:21.658]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.658]                               info, version)
[18:04:21.658]                           }
[18:04:21.658]                           base::stop(msg)
[18:04:21.658]                         }
[18:04:21.658]                       })
[18:04:21.658]                     }
[18:04:21.658]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.658]                     base::options(mc.cores = 1L)
[18:04:21.658]                   }
[18:04:21.658]                   ...future.strategy.old <- future::plan("list")
[18:04:21.658]                   options(future.plan = NULL)
[18:04:21.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.658]                 }
[18:04:21.658]                 ...future.workdir <- getwd()
[18:04:21.658]             }
[18:04:21.658]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.658]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.658]         }
[18:04:21.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.658]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.658]             base::names(...future.oldOptions))
[18:04:21.658]     }
[18:04:21.658]     if (FALSE) {
[18:04:21.658]     }
[18:04:21.658]     else {
[18:04:21.658]         if (TRUE) {
[18:04:21.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.658]                 open = "w")
[18:04:21.658]         }
[18:04:21.658]         else {
[18:04:21.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.658]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.658]         }
[18:04:21.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.658]             base::sink(type = "output", split = FALSE)
[18:04:21.658]             base::close(...future.stdout)
[18:04:21.658]         }, add = TRUE)
[18:04:21.658]     }
[18:04:21.658]     ...future.frame <- base::sys.nframe()
[18:04:21.658]     ...future.conditions <- base::list()
[18:04:21.658]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.658]     if (FALSE) {
[18:04:21.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.658]     }
[18:04:21.658]     ...future.result <- base::tryCatch({
[18:04:21.658]         base::withCallingHandlers({
[18:04:21.658]             ...future.value <- base::withVisible(base::local({
[18:04:21.658]                 withCallingHandlers({
[18:04:21.658]                   {
[18:04:21.658]                     4
[18:04:21.658]                   }
[18:04:21.658]                 }, immediateCondition = function(cond) {
[18:04:21.658]                   save_rds <- function (object, pathname, ...) 
[18:04:21.658]                   {
[18:04:21.658]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:21.658]                     if (file_test("-f", pathname_tmp)) {
[18:04:21.658]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.658]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:21.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.658]                         fi_tmp[["mtime"]])
[18:04:21.658]                     }
[18:04:21.658]                     tryCatch({
[18:04:21.658]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:21.658]                     }, error = function(ex) {
[18:04:21.658]                       msg <- conditionMessage(ex)
[18:04:21.658]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.658]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:21.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.658]                         fi_tmp[["mtime"]], msg)
[18:04:21.658]                       ex$message <- msg
[18:04:21.658]                       stop(ex)
[18:04:21.658]                     })
[18:04:21.658]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:21.658]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:21.658]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:21.658]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.658]                       fi <- file.info(pathname)
[18:04:21.658]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:21.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.658]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:21.658]                         fi[["size"]], fi[["mtime"]])
[18:04:21.658]                       stop(msg)
[18:04:21.658]                     }
[18:04:21.658]                     invisible(pathname)
[18:04:21.658]                   }
[18:04:21.658]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:21.658]                     rootPath = tempdir()) 
[18:04:21.658]                   {
[18:04:21.658]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:21.658]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:21.658]                       tmpdir = path, fileext = ".rds")
[18:04:21.658]                     save_rds(obj, file)
[18:04:21.658]                   }
[18:04:21.658]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:21.658]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.658]                   {
[18:04:21.658]                     inherits <- base::inherits
[18:04:21.658]                     invokeRestart <- base::invokeRestart
[18:04:21.658]                     is.null <- base::is.null
[18:04:21.658]                     muffled <- FALSE
[18:04:21.658]                     if (inherits(cond, "message")) {
[18:04:21.658]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.658]                       if (muffled) 
[18:04:21.658]                         invokeRestart("muffleMessage")
[18:04:21.658]                     }
[18:04:21.658]                     else if (inherits(cond, "warning")) {
[18:04:21.658]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.658]                       if (muffled) 
[18:04:21.658]                         invokeRestart("muffleWarning")
[18:04:21.658]                     }
[18:04:21.658]                     else if (inherits(cond, "condition")) {
[18:04:21.658]                       if (!is.null(pattern)) {
[18:04:21.658]                         computeRestarts <- base::computeRestarts
[18:04:21.658]                         grepl <- base::grepl
[18:04:21.658]                         restarts <- computeRestarts(cond)
[18:04:21.658]                         for (restart in restarts) {
[18:04:21.658]                           name <- restart$name
[18:04:21.658]                           if (is.null(name)) 
[18:04:21.658]                             next
[18:04:21.658]                           if (!grepl(pattern, name)) 
[18:04:21.658]                             next
[18:04:21.658]                           invokeRestart(restart)
[18:04:21.658]                           muffled <- TRUE
[18:04:21.658]                           break
[18:04:21.658]                         }
[18:04:21.658]                       }
[18:04:21.658]                     }
[18:04:21.658]                     invisible(muffled)
[18:04:21.658]                   }
[18:04:21.658]                   muffleCondition(cond)
[18:04:21.658]                 })
[18:04:21.658]             }))
[18:04:21.658]             future::FutureResult(value = ...future.value$value, 
[18:04:21.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.658]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.658]                     ...future.globalenv.names))
[18:04:21.658]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.658]         }, condition = base::local({
[18:04:21.658]             c <- base::c
[18:04:21.658]             inherits <- base::inherits
[18:04:21.658]             invokeRestart <- base::invokeRestart
[18:04:21.658]             length <- base::length
[18:04:21.658]             list <- base::list
[18:04:21.658]             seq.int <- base::seq.int
[18:04:21.658]             signalCondition <- base::signalCondition
[18:04:21.658]             sys.calls <- base::sys.calls
[18:04:21.658]             `[[` <- base::`[[`
[18:04:21.658]             `+` <- base::`+`
[18:04:21.658]             `<<-` <- base::`<<-`
[18:04:21.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.658]                   3L)]
[18:04:21.658]             }
[18:04:21.658]             function(cond) {
[18:04:21.658]                 is_error <- inherits(cond, "error")
[18:04:21.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.658]                   NULL)
[18:04:21.658]                 if (is_error) {
[18:04:21.658]                   sessionInformation <- function() {
[18:04:21.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.658]                       search = base::search(), system = base::Sys.info())
[18:04:21.658]                   }
[18:04:21.658]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.658]                     cond$call), session = sessionInformation(), 
[18:04:21.658]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.658]                   signalCondition(cond)
[18:04:21.658]                 }
[18:04:21.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.658]                 "immediateCondition"))) {
[18:04:21.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.658]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.658]                   if (TRUE && !signal) {
[18:04:21.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.658]                     {
[18:04:21.658]                       inherits <- base::inherits
[18:04:21.658]                       invokeRestart <- base::invokeRestart
[18:04:21.658]                       is.null <- base::is.null
[18:04:21.658]                       muffled <- FALSE
[18:04:21.658]                       if (inherits(cond, "message")) {
[18:04:21.658]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.658]                         if (muffled) 
[18:04:21.658]                           invokeRestart("muffleMessage")
[18:04:21.658]                       }
[18:04:21.658]                       else if (inherits(cond, "warning")) {
[18:04:21.658]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.658]                         if (muffled) 
[18:04:21.658]                           invokeRestart("muffleWarning")
[18:04:21.658]                       }
[18:04:21.658]                       else if (inherits(cond, "condition")) {
[18:04:21.658]                         if (!is.null(pattern)) {
[18:04:21.658]                           computeRestarts <- base::computeRestarts
[18:04:21.658]                           grepl <- base::grepl
[18:04:21.658]                           restarts <- computeRestarts(cond)
[18:04:21.658]                           for (restart in restarts) {
[18:04:21.658]                             name <- restart$name
[18:04:21.658]                             if (is.null(name)) 
[18:04:21.658]                               next
[18:04:21.658]                             if (!grepl(pattern, name)) 
[18:04:21.658]                               next
[18:04:21.658]                             invokeRestart(restart)
[18:04:21.658]                             muffled <- TRUE
[18:04:21.658]                             break
[18:04:21.658]                           }
[18:04:21.658]                         }
[18:04:21.658]                       }
[18:04:21.658]                       invisible(muffled)
[18:04:21.658]                     }
[18:04:21.658]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.658]                   }
[18:04:21.658]                 }
[18:04:21.658]                 else {
[18:04:21.658]                   if (TRUE) {
[18:04:21.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.658]                     {
[18:04:21.658]                       inherits <- base::inherits
[18:04:21.658]                       invokeRestart <- base::invokeRestart
[18:04:21.658]                       is.null <- base::is.null
[18:04:21.658]                       muffled <- FALSE
[18:04:21.658]                       if (inherits(cond, "message")) {
[18:04:21.658]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.658]                         if (muffled) 
[18:04:21.658]                           invokeRestart("muffleMessage")
[18:04:21.658]                       }
[18:04:21.658]                       else if (inherits(cond, "warning")) {
[18:04:21.658]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.658]                         if (muffled) 
[18:04:21.658]                           invokeRestart("muffleWarning")
[18:04:21.658]                       }
[18:04:21.658]                       else if (inherits(cond, "condition")) {
[18:04:21.658]                         if (!is.null(pattern)) {
[18:04:21.658]                           computeRestarts <- base::computeRestarts
[18:04:21.658]                           grepl <- base::grepl
[18:04:21.658]                           restarts <- computeRestarts(cond)
[18:04:21.658]                           for (restart in restarts) {
[18:04:21.658]                             name <- restart$name
[18:04:21.658]                             if (is.null(name)) 
[18:04:21.658]                               next
[18:04:21.658]                             if (!grepl(pattern, name)) 
[18:04:21.658]                               next
[18:04:21.658]                             invokeRestart(restart)
[18:04:21.658]                             muffled <- TRUE
[18:04:21.658]                             break
[18:04:21.658]                           }
[18:04:21.658]                         }
[18:04:21.658]                       }
[18:04:21.658]                       invisible(muffled)
[18:04:21.658]                     }
[18:04:21.658]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.658]                   }
[18:04:21.658]                 }
[18:04:21.658]             }
[18:04:21.658]         }))
[18:04:21.658]     }, error = function(ex) {
[18:04:21.658]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.658]                 ...future.rng), started = ...future.startTime, 
[18:04:21.658]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.658]             version = "1.8"), class = "FutureResult")
[18:04:21.658]     }, finally = {
[18:04:21.658]         if (!identical(...future.workdir, getwd())) 
[18:04:21.658]             setwd(...future.workdir)
[18:04:21.658]         {
[18:04:21.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.658]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.658]             }
[18:04:21.658]             base::options(...future.oldOptions)
[18:04:21.658]             if (.Platform$OS.type == "windows") {
[18:04:21.658]                 old_names <- names(...future.oldEnvVars)
[18:04:21.658]                 envs <- base::Sys.getenv()
[18:04:21.658]                 names <- names(envs)
[18:04:21.658]                 common <- intersect(names, old_names)
[18:04:21.658]                 added <- setdiff(names, old_names)
[18:04:21.658]                 removed <- setdiff(old_names, names)
[18:04:21.658]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.658]                   envs[common]]
[18:04:21.658]                 NAMES <- toupper(changed)
[18:04:21.658]                 args <- list()
[18:04:21.658]                 for (kk in seq_along(NAMES)) {
[18:04:21.658]                   name <- changed[[kk]]
[18:04:21.658]                   NAME <- NAMES[[kk]]
[18:04:21.658]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.658]                     next
[18:04:21.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.658]                 }
[18:04:21.658]                 NAMES <- toupper(added)
[18:04:21.658]                 for (kk in seq_along(NAMES)) {
[18:04:21.658]                   name <- added[[kk]]
[18:04:21.658]                   NAME <- NAMES[[kk]]
[18:04:21.658]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.658]                     next
[18:04:21.658]                   args[[name]] <- ""
[18:04:21.658]                 }
[18:04:21.658]                 NAMES <- toupper(removed)
[18:04:21.658]                 for (kk in seq_along(NAMES)) {
[18:04:21.658]                   name <- removed[[kk]]
[18:04:21.658]                   NAME <- NAMES[[kk]]
[18:04:21.658]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.658]                     next
[18:04:21.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.658]                 }
[18:04:21.658]                 if (length(args) > 0) 
[18:04:21.658]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.658]             }
[18:04:21.658]             else {
[18:04:21.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.658]             }
[18:04:21.658]             {
[18:04:21.658]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.658]                   0L) {
[18:04:21.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.658]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.658]                   base::options(opts)
[18:04:21.658]                 }
[18:04:21.658]                 {
[18:04:21.658]                   {
[18:04:21.658]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.658]                     NULL
[18:04:21.658]                   }
[18:04:21.658]                   options(future.plan = NULL)
[18:04:21.658]                   if (is.na(NA_character_)) 
[18:04:21.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.658]                     .init = FALSE)
[18:04:21.658]                 }
[18:04:21.658]             }
[18:04:21.658]         }
[18:04:21.658]     })
[18:04:21.658]     if (TRUE) {
[18:04:21.658]         base::sink(type = "output", split = FALSE)
[18:04:21.658]         if (TRUE) {
[18:04:21.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.658]         }
[18:04:21.658]         else {
[18:04:21.658]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.658]         }
[18:04:21.658]         base::close(...future.stdout)
[18:04:21.658]         ...future.stdout <- NULL
[18:04:21.658]     }
[18:04:21.658]     ...future.result$conditions <- ...future.conditions
[18:04:21.658]     ...future.result$finished <- base::Sys.time()
[18:04:21.658]     ...future.result
[18:04:21.658] }
[18:04:21.665] requestCore(): workers = 2
[18:04:21.666] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:21.678] result() for MulticoreFuture ...
[18:04:21.680] result() for MulticoreFuture ...
[18:04:21.680] result() for MulticoreFuture ... done
[18:04:21.681] result() for MulticoreFuture ... done
[18:04:21.683] result() for MulticoreFuture ...
[18:04:21.684] result() for MulticoreFuture ... done
[18:04:21.691] MulticoreFuture started
[18:04:21.693] - Launch lazy future ... done
[18:04:21.694] run() for ‘MulticoreFuture’ ... done
[18:04:21.696] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5e3c2abde4d8> 
[18:04:21.696] List of future strategies:
[18:04:21.696] 1. sequential:
[18:04:21.696]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:21.696]    - tweaked: FALSE
[18:04:21.696]    - call: NULL
[18:04:21.703] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5e3c2c702128> 
 - attr(*, "dim.")=[18:04:21.711] plan(): Setting new future strategy stack:
 int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ :[18:04:21.712] List of future strategies:
[18:04:21.712] 1. multicore:
[18:04:21.712]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:21.712]    - tweaked: FALSE
[18:04:21.712]    - call: plan(strategy)
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[18:04:21.730] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:21.739] resolve() on list environment ...
[18:04:21.740]  recursive: 0
[18:04:21.743]  length: 6
[18:04:21.744]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:21.744] signalConditionsASAP(numeric, pos=1) ...
[18:04:21.745] - nx: 6
[18:04:21.745] - relay: TRUE
[18:04:21.745] - stdout: TRUE
[18:04:21.745] - signal: TRUE
[18:04:21.746] - resignal: FALSE
[18:04:21.746] - force: TRUE
[18:04:21.746] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.746] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.747]  - until=2
[18:04:21.747]  - relaying element #2
[18:04:21.747] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.748] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.748] signalConditionsASAP(NULL, pos=1) ... done
[18:04:21.748]  length: 5 (resolved future 1)
[18:04:21.749] Future #2
[18:04:21.749] result() for MulticoreFuture ...
[18:04:21.749] result() for MulticoreFuture ... done
[18:04:21.750] result() for MulticoreFuture ...
[18:04:21.750] result() for MulticoreFuture ... done
[18:04:21.750] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:21.751] - nx: 6
[18:04:21.751] - relay: TRUE
[18:04:21.751] - stdout: TRUE
[18:04:21.751] - signal: TRUE
[18:04:21.752] - resignal: FALSE
[18:04:21.752] - force: TRUE
[18:04:21.752] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.752] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:21.753]  - until=2
[18:04:21.753]  - relaying element #2
[18:04:21.753] result() for MulticoreFuture ...
[18:04:21.754] result() for MulticoreFuture ... done
[18:04:21.754] result() for MulticoreFuture ...
[18:04:21.754] result() for MulticoreFuture ... done
[18:04:21.755] result() for MulticoreFuture ...
[18:04:21.755] result() for MulticoreFuture ... done
[18:04:21.755] result() for MulticoreFuture ...
[18:04:21.756] result() for MulticoreFuture ... done
[18:04:21.756] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:21.756] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:21.757] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:21.757]  length: 4 (resolved future 2)
[18:04:21.758] Future #3
[18:04:21.759] result() for MulticoreFuture ...
[18:04:21.761] result() for MulticoreFuture ...
[18:04:21.763] result() for MulticoreFuture ... done
[18:04:21.763] result() for MulticoreFuture ... done
[18:04:21.764] result() for MulticoreFuture ...
[18:04:21.764] result() for MulticoreFuture ... done
[18:04:21.767] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:21.768] - nx: 6
[18:04:21.768] - relay: TRUE
[18:04:21.768] - stdout: TRUE
[18:04:21.769] - signal: TRUE
[18:04:21.771] - resignal: FALSE
[18:04:21.772] - force: TRUE
[18:04:21.774] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:21.775] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:21.775]  - until=3
[18:04:21.775]  - relaying element #3
[18:04:21.778] result() for MulticoreFuture ...
[18:04:21.778] result() for MulticoreFuture ... done
[18:04:21.779] result() for MulticoreFuture ...
[18:04:21.779] result() for MulticoreFuture ... done
[18:04:21.782] result() for MulticoreFuture ...
[18:04:21.782] result() for MulticoreFuture ... done
[18:04:21.783] result() for MulticoreFuture ...
[18:04:21.783] result() for MulticoreFuture ... done
[18:04:21.783] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:21.784] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:21.784] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:21.784]  length: 3 (resolved future 3)
[18:04:21.788] Future #4
[18:04:21.788] result() for MulticoreFuture ...
[18:04:21.794] result() for MulticoreFuture ...
[18:04:21.794] result() for MulticoreFuture ... done
[18:04:21.795] result() for MulticoreFuture ... done
[18:04:21.797] result() for MulticoreFuture ...
[18:04:21.797] result() for MulticoreFuture ... done
[18:04:21.798] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:21.798] - nx: 6
[18:04:21.798] - relay: TRUE
[18:04:21.803] - stdout: TRUE
[18:04:21.803] - signal: TRUE
[18:04:21.804] - resignal: FALSE
[18:04:21.804] - force: TRUE
[18:04:21.804] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:21.804] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:21.805]  - until=4
[18:04:21.806]  - relaying element #4
[18:04:21.806] result() for MulticoreFuture ...
[18:04:21.807] result() for MulticoreFuture ... done
[18:04:21.807] result() for MulticoreFuture ...
[18:04:21.807] result() for MulticoreFuture ... done
[18:04:21.807] result() for MulticoreFuture ...
[18:04:21.808] result() for MulticoreFuture ... done
[18:04:21.811] result() for MulticoreFuture ...
[18:04:21.811] result() for MulticoreFuture ... done
[18:04:21.812] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.812] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.812] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:21.812]  length: 2 (resolved future 4)
[18:04:21.815] signalConditionsASAP(NULL, pos=5) ...
[18:04:21.815] - nx: 6
[18:04:21.815] - relay: TRUE
[18:04:21.816] - stdout: TRUE
[18:04:21.816] - signal: TRUE
[18:04:21.816] - resignal: FALSE
[18:04:21.816] - force: TRUE
[18:04:21.816] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.817] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.819]  - until=6
[18:04:21.819]  - relaying element #6
[18:04:21.820] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:21.820] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.822] signalConditionsASAP(NULL, pos=5) ... done
[18:04:21.822]  length: 1 (resolved future 5)
[18:04:21.823] signalConditionsASAP(numeric, pos=6) ...
[18:04:21.823] - nx: 6
[18:04:21.823] - relay: TRUE
[18:04:21.823] - stdout: TRUE
[18:04:21.824] - signal: TRUE
[18:04:21.824] - resignal: FALSE
[18:04:21.824] - force: TRUE
[18:04:21.824] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:21.824] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.825]  - until=6
[18:04:21.825] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:21.825] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.825] signalConditionsASAP(numeric, pos=6) ... done
[18:04:21.826]  length: 0 (resolved future 6)
[18:04:21.826] Relaying remaining futures
[18:04:21.826] signalConditionsASAP(NULL, pos=0) ...
[18:04:21.826] - nx: 6
[18:04:21.826] - relay: TRUE
[18:04:21.827] - stdout: TRUE
[18:04:21.827] - signal: TRUE
[18:04:21.827] - resignal: FALSE
[18:04:21.827] - force: TRUE
[18:04:21.827] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:21.828] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:21.828] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:21.828] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:21.829] signalConditionsASAP(NULL, pos=0) ... done
[18:04:21.829] resolve() on list environment ... DONE
[18:04:21.829] result() for MulticoreFuture ...
[18:04:21.829] result() for MulticoreFuture ... done
[18:04:21.830] result() for MulticoreFuture ...
[18:04:21.830] result() for MulticoreFuture ... done
[18:04:21.830] result() for MulticoreFuture ...
[18:04:21.831] result() for MulticoreFuture ... done
[18:04:21.831] result() for MulticoreFuture ...
[18:04:21.831] result() for MulticoreFuture ... done
[18:04:21.832] result() for MulticoreFuture ...
[18:04:21.832] result() for MulticoreFuture ... done
[18:04:21.832] result() for MulticoreFuture ...
[18:04:21.832] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2ca14e98> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[18:04:21.836] getGlobalsAndPackages() ...
[18:04:21.837] Searching for globals...
[18:04:21.837] 
[18:04:21.838] Searching for globals ... DONE
[18:04:21.838] - globals: [0] <none>
[18:04:21.838] getGlobalsAndPackages() ... DONE
[18:04:21.844] run() for ‘Future’ ...
[18:04:21.845] - state: ‘created’
[18:04:21.845] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.853] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:21.854]   - Field: ‘label’
[18:04:21.854]   - Field: ‘local’
[18:04:21.855]   - Field: ‘owner’
[18:04:21.855]   - Field: ‘envir’
[18:04:21.855]   - Field: ‘workers’
[18:04:21.856]   - Field: ‘packages’
[18:04:21.856]   - Field: ‘gc’
[18:04:21.856]   - Field: ‘job’
[18:04:21.856]   - Field: ‘conditions’
[18:04:21.857]   - Field: ‘expr’
[18:04:21.857]   - Field: ‘uuid’
[18:04:21.857]   - Field: ‘seed’
[18:04:21.857]   - Field: ‘version’
[18:04:21.858]   - Field: ‘result’
[18:04:21.858]   - Field: ‘asynchronous’
[18:04:21.858]   - Field: ‘calls’
[18:04:21.858]   - Field: ‘globals’
[18:04:21.859]   - Field: ‘stdout’
[18:04:21.859]   - Field: ‘earlySignal’
[18:04:21.859]   - Field: ‘lazy’
[18:04:21.859]   - Field: ‘state’
[18:04:21.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:21.860] - Launch lazy future ...
[18:04:21.861] Packages needed by the future expression (n = 0): <none>
[18:04:21.861] Packages needed by future strategies (n = 0): <none>
[18:04:21.862] {
[18:04:21.862]     {
[18:04:21.862]         {
[18:04:21.862]             ...future.startTime <- base::Sys.time()
[18:04:21.862]             {
[18:04:21.862]                 {
[18:04:21.862]                   {
[18:04:21.862]                     {
[18:04:21.862]                       base::local({
[18:04:21.862]                         has_future <- base::requireNamespace("future", 
[18:04:21.862]                           quietly = TRUE)
[18:04:21.862]                         if (has_future) {
[18:04:21.862]                           ns <- base::getNamespace("future")
[18:04:21.862]                           version <- ns[[".package"]][["version"]]
[18:04:21.862]                           if (is.null(version)) 
[18:04:21.862]                             version <- utils::packageVersion("future")
[18:04:21.862]                         }
[18:04:21.862]                         else {
[18:04:21.862]                           version <- NULL
[18:04:21.862]                         }
[18:04:21.862]                         if (!has_future || version < "1.8.0") {
[18:04:21.862]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.862]                             "", base::R.version$version.string), 
[18:04:21.862]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.862]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.862]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.862]                               "release", "version")], collapse = " "), 
[18:04:21.862]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.862]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.862]                             info)
[18:04:21.862]                           info <- base::paste(info, collapse = "; ")
[18:04:21.862]                           if (!has_future) {
[18:04:21.862]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.862]                               info)
[18:04:21.862]                           }
[18:04:21.862]                           else {
[18:04:21.862]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.862]                               info, version)
[18:04:21.862]                           }
[18:04:21.862]                           base::stop(msg)
[18:04:21.862]                         }
[18:04:21.862]                       })
[18:04:21.862]                     }
[18:04:21.862]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.862]                     base::options(mc.cores = 1L)
[18:04:21.862]                   }
[18:04:21.862]                   ...future.strategy.old <- future::plan("list")
[18:04:21.862]                   options(future.plan = NULL)
[18:04:21.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.862]                 }
[18:04:21.862]                 ...future.workdir <- getwd()
[18:04:21.862]             }
[18:04:21.862]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.862]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.862]         }
[18:04:21.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.862]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.862]             base::names(...future.oldOptions))
[18:04:21.862]     }
[18:04:21.862]     if (FALSE) {
[18:04:21.862]     }
[18:04:21.862]     else {
[18:04:21.862]         if (TRUE) {
[18:04:21.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.862]                 open = "w")
[18:04:21.862]         }
[18:04:21.862]         else {
[18:04:21.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.862]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.862]         }
[18:04:21.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.862]             base::sink(type = "output", split = FALSE)
[18:04:21.862]             base::close(...future.stdout)
[18:04:21.862]         }, add = TRUE)
[18:04:21.862]     }
[18:04:21.862]     ...future.frame <- base::sys.nframe()
[18:04:21.862]     ...future.conditions <- base::list()
[18:04:21.862]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.862]     if (FALSE) {
[18:04:21.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.862]     }
[18:04:21.862]     ...future.result <- base::tryCatch({
[18:04:21.862]         base::withCallingHandlers({
[18:04:21.862]             ...future.value <- base::withVisible(base::local({
[18:04:21.862]                 withCallingHandlers({
[18:04:21.862]                   2
[18:04:21.862]                 }, immediateCondition = function(cond) {
[18:04:21.862]                   save_rds <- function (object, pathname, ...) 
[18:04:21.862]                   {
[18:04:21.862]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:21.862]                     if (file_test("-f", pathname_tmp)) {
[18:04:21.862]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.862]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:21.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.862]                         fi_tmp[["mtime"]])
[18:04:21.862]                     }
[18:04:21.862]                     tryCatch({
[18:04:21.862]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:21.862]                     }, error = function(ex) {
[18:04:21.862]                       msg <- conditionMessage(ex)
[18:04:21.862]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.862]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:21.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.862]                         fi_tmp[["mtime"]], msg)
[18:04:21.862]                       ex$message <- msg
[18:04:21.862]                       stop(ex)
[18:04:21.862]                     })
[18:04:21.862]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:21.862]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:21.862]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:21.862]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.862]                       fi <- file.info(pathname)
[18:04:21.862]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:21.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.862]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:21.862]                         fi[["size"]], fi[["mtime"]])
[18:04:21.862]                       stop(msg)
[18:04:21.862]                     }
[18:04:21.862]                     invisible(pathname)
[18:04:21.862]                   }
[18:04:21.862]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:21.862]                     rootPath = tempdir()) 
[18:04:21.862]                   {
[18:04:21.862]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:21.862]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:21.862]                       tmpdir = path, fileext = ".rds")
[18:04:21.862]                     save_rds(obj, file)
[18:04:21.862]                   }
[18:04:21.862]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:21.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.862]                   {
[18:04:21.862]                     inherits <- base::inherits
[18:04:21.862]                     invokeRestart <- base::invokeRestart
[18:04:21.862]                     is.null <- base::is.null
[18:04:21.862]                     muffled <- FALSE
[18:04:21.862]                     if (inherits(cond, "message")) {
[18:04:21.862]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.862]                       if (muffled) 
[18:04:21.862]                         invokeRestart("muffleMessage")
[18:04:21.862]                     }
[18:04:21.862]                     else if (inherits(cond, "warning")) {
[18:04:21.862]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.862]                       if (muffled) 
[18:04:21.862]                         invokeRestart("muffleWarning")
[18:04:21.862]                     }
[18:04:21.862]                     else if (inherits(cond, "condition")) {
[18:04:21.862]                       if (!is.null(pattern)) {
[18:04:21.862]                         computeRestarts <- base::computeRestarts
[18:04:21.862]                         grepl <- base::grepl
[18:04:21.862]                         restarts <- computeRestarts(cond)
[18:04:21.862]                         for (restart in restarts) {
[18:04:21.862]                           name <- restart$name
[18:04:21.862]                           if (is.null(name)) 
[18:04:21.862]                             next
[18:04:21.862]                           if (!grepl(pattern, name)) 
[18:04:21.862]                             next
[18:04:21.862]                           invokeRestart(restart)
[18:04:21.862]                           muffled <- TRUE
[18:04:21.862]                           break
[18:04:21.862]                         }
[18:04:21.862]                       }
[18:04:21.862]                     }
[18:04:21.862]                     invisible(muffled)
[18:04:21.862]                   }
[18:04:21.862]                   muffleCondition(cond)
[18:04:21.862]                 })
[18:04:21.862]             }))
[18:04:21.862]             future::FutureResult(value = ...future.value$value, 
[18:04:21.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.862]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.862]                     ...future.globalenv.names))
[18:04:21.862]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.862]         }, condition = base::local({
[18:04:21.862]             c <- base::c
[18:04:21.862]             inherits <- base::inherits
[18:04:21.862]             invokeRestart <- base::invokeRestart
[18:04:21.862]             length <- base::length
[18:04:21.862]             list <- base::list
[18:04:21.862]             seq.int <- base::seq.int
[18:04:21.862]             signalCondition <- base::signalCondition
[18:04:21.862]             sys.calls <- base::sys.calls
[18:04:21.862]             `[[` <- base::`[[`
[18:04:21.862]             `+` <- base::`+`
[18:04:21.862]             `<<-` <- base::`<<-`
[18:04:21.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.862]                   3L)]
[18:04:21.862]             }
[18:04:21.862]             function(cond) {
[18:04:21.862]                 is_error <- inherits(cond, "error")
[18:04:21.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.862]                   NULL)
[18:04:21.862]                 if (is_error) {
[18:04:21.862]                   sessionInformation <- function() {
[18:04:21.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.862]                       search = base::search(), system = base::Sys.info())
[18:04:21.862]                   }
[18:04:21.862]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.862]                     cond$call), session = sessionInformation(), 
[18:04:21.862]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.862]                   signalCondition(cond)
[18:04:21.862]                 }
[18:04:21.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.862]                 "immediateCondition"))) {
[18:04:21.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.862]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.862]                   if (TRUE && !signal) {
[18:04:21.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.862]                     {
[18:04:21.862]                       inherits <- base::inherits
[18:04:21.862]                       invokeRestart <- base::invokeRestart
[18:04:21.862]                       is.null <- base::is.null
[18:04:21.862]                       muffled <- FALSE
[18:04:21.862]                       if (inherits(cond, "message")) {
[18:04:21.862]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.862]                         if (muffled) 
[18:04:21.862]                           invokeRestart("muffleMessage")
[18:04:21.862]                       }
[18:04:21.862]                       else if (inherits(cond, "warning")) {
[18:04:21.862]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.862]                         if (muffled) 
[18:04:21.862]                           invokeRestart("muffleWarning")
[18:04:21.862]                       }
[18:04:21.862]                       else if (inherits(cond, "condition")) {
[18:04:21.862]                         if (!is.null(pattern)) {
[18:04:21.862]                           computeRestarts <- base::computeRestarts
[18:04:21.862]                           grepl <- base::grepl
[18:04:21.862]                           restarts <- computeRestarts(cond)
[18:04:21.862]                           for (restart in restarts) {
[18:04:21.862]                             name <- restart$name
[18:04:21.862]                             if (is.null(name)) 
[18:04:21.862]                               next
[18:04:21.862]                             if (!grepl(pattern, name)) 
[18:04:21.862]                               next
[18:04:21.862]                             invokeRestart(restart)
[18:04:21.862]                             muffled <- TRUE
[18:04:21.862]                             break
[18:04:21.862]                           }
[18:04:21.862]                         }
[18:04:21.862]                       }
[18:04:21.862]                       invisible(muffled)
[18:04:21.862]                     }
[18:04:21.862]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.862]                   }
[18:04:21.862]                 }
[18:04:21.862]                 else {
[18:04:21.862]                   if (TRUE) {
[18:04:21.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.862]                     {
[18:04:21.862]                       inherits <- base::inherits
[18:04:21.862]                       invokeRestart <- base::invokeRestart
[18:04:21.862]                       is.null <- base::is.null
[18:04:21.862]                       muffled <- FALSE
[18:04:21.862]                       if (inherits(cond, "message")) {
[18:04:21.862]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.862]                         if (muffled) 
[18:04:21.862]                           invokeRestart("muffleMessage")
[18:04:21.862]                       }
[18:04:21.862]                       else if (inherits(cond, "warning")) {
[18:04:21.862]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.862]                         if (muffled) 
[18:04:21.862]                           invokeRestart("muffleWarning")
[18:04:21.862]                       }
[18:04:21.862]                       else if (inherits(cond, "condition")) {
[18:04:21.862]                         if (!is.null(pattern)) {
[18:04:21.862]                           computeRestarts <- base::computeRestarts
[18:04:21.862]                           grepl <- base::grepl
[18:04:21.862]                           restarts <- computeRestarts(cond)
[18:04:21.862]                           for (restart in restarts) {
[18:04:21.862]                             name <- restart$name
[18:04:21.862]                             if (is.null(name)) 
[18:04:21.862]                               next
[18:04:21.862]                             if (!grepl(pattern, name)) 
[18:04:21.862]                               next
[18:04:21.862]                             invokeRestart(restart)
[18:04:21.862]                             muffled <- TRUE
[18:04:21.862]                             break
[18:04:21.862]                           }
[18:04:21.862]                         }
[18:04:21.862]                       }
[18:04:21.862]                       invisible(muffled)
[18:04:21.862]                     }
[18:04:21.862]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.862]                   }
[18:04:21.862]                 }
[18:04:21.862]             }
[18:04:21.862]         }))
[18:04:21.862]     }, error = function(ex) {
[18:04:21.862]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.862]                 ...future.rng), started = ...future.startTime, 
[18:04:21.862]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.862]             version = "1.8"), class = "FutureResult")
[18:04:21.862]     }, finally = {
[18:04:21.862]         if (!identical(...future.workdir, getwd())) 
[18:04:21.862]             setwd(...future.workdir)
[18:04:21.862]         {
[18:04:21.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.862]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.862]             }
[18:04:21.862]             base::options(...future.oldOptions)
[18:04:21.862]             if (.Platform$OS.type == "windows") {
[18:04:21.862]                 old_names <- names(...future.oldEnvVars)
[18:04:21.862]                 envs <- base::Sys.getenv()
[18:04:21.862]                 names <- names(envs)
[18:04:21.862]                 common <- intersect(names, old_names)
[18:04:21.862]                 added <- setdiff(names, old_names)
[18:04:21.862]                 removed <- setdiff(old_names, names)
[18:04:21.862]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.862]                   envs[common]]
[18:04:21.862]                 NAMES <- toupper(changed)
[18:04:21.862]                 args <- list()
[18:04:21.862]                 for (kk in seq_along(NAMES)) {
[18:04:21.862]                   name <- changed[[kk]]
[18:04:21.862]                   NAME <- NAMES[[kk]]
[18:04:21.862]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.862]                     next
[18:04:21.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.862]                 }
[18:04:21.862]                 NAMES <- toupper(added)
[18:04:21.862]                 for (kk in seq_along(NAMES)) {
[18:04:21.862]                   name <- added[[kk]]
[18:04:21.862]                   NAME <- NAMES[[kk]]
[18:04:21.862]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.862]                     next
[18:04:21.862]                   args[[name]] <- ""
[18:04:21.862]                 }
[18:04:21.862]                 NAMES <- toupper(removed)
[18:04:21.862]                 for (kk in seq_along(NAMES)) {
[18:04:21.862]                   name <- removed[[kk]]
[18:04:21.862]                   NAME <- NAMES[[kk]]
[18:04:21.862]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.862]                     next
[18:04:21.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.862]                 }
[18:04:21.862]                 if (length(args) > 0) 
[18:04:21.862]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.862]             }
[18:04:21.862]             else {
[18:04:21.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.862]             }
[18:04:21.862]             {
[18:04:21.862]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.862]                   0L) {
[18:04:21.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.862]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.862]                   base::options(opts)
[18:04:21.862]                 }
[18:04:21.862]                 {
[18:04:21.862]                   {
[18:04:21.862]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.862]                     NULL
[18:04:21.862]                   }
[18:04:21.862]                   options(future.plan = NULL)
[18:04:21.862]                   if (is.na(NA_character_)) 
[18:04:21.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.862]                     .init = FALSE)
[18:04:21.862]                 }
[18:04:21.862]             }
[18:04:21.862]         }
[18:04:21.862]     })
[18:04:21.862]     if (TRUE) {
[18:04:21.862]         base::sink(type = "output", split = FALSE)
[18:04:21.862]         if (TRUE) {
[18:04:21.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.862]         }
[18:04:21.862]         else {
[18:04:21.862]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.862]         }
[18:04:21.862]         base::close(...future.stdout)
[18:04:21.862]         ...future.stdout <- NULL
[18:04:21.862]     }
[18:04:21.862]     ...future.result$conditions <- ...future.conditions
[18:04:21.862]     ...future.result$finished <- base::Sys.time()
[18:04:21.862]     ...future.result
[18:04:21.862] }
[18:04:21.867] requestCore(): workers = 2
[18:04:21.872] MulticoreFuture started
[18:04:21.874] - Launch lazy future ... done
[18:04:21.875] run() for ‘MulticoreFuture’ ... done
[18:04:21.877] plan(): Setting new future strategy stack:
[18:04:21.878] getGlobalsAndPackages() ...
[18:04:21.878] Searching for globals...
[18:04:21.881] 
[18:04:21.882] Searching for globals ... DONE
[18:04:21.882] - globals: [0] <none>
[18:04:21.882] getGlobalsAndPackages() ... DONE
[18:04:21.877] List of future strategies:
[18:04:21.877] 1. sequential:
[18:04:21.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:21.877]    - tweaked: FALSE
[18:04:21.877]    - call: NULL
[18:04:21.883] plan(): nbrOfWorkers() = 1
[18:04:21.887] run() for ‘Future’ ...
[18:04:21.887] - state: ‘created’
[18:04:21.889] plan(): Setting new future strategy stack:
[18:04:21.890] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.890] List of future strategies:
[18:04:21.890] 1. multicore:
[18:04:21.890]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:21.890]    - tweaked: FALSE
[18:04:21.890]    - call: plan(strategy)
[18:04:21.905] plan(): nbrOfWorkers() = 2
[18:04:21.905] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.906] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:21.906]   - Field: ‘label’
[18:04:21.906]   - Field: ‘local’
[18:04:21.907]   - Field: ‘owner’
[18:04:21.907]   - Field: ‘envir’
[18:04:21.907]   - Field: ‘workers’
[18:04:21.908]   - Field: ‘packages’
[18:04:21.908]   - Field: ‘gc’
[18:04:21.908]   - Field: ‘job’
[18:04:21.909]   - Field: ‘conditions’
[18:04:21.909]   - Field: ‘expr’
[18:04:21.909]   - Field: ‘uuid’
[18:04:21.909]   - Field: ‘seed’
[18:04:21.910]   - Field: ‘version’
[18:04:21.910]   - Field: ‘result’
[18:04:21.910]   - Field: ‘asynchronous’
[18:04:21.911]   - Field: ‘calls’
[18:04:21.911]   - Field: ‘globals’
[18:04:21.911]   - Field: ‘stdout’
[18:04:21.912]   - Field: ‘earlySignal’
[18:04:21.912]   - Field: ‘lazy’
[18:04:21.912]   - Field: ‘state’
[18:04:21.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:21.913] - Launch lazy future ...
[18:04:21.914] Packages needed by the future expression (n = 0): <none>
[18:04:21.914] Packages needed by future strategies (n = 0): <none>
[18:04:21.916] {
[18:04:21.916]     {
[18:04:21.916]         {
[18:04:21.916]             ...future.startTime <- base::Sys.time()
[18:04:21.916]             {
[18:04:21.916]                 {
[18:04:21.916]                   {
[18:04:21.916]                     {
[18:04:21.916]                       base::local({
[18:04:21.916]                         has_future <- base::requireNamespace("future", 
[18:04:21.916]                           quietly = TRUE)
[18:04:21.916]                         if (has_future) {
[18:04:21.916]                           ns <- base::getNamespace("future")
[18:04:21.916]                           version <- ns[[".package"]][["version"]]
[18:04:21.916]                           if (is.null(version)) 
[18:04:21.916]                             version <- utils::packageVersion("future")
[18:04:21.916]                         }
[18:04:21.916]                         else {
[18:04:21.916]                           version <- NULL
[18:04:21.916]                         }
[18:04:21.916]                         if (!has_future || version < "1.8.0") {
[18:04:21.916]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.916]                             "", base::R.version$version.string), 
[18:04:21.916]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.916]                               "release", "version")], collapse = " "), 
[18:04:21.916]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.916]                             info)
[18:04:21.916]                           info <- base::paste(info, collapse = "; ")
[18:04:21.916]                           if (!has_future) {
[18:04:21.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.916]                               info)
[18:04:21.916]                           }
[18:04:21.916]                           else {
[18:04:21.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.916]                               info, version)
[18:04:21.916]                           }
[18:04:21.916]                           base::stop(msg)
[18:04:21.916]                         }
[18:04:21.916]                       })
[18:04:21.916]                     }
[18:04:21.916]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.916]                     base::options(mc.cores = 1L)
[18:04:21.916]                   }
[18:04:21.916]                   ...future.strategy.old <- future::plan("list")
[18:04:21.916]                   options(future.plan = NULL)
[18:04:21.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.916]                 }
[18:04:21.916]                 ...future.workdir <- getwd()
[18:04:21.916]             }
[18:04:21.916]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.916]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.916]         }
[18:04:21.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.916]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.916]             base::names(...future.oldOptions))
[18:04:21.916]     }
[18:04:21.916]     if (FALSE) {
[18:04:21.916]     }
[18:04:21.916]     else {
[18:04:21.916]         if (TRUE) {
[18:04:21.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.916]                 open = "w")
[18:04:21.916]         }
[18:04:21.916]         else {
[18:04:21.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.916]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.916]         }
[18:04:21.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.916]             base::sink(type = "output", split = FALSE)
[18:04:21.916]             base::close(...future.stdout)
[18:04:21.916]         }, add = TRUE)
[18:04:21.916]     }
[18:04:21.916]     ...future.frame <- base::sys.nframe()
[18:04:21.916]     ...future.conditions <- base::list()
[18:04:21.916]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.916]     if (FALSE) {
[18:04:21.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.916]     }
[18:04:21.916]     ...future.result <- base::tryCatch({
[18:04:21.916]         base::withCallingHandlers({
[18:04:21.916]             ...future.value <- base::withVisible(base::local({
[18:04:21.916]                 withCallingHandlers({
[18:04:21.916]                   NULL
[18:04:21.916]                 }, immediateCondition = function(cond) {
[18:04:21.916]                   save_rds <- function (object, pathname, ...) 
[18:04:21.916]                   {
[18:04:21.916]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:21.916]                     if (file_test("-f", pathname_tmp)) {
[18:04:21.916]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.916]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:21.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.916]                         fi_tmp[["mtime"]])
[18:04:21.916]                     }
[18:04:21.916]                     tryCatch({
[18:04:21.916]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:21.916]                     }, error = function(ex) {
[18:04:21.916]                       msg <- conditionMessage(ex)
[18:04:21.916]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.916]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:21.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.916]                         fi_tmp[["mtime"]], msg)
[18:04:21.916]                       ex$message <- msg
[18:04:21.916]                       stop(ex)
[18:04:21.916]                     })
[18:04:21.916]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:21.916]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:21.916]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:21.916]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.916]                       fi <- file.info(pathname)
[18:04:21.916]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:21.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.916]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:21.916]                         fi[["size"]], fi[["mtime"]])
[18:04:21.916]                       stop(msg)
[18:04:21.916]                     }
[18:04:21.916]                     invisible(pathname)
[18:04:21.916]                   }
[18:04:21.916]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:21.916]                     rootPath = tempdir()) 
[18:04:21.916]                   {
[18:04:21.916]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:21.916]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:21.916]                       tmpdir = path, fileext = ".rds")
[18:04:21.916]                     save_rds(obj, file)
[18:04:21.916]                   }
[18:04:21.916]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:21.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.916]                   {
[18:04:21.916]                     inherits <- base::inherits
[18:04:21.916]                     invokeRestart <- base::invokeRestart
[18:04:21.916]                     is.null <- base::is.null
[18:04:21.916]                     muffled <- FALSE
[18:04:21.916]                     if (inherits(cond, "message")) {
[18:04:21.916]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.916]                       if (muffled) 
[18:04:21.916]                         invokeRestart("muffleMessage")
[18:04:21.916]                     }
[18:04:21.916]                     else if (inherits(cond, "warning")) {
[18:04:21.916]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.916]                       if (muffled) 
[18:04:21.916]                         invokeRestart("muffleWarning")
[18:04:21.916]                     }
[18:04:21.916]                     else if (inherits(cond, "condition")) {
[18:04:21.916]                       if (!is.null(pattern)) {
[18:04:21.916]                         computeRestarts <- base::computeRestarts
[18:04:21.916]                         grepl <- base::grepl
[18:04:21.916]                         restarts <- computeRestarts(cond)
[18:04:21.916]                         for (restart in restarts) {
[18:04:21.916]                           name <- restart$name
[18:04:21.916]                           if (is.null(name)) 
[18:04:21.916]                             next
[18:04:21.916]                           if (!grepl(pattern, name)) 
[18:04:21.916]                             next
[18:04:21.916]                           invokeRestart(restart)
[18:04:21.916]                           muffled <- TRUE
[18:04:21.916]                           break
[18:04:21.916]                         }
[18:04:21.916]                       }
[18:04:21.916]                     }
[18:04:21.916]                     invisible(muffled)
[18:04:21.916]                   }
[18:04:21.916]                   muffleCondition(cond)
[18:04:21.916]                 })
[18:04:21.916]             }))
[18:04:21.916]             future::FutureResult(value = ...future.value$value, 
[18:04:21.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.916]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.916]                     ...future.globalenv.names))
[18:04:21.916]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.916]         }, condition = base::local({
[18:04:21.916]             c <- base::c
[18:04:21.916]             inherits <- base::inherits
[18:04:21.916]             invokeRestart <- base::invokeRestart
[18:04:21.916]             length <- base::length
[18:04:21.916]             list <- base::list
[18:04:21.916]             seq.int <- base::seq.int
[18:04:21.916]             signalCondition <- base::signalCondition
[18:04:21.916]             sys.calls <- base::sys.calls
[18:04:21.916]             `[[` <- base::`[[`
[18:04:21.916]             `+` <- base::`+`
[18:04:21.916]             `<<-` <- base::`<<-`
[18:04:21.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.916]                   3L)]
[18:04:21.916]             }
[18:04:21.916]             function(cond) {
[18:04:21.916]                 is_error <- inherits(cond, "error")
[18:04:21.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.916]                   NULL)
[18:04:21.916]                 if (is_error) {
[18:04:21.916]                   sessionInformation <- function() {
[18:04:21.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.916]                       search = base::search(), system = base::Sys.info())
[18:04:21.916]                   }
[18:04:21.916]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.916]                     cond$call), session = sessionInformation(), 
[18:04:21.916]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.916]                   signalCondition(cond)
[18:04:21.916]                 }
[18:04:21.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.916]                 "immediateCondition"))) {
[18:04:21.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.916]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.916]                   if (TRUE && !signal) {
[18:04:21.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.916]                     {
[18:04:21.916]                       inherits <- base::inherits
[18:04:21.916]                       invokeRestart <- base::invokeRestart
[18:04:21.916]                       is.null <- base::is.null
[18:04:21.916]                       muffled <- FALSE
[18:04:21.916]                       if (inherits(cond, "message")) {
[18:04:21.916]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.916]                         if (muffled) 
[18:04:21.916]                           invokeRestart("muffleMessage")
[18:04:21.916]                       }
[18:04:21.916]                       else if (inherits(cond, "warning")) {
[18:04:21.916]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.916]                         if (muffled) 
[18:04:21.916]                           invokeRestart("muffleWarning")
[18:04:21.916]                       }
[18:04:21.916]                       else if (inherits(cond, "condition")) {
[18:04:21.916]                         if (!is.null(pattern)) {
[18:04:21.916]                           computeRestarts <- base::computeRestarts
[18:04:21.916]                           grepl <- base::grepl
[18:04:21.916]                           restarts <- computeRestarts(cond)
[18:04:21.916]                           for (restart in restarts) {
[18:04:21.916]                             name <- restart$name
[18:04:21.916]                             if (is.null(name)) 
[18:04:21.916]                               next
[18:04:21.916]                             if (!grepl(pattern, name)) 
[18:04:21.916]                               next
[18:04:21.916]                             invokeRestart(restart)
[18:04:21.916]                             muffled <- TRUE
[18:04:21.916]                             break
[18:04:21.916]                           }
[18:04:21.916]                         }
[18:04:21.916]                       }
[18:04:21.916]                       invisible(muffled)
[18:04:21.916]                     }
[18:04:21.916]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.916]                   }
[18:04:21.916]                 }
[18:04:21.916]                 else {
[18:04:21.916]                   if (TRUE) {
[18:04:21.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.916]                     {
[18:04:21.916]                       inherits <- base::inherits
[18:04:21.916]                       invokeRestart <- base::invokeRestart
[18:04:21.916]                       is.null <- base::is.null
[18:04:21.916]                       muffled <- FALSE
[18:04:21.916]                       if (inherits(cond, "message")) {
[18:04:21.916]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.916]                         if (muffled) 
[18:04:21.916]                           invokeRestart("muffleMessage")
[18:04:21.916]                       }
[18:04:21.916]                       else if (inherits(cond, "warning")) {
[18:04:21.916]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.916]                         if (muffled) 
[18:04:21.916]                           invokeRestart("muffleWarning")
[18:04:21.916]                       }
[18:04:21.916]                       else if (inherits(cond, "condition")) {
[18:04:21.916]                         if (!is.null(pattern)) {
[18:04:21.916]                           computeRestarts <- base::computeRestarts
[18:04:21.916]                           grepl <- base::grepl
[18:04:21.916]                           restarts <- computeRestarts(cond)
[18:04:21.916]                           for (restart in restarts) {
[18:04:21.916]                             name <- restart$name
[18:04:21.916]                             if (is.null(name)) 
[18:04:21.916]                               next
[18:04:21.916]                             if (!grepl(pattern, name)) 
[18:04:21.916]                               next
[18:04:21.916]                             invokeRestart(restart)
[18:04:21.916]                             muffled <- TRUE
[18:04:21.916]                             break
[18:04:21.916]                           }
[18:04:21.916]                         }
[18:04:21.916]                       }
[18:04:21.916]                       invisible(muffled)
[18:04:21.916]                     }
[18:04:21.916]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.916]                   }
[18:04:21.916]                 }
[18:04:21.916]             }
[18:04:21.916]         }))
[18:04:21.916]     }, error = function(ex) {
[18:04:21.916]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.916]                 ...future.rng), started = ...future.startTime, 
[18:04:21.916]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.916]             version = "1.8"), class = "FutureResult")
[18:04:21.916]     }, finally = {
[18:04:21.916]         if (!identical(...future.workdir, getwd())) 
[18:04:21.916]             setwd(...future.workdir)
[18:04:21.916]         {
[18:04:21.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.916]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.916]             }
[18:04:21.916]             base::options(...future.oldOptions)
[18:04:21.916]             if (.Platform$OS.type == "windows") {
[18:04:21.916]                 old_names <- names(...future.oldEnvVars)
[18:04:21.916]                 envs <- base::Sys.getenv()
[18:04:21.916]                 names <- names(envs)
[18:04:21.916]                 common <- intersect(names, old_names)
[18:04:21.916]                 added <- setdiff(names, old_names)
[18:04:21.916]                 removed <- setdiff(old_names, names)
[18:04:21.916]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.916]                   envs[common]]
[18:04:21.916]                 NAMES <- toupper(changed)
[18:04:21.916]                 args <- list()
[18:04:21.916]                 for (kk in seq_along(NAMES)) {
[18:04:21.916]                   name <- changed[[kk]]
[18:04:21.916]                   NAME <- NAMES[[kk]]
[18:04:21.916]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.916]                     next
[18:04:21.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.916]                 }
[18:04:21.916]                 NAMES <- toupper(added)
[18:04:21.916]                 for (kk in seq_along(NAMES)) {
[18:04:21.916]                   name <- added[[kk]]
[18:04:21.916]                   NAME <- NAMES[[kk]]
[18:04:21.916]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.916]                     next
[18:04:21.916]                   args[[name]] <- ""
[18:04:21.916]                 }
[18:04:21.916]                 NAMES <- toupper(removed)
[18:04:21.916]                 for (kk in seq_along(NAMES)) {
[18:04:21.916]                   name <- removed[[kk]]
[18:04:21.916]                   NAME <- NAMES[[kk]]
[18:04:21.916]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.916]                     next
[18:04:21.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.916]                 }
[18:04:21.916]                 if (length(args) > 0) 
[18:04:21.916]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.916]             }
[18:04:21.916]             else {
[18:04:21.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.916]             }
[18:04:21.916]             {
[18:04:21.916]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.916]                   0L) {
[18:04:21.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.916]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.916]                   base::options(opts)
[18:04:21.916]                 }
[18:04:21.916]                 {
[18:04:21.916]                   {
[18:04:21.916]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.916]                     NULL
[18:04:21.916]                   }
[18:04:21.916]                   options(future.plan = NULL)
[18:04:21.916]                   if (is.na(NA_character_)) 
[18:04:21.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.916]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.916]                     .init = FALSE)
[18:04:21.916]                 }
[18:04:21.916]             }
[18:04:21.916]         }
[18:04:21.916]     })
[18:04:21.916]     if (TRUE) {
[18:04:21.916]         base::sink(type = "output", split = FALSE)
[18:04:21.916]         if (TRUE) {
[18:04:21.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.916]         }
[18:04:21.916]         else {
[18:04:21.916]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.916]         }
[18:04:21.916]         base::close(...future.stdout)
[18:04:21.916]         ...future.stdout <- NULL
[18:04:21.916]     }
[18:04:21.916]     ...future.result$conditions <- ...future.conditions
[18:04:21.916]     ...future.result$finished <- base::Sys.time()
[18:04:21.916]     ...future.result
[18:04:21.916] }
[18:04:21.923] requestCore(): workers = 2
[18:04:21.928] MulticoreFuture started
[18:04:21.929] - Launch lazy future ... done
[18:04:21.929] run() for ‘MulticoreFuture’ ... done
[18:04:21.930] plan(): Setting new future strategy stack:
[18:04:21.931] getGlobalsAndPackages() ...
[18:04:21.931] Searching for globals...
[18:04:21.931] List of future strategies:
[18:04:21.931] 1. sequential:
[18:04:21.931]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:21.931]    - tweaked: FALSE
[18:04:21.931]    - call: NULL
[18:04:21.933] plan(): nbrOfWorkers() = 1
[18:04:21.934] - globals found: [1] ‘{’
[18:04:21.935] Searching for globals ... DONE
[18:04:21.935] Resolving globals: FALSE
[18:04:21.936] 
[18:04:21.937] 
[18:04:21.937] getGlobalsAndPackages() ... DONE
[18:04:21.938] run() for ‘Future’ ...
[18:04:21.939] - state: ‘created’
[18:04:21.939] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:21.941] plan(): Setting new future strategy stack:
[18:04:21.943] List of future strategies:
[18:04:21.943] 1. multicore:
[18:04:21.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:21.943]    - tweaked: FALSE
[18:04:21.943]    - call: plan(strategy)
[18:04:21.949] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:21.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:21.950]   - Field: ‘label’
[18:04:21.951]   - Field: ‘local’
[18:04:21.952]   - Field: ‘owner’
[18:04:21.952]   - Field: ‘envir’
[18:04:21.952]   - Field: ‘workers’
[18:04:21.953]   - Field: ‘packages’
[18:04:21.956]   - Field: ‘gc’
[18:04:21.957]   - Field: ‘job’
[18:04:21.957]   - Field: ‘conditions’
[18:04:21.957]   - Field: ‘expr’
[18:04:21.958]   - Field: ‘uuid’
[18:04:21.959]   - Field: ‘seed’
[18:04:21.959]   - Field: ‘version’
[18:04:21.960]   - Field: ‘result’
[18:04:21.960]   - Field: ‘asynchronous’
[18:04:21.961] plan(): nbrOfWorkers() = 2
[18:04:21.961]   - Field: ‘calls’
[18:04:21.962]   - Field: ‘globals’
[18:04:21.963]   - Field: ‘stdout’
[18:04:21.963]   - Field: ‘earlySignal’
[18:04:21.964]   - Field: ‘lazy’
[18:04:21.964]   - Field: ‘state’
[18:04:21.964] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:21.965] - Launch lazy future ...
[18:04:21.966] Packages needed by the future expression (n = 0): <none>
[18:04:21.966] Packages needed by future strategies (n = 0): <none>
[18:04:21.968] {
[18:04:21.968]     {
[18:04:21.968]         {
[18:04:21.968]             ...future.startTime <- base::Sys.time()
[18:04:21.968]             {
[18:04:21.968]                 {
[18:04:21.968]                   {
[18:04:21.968]                     {
[18:04:21.968]                       base::local({
[18:04:21.968]                         has_future <- base::requireNamespace("future", 
[18:04:21.968]                           quietly = TRUE)
[18:04:21.968]                         if (has_future) {
[18:04:21.968]                           ns <- base::getNamespace("future")
[18:04:21.968]                           version <- ns[[".package"]][["version"]]
[18:04:21.968]                           if (is.null(version)) 
[18:04:21.968]                             version <- utils::packageVersion("future")
[18:04:21.968]                         }
[18:04:21.968]                         else {
[18:04:21.968]                           version <- NULL
[18:04:21.968]                         }
[18:04:21.968]                         if (!has_future || version < "1.8.0") {
[18:04:21.968]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:21.968]                             "", base::R.version$version.string), 
[18:04:21.968]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:21.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:21.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:21.968]                               "release", "version")], collapse = " "), 
[18:04:21.968]                             hostname = base::Sys.info()[["nodename"]])
[18:04:21.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:21.968]                             info)
[18:04:21.968]                           info <- base::paste(info, collapse = "; ")
[18:04:21.968]                           if (!has_future) {
[18:04:21.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:21.968]                               info)
[18:04:21.968]                           }
[18:04:21.968]                           else {
[18:04:21.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:21.968]                               info, version)
[18:04:21.968]                           }
[18:04:21.968]                           base::stop(msg)
[18:04:21.968]                         }
[18:04:21.968]                       })
[18:04:21.968]                     }
[18:04:21.968]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:21.968]                     base::options(mc.cores = 1L)
[18:04:21.968]                   }
[18:04:21.968]                   ...future.strategy.old <- future::plan("list")
[18:04:21.968]                   options(future.plan = NULL)
[18:04:21.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:21.968]                 }
[18:04:21.968]                 ...future.workdir <- getwd()
[18:04:21.968]             }
[18:04:21.968]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:21.968]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:21.968]         }
[18:04:21.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:21.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:21.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:21.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:21.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:21.968]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:21.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:21.968]             base::names(...future.oldOptions))
[18:04:21.968]     }
[18:04:21.968]     if (FALSE) {
[18:04:21.968]     }
[18:04:21.968]     else {
[18:04:21.968]         if (TRUE) {
[18:04:21.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:21.968]                 open = "w")
[18:04:21.968]         }
[18:04:21.968]         else {
[18:04:21.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:21.968]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:21.968]         }
[18:04:21.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:21.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:21.968]             base::sink(type = "output", split = FALSE)
[18:04:21.968]             base::close(...future.stdout)
[18:04:21.968]         }, add = TRUE)
[18:04:21.968]     }
[18:04:21.968]     ...future.frame <- base::sys.nframe()
[18:04:21.968]     ...future.conditions <- base::list()
[18:04:21.968]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:21.968]     if (FALSE) {
[18:04:21.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:21.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:21.968]     }
[18:04:21.968]     ...future.result <- base::tryCatch({
[18:04:21.968]         base::withCallingHandlers({
[18:04:21.968]             ...future.value <- base::withVisible(base::local({
[18:04:21.968]                 withCallingHandlers({
[18:04:21.968]                   {
[18:04:21.968]                     4
[18:04:21.968]                   }
[18:04:21.968]                 }, immediateCondition = function(cond) {
[18:04:21.968]                   save_rds <- function (object, pathname, ...) 
[18:04:21.968]                   {
[18:04:21.968]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:21.968]                     if (file_test("-f", pathname_tmp)) {
[18:04:21.968]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.968]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:21.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.968]                         fi_tmp[["mtime"]])
[18:04:21.968]                     }
[18:04:21.968]                     tryCatch({
[18:04:21.968]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:21.968]                     }, error = function(ex) {
[18:04:21.968]                       msg <- conditionMessage(ex)
[18:04:21.968]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.968]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:21.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.968]                         fi_tmp[["mtime"]], msg)
[18:04:21.968]                       ex$message <- msg
[18:04:21.968]                       stop(ex)
[18:04:21.968]                     })
[18:04:21.968]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:21.968]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:21.968]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:21.968]                       fi_tmp <- file.info(pathname_tmp)
[18:04:21.968]                       fi <- file.info(pathname)
[18:04:21.968]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:21.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:21.968]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:21.968]                         fi[["size"]], fi[["mtime"]])
[18:04:21.968]                       stop(msg)
[18:04:21.968]                     }
[18:04:21.968]                     invisible(pathname)
[18:04:21.968]                   }
[18:04:21.968]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:21.968]                     rootPath = tempdir()) 
[18:04:21.968]                   {
[18:04:21.968]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:21.968]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:21.968]                       tmpdir = path, fileext = ".rds")
[18:04:21.968]                     save_rds(obj, file)
[18:04:21.968]                   }
[18:04:21.968]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:21.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.968]                   {
[18:04:21.968]                     inherits <- base::inherits
[18:04:21.968]                     invokeRestart <- base::invokeRestart
[18:04:21.968]                     is.null <- base::is.null
[18:04:21.968]                     muffled <- FALSE
[18:04:21.968]                     if (inherits(cond, "message")) {
[18:04:21.968]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:21.968]                       if (muffled) 
[18:04:21.968]                         invokeRestart("muffleMessage")
[18:04:21.968]                     }
[18:04:21.968]                     else if (inherits(cond, "warning")) {
[18:04:21.968]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:21.968]                       if (muffled) 
[18:04:21.968]                         invokeRestart("muffleWarning")
[18:04:21.968]                     }
[18:04:21.968]                     else if (inherits(cond, "condition")) {
[18:04:21.968]                       if (!is.null(pattern)) {
[18:04:21.968]                         computeRestarts <- base::computeRestarts
[18:04:21.968]                         grepl <- base::grepl
[18:04:21.968]                         restarts <- computeRestarts(cond)
[18:04:21.968]                         for (restart in restarts) {
[18:04:21.968]                           name <- restart$name
[18:04:21.968]                           if (is.null(name)) 
[18:04:21.968]                             next
[18:04:21.968]                           if (!grepl(pattern, name)) 
[18:04:21.968]                             next
[18:04:21.968]                           invokeRestart(restart)
[18:04:21.968]                           muffled <- TRUE
[18:04:21.968]                           break
[18:04:21.968]                         }
[18:04:21.968]                       }
[18:04:21.968]                     }
[18:04:21.968]                     invisible(muffled)
[18:04:21.968]                   }
[18:04:21.968]                   muffleCondition(cond)
[18:04:21.968]                 })
[18:04:21.968]             }))
[18:04:21.968]             future::FutureResult(value = ...future.value$value, 
[18:04:21.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.968]                   ...future.rng), globalenv = if (FALSE) 
[18:04:21.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:21.968]                     ...future.globalenv.names))
[18:04:21.968]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:21.968]         }, condition = base::local({
[18:04:21.968]             c <- base::c
[18:04:21.968]             inherits <- base::inherits
[18:04:21.968]             invokeRestart <- base::invokeRestart
[18:04:21.968]             length <- base::length
[18:04:21.968]             list <- base::list
[18:04:21.968]             seq.int <- base::seq.int
[18:04:21.968]             signalCondition <- base::signalCondition
[18:04:21.968]             sys.calls <- base::sys.calls
[18:04:21.968]             `[[` <- base::`[[`
[18:04:21.968]             `+` <- base::`+`
[18:04:21.968]             `<<-` <- base::`<<-`
[18:04:21.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:21.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:21.968]                   3L)]
[18:04:21.968]             }
[18:04:21.968]             function(cond) {
[18:04:21.968]                 is_error <- inherits(cond, "error")
[18:04:21.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:21.968]                   NULL)
[18:04:21.968]                 if (is_error) {
[18:04:21.968]                   sessionInformation <- function() {
[18:04:21.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:21.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:21.968]                       search = base::search(), system = base::Sys.info())
[18:04:21.968]                   }
[18:04:21.968]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:21.968]                     cond$call), session = sessionInformation(), 
[18:04:21.968]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:21.968]                   signalCondition(cond)
[18:04:21.968]                 }
[18:04:21.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:21.968]                 "immediateCondition"))) {
[18:04:21.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:21.968]                   ...future.conditions[[length(...future.conditions) + 
[18:04:21.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:21.968]                   if (TRUE && !signal) {
[18:04:21.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.968]                     {
[18:04:21.968]                       inherits <- base::inherits
[18:04:21.968]                       invokeRestart <- base::invokeRestart
[18:04:21.968]                       is.null <- base::is.null
[18:04:21.968]                       muffled <- FALSE
[18:04:21.968]                       if (inherits(cond, "message")) {
[18:04:21.968]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.968]                         if (muffled) 
[18:04:21.968]                           invokeRestart("muffleMessage")
[18:04:21.968]                       }
[18:04:21.968]                       else if (inherits(cond, "warning")) {
[18:04:21.968]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.968]                         if (muffled) 
[18:04:21.968]                           invokeRestart("muffleWarning")
[18:04:21.968]                       }
[18:04:21.968]                       else if (inherits(cond, "condition")) {
[18:04:21.968]                         if (!is.null(pattern)) {
[18:04:21.968]                           computeRestarts <- base::computeRestarts
[18:04:21.968]                           grepl <- base::grepl
[18:04:21.968]                           restarts <- computeRestarts(cond)
[18:04:21.968]                           for (restart in restarts) {
[18:04:21.968]                             name <- restart$name
[18:04:21.968]                             if (is.null(name)) 
[18:04:21.968]                               next
[18:04:21.968]                             if (!grepl(pattern, name)) 
[18:04:21.968]                               next
[18:04:21.968]                             invokeRestart(restart)
[18:04:21.968]                             muffled <- TRUE
[18:04:21.968]                             break
[18:04:21.968]                           }
[18:04:21.968]                         }
[18:04:21.968]                       }
[18:04:21.968]                       invisible(muffled)
[18:04:21.968]                     }
[18:04:21.968]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.968]                   }
[18:04:21.968]                 }
[18:04:21.968]                 else {
[18:04:21.968]                   if (TRUE) {
[18:04:21.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:21.968]                     {
[18:04:21.968]                       inherits <- base::inherits
[18:04:21.968]                       invokeRestart <- base::invokeRestart
[18:04:21.968]                       is.null <- base::is.null
[18:04:21.968]                       muffled <- FALSE
[18:04:21.968]                       if (inherits(cond, "message")) {
[18:04:21.968]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:21.968]                         if (muffled) 
[18:04:21.968]                           invokeRestart("muffleMessage")
[18:04:21.968]                       }
[18:04:21.968]                       else if (inherits(cond, "warning")) {
[18:04:21.968]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:21.968]                         if (muffled) 
[18:04:21.968]                           invokeRestart("muffleWarning")
[18:04:21.968]                       }
[18:04:21.968]                       else if (inherits(cond, "condition")) {
[18:04:21.968]                         if (!is.null(pattern)) {
[18:04:21.968]                           computeRestarts <- base::computeRestarts
[18:04:21.968]                           grepl <- base::grepl
[18:04:21.968]                           restarts <- computeRestarts(cond)
[18:04:21.968]                           for (restart in restarts) {
[18:04:21.968]                             name <- restart$name
[18:04:21.968]                             if (is.null(name)) 
[18:04:21.968]                               next
[18:04:21.968]                             if (!grepl(pattern, name)) 
[18:04:21.968]                               next
[18:04:21.968]                             invokeRestart(restart)
[18:04:21.968]                             muffled <- TRUE
[18:04:21.968]                             break
[18:04:21.968]                           }
[18:04:21.968]                         }
[18:04:21.968]                       }
[18:04:21.968]                       invisible(muffled)
[18:04:21.968]                     }
[18:04:21.968]                     muffleCondition(cond, pattern = "^muffle")
[18:04:21.968]                   }
[18:04:21.968]                 }
[18:04:21.968]             }
[18:04:21.968]         }))
[18:04:21.968]     }, error = function(ex) {
[18:04:21.968]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:21.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:21.968]                 ...future.rng), started = ...future.startTime, 
[18:04:21.968]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:21.968]             version = "1.8"), class = "FutureResult")
[18:04:21.968]     }, finally = {
[18:04:21.968]         if (!identical(...future.workdir, getwd())) 
[18:04:21.968]             setwd(...future.workdir)
[18:04:21.968]         {
[18:04:21.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:21.968]                 ...future.oldOptions$nwarnings <- NULL
[18:04:21.968]             }
[18:04:21.968]             base::options(...future.oldOptions)
[18:04:21.968]             if (.Platform$OS.type == "windows") {
[18:04:21.968]                 old_names <- names(...future.oldEnvVars)
[18:04:21.968]                 envs <- base::Sys.getenv()
[18:04:21.968]                 names <- names(envs)
[18:04:21.968]                 common <- intersect(names, old_names)
[18:04:21.968]                 added <- setdiff(names, old_names)
[18:04:21.968]                 removed <- setdiff(old_names, names)
[18:04:21.968]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:21.968]                   envs[common]]
[18:04:21.968]                 NAMES <- toupper(changed)
[18:04:21.968]                 args <- list()
[18:04:21.968]                 for (kk in seq_along(NAMES)) {
[18:04:21.968]                   name <- changed[[kk]]
[18:04:21.968]                   NAME <- NAMES[[kk]]
[18:04:21.968]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.968]                     next
[18:04:21.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.968]                 }
[18:04:21.968]                 NAMES <- toupper(added)
[18:04:21.968]                 for (kk in seq_along(NAMES)) {
[18:04:21.968]                   name <- added[[kk]]
[18:04:21.968]                   NAME <- NAMES[[kk]]
[18:04:21.968]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.968]                     next
[18:04:21.968]                   args[[name]] <- ""
[18:04:21.968]                 }
[18:04:21.968]                 NAMES <- toupper(removed)
[18:04:21.968]                 for (kk in seq_along(NAMES)) {
[18:04:21.968]                   name <- removed[[kk]]
[18:04:21.968]                   NAME <- NAMES[[kk]]
[18:04:21.968]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:21.968]                     next
[18:04:21.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:21.968]                 }
[18:04:21.968]                 if (length(args) > 0) 
[18:04:21.968]                   base::do.call(base::Sys.setenv, args = args)
[18:04:21.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:21.968]             }
[18:04:21.968]             else {
[18:04:21.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:21.968]             }
[18:04:21.968]             {
[18:04:21.968]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:21.968]                   0L) {
[18:04:21.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:21.968]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:21.968]                   base::options(opts)
[18:04:21.968]                 }
[18:04:21.968]                 {
[18:04:21.968]                   {
[18:04:21.968]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:21.968]                     NULL
[18:04:21.968]                   }
[18:04:21.968]                   options(future.plan = NULL)
[18:04:21.968]                   if (is.na(NA_character_)) 
[18:04:21.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:21.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:21.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:21.968]                     .init = FALSE)
[18:04:21.968]                 }
[18:04:21.968]             }
[18:04:21.968]         }
[18:04:21.968]     })
[18:04:21.968]     if (TRUE) {
[18:04:21.968]         base::sink(type = "output", split = FALSE)
[18:04:21.968]         if (TRUE) {
[18:04:21.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:21.968]         }
[18:04:21.968]         else {
[18:04:21.968]             ...future.result["stdout"] <- base::list(NULL)
[18:04:21.968]         }
[18:04:21.968]         base::close(...future.stdout)
[18:04:21.968]         ...future.stdout <- NULL
[18:04:21.968]     }
[18:04:21.968]     ...future.result$conditions <- ...future.conditions
[18:04:21.968]     ...future.result$finished <- base::Sys.time()
[18:04:21.968]     ...future.result
[18:04:21.968] }
[18:04:21.975] requestCore(): workers = 2
[18:04:21.976] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:21.987] result() for MulticoreFuture ...
[18:04:21.989] result() for MulticoreFuture ...
[18:04:21.990] result() for MulticoreFuture ... done
[18:04:21.990] result() for MulticoreFuture ... done
[18:04:21.990] result() for MulticoreFuture ...
[18:04:21.991] result() for MulticoreFuture ... done
[18:04:21.996] MulticoreFuture started
[18:04:21.996] - Launch lazy future ... done
[18:04:21.997] run() for ‘MulticoreFuture’ ... done
[18:04:21.998] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5e3c2d3c0628> 
[18:04:21.998] List of future strategies:
[18:04:21.998] 1. sequential:
[18:04:21.998]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:21.998]    - tweaked: FALSE
[18:04:21.998]    - call: NULL
[18:04:22.001] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5e3c2a572e00> 
 - attr(*, "dim.")=[18:04:22.005] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
[18:04:22.005] List of future strategies:
[18:04:22.005] 1. multicore:
[18:04:22.005]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:22.005]    - tweaked: FALSE
[18:04:22.005]    - call: plan(strategy)
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[18:04:22.015] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:22.025] resolve() on list environment ...
[18:04:22.025]  recursive: 0
[18:04:22.028]  length: 6
[18:04:22.029]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:22.029] signalConditionsASAP(numeric, pos=1) ...
[18:04:22.029] - nx: 6
[18:04:22.030] - relay: TRUE
[18:04:22.030] - stdout: TRUE
[18:04:22.030] - signal: TRUE
[18:04:22.030] - resignal: FALSE
[18:04:22.031] - force: TRUE
[18:04:22.031] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.031] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.032]  - until=2
[18:04:22.032]  - relaying element #2
[18:04:22.032] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.033] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.033] signalConditionsASAP(NULL, pos=1) ... done
[18:04:22.033]  length: 5 (resolved future 1)
[18:04:22.034] Future #2
[18:04:22.034] result() for MulticoreFuture ...
[18:04:22.034] result() for MulticoreFuture ... done
[18:04:22.035] result() for MulticoreFuture ...
[18:04:22.035] result() for MulticoreFuture ... done
[18:04:22.035] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:22.036] - nx: 6
[18:04:22.036] - relay: TRUE
[18:04:22.036] - stdout: TRUE
[18:04:22.036] - signal: TRUE
[18:04:22.037] - resignal: FALSE
[18:04:22.037] - force: TRUE
[18:04:22.037] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.037] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.038]  - until=2
[18:04:22.038]  - relaying element #2
[18:04:22.038] result() for MulticoreFuture ...
[18:04:22.039] result() for MulticoreFuture ... done
[18:04:22.039] result() for MulticoreFuture ...
[18:04:22.039] result() for MulticoreFuture ... done
[18:04:22.040] result() for MulticoreFuture ...
[18:04:22.040] result() for MulticoreFuture ... done
[18:04:22.040] result() for MulticoreFuture ...
[18:04:22.041] result() for MulticoreFuture ... done
[18:04:22.041] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.041] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.041] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:22.042]  length: 4 (resolved future 2)
[18:04:22.043] Future #3
[18:04:22.043] result() for MulticoreFuture ...
[18:04:22.045] result() for MulticoreFuture ...
[18:04:22.046] result() for MulticoreFuture ... done
[18:04:22.046] result() for MulticoreFuture ... done
[18:04:22.047] result() for MulticoreFuture ...
[18:04:22.047] result() for MulticoreFuture ... done
[18:04:22.047] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:22.048] - nx: 6
[18:04:22.048] - relay: TRUE
[18:04:22.048] - stdout: TRUE
[18:04:22.048] - signal: TRUE
[18:04:22.049] - resignal: FALSE
[18:04:22.049] - force: TRUE
[18:04:22.049] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.049] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.050]  - until=3
[18:04:22.050]  - relaying element #3
[18:04:22.050] result() for MulticoreFuture ...
[18:04:22.051] result() for MulticoreFuture ... done
[18:04:22.051] result() for MulticoreFuture ...
[18:04:22.051] result() for MulticoreFuture ... done
[18:04:22.052] result() for MulticoreFuture ...
[18:04:22.052] result() for MulticoreFuture ... done
[18:04:22.052] result() for MulticoreFuture ...
[18:04:22.052] result() for MulticoreFuture ... done
[18:04:22.053] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.053] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.053] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:22.054]  length: 3 (resolved future 3)
[18:04:22.054] Future #4
[18:04:22.055] result() for MulticoreFuture ...
[18:04:22.056] result() for MulticoreFuture ...
[18:04:22.056] result() for MulticoreFuture ... done
[18:04:22.057] result() for MulticoreFuture ... done
[18:04:22.057] result() for MulticoreFuture ...
[18:04:22.057] result() for MulticoreFuture ... done
[18:04:22.058] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:22.058] - nx: 6
[18:04:22.058] - relay: TRUE
[18:04:22.058] - stdout: TRUE
[18:04:22.059] - signal: TRUE
[18:04:22.059] - resignal: FALSE
[18:04:22.059] - force: TRUE
[18:04:22.059] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.059] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.060]  - until=4
[18:04:22.060]  - relaying element #4
[18:04:22.060] result() for MulticoreFuture ...
[18:04:22.060] result() for MulticoreFuture ... done
[18:04:22.061] result() for MulticoreFuture ...
[18:04:22.061] result() for MulticoreFuture ... done
[18:04:22.061] result() for MulticoreFuture ...
[18:04:22.061] result() for MulticoreFuture ... done
[18:04:22.062] result() for MulticoreFuture ...
[18:04:22.062] result() for MulticoreFuture ... done
[18:04:22.062] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.062] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.062] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:22.063]  length: 2 (resolved future 4)
[18:04:22.063] signalConditionsASAP(NULL, pos=5) ...
[18:04:22.063] - nx: 6
[18:04:22.063] - relay: TRUE
[18:04:22.064] - stdout: TRUE
[18:04:22.064] - signal: TRUE
[18:04:22.064] - resignal: FALSE
[18:04:22.064] - force: TRUE
[18:04:22.064] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.065] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.065]  - until=6
[18:04:22.065]  - relaying element #6
[18:04:22.065] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:22.065] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.066] signalConditionsASAP(NULL, pos=5) ... done
[18:04:22.066]  length: 1 (resolved future 5)
[18:04:22.066] signalConditionsASAP(numeric, pos=6) ...
[18:04:22.066] - nx: 6
[18:04:22.067] - relay: TRUE
[18:04:22.067] - stdout: TRUE
[18:04:22.067] - signal: TRUE
[18:04:22.067] - resignal: FALSE
[18:04:22.067] - force: TRUE
[18:04:22.068] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:22.068] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.068]  - until=6
[18:04:22.068] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:22.068] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.069] signalConditionsASAP(numeric, pos=6) ... done
[18:04:22.069]  length: 0 (resolved future 6)
[18:04:22.069] Relaying remaining futures
[18:04:22.069] signalConditionsASAP(NULL, pos=0) ...
[18:04:22.069] - nx: 6
[18:04:22.070] - relay: TRUE
[18:04:22.070] - stdout: TRUE
[18:04:22.070] - signal: TRUE
[18:04:22.070] - resignal: FALSE
[18:04:22.070] - force: TRUE
[18:04:22.071] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:22.071] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:22.072] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:22.072] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.072] signalConditionsASAP(NULL, pos=0) ... done
[18:04:22.072] resolve() on list environment ... DONE
[18:04:22.073] result() for MulticoreFuture ...
[18:04:22.073] result() for MulticoreFuture ... done
[18:04:22.073] result() for MulticoreFuture ...
[18:04:22.073] result() for MulticoreFuture ... done
[18:04:22.074] result() for MulticoreFuture ...
[18:04:22.074] result() for MulticoreFuture ... done
[18:04:22.074] result() for MulticoreFuture ...
[18:04:22.074] result() for MulticoreFuture ... done
[18:04:22.075] result() for MulticoreFuture ...
[18:04:22.075] result() for MulticoreFuture ... done
[18:04:22.075] result() for MulticoreFuture ...
[18:04:22.075] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2b9a25e0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[18:04:22.079] getGlobalsAndPackages() ...
[18:04:22.079] Searching for globals...
[18:04:22.080] 
[18:04:22.080] Searching for globals ... DONE
[18:04:22.081] - globals: [0] <none>
[18:04:22.081] getGlobalsAndPackages() ... DONE
[18:04:22.081] run() for ‘Future’ ...
[18:04:22.082] - state: ‘created’
[18:04:22.082] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:22.089] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:22.090] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:22.090]   - Field: ‘label’
[18:04:22.090]   - Field: ‘local’
[18:04:22.090]   - Field: ‘owner’
[18:04:22.091]   - Field: ‘envir’
[18:04:22.091]   - Field: ‘workers’
[18:04:22.091]   - Field: ‘packages’
[18:04:22.091]   - Field: ‘gc’
[18:04:22.092]   - Field: ‘job’
[18:04:22.092]   - Field: ‘conditions’
[18:04:22.092]   - Field: ‘expr’
[18:04:22.092]   - Field: ‘uuid’
[18:04:22.093]   - Field: ‘seed’
[18:04:22.093]   - Field: ‘version’
[18:04:22.093]   - Field: ‘result’
[18:04:22.093]   - Field: ‘asynchronous’
[18:04:22.093]   - Field: ‘calls’
[18:04:22.094]   - Field: ‘globals’
[18:04:22.094]   - Field: ‘stdout’
[18:04:22.094]   - Field: ‘earlySignal’
[18:04:22.094]   - Field: ‘lazy’
[18:04:22.095]   - Field: ‘state’
[18:04:22.095] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:22.095] - Launch lazy future ...
[18:04:22.096] Packages needed by the future expression (n = 0): <none>
[18:04:22.096] Packages needed by future strategies (n = 0): <none>
[18:04:22.097] {
[18:04:22.097]     {
[18:04:22.097]         {
[18:04:22.097]             ...future.startTime <- base::Sys.time()
[18:04:22.097]             {
[18:04:22.097]                 {
[18:04:22.097]                   {
[18:04:22.097]                     {
[18:04:22.097]                       base::local({
[18:04:22.097]                         has_future <- base::requireNamespace("future", 
[18:04:22.097]                           quietly = TRUE)
[18:04:22.097]                         if (has_future) {
[18:04:22.097]                           ns <- base::getNamespace("future")
[18:04:22.097]                           version <- ns[[".package"]][["version"]]
[18:04:22.097]                           if (is.null(version)) 
[18:04:22.097]                             version <- utils::packageVersion("future")
[18:04:22.097]                         }
[18:04:22.097]                         else {
[18:04:22.097]                           version <- NULL
[18:04:22.097]                         }
[18:04:22.097]                         if (!has_future || version < "1.8.0") {
[18:04:22.097]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:22.097]                             "", base::R.version$version.string), 
[18:04:22.097]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:22.097]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:22.097]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:22.097]                               "release", "version")], collapse = " "), 
[18:04:22.097]                             hostname = base::Sys.info()[["nodename"]])
[18:04:22.097]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:22.097]                             info)
[18:04:22.097]                           info <- base::paste(info, collapse = "; ")
[18:04:22.097]                           if (!has_future) {
[18:04:22.097]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:22.097]                               info)
[18:04:22.097]                           }
[18:04:22.097]                           else {
[18:04:22.097]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:22.097]                               info, version)
[18:04:22.097]                           }
[18:04:22.097]                           base::stop(msg)
[18:04:22.097]                         }
[18:04:22.097]                       })
[18:04:22.097]                     }
[18:04:22.097]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:22.097]                     base::options(mc.cores = 1L)
[18:04:22.097]                   }
[18:04:22.097]                   ...future.strategy.old <- future::plan("list")
[18:04:22.097]                   options(future.plan = NULL)
[18:04:22.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:22.097]                 }
[18:04:22.097]                 ...future.workdir <- getwd()
[18:04:22.097]             }
[18:04:22.097]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:22.097]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:22.097]         }
[18:04:22.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:22.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:22.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:22.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:22.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:22.097]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:22.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:22.097]             base::names(...future.oldOptions))
[18:04:22.097]     }
[18:04:22.097]     if (FALSE) {
[18:04:22.097]     }
[18:04:22.097]     else {
[18:04:22.097]         if (TRUE) {
[18:04:22.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:22.097]                 open = "w")
[18:04:22.097]         }
[18:04:22.097]         else {
[18:04:22.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:22.097]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:22.097]         }
[18:04:22.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:22.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:22.097]             base::sink(type = "output", split = FALSE)
[18:04:22.097]             base::close(...future.stdout)
[18:04:22.097]         }, add = TRUE)
[18:04:22.097]     }
[18:04:22.097]     ...future.frame <- base::sys.nframe()
[18:04:22.097]     ...future.conditions <- base::list()
[18:04:22.097]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:22.097]     if (FALSE) {
[18:04:22.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:22.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:22.097]     }
[18:04:22.097]     ...future.result <- base::tryCatch({
[18:04:22.097]         base::withCallingHandlers({
[18:04:22.097]             ...future.value <- base::withVisible(base::local({
[18:04:22.097]                 withCallingHandlers({
[18:04:22.097]                   2
[18:04:22.097]                 }, immediateCondition = function(cond) {
[18:04:22.097]                   save_rds <- function (object, pathname, ...) 
[18:04:22.097]                   {
[18:04:22.097]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:22.097]                     if (file_test("-f", pathname_tmp)) {
[18:04:22.097]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.097]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:22.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.097]                         fi_tmp[["mtime"]])
[18:04:22.097]                     }
[18:04:22.097]                     tryCatch({
[18:04:22.097]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:22.097]                     }, error = function(ex) {
[18:04:22.097]                       msg <- conditionMessage(ex)
[18:04:22.097]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.097]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:22.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.097]                         fi_tmp[["mtime"]], msg)
[18:04:22.097]                       ex$message <- msg
[18:04:22.097]                       stop(ex)
[18:04:22.097]                     })
[18:04:22.097]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:22.097]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:22.097]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:22.097]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.097]                       fi <- file.info(pathname)
[18:04:22.097]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:22.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.097]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:22.097]                         fi[["size"]], fi[["mtime"]])
[18:04:22.097]                       stop(msg)
[18:04:22.097]                     }
[18:04:22.097]                     invisible(pathname)
[18:04:22.097]                   }
[18:04:22.097]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:22.097]                     rootPath = tempdir()) 
[18:04:22.097]                   {
[18:04:22.097]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:22.097]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:22.097]                       tmpdir = path, fileext = ".rds")
[18:04:22.097]                     save_rds(obj, file)
[18:04:22.097]                   }
[18:04:22.097]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:22.097]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.097]                   {
[18:04:22.097]                     inherits <- base::inherits
[18:04:22.097]                     invokeRestart <- base::invokeRestart
[18:04:22.097]                     is.null <- base::is.null
[18:04:22.097]                     muffled <- FALSE
[18:04:22.097]                     if (inherits(cond, "message")) {
[18:04:22.097]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:22.097]                       if (muffled) 
[18:04:22.097]                         invokeRestart("muffleMessage")
[18:04:22.097]                     }
[18:04:22.097]                     else if (inherits(cond, "warning")) {
[18:04:22.097]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:22.097]                       if (muffled) 
[18:04:22.097]                         invokeRestart("muffleWarning")
[18:04:22.097]                     }
[18:04:22.097]                     else if (inherits(cond, "condition")) {
[18:04:22.097]                       if (!is.null(pattern)) {
[18:04:22.097]                         computeRestarts <- base::computeRestarts
[18:04:22.097]                         grepl <- base::grepl
[18:04:22.097]                         restarts <- computeRestarts(cond)
[18:04:22.097]                         for (restart in restarts) {
[18:04:22.097]                           name <- restart$name
[18:04:22.097]                           if (is.null(name)) 
[18:04:22.097]                             next
[18:04:22.097]                           if (!grepl(pattern, name)) 
[18:04:22.097]                             next
[18:04:22.097]                           invokeRestart(restart)
[18:04:22.097]                           muffled <- TRUE
[18:04:22.097]                           break
[18:04:22.097]                         }
[18:04:22.097]                       }
[18:04:22.097]                     }
[18:04:22.097]                     invisible(muffled)
[18:04:22.097]                   }
[18:04:22.097]                   muffleCondition(cond)
[18:04:22.097]                 })
[18:04:22.097]             }))
[18:04:22.097]             future::FutureResult(value = ...future.value$value, 
[18:04:22.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.097]                   ...future.rng), globalenv = if (FALSE) 
[18:04:22.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:22.097]                     ...future.globalenv.names))
[18:04:22.097]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:22.097]         }, condition = base::local({
[18:04:22.097]             c <- base::c
[18:04:22.097]             inherits <- base::inherits
[18:04:22.097]             invokeRestart <- base::invokeRestart
[18:04:22.097]             length <- base::length
[18:04:22.097]             list <- base::list
[18:04:22.097]             seq.int <- base::seq.int
[18:04:22.097]             signalCondition <- base::signalCondition
[18:04:22.097]             sys.calls <- base::sys.calls
[18:04:22.097]             `[[` <- base::`[[`
[18:04:22.097]             `+` <- base::`+`
[18:04:22.097]             `<<-` <- base::`<<-`
[18:04:22.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:22.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:22.097]                   3L)]
[18:04:22.097]             }
[18:04:22.097]             function(cond) {
[18:04:22.097]                 is_error <- inherits(cond, "error")
[18:04:22.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:22.097]                   NULL)
[18:04:22.097]                 if (is_error) {
[18:04:22.097]                   sessionInformation <- function() {
[18:04:22.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:22.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:22.097]                       search = base::search(), system = base::Sys.info())
[18:04:22.097]                   }
[18:04:22.097]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:22.097]                     cond$call), session = sessionInformation(), 
[18:04:22.097]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:22.097]                   signalCondition(cond)
[18:04:22.097]                 }
[18:04:22.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:22.097]                 "immediateCondition"))) {
[18:04:22.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:22.097]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:22.097]                   if (TRUE && !signal) {
[18:04:22.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.097]                     {
[18:04:22.097]                       inherits <- base::inherits
[18:04:22.097]                       invokeRestart <- base::invokeRestart
[18:04:22.097]                       is.null <- base::is.null
[18:04:22.097]                       muffled <- FALSE
[18:04:22.097]                       if (inherits(cond, "message")) {
[18:04:22.097]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.097]                         if (muffled) 
[18:04:22.097]                           invokeRestart("muffleMessage")
[18:04:22.097]                       }
[18:04:22.097]                       else if (inherits(cond, "warning")) {
[18:04:22.097]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.097]                         if (muffled) 
[18:04:22.097]                           invokeRestart("muffleWarning")
[18:04:22.097]                       }
[18:04:22.097]                       else if (inherits(cond, "condition")) {
[18:04:22.097]                         if (!is.null(pattern)) {
[18:04:22.097]                           computeRestarts <- base::computeRestarts
[18:04:22.097]                           grepl <- base::grepl
[18:04:22.097]                           restarts <- computeRestarts(cond)
[18:04:22.097]                           for (restart in restarts) {
[18:04:22.097]                             name <- restart$name
[18:04:22.097]                             if (is.null(name)) 
[18:04:22.097]                               next
[18:04:22.097]                             if (!grepl(pattern, name)) 
[18:04:22.097]                               next
[18:04:22.097]                             invokeRestart(restart)
[18:04:22.097]                             muffled <- TRUE
[18:04:22.097]                             break
[18:04:22.097]                           }
[18:04:22.097]                         }
[18:04:22.097]                       }
[18:04:22.097]                       invisible(muffled)
[18:04:22.097]                     }
[18:04:22.097]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.097]                   }
[18:04:22.097]                 }
[18:04:22.097]                 else {
[18:04:22.097]                   if (TRUE) {
[18:04:22.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.097]                     {
[18:04:22.097]                       inherits <- base::inherits
[18:04:22.097]                       invokeRestart <- base::invokeRestart
[18:04:22.097]                       is.null <- base::is.null
[18:04:22.097]                       muffled <- FALSE
[18:04:22.097]                       if (inherits(cond, "message")) {
[18:04:22.097]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.097]                         if (muffled) 
[18:04:22.097]                           invokeRestart("muffleMessage")
[18:04:22.097]                       }
[18:04:22.097]                       else if (inherits(cond, "warning")) {
[18:04:22.097]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.097]                         if (muffled) 
[18:04:22.097]                           invokeRestart("muffleWarning")
[18:04:22.097]                       }
[18:04:22.097]                       else if (inherits(cond, "condition")) {
[18:04:22.097]                         if (!is.null(pattern)) {
[18:04:22.097]                           computeRestarts <- base::computeRestarts
[18:04:22.097]                           grepl <- base::grepl
[18:04:22.097]                           restarts <- computeRestarts(cond)
[18:04:22.097]                           for (restart in restarts) {
[18:04:22.097]                             name <- restart$name
[18:04:22.097]                             if (is.null(name)) 
[18:04:22.097]                               next
[18:04:22.097]                             if (!grepl(pattern, name)) 
[18:04:22.097]                               next
[18:04:22.097]                             invokeRestart(restart)
[18:04:22.097]                             muffled <- TRUE
[18:04:22.097]                             break
[18:04:22.097]                           }
[18:04:22.097]                         }
[18:04:22.097]                       }
[18:04:22.097]                       invisible(muffled)
[18:04:22.097]                     }
[18:04:22.097]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.097]                   }
[18:04:22.097]                 }
[18:04:22.097]             }
[18:04:22.097]         }))
[18:04:22.097]     }, error = function(ex) {
[18:04:22.097]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:22.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.097]                 ...future.rng), started = ...future.startTime, 
[18:04:22.097]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:22.097]             version = "1.8"), class = "FutureResult")
[18:04:22.097]     }, finally = {
[18:04:22.097]         if (!identical(...future.workdir, getwd())) 
[18:04:22.097]             setwd(...future.workdir)
[18:04:22.097]         {
[18:04:22.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:22.097]                 ...future.oldOptions$nwarnings <- NULL
[18:04:22.097]             }
[18:04:22.097]             base::options(...future.oldOptions)
[18:04:22.097]             if (.Platform$OS.type == "windows") {
[18:04:22.097]                 old_names <- names(...future.oldEnvVars)
[18:04:22.097]                 envs <- base::Sys.getenv()
[18:04:22.097]                 names <- names(envs)
[18:04:22.097]                 common <- intersect(names, old_names)
[18:04:22.097]                 added <- setdiff(names, old_names)
[18:04:22.097]                 removed <- setdiff(old_names, names)
[18:04:22.097]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:22.097]                   envs[common]]
[18:04:22.097]                 NAMES <- toupper(changed)
[18:04:22.097]                 args <- list()
[18:04:22.097]                 for (kk in seq_along(NAMES)) {
[18:04:22.097]                   name <- changed[[kk]]
[18:04:22.097]                   NAME <- NAMES[[kk]]
[18:04:22.097]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.097]                     next
[18:04:22.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.097]                 }
[18:04:22.097]                 NAMES <- toupper(added)
[18:04:22.097]                 for (kk in seq_along(NAMES)) {
[18:04:22.097]                   name <- added[[kk]]
[18:04:22.097]                   NAME <- NAMES[[kk]]
[18:04:22.097]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.097]                     next
[18:04:22.097]                   args[[name]] <- ""
[18:04:22.097]                 }
[18:04:22.097]                 NAMES <- toupper(removed)
[18:04:22.097]                 for (kk in seq_along(NAMES)) {
[18:04:22.097]                   name <- removed[[kk]]
[18:04:22.097]                   NAME <- NAMES[[kk]]
[18:04:22.097]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.097]                     next
[18:04:22.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.097]                 }
[18:04:22.097]                 if (length(args) > 0) 
[18:04:22.097]                   base::do.call(base::Sys.setenv, args = args)
[18:04:22.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:22.097]             }
[18:04:22.097]             else {
[18:04:22.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:22.097]             }
[18:04:22.097]             {
[18:04:22.097]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:22.097]                   0L) {
[18:04:22.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:22.097]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:22.097]                   base::options(opts)
[18:04:22.097]                 }
[18:04:22.097]                 {
[18:04:22.097]                   {
[18:04:22.097]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:22.097]                     NULL
[18:04:22.097]                   }
[18:04:22.097]                   options(future.plan = NULL)
[18:04:22.097]                   if (is.na(NA_character_)) 
[18:04:22.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:22.097]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:22.097]                     .init = FALSE)
[18:04:22.097]                 }
[18:04:22.097]             }
[18:04:22.097]         }
[18:04:22.097]     })
[18:04:22.097]     if (TRUE) {
[18:04:22.097]         base::sink(type = "output", split = FALSE)
[18:04:22.097]         if (TRUE) {
[18:04:22.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:22.097]         }
[18:04:22.097]         else {
[18:04:22.097]             ...future.result["stdout"] <- base::list(NULL)
[18:04:22.097]         }
[18:04:22.097]         base::close(...future.stdout)
[18:04:22.097]         ...future.stdout <- NULL
[18:04:22.097]     }
[18:04:22.097]     ...future.result$conditions <- ...future.conditions
[18:04:22.097]     ...future.result$finished <- base::Sys.time()
[18:04:22.097]     ...future.result
[18:04:22.097] }
[18:04:22.102] requestCore(): workers = 2
[18:04:22.106] MulticoreFuture started
[18:04:22.107] - Launch lazy future ... done
[18:04:22.107] run() for ‘MulticoreFuture’ ... done
[18:04:22.108] getGlobalsAndPackages() ...
[18:04:22.108] plan(): Setting new future strategy stack:
[18:04:22.108] Searching for globals...
[18:04:22.108] List of future strategies:
[18:04:22.108] 1. sequential:
[18:04:22.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:22.108]    - tweaked: FALSE
[18:04:22.108]    - call: NULL
[18:04:22.110] 
[18:04:22.110] Searching for globals ... DONE
[18:04:22.110] plan(): nbrOfWorkers() = 1
[18:04:22.111] - globals: [0] <none>
[18:04:22.111] getGlobalsAndPackages() ... DONE
[18:04:22.112] run() for ‘Future’ ...
[18:04:22.112] - state: ‘created’
[18:04:22.113] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:22.114] plan(): Setting new future strategy stack:
[18:04:22.114] List of future strategies:
[18:04:22.114] 1. multicore:
[18:04:22.114]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:22.114]    - tweaked: FALSE
[18:04:22.114]    - call: plan(strategy)
[18:04:22.122] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:22.123] plan(): nbrOfWorkers() = 2
[18:04:22.122] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:22.123]   - Field: ‘label’
[18:04:22.123]   - Field: ‘local’
[18:04:22.124]   - Field: ‘owner’
[18:04:22.124]   - Field: ‘envir’
[18:04:22.124]   - Field: ‘workers’
[18:04:22.124]   - Field: ‘packages’
[18:04:22.125]   - Field: ‘gc’
[18:04:22.125]   - Field: ‘job’
[18:04:22.125]   - Field: ‘conditions’
[18:04:22.126]   - Field: ‘expr’
[18:04:22.126]   - Field: ‘uuid’
[18:04:22.126]   - Field: ‘seed’
[18:04:22.126]   - Field: ‘version’
[18:04:22.127]   - Field: ‘result’
[18:04:22.127]   - Field: ‘asynchronous’
[18:04:22.127]   - Field: ‘calls’
[18:04:22.128]   - Field: ‘globals’
[18:04:22.128]   - Field: ‘stdout’
[18:04:22.128]   - Field: ‘earlySignal’
[18:04:22.129]   - Field: ‘lazy’
[18:04:22.129]   - Field: ‘state’
[18:04:22.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:22.129] - Launch lazy future ...
[18:04:22.130] Packages needed by the future expression (n = 0): <none>
[18:04:22.131] Packages needed by future strategies (n = 0): <none>
[18:04:22.132] {
[18:04:22.132]     {
[18:04:22.132]         {
[18:04:22.132]             ...future.startTime <- base::Sys.time()
[18:04:22.132]             {
[18:04:22.132]                 {
[18:04:22.132]                   {
[18:04:22.132]                     {
[18:04:22.132]                       base::local({
[18:04:22.132]                         has_future <- base::requireNamespace("future", 
[18:04:22.132]                           quietly = TRUE)
[18:04:22.132]                         if (has_future) {
[18:04:22.132]                           ns <- base::getNamespace("future")
[18:04:22.132]                           version <- ns[[".package"]][["version"]]
[18:04:22.132]                           if (is.null(version)) 
[18:04:22.132]                             version <- utils::packageVersion("future")
[18:04:22.132]                         }
[18:04:22.132]                         else {
[18:04:22.132]                           version <- NULL
[18:04:22.132]                         }
[18:04:22.132]                         if (!has_future || version < "1.8.0") {
[18:04:22.132]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:22.132]                             "", base::R.version$version.string), 
[18:04:22.132]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:22.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:22.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:22.132]                               "release", "version")], collapse = " "), 
[18:04:22.132]                             hostname = base::Sys.info()[["nodename"]])
[18:04:22.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:22.132]                             info)
[18:04:22.132]                           info <- base::paste(info, collapse = "; ")
[18:04:22.132]                           if (!has_future) {
[18:04:22.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:22.132]                               info)
[18:04:22.132]                           }
[18:04:22.132]                           else {
[18:04:22.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:22.132]                               info, version)
[18:04:22.132]                           }
[18:04:22.132]                           base::stop(msg)
[18:04:22.132]                         }
[18:04:22.132]                       })
[18:04:22.132]                     }
[18:04:22.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:22.132]                     base::options(mc.cores = 1L)
[18:04:22.132]                   }
[18:04:22.132]                   ...future.strategy.old <- future::plan("list")
[18:04:22.132]                   options(future.plan = NULL)
[18:04:22.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:22.132]                 }
[18:04:22.132]                 ...future.workdir <- getwd()
[18:04:22.132]             }
[18:04:22.132]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:22.132]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:22.132]         }
[18:04:22.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:22.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:22.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:22.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:22.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:22.132]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:22.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:22.132]             base::names(...future.oldOptions))
[18:04:22.132]     }
[18:04:22.132]     if (FALSE) {
[18:04:22.132]     }
[18:04:22.132]     else {
[18:04:22.132]         if (TRUE) {
[18:04:22.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:22.132]                 open = "w")
[18:04:22.132]         }
[18:04:22.132]         else {
[18:04:22.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:22.132]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:22.132]         }
[18:04:22.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:22.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:22.132]             base::sink(type = "output", split = FALSE)
[18:04:22.132]             base::close(...future.stdout)
[18:04:22.132]         }, add = TRUE)
[18:04:22.132]     }
[18:04:22.132]     ...future.frame <- base::sys.nframe()
[18:04:22.132]     ...future.conditions <- base::list()
[18:04:22.132]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:22.132]     if (FALSE) {
[18:04:22.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:22.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:22.132]     }
[18:04:22.132]     ...future.result <- base::tryCatch({
[18:04:22.132]         base::withCallingHandlers({
[18:04:22.132]             ...future.value <- base::withVisible(base::local({
[18:04:22.132]                 withCallingHandlers({
[18:04:22.132]                   NULL
[18:04:22.132]                 }, immediateCondition = function(cond) {
[18:04:22.132]                   save_rds <- function (object, pathname, ...) 
[18:04:22.132]                   {
[18:04:22.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:22.132]                     if (file_test("-f", pathname_tmp)) {
[18:04:22.132]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:22.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.132]                         fi_tmp[["mtime"]])
[18:04:22.132]                     }
[18:04:22.132]                     tryCatch({
[18:04:22.132]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:22.132]                     }, error = function(ex) {
[18:04:22.132]                       msg <- conditionMessage(ex)
[18:04:22.132]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:22.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.132]                         fi_tmp[["mtime"]], msg)
[18:04:22.132]                       ex$message <- msg
[18:04:22.132]                       stop(ex)
[18:04:22.132]                     })
[18:04:22.132]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:22.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:22.132]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:22.132]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.132]                       fi <- file.info(pathname)
[18:04:22.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:22.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:22.132]                         fi[["size"]], fi[["mtime"]])
[18:04:22.132]                       stop(msg)
[18:04:22.132]                     }
[18:04:22.132]                     invisible(pathname)
[18:04:22.132]                   }
[18:04:22.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:22.132]                     rootPath = tempdir()) 
[18:04:22.132]                   {
[18:04:22.132]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:22.132]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:22.132]                       tmpdir = path, fileext = ".rds")
[18:04:22.132]                     save_rds(obj, file)
[18:04:22.132]                   }
[18:04:22.132]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:22.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.132]                   {
[18:04:22.132]                     inherits <- base::inherits
[18:04:22.132]                     invokeRestart <- base::invokeRestart
[18:04:22.132]                     is.null <- base::is.null
[18:04:22.132]                     muffled <- FALSE
[18:04:22.132]                     if (inherits(cond, "message")) {
[18:04:22.132]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:22.132]                       if (muffled) 
[18:04:22.132]                         invokeRestart("muffleMessage")
[18:04:22.132]                     }
[18:04:22.132]                     else if (inherits(cond, "warning")) {
[18:04:22.132]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:22.132]                       if (muffled) 
[18:04:22.132]                         invokeRestart("muffleWarning")
[18:04:22.132]                     }
[18:04:22.132]                     else if (inherits(cond, "condition")) {
[18:04:22.132]                       if (!is.null(pattern)) {
[18:04:22.132]                         computeRestarts <- base::computeRestarts
[18:04:22.132]                         grepl <- base::grepl
[18:04:22.132]                         restarts <- computeRestarts(cond)
[18:04:22.132]                         for (restart in restarts) {
[18:04:22.132]                           name <- restart$name
[18:04:22.132]                           if (is.null(name)) 
[18:04:22.132]                             next
[18:04:22.132]                           if (!grepl(pattern, name)) 
[18:04:22.132]                             next
[18:04:22.132]                           invokeRestart(restart)
[18:04:22.132]                           muffled <- TRUE
[18:04:22.132]                           break
[18:04:22.132]                         }
[18:04:22.132]                       }
[18:04:22.132]                     }
[18:04:22.132]                     invisible(muffled)
[18:04:22.132]                   }
[18:04:22.132]                   muffleCondition(cond)
[18:04:22.132]                 })
[18:04:22.132]             }))
[18:04:22.132]             future::FutureResult(value = ...future.value$value, 
[18:04:22.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.132]                   ...future.rng), globalenv = if (FALSE) 
[18:04:22.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:22.132]                     ...future.globalenv.names))
[18:04:22.132]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:22.132]         }, condition = base::local({
[18:04:22.132]             c <- base::c
[18:04:22.132]             inherits <- base::inherits
[18:04:22.132]             invokeRestart <- base::invokeRestart
[18:04:22.132]             length <- base::length
[18:04:22.132]             list <- base::list
[18:04:22.132]             seq.int <- base::seq.int
[18:04:22.132]             signalCondition <- base::signalCondition
[18:04:22.132]             sys.calls <- base::sys.calls
[18:04:22.132]             `[[` <- base::`[[`
[18:04:22.132]             `+` <- base::`+`
[18:04:22.132]             `<<-` <- base::`<<-`
[18:04:22.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:22.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:22.132]                   3L)]
[18:04:22.132]             }
[18:04:22.132]             function(cond) {
[18:04:22.132]                 is_error <- inherits(cond, "error")
[18:04:22.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:22.132]                   NULL)
[18:04:22.132]                 if (is_error) {
[18:04:22.132]                   sessionInformation <- function() {
[18:04:22.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:22.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:22.132]                       search = base::search(), system = base::Sys.info())
[18:04:22.132]                   }
[18:04:22.132]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:22.132]                     cond$call), session = sessionInformation(), 
[18:04:22.132]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:22.132]                   signalCondition(cond)
[18:04:22.132]                 }
[18:04:22.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:22.132]                 "immediateCondition"))) {
[18:04:22.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:22.132]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:22.132]                   if (TRUE && !signal) {
[18:04:22.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.132]                     {
[18:04:22.132]                       inherits <- base::inherits
[18:04:22.132]                       invokeRestart <- base::invokeRestart
[18:04:22.132]                       is.null <- base::is.null
[18:04:22.132]                       muffled <- FALSE
[18:04:22.132]                       if (inherits(cond, "message")) {
[18:04:22.132]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.132]                         if (muffled) 
[18:04:22.132]                           invokeRestart("muffleMessage")
[18:04:22.132]                       }
[18:04:22.132]                       else if (inherits(cond, "warning")) {
[18:04:22.132]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.132]                         if (muffled) 
[18:04:22.132]                           invokeRestart("muffleWarning")
[18:04:22.132]                       }
[18:04:22.132]                       else if (inherits(cond, "condition")) {
[18:04:22.132]                         if (!is.null(pattern)) {
[18:04:22.132]                           computeRestarts <- base::computeRestarts
[18:04:22.132]                           grepl <- base::grepl
[18:04:22.132]                           restarts <- computeRestarts(cond)
[18:04:22.132]                           for (restart in restarts) {
[18:04:22.132]                             name <- restart$name
[18:04:22.132]                             if (is.null(name)) 
[18:04:22.132]                               next
[18:04:22.132]                             if (!grepl(pattern, name)) 
[18:04:22.132]                               next
[18:04:22.132]                             invokeRestart(restart)
[18:04:22.132]                             muffled <- TRUE
[18:04:22.132]                             break
[18:04:22.132]                           }
[18:04:22.132]                         }
[18:04:22.132]                       }
[18:04:22.132]                       invisible(muffled)
[18:04:22.132]                     }
[18:04:22.132]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.132]                   }
[18:04:22.132]                 }
[18:04:22.132]                 else {
[18:04:22.132]                   if (TRUE) {
[18:04:22.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.132]                     {
[18:04:22.132]                       inherits <- base::inherits
[18:04:22.132]                       invokeRestart <- base::invokeRestart
[18:04:22.132]                       is.null <- base::is.null
[18:04:22.132]                       muffled <- FALSE
[18:04:22.132]                       if (inherits(cond, "message")) {
[18:04:22.132]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.132]                         if (muffled) 
[18:04:22.132]                           invokeRestart("muffleMessage")
[18:04:22.132]                       }
[18:04:22.132]                       else if (inherits(cond, "warning")) {
[18:04:22.132]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.132]                         if (muffled) 
[18:04:22.132]                           invokeRestart("muffleWarning")
[18:04:22.132]                       }
[18:04:22.132]                       else if (inherits(cond, "condition")) {
[18:04:22.132]                         if (!is.null(pattern)) {
[18:04:22.132]                           computeRestarts <- base::computeRestarts
[18:04:22.132]                           grepl <- base::grepl
[18:04:22.132]                           restarts <- computeRestarts(cond)
[18:04:22.132]                           for (restart in restarts) {
[18:04:22.132]                             name <- restart$name
[18:04:22.132]                             if (is.null(name)) 
[18:04:22.132]                               next
[18:04:22.132]                             if (!grepl(pattern, name)) 
[18:04:22.132]                               next
[18:04:22.132]                             invokeRestart(restart)
[18:04:22.132]                             muffled <- TRUE
[18:04:22.132]                             break
[18:04:22.132]                           }
[18:04:22.132]                         }
[18:04:22.132]                       }
[18:04:22.132]                       invisible(muffled)
[18:04:22.132]                     }
[18:04:22.132]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.132]                   }
[18:04:22.132]                 }
[18:04:22.132]             }
[18:04:22.132]         }))
[18:04:22.132]     }, error = function(ex) {
[18:04:22.132]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:22.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.132]                 ...future.rng), started = ...future.startTime, 
[18:04:22.132]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:22.132]             version = "1.8"), class = "FutureResult")
[18:04:22.132]     }, finally = {
[18:04:22.132]         if (!identical(...future.workdir, getwd())) 
[18:04:22.132]             setwd(...future.workdir)
[18:04:22.132]         {
[18:04:22.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:22.132]                 ...future.oldOptions$nwarnings <- NULL
[18:04:22.132]             }
[18:04:22.132]             base::options(...future.oldOptions)
[18:04:22.132]             if (.Platform$OS.type == "windows") {
[18:04:22.132]                 old_names <- names(...future.oldEnvVars)
[18:04:22.132]                 envs <- base::Sys.getenv()
[18:04:22.132]                 names <- names(envs)
[18:04:22.132]                 common <- intersect(names, old_names)
[18:04:22.132]                 added <- setdiff(names, old_names)
[18:04:22.132]                 removed <- setdiff(old_names, names)
[18:04:22.132]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:22.132]                   envs[common]]
[18:04:22.132]                 NAMES <- toupper(changed)
[18:04:22.132]                 args <- list()
[18:04:22.132]                 for (kk in seq_along(NAMES)) {
[18:04:22.132]                   name <- changed[[kk]]
[18:04:22.132]                   NAME <- NAMES[[kk]]
[18:04:22.132]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.132]                     next
[18:04:22.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.132]                 }
[18:04:22.132]                 NAMES <- toupper(added)
[18:04:22.132]                 for (kk in seq_along(NAMES)) {
[18:04:22.132]                   name <- added[[kk]]
[18:04:22.132]                   NAME <- NAMES[[kk]]
[18:04:22.132]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.132]                     next
[18:04:22.132]                   args[[name]] <- ""
[18:04:22.132]                 }
[18:04:22.132]                 NAMES <- toupper(removed)
[18:04:22.132]                 for (kk in seq_along(NAMES)) {
[18:04:22.132]                   name <- removed[[kk]]
[18:04:22.132]                   NAME <- NAMES[[kk]]
[18:04:22.132]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.132]                     next
[18:04:22.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.132]                 }
[18:04:22.132]                 if (length(args) > 0) 
[18:04:22.132]                   base::do.call(base::Sys.setenv, args = args)
[18:04:22.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:22.132]             }
[18:04:22.132]             else {
[18:04:22.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:22.132]             }
[18:04:22.132]             {
[18:04:22.132]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:22.132]                   0L) {
[18:04:22.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:22.132]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:22.132]                   base::options(opts)
[18:04:22.132]                 }
[18:04:22.132]                 {
[18:04:22.132]                   {
[18:04:22.132]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:22.132]                     NULL
[18:04:22.132]                   }
[18:04:22.132]                   options(future.plan = NULL)
[18:04:22.132]                   if (is.na(NA_character_)) 
[18:04:22.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:22.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:22.132]                     .init = FALSE)
[18:04:22.132]                 }
[18:04:22.132]             }
[18:04:22.132]         }
[18:04:22.132]     })
[18:04:22.132]     if (TRUE) {
[18:04:22.132]         base::sink(type = "output", split = FALSE)
[18:04:22.132]         if (TRUE) {
[18:04:22.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:22.132]         }
[18:04:22.132]         else {
[18:04:22.132]             ...future.result["stdout"] <- base::list(NULL)
[18:04:22.132]         }
[18:04:22.132]         base::close(...future.stdout)
[18:04:22.132]         ...future.stdout <- NULL
[18:04:22.132]     }
[18:04:22.132]     ...future.result$conditions <- ...future.conditions
[18:04:22.132]     ...future.result$finished <- base::Sys.time()
[18:04:22.132]     ...future.result
[18:04:22.132] }
[18:04:22.139] requestCore(): workers = 2
[18:04:22.144] MulticoreFuture started
[18:04:22.144] - Launch lazy future ... done
[18:04:22.145] run() for ‘MulticoreFuture’ ... done
[18:04:22.146] plan(): Setting new future strategy stack:
[18:04:22.147] getGlobalsAndPackages() ...
[18:04:22.147] Searching for globals...
[18:04:22.146] List of future strategies:
[18:04:22.146] 1. sequential:
[18:04:22.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:22.146]    - tweaked: FALSE
[18:04:22.146]    - call: NULL
[18:04:22.148] plan(): nbrOfWorkers() = 1
[18:04:22.150] - globals found: [1] ‘{’
[18:04:22.150] Searching for globals ... DONE
[18:04:22.151] Resolving globals: FALSE
[18:04:22.152] 
[18:04:22.152] plan(): Setting new future strategy stack:
[18:04:22.152] 
[18:04:22.152] getGlobalsAndPackages() ... DONE
[18:04:22.152] List of future strategies:
[18:04:22.152] 1. multicore:
[18:04:22.152]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:22.152]    - tweaked: FALSE
[18:04:22.152]    - call: plan(strategy)
[18:04:22.153] run() for ‘Future’ ...
[18:04:22.154] - state: ‘created’
[18:04:22.154] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:22.164] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:22.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:22.165]   - Field: ‘label’
[18:04:22.165]   - Field: ‘local’
[18:04:22.165] plan(): nbrOfWorkers() = 2
[18:04:22.166]   - Field: ‘owner’
[18:04:22.166]   - Field: ‘envir’
[18:04:22.166]   - Field: ‘workers’
[18:04:22.167]   - Field: ‘packages’
[18:04:22.167]   - Field: ‘gc’
[18:04:22.167]   - Field: ‘job’
[18:04:22.167]   - Field: ‘conditions’
[18:04:22.168]   - Field: ‘expr’
[18:04:22.168]   - Field: ‘uuid’
[18:04:22.168]   - Field: ‘seed’
[18:04:22.169]   - Field: ‘version’
[18:04:22.169]   - Field: ‘result’
[18:04:22.169]   - Field: ‘asynchronous’
[18:04:22.170]   - Field: ‘calls’
[18:04:22.170]   - Field: ‘globals’
[18:04:22.170]   - Field: ‘stdout’
[18:04:22.171]   - Field: ‘earlySignal’
[18:04:22.171]   - Field: ‘lazy’
[18:04:22.171]   - Field: ‘state’
[18:04:22.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:22.172] - Launch lazy future ...
[18:04:22.173] Packages needed by the future expression (n = 0): <none>
[18:04:22.173] Packages needed by future strategies (n = 0): <none>
[18:04:22.189] {
[18:04:22.189]     {
[18:04:22.189]         {
[18:04:22.189]             ...future.startTime <- base::Sys.time()
[18:04:22.189]             {
[18:04:22.189]                 {
[18:04:22.189]                   {
[18:04:22.189]                     {
[18:04:22.189]                       base::local({
[18:04:22.189]                         has_future <- base::requireNamespace("future", 
[18:04:22.189]                           quietly = TRUE)
[18:04:22.189]                         if (has_future) {
[18:04:22.189]                           ns <- base::getNamespace("future")
[18:04:22.189]                           version <- ns[[".package"]][["version"]]
[18:04:22.189]                           if (is.null(version)) 
[18:04:22.189]                             version <- utils::packageVersion("future")
[18:04:22.189]                         }
[18:04:22.189]                         else {
[18:04:22.189]                           version <- NULL
[18:04:22.189]                         }
[18:04:22.189]                         if (!has_future || version < "1.8.0") {
[18:04:22.189]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:22.189]                             "", base::R.version$version.string), 
[18:04:22.189]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:22.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:22.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:22.189]                               "release", "version")], collapse = " "), 
[18:04:22.189]                             hostname = base::Sys.info()[["nodename"]])
[18:04:22.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:22.189]                             info)
[18:04:22.189]                           info <- base::paste(info, collapse = "; ")
[18:04:22.189]                           if (!has_future) {
[18:04:22.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:22.189]                               info)
[18:04:22.189]                           }
[18:04:22.189]                           else {
[18:04:22.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:22.189]                               info, version)
[18:04:22.189]                           }
[18:04:22.189]                           base::stop(msg)
[18:04:22.189]                         }
[18:04:22.189]                       })
[18:04:22.189]                     }
[18:04:22.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:22.189]                     base::options(mc.cores = 1L)
[18:04:22.189]                   }
[18:04:22.189]                   ...future.strategy.old <- future::plan("list")
[18:04:22.189]                   options(future.plan = NULL)
[18:04:22.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:22.189]                 }
[18:04:22.189]                 ...future.workdir <- getwd()
[18:04:22.189]             }
[18:04:22.189]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:22.189]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:22.189]         }
[18:04:22.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:22.189]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:22.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:22.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:22.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:22.189]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:22.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:22.189]             base::names(...future.oldOptions))
[18:04:22.189]     }
[18:04:22.189]     if (FALSE) {
[18:04:22.189]     }
[18:04:22.189]     else {
[18:04:22.189]         if (TRUE) {
[18:04:22.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:22.189]                 open = "w")
[18:04:22.189]         }
[18:04:22.189]         else {
[18:04:22.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:22.189]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:22.189]         }
[18:04:22.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:22.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:22.189]             base::sink(type = "output", split = FALSE)
[18:04:22.189]             base::close(...future.stdout)
[18:04:22.189]         }, add = TRUE)
[18:04:22.189]     }
[18:04:22.189]     ...future.frame <- base::sys.nframe()
[18:04:22.189]     ...future.conditions <- base::list()
[18:04:22.189]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:22.189]     if (FALSE) {
[18:04:22.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:22.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:22.189]     }
[18:04:22.189]     ...future.result <- base::tryCatch({
[18:04:22.189]         base::withCallingHandlers({
[18:04:22.189]             ...future.value <- base::withVisible(base::local({
[18:04:22.189]                 withCallingHandlers({
[18:04:22.189]                   {
[18:04:22.189]                     4
[18:04:22.189]                   }
[18:04:22.189]                 }, immediateCondition = function(cond) {
[18:04:22.189]                   save_rds <- function (object, pathname, ...) 
[18:04:22.189]                   {
[18:04:22.189]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:22.189]                     if (file_test("-f", pathname_tmp)) {
[18:04:22.189]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.189]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:22.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.189]                         fi_tmp[["mtime"]])
[18:04:22.189]                     }
[18:04:22.189]                     tryCatch({
[18:04:22.189]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:22.189]                     }, error = function(ex) {
[18:04:22.189]                       msg <- conditionMessage(ex)
[18:04:22.189]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.189]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:22.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.189]                         fi_tmp[["mtime"]], msg)
[18:04:22.189]                       ex$message <- msg
[18:04:22.189]                       stop(ex)
[18:04:22.189]                     })
[18:04:22.189]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:22.189]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:22.189]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:22.189]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.189]                       fi <- file.info(pathname)
[18:04:22.189]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:22.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.189]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:22.189]                         fi[["size"]], fi[["mtime"]])
[18:04:22.189]                       stop(msg)
[18:04:22.189]                     }
[18:04:22.189]                     invisible(pathname)
[18:04:22.189]                   }
[18:04:22.189]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:22.189]                     rootPath = tempdir()) 
[18:04:22.189]                   {
[18:04:22.189]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:22.189]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:22.189]                       tmpdir = path, fileext = ".rds")
[18:04:22.189]                     save_rds(obj, file)
[18:04:22.189]                   }
[18:04:22.189]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:22.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.189]                   {
[18:04:22.189]                     inherits <- base::inherits
[18:04:22.189]                     invokeRestart <- base::invokeRestart
[18:04:22.189]                     is.null <- base::is.null
[18:04:22.189]                     muffled <- FALSE
[18:04:22.189]                     if (inherits(cond, "message")) {
[18:04:22.189]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:22.189]                       if (muffled) 
[18:04:22.189]                         invokeRestart("muffleMessage")
[18:04:22.189]                     }
[18:04:22.189]                     else if (inherits(cond, "warning")) {
[18:04:22.189]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:22.189]                       if (muffled) 
[18:04:22.189]                         invokeRestart("muffleWarning")
[18:04:22.189]                     }
[18:04:22.189]                     else if (inherits(cond, "condition")) {
[18:04:22.189]                       if (!is.null(pattern)) {
[18:04:22.189]                         computeRestarts <- base::computeRestarts
[18:04:22.189]                         grepl <- base::grepl
[18:04:22.189]                         restarts <- computeRestarts(cond)
[18:04:22.189]                         for (restart in restarts) {
[18:04:22.189]                           name <- restart$name
[18:04:22.189]                           if (is.null(name)) 
[18:04:22.189]                             next
[18:04:22.189]                           if (!grepl(pattern, name)) 
[18:04:22.189]                             next
[18:04:22.189]                           invokeRestart(restart)
[18:04:22.189]                           muffled <- TRUE
[18:04:22.189]                           break
[18:04:22.189]                         }
[18:04:22.189]                       }
[18:04:22.189]                     }
[18:04:22.189]                     invisible(muffled)
[18:04:22.189]                   }
[18:04:22.189]                   muffleCondition(cond)
[18:04:22.189]                 })
[18:04:22.189]             }))
[18:04:22.189]             future::FutureResult(value = ...future.value$value, 
[18:04:22.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.189]                   ...future.rng), globalenv = if (FALSE) 
[18:04:22.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:22.189]                     ...future.globalenv.names))
[18:04:22.189]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:22.189]         }, condition = base::local({
[18:04:22.189]             c <- base::c
[18:04:22.189]             inherits <- base::inherits
[18:04:22.189]             invokeRestart <- base::invokeRestart
[18:04:22.189]             length <- base::length
[18:04:22.189]             list <- base::list
[18:04:22.189]             seq.int <- base::seq.int
[18:04:22.189]             signalCondition <- base::signalCondition
[18:04:22.189]             sys.calls <- base::sys.calls
[18:04:22.189]             `[[` <- base::`[[`
[18:04:22.189]             `+` <- base::`+`
[18:04:22.189]             `<<-` <- base::`<<-`
[18:04:22.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:22.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:22.189]                   3L)]
[18:04:22.189]             }
[18:04:22.189]             function(cond) {
[18:04:22.189]                 is_error <- inherits(cond, "error")
[18:04:22.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:22.189]                   NULL)
[18:04:22.189]                 if (is_error) {
[18:04:22.189]                   sessionInformation <- function() {
[18:04:22.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:22.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:22.189]                       search = base::search(), system = base::Sys.info())
[18:04:22.189]                   }
[18:04:22.189]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:22.189]                     cond$call), session = sessionInformation(), 
[18:04:22.189]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:22.189]                   signalCondition(cond)
[18:04:22.189]                 }
[18:04:22.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:22.189]                 "immediateCondition"))) {
[18:04:22.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:22.189]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:22.189]                   if (TRUE && !signal) {
[18:04:22.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.189]                     {
[18:04:22.189]                       inherits <- base::inherits
[18:04:22.189]                       invokeRestart <- base::invokeRestart
[18:04:22.189]                       is.null <- base::is.null
[18:04:22.189]                       muffled <- FALSE
[18:04:22.189]                       if (inherits(cond, "message")) {
[18:04:22.189]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.189]                         if (muffled) 
[18:04:22.189]                           invokeRestart("muffleMessage")
[18:04:22.189]                       }
[18:04:22.189]                       else if (inherits(cond, "warning")) {
[18:04:22.189]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.189]                         if (muffled) 
[18:04:22.189]                           invokeRestart("muffleWarning")
[18:04:22.189]                       }
[18:04:22.189]                       else if (inherits(cond, "condition")) {
[18:04:22.189]                         if (!is.null(pattern)) {
[18:04:22.189]                           computeRestarts <- base::computeRestarts
[18:04:22.189]                           grepl <- base::grepl
[18:04:22.189]                           restarts <- computeRestarts(cond)
[18:04:22.189]                           for (restart in restarts) {
[18:04:22.189]                             name <- restart$name
[18:04:22.189]                             if (is.null(name)) 
[18:04:22.189]                               next
[18:04:22.189]                             if (!grepl(pattern, name)) 
[18:04:22.189]                               next
[18:04:22.189]                             invokeRestart(restart)
[18:04:22.189]                             muffled <- TRUE
[18:04:22.189]                             break
[18:04:22.189]                           }
[18:04:22.189]                         }
[18:04:22.189]                       }
[18:04:22.189]                       invisible(muffled)
[18:04:22.189]                     }
[18:04:22.189]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.189]                   }
[18:04:22.189]                 }
[18:04:22.189]                 else {
[18:04:22.189]                   if (TRUE) {
[18:04:22.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.189]                     {
[18:04:22.189]                       inherits <- base::inherits
[18:04:22.189]                       invokeRestart <- base::invokeRestart
[18:04:22.189]                       is.null <- base::is.null
[18:04:22.189]                       muffled <- FALSE
[18:04:22.189]                       if (inherits(cond, "message")) {
[18:04:22.189]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.189]                         if (muffled) 
[18:04:22.189]                           invokeRestart("muffleMessage")
[18:04:22.189]                       }
[18:04:22.189]                       else if (inherits(cond, "warning")) {
[18:04:22.189]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.189]                         if (muffled) 
[18:04:22.189]                           invokeRestart("muffleWarning")
[18:04:22.189]                       }
[18:04:22.189]                       else if (inherits(cond, "condition")) {
[18:04:22.189]                         if (!is.null(pattern)) {
[18:04:22.189]                           computeRestarts <- base::computeRestarts
[18:04:22.189]                           grepl <- base::grepl
[18:04:22.189]                           restarts <- computeRestarts(cond)
[18:04:22.189]                           for (restart in restarts) {
[18:04:22.189]                             name <- restart$name
[18:04:22.189]                             if (is.null(name)) 
[18:04:22.189]                               next
[18:04:22.189]                             if (!grepl(pattern, name)) 
[18:04:22.189]                               next
[18:04:22.189]                             invokeRestart(restart)
[18:04:22.189]                             muffled <- TRUE
[18:04:22.189]                             break
[18:04:22.189]                           }
[18:04:22.189]                         }
[18:04:22.189]                       }
[18:04:22.189]                       invisible(muffled)
[18:04:22.189]                     }
[18:04:22.189]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.189]                   }
[18:04:22.189]                 }
[18:04:22.189]             }
[18:04:22.189]         }))
[18:04:22.189]     }, error = function(ex) {
[18:04:22.189]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:22.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.189]                 ...future.rng), started = ...future.startTime, 
[18:04:22.189]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:22.189]             version = "1.8"), class = "FutureResult")
[18:04:22.189]     }, finally = {
[18:04:22.189]         if (!identical(...future.workdir, getwd())) 
[18:04:22.189]             setwd(...future.workdir)
[18:04:22.189]         {
[18:04:22.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:22.189]                 ...future.oldOptions$nwarnings <- NULL
[18:04:22.189]             }
[18:04:22.189]             base::options(...future.oldOptions)
[18:04:22.189]             if (.Platform$OS.type == "windows") {
[18:04:22.189]                 old_names <- names(...future.oldEnvVars)
[18:04:22.189]                 envs <- base::Sys.getenv()
[18:04:22.189]                 names <- names(envs)
[18:04:22.189]                 common <- intersect(names, old_names)
[18:04:22.189]                 added <- setdiff(names, old_names)
[18:04:22.189]                 removed <- setdiff(old_names, names)
[18:04:22.189]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:22.189]                   envs[common]]
[18:04:22.189]                 NAMES <- toupper(changed)
[18:04:22.189]                 args <- list()
[18:04:22.189]                 for (kk in seq_along(NAMES)) {
[18:04:22.189]                   name <- changed[[kk]]
[18:04:22.189]                   NAME <- NAMES[[kk]]
[18:04:22.189]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.189]                     next
[18:04:22.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.189]                 }
[18:04:22.189]                 NAMES <- toupper(added)
[18:04:22.189]                 for (kk in seq_along(NAMES)) {
[18:04:22.189]                   name <- added[[kk]]
[18:04:22.189]                   NAME <- NAMES[[kk]]
[18:04:22.189]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.189]                     next
[18:04:22.189]                   args[[name]] <- ""
[18:04:22.189]                 }
[18:04:22.189]                 NAMES <- toupper(removed)
[18:04:22.189]                 for (kk in seq_along(NAMES)) {
[18:04:22.189]                   name <- removed[[kk]]
[18:04:22.189]                   NAME <- NAMES[[kk]]
[18:04:22.189]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.189]                     next
[18:04:22.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.189]                 }
[18:04:22.189]                 if (length(args) > 0) 
[18:04:22.189]                   base::do.call(base::Sys.setenv, args = args)
[18:04:22.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:22.189]             }
[18:04:22.189]             else {
[18:04:22.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:22.189]             }
[18:04:22.189]             {
[18:04:22.189]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:22.189]                   0L) {
[18:04:22.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:22.189]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:22.189]                   base::options(opts)
[18:04:22.189]                 }
[18:04:22.189]                 {
[18:04:22.189]                   {
[18:04:22.189]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:22.189]                     NULL
[18:04:22.189]                   }
[18:04:22.189]                   options(future.plan = NULL)
[18:04:22.189]                   if (is.na(NA_character_)) 
[18:04:22.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:22.189]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:22.189]                     .init = FALSE)
[18:04:22.189]                 }
[18:04:22.189]             }
[18:04:22.189]         }
[18:04:22.189]     })
[18:04:22.189]     if (TRUE) {
[18:04:22.189]         base::sink(type = "output", split = FALSE)
[18:04:22.189]         if (TRUE) {
[18:04:22.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:22.189]         }
[18:04:22.189]         else {
[18:04:22.189]             ...future.result["stdout"] <- base::list(NULL)
[18:04:22.189]         }
[18:04:22.189]         base::close(...future.stdout)
[18:04:22.189]         ...future.stdout <- NULL
[18:04:22.189]     }
[18:04:22.189]     ...future.result$conditions <- ...future.conditions
[18:04:22.189]     ...future.result$finished <- base::Sys.time()
[18:04:22.189]     ...future.result
[18:04:22.189] }
[18:04:22.196] requestCore(): workers = 2
[18:04:22.197] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:22.209] result() for MulticoreFuture ...
[18:04:22.211] result() for MulticoreFuture ...
[18:04:22.212] result() for MulticoreFuture ... done
[18:04:22.212] result() for MulticoreFuture ... done
[18:04:22.213] result() for MulticoreFuture ...
[18:04:22.213] result() for MulticoreFuture ... done
[18:04:22.218] MulticoreFuture started
[18:04:22.219] - Launch lazy future ... done
[18:04:22.220] run() for ‘MulticoreFuture’ ... done
[18:04:22.220] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5e3c2caebe10> 
[18:04:22.221] List of future strategies:
[18:04:22.221] 1. sequential:
[18:04:22.221]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:22.221]    - tweaked: FALSE
[18:04:22.221]    - call: NULL
[18:04:22.223] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5e3c2ba26b78> 
 - attr(*, "dim.")= int [1:3] 2 3 1
[18:04:22.228] plan(): Setting new future strategy stack:
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ :[18:04:22.228] List of future strategies:
[18:04:22.228] 1. multicore:
[18:04:22.228]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:22.228]    - tweaked: FALSE
[18:04:22.228]    - call: plan(strategy)
 chr "a"
[18:04:22.242] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:22.252] resolve() on list environment ...
[18:04:22.252]  recursive: 0
[18:04:22.256]  length: 6
[18:04:22.256]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:22.256] signalConditionsASAP(numeric, pos=1) ...
[18:04:22.257] - nx: 6
[18:04:22.257] - relay: TRUE
[18:04:22.257] - stdout: TRUE
[18:04:22.258] - signal: TRUE
[18:04:22.258] - resignal: FALSE
[18:04:22.258] - force: TRUE
[18:04:22.258] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.259] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.259]  - until=2
[18:04:22.259]  - relaying element #2
[18:04:22.260] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.260] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.260] signalConditionsASAP(NULL, pos=1) ... done
[18:04:22.261]  length: 5 (resolved future 1)
[18:04:22.261] Future #2
[18:04:22.261] result() for MulticoreFuture ...
[18:04:22.262] result() for MulticoreFuture ... done
[18:04:22.262] result() for MulticoreFuture ...
[18:04:22.262] result() for MulticoreFuture ... done
[18:04:22.263] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:22.263] - nx: 6
[18:04:22.263] - relay: TRUE
[18:04:22.264] - stdout: TRUE
[18:04:22.264] - signal: TRUE
[18:04:22.264] - resignal: FALSE
[18:04:22.264] - force: TRUE
[18:04:22.265] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.265] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.265]  - until=2
[18:04:22.265]  - relaying element #2
[18:04:22.266] result() for MulticoreFuture ...
[18:04:22.266] result() for MulticoreFuture ... done
[18:04:22.266] result() for MulticoreFuture ...
[18:04:22.267] result() for MulticoreFuture ... done
[18:04:22.267] result() for MulticoreFuture ...
[18:04:22.267] result() for MulticoreFuture ... done
[18:04:22.268] result() for MulticoreFuture ...
[18:04:22.268] result() for MulticoreFuture ... done
[18:04:22.268] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.268] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.269] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:22.269]  length: 4 (resolved future 2)
[18:04:22.270] Future #3
[18:04:22.270] result() for MulticoreFuture ...
[18:04:22.272] result() for MulticoreFuture ...
[18:04:22.272] result() for MulticoreFuture ... done
[18:04:22.272] result() for MulticoreFuture ... done
[18:04:22.273] result() for MulticoreFuture ...
[18:04:22.273] result() for MulticoreFuture ... done
[18:04:22.273] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:22.274] - nx: 6
[18:04:22.274] - relay: TRUE
[18:04:22.274] - stdout: TRUE
[18:04:22.274] - signal: TRUE
[18:04:22.275] - resignal: FALSE
[18:04:22.275] - force: TRUE
[18:04:22.275] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.275] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.276]  - until=3
[18:04:22.276]  - relaying element #3
[18:04:22.276] result() for MulticoreFuture ...
[18:04:22.277] result() for MulticoreFuture ... done
[18:04:22.277] result() for MulticoreFuture ...
[18:04:22.277] result() for MulticoreFuture ... done
[18:04:22.278] result() for MulticoreFuture ...
[18:04:22.278] result() for MulticoreFuture ... done
[18:04:22.278] result() for MulticoreFuture ...
[18:04:22.278] result() for MulticoreFuture ... done
[18:04:22.279] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.279] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.279] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:22.280]  length: 3 (resolved future 3)
[18:04:22.280] Future #4
[18:04:22.281] result() for MulticoreFuture ...
[18:04:22.282] result() for MulticoreFuture ...
[18:04:22.283] result() for MulticoreFuture ... done
[18:04:22.283] result() for MulticoreFuture ... done
[18:04:22.283] result() for MulticoreFuture ...
[18:04:22.283] result() for MulticoreFuture ... done
[18:04:22.284] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:22.284] - nx: 6
[18:04:22.284] - relay: TRUE
[18:04:22.284] - stdout: TRUE
[18:04:22.285] - signal: TRUE
[18:04:22.285] - resignal: FALSE
[18:04:22.285] - force: TRUE
[18:04:22.285] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.286] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.286]  - until=4
[18:04:22.286]  - relaying element #4
[18:04:22.286] result() for MulticoreFuture ...
[18:04:22.287] result() for MulticoreFuture ... done
[18:04:22.287] result() for MulticoreFuture ...
[18:04:22.287] result() for MulticoreFuture ... done
[18:04:22.287] result() for MulticoreFuture ...
[18:04:22.288] result() for MulticoreFuture ... done
[18:04:22.288] result() for MulticoreFuture ...
[18:04:22.288] result() for MulticoreFuture ... done
[18:04:22.288] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.289] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.289] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:22.289]  length: 2 (resolved future 4)
[18:04:22.290] signalConditionsASAP(NULL, pos=5) ...
[18:04:22.290] - nx: 6
[18:04:22.290] - relay: TRUE
[18:04:22.290] - stdout: TRUE
[18:04:22.290] - signal: TRUE
[18:04:22.291] - resignal: FALSE
[18:04:22.291] - force: TRUE
[18:04:22.291] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.291] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.292]  - until=6
[18:04:22.292]  - relaying element #6
[18:04:22.292] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:22.292] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.293] signalConditionsASAP(NULL, pos=5) ... done
[18:04:22.293]  length: 1 (resolved future 5)
[18:04:22.293] signalConditionsASAP(numeric, pos=6) ...
[18:04:22.293] - nx: 6
[18:04:22.294] - relay: TRUE
[18:04:22.294] - stdout: TRUE
[18:04:22.294] - signal: TRUE
[18:04:22.294] - resignal: FALSE
[18:04:22.294] - force: TRUE
[18:04:22.295] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:22.295] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.295]  - until=6
[18:04:22.296] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:22.296] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.296] signalConditionsASAP(numeric, pos=6) ... done
[18:04:22.296]  length: 0 (resolved future 6)
[18:04:22.297] Relaying remaining futures
[18:04:22.297] signalConditionsASAP(NULL, pos=0) ...
[18:04:22.297] - nx: 6
[18:04:22.297] - relay: TRUE
[18:04:22.297] - stdout: TRUE
[18:04:22.298] - signal: TRUE
[18:04:22.298] - resignal: FALSE
[18:04:22.298] - force: TRUE
[18:04:22.298] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:22.299] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:22.299] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:22.299] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.299] signalConditionsASAP(NULL, pos=0) ... done
[18:04:22.300] resolve() on list environment ... DONE
[18:04:22.300] result() for MulticoreFuture ...
[18:04:22.300] result() for MulticoreFuture ... done
[18:04:22.300] result() for MulticoreFuture ...
[18:04:22.300] result() for MulticoreFuture ... done
[18:04:22.301] result() for MulticoreFuture ...
[18:04:22.301] result() for MulticoreFuture ... done
[18:04:22.301] result() for MulticoreFuture ...
[18:04:22.302] result() for MulticoreFuture ... done
[18:04:22.302] result() for MulticoreFuture ...
[18:04:22.302] result() for MulticoreFuture ... done
[18:04:22.303] result() for MulticoreFuture ...
[18:04:22.303] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2b305240> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[18:04:22.307] getGlobalsAndPackages() ...
[18:04:22.307] Searching for globals...
[18:04:22.308] 
[18:04:22.308] Searching for globals ... DONE
[18:04:22.309] - globals: [0] <none>
[18:04:22.309] getGlobalsAndPackages() ... DONE
[18:04:22.309] run() for ‘Future’ ...
[18:04:22.310] - state: ‘created’
[18:04:22.310] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:22.317] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:22.318] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:22.318]   - Field: ‘label’
[18:04:22.318]   - Field: ‘local’
[18:04:22.318]   - Field: ‘owner’
[18:04:22.319]   - Field: ‘envir’
[18:04:22.319]   - Field: ‘workers’
[18:04:22.319]   - Field: ‘packages’
[18:04:22.319]   - Field: ‘gc’
[18:04:22.320]   - Field: ‘job’
[18:04:22.320]   - Field: ‘conditions’
[18:04:22.320]   - Field: ‘expr’
[18:04:22.320]   - Field: ‘uuid’
[18:04:22.321]   - Field: ‘seed’
[18:04:22.321]   - Field: ‘version’
[18:04:22.321]   - Field: ‘result’
[18:04:22.321]   - Field: ‘asynchronous’
[18:04:22.321]   - Field: ‘calls’
[18:04:22.322]   - Field: ‘globals’
[18:04:22.322]   - Field: ‘stdout’
[18:04:22.322]   - Field: ‘earlySignal’
[18:04:22.322]   - Field: ‘lazy’
[18:04:22.323]   - Field: ‘state’
[18:04:22.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:22.323] - Launch lazy future ...
[18:04:22.324] Packages needed by the future expression (n = 0): <none>
[18:04:22.324] Packages needed by future strategies (n = 0): <none>
[18:04:22.325] {
[18:04:22.325]     {
[18:04:22.325]         {
[18:04:22.325]             ...future.startTime <- base::Sys.time()
[18:04:22.325]             {
[18:04:22.325]                 {
[18:04:22.325]                   {
[18:04:22.325]                     {
[18:04:22.325]                       base::local({
[18:04:22.325]                         has_future <- base::requireNamespace("future", 
[18:04:22.325]                           quietly = TRUE)
[18:04:22.325]                         if (has_future) {
[18:04:22.325]                           ns <- base::getNamespace("future")
[18:04:22.325]                           version <- ns[[".package"]][["version"]]
[18:04:22.325]                           if (is.null(version)) 
[18:04:22.325]                             version <- utils::packageVersion("future")
[18:04:22.325]                         }
[18:04:22.325]                         else {
[18:04:22.325]                           version <- NULL
[18:04:22.325]                         }
[18:04:22.325]                         if (!has_future || version < "1.8.0") {
[18:04:22.325]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:22.325]                             "", base::R.version$version.string), 
[18:04:22.325]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:22.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:22.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:22.325]                               "release", "version")], collapse = " "), 
[18:04:22.325]                             hostname = base::Sys.info()[["nodename"]])
[18:04:22.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:22.325]                             info)
[18:04:22.325]                           info <- base::paste(info, collapse = "; ")
[18:04:22.325]                           if (!has_future) {
[18:04:22.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:22.325]                               info)
[18:04:22.325]                           }
[18:04:22.325]                           else {
[18:04:22.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:22.325]                               info, version)
[18:04:22.325]                           }
[18:04:22.325]                           base::stop(msg)
[18:04:22.325]                         }
[18:04:22.325]                       })
[18:04:22.325]                     }
[18:04:22.325]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:22.325]                     base::options(mc.cores = 1L)
[18:04:22.325]                   }
[18:04:22.325]                   ...future.strategy.old <- future::plan("list")
[18:04:22.325]                   options(future.plan = NULL)
[18:04:22.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:22.325]                 }
[18:04:22.325]                 ...future.workdir <- getwd()
[18:04:22.325]             }
[18:04:22.325]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:22.325]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:22.325]         }
[18:04:22.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:22.325]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:22.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:22.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:22.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:22.325]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:22.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:22.325]             base::names(...future.oldOptions))
[18:04:22.325]     }
[18:04:22.325]     if (FALSE) {
[18:04:22.325]     }
[18:04:22.325]     else {
[18:04:22.325]         if (TRUE) {
[18:04:22.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:22.325]                 open = "w")
[18:04:22.325]         }
[18:04:22.325]         else {
[18:04:22.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:22.325]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:22.325]         }
[18:04:22.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:22.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:22.325]             base::sink(type = "output", split = FALSE)
[18:04:22.325]             base::close(...future.stdout)
[18:04:22.325]         }, add = TRUE)
[18:04:22.325]     }
[18:04:22.325]     ...future.frame <- base::sys.nframe()
[18:04:22.325]     ...future.conditions <- base::list()
[18:04:22.325]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:22.325]     if (FALSE) {
[18:04:22.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:22.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:22.325]     }
[18:04:22.325]     ...future.result <- base::tryCatch({
[18:04:22.325]         base::withCallingHandlers({
[18:04:22.325]             ...future.value <- base::withVisible(base::local({
[18:04:22.325]                 withCallingHandlers({
[18:04:22.325]                   2
[18:04:22.325]                 }, immediateCondition = function(cond) {
[18:04:22.325]                   save_rds <- function (object, pathname, ...) 
[18:04:22.325]                   {
[18:04:22.325]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:22.325]                     if (file_test("-f", pathname_tmp)) {
[18:04:22.325]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.325]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:22.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.325]                         fi_tmp[["mtime"]])
[18:04:22.325]                     }
[18:04:22.325]                     tryCatch({
[18:04:22.325]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:22.325]                     }, error = function(ex) {
[18:04:22.325]                       msg <- conditionMessage(ex)
[18:04:22.325]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.325]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:22.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.325]                         fi_tmp[["mtime"]], msg)
[18:04:22.325]                       ex$message <- msg
[18:04:22.325]                       stop(ex)
[18:04:22.325]                     })
[18:04:22.325]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:22.325]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:22.325]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:22.325]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.325]                       fi <- file.info(pathname)
[18:04:22.325]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:22.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.325]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:22.325]                         fi[["size"]], fi[["mtime"]])
[18:04:22.325]                       stop(msg)
[18:04:22.325]                     }
[18:04:22.325]                     invisible(pathname)
[18:04:22.325]                   }
[18:04:22.325]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:22.325]                     rootPath = tempdir()) 
[18:04:22.325]                   {
[18:04:22.325]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:22.325]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:22.325]                       tmpdir = path, fileext = ".rds")
[18:04:22.325]                     save_rds(obj, file)
[18:04:22.325]                   }
[18:04:22.325]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:22.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.325]                   {
[18:04:22.325]                     inherits <- base::inherits
[18:04:22.325]                     invokeRestart <- base::invokeRestart
[18:04:22.325]                     is.null <- base::is.null
[18:04:22.325]                     muffled <- FALSE
[18:04:22.325]                     if (inherits(cond, "message")) {
[18:04:22.325]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:22.325]                       if (muffled) 
[18:04:22.325]                         invokeRestart("muffleMessage")
[18:04:22.325]                     }
[18:04:22.325]                     else if (inherits(cond, "warning")) {
[18:04:22.325]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:22.325]                       if (muffled) 
[18:04:22.325]                         invokeRestart("muffleWarning")
[18:04:22.325]                     }
[18:04:22.325]                     else if (inherits(cond, "condition")) {
[18:04:22.325]                       if (!is.null(pattern)) {
[18:04:22.325]                         computeRestarts <- base::computeRestarts
[18:04:22.325]                         grepl <- base::grepl
[18:04:22.325]                         restarts <- computeRestarts(cond)
[18:04:22.325]                         for (restart in restarts) {
[18:04:22.325]                           name <- restart$name
[18:04:22.325]                           if (is.null(name)) 
[18:04:22.325]                             next
[18:04:22.325]                           if (!grepl(pattern, name)) 
[18:04:22.325]                             next
[18:04:22.325]                           invokeRestart(restart)
[18:04:22.325]                           muffled <- TRUE
[18:04:22.325]                           break
[18:04:22.325]                         }
[18:04:22.325]                       }
[18:04:22.325]                     }
[18:04:22.325]                     invisible(muffled)
[18:04:22.325]                   }
[18:04:22.325]                   muffleCondition(cond)
[18:04:22.325]                 })
[18:04:22.325]             }))
[18:04:22.325]             future::FutureResult(value = ...future.value$value, 
[18:04:22.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.325]                   ...future.rng), globalenv = if (FALSE) 
[18:04:22.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:22.325]                     ...future.globalenv.names))
[18:04:22.325]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:22.325]         }, condition = base::local({
[18:04:22.325]             c <- base::c
[18:04:22.325]             inherits <- base::inherits
[18:04:22.325]             invokeRestart <- base::invokeRestart
[18:04:22.325]             length <- base::length
[18:04:22.325]             list <- base::list
[18:04:22.325]             seq.int <- base::seq.int
[18:04:22.325]             signalCondition <- base::signalCondition
[18:04:22.325]             sys.calls <- base::sys.calls
[18:04:22.325]             `[[` <- base::`[[`
[18:04:22.325]             `+` <- base::`+`
[18:04:22.325]             `<<-` <- base::`<<-`
[18:04:22.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:22.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:22.325]                   3L)]
[18:04:22.325]             }
[18:04:22.325]             function(cond) {
[18:04:22.325]                 is_error <- inherits(cond, "error")
[18:04:22.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:22.325]                   NULL)
[18:04:22.325]                 if (is_error) {
[18:04:22.325]                   sessionInformation <- function() {
[18:04:22.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:22.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:22.325]                       search = base::search(), system = base::Sys.info())
[18:04:22.325]                   }
[18:04:22.325]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:22.325]                     cond$call), session = sessionInformation(), 
[18:04:22.325]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:22.325]                   signalCondition(cond)
[18:04:22.325]                 }
[18:04:22.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:22.325]                 "immediateCondition"))) {
[18:04:22.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:22.325]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:22.325]                   if (TRUE && !signal) {
[18:04:22.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.325]                     {
[18:04:22.325]                       inherits <- base::inherits
[18:04:22.325]                       invokeRestart <- base::invokeRestart
[18:04:22.325]                       is.null <- base::is.null
[18:04:22.325]                       muffled <- FALSE
[18:04:22.325]                       if (inherits(cond, "message")) {
[18:04:22.325]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.325]                         if (muffled) 
[18:04:22.325]                           invokeRestart("muffleMessage")
[18:04:22.325]                       }
[18:04:22.325]                       else if (inherits(cond, "warning")) {
[18:04:22.325]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.325]                         if (muffled) 
[18:04:22.325]                           invokeRestart("muffleWarning")
[18:04:22.325]                       }
[18:04:22.325]                       else if (inherits(cond, "condition")) {
[18:04:22.325]                         if (!is.null(pattern)) {
[18:04:22.325]                           computeRestarts <- base::computeRestarts
[18:04:22.325]                           grepl <- base::grepl
[18:04:22.325]                           restarts <- computeRestarts(cond)
[18:04:22.325]                           for (restart in restarts) {
[18:04:22.325]                             name <- restart$name
[18:04:22.325]                             if (is.null(name)) 
[18:04:22.325]                               next
[18:04:22.325]                             if (!grepl(pattern, name)) 
[18:04:22.325]                               next
[18:04:22.325]                             invokeRestart(restart)
[18:04:22.325]                             muffled <- TRUE
[18:04:22.325]                             break
[18:04:22.325]                           }
[18:04:22.325]                         }
[18:04:22.325]                       }
[18:04:22.325]                       invisible(muffled)
[18:04:22.325]                     }
[18:04:22.325]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.325]                   }
[18:04:22.325]                 }
[18:04:22.325]                 else {
[18:04:22.325]                   if (TRUE) {
[18:04:22.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.325]                     {
[18:04:22.325]                       inherits <- base::inherits
[18:04:22.325]                       invokeRestart <- base::invokeRestart
[18:04:22.325]                       is.null <- base::is.null
[18:04:22.325]                       muffled <- FALSE
[18:04:22.325]                       if (inherits(cond, "message")) {
[18:04:22.325]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.325]                         if (muffled) 
[18:04:22.325]                           invokeRestart("muffleMessage")
[18:04:22.325]                       }
[18:04:22.325]                       else if (inherits(cond, "warning")) {
[18:04:22.325]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.325]                         if (muffled) 
[18:04:22.325]                           invokeRestart("muffleWarning")
[18:04:22.325]                       }
[18:04:22.325]                       else if (inherits(cond, "condition")) {
[18:04:22.325]                         if (!is.null(pattern)) {
[18:04:22.325]                           computeRestarts <- base::computeRestarts
[18:04:22.325]                           grepl <- base::grepl
[18:04:22.325]                           restarts <- computeRestarts(cond)
[18:04:22.325]                           for (restart in restarts) {
[18:04:22.325]                             name <- restart$name
[18:04:22.325]                             if (is.null(name)) 
[18:04:22.325]                               next
[18:04:22.325]                             if (!grepl(pattern, name)) 
[18:04:22.325]                               next
[18:04:22.325]                             invokeRestart(restart)
[18:04:22.325]                             muffled <- TRUE
[18:04:22.325]                             break
[18:04:22.325]                           }
[18:04:22.325]                         }
[18:04:22.325]                       }
[18:04:22.325]                       invisible(muffled)
[18:04:22.325]                     }
[18:04:22.325]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.325]                   }
[18:04:22.325]                 }
[18:04:22.325]             }
[18:04:22.325]         }))
[18:04:22.325]     }, error = function(ex) {
[18:04:22.325]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:22.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.325]                 ...future.rng), started = ...future.startTime, 
[18:04:22.325]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:22.325]             version = "1.8"), class = "FutureResult")
[18:04:22.325]     }, finally = {
[18:04:22.325]         if (!identical(...future.workdir, getwd())) 
[18:04:22.325]             setwd(...future.workdir)
[18:04:22.325]         {
[18:04:22.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:22.325]                 ...future.oldOptions$nwarnings <- NULL
[18:04:22.325]             }
[18:04:22.325]             base::options(...future.oldOptions)
[18:04:22.325]             if (.Platform$OS.type == "windows") {
[18:04:22.325]                 old_names <- names(...future.oldEnvVars)
[18:04:22.325]                 envs <- base::Sys.getenv()
[18:04:22.325]                 names <- names(envs)
[18:04:22.325]                 common <- intersect(names, old_names)
[18:04:22.325]                 added <- setdiff(names, old_names)
[18:04:22.325]                 removed <- setdiff(old_names, names)
[18:04:22.325]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:22.325]                   envs[common]]
[18:04:22.325]                 NAMES <- toupper(changed)
[18:04:22.325]                 args <- list()
[18:04:22.325]                 for (kk in seq_along(NAMES)) {
[18:04:22.325]                   name <- changed[[kk]]
[18:04:22.325]                   NAME <- NAMES[[kk]]
[18:04:22.325]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.325]                     next
[18:04:22.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.325]                 }
[18:04:22.325]                 NAMES <- toupper(added)
[18:04:22.325]                 for (kk in seq_along(NAMES)) {
[18:04:22.325]                   name <- added[[kk]]
[18:04:22.325]                   NAME <- NAMES[[kk]]
[18:04:22.325]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.325]                     next
[18:04:22.325]                   args[[name]] <- ""
[18:04:22.325]                 }
[18:04:22.325]                 NAMES <- toupper(removed)
[18:04:22.325]                 for (kk in seq_along(NAMES)) {
[18:04:22.325]                   name <- removed[[kk]]
[18:04:22.325]                   NAME <- NAMES[[kk]]
[18:04:22.325]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.325]                     next
[18:04:22.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.325]                 }
[18:04:22.325]                 if (length(args) > 0) 
[18:04:22.325]                   base::do.call(base::Sys.setenv, args = args)
[18:04:22.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:22.325]             }
[18:04:22.325]             else {
[18:04:22.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:22.325]             }
[18:04:22.325]             {
[18:04:22.325]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:22.325]                   0L) {
[18:04:22.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:22.325]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:22.325]                   base::options(opts)
[18:04:22.325]                 }
[18:04:22.325]                 {
[18:04:22.325]                   {
[18:04:22.325]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:22.325]                     NULL
[18:04:22.325]                   }
[18:04:22.325]                   options(future.plan = NULL)
[18:04:22.325]                   if (is.na(NA_character_)) 
[18:04:22.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:22.325]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:22.325]                     .init = FALSE)
[18:04:22.325]                 }
[18:04:22.325]             }
[18:04:22.325]         }
[18:04:22.325]     })
[18:04:22.325]     if (TRUE) {
[18:04:22.325]         base::sink(type = "output", split = FALSE)
[18:04:22.325]         if (TRUE) {
[18:04:22.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:22.325]         }
[18:04:22.325]         else {
[18:04:22.325]             ...future.result["stdout"] <- base::list(NULL)
[18:04:22.325]         }
[18:04:22.325]         base::close(...future.stdout)
[18:04:22.325]         ...future.stdout <- NULL
[18:04:22.325]     }
[18:04:22.325]     ...future.result$conditions <- ...future.conditions
[18:04:22.325]     ...future.result$finished <- base::Sys.time()
[18:04:22.325]     ...future.result
[18:04:22.325] }
[18:04:22.330] requestCore(): workers = 2
[18:04:22.334] MulticoreFuture started
[18:04:22.335] - Launch lazy future ... done
[18:04:22.335] run() for ‘MulticoreFuture’ ... done
[18:04:22.336] getGlobalsAndPackages() ...
[18:04:22.336] plan(): Setting new future strategy stack:
[18:04:22.336] Searching for globals...
[18:04:22.338] 
[18:04:22.336] List of future strategies:
[18:04:22.336] 1. sequential:
[18:04:22.336]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:22.336]    - tweaked: FALSE
[18:04:22.336]    - call: NULL
[18:04:22.338] Searching for globals ... DONE
[18:04:22.339] plan(): nbrOfWorkers() = 1
[18:04:22.339] - globals: [0] <none>
[18:04:22.339] getGlobalsAndPackages() ... DONE
[18:04:22.341] run() for ‘Future’ ...
[18:04:22.341] - state: ‘created’
[18:04:22.342] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:22.344] plan(): Setting new future strategy stack:
[18:04:22.345] List of future strategies:
[18:04:22.345] 1. multicore:
[18:04:22.345]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:22.345]    - tweaked: FALSE
[18:04:22.345]    - call: plan(strategy)
[18:04:22.353] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:22.353] plan(): nbrOfWorkers() = 2
[18:04:22.353] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:22.354]   - Field: ‘label’
[18:04:22.354]   - Field: ‘local’
[18:04:22.355]   - Field: ‘owner’
[18:04:22.355]   - Field: ‘envir’
[18:04:22.355]   - Field: ‘workers’
[18:04:22.355]   - Field: ‘packages’
[18:04:22.356]   - Field: ‘gc’
[18:04:22.356]   - Field: ‘job’
[18:04:22.356]   - Field: ‘conditions’
[18:04:22.357]   - Field: ‘expr’
[18:04:22.357]   - Field: ‘uuid’
[18:04:22.357]   - Field: ‘seed’
[18:04:22.358]   - Field: ‘version’
[18:04:22.358]   - Field: ‘result’
[18:04:22.358]   - Field: ‘asynchronous’
[18:04:22.358]   - Field: ‘calls’
[18:04:22.359]   - Field: ‘globals’
[18:04:22.359]   - Field: ‘stdout’
[18:04:22.359]   - Field: ‘earlySignal’
[18:04:22.360]   - Field: ‘lazy’
[18:04:22.360]   - Field: ‘state’
[18:04:22.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:22.361] - Launch lazy future ...
[18:04:22.362] Packages needed by the future expression (n = 0): <none>
[18:04:22.362] Packages needed by future strategies (n = 0): <none>
[18:04:22.363] {
[18:04:22.363]     {
[18:04:22.363]         {
[18:04:22.363]             ...future.startTime <- base::Sys.time()
[18:04:22.363]             {
[18:04:22.363]                 {
[18:04:22.363]                   {
[18:04:22.363]                     {
[18:04:22.363]                       base::local({
[18:04:22.363]                         has_future <- base::requireNamespace("future", 
[18:04:22.363]                           quietly = TRUE)
[18:04:22.363]                         if (has_future) {
[18:04:22.363]                           ns <- base::getNamespace("future")
[18:04:22.363]                           version <- ns[[".package"]][["version"]]
[18:04:22.363]                           if (is.null(version)) 
[18:04:22.363]                             version <- utils::packageVersion("future")
[18:04:22.363]                         }
[18:04:22.363]                         else {
[18:04:22.363]                           version <- NULL
[18:04:22.363]                         }
[18:04:22.363]                         if (!has_future || version < "1.8.0") {
[18:04:22.363]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:22.363]                             "", base::R.version$version.string), 
[18:04:22.363]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:22.363]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:22.363]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:22.363]                               "release", "version")], collapse = " "), 
[18:04:22.363]                             hostname = base::Sys.info()[["nodename"]])
[18:04:22.363]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:22.363]                             info)
[18:04:22.363]                           info <- base::paste(info, collapse = "; ")
[18:04:22.363]                           if (!has_future) {
[18:04:22.363]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:22.363]                               info)
[18:04:22.363]                           }
[18:04:22.363]                           else {
[18:04:22.363]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:22.363]                               info, version)
[18:04:22.363]                           }
[18:04:22.363]                           base::stop(msg)
[18:04:22.363]                         }
[18:04:22.363]                       })
[18:04:22.363]                     }
[18:04:22.363]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:22.363]                     base::options(mc.cores = 1L)
[18:04:22.363]                   }
[18:04:22.363]                   ...future.strategy.old <- future::plan("list")
[18:04:22.363]                   options(future.plan = NULL)
[18:04:22.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:22.363]                 }
[18:04:22.363]                 ...future.workdir <- getwd()
[18:04:22.363]             }
[18:04:22.363]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:22.363]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:22.363]         }
[18:04:22.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:22.363]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:22.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:22.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:22.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:22.363]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:22.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:22.363]             base::names(...future.oldOptions))
[18:04:22.363]     }
[18:04:22.363]     if (FALSE) {
[18:04:22.363]     }
[18:04:22.363]     else {
[18:04:22.363]         if (TRUE) {
[18:04:22.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:22.363]                 open = "w")
[18:04:22.363]         }
[18:04:22.363]         else {
[18:04:22.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:22.363]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:22.363]         }
[18:04:22.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:22.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:22.363]             base::sink(type = "output", split = FALSE)
[18:04:22.363]             base::close(...future.stdout)
[18:04:22.363]         }, add = TRUE)
[18:04:22.363]     }
[18:04:22.363]     ...future.frame <- base::sys.nframe()
[18:04:22.363]     ...future.conditions <- base::list()
[18:04:22.363]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:22.363]     if (FALSE) {
[18:04:22.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:22.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:22.363]     }
[18:04:22.363]     ...future.result <- base::tryCatch({
[18:04:22.363]         base::withCallingHandlers({
[18:04:22.363]             ...future.value <- base::withVisible(base::local({
[18:04:22.363]                 withCallingHandlers({
[18:04:22.363]                   NULL
[18:04:22.363]                 }, immediateCondition = function(cond) {
[18:04:22.363]                   save_rds <- function (object, pathname, ...) 
[18:04:22.363]                   {
[18:04:22.363]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:22.363]                     if (file_test("-f", pathname_tmp)) {
[18:04:22.363]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.363]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:22.363]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.363]                         fi_tmp[["mtime"]])
[18:04:22.363]                     }
[18:04:22.363]                     tryCatch({
[18:04:22.363]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:22.363]                     }, error = function(ex) {
[18:04:22.363]                       msg <- conditionMessage(ex)
[18:04:22.363]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.363]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:22.363]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.363]                         fi_tmp[["mtime"]], msg)
[18:04:22.363]                       ex$message <- msg
[18:04:22.363]                       stop(ex)
[18:04:22.363]                     })
[18:04:22.363]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:22.363]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:22.363]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:22.363]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.363]                       fi <- file.info(pathname)
[18:04:22.363]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:22.363]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.363]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:22.363]                         fi[["size"]], fi[["mtime"]])
[18:04:22.363]                       stop(msg)
[18:04:22.363]                     }
[18:04:22.363]                     invisible(pathname)
[18:04:22.363]                   }
[18:04:22.363]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:22.363]                     rootPath = tempdir()) 
[18:04:22.363]                   {
[18:04:22.363]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:22.363]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:22.363]                       tmpdir = path, fileext = ".rds")
[18:04:22.363]                     save_rds(obj, file)
[18:04:22.363]                   }
[18:04:22.363]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:22.363]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.363]                   {
[18:04:22.363]                     inherits <- base::inherits
[18:04:22.363]                     invokeRestart <- base::invokeRestart
[18:04:22.363]                     is.null <- base::is.null
[18:04:22.363]                     muffled <- FALSE
[18:04:22.363]                     if (inherits(cond, "message")) {
[18:04:22.363]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:22.363]                       if (muffled) 
[18:04:22.363]                         invokeRestart("muffleMessage")
[18:04:22.363]                     }
[18:04:22.363]                     else if (inherits(cond, "warning")) {
[18:04:22.363]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:22.363]                       if (muffled) 
[18:04:22.363]                         invokeRestart("muffleWarning")
[18:04:22.363]                     }
[18:04:22.363]                     else if (inherits(cond, "condition")) {
[18:04:22.363]                       if (!is.null(pattern)) {
[18:04:22.363]                         computeRestarts <- base::computeRestarts
[18:04:22.363]                         grepl <- base::grepl
[18:04:22.363]                         restarts <- computeRestarts(cond)
[18:04:22.363]                         for (restart in restarts) {
[18:04:22.363]                           name <- restart$name
[18:04:22.363]                           if (is.null(name)) 
[18:04:22.363]                             next
[18:04:22.363]                           if (!grepl(pattern, name)) 
[18:04:22.363]                             next
[18:04:22.363]                           invokeRestart(restart)
[18:04:22.363]                           muffled <- TRUE
[18:04:22.363]                           break
[18:04:22.363]                         }
[18:04:22.363]                       }
[18:04:22.363]                     }
[18:04:22.363]                     invisible(muffled)
[18:04:22.363]                   }
[18:04:22.363]                   muffleCondition(cond)
[18:04:22.363]                 })
[18:04:22.363]             }))
[18:04:22.363]             future::FutureResult(value = ...future.value$value, 
[18:04:22.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.363]                   ...future.rng), globalenv = if (FALSE) 
[18:04:22.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:22.363]                     ...future.globalenv.names))
[18:04:22.363]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:22.363]         }, condition = base::local({
[18:04:22.363]             c <- base::c
[18:04:22.363]             inherits <- base::inherits
[18:04:22.363]             invokeRestart <- base::invokeRestart
[18:04:22.363]             length <- base::length
[18:04:22.363]             list <- base::list
[18:04:22.363]             seq.int <- base::seq.int
[18:04:22.363]             signalCondition <- base::signalCondition
[18:04:22.363]             sys.calls <- base::sys.calls
[18:04:22.363]             `[[` <- base::`[[`
[18:04:22.363]             `+` <- base::`+`
[18:04:22.363]             `<<-` <- base::`<<-`
[18:04:22.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:22.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:22.363]                   3L)]
[18:04:22.363]             }
[18:04:22.363]             function(cond) {
[18:04:22.363]                 is_error <- inherits(cond, "error")
[18:04:22.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:22.363]                   NULL)
[18:04:22.363]                 if (is_error) {
[18:04:22.363]                   sessionInformation <- function() {
[18:04:22.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:22.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:22.363]                       search = base::search(), system = base::Sys.info())
[18:04:22.363]                   }
[18:04:22.363]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:22.363]                     cond$call), session = sessionInformation(), 
[18:04:22.363]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:22.363]                   signalCondition(cond)
[18:04:22.363]                 }
[18:04:22.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:22.363]                 "immediateCondition"))) {
[18:04:22.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:22.363]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:22.363]                   if (TRUE && !signal) {
[18:04:22.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.363]                     {
[18:04:22.363]                       inherits <- base::inherits
[18:04:22.363]                       invokeRestart <- base::invokeRestart
[18:04:22.363]                       is.null <- base::is.null
[18:04:22.363]                       muffled <- FALSE
[18:04:22.363]                       if (inherits(cond, "message")) {
[18:04:22.363]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.363]                         if (muffled) 
[18:04:22.363]                           invokeRestart("muffleMessage")
[18:04:22.363]                       }
[18:04:22.363]                       else if (inherits(cond, "warning")) {
[18:04:22.363]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.363]                         if (muffled) 
[18:04:22.363]                           invokeRestart("muffleWarning")
[18:04:22.363]                       }
[18:04:22.363]                       else if (inherits(cond, "condition")) {
[18:04:22.363]                         if (!is.null(pattern)) {
[18:04:22.363]                           computeRestarts <- base::computeRestarts
[18:04:22.363]                           grepl <- base::grepl
[18:04:22.363]                           restarts <- computeRestarts(cond)
[18:04:22.363]                           for (restart in restarts) {
[18:04:22.363]                             name <- restart$name
[18:04:22.363]                             if (is.null(name)) 
[18:04:22.363]                               next
[18:04:22.363]                             if (!grepl(pattern, name)) 
[18:04:22.363]                               next
[18:04:22.363]                             invokeRestart(restart)
[18:04:22.363]                             muffled <- TRUE
[18:04:22.363]                             break
[18:04:22.363]                           }
[18:04:22.363]                         }
[18:04:22.363]                       }
[18:04:22.363]                       invisible(muffled)
[18:04:22.363]                     }
[18:04:22.363]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.363]                   }
[18:04:22.363]                 }
[18:04:22.363]                 else {
[18:04:22.363]                   if (TRUE) {
[18:04:22.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.363]                     {
[18:04:22.363]                       inherits <- base::inherits
[18:04:22.363]                       invokeRestart <- base::invokeRestart
[18:04:22.363]                       is.null <- base::is.null
[18:04:22.363]                       muffled <- FALSE
[18:04:22.363]                       if (inherits(cond, "message")) {
[18:04:22.363]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.363]                         if (muffled) 
[18:04:22.363]                           invokeRestart("muffleMessage")
[18:04:22.363]                       }
[18:04:22.363]                       else if (inherits(cond, "warning")) {
[18:04:22.363]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.363]                         if (muffled) 
[18:04:22.363]                           invokeRestart("muffleWarning")
[18:04:22.363]                       }
[18:04:22.363]                       else if (inherits(cond, "condition")) {
[18:04:22.363]                         if (!is.null(pattern)) {
[18:04:22.363]                           computeRestarts <- base::computeRestarts
[18:04:22.363]                           grepl <- base::grepl
[18:04:22.363]                           restarts <- computeRestarts(cond)
[18:04:22.363]                           for (restart in restarts) {
[18:04:22.363]                             name <- restart$name
[18:04:22.363]                             if (is.null(name)) 
[18:04:22.363]                               next
[18:04:22.363]                             if (!grepl(pattern, name)) 
[18:04:22.363]                               next
[18:04:22.363]                             invokeRestart(restart)
[18:04:22.363]                             muffled <- TRUE
[18:04:22.363]                             break
[18:04:22.363]                           }
[18:04:22.363]                         }
[18:04:22.363]                       }
[18:04:22.363]                       invisible(muffled)
[18:04:22.363]                     }
[18:04:22.363]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.363]                   }
[18:04:22.363]                 }
[18:04:22.363]             }
[18:04:22.363]         }))
[18:04:22.363]     }, error = function(ex) {
[18:04:22.363]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:22.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.363]                 ...future.rng), started = ...future.startTime, 
[18:04:22.363]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:22.363]             version = "1.8"), class = "FutureResult")
[18:04:22.363]     }, finally = {
[18:04:22.363]         if (!identical(...future.workdir, getwd())) 
[18:04:22.363]             setwd(...future.workdir)
[18:04:22.363]         {
[18:04:22.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:22.363]                 ...future.oldOptions$nwarnings <- NULL
[18:04:22.363]             }
[18:04:22.363]             base::options(...future.oldOptions)
[18:04:22.363]             if (.Platform$OS.type == "windows") {
[18:04:22.363]                 old_names <- names(...future.oldEnvVars)
[18:04:22.363]                 envs <- base::Sys.getenv()
[18:04:22.363]                 names <- names(envs)
[18:04:22.363]                 common <- intersect(names, old_names)
[18:04:22.363]                 added <- setdiff(names, old_names)
[18:04:22.363]                 removed <- setdiff(old_names, names)
[18:04:22.363]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:22.363]                   envs[common]]
[18:04:22.363]                 NAMES <- toupper(changed)
[18:04:22.363]                 args <- list()
[18:04:22.363]                 for (kk in seq_along(NAMES)) {
[18:04:22.363]                   name <- changed[[kk]]
[18:04:22.363]                   NAME <- NAMES[[kk]]
[18:04:22.363]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.363]                     next
[18:04:22.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.363]                 }
[18:04:22.363]                 NAMES <- toupper(added)
[18:04:22.363]                 for (kk in seq_along(NAMES)) {
[18:04:22.363]                   name <- added[[kk]]
[18:04:22.363]                   NAME <- NAMES[[kk]]
[18:04:22.363]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.363]                     next
[18:04:22.363]                   args[[name]] <- ""
[18:04:22.363]                 }
[18:04:22.363]                 NAMES <- toupper(removed)
[18:04:22.363]                 for (kk in seq_along(NAMES)) {
[18:04:22.363]                   name <- removed[[kk]]
[18:04:22.363]                   NAME <- NAMES[[kk]]
[18:04:22.363]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.363]                     next
[18:04:22.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.363]                 }
[18:04:22.363]                 if (length(args) > 0) 
[18:04:22.363]                   base::do.call(base::Sys.setenv, args = args)
[18:04:22.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:22.363]             }
[18:04:22.363]             else {
[18:04:22.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:22.363]             }
[18:04:22.363]             {
[18:04:22.363]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:22.363]                   0L) {
[18:04:22.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:22.363]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:22.363]                   base::options(opts)
[18:04:22.363]                 }
[18:04:22.363]                 {
[18:04:22.363]                   {
[18:04:22.363]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:22.363]                     NULL
[18:04:22.363]                   }
[18:04:22.363]                   options(future.plan = NULL)
[18:04:22.363]                   if (is.na(NA_character_)) 
[18:04:22.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:22.363]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:22.363]                     .init = FALSE)
[18:04:22.363]                 }
[18:04:22.363]             }
[18:04:22.363]         }
[18:04:22.363]     })
[18:04:22.363]     if (TRUE) {
[18:04:22.363]         base::sink(type = "output", split = FALSE)
[18:04:22.363]         if (TRUE) {
[18:04:22.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:22.363]         }
[18:04:22.363]         else {
[18:04:22.363]             ...future.result["stdout"] <- base::list(NULL)
[18:04:22.363]         }
[18:04:22.363]         base::close(...future.stdout)
[18:04:22.363]         ...future.stdout <- NULL
[18:04:22.363]     }
[18:04:22.363]     ...future.result$conditions <- ...future.conditions
[18:04:22.363]     ...future.result$finished <- base::Sys.time()
[18:04:22.363]     ...future.result
[18:04:22.363] }
[18:04:22.372] requestCore(): workers = 2
[18:04:22.376] MulticoreFuture started
[18:04:22.377] - Launch lazy future ... done
[18:04:22.378] run() for ‘MulticoreFuture’ ... done
[18:04:22.378] plan(): Setting new future strategy stack:
[18:04:22.380] getGlobalsAndPackages() ...
[18:04:22.380] Searching for globals...
[18:04:22.379] List of future strategies:
[18:04:22.379] 1. sequential:
[18:04:22.379]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:22.379]    - tweaked: FALSE
[18:04:22.379]    - call: NULL
[18:04:22.381] plan(): nbrOfWorkers() = 1
[18:04:22.383] - globals found: [1] ‘{’
[18:04:22.383] Searching for globals ... DONE
[18:04:22.384] Resolving globals: FALSE
[18:04:22.385] 
[18:04:22.385] 
[18:04:22.385] plan(): Setting new future strategy stack:
[18:04:22.385] getGlobalsAndPackages() ... DONE
[18:04:22.385] List of future strategies:
[18:04:22.385] 1. multicore:
[18:04:22.385]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:22.385]    - tweaked: FALSE
[18:04:22.385]    - call: plan(strategy)
[18:04:22.386] run() for ‘Future’ ...
[18:04:22.387] - state: ‘created’
[18:04:22.387] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:22.394] plan(): nbrOfWorkers() = 2
[18:04:22.395] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:22.396] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:22.396]   - Field: ‘label’
[18:04:22.397]   - Field: ‘local’
[18:04:22.397]   - Field: ‘owner’
[18:04:22.397]   - Field: ‘envir’
[18:04:22.398]   - Field: ‘workers’
[18:04:22.398]   - Field: ‘packages’
[18:04:22.398]   - Field: ‘gc’
[18:04:22.398]   - Field: ‘job’
[18:04:22.399]   - Field: ‘conditions’
[18:04:22.399]   - Field: ‘expr’
[18:04:22.399]   - Field: ‘uuid’
[18:04:22.400]   - Field: ‘seed’
[18:04:22.400]   - Field: ‘version’
[18:04:22.400]   - Field: ‘result’
[18:04:22.400]   - Field: ‘asynchronous’
[18:04:22.401]   - Field: ‘calls’
[18:04:22.401]   - Field: ‘globals’
[18:04:22.401]   - Field: ‘stdout’
[18:04:22.402]   - Field: ‘earlySignal’
[18:04:22.402]   - Field: ‘lazy’
[18:04:22.402]   - Field: ‘state’
[18:04:22.402] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:22.403] - Launch lazy future ...
[18:04:22.404] Packages needed by the future expression (n = 0): <none>
[18:04:22.404] Packages needed by future strategies (n = 0): <none>
[18:04:22.406] {
[18:04:22.406]     {
[18:04:22.406]         {
[18:04:22.406]             ...future.startTime <- base::Sys.time()
[18:04:22.406]             {
[18:04:22.406]                 {
[18:04:22.406]                   {
[18:04:22.406]                     {
[18:04:22.406]                       base::local({
[18:04:22.406]                         has_future <- base::requireNamespace("future", 
[18:04:22.406]                           quietly = TRUE)
[18:04:22.406]                         if (has_future) {
[18:04:22.406]                           ns <- base::getNamespace("future")
[18:04:22.406]                           version <- ns[[".package"]][["version"]]
[18:04:22.406]                           if (is.null(version)) 
[18:04:22.406]                             version <- utils::packageVersion("future")
[18:04:22.406]                         }
[18:04:22.406]                         else {
[18:04:22.406]                           version <- NULL
[18:04:22.406]                         }
[18:04:22.406]                         if (!has_future || version < "1.8.0") {
[18:04:22.406]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:22.406]                             "", base::R.version$version.string), 
[18:04:22.406]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:22.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:22.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:22.406]                               "release", "version")], collapse = " "), 
[18:04:22.406]                             hostname = base::Sys.info()[["nodename"]])
[18:04:22.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:22.406]                             info)
[18:04:22.406]                           info <- base::paste(info, collapse = "; ")
[18:04:22.406]                           if (!has_future) {
[18:04:22.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:22.406]                               info)
[18:04:22.406]                           }
[18:04:22.406]                           else {
[18:04:22.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:22.406]                               info, version)
[18:04:22.406]                           }
[18:04:22.406]                           base::stop(msg)
[18:04:22.406]                         }
[18:04:22.406]                       })
[18:04:22.406]                     }
[18:04:22.406]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:22.406]                     base::options(mc.cores = 1L)
[18:04:22.406]                   }
[18:04:22.406]                   ...future.strategy.old <- future::plan("list")
[18:04:22.406]                   options(future.plan = NULL)
[18:04:22.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:22.406]                 }
[18:04:22.406]                 ...future.workdir <- getwd()
[18:04:22.406]             }
[18:04:22.406]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:22.406]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:22.406]         }
[18:04:22.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:22.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:22.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:22.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:22.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:22.406]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:22.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:22.406]             base::names(...future.oldOptions))
[18:04:22.406]     }
[18:04:22.406]     if (FALSE) {
[18:04:22.406]     }
[18:04:22.406]     else {
[18:04:22.406]         if (TRUE) {
[18:04:22.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:22.406]                 open = "w")
[18:04:22.406]         }
[18:04:22.406]         else {
[18:04:22.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:22.406]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:22.406]         }
[18:04:22.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:22.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:22.406]             base::sink(type = "output", split = FALSE)
[18:04:22.406]             base::close(...future.stdout)
[18:04:22.406]         }, add = TRUE)
[18:04:22.406]     }
[18:04:22.406]     ...future.frame <- base::sys.nframe()
[18:04:22.406]     ...future.conditions <- base::list()
[18:04:22.406]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:22.406]     if (FALSE) {
[18:04:22.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:22.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:22.406]     }
[18:04:22.406]     ...future.result <- base::tryCatch({
[18:04:22.406]         base::withCallingHandlers({
[18:04:22.406]             ...future.value <- base::withVisible(base::local({
[18:04:22.406]                 withCallingHandlers({
[18:04:22.406]                   {
[18:04:22.406]                     4
[18:04:22.406]                   }
[18:04:22.406]                 }, immediateCondition = function(cond) {
[18:04:22.406]                   save_rds <- function (object, pathname, ...) 
[18:04:22.406]                   {
[18:04:22.406]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:22.406]                     if (file_test("-f", pathname_tmp)) {
[18:04:22.406]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.406]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:22.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.406]                         fi_tmp[["mtime"]])
[18:04:22.406]                     }
[18:04:22.406]                     tryCatch({
[18:04:22.406]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:22.406]                     }, error = function(ex) {
[18:04:22.406]                       msg <- conditionMessage(ex)
[18:04:22.406]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.406]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:22.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.406]                         fi_tmp[["mtime"]], msg)
[18:04:22.406]                       ex$message <- msg
[18:04:22.406]                       stop(ex)
[18:04:22.406]                     })
[18:04:22.406]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:22.406]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:22.406]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:22.406]                       fi_tmp <- file.info(pathname_tmp)
[18:04:22.406]                       fi <- file.info(pathname)
[18:04:22.406]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:22.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:22.406]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:22.406]                         fi[["size"]], fi[["mtime"]])
[18:04:22.406]                       stop(msg)
[18:04:22.406]                     }
[18:04:22.406]                     invisible(pathname)
[18:04:22.406]                   }
[18:04:22.406]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:22.406]                     rootPath = tempdir()) 
[18:04:22.406]                   {
[18:04:22.406]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:22.406]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:22.406]                       tmpdir = path, fileext = ".rds")
[18:04:22.406]                     save_rds(obj, file)
[18:04:22.406]                   }
[18:04:22.406]                   saveImmediateCondition(cond, path = "/tmp/RtmpZUhzkP/.future/immediateConditions")
[18:04:22.406]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.406]                   {
[18:04:22.406]                     inherits <- base::inherits
[18:04:22.406]                     invokeRestart <- base::invokeRestart
[18:04:22.406]                     is.null <- base::is.null
[18:04:22.406]                     muffled <- FALSE
[18:04:22.406]                     if (inherits(cond, "message")) {
[18:04:22.406]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:22.406]                       if (muffled) 
[18:04:22.406]                         invokeRestart("muffleMessage")
[18:04:22.406]                     }
[18:04:22.406]                     else if (inherits(cond, "warning")) {
[18:04:22.406]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:22.406]                       if (muffled) 
[18:04:22.406]                         invokeRestart("muffleWarning")
[18:04:22.406]                     }
[18:04:22.406]                     else if (inherits(cond, "condition")) {
[18:04:22.406]                       if (!is.null(pattern)) {
[18:04:22.406]                         computeRestarts <- base::computeRestarts
[18:04:22.406]                         grepl <- base::grepl
[18:04:22.406]                         restarts <- computeRestarts(cond)
[18:04:22.406]                         for (restart in restarts) {
[18:04:22.406]                           name <- restart$name
[18:04:22.406]                           if (is.null(name)) 
[18:04:22.406]                             next
[18:04:22.406]                           if (!grepl(pattern, name)) 
[18:04:22.406]                             next
[18:04:22.406]                           invokeRestart(restart)
[18:04:22.406]                           muffled <- TRUE
[18:04:22.406]                           break
[18:04:22.406]                         }
[18:04:22.406]                       }
[18:04:22.406]                     }
[18:04:22.406]                     invisible(muffled)
[18:04:22.406]                   }
[18:04:22.406]                   muffleCondition(cond)
[18:04:22.406]                 })
[18:04:22.406]             }))
[18:04:22.406]             future::FutureResult(value = ...future.value$value, 
[18:04:22.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.406]                   ...future.rng), globalenv = if (FALSE) 
[18:04:22.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:22.406]                     ...future.globalenv.names))
[18:04:22.406]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:22.406]         }, condition = base::local({
[18:04:22.406]             c <- base::c
[18:04:22.406]             inherits <- base::inherits
[18:04:22.406]             invokeRestart <- base::invokeRestart
[18:04:22.406]             length <- base::length
[18:04:22.406]             list <- base::list
[18:04:22.406]             seq.int <- base::seq.int
[18:04:22.406]             signalCondition <- base::signalCondition
[18:04:22.406]             sys.calls <- base::sys.calls
[18:04:22.406]             `[[` <- base::`[[`
[18:04:22.406]             `+` <- base::`+`
[18:04:22.406]             `<<-` <- base::`<<-`
[18:04:22.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:22.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:22.406]                   3L)]
[18:04:22.406]             }
[18:04:22.406]             function(cond) {
[18:04:22.406]                 is_error <- inherits(cond, "error")
[18:04:22.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:22.406]                   NULL)
[18:04:22.406]                 if (is_error) {
[18:04:22.406]                   sessionInformation <- function() {
[18:04:22.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:22.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:22.406]                       search = base::search(), system = base::Sys.info())
[18:04:22.406]                   }
[18:04:22.406]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:22.406]                     cond$call), session = sessionInformation(), 
[18:04:22.406]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:22.406]                   signalCondition(cond)
[18:04:22.406]                 }
[18:04:22.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:22.406]                 "immediateCondition"))) {
[18:04:22.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:22.406]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:22.406]                   if (TRUE && !signal) {
[18:04:22.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.406]                     {
[18:04:22.406]                       inherits <- base::inherits
[18:04:22.406]                       invokeRestart <- base::invokeRestart
[18:04:22.406]                       is.null <- base::is.null
[18:04:22.406]                       muffled <- FALSE
[18:04:22.406]                       if (inherits(cond, "message")) {
[18:04:22.406]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.406]                         if (muffled) 
[18:04:22.406]                           invokeRestart("muffleMessage")
[18:04:22.406]                       }
[18:04:22.406]                       else if (inherits(cond, "warning")) {
[18:04:22.406]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.406]                         if (muffled) 
[18:04:22.406]                           invokeRestart("muffleWarning")
[18:04:22.406]                       }
[18:04:22.406]                       else if (inherits(cond, "condition")) {
[18:04:22.406]                         if (!is.null(pattern)) {
[18:04:22.406]                           computeRestarts <- base::computeRestarts
[18:04:22.406]                           grepl <- base::grepl
[18:04:22.406]                           restarts <- computeRestarts(cond)
[18:04:22.406]                           for (restart in restarts) {
[18:04:22.406]                             name <- restart$name
[18:04:22.406]                             if (is.null(name)) 
[18:04:22.406]                               next
[18:04:22.406]                             if (!grepl(pattern, name)) 
[18:04:22.406]                               next
[18:04:22.406]                             invokeRestart(restart)
[18:04:22.406]                             muffled <- TRUE
[18:04:22.406]                             break
[18:04:22.406]                           }
[18:04:22.406]                         }
[18:04:22.406]                       }
[18:04:22.406]                       invisible(muffled)
[18:04:22.406]                     }
[18:04:22.406]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.406]                   }
[18:04:22.406]                 }
[18:04:22.406]                 else {
[18:04:22.406]                   if (TRUE) {
[18:04:22.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.406]                     {
[18:04:22.406]                       inherits <- base::inherits
[18:04:22.406]                       invokeRestart <- base::invokeRestart
[18:04:22.406]                       is.null <- base::is.null
[18:04:22.406]                       muffled <- FALSE
[18:04:22.406]                       if (inherits(cond, "message")) {
[18:04:22.406]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.406]                         if (muffled) 
[18:04:22.406]                           invokeRestart("muffleMessage")
[18:04:22.406]                       }
[18:04:22.406]                       else if (inherits(cond, "warning")) {
[18:04:22.406]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.406]                         if (muffled) 
[18:04:22.406]                           invokeRestart("muffleWarning")
[18:04:22.406]                       }
[18:04:22.406]                       else if (inherits(cond, "condition")) {
[18:04:22.406]                         if (!is.null(pattern)) {
[18:04:22.406]                           computeRestarts <- base::computeRestarts
[18:04:22.406]                           grepl <- base::grepl
[18:04:22.406]                           restarts <- computeRestarts(cond)
[18:04:22.406]                           for (restart in restarts) {
[18:04:22.406]                             name <- restart$name
[18:04:22.406]                             if (is.null(name)) 
[18:04:22.406]                               next
[18:04:22.406]                             if (!grepl(pattern, name)) 
[18:04:22.406]                               next
[18:04:22.406]                             invokeRestart(restart)
[18:04:22.406]                             muffled <- TRUE
[18:04:22.406]                             break
[18:04:22.406]                           }
[18:04:22.406]                         }
[18:04:22.406]                       }
[18:04:22.406]                       invisible(muffled)
[18:04:22.406]                     }
[18:04:22.406]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.406]                   }
[18:04:22.406]                 }
[18:04:22.406]             }
[18:04:22.406]         }))
[18:04:22.406]     }, error = function(ex) {
[18:04:22.406]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:22.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.406]                 ...future.rng), started = ...future.startTime, 
[18:04:22.406]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:22.406]             version = "1.8"), class = "FutureResult")
[18:04:22.406]     }, finally = {
[18:04:22.406]         if (!identical(...future.workdir, getwd())) 
[18:04:22.406]             setwd(...future.workdir)
[18:04:22.406]         {
[18:04:22.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:22.406]                 ...future.oldOptions$nwarnings <- NULL
[18:04:22.406]             }
[18:04:22.406]             base::options(...future.oldOptions)
[18:04:22.406]             if (.Platform$OS.type == "windows") {
[18:04:22.406]                 old_names <- names(...future.oldEnvVars)
[18:04:22.406]                 envs <- base::Sys.getenv()
[18:04:22.406]                 names <- names(envs)
[18:04:22.406]                 common <- intersect(names, old_names)
[18:04:22.406]                 added <- setdiff(names, old_names)
[18:04:22.406]                 removed <- setdiff(old_names, names)
[18:04:22.406]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:22.406]                   envs[common]]
[18:04:22.406]                 NAMES <- toupper(changed)
[18:04:22.406]                 args <- list()
[18:04:22.406]                 for (kk in seq_along(NAMES)) {
[18:04:22.406]                   name <- changed[[kk]]
[18:04:22.406]                   NAME <- NAMES[[kk]]
[18:04:22.406]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.406]                     next
[18:04:22.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.406]                 }
[18:04:22.406]                 NAMES <- toupper(added)
[18:04:22.406]                 for (kk in seq_along(NAMES)) {
[18:04:22.406]                   name <- added[[kk]]
[18:04:22.406]                   NAME <- NAMES[[kk]]
[18:04:22.406]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.406]                     next
[18:04:22.406]                   args[[name]] <- ""
[18:04:22.406]                 }
[18:04:22.406]                 NAMES <- toupper(removed)
[18:04:22.406]                 for (kk in seq_along(NAMES)) {
[18:04:22.406]                   name <- removed[[kk]]
[18:04:22.406]                   NAME <- NAMES[[kk]]
[18:04:22.406]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.406]                     next
[18:04:22.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.406]                 }
[18:04:22.406]                 if (length(args) > 0) 
[18:04:22.406]                   base::do.call(base::Sys.setenv, args = args)
[18:04:22.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:22.406]             }
[18:04:22.406]             else {
[18:04:22.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:22.406]             }
[18:04:22.406]             {
[18:04:22.406]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:22.406]                   0L) {
[18:04:22.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:22.406]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:22.406]                   base::options(opts)
[18:04:22.406]                 }
[18:04:22.406]                 {
[18:04:22.406]                   {
[18:04:22.406]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:22.406]                     NULL
[18:04:22.406]                   }
[18:04:22.406]                   options(future.plan = NULL)
[18:04:22.406]                   if (is.na(NA_character_)) 
[18:04:22.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:22.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:22.406]                     .init = FALSE)
[18:04:22.406]                 }
[18:04:22.406]             }
[18:04:22.406]         }
[18:04:22.406]     })
[18:04:22.406]     if (TRUE) {
[18:04:22.406]         base::sink(type = "output", split = FALSE)
[18:04:22.406]         if (TRUE) {
[18:04:22.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:22.406]         }
[18:04:22.406]         else {
[18:04:22.406]             ...future.result["stdout"] <- base::list(NULL)
[18:04:22.406]         }
[18:04:22.406]         base::close(...future.stdout)
[18:04:22.406]         ...future.stdout <- NULL
[18:04:22.406]     }
[18:04:22.406]     ...future.result$conditions <- ...future.conditions
[18:04:22.406]     ...future.result$finished <- base::Sys.time()
[18:04:22.406]     ...future.result
[18:04:22.406] }
[18:04:22.412] requestCore(): workers = 2
[18:04:22.413] Poll #1 (0): usedCores() = 2, workers = 2
[18:04:22.425] result() for MulticoreFuture ...
[18:04:22.426] result() for MulticoreFuture ...
[18:04:22.427] result() for MulticoreFuture ... done
[18:04:22.427] result() for MulticoreFuture ... done
[18:04:22.427] result() for MulticoreFuture ...
[18:04:22.428] result() for MulticoreFuture ... done
[18:04:22.432] MulticoreFuture started
[18:04:22.433] - Launch lazy future ... done
[18:04:22.433] run() for ‘MulticoreFuture’ ... done
[18:04:22.434] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5e3c2bd381a0> 
[18:04:22.435] List of future strategies:
[18:04:22.435] 1. sequential:
[18:04:22.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:22.435]    - tweaked: FALSE
[18:04:22.435]    - call: NULL
[18:04:22.437] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5e3c2cdd04c8> 
 - attr(*, "dim.")=[18:04:22.441] plan(): Setting new future strategy stack:
 int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
[18:04:22.441] List of future strategies:
[18:04:22.441] 1. multicore:
[18:04:22.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:22.441]    - tweaked: FALSE
[18:04:22.441]    - call: plan(strategy)
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[18:04:22.455] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:22.464] resolve() on list environment ...
[18:04:22.464]  recursive: 0
[18:04:22.470]  length: 6
[18:04:22.470]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:22.471] signalConditionsASAP(numeric, pos=1) ...
[18:04:22.471] - nx: 6
[18:04:22.471] - relay: TRUE
[18:04:22.472] - stdout: TRUE
[18:04:22.472] - signal: TRUE
[18:04:22.472] - resignal: FALSE
[18:04:22.473] - force: TRUE
[18:04:22.473] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.473] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.474]  - until=2
[18:04:22.474]  - relaying element #2
[18:04:22.474] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.474] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.475] signalConditionsASAP(NULL, pos=1) ... done
[18:04:22.475]  length: 5 (resolved future 1)
[18:04:22.475] Future #2
[18:04:22.476] result() for MulticoreFuture ...
[18:04:22.476] result() for MulticoreFuture ... done
[18:04:22.476] result() for MulticoreFuture ...
[18:04:22.477] result() for MulticoreFuture ... done
[18:04:22.477] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:04:22.477] - nx: 6
[18:04:22.478] - relay: TRUE
[18:04:22.478] - stdout: TRUE
[18:04:22.478] - signal: TRUE
[18:04:22.478] - resignal: FALSE
[18:04:22.479] - force: TRUE
[18:04:22.479] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.479] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:22.480]  - until=2
[18:04:22.480]  - relaying element #2
[18:04:22.480] result() for MulticoreFuture ...
[18:04:22.481] result() for MulticoreFuture ... done
[18:04:22.481] result() for MulticoreFuture ...
[18:04:22.481] result() for MulticoreFuture ... done
[18:04:22.482] result() for MulticoreFuture ...
[18:04:22.482] result() for MulticoreFuture ... done
[18:04:22.482] result() for MulticoreFuture ...
[18:04:22.483] result() for MulticoreFuture ... done
[18:04:22.483] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.483] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.484] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:04:22.484]  length: 4 (resolved future 2)
[18:04:22.485] Future #3
[18:04:22.485] result() for MulticoreFuture ...
[18:04:22.487] result() for MulticoreFuture ...
[18:04:22.487] result() for MulticoreFuture ... done
[18:04:22.487] result() for MulticoreFuture ... done
[18:04:22.488] result() for MulticoreFuture ...
[18:04:22.488] result() for MulticoreFuture ... done
[18:04:22.488] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:04:22.489] - nx: 6
[18:04:22.500] - relay: TRUE
[18:04:22.501] - stdout: TRUE
[18:04:22.501] - signal: TRUE
[18:04:22.502] - resignal: FALSE
[18:04:22.503] - force: TRUE
[18:04:22.504] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.504] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:22.505]  - until=3
[18:04:22.505]  - relaying element #3
[18:04:22.506] result() for MulticoreFuture ...
[18:04:22.506] result() for MulticoreFuture ... done
[18:04:22.507] result() for MulticoreFuture ...
[18:04:22.507] result() for MulticoreFuture ... done
[18:04:22.507] result() for MulticoreFuture ...
[18:04:22.508] result() for MulticoreFuture ... done
[18:04:22.508] result() for MulticoreFuture ...
[18:04:22.508] result() for MulticoreFuture ... done
[18:04:22.509] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.509] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.509] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:04:22.510]  length: 3 (resolved future 3)
[18:04:22.510] Future #4
[18:04:22.511] result() for MulticoreFuture ...
[18:04:22.512] result() for MulticoreFuture ...
[18:04:22.512] result() for MulticoreFuture ... done
[18:04:22.513] result() for MulticoreFuture ... done
[18:04:22.513] result() for MulticoreFuture ...
[18:04:22.513] result() for MulticoreFuture ... done
[18:04:22.514] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:04:22.514] - nx: 6
[18:04:22.514] - relay: TRUE
[18:04:22.514] - stdout: TRUE
[18:04:22.515] - signal: TRUE
[18:04:22.515] - resignal: FALSE
[18:04:22.515] - force: TRUE
[18:04:22.515] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.515] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:22.516]  - until=4
[18:04:22.516]  - relaying element #4
[18:04:22.516] result() for MulticoreFuture ...
[18:04:22.516] result() for MulticoreFuture ... done
[18:04:22.517] result() for MulticoreFuture ...
[18:04:22.517] result() for MulticoreFuture ... done
[18:04:22.517] result() for MulticoreFuture ...
[18:04:22.517] result() for MulticoreFuture ... done
[18:04:22.518] result() for MulticoreFuture ...
[18:04:22.518] result() for MulticoreFuture ... done
[18:04:22.518] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.518] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.518] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:04:22.519]  length: 2 (resolved future 4)
[18:04:22.519] signalConditionsASAP(NULL, pos=5) ...
[18:04:22.519] - nx: 6
[18:04:22.519] - relay: TRUE
[18:04:22.520] - stdout: TRUE
[18:04:22.520] - signal: TRUE
[18:04:22.520] - resignal: FALSE
[18:04:22.520] - force: TRUE
[18:04:22.520] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.521] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.521]  - until=6
[18:04:22.521]  - relaying element #6
[18:04:22.521] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:22.521] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.522] signalConditionsASAP(NULL, pos=5) ... done
[18:04:22.522]  length: 1 (resolved future 5)
[18:04:22.522] signalConditionsASAP(numeric, pos=6) ...
[18:04:22.522] - nx: 6
[18:04:22.523] - relay: TRUE
[18:04:22.523] - stdout: TRUE
[18:04:22.523] - signal: TRUE
[18:04:22.523] - resignal: FALSE
[18:04:22.523] - force: TRUE
[18:04:22.523] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:22.524] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.524]  - until=6
[18:04:22.524] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:22.524] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.525] signalConditionsASAP(numeric, pos=6) ... done
[18:04:22.525]  length: 0 (resolved future 6)
[18:04:22.525] Relaying remaining futures
[18:04:22.525] signalConditionsASAP(NULL, pos=0) ...
[18:04:22.525] - nx: 6
[18:04:22.526] - relay: TRUE
[18:04:22.526] - stdout: TRUE
[18:04:22.526] - signal: TRUE
[18:04:22.526] - resignal: FALSE
[18:04:22.526] - force: TRUE
[18:04:22.527] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:22.527] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:22.527] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:22.527] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:22.527] signalConditionsASAP(NULL, pos=0) ... done
[18:04:22.528] resolve() on list environment ... DONE
[18:04:22.528] result() for MulticoreFuture ...
[18:04:22.528] result() for MulticoreFuture ... done
[18:04:22.528] result() for MulticoreFuture ...
[18:04:22.529] result() for MulticoreFuture ... done
[18:04:22.529] result() for MulticoreFuture ...
[18:04:22.529] result() for MulticoreFuture ... done
[18:04:22.529] result() for MulticoreFuture ...
[18:04:22.530] result() for MulticoreFuture ... done
[18:04:22.530] result() for MulticoreFuture ...
[18:04:22.530] result() for MulticoreFuture ... done
[18:04:22.531] result() for MulticoreFuture ...
[18:04:22.531] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2d0b1660> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[18:04:22.536] plan(): Setting new future strategy stack:
[18:04:22.536] List of future strategies:
[18:04:22.536] 1. multisession:
[18:04:22.536]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:22.536]    - tweaked: FALSE
[18:04:22.536]    - call: plan(strategy)
[18:04:22.537] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:04:22.537] multisession:
[18:04:22.537] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:22.537] - tweaked: FALSE
[18:04:22.537] - call: plan(strategy)
[18:04:22.543] getGlobalsAndPackages() ...
[18:04:22.544] Not searching for globals
[18:04:22.544] - globals: [0] <none>
[18:04:22.544] getGlobalsAndPackages() ... DONE
[18:04:22.545] [local output] makeClusterPSOCK() ...
[18:04:22.551] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:04:22.552] [local output] Base port: 11444
[18:04:22.552] [local output] Getting setup options for 2 cluster nodes ...
[18:04:22.553] [local output]  - Node 1 of 2 ...
[18:04:22.553] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:22.555] [local output] Rscript port: 11444

[18:04:22.555] [local output]  - Node 2 of 2 ...
[18:04:22.556] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:22.557] [local output] Rscript port: 11444

[18:04:22.558] [local output] Getting setup options for 2 cluster nodes ... done
[18:04:22.558] [local output]  - Parallel setup requested for some PSOCK nodes
[18:04:22.559] [local output] Setting up PSOCK nodes in parallel
[18:04:22.559] List of 36
[18:04:22.559]  $ worker          : chr "localhost"
[18:04:22.559]   ..- attr(*, "localhost")= logi TRUE
[18:04:22.559]  $ master          : chr "localhost"
[18:04:22.559]  $ port            : int 11444
[18:04:22.559]  $ connectTimeout  : num 120
[18:04:22.559]  $ timeout         : num 2592000
[18:04:22.559]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:04:22.559]  $ homogeneous     : logi TRUE
[18:04:22.559]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:04:22.559]  $ rscript_envs    : NULL
[18:04:22.559]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:22.559]  $ rscript_startup : NULL
[18:04:22.559]  $ rscript_sh      : chr "sh"
[18:04:22.559]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:22.559]  $ methods         : logi TRUE
[18:04:22.559]  $ socketOptions   : chr "no-delay"
[18:04:22.559]  $ useXDR          : logi FALSE
[18:04:22.559]  $ outfile         : chr "/dev/null"
[18:04:22.559]  $ renice          : int NA
[18:04:22.559]  $ rshcmd          : NULL
[18:04:22.559]  $ user            : chr(0) 
[18:04:22.559]  $ revtunnel       : logi FALSE
[18:04:22.559]  $ rshlogfile      : NULL
[18:04:22.559]  $ rshopts         : chr(0) 
[18:04:22.559]  $ rank            : int 1
[18:04:22.559]  $ manual          : logi FALSE
[18:04:22.559]  $ dryrun          : logi FALSE
[18:04:22.559]  $ quiet           : logi FALSE
[18:04:22.559]  $ setup_strategy  : chr "parallel"
[18:04:22.559]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:22.559]  $ pidfile         : chr "/tmp/RtmpZUhzkP/worker.rank=1.parallelly.parent=322369.4eb4175a0aa82.pid"
[18:04:22.559]  $ rshcmd_label    : NULL
[18:04:22.559]  $ rsh_call        : NULL
[18:04:22.559]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:22.559]  $ localMachine    : logi TRUE
[18:04:22.559]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:04:22.559]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:04:22.559]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:04:22.559]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:04:22.559]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:04:22.559]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:04:22.559]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:04:22.559]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:04:22.559]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:04:22.559]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:04:22.559]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:04:22.559]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:04:22.559]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:04:22.559]  $ arguments       :List of 28
[18:04:22.559]   ..$ worker          : chr "localhost"
[18:04:22.559]   ..$ master          : NULL
[18:04:22.559]   ..$ port            : int 11444
[18:04:22.559]   ..$ connectTimeout  : num 120
[18:04:22.559]   ..$ timeout         : num 2592000
[18:04:22.559]   ..$ rscript         : NULL
[18:04:22.559]   ..$ homogeneous     : NULL
[18:04:22.559]   ..$ rscript_args    : NULL
[18:04:22.559]   ..$ rscript_envs    : NULL
[18:04:22.559]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:22.559]   ..$ rscript_startup : NULL
[18:04:22.559]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:04:22.559]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:22.559]   ..$ methods         : logi TRUE
[18:04:22.559]   ..$ socketOptions   : chr "no-delay"
[18:04:22.559]   ..$ useXDR          : logi FALSE
[18:04:22.559]   ..$ outfile         : chr "/dev/null"
[18:04:22.559]   ..$ renice          : int NA
[18:04:22.559]   ..$ rshcmd          : NULL
[18:04:22.559]   ..$ user            : NULL
[18:04:22.559]   ..$ revtunnel       : logi NA
[18:04:22.559]   ..$ rshlogfile      : NULL
[18:04:22.559]   ..$ rshopts         : NULL
[18:04:22.559]   ..$ rank            : int 1
[18:04:22.559]   ..$ manual          : logi FALSE
[18:04:22.559]   ..$ dryrun          : logi FALSE
[18:04:22.559]   ..$ quiet           : logi FALSE
[18:04:22.559]   ..$ setup_strategy  : chr "parallel"
[18:04:22.559]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:04:22.600] [local output] System call to launch all workers:
[18:04:22.600] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpZUhzkP/worker.rank=1.parallelly.parent=322369.4eb4175a0aa82.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11444 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:04:22.600] [local output] Starting PSOCK main server
[18:04:22.603] [local output] Workers launched
[18:04:22.603] [local output] Waiting for workers to connect back
[18:04:22.604]  - [local output] 0 workers out of 2 ready
[18:04:22.963]  - [local output] 0 workers out of 2 ready
[18:04:22.964]  - [local output] 1 workers out of 2 ready
[18:04:22.970]  - [local output] 1 workers out of 2 ready
[18:04:22.971]  - [local output] 2 workers out of 2 ready
[18:04:22.971] [local output] Launching of workers completed
[18:04:22.971] [local output] Collecting session information from workers
[18:04:22.973] [local output]  - Worker #1 of 2
[18:04:22.974] [local output]  - Worker #2 of 2
[18:04:22.974] [local output] makeClusterPSOCK() ... done
[18:04:22.994] Packages needed by the future expression (n = 0): <none>
[18:04:22.994] Packages needed by future strategies (n = 0): <none>
[18:04:22.995] {
[18:04:22.995]     {
[18:04:22.995]         {
[18:04:22.995]             ...future.startTime <- base::Sys.time()
[18:04:22.995]             {
[18:04:22.995]                 {
[18:04:22.995]                   {
[18:04:22.995]                     {
[18:04:22.995]                       base::local({
[18:04:22.995]                         has_future <- base::requireNamespace("future", 
[18:04:22.995]                           quietly = TRUE)
[18:04:22.995]                         if (has_future) {
[18:04:22.995]                           ns <- base::getNamespace("future")
[18:04:22.995]                           version <- ns[[".package"]][["version"]]
[18:04:22.995]                           if (is.null(version)) 
[18:04:22.995]                             version <- utils::packageVersion("future")
[18:04:22.995]                         }
[18:04:22.995]                         else {
[18:04:22.995]                           version <- NULL
[18:04:22.995]                         }
[18:04:22.995]                         if (!has_future || version < "1.8.0") {
[18:04:22.995]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:22.995]                             "", base::R.version$version.string), 
[18:04:22.995]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:22.995]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:22.995]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:22.995]                               "release", "version")], collapse = " "), 
[18:04:22.995]                             hostname = base::Sys.info()[["nodename"]])
[18:04:22.995]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:22.995]                             info)
[18:04:22.995]                           info <- base::paste(info, collapse = "; ")
[18:04:22.995]                           if (!has_future) {
[18:04:22.995]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:22.995]                               info)
[18:04:22.995]                           }
[18:04:22.995]                           else {
[18:04:22.995]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:22.995]                               info, version)
[18:04:22.995]                           }
[18:04:22.995]                           base::stop(msg)
[18:04:22.995]                         }
[18:04:22.995]                       })
[18:04:22.995]                     }
[18:04:22.995]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:22.995]                     base::options(mc.cores = 1L)
[18:04:22.995]                   }
[18:04:22.995]                   ...future.strategy.old <- future::plan("list")
[18:04:22.995]                   options(future.plan = NULL)
[18:04:22.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:22.995]                 }
[18:04:22.995]                 ...future.workdir <- getwd()
[18:04:22.995]             }
[18:04:22.995]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:22.995]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:22.995]         }
[18:04:22.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:22.995]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:22.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:22.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:22.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:22.995]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:22.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:22.995]             base::names(...future.oldOptions))
[18:04:22.995]     }
[18:04:22.995]     if (FALSE) {
[18:04:22.995]     }
[18:04:22.995]     else {
[18:04:22.995]         if (TRUE) {
[18:04:22.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:22.995]                 open = "w")
[18:04:22.995]         }
[18:04:22.995]         else {
[18:04:22.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:22.995]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:22.995]         }
[18:04:22.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:22.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:22.995]             base::sink(type = "output", split = FALSE)
[18:04:22.995]             base::close(...future.stdout)
[18:04:22.995]         }, add = TRUE)
[18:04:22.995]     }
[18:04:22.995]     ...future.frame <- base::sys.nframe()
[18:04:22.995]     ...future.conditions <- base::list()
[18:04:22.995]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:22.995]     if (FALSE) {
[18:04:22.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:22.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:22.995]     }
[18:04:22.995]     ...future.result <- base::tryCatch({
[18:04:22.995]         base::withCallingHandlers({
[18:04:22.995]             ...future.value <- base::withVisible(base::local({
[18:04:22.995]                 ...future.makeSendCondition <- base::local({
[18:04:22.995]                   sendCondition <- NULL
[18:04:22.995]                   function(frame = 1L) {
[18:04:22.995]                     if (is.function(sendCondition)) 
[18:04:22.995]                       return(sendCondition)
[18:04:22.995]                     ns <- getNamespace("parallel")
[18:04:22.995]                     if (exists("sendData", mode = "function", 
[18:04:22.995]                       envir = ns)) {
[18:04:22.995]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:22.995]                         envir = ns)
[18:04:22.995]                       envir <- sys.frame(frame)
[18:04:22.995]                       master <- NULL
[18:04:22.995]                       while (!identical(envir, .GlobalEnv) && 
[18:04:22.995]                         !identical(envir, emptyenv())) {
[18:04:22.995]                         if (exists("master", mode = "list", envir = envir, 
[18:04:22.995]                           inherits = FALSE)) {
[18:04:22.995]                           master <- get("master", mode = "list", 
[18:04:22.995]                             envir = envir, inherits = FALSE)
[18:04:22.995]                           if (inherits(master, c("SOCKnode", 
[18:04:22.995]                             "SOCK0node"))) {
[18:04:22.995]                             sendCondition <<- function(cond) {
[18:04:22.995]                               data <- list(type = "VALUE", value = cond, 
[18:04:22.995]                                 success = TRUE)
[18:04:22.995]                               parallel_sendData(master, data)
[18:04:22.995]                             }
[18:04:22.995]                             return(sendCondition)
[18:04:22.995]                           }
[18:04:22.995]                         }
[18:04:22.995]                         frame <- frame + 1L
[18:04:22.995]                         envir <- sys.frame(frame)
[18:04:22.995]                       }
[18:04:22.995]                     }
[18:04:22.995]                     sendCondition <<- function(cond) NULL
[18:04:22.995]                   }
[18:04:22.995]                 })
[18:04:22.995]                 withCallingHandlers({
[18:04:22.995]                   NA
[18:04:22.995]                 }, immediateCondition = function(cond) {
[18:04:22.995]                   sendCondition <- ...future.makeSendCondition()
[18:04:22.995]                   sendCondition(cond)
[18:04:22.995]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.995]                   {
[18:04:22.995]                     inherits <- base::inherits
[18:04:22.995]                     invokeRestart <- base::invokeRestart
[18:04:22.995]                     is.null <- base::is.null
[18:04:22.995]                     muffled <- FALSE
[18:04:22.995]                     if (inherits(cond, "message")) {
[18:04:22.995]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:22.995]                       if (muffled) 
[18:04:22.995]                         invokeRestart("muffleMessage")
[18:04:22.995]                     }
[18:04:22.995]                     else if (inherits(cond, "warning")) {
[18:04:22.995]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:22.995]                       if (muffled) 
[18:04:22.995]                         invokeRestart("muffleWarning")
[18:04:22.995]                     }
[18:04:22.995]                     else if (inherits(cond, "condition")) {
[18:04:22.995]                       if (!is.null(pattern)) {
[18:04:22.995]                         computeRestarts <- base::computeRestarts
[18:04:22.995]                         grepl <- base::grepl
[18:04:22.995]                         restarts <- computeRestarts(cond)
[18:04:22.995]                         for (restart in restarts) {
[18:04:22.995]                           name <- restart$name
[18:04:22.995]                           if (is.null(name)) 
[18:04:22.995]                             next
[18:04:22.995]                           if (!grepl(pattern, name)) 
[18:04:22.995]                             next
[18:04:22.995]                           invokeRestart(restart)
[18:04:22.995]                           muffled <- TRUE
[18:04:22.995]                           break
[18:04:22.995]                         }
[18:04:22.995]                       }
[18:04:22.995]                     }
[18:04:22.995]                     invisible(muffled)
[18:04:22.995]                   }
[18:04:22.995]                   muffleCondition(cond)
[18:04:22.995]                 })
[18:04:22.995]             }))
[18:04:22.995]             future::FutureResult(value = ...future.value$value, 
[18:04:22.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.995]                   ...future.rng), globalenv = if (FALSE) 
[18:04:22.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:22.995]                     ...future.globalenv.names))
[18:04:22.995]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:22.995]         }, condition = base::local({
[18:04:22.995]             c <- base::c
[18:04:22.995]             inherits <- base::inherits
[18:04:22.995]             invokeRestart <- base::invokeRestart
[18:04:22.995]             length <- base::length
[18:04:22.995]             list <- base::list
[18:04:22.995]             seq.int <- base::seq.int
[18:04:22.995]             signalCondition <- base::signalCondition
[18:04:22.995]             sys.calls <- base::sys.calls
[18:04:22.995]             `[[` <- base::`[[`
[18:04:22.995]             `+` <- base::`+`
[18:04:22.995]             `<<-` <- base::`<<-`
[18:04:22.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:22.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:22.995]                   3L)]
[18:04:22.995]             }
[18:04:22.995]             function(cond) {
[18:04:22.995]                 is_error <- inherits(cond, "error")
[18:04:22.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:22.995]                   NULL)
[18:04:22.995]                 if (is_error) {
[18:04:22.995]                   sessionInformation <- function() {
[18:04:22.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:22.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:22.995]                       search = base::search(), system = base::Sys.info())
[18:04:22.995]                   }
[18:04:22.995]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:22.995]                     cond$call), session = sessionInformation(), 
[18:04:22.995]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:22.995]                   signalCondition(cond)
[18:04:22.995]                 }
[18:04:22.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:22.995]                 "immediateCondition"))) {
[18:04:22.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:22.995]                   ...future.conditions[[length(...future.conditions) + 
[18:04:22.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:22.995]                   if (TRUE && !signal) {
[18:04:22.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.995]                     {
[18:04:22.995]                       inherits <- base::inherits
[18:04:22.995]                       invokeRestart <- base::invokeRestart
[18:04:22.995]                       is.null <- base::is.null
[18:04:22.995]                       muffled <- FALSE
[18:04:22.995]                       if (inherits(cond, "message")) {
[18:04:22.995]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.995]                         if (muffled) 
[18:04:22.995]                           invokeRestart("muffleMessage")
[18:04:22.995]                       }
[18:04:22.995]                       else if (inherits(cond, "warning")) {
[18:04:22.995]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.995]                         if (muffled) 
[18:04:22.995]                           invokeRestart("muffleWarning")
[18:04:22.995]                       }
[18:04:22.995]                       else if (inherits(cond, "condition")) {
[18:04:22.995]                         if (!is.null(pattern)) {
[18:04:22.995]                           computeRestarts <- base::computeRestarts
[18:04:22.995]                           grepl <- base::grepl
[18:04:22.995]                           restarts <- computeRestarts(cond)
[18:04:22.995]                           for (restart in restarts) {
[18:04:22.995]                             name <- restart$name
[18:04:22.995]                             if (is.null(name)) 
[18:04:22.995]                               next
[18:04:22.995]                             if (!grepl(pattern, name)) 
[18:04:22.995]                               next
[18:04:22.995]                             invokeRestart(restart)
[18:04:22.995]                             muffled <- TRUE
[18:04:22.995]                             break
[18:04:22.995]                           }
[18:04:22.995]                         }
[18:04:22.995]                       }
[18:04:22.995]                       invisible(muffled)
[18:04:22.995]                     }
[18:04:22.995]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.995]                   }
[18:04:22.995]                 }
[18:04:22.995]                 else {
[18:04:22.995]                   if (TRUE) {
[18:04:22.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:22.995]                     {
[18:04:22.995]                       inherits <- base::inherits
[18:04:22.995]                       invokeRestart <- base::invokeRestart
[18:04:22.995]                       is.null <- base::is.null
[18:04:22.995]                       muffled <- FALSE
[18:04:22.995]                       if (inherits(cond, "message")) {
[18:04:22.995]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:22.995]                         if (muffled) 
[18:04:22.995]                           invokeRestart("muffleMessage")
[18:04:22.995]                       }
[18:04:22.995]                       else if (inherits(cond, "warning")) {
[18:04:22.995]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:22.995]                         if (muffled) 
[18:04:22.995]                           invokeRestart("muffleWarning")
[18:04:22.995]                       }
[18:04:22.995]                       else if (inherits(cond, "condition")) {
[18:04:22.995]                         if (!is.null(pattern)) {
[18:04:22.995]                           computeRestarts <- base::computeRestarts
[18:04:22.995]                           grepl <- base::grepl
[18:04:22.995]                           restarts <- computeRestarts(cond)
[18:04:22.995]                           for (restart in restarts) {
[18:04:22.995]                             name <- restart$name
[18:04:22.995]                             if (is.null(name)) 
[18:04:22.995]                               next
[18:04:22.995]                             if (!grepl(pattern, name)) 
[18:04:22.995]                               next
[18:04:22.995]                             invokeRestart(restart)
[18:04:22.995]                             muffled <- TRUE
[18:04:22.995]                             break
[18:04:22.995]                           }
[18:04:22.995]                         }
[18:04:22.995]                       }
[18:04:22.995]                       invisible(muffled)
[18:04:22.995]                     }
[18:04:22.995]                     muffleCondition(cond, pattern = "^muffle")
[18:04:22.995]                   }
[18:04:22.995]                 }
[18:04:22.995]             }
[18:04:22.995]         }))
[18:04:22.995]     }, error = function(ex) {
[18:04:22.995]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:22.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:22.995]                 ...future.rng), started = ...future.startTime, 
[18:04:22.995]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:22.995]             version = "1.8"), class = "FutureResult")
[18:04:22.995]     }, finally = {
[18:04:22.995]         if (!identical(...future.workdir, getwd())) 
[18:04:22.995]             setwd(...future.workdir)
[18:04:22.995]         {
[18:04:22.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:22.995]                 ...future.oldOptions$nwarnings <- NULL
[18:04:22.995]             }
[18:04:22.995]             base::options(...future.oldOptions)
[18:04:22.995]             if (.Platform$OS.type == "windows") {
[18:04:22.995]                 old_names <- names(...future.oldEnvVars)
[18:04:22.995]                 envs <- base::Sys.getenv()
[18:04:22.995]                 names <- names(envs)
[18:04:22.995]                 common <- intersect(names, old_names)
[18:04:22.995]                 added <- setdiff(names, old_names)
[18:04:22.995]                 removed <- setdiff(old_names, names)
[18:04:22.995]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:22.995]                   envs[common]]
[18:04:22.995]                 NAMES <- toupper(changed)
[18:04:22.995]                 args <- list()
[18:04:22.995]                 for (kk in seq_along(NAMES)) {
[18:04:22.995]                   name <- changed[[kk]]
[18:04:22.995]                   NAME <- NAMES[[kk]]
[18:04:22.995]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.995]                     next
[18:04:22.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.995]                 }
[18:04:22.995]                 NAMES <- toupper(added)
[18:04:22.995]                 for (kk in seq_along(NAMES)) {
[18:04:22.995]                   name <- added[[kk]]
[18:04:22.995]                   NAME <- NAMES[[kk]]
[18:04:22.995]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.995]                     next
[18:04:22.995]                   args[[name]] <- ""
[18:04:22.995]                 }
[18:04:22.995]                 NAMES <- toupper(removed)
[18:04:22.995]                 for (kk in seq_along(NAMES)) {
[18:04:22.995]                   name <- removed[[kk]]
[18:04:22.995]                   NAME <- NAMES[[kk]]
[18:04:22.995]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:22.995]                     next
[18:04:22.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:22.995]                 }
[18:04:22.995]                 if (length(args) > 0) 
[18:04:22.995]                   base::do.call(base::Sys.setenv, args = args)
[18:04:22.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:22.995]             }
[18:04:22.995]             else {
[18:04:22.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:22.995]             }
[18:04:22.995]             {
[18:04:22.995]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:22.995]                   0L) {
[18:04:22.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:22.995]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:22.995]                   base::options(opts)
[18:04:22.995]                 }
[18:04:22.995]                 {
[18:04:22.995]                   {
[18:04:22.995]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:22.995]                     NULL
[18:04:22.995]                   }
[18:04:22.995]                   options(future.plan = NULL)
[18:04:22.995]                   if (is.na(NA_character_)) 
[18:04:22.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:22.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:22.995]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:22.995]                     .init = FALSE)
[18:04:22.995]                 }
[18:04:22.995]             }
[18:04:22.995]         }
[18:04:22.995]     })
[18:04:22.995]     if (TRUE) {
[18:04:22.995]         base::sink(type = "output", split = FALSE)
[18:04:22.995]         if (TRUE) {
[18:04:22.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:22.995]         }
[18:04:22.995]         else {
[18:04:22.995]             ...future.result["stdout"] <- base::list(NULL)
[18:04:22.995]         }
[18:04:22.995]         base::close(...future.stdout)
[18:04:22.995]         ...future.stdout <- NULL
[18:04:22.995]     }
[18:04:22.995]     ...future.result$conditions <- ...future.conditions
[18:04:22.995]     ...future.result$finished <- base::Sys.time()
[18:04:22.995]     ...future.result
[18:04:22.995] }
[18:04:23.097] MultisessionFuture started
[18:04:23.098] result() for ClusterFuture ...
[18:04:23.098] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.098] - Validating connection of MultisessionFuture
[18:04:23.161] - received message: FutureResult
[18:04:23.161] - Received FutureResult
[18:04:23.162] - Erased future from FutureRegistry
[18:04:23.162] result() for ClusterFuture ...
[18:04:23.163] - result already collected: FutureResult
[18:04:23.163] result() for ClusterFuture ... done
[18:04:23.163] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:23.164] result() for ClusterFuture ... done
[18:04:23.164] result() for ClusterFuture ...
[18:04:23.164] - result already collected: FutureResult
[18:04:23.165] result() for ClusterFuture ... done
[18:04:23.165] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:04:23.173] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[18:04:23.174] getGlobalsAndPackages() ...
[18:04:23.174] Searching for globals...
[18:04:23.175] 
[18:04:23.175] Searching for globals ... DONE
[18:04:23.176] - globals: [0] <none>
[18:04:23.176] getGlobalsAndPackages() ... DONE
[18:04:23.176] run() for ‘Future’ ...
[18:04:23.177] - state: ‘created’
[18:04:23.177] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.209] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.210]   - Field: ‘node’
[18:04:23.210]   - Field: ‘label’
[18:04:23.210]   - Field: ‘local’
[18:04:23.210]   - Field: ‘owner’
[18:04:23.211]   - Field: ‘envir’
[18:04:23.211]   - Field: ‘workers’
[18:04:23.211]   - Field: ‘packages’
[18:04:23.212]   - Field: ‘gc’
[18:04:23.212]   - Field: ‘conditions’
[18:04:23.212]   - Field: ‘persistent’
[18:04:23.212]   - Field: ‘expr’
[18:04:23.213]   - Field: ‘uuid’
[18:04:23.213]   - Field: ‘seed’
[18:04:23.213]   - Field: ‘version’
[18:04:23.214]   - Field: ‘result’
[18:04:23.214]   - Field: ‘asynchronous’
[18:04:23.214]   - Field: ‘calls’
[18:04:23.214]   - Field: ‘globals’
[18:04:23.215]   - Field: ‘stdout’
[18:04:23.215]   - Field: ‘earlySignal’
[18:04:23.215]   - Field: ‘lazy’
[18:04:23.215]   - Field: ‘state’
[18:04:23.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.216] - Launch lazy future ...
[18:04:23.217] Packages needed by the future expression (n = 0): <none>
[18:04:23.217] Packages needed by future strategies (n = 0): <none>
[18:04:23.218] {
[18:04:23.218]     {
[18:04:23.218]         {
[18:04:23.218]             ...future.startTime <- base::Sys.time()
[18:04:23.218]             {
[18:04:23.218]                 {
[18:04:23.218]                   {
[18:04:23.218]                     {
[18:04:23.218]                       base::local({
[18:04:23.218]                         has_future <- base::requireNamespace("future", 
[18:04:23.218]                           quietly = TRUE)
[18:04:23.218]                         if (has_future) {
[18:04:23.218]                           ns <- base::getNamespace("future")
[18:04:23.218]                           version <- ns[[".package"]][["version"]]
[18:04:23.218]                           if (is.null(version)) 
[18:04:23.218]                             version <- utils::packageVersion("future")
[18:04:23.218]                         }
[18:04:23.218]                         else {
[18:04:23.218]                           version <- NULL
[18:04:23.218]                         }
[18:04:23.218]                         if (!has_future || version < "1.8.0") {
[18:04:23.218]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.218]                             "", base::R.version$version.string), 
[18:04:23.218]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.218]                               "release", "version")], collapse = " "), 
[18:04:23.218]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.218]                             info)
[18:04:23.218]                           info <- base::paste(info, collapse = "; ")
[18:04:23.218]                           if (!has_future) {
[18:04:23.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.218]                               info)
[18:04:23.218]                           }
[18:04:23.218]                           else {
[18:04:23.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.218]                               info, version)
[18:04:23.218]                           }
[18:04:23.218]                           base::stop(msg)
[18:04:23.218]                         }
[18:04:23.218]                       })
[18:04:23.218]                     }
[18:04:23.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.218]                     base::options(mc.cores = 1L)
[18:04:23.218]                   }
[18:04:23.218]                   ...future.strategy.old <- future::plan("list")
[18:04:23.218]                   options(future.plan = NULL)
[18:04:23.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.218]                 }
[18:04:23.218]                 ...future.workdir <- getwd()
[18:04:23.218]             }
[18:04:23.218]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.218]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.218]         }
[18:04:23.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.218]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.218]             base::names(...future.oldOptions))
[18:04:23.218]     }
[18:04:23.218]     if (FALSE) {
[18:04:23.218]     }
[18:04:23.218]     else {
[18:04:23.218]         if (TRUE) {
[18:04:23.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.218]                 open = "w")
[18:04:23.218]         }
[18:04:23.218]         else {
[18:04:23.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.218]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.218]         }
[18:04:23.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.218]             base::sink(type = "output", split = FALSE)
[18:04:23.218]             base::close(...future.stdout)
[18:04:23.218]         }, add = TRUE)
[18:04:23.218]     }
[18:04:23.218]     ...future.frame <- base::sys.nframe()
[18:04:23.218]     ...future.conditions <- base::list()
[18:04:23.218]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.218]     if (FALSE) {
[18:04:23.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.218]     }
[18:04:23.218]     ...future.result <- base::tryCatch({
[18:04:23.218]         base::withCallingHandlers({
[18:04:23.218]             ...future.value <- base::withVisible(base::local({
[18:04:23.218]                 ...future.makeSendCondition <- base::local({
[18:04:23.218]                   sendCondition <- NULL
[18:04:23.218]                   function(frame = 1L) {
[18:04:23.218]                     if (is.function(sendCondition)) 
[18:04:23.218]                       return(sendCondition)
[18:04:23.218]                     ns <- getNamespace("parallel")
[18:04:23.218]                     if (exists("sendData", mode = "function", 
[18:04:23.218]                       envir = ns)) {
[18:04:23.218]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.218]                         envir = ns)
[18:04:23.218]                       envir <- sys.frame(frame)
[18:04:23.218]                       master <- NULL
[18:04:23.218]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.218]                         !identical(envir, emptyenv())) {
[18:04:23.218]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.218]                           inherits = FALSE)) {
[18:04:23.218]                           master <- get("master", mode = "list", 
[18:04:23.218]                             envir = envir, inherits = FALSE)
[18:04:23.218]                           if (inherits(master, c("SOCKnode", 
[18:04:23.218]                             "SOCK0node"))) {
[18:04:23.218]                             sendCondition <<- function(cond) {
[18:04:23.218]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.218]                                 success = TRUE)
[18:04:23.218]                               parallel_sendData(master, data)
[18:04:23.218]                             }
[18:04:23.218]                             return(sendCondition)
[18:04:23.218]                           }
[18:04:23.218]                         }
[18:04:23.218]                         frame <- frame + 1L
[18:04:23.218]                         envir <- sys.frame(frame)
[18:04:23.218]                       }
[18:04:23.218]                     }
[18:04:23.218]                     sendCondition <<- function(cond) NULL
[18:04:23.218]                   }
[18:04:23.218]                 })
[18:04:23.218]                 withCallingHandlers({
[18:04:23.218]                   2
[18:04:23.218]                 }, immediateCondition = function(cond) {
[18:04:23.218]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.218]                   sendCondition(cond)
[18:04:23.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.218]                   {
[18:04:23.218]                     inherits <- base::inherits
[18:04:23.218]                     invokeRestart <- base::invokeRestart
[18:04:23.218]                     is.null <- base::is.null
[18:04:23.218]                     muffled <- FALSE
[18:04:23.218]                     if (inherits(cond, "message")) {
[18:04:23.218]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.218]                       if (muffled) 
[18:04:23.218]                         invokeRestart("muffleMessage")
[18:04:23.218]                     }
[18:04:23.218]                     else if (inherits(cond, "warning")) {
[18:04:23.218]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.218]                       if (muffled) 
[18:04:23.218]                         invokeRestart("muffleWarning")
[18:04:23.218]                     }
[18:04:23.218]                     else if (inherits(cond, "condition")) {
[18:04:23.218]                       if (!is.null(pattern)) {
[18:04:23.218]                         computeRestarts <- base::computeRestarts
[18:04:23.218]                         grepl <- base::grepl
[18:04:23.218]                         restarts <- computeRestarts(cond)
[18:04:23.218]                         for (restart in restarts) {
[18:04:23.218]                           name <- restart$name
[18:04:23.218]                           if (is.null(name)) 
[18:04:23.218]                             next
[18:04:23.218]                           if (!grepl(pattern, name)) 
[18:04:23.218]                             next
[18:04:23.218]                           invokeRestart(restart)
[18:04:23.218]                           muffled <- TRUE
[18:04:23.218]                           break
[18:04:23.218]                         }
[18:04:23.218]                       }
[18:04:23.218]                     }
[18:04:23.218]                     invisible(muffled)
[18:04:23.218]                   }
[18:04:23.218]                   muffleCondition(cond)
[18:04:23.218]                 })
[18:04:23.218]             }))
[18:04:23.218]             future::FutureResult(value = ...future.value$value, 
[18:04:23.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.218]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.218]                     ...future.globalenv.names))
[18:04:23.218]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.218]         }, condition = base::local({
[18:04:23.218]             c <- base::c
[18:04:23.218]             inherits <- base::inherits
[18:04:23.218]             invokeRestart <- base::invokeRestart
[18:04:23.218]             length <- base::length
[18:04:23.218]             list <- base::list
[18:04:23.218]             seq.int <- base::seq.int
[18:04:23.218]             signalCondition <- base::signalCondition
[18:04:23.218]             sys.calls <- base::sys.calls
[18:04:23.218]             `[[` <- base::`[[`
[18:04:23.218]             `+` <- base::`+`
[18:04:23.218]             `<<-` <- base::`<<-`
[18:04:23.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.218]                   3L)]
[18:04:23.218]             }
[18:04:23.218]             function(cond) {
[18:04:23.218]                 is_error <- inherits(cond, "error")
[18:04:23.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.218]                   NULL)
[18:04:23.218]                 if (is_error) {
[18:04:23.218]                   sessionInformation <- function() {
[18:04:23.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.218]                       search = base::search(), system = base::Sys.info())
[18:04:23.218]                   }
[18:04:23.218]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.218]                     cond$call), session = sessionInformation(), 
[18:04:23.218]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.218]                   signalCondition(cond)
[18:04:23.218]                 }
[18:04:23.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.218]                 "immediateCondition"))) {
[18:04:23.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.218]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.218]                   if (TRUE && !signal) {
[18:04:23.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.218]                     {
[18:04:23.218]                       inherits <- base::inherits
[18:04:23.218]                       invokeRestart <- base::invokeRestart
[18:04:23.218]                       is.null <- base::is.null
[18:04:23.218]                       muffled <- FALSE
[18:04:23.218]                       if (inherits(cond, "message")) {
[18:04:23.218]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.218]                         if (muffled) 
[18:04:23.218]                           invokeRestart("muffleMessage")
[18:04:23.218]                       }
[18:04:23.218]                       else if (inherits(cond, "warning")) {
[18:04:23.218]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.218]                         if (muffled) 
[18:04:23.218]                           invokeRestart("muffleWarning")
[18:04:23.218]                       }
[18:04:23.218]                       else if (inherits(cond, "condition")) {
[18:04:23.218]                         if (!is.null(pattern)) {
[18:04:23.218]                           computeRestarts <- base::computeRestarts
[18:04:23.218]                           grepl <- base::grepl
[18:04:23.218]                           restarts <- computeRestarts(cond)
[18:04:23.218]                           for (restart in restarts) {
[18:04:23.218]                             name <- restart$name
[18:04:23.218]                             if (is.null(name)) 
[18:04:23.218]                               next
[18:04:23.218]                             if (!grepl(pattern, name)) 
[18:04:23.218]                               next
[18:04:23.218]                             invokeRestart(restart)
[18:04:23.218]                             muffled <- TRUE
[18:04:23.218]                             break
[18:04:23.218]                           }
[18:04:23.218]                         }
[18:04:23.218]                       }
[18:04:23.218]                       invisible(muffled)
[18:04:23.218]                     }
[18:04:23.218]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.218]                   }
[18:04:23.218]                 }
[18:04:23.218]                 else {
[18:04:23.218]                   if (TRUE) {
[18:04:23.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.218]                     {
[18:04:23.218]                       inherits <- base::inherits
[18:04:23.218]                       invokeRestart <- base::invokeRestart
[18:04:23.218]                       is.null <- base::is.null
[18:04:23.218]                       muffled <- FALSE
[18:04:23.218]                       if (inherits(cond, "message")) {
[18:04:23.218]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.218]                         if (muffled) 
[18:04:23.218]                           invokeRestart("muffleMessage")
[18:04:23.218]                       }
[18:04:23.218]                       else if (inherits(cond, "warning")) {
[18:04:23.218]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.218]                         if (muffled) 
[18:04:23.218]                           invokeRestart("muffleWarning")
[18:04:23.218]                       }
[18:04:23.218]                       else if (inherits(cond, "condition")) {
[18:04:23.218]                         if (!is.null(pattern)) {
[18:04:23.218]                           computeRestarts <- base::computeRestarts
[18:04:23.218]                           grepl <- base::grepl
[18:04:23.218]                           restarts <- computeRestarts(cond)
[18:04:23.218]                           for (restart in restarts) {
[18:04:23.218]                             name <- restart$name
[18:04:23.218]                             if (is.null(name)) 
[18:04:23.218]                               next
[18:04:23.218]                             if (!grepl(pattern, name)) 
[18:04:23.218]                               next
[18:04:23.218]                             invokeRestart(restart)
[18:04:23.218]                             muffled <- TRUE
[18:04:23.218]                             break
[18:04:23.218]                           }
[18:04:23.218]                         }
[18:04:23.218]                       }
[18:04:23.218]                       invisible(muffled)
[18:04:23.218]                     }
[18:04:23.218]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.218]                   }
[18:04:23.218]                 }
[18:04:23.218]             }
[18:04:23.218]         }))
[18:04:23.218]     }, error = function(ex) {
[18:04:23.218]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.218]                 ...future.rng), started = ...future.startTime, 
[18:04:23.218]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.218]             version = "1.8"), class = "FutureResult")
[18:04:23.218]     }, finally = {
[18:04:23.218]         if (!identical(...future.workdir, getwd())) 
[18:04:23.218]             setwd(...future.workdir)
[18:04:23.218]         {
[18:04:23.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.218]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.218]             }
[18:04:23.218]             base::options(...future.oldOptions)
[18:04:23.218]             if (.Platform$OS.type == "windows") {
[18:04:23.218]                 old_names <- names(...future.oldEnvVars)
[18:04:23.218]                 envs <- base::Sys.getenv()
[18:04:23.218]                 names <- names(envs)
[18:04:23.218]                 common <- intersect(names, old_names)
[18:04:23.218]                 added <- setdiff(names, old_names)
[18:04:23.218]                 removed <- setdiff(old_names, names)
[18:04:23.218]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.218]                   envs[common]]
[18:04:23.218]                 NAMES <- toupper(changed)
[18:04:23.218]                 args <- list()
[18:04:23.218]                 for (kk in seq_along(NAMES)) {
[18:04:23.218]                   name <- changed[[kk]]
[18:04:23.218]                   NAME <- NAMES[[kk]]
[18:04:23.218]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.218]                     next
[18:04:23.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.218]                 }
[18:04:23.218]                 NAMES <- toupper(added)
[18:04:23.218]                 for (kk in seq_along(NAMES)) {
[18:04:23.218]                   name <- added[[kk]]
[18:04:23.218]                   NAME <- NAMES[[kk]]
[18:04:23.218]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.218]                     next
[18:04:23.218]                   args[[name]] <- ""
[18:04:23.218]                 }
[18:04:23.218]                 NAMES <- toupper(removed)
[18:04:23.218]                 for (kk in seq_along(NAMES)) {
[18:04:23.218]                   name <- removed[[kk]]
[18:04:23.218]                   NAME <- NAMES[[kk]]
[18:04:23.218]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.218]                     next
[18:04:23.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.218]                 }
[18:04:23.218]                 if (length(args) > 0) 
[18:04:23.218]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.218]             }
[18:04:23.218]             else {
[18:04:23.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.218]             }
[18:04:23.218]             {
[18:04:23.218]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.218]                   0L) {
[18:04:23.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.218]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.218]                   base::options(opts)
[18:04:23.218]                 }
[18:04:23.218]                 {
[18:04:23.218]                   {
[18:04:23.218]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.218]                     NULL
[18:04:23.218]                   }
[18:04:23.218]                   options(future.plan = NULL)
[18:04:23.218]                   if (is.na(NA_character_)) 
[18:04:23.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.218]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.218]                     .init = FALSE)
[18:04:23.218]                 }
[18:04:23.218]             }
[18:04:23.218]         }
[18:04:23.218]     })
[18:04:23.218]     if (TRUE) {
[18:04:23.218]         base::sink(type = "output", split = FALSE)
[18:04:23.218]         if (TRUE) {
[18:04:23.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.218]         }
[18:04:23.218]         else {
[18:04:23.218]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.218]         }
[18:04:23.218]         base::close(...future.stdout)
[18:04:23.218]         ...future.stdout <- NULL
[18:04:23.218]     }
[18:04:23.218]     ...future.result$conditions <- ...future.conditions
[18:04:23.218]     ...future.result$finished <- base::Sys.time()
[18:04:23.218]     ...future.result
[18:04:23.218] }
[18:04:23.225] MultisessionFuture started
[18:04:23.226] - Launch lazy future ... done
[18:04:23.226] run() for ‘MultisessionFuture’ ... done
[18:04:23.226] getGlobalsAndPackages() ...
[18:04:23.226] Searching for globals...
[18:04:23.227] 
[18:04:23.228] Searching for globals ... DONE
[18:04:23.228] - globals: [0] <none>
[18:04:23.228] getGlobalsAndPackages() ... DONE
[18:04:23.229] run() for ‘Future’ ...
[18:04:23.229] - state: ‘created’
[18:04:23.229] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.255] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.256]   - Field: ‘node’
[18:04:23.256]   - Field: ‘label’
[18:04:23.257]   - Field: ‘local’
[18:04:23.257]   - Field: ‘owner’
[18:04:23.257]   - Field: ‘envir’
[18:04:23.257]   - Field: ‘workers’
[18:04:23.257]   - Field: ‘packages’
[18:04:23.258]   - Field: ‘gc’
[18:04:23.258]   - Field: ‘conditions’
[18:04:23.258]   - Field: ‘persistent’
[18:04:23.258]   - Field: ‘expr’
[18:04:23.258]   - Field: ‘uuid’
[18:04:23.259]   - Field: ‘seed’
[18:04:23.259]   - Field: ‘version’
[18:04:23.259]   - Field: ‘result’
[18:04:23.259]   - Field: ‘asynchronous’
[18:04:23.260]   - Field: ‘calls’
[18:04:23.260]   - Field: ‘globals’
[18:04:23.260]   - Field: ‘stdout’
[18:04:23.260]   - Field: ‘earlySignal’
[18:04:23.260]   - Field: ‘lazy’
[18:04:23.261]   - Field: ‘state’
[18:04:23.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.261] - Launch lazy future ...
[18:04:23.262] Packages needed by the future expression (n = 0): <none>
[18:04:23.262] Packages needed by future strategies (n = 0): <none>
[18:04:23.263] {
[18:04:23.263]     {
[18:04:23.263]         {
[18:04:23.263]             ...future.startTime <- base::Sys.time()
[18:04:23.263]             {
[18:04:23.263]                 {
[18:04:23.263]                   {
[18:04:23.263]                     {
[18:04:23.263]                       base::local({
[18:04:23.263]                         has_future <- base::requireNamespace("future", 
[18:04:23.263]                           quietly = TRUE)
[18:04:23.263]                         if (has_future) {
[18:04:23.263]                           ns <- base::getNamespace("future")
[18:04:23.263]                           version <- ns[[".package"]][["version"]]
[18:04:23.263]                           if (is.null(version)) 
[18:04:23.263]                             version <- utils::packageVersion("future")
[18:04:23.263]                         }
[18:04:23.263]                         else {
[18:04:23.263]                           version <- NULL
[18:04:23.263]                         }
[18:04:23.263]                         if (!has_future || version < "1.8.0") {
[18:04:23.263]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.263]                             "", base::R.version$version.string), 
[18:04:23.263]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.263]                               "release", "version")], collapse = " "), 
[18:04:23.263]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.263]                             info)
[18:04:23.263]                           info <- base::paste(info, collapse = "; ")
[18:04:23.263]                           if (!has_future) {
[18:04:23.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.263]                               info)
[18:04:23.263]                           }
[18:04:23.263]                           else {
[18:04:23.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.263]                               info, version)
[18:04:23.263]                           }
[18:04:23.263]                           base::stop(msg)
[18:04:23.263]                         }
[18:04:23.263]                       })
[18:04:23.263]                     }
[18:04:23.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.263]                     base::options(mc.cores = 1L)
[18:04:23.263]                   }
[18:04:23.263]                   ...future.strategy.old <- future::plan("list")
[18:04:23.263]                   options(future.plan = NULL)
[18:04:23.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.263]                 }
[18:04:23.263]                 ...future.workdir <- getwd()
[18:04:23.263]             }
[18:04:23.263]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.263]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.263]         }
[18:04:23.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.263]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.263]             base::names(...future.oldOptions))
[18:04:23.263]     }
[18:04:23.263]     if (FALSE) {
[18:04:23.263]     }
[18:04:23.263]     else {
[18:04:23.263]         if (TRUE) {
[18:04:23.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.263]                 open = "w")
[18:04:23.263]         }
[18:04:23.263]         else {
[18:04:23.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.263]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.263]         }
[18:04:23.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.263]             base::sink(type = "output", split = FALSE)
[18:04:23.263]             base::close(...future.stdout)
[18:04:23.263]         }, add = TRUE)
[18:04:23.263]     }
[18:04:23.263]     ...future.frame <- base::sys.nframe()
[18:04:23.263]     ...future.conditions <- base::list()
[18:04:23.263]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.263]     if (FALSE) {
[18:04:23.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.263]     }
[18:04:23.263]     ...future.result <- base::tryCatch({
[18:04:23.263]         base::withCallingHandlers({
[18:04:23.263]             ...future.value <- base::withVisible(base::local({
[18:04:23.263]                 ...future.makeSendCondition <- base::local({
[18:04:23.263]                   sendCondition <- NULL
[18:04:23.263]                   function(frame = 1L) {
[18:04:23.263]                     if (is.function(sendCondition)) 
[18:04:23.263]                       return(sendCondition)
[18:04:23.263]                     ns <- getNamespace("parallel")
[18:04:23.263]                     if (exists("sendData", mode = "function", 
[18:04:23.263]                       envir = ns)) {
[18:04:23.263]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.263]                         envir = ns)
[18:04:23.263]                       envir <- sys.frame(frame)
[18:04:23.263]                       master <- NULL
[18:04:23.263]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.263]                         !identical(envir, emptyenv())) {
[18:04:23.263]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.263]                           inherits = FALSE)) {
[18:04:23.263]                           master <- get("master", mode = "list", 
[18:04:23.263]                             envir = envir, inherits = FALSE)
[18:04:23.263]                           if (inherits(master, c("SOCKnode", 
[18:04:23.263]                             "SOCK0node"))) {
[18:04:23.263]                             sendCondition <<- function(cond) {
[18:04:23.263]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.263]                                 success = TRUE)
[18:04:23.263]                               parallel_sendData(master, data)
[18:04:23.263]                             }
[18:04:23.263]                             return(sendCondition)
[18:04:23.263]                           }
[18:04:23.263]                         }
[18:04:23.263]                         frame <- frame + 1L
[18:04:23.263]                         envir <- sys.frame(frame)
[18:04:23.263]                       }
[18:04:23.263]                     }
[18:04:23.263]                     sendCondition <<- function(cond) NULL
[18:04:23.263]                   }
[18:04:23.263]                 })
[18:04:23.263]                 withCallingHandlers({
[18:04:23.263]                   NULL
[18:04:23.263]                 }, immediateCondition = function(cond) {
[18:04:23.263]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.263]                   sendCondition(cond)
[18:04:23.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.263]                   {
[18:04:23.263]                     inherits <- base::inherits
[18:04:23.263]                     invokeRestart <- base::invokeRestart
[18:04:23.263]                     is.null <- base::is.null
[18:04:23.263]                     muffled <- FALSE
[18:04:23.263]                     if (inherits(cond, "message")) {
[18:04:23.263]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.263]                       if (muffled) 
[18:04:23.263]                         invokeRestart("muffleMessage")
[18:04:23.263]                     }
[18:04:23.263]                     else if (inherits(cond, "warning")) {
[18:04:23.263]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.263]                       if (muffled) 
[18:04:23.263]                         invokeRestart("muffleWarning")
[18:04:23.263]                     }
[18:04:23.263]                     else if (inherits(cond, "condition")) {
[18:04:23.263]                       if (!is.null(pattern)) {
[18:04:23.263]                         computeRestarts <- base::computeRestarts
[18:04:23.263]                         grepl <- base::grepl
[18:04:23.263]                         restarts <- computeRestarts(cond)
[18:04:23.263]                         for (restart in restarts) {
[18:04:23.263]                           name <- restart$name
[18:04:23.263]                           if (is.null(name)) 
[18:04:23.263]                             next
[18:04:23.263]                           if (!grepl(pattern, name)) 
[18:04:23.263]                             next
[18:04:23.263]                           invokeRestart(restart)
[18:04:23.263]                           muffled <- TRUE
[18:04:23.263]                           break
[18:04:23.263]                         }
[18:04:23.263]                       }
[18:04:23.263]                     }
[18:04:23.263]                     invisible(muffled)
[18:04:23.263]                   }
[18:04:23.263]                   muffleCondition(cond)
[18:04:23.263]                 })
[18:04:23.263]             }))
[18:04:23.263]             future::FutureResult(value = ...future.value$value, 
[18:04:23.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.263]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.263]                     ...future.globalenv.names))
[18:04:23.263]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.263]         }, condition = base::local({
[18:04:23.263]             c <- base::c
[18:04:23.263]             inherits <- base::inherits
[18:04:23.263]             invokeRestart <- base::invokeRestart
[18:04:23.263]             length <- base::length
[18:04:23.263]             list <- base::list
[18:04:23.263]             seq.int <- base::seq.int
[18:04:23.263]             signalCondition <- base::signalCondition
[18:04:23.263]             sys.calls <- base::sys.calls
[18:04:23.263]             `[[` <- base::`[[`
[18:04:23.263]             `+` <- base::`+`
[18:04:23.263]             `<<-` <- base::`<<-`
[18:04:23.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.263]                   3L)]
[18:04:23.263]             }
[18:04:23.263]             function(cond) {
[18:04:23.263]                 is_error <- inherits(cond, "error")
[18:04:23.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.263]                   NULL)
[18:04:23.263]                 if (is_error) {
[18:04:23.263]                   sessionInformation <- function() {
[18:04:23.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.263]                       search = base::search(), system = base::Sys.info())
[18:04:23.263]                   }
[18:04:23.263]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.263]                     cond$call), session = sessionInformation(), 
[18:04:23.263]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.263]                   signalCondition(cond)
[18:04:23.263]                 }
[18:04:23.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.263]                 "immediateCondition"))) {
[18:04:23.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.263]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.263]                   if (TRUE && !signal) {
[18:04:23.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.263]                     {
[18:04:23.263]                       inherits <- base::inherits
[18:04:23.263]                       invokeRestart <- base::invokeRestart
[18:04:23.263]                       is.null <- base::is.null
[18:04:23.263]                       muffled <- FALSE
[18:04:23.263]                       if (inherits(cond, "message")) {
[18:04:23.263]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.263]                         if (muffled) 
[18:04:23.263]                           invokeRestart("muffleMessage")
[18:04:23.263]                       }
[18:04:23.263]                       else if (inherits(cond, "warning")) {
[18:04:23.263]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.263]                         if (muffled) 
[18:04:23.263]                           invokeRestart("muffleWarning")
[18:04:23.263]                       }
[18:04:23.263]                       else if (inherits(cond, "condition")) {
[18:04:23.263]                         if (!is.null(pattern)) {
[18:04:23.263]                           computeRestarts <- base::computeRestarts
[18:04:23.263]                           grepl <- base::grepl
[18:04:23.263]                           restarts <- computeRestarts(cond)
[18:04:23.263]                           for (restart in restarts) {
[18:04:23.263]                             name <- restart$name
[18:04:23.263]                             if (is.null(name)) 
[18:04:23.263]                               next
[18:04:23.263]                             if (!grepl(pattern, name)) 
[18:04:23.263]                               next
[18:04:23.263]                             invokeRestart(restart)
[18:04:23.263]                             muffled <- TRUE
[18:04:23.263]                             break
[18:04:23.263]                           }
[18:04:23.263]                         }
[18:04:23.263]                       }
[18:04:23.263]                       invisible(muffled)
[18:04:23.263]                     }
[18:04:23.263]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.263]                   }
[18:04:23.263]                 }
[18:04:23.263]                 else {
[18:04:23.263]                   if (TRUE) {
[18:04:23.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.263]                     {
[18:04:23.263]                       inherits <- base::inherits
[18:04:23.263]                       invokeRestart <- base::invokeRestart
[18:04:23.263]                       is.null <- base::is.null
[18:04:23.263]                       muffled <- FALSE
[18:04:23.263]                       if (inherits(cond, "message")) {
[18:04:23.263]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.263]                         if (muffled) 
[18:04:23.263]                           invokeRestart("muffleMessage")
[18:04:23.263]                       }
[18:04:23.263]                       else if (inherits(cond, "warning")) {
[18:04:23.263]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.263]                         if (muffled) 
[18:04:23.263]                           invokeRestart("muffleWarning")
[18:04:23.263]                       }
[18:04:23.263]                       else if (inherits(cond, "condition")) {
[18:04:23.263]                         if (!is.null(pattern)) {
[18:04:23.263]                           computeRestarts <- base::computeRestarts
[18:04:23.263]                           grepl <- base::grepl
[18:04:23.263]                           restarts <- computeRestarts(cond)
[18:04:23.263]                           for (restart in restarts) {
[18:04:23.263]                             name <- restart$name
[18:04:23.263]                             if (is.null(name)) 
[18:04:23.263]                               next
[18:04:23.263]                             if (!grepl(pattern, name)) 
[18:04:23.263]                               next
[18:04:23.263]                             invokeRestart(restart)
[18:04:23.263]                             muffled <- TRUE
[18:04:23.263]                             break
[18:04:23.263]                           }
[18:04:23.263]                         }
[18:04:23.263]                       }
[18:04:23.263]                       invisible(muffled)
[18:04:23.263]                     }
[18:04:23.263]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.263]                   }
[18:04:23.263]                 }
[18:04:23.263]             }
[18:04:23.263]         }))
[18:04:23.263]     }, error = function(ex) {
[18:04:23.263]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.263]                 ...future.rng), started = ...future.startTime, 
[18:04:23.263]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.263]             version = "1.8"), class = "FutureResult")
[18:04:23.263]     }, finally = {
[18:04:23.263]         if (!identical(...future.workdir, getwd())) 
[18:04:23.263]             setwd(...future.workdir)
[18:04:23.263]         {
[18:04:23.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.263]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.263]             }
[18:04:23.263]             base::options(...future.oldOptions)
[18:04:23.263]             if (.Platform$OS.type == "windows") {
[18:04:23.263]                 old_names <- names(...future.oldEnvVars)
[18:04:23.263]                 envs <- base::Sys.getenv()
[18:04:23.263]                 names <- names(envs)
[18:04:23.263]                 common <- intersect(names, old_names)
[18:04:23.263]                 added <- setdiff(names, old_names)
[18:04:23.263]                 removed <- setdiff(old_names, names)
[18:04:23.263]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.263]                   envs[common]]
[18:04:23.263]                 NAMES <- toupper(changed)
[18:04:23.263]                 args <- list()
[18:04:23.263]                 for (kk in seq_along(NAMES)) {
[18:04:23.263]                   name <- changed[[kk]]
[18:04:23.263]                   NAME <- NAMES[[kk]]
[18:04:23.263]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.263]                     next
[18:04:23.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.263]                 }
[18:04:23.263]                 NAMES <- toupper(added)
[18:04:23.263]                 for (kk in seq_along(NAMES)) {
[18:04:23.263]                   name <- added[[kk]]
[18:04:23.263]                   NAME <- NAMES[[kk]]
[18:04:23.263]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.263]                     next
[18:04:23.263]                   args[[name]] <- ""
[18:04:23.263]                 }
[18:04:23.263]                 NAMES <- toupper(removed)
[18:04:23.263]                 for (kk in seq_along(NAMES)) {
[18:04:23.263]                   name <- removed[[kk]]
[18:04:23.263]                   NAME <- NAMES[[kk]]
[18:04:23.263]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.263]                     next
[18:04:23.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.263]                 }
[18:04:23.263]                 if (length(args) > 0) 
[18:04:23.263]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.263]             }
[18:04:23.263]             else {
[18:04:23.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.263]             }
[18:04:23.263]             {
[18:04:23.263]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.263]                   0L) {
[18:04:23.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.263]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.263]                   base::options(opts)
[18:04:23.263]                 }
[18:04:23.263]                 {
[18:04:23.263]                   {
[18:04:23.263]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.263]                     NULL
[18:04:23.263]                   }
[18:04:23.263]                   options(future.plan = NULL)
[18:04:23.263]                   if (is.na(NA_character_)) 
[18:04:23.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.263]                     .init = FALSE)
[18:04:23.263]                 }
[18:04:23.263]             }
[18:04:23.263]         }
[18:04:23.263]     })
[18:04:23.263]     if (TRUE) {
[18:04:23.263]         base::sink(type = "output", split = FALSE)
[18:04:23.263]         if (TRUE) {
[18:04:23.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.263]         }
[18:04:23.263]         else {
[18:04:23.263]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.263]         }
[18:04:23.263]         base::close(...future.stdout)
[18:04:23.263]         ...future.stdout <- NULL
[18:04:23.263]     }
[18:04:23.263]     ...future.result$conditions <- ...future.conditions
[18:04:23.263]     ...future.result$finished <- base::Sys.time()
[18:04:23.263]     ...future.result
[18:04:23.263] }
[18:04:23.369] MultisessionFuture started
[18:04:23.369] - Launch lazy future ... done
[18:04:23.372] run() for ‘MultisessionFuture’ ... done
[18:04:23.373] getGlobalsAndPackages() ...
[18:04:23.373] Searching for globals...
[18:04:23.374] - globals found: [1] ‘{’
[18:04:23.375] Searching for globals ... DONE
[18:04:23.375] Resolving globals: FALSE
[18:04:23.375] 
[18:04:23.376] 
[18:04:23.376] getGlobalsAndPackages() ... DONE
[18:04:23.376] run() for ‘Future’ ...
[18:04:23.377] - state: ‘created’
[18:04:23.377] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.403] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.404]   - Field: ‘node’
[18:04:23.404]   - Field: ‘label’
[18:04:23.404]   - Field: ‘local’
[18:04:23.405]   - Field: ‘owner’
[18:04:23.405]   - Field: ‘envir’
[18:04:23.405]   - Field: ‘workers’
[18:04:23.405]   - Field: ‘packages’
[18:04:23.405]   - Field: ‘gc’
[18:04:23.406]   - Field: ‘conditions’
[18:04:23.406]   - Field: ‘persistent’
[18:04:23.406]   - Field: ‘expr’
[18:04:23.406]   - Field: ‘uuid’
[18:04:23.406]   - Field: ‘seed’
[18:04:23.407]   - Field: ‘version’
[18:04:23.407]   - Field: ‘result’
[18:04:23.407]   - Field: ‘asynchronous’
[18:04:23.407]   - Field: ‘calls’
[18:04:23.407]   - Field: ‘globals’
[18:04:23.408]   - Field: ‘stdout’
[18:04:23.408]   - Field: ‘earlySignal’
[18:04:23.408]   - Field: ‘lazy’
[18:04:23.408]   - Field: ‘state’
[18:04:23.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.409] - Launch lazy future ...
[18:04:23.409] Packages needed by the future expression (n = 0): <none>
[18:04:23.409] Packages needed by future strategies (n = 0): <none>
[18:04:23.410] {
[18:04:23.410]     {
[18:04:23.410]         {
[18:04:23.410]             ...future.startTime <- base::Sys.time()
[18:04:23.410]             {
[18:04:23.410]                 {
[18:04:23.410]                   {
[18:04:23.410]                     {
[18:04:23.410]                       base::local({
[18:04:23.410]                         has_future <- base::requireNamespace("future", 
[18:04:23.410]                           quietly = TRUE)
[18:04:23.410]                         if (has_future) {
[18:04:23.410]                           ns <- base::getNamespace("future")
[18:04:23.410]                           version <- ns[[".package"]][["version"]]
[18:04:23.410]                           if (is.null(version)) 
[18:04:23.410]                             version <- utils::packageVersion("future")
[18:04:23.410]                         }
[18:04:23.410]                         else {
[18:04:23.410]                           version <- NULL
[18:04:23.410]                         }
[18:04:23.410]                         if (!has_future || version < "1.8.0") {
[18:04:23.410]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.410]                             "", base::R.version$version.string), 
[18:04:23.410]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.410]                               "release", "version")], collapse = " "), 
[18:04:23.410]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.410]                             info)
[18:04:23.410]                           info <- base::paste(info, collapse = "; ")
[18:04:23.410]                           if (!has_future) {
[18:04:23.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.410]                               info)
[18:04:23.410]                           }
[18:04:23.410]                           else {
[18:04:23.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.410]                               info, version)
[18:04:23.410]                           }
[18:04:23.410]                           base::stop(msg)
[18:04:23.410]                         }
[18:04:23.410]                       })
[18:04:23.410]                     }
[18:04:23.410]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.410]                     base::options(mc.cores = 1L)
[18:04:23.410]                   }
[18:04:23.410]                   ...future.strategy.old <- future::plan("list")
[18:04:23.410]                   options(future.plan = NULL)
[18:04:23.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.410]                 }
[18:04:23.410]                 ...future.workdir <- getwd()
[18:04:23.410]             }
[18:04:23.410]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.410]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.410]         }
[18:04:23.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.410]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.410]             base::names(...future.oldOptions))
[18:04:23.410]     }
[18:04:23.410]     if (FALSE) {
[18:04:23.410]     }
[18:04:23.410]     else {
[18:04:23.410]         if (TRUE) {
[18:04:23.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.410]                 open = "w")
[18:04:23.410]         }
[18:04:23.410]         else {
[18:04:23.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.410]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.410]         }
[18:04:23.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.410]             base::sink(type = "output", split = FALSE)
[18:04:23.410]             base::close(...future.stdout)
[18:04:23.410]         }, add = TRUE)
[18:04:23.410]     }
[18:04:23.410]     ...future.frame <- base::sys.nframe()
[18:04:23.410]     ...future.conditions <- base::list()
[18:04:23.410]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.410]     if (FALSE) {
[18:04:23.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.410]     }
[18:04:23.410]     ...future.result <- base::tryCatch({
[18:04:23.410]         base::withCallingHandlers({
[18:04:23.410]             ...future.value <- base::withVisible(base::local({
[18:04:23.410]                 ...future.makeSendCondition <- base::local({
[18:04:23.410]                   sendCondition <- NULL
[18:04:23.410]                   function(frame = 1L) {
[18:04:23.410]                     if (is.function(sendCondition)) 
[18:04:23.410]                       return(sendCondition)
[18:04:23.410]                     ns <- getNamespace("parallel")
[18:04:23.410]                     if (exists("sendData", mode = "function", 
[18:04:23.410]                       envir = ns)) {
[18:04:23.410]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.410]                         envir = ns)
[18:04:23.410]                       envir <- sys.frame(frame)
[18:04:23.410]                       master <- NULL
[18:04:23.410]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.410]                         !identical(envir, emptyenv())) {
[18:04:23.410]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.410]                           inherits = FALSE)) {
[18:04:23.410]                           master <- get("master", mode = "list", 
[18:04:23.410]                             envir = envir, inherits = FALSE)
[18:04:23.410]                           if (inherits(master, c("SOCKnode", 
[18:04:23.410]                             "SOCK0node"))) {
[18:04:23.410]                             sendCondition <<- function(cond) {
[18:04:23.410]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.410]                                 success = TRUE)
[18:04:23.410]                               parallel_sendData(master, data)
[18:04:23.410]                             }
[18:04:23.410]                             return(sendCondition)
[18:04:23.410]                           }
[18:04:23.410]                         }
[18:04:23.410]                         frame <- frame + 1L
[18:04:23.410]                         envir <- sys.frame(frame)
[18:04:23.410]                       }
[18:04:23.410]                     }
[18:04:23.410]                     sendCondition <<- function(cond) NULL
[18:04:23.410]                   }
[18:04:23.410]                 })
[18:04:23.410]                 withCallingHandlers({
[18:04:23.410]                   {
[18:04:23.410]                     4
[18:04:23.410]                   }
[18:04:23.410]                 }, immediateCondition = function(cond) {
[18:04:23.410]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.410]                   sendCondition(cond)
[18:04:23.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.410]                   {
[18:04:23.410]                     inherits <- base::inherits
[18:04:23.410]                     invokeRestart <- base::invokeRestart
[18:04:23.410]                     is.null <- base::is.null
[18:04:23.410]                     muffled <- FALSE
[18:04:23.410]                     if (inherits(cond, "message")) {
[18:04:23.410]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.410]                       if (muffled) 
[18:04:23.410]                         invokeRestart("muffleMessage")
[18:04:23.410]                     }
[18:04:23.410]                     else if (inherits(cond, "warning")) {
[18:04:23.410]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.410]                       if (muffled) 
[18:04:23.410]                         invokeRestart("muffleWarning")
[18:04:23.410]                     }
[18:04:23.410]                     else if (inherits(cond, "condition")) {
[18:04:23.410]                       if (!is.null(pattern)) {
[18:04:23.410]                         computeRestarts <- base::computeRestarts
[18:04:23.410]                         grepl <- base::grepl
[18:04:23.410]                         restarts <- computeRestarts(cond)
[18:04:23.410]                         for (restart in restarts) {
[18:04:23.410]                           name <- restart$name
[18:04:23.410]                           if (is.null(name)) 
[18:04:23.410]                             next
[18:04:23.410]                           if (!grepl(pattern, name)) 
[18:04:23.410]                             next
[18:04:23.410]                           invokeRestart(restart)
[18:04:23.410]                           muffled <- TRUE
[18:04:23.410]                           break
[18:04:23.410]                         }
[18:04:23.410]                       }
[18:04:23.410]                     }
[18:04:23.410]                     invisible(muffled)
[18:04:23.410]                   }
[18:04:23.410]                   muffleCondition(cond)
[18:04:23.410]                 })
[18:04:23.410]             }))
[18:04:23.410]             future::FutureResult(value = ...future.value$value, 
[18:04:23.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.410]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.410]                     ...future.globalenv.names))
[18:04:23.410]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.410]         }, condition = base::local({
[18:04:23.410]             c <- base::c
[18:04:23.410]             inherits <- base::inherits
[18:04:23.410]             invokeRestart <- base::invokeRestart
[18:04:23.410]             length <- base::length
[18:04:23.410]             list <- base::list
[18:04:23.410]             seq.int <- base::seq.int
[18:04:23.410]             signalCondition <- base::signalCondition
[18:04:23.410]             sys.calls <- base::sys.calls
[18:04:23.410]             `[[` <- base::`[[`
[18:04:23.410]             `+` <- base::`+`
[18:04:23.410]             `<<-` <- base::`<<-`
[18:04:23.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.410]                   3L)]
[18:04:23.410]             }
[18:04:23.410]             function(cond) {
[18:04:23.410]                 is_error <- inherits(cond, "error")
[18:04:23.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.410]                   NULL)
[18:04:23.410]                 if (is_error) {
[18:04:23.410]                   sessionInformation <- function() {
[18:04:23.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.410]                       search = base::search(), system = base::Sys.info())
[18:04:23.410]                   }
[18:04:23.410]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.410]                     cond$call), session = sessionInformation(), 
[18:04:23.410]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.410]                   signalCondition(cond)
[18:04:23.410]                 }
[18:04:23.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.410]                 "immediateCondition"))) {
[18:04:23.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.410]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.410]                   if (TRUE && !signal) {
[18:04:23.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.410]                     {
[18:04:23.410]                       inherits <- base::inherits
[18:04:23.410]                       invokeRestart <- base::invokeRestart
[18:04:23.410]                       is.null <- base::is.null
[18:04:23.410]                       muffled <- FALSE
[18:04:23.410]                       if (inherits(cond, "message")) {
[18:04:23.410]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.410]                         if (muffled) 
[18:04:23.410]                           invokeRestart("muffleMessage")
[18:04:23.410]                       }
[18:04:23.410]                       else if (inherits(cond, "warning")) {
[18:04:23.410]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.410]                         if (muffled) 
[18:04:23.410]                           invokeRestart("muffleWarning")
[18:04:23.410]                       }
[18:04:23.410]                       else if (inherits(cond, "condition")) {
[18:04:23.410]                         if (!is.null(pattern)) {
[18:04:23.410]                           computeRestarts <- base::computeRestarts
[18:04:23.410]                           grepl <- base::grepl
[18:04:23.410]                           restarts <- computeRestarts(cond)
[18:04:23.410]                           for (restart in restarts) {
[18:04:23.410]                             name <- restart$name
[18:04:23.410]                             if (is.null(name)) 
[18:04:23.410]                               next
[18:04:23.410]                             if (!grepl(pattern, name)) 
[18:04:23.410]                               next
[18:04:23.410]                             invokeRestart(restart)
[18:04:23.410]                             muffled <- TRUE
[18:04:23.410]                             break
[18:04:23.410]                           }
[18:04:23.410]                         }
[18:04:23.410]                       }
[18:04:23.410]                       invisible(muffled)
[18:04:23.410]                     }
[18:04:23.410]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.410]                   }
[18:04:23.410]                 }
[18:04:23.410]                 else {
[18:04:23.410]                   if (TRUE) {
[18:04:23.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.410]                     {
[18:04:23.410]                       inherits <- base::inherits
[18:04:23.410]                       invokeRestart <- base::invokeRestart
[18:04:23.410]                       is.null <- base::is.null
[18:04:23.410]                       muffled <- FALSE
[18:04:23.410]                       if (inherits(cond, "message")) {
[18:04:23.410]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.410]                         if (muffled) 
[18:04:23.410]                           invokeRestart("muffleMessage")
[18:04:23.410]                       }
[18:04:23.410]                       else if (inherits(cond, "warning")) {
[18:04:23.410]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.410]                         if (muffled) 
[18:04:23.410]                           invokeRestart("muffleWarning")
[18:04:23.410]                       }
[18:04:23.410]                       else if (inherits(cond, "condition")) {
[18:04:23.410]                         if (!is.null(pattern)) {
[18:04:23.410]                           computeRestarts <- base::computeRestarts
[18:04:23.410]                           grepl <- base::grepl
[18:04:23.410]                           restarts <- computeRestarts(cond)
[18:04:23.410]                           for (restart in restarts) {
[18:04:23.410]                             name <- restart$name
[18:04:23.410]                             if (is.null(name)) 
[18:04:23.410]                               next
[18:04:23.410]                             if (!grepl(pattern, name)) 
[18:04:23.410]                               next
[18:04:23.410]                             invokeRestart(restart)
[18:04:23.410]                             muffled <- TRUE
[18:04:23.410]                             break
[18:04:23.410]                           }
[18:04:23.410]                         }
[18:04:23.410]                       }
[18:04:23.410]                       invisible(muffled)
[18:04:23.410]                     }
[18:04:23.410]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.410]                   }
[18:04:23.410]                 }
[18:04:23.410]             }
[18:04:23.410]         }))
[18:04:23.410]     }, error = function(ex) {
[18:04:23.410]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.410]                 ...future.rng), started = ...future.startTime, 
[18:04:23.410]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.410]             version = "1.8"), class = "FutureResult")
[18:04:23.410]     }, finally = {
[18:04:23.410]         if (!identical(...future.workdir, getwd())) 
[18:04:23.410]             setwd(...future.workdir)
[18:04:23.410]         {
[18:04:23.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.410]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.410]             }
[18:04:23.410]             base::options(...future.oldOptions)
[18:04:23.410]             if (.Platform$OS.type == "windows") {
[18:04:23.410]                 old_names <- names(...future.oldEnvVars)
[18:04:23.410]                 envs <- base::Sys.getenv()
[18:04:23.410]                 names <- names(envs)
[18:04:23.410]                 common <- intersect(names, old_names)
[18:04:23.410]                 added <- setdiff(names, old_names)
[18:04:23.410]                 removed <- setdiff(old_names, names)
[18:04:23.410]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.410]                   envs[common]]
[18:04:23.410]                 NAMES <- toupper(changed)
[18:04:23.410]                 args <- list()
[18:04:23.410]                 for (kk in seq_along(NAMES)) {
[18:04:23.410]                   name <- changed[[kk]]
[18:04:23.410]                   NAME <- NAMES[[kk]]
[18:04:23.410]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.410]                     next
[18:04:23.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.410]                 }
[18:04:23.410]                 NAMES <- toupper(added)
[18:04:23.410]                 for (kk in seq_along(NAMES)) {
[18:04:23.410]                   name <- added[[kk]]
[18:04:23.410]                   NAME <- NAMES[[kk]]
[18:04:23.410]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.410]                     next
[18:04:23.410]                   args[[name]] <- ""
[18:04:23.410]                 }
[18:04:23.410]                 NAMES <- toupper(removed)
[18:04:23.410]                 for (kk in seq_along(NAMES)) {
[18:04:23.410]                   name <- removed[[kk]]
[18:04:23.410]                   NAME <- NAMES[[kk]]
[18:04:23.410]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.410]                     next
[18:04:23.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.410]                 }
[18:04:23.410]                 if (length(args) > 0) 
[18:04:23.410]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.410]             }
[18:04:23.410]             else {
[18:04:23.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.410]             }
[18:04:23.410]             {
[18:04:23.410]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.410]                   0L) {
[18:04:23.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.410]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.410]                   base::options(opts)
[18:04:23.410]                 }
[18:04:23.410]                 {
[18:04:23.410]                   {
[18:04:23.410]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.410]                     NULL
[18:04:23.410]                   }
[18:04:23.410]                   options(future.plan = NULL)
[18:04:23.410]                   if (is.na(NA_character_)) 
[18:04:23.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.410]                     .init = FALSE)
[18:04:23.410]                 }
[18:04:23.410]             }
[18:04:23.410]         }
[18:04:23.410]     })
[18:04:23.410]     if (TRUE) {
[18:04:23.410]         base::sink(type = "output", split = FALSE)
[18:04:23.410]         if (TRUE) {
[18:04:23.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.410]         }
[18:04:23.410]         else {
[18:04:23.410]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.410]         }
[18:04:23.410]         base::close(...future.stdout)
[18:04:23.410]         ...future.stdout <- NULL
[18:04:23.410]     }
[18:04:23.410]     ...future.result$conditions <- ...future.conditions
[18:04:23.410]     ...future.result$finished <- base::Sys.time()
[18:04:23.410]     ...future.result
[18:04:23.410] }
[18:04:23.414] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:23.426] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.426] - Validating connection of MultisessionFuture
[18:04:23.426] - received message: FutureResult
[18:04:23.427] - Received FutureResult
[18:04:23.427] - Erased future from FutureRegistry
[18:04:23.427] result() for ClusterFuture ...
[18:04:23.427] - result already collected: FutureResult
[18:04:23.427] result() for ClusterFuture ... done
[18:04:23.428] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:23.428] result() for ClusterFuture ...
[18:04:23.428] - result already collected: FutureResult
[18:04:23.428] result() for ClusterFuture ... done
[18:04:23.428] result() for ClusterFuture ...
[18:04:23.429] - result already collected: FutureResult
[18:04:23.429] result() for ClusterFuture ... done
[18:04:23.431] MultisessionFuture started
[18:04:23.431] - Launch lazy future ... done
[18:04:23.431] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2cb12520> 
Classes 'listenv', 'environment' <environment: 0x5e3c2b355b88> 
[18:04:23.438] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.438] - Validating connection of MultisessionFuture
[18:04:23.439] - received message: FutureResult
[18:04:23.439] - Received FutureResult
[18:04:23.439] - Erased future from FutureRegistry
[18:04:23.439] result() for ClusterFuture ...
[18:04:23.440] - result already collected: FutureResult
[18:04:23.440] result() for ClusterFuture ... done
[18:04:23.440] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:23.454] resolve() on list environment ...
[18:04:23.455]  recursive: 0
[18:04:23.457]  length: 6
[18:04:23.457]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:23.457] signalConditionsASAP(numeric, pos=1) ...
[18:04:23.457] - nx: 6
[18:04:23.458] - relay: TRUE
[18:04:23.458] - stdout: TRUE
[18:04:23.458] - signal: TRUE
[18:04:23.458] - resignal: FALSE
[18:04:23.458] - force: TRUE
[18:04:23.459] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.459] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.459]  - until=2
[18:04:23.459]  - relaying element #2
[18:04:23.459] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.460] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.460] signalConditionsASAP(NULL, pos=1) ... done
[18:04:23.460]  length: 5 (resolved future 1)
[18:04:23.460] Future #2
[18:04:23.461] result() for ClusterFuture ...
[18:04:23.461] - result already collected: FutureResult
[18:04:23.461] result() for ClusterFuture ... done
[18:04:23.461] result() for ClusterFuture ...
[18:04:23.461] - result already collected: FutureResult
[18:04:23.462] result() for ClusterFuture ... done
[18:04:23.462] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:23.462] - nx: 6
[18:04:23.462] - relay: TRUE
[18:04:23.462] - stdout: TRUE
[18:04:23.463] - signal: TRUE
[18:04:23.463] - resignal: FALSE
[18:04:23.463] - force: TRUE
[18:04:23.463] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.463] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.464]  - until=2
[18:04:23.464]  - relaying element #2
[18:04:23.464] result() for ClusterFuture ...
[18:04:23.464] - result already collected: FutureResult
[18:04:23.464] result() for ClusterFuture ... done
[18:04:23.465] result() for ClusterFuture ...
[18:04:23.465] - result already collected: FutureResult
[18:04:23.465] result() for ClusterFuture ... done
[18:04:23.465] result() for ClusterFuture ...
[18:04:23.466] - result already collected: FutureResult
[18:04:23.466] result() for ClusterFuture ... done
[18:04:23.466] result() for ClusterFuture ...
[18:04:23.466] - result already collected: FutureResult
[18:04:23.466] result() for ClusterFuture ... done
[18:04:23.467] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.467] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.467] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:23.467]  length: 4 (resolved future 2)
[18:04:23.468] Future #3
[18:04:23.468] result() for ClusterFuture ...
[18:04:23.468] - result already collected: FutureResult
[18:04:23.468] result() for ClusterFuture ... done
[18:04:23.468] result() for ClusterFuture ...
[18:04:23.469] - result already collected: FutureResult
[18:04:23.469] result() for ClusterFuture ... done
[18:04:23.469] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:23.469] - nx: 6
[18:04:23.469] - relay: TRUE
[18:04:23.470] - stdout: TRUE
[18:04:23.470] - signal: TRUE
[18:04:23.470] - resignal: FALSE
[18:04:23.470] - force: TRUE
[18:04:23.470] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.471] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.471]  - until=3
[18:04:23.471]  - relaying element #3
[18:04:23.471] result() for ClusterFuture ...
[18:04:23.471] - result already collected: FutureResult
[18:04:23.472] result() for ClusterFuture ... done
[18:04:23.473] result() for ClusterFuture ...
[18:04:23.473] - result already collected: FutureResult
[18:04:23.473] result() for ClusterFuture ... done
[18:04:23.474] result() for ClusterFuture ...
[18:04:23.474] - result already collected: FutureResult
[18:04:23.474] result() for ClusterFuture ... done
[18:04:23.474] result() for ClusterFuture ...
[18:04:23.475] - result already collected: FutureResult
[18:04:23.475] result() for ClusterFuture ... done
[18:04:23.475] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.475] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.475] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:23.476]  length: 3 (resolved future 3)
[18:04:23.479] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.480] - Validating connection of MultisessionFuture
[18:04:23.480] - received message: FutureResult
[18:04:23.480] - Received FutureResult
[18:04:23.480] - Erased future from FutureRegistry
[18:04:23.481] result() for ClusterFuture ...
[18:04:23.481] - result already collected: FutureResult
[18:04:23.481] result() for ClusterFuture ... done
[18:04:23.481] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:23.481] Future #4
[18:04:23.482] result() for ClusterFuture ...
[18:04:23.482] - result already collected: FutureResult
[18:04:23.482] result() for ClusterFuture ... done
[18:04:23.482] result() for ClusterFuture ...
[18:04:23.482] - result already collected: FutureResult
[18:04:23.483] result() for ClusterFuture ... done
[18:04:23.483] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:23.483] - nx: 6
[18:04:23.483] - relay: TRUE
[18:04:23.483] - stdout: TRUE
[18:04:23.484] - signal: TRUE
[18:04:23.484] - resignal: FALSE
[18:04:23.484] - force: TRUE
[18:04:23.484] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.484] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.484]  - until=4
[18:04:23.485]  - relaying element #4
[18:04:23.485] result() for ClusterFuture ...
[18:04:23.485] - result already collected: FutureResult
[18:04:23.485] result() for ClusterFuture ... done
[18:04:23.485] result() for ClusterFuture ...
[18:04:23.486] - result already collected: FutureResult
[18:04:23.486] result() for ClusterFuture ... done
[18:04:23.486] result() for ClusterFuture ...
[18:04:23.486] - result already collected: FutureResult
[18:04:23.486] result() for ClusterFuture ... done
[18:04:23.487] result() for ClusterFuture ...
[18:04:23.487] - result already collected: FutureResult
[18:04:23.487] result() for ClusterFuture ... done
[18:04:23.487] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.487] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.487] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:23.488]  length: 2 (resolved future 4)
[18:04:23.488] signalConditionsASAP(NULL, pos=5) ...
[18:04:23.488] - nx: 6
[18:04:23.488] - relay: TRUE
[18:04:23.488] - stdout: TRUE
[18:04:23.489] - signal: TRUE
[18:04:23.489] - resignal: FALSE
[18:04:23.489] - force: TRUE
[18:04:23.489] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.489] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.490]  - until=6
[18:04:23.490]  - relaying element #6
[18:04:23.490] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:23.490] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.490] signalConditionsASAP(NULL, pos=5) ... done
[18:04:23.491]  length: 1 (resolved future 5)
[18:04:23.491] signalConditionsASAP(numeric, pos=6) ...
[18:04:23.491] - nx: 6
[18:04:23.491] - relay: TRUE
[18:04:23.491] - stdout: TRUE
[18:04:23.491] - signal: TRUE
[18:04:23.492] - resignal: FALSE
[18:04:23.492] - force: TRUE
[18:04:23.492] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:23.492] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.492]  - until=6
[18:04:23.493] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:23.493] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.493] signalConditionsASAP(numeric, pos=6) ... done
[18:04:23.493]  length: 0 (resolved future 6)
[18:04:23.493] Relaying remaining futures
[18:04:23.493] signalConditionsASAP(NULL, pos=0) ...
[18:04:23.494] - nx: 6
[18:04:23.494] - relay: TRUE
[18:04:23.494] - stdout: TRUE
[18:04:23.494] - signal: TRUE
[18:04:23.494] - resignal: FALSE
[18:04:23.494] - force: TRUE
[18:04:23.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:23.495] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:23.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:23.495] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.496] signalConditionsASAP(NULL, pos=0) ... done
[18:04:23.496] resolve() on list environment ... DONE
[18:04:23.496] result() for ClusterFuture ...
[18:04:23.496] - result already collected: FutureResult
[18:04:23.496] result() for ClusterFuture ... done
[18:04:23.497] result() for ClusterFuture ...
[18:04:23.497] - result already collected: FutureResult
[18:04:23.497] result() for ClusterFuture ... done
[18:04:23.497] result() for ClusterFuture ...
[18:04:23.497] - result already collected: FutureResult
[18:04:23.498] result() for ClusterFuture ... done
[18:04:23.498] result() for ClusterFuture ...
[18:04:23.498] - result already collected: FutureResult
[18:04:23.498] result() for ClusterFuture ... done
[18:04:23.499] result() for ClusterFuture ...
[18:04:23.499] - result already collected: FutureResult
[18:04:23.499] result() for ClusterFuture ... done
[18:04:23.499] result() for ClusterFuture ...
[18:04:23.500] - result already collected: FutureResult
[18:04:23.500] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2b075f18> 
Dimensions: c(1, 6)
[18:04:23.501] getGlobalsAndPackages() ...
[18:04:23.501] Searching for globals...
[18:04:23.502] 
[18:04:23.502] Searching for globals ... DONE
[18:04:23.502] - globals: [0] <none>
[18:04:23.502] getGlobalsAndPackages() ... DONE
[18:04:23.503] run() for ‘Future’ ...
[18:04:23.503] - state: ‘created’
[18:04:23.503] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.528] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.529]   - Field: ‘node’
[18:04:23.529]   - Field: ‘label’
[18:04:23.529]   - Field: ‘local’
[18:04:23.529]   - Field: ‘owner’
[18:04:23.529]   - Field: ‘envir’
[18:04:23.530]   - Field: ‘workers’
[18:04:23.530]   - Field: ‘packages’
[18:04:23.530]   - Field: ‘gc’
[18:04:23.530]   - Field: ‘conditions’
[18:04:23.531]   - Field: ‘persistent’
[18:04:23.531]   - Field: ‘expr’
[18:04:23.531]   - Field: ‘uuid’
[18:04:23.531]   - Field: ‘seed’
[18:04:23.532]   - Field: ‘version’
[18:04:23.532]   - Field: ‘result’
[18:04:23.532]   - Field: ‘asynchronous’
[18:04:23.532]   - Field: ‘calls’
[18:04:23.532]   - Field: ‘globals’
[18:04:23.533]   - Field: ‘stdout’
[18:04:23.533]   - Field: ‘earlySignal’
[18:04:23.533]   - Field: ‘lazy’
[18:04:23.533]   - Field: ‘state’
[18:04:23.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.534] - Launch lazy future ...
[18:04:23.534] Packages needed by the future expression (n = 0): <none>
[18:04:23.534] Packages needed by future strategies (n = 0): <none>
[18:04:23.535] {
[18:04:23.535]     {
[18:04:23.535]         {
[18:04:23.535]             ...future.startTime <- base::Sys.time()
[18:04:23.535]             {
[18:04:23.535]                 {
[18:04:23.535]                   {
[18:04:23.535]                     {
[18:04:23.535]                       base::local({
[18:04:23.535]                         has_future <- base::requireNamespace("future", 
[18:04:23.535]                           quietly = TRUE)
[18:04:23.535]                         if (has_future) {
[18:04:23.535]                           ns <- base::getNamespace("future")
[18:04:23.535]                           version <- ns[[".package"]][["version"]]
[18:04:23.535]                           if (is.null(version)) 
[18:04:23.535]                             version <- utils::packageVersion("future")
[18:04:23.535]                         }
[18:04:23.535]                         else {
[18:04:23.535]                           version <- NULL
[18:04:23.535]                         }
[18:04:23.535]                         if (!has_future || version < "1.8.0") {
[18:04:23.535]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.535]                             "", base::R.version$version.string), 
[18:04:23.535]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.535]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.535]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.535]                               "release", "version")], collapse = " "), 
[18:04:23.535]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.535]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.535]                             info)
[18:04:23.535]                           info <- base::paste(info, collapse = "; ")
[18:04:23.535]                           if (!has_future) {
[18:04:23.535]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.535]                               info)
[18:04:23.535]                           }
[18:04:23.535]                           else {
[18:04:23.535]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.535]                               info, version)
[18:04:23.535]                           }
[18:04:23.535]                           base::stop(msg)
[18:04:23.535]                         }
[18:04:23.535]                       })
[18:04:23.535]                     }
[18:04:23.535]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.535]                     base::options(mc.cores = 1L)
[18:04:23.535]                   }
[18:04:23.535]                   ...future.strategy.old <- future::plan("list")
[18:04:23.535]                   options(future.plan = NULL)
[18:04:23.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.535]                 }
[18:04:23.535]                 ...future.workdir <- getwd()
[18:04:23.535]             }
[18:04:23.535]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.535]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.535]         }
[18:04:23.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.535]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.535]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.535]             base::names(...future.oldOptions))
[18:04:23.535]     }
[18:04:23.535]     if (FALSE) {
[18:04:23.535]     }
[18:04:23.535]     else {
[18:04:23.535]         if (TRUE) {
[18:04:23.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.535]                 open = "w")
[18:04:23.535]         }
[18:04:23.535]         else {
[18:04:23.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.535]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.535]         }
[18:04:23.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.535]             base::sink(type = "output", split = FALSE)
[18:04:23.535]             base::close(...future.stdout)
[18:04:23.535]         }, add = TRUE)
[18:04:23.535]     }
[18:04:23.535]     ...future.frame <- base::sys.nframe()
[18:04:23.535]     ...future.conditions <- base::list()
[18:04:23.535]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.535]     if (FALSE) {
[18:04:23.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.535]     }
[18:04:23.535]     ...future.result <- base::tryCatch({
[18:04:23.535]         base::withCallingHandlers({
[18:04:23.535]             ...future.value <- base::withVisible(base::local({
[18:04:23.535]                 ...future.makeSendCondition <- base::local({
[18:04:23.535]                   sendCondition <- NULL
[18:04:23.535]                   function(frame = 1L) {
[18:04:23.535]                     if (is.function(sendCondition)) 
[18:04:23.535]                       return(sendCondition)
[18:04:23.535]                     ns <- getNamespace("parallel")
[18:04:23.535]                     if (exists("sendData", mode = "function", 
[18:04:23.535]                       envir = ns)) {
[18:04:23.535]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.535]                         envir = ns)
[18:04:23.535]                       envir <- sys.frame(frame)
[18:04:23.535]                       master <- NULL
[18:04:23.535]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.535]                         !identical(envir, emptyenv())) {
[18:04:23.535]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.535]                           inherits = FALSE)) {
[18:04:23.535]                           master <- get("master", mode = "list", 
[18:04:23.535]                             envir = envir, inherits = FALSE)
[18:04:23.535]                           if (inherits(master, c("SOCKnode", 
[18:04:23.535]                             "SOCK0node"))) {
[18:04:23.535]                             sendCondition <<- function(cond) {
[18:04:23.535]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.535]                                 success = TRUE)
[18:04:23.535]                               parallel_sendData(master, data)
[18:04:23.535]                             }
[18:04:23.535]                             return(sendCondition)
[18:04:23.535]                           }
[18:04:23.535]                         }
[18:04:23.535]                         frame <- frame + 1L
[18:04:23.535]                         envir <- sys.frame(frame)
[18:04:23.535]                       }
[18:04:23.535]                     }
[18:04:23.535]                     sendCondition <<- function(cond) NULL
[18:04:23.535]                   }
[18:04:23.535]                 })
[18:04:23.535]                 withCallingHandlers({
[18:04:23.535]                   2
[18:04:23.535]                 }, immediateCondition = function(cond) {
[18:04:23.535]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.535]                   sendCondition(cond)
[18:04:23.535]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.535]                   {
[18:04:23.535]                     inherits <- base::inherits
[18:04:23.535]                     invokeRestart <- base::invokeRestart
[18:04:23.535]                     is.null <- base::is.null
[18:04:23.535]                     muffled <- FALSE
[18:04:23.535]                     if (inherits(cond, "message")) {
[18:04:23.535]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.535]                       if (muffled) 
[18:04:23.535]                         invokeRestart("muffleMessage")
[18:04:23.535]                     }
[18:04:23.535]                     else if (inherits(cond, "warning")) {
[18:04:23.535]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.535]                       if (muffled) 
[18:04:23.535]                         invokeRestart("muffleWarning")
[18:04:23.535]                     }
[18:04:23.535]                     else if (inherits(cond, "condition")) {
[18:04:23.535]                       if (!is.null(pattern)) {
[18:04:23.535]                         computeRestarts <- base::computeRestarts
[18:04:23.535]                         grepl <- base::grepl
[18:04:23.535]                         restarts <- computeRestarts(cond)
[18:04:23.535]                         for (restart in restarts) {
[18:04:23.535]                           name <- restart$name
[18:04:23.535]                           if (is.null(name)) 
[18:04:23.535]                             next
[18:04:23.535]                           if (!grepl(pattern, name)) 
[18:04:23.535]                             next
[18:04:23.535]                           invokeRestart(restart)
[18:04:23.535]                           muffled <- TRUE
[18:04:23.535]                           break
[18:04:23.535]                         }
[18:04:23.535]                       }
[18:04:23.535]                     }
[18:04:23.535]                     invisible(muffled)
[18:04:23.535]                   }
[18:04:23.535]                   muffleCondition(cond)
[18:04:23.535]                 })
[18:04:23.535]             }))
[18:04:23.535]             future::FutureResult(value = ...future.value$value, 
[18:04:23.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.535]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.535]                     ...future.globalenv.names))
[18:04:23.535]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.535]         }, condition = base::local({
[18:04:23.535]             c <- base::c
[18:04:23.535]             inherits <- base::inherits
[18:04:23.535]             invokeRestart <- base::invokeRestart
[18:04:23.535]             length <- base::length
[18:04:23.535]             list <- base::list
[18:04:23.535]             seq.int <- base::seq.int
[18:04:23.535]             signalCondition <- base::signalCondition
[18:04:23.535]             sys.calls <- base::sys.calls
[18:04:23.535]             `[[` <- base::`[[`
[18:04:23.535]             `+` <- base::`+`
[18:04:23.535]             `<<-` <- base::`<<-`
[18:04:23.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.535]                   3L)]
[18:04:23.535]             }
[18:04:23.535]             function(cond) {
[18:04:23.535]                 is_error <- inherits(cond, "error")
[18:04:23.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.535]                   NULL)
[18:04:23.535]                 if (is_error) {
[18:04:23.535]                   sessionInformation <- function() {
[18:04:23.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.535]                       search = base::search(), system = base::Sys.info())
[18:04:23.535]                   }
[18:04:23.535]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.535]                     cond$call), session = sessionInformation(), 
[18:04:23.535]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.535]                   signalCondition(cond)
[18:04:23.535]                 }
[18:04:23.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.535]                 "immediateCondition"))) {
[18:04:23.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.535]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.535]                   if (TRUE && !signal) {
[18:04:23.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.535]                     {
[18:04:23.535]                       inherits <- base::inherits
[18:04:23.535]                       invokeRestart <- base::invokeRestart
[18:04:23.535]                       is.null <- base::is.null
[18:04:23.535]                       muffled <- FALSE
[18:04:23.535]                       if (inherits(cond, "message")) {
[18:04:23.535]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.535]                         if (muffled) 
[18:04:23.535]                           invokeRestart("muffleMessage")
[18:04:23.535]                       }
[18:04:23.535]                       else if (inherits(cond, "warning")) {
[18:04:23.535]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.535]                         if (muffled) 
[18:04:23.535]                           invokeRestart("muffleWarning")
[18:04:23.535]                       }
[18:04:23.535]                       else if (inherits(cond, "condition")) {
[18:04:23.535]                         if (!is.null(pattern)) {
[18:04:23.535]                           computeRestarts <- base::computeRestarts
[18:04:23.535]                           grepl <- base::grepl
[18:04:23.535]                           restarts <- computeRestarts(cond)
[18:04:23.535]                           for (restart in restarts) {
[18:04:23.535]                             name <- restart$name
[18:04:23.535]                             if (is.null(name)) 
[18:04:23.535]                               next
[18:04:23.535]                             if (!grepl(pattern, name)) 
[18:04:23.535]                               next
[18:04:23.535]                             invokeRestart(restart)
[18:04:23.535]                             muffled <- TRUE
[18:04:23.535]                             break
[18:04:23.535]                           }
[18:04:23.535]                         }
[18:04:23.535]                       }
[18:04:23.535]                       invisible(muffled)
[18:04:23.535]                     }
[18:04:23.535]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.535]                   }
[18:04:23.535]                 }
[18:04:23.535]                 else {
[18:04:23.535]                   if (TRUE) {
[18:04:23.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.535]                     {
[18:04:23.535]                       inherits <- base::inherits
[18:04:23.535]                       invokeRestart <- base::invokeRestart
[18:04:23.535]                       is.null <- base::is.null
[18:04:23.535]                       muffled <- FALSE
[18:04:23.535]                       if (inherits(cond, "message")) {
[18:04:23.535]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.535]                         if (muffled) 
[18:04:23.535]                           invokeRestart("muffleMessage")
[18:04:23.535]                       }
[18:04:23.535]                       else if (inherits(cond, "warning")) {
[18:04:23.535]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.535]                         if (muffled) 
[18:04:23.535]                           invokeRestart("muffleWarning")
[18:04:23.535]                       }
[18:04:23.535]                       else if (inherits(cond, "condition")) {
[18:04:23.535]                         if (!is.null(pattern)) {
[18:04:23.535]                           computeRestarts <- base::computeRestarts
[18:04:23.535]                           grepl <- base::grepl
[18:04:23.535]                           restarts <- computeRestarts(cond)
[18:04:23.535]                           for (restart in restarts) {
[18:04:23.535]                             name <- restart$name
[18:04:23.535]                             if (is.null(name)) 
[18:04:23.535]                               next
[18:04:23.535]                             if (!grepl(pattern, name)) 
[18:04:23.535]                               next
[18:04:23.535]                             invokeRestart(restart)
[18:04:23.535]                             muffled <- TRUE
[18:04:23.535]                             break
[18:04:23.535]                           }
[18:04:23.535]                         }
[18:04:23.535]                       }
[18:04:23.535]                       invisible(muffled)
[18:04:23.535]                     }
[18:04:23.535]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.535]                   }
[18:04:23.535]                 }
[18:04:23.535]             }
[18:04:23.535]         }))
[18:04:23.535]     }, error = function(ex) {
[18:04:23.535]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.535]                 ...future.rng), started = ...future.startTime, 
[18:04:23.535]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.535]             version = "1.8"), class = "FutureResult")
[18:04:23.535]     }, finally = {
[18:04:23.535]         if (!identical(...future.workdir, getwd())) 
[18:04:23.535]             setwd(...future.workdir)
[18:04:23.535]         {
[18:04:23.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.535]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.535]             }
[18:04:23.535]             base::options(...future.oldOptions)
[18:04:23.535]             if (.Platform$OS.type == "windows") {
[18:04:23.535]                 old_names <- names(...future.oldEnvVars)
[18:04:23.535]                 envs <- base::Sys.getenv()
[18:04:23.535]                 names <- names(envs)
[18:04:23.535]                 common <- intersect(names, old_names)
[18:04:23.535]                 added <- setdiff(names, old_names)
[18:04:23.535]                 removed <- setdiff(old_names, names)
[18:04:23.535]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.535]                   envs[common]]
[18:04:23.535]                 NAMES <- toupper(changed)
[18:04:23.535]                 args <- list()
[18:04:23.535]                 for (kk in seq_along(NAMES)) {
[18:04:23.535]                   name <- changed[[kk]]
[18:04:23.535]                   NAME <- NAMES[[kk]]
[18:04:23.535]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.535]                     next
[18:04:23.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.535]                 }
[18:04:23.535]                 NAMES <- toupper(added)
[18:04:23.535]                 for (kk in seq_along(NAMES)) {
[18:04:23.535]                   name <- added[[kk]]
[18:04:23.535]                   NAME <- NAMES[[kk]]
[18:04:23.535]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.535]                     next
[18:04:23.535]                   args[[name]] <- ""
[18:04:23.535]                 }
[18:04:23.535]                 NAMES <- toupper(removed)
[18:04:23.535]                 for (kk in seq_along(NAMES)) {
[18:04:23.535]                   name <- removed[[kk]]
[18:04:23.535]                   NAME <- NAMES[[kk]]
[18:04:23.535]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.535]                     next
[18:04:23.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.535]                 }
[18:04:23.535]                 if (length(args) > 0) 
[18:04:23.535]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.535]             }
[18:04:23.535]             else {
[18:04:23.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.535]             }
[18:04:23.535]             {
[18:04:23.535]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.535]                   0L) {
[18:04:23.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.535]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.535]                   base::options(opts)
[18:04:23.535]                 }
[18:04:23.535]                 {
[18:04:23.535]                   {
[18:04:23.535]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.535]                     NULL
[18:04:23.535]                   }
[18:04:23.535]                   options(future.plan = NULL)
[18:04:23.535]                   if (is.na(NA_character_)) 
[18:04:23.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.535]                     .init = FALSE)
[18:04:23.535]                 }
[18:04:23.535]             }
[18:04:23.535]         }
[18:04:23.535]     })
[18:04:23.535]     if (TRUE) {
[18:04:23.535]         base::sink(type = "output", split = FALSE)
[18:04:23.535]         if (TRUE) {
[18:04:23.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.535]         }
[18:04:23.535]         else {
[18:04:23.535]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.535]         }
[18:04:23.535]         base::close(...future.stdout)
[18:04:23.535]         ...future.stdout <- NULL
[18:04:23.535]     }
[18:04:23.535]     ...future.result$conditions <- ...future.conditions
[18:04:23.535]     ...future.result$finished <- base::Sys.time()
[18:04:23.535]     ...future.result
[18:04:23.535] }
[18:04:23.541] MultisessionFuture started
[18:04:23.542] - Launch lazy future ... done
[18:04:23.542] run() for ‘MultisessionFuture’ ... done
[18:04:23.543] getGlobalsAndPackages() ...
[18:04:23.544] Searching for globals...
[18:04:23.544] 
[18:04:23.545] Searching for globals ... DONE
[18:04:23.545] - globals: [0] <none>
[18:04:23.545] getGlobalsAndPackages() ... DONE
[18:04:23.545] run() for ‘Future’ ...
[18:04:23.546] - state: ‘created’
[18:04:23.546] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.572]   - Field: ‘node’
[18:04:23.572]   - Field: ‘label’
[18:04:23.573]   - Field: ‘local’
[18:04:23.573]   - Field: ‘owner’
[18:04:23.573]   - Field: ‘envir’
[18:04:23.573]   - Field: ‘workers’
[18:04:23.573]   - Field: ‘packages’
[18:04:23.574]   - Field: ‘gc’
[18:04:23.574]   - Field: ‘conditions’
[18:04:23.574]   - Field: ‘persistent’
[18:04:23.574]   - Field: ‘expr’
[18:04:23.574]   - Field: ‘uuid’
[18:04:23.575]   - Field: ‘seed’
[18:04:23.575]   - Field: ‘version’
[18:04:23.575]   - Field: ‘result’
[18:04:23.575]   - Field: ‘asynchronous’
[18:04:23.575]   - Field: ‘calls’
[18:04:23.576]   - Field: ‘globals’
[18:04:23.576]   - Field: ‘stdout’
[18:04:23.576]   - Field: ‘earlySignal’
[18:04:23.576]   - Field: ‘lazy’
[18:04:23.576]   - Field: ‘state’
[18:04:23.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.577] - Launch lazy future ...
[18:04:23.577] Packages needed by the future expression (n = 0): <none>
[18:04:23.577] Packages needed by future strategies (n = 0): <none>
[18:04:23.578] {
[18:04:23.578]     {
[18:04:23.578]         {
[18:04:23.578]             ...future.startTime <- base::Sys.time()
[18:04:23.578]             {
[18:04:23.578]                 {
[18:04:23.578]                   {
[18:04:23.578]                     {
[18:04:23.578]                       base::local({
[18:04:23.578]                         has_future <- base::requireNamespace("future", 
[18:04:23.578]                           quietly = TRUE)
[18:04:23.578]                         if (has_future) {
[18:04:23.578]                           ns <- base::getNamespace("future")
[18:04:23.578]                           version <- ns[[".package"]][["version"]]
[18:04:23.578]                           if (is.null(version)) 
[18:04:23.578]                             version <- utils::packageVersion("future")
[18:04:23.578]                         }
[18:04:23.578]                         else {
[18:04:23.578]                           version <- NULL
[18:04:23.578]                         }
[18:04:23.578]                         if (!has_future || version < "1.8.0") {
[18:04:23.578]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.578]                             "", base::R.version$version.string), 
[18:04:23.578]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.578]                               "release", "version")], collapse = " "), 
[18:04:23.578]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.578]                             info)
[18:04:23.578]                           info <- base::paste(info, collapse = "; ")
[18:04:23.578]                           if (!has_future) {
[18:04:23.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.578]                               info)
[18:04:23.578]                           }
[18:04:23.578]                           else {
[18:04:23.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.578]                               info, version)
[18:04:23.578]                           }
[18:04:23.578]                           base::stop(msg)
[18:04:23.578]                         }
[18:04:23.578]                       })
[18:04:23.578]                     }
[18:04:23.578]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.578]                     base::options(mc.cores = 1L)
[18:04:23.578]                   }
[18:04:23.578]                   ...future.strategy.old <- future::plan("list")
[18:04:23.578]                   options(future.plan = NULL)
[18:04:23.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.578]                 }
[18:04:23.578]                 ...future.workdir <- getwd()
[18:04:23.578]             }
[18:04:23.578]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.578]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.578]         }
[18:04:23.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.578]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.578]             base::names(...future.oldOptions))
[18:04:23.578]     }
[18:04:23.578]     if (FALSE) {
[18:04:23.578]     }
[18:04:23.578]     else {
[18:04:23.578]         if (TRUE) {
[18:04:23.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.578]                 open = "w")
[18:04:23.578]         }
[18:04:23.578]         else {
[18:04:23.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.578]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.578]         }
[18:04:23.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.578]             base::sink(type = "output", split = FALSE)
[18:04:23.578]             base::close(...future.stdout)
[18:04:23.578]         }, add = TRUE)
[18:04:23.578]     }
[18:04:23.578]     ...future.frame <- base::sys.nframe()
[18:04:23.578]     ...future.conditions <- base::list()
[18:04:23.578]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.578]     if (FALSE) {
[18:04:23.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.578]     }
[18:04:23.578]     ...future.result <- base::tryCatch({
[18:04:23.578]         base::withCallingHandlers({
[18:04:23.578]             ...future.value <- base::withVisible(base::local({
[18:04:23.578]                 ...future.makeSendCondition <- base::local({
[18:04:23.578]                   sendCondition <- NULL
[18:04:23.578]                   function(frame = 1L) {
[18:04:23.578]                     if (is.function(sendCondition)) 
[18:04:23.578]                       return(sendCondition)
[18:04:23.578]                     ns <- getNamespace("parallel")
[18:04:23.578]                     if (exists("sendData", mode = "function", 
[18:04:23.578]                       envir = ns)) {
[18:04:23.578]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.578]                         envir = ns)
[18:04:23.578]                       envir <- sys.frame(frame)
[18:04:23.578]                       master <- NULL
[18:04:23.578]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.578]                         !identical(envir, emptyenv())) {
[18:04:23.578]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.578]                           inherits = FALSE)) {
[18:04:23.578]                           master <- get("master", mode = "list", 
[18:04:23.578]                             envir = envir, inherits = FALSE)
[18:04:23.578]                           if (inherits(master, c("SOCKnode", 
[18:04:23.578]                             "SOCK0node"))) {
[18:04:23.578]                             sendCondition <<- function(cond) {
[18:04:23.578]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.578]                                 success = TRUE)
[18:04:23.578]                               parallel_sendData(master, data)
[18:04:23.578]                             }
[18:04:23.578]                             return(sendCondition)
[18:04:23.578]                           }
[18:04:23.578]                         }
[18:04:23.578]                         frame <- frame + 1L
[18:04:23.578]                         envir <- sys.frame(frame)
[18:04:23.578]                       }
[18:04:23.578]                     }
[18:04:23.578]                     sendCondition <<- function(cond) NULL
[18:04:23.578]                   }
[18:04:23.578]                 })
[18:04:23.578]                 withCallingHandlers({
[18:04:23.578]                   NULL
[18:04:23.578]                 }, immediateCondition = function(cond) {
[18:04:23.578]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.578]                   sendCondition(cond)
[18:04:23.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.578]                   {
[18:04:23.578]                     inherits <- base::inherits
[18:04:23.578]                     invokeRestart <- base::invokeRestart
[18:04:23.578]                     is.null <- base::is.null
[18:04:23.578]                     muffled <- FALSE
[18:04:23.578]                     if (inherits(cond, "message")) {
[18:04:23.578]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.578]                       if (muffled) 
[18:04:23.578]                         invokeRestart("muffleMessage")
[18:04:23.578]                     }
[18:04:23.578]                     else if (inherits(cond, "warning")) {
[18:04:23.578]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.578]                       if (muffled) 
[18:04:23.578]                         invokeRestart("muffleWarning")
[18:04:23.578]                     }
[18:04:23.578]                     else if (inherits(cond, "condition")) {
[18:04:23.578]                       if (!is.null(pattern)) {
[18:04:23.578]                         computeRestarts <- base::computeRestarts
[18:04:23.578]                         grepl <- base::grepl
[18:04:23.578]                         restarts <- computeRestarts(cond)
[18:04:23.578]                         for (restart in restarts) {
[18:04:23.578]                           name <- restart$name
[18:04:23.578]                           if (is.null(name)) 
[18:04:23.578]                             next
[18:04:23.578]                           if (!grepl(pattern, name)) 
[18:04:23.578]                             next
[18:04:23.578]                           invokeRestart(restart)
[18:04:23.578]                           muffled <- TRUE
[18:04:23.578]                           break
[18:04:23.578]                         }
[18:04:23.578]                       }
[18:04:23.578]                     }
[18:04:23.578]                     invisible(muffled)
[18:04:23.578]                   }
[18:04:23.578]                   muffleCondition(cond)
[18:04:23.578]                 })
[18:04:23.578]             }))
[18:04:23.578]             future::FutureResult(value = ...future.value$value, 
[18:04:23.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.578]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.578]                     ...future.globalenv.names))
[18:04:23.578]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.578]         }, condition = base::local({
[18:04:23.578]             c <- base::c
[18:04:23.578]             inherits <- base::inherits
[18:04:23.578]             invokeRestart <- base::invokeRestart
[18:04:23.578]             length <- base::length
[18:04:23.578]             list <- base::list
[18:04:23.578]             seq.int <- base::seq.int
[18:04:23.578]             signalCondition <- base::signalCondition
[18:04:23.578]             sys.calls <- base::sys.calls
[18:04:23.578]             `[[` <- base::`[[`
[18:04:23.578]             `+` <- base::`+`
[18:04:23.578]             `<<-` <- base::`<<-`
[18:04:23.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.578]                   3L)]
[18:04:23.578]             }
[18:04:23.578]             function(cond) {
[18:04:23.578]                 is_error <- inherits(cond, "error")
[18:04:23.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.578]                   NULL)
[18:04:23.578]                 if (is_error) {
[18:04:23.578]                   sessionInformation <- function() {
[18:04:23.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.578]                       search = base::search(), system = base::Sys.info())
[18:04:23.578]                   }
[18:04:23.578]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.578]                     cond$call), session = sessionInformation(), 
[18:04:23.578]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.578]                   signalCondition(cond)
[18:04:23.578]                 }
[18:04:23.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.578]                 "immediateCondition"))) {
[18:04:23.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.578]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.578]                   if (TRUE && !signal) {
[18:04:23.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.578]                     {
[18:04:23.578]                       inherits <- base::inherits
[18:04:23.578]                       invokeRestart <- base::invokeRestart
[18:04:23.578]                       is.null <- base::is.null
[18:04:23.578]                       muffled <- FALSE
[18:04:23.578]                       if (inherits(cond, "message")) {
[18:04:23.578]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.578]                         if (muffled) 
[18:04:23.578]                           invokeRestart("muffleMessage")
[18:04:23.578]                       }
[18:04:23.578]                       else if (inherits(cond, "warning")) {
[18:04:23.578]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.578]                         if (muffled) 
[18:04:23.578]                           invokeRestart("muffleWarning")
[18:04:23.578]                       }
[18:04:23.578]                       else if (inherits(cond, "condition")) {
[18:04:23.578]                         if (!is.null(pattern)) {
[18:04:23.578]                           computeRestarts <- base::computeRestarts
[18:04:23.578]                           grepl <- base::grepl
[18:04:23.578]                           restarts <- computeRestarts(cond)
[18:04:23.578]                           for (restart in restarts) {
[18:04:23.578]                             name <- restart$name
[18:04:23.578]                             if (is.null(name)) 
[18:04:23.578]                               next
[18:04:23.578]                             if (!grepl(pattern, name)) 
[18:04:23.578]                               next
[18:04:23.578]                             invokeRestart(restart)
[18:04:23.578]                             muffled <- TRUE
[18:04:23.578]                             break
[18:04:23.578]                           }
[18:04:23.578]                         }
[18:04:23.578]                       }
[18:04:23.578]                       invisible(muffled)
[18:04:23.578]                     }
[18:04:23.578]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.578]                   }
[18:04:23.578]                 }
[18:04:23.578]                 else {
[18:04:23.578]                   if (TRUE) {
[18:04:23.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.578]                     {
[18:04:23.578]                       inherits <- base::inherits
[18:04:23.578]                       invokeRestart <- base::invokeRestart
[18:04:23.578]                       is.null <- base::is.null
[18:04:23.578]                       muffled <- FALSE
[18:04:23.578]                       if (inherits(cond, "message")) {
[18:04:23.578]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.578]                         if (muffled) 
[18:04:23.578]                           invokeRestart("muffleMessage")
[18:04:23.578]                       }
[18:04:23.578]                       else if (inherits(cond, "warning")) {
[18:04:23.578]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.578]                         if (muffled) 
[18:04:23.578]                           invokeRestart("muffleWarning")
[18:04:23.578]                       }
[18:04:23.578]                       else if (inherits(cond, "condition")) {
[18:04:23.578]                         if (!is.null(pattern)) {
[18:04:23.578]                           computeRestarts <- base::computeRestarts
[18:04:23.578]                           grepl <- base::grepl
[18:04:23.578]                           restarts <- computeRestarts(cond)
[18:04:23.578]                           for (restart in restarts) {
[18:04:23.578]                             name <- restart$name
[18:04:23.578]                             if (is.null(name)) 
[18:04:23.578]                               next
[18:04:23.578]                             if (!grepl(pattern, name)) 
[18:04:23.578]                               next
[18:04:23.578]                             invokeRestart(restart)
[18:04:23.578]                             muffled <- TRUE
[18:04:23.578]                             break
[18:04:23.578]                           }
[18:04:23.578]                         }
[18:04:23.578]                       }
[18:04:23.578]                       invisible(muffled)
[18:04:23.578]                     }
[18:04:23.578]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.578]                   }
[18:04:23.578]                 }
[18:04:23.578]             }
[18:04:23.578]         }))
[18:04:23.578]     }, error = function(ex) {
[18:04:23.578]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.578]                 ...future.rng), started = ...future.startTime, 
[18:04:23.578]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.578]             version = "1.8"), class = "FutureResult")
[18:04:23.578]     }, finally = {
[18:04:23.578]         if (!identical(...future.workdir, getwd())) 
[18:04:23.578]             setwd(...future.workdir)
[18:04:23.578]         {
[18:04:23.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.578]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.578]             }
[18:04:23.578]             base::options(...future.oldOptions)
[18:04:23.578]             if (.Platform$OS.type == "windows") {
[18:04:23.578]                 old_names <- names(...future.oldEnvVars)
[18:04:23.578]                 envs <- base::Sys.getenv()
[18:04:23.578]                 names <- names(envs)
[18:04:23.578]                 common <- intersect(names, old_names)
[18:04:23.578]                 added <- setdiff(names, old_names)
[18:04:23.578]                 removed <- setdiff(old_names, names)
[18:04:23.578]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.578]                   envs[common]]
[18:04:23.578]                 NAMES <- toupper(changed)
[18:04:23.578]                 args <- list()
[18:04:23.578]                 for (kk in seq_along(NAMES)) {
[18:04:23.578]                   name <- changed[[kk]]
[18:04:23.578]                   NAME <- NAMES[[kk]]
[18:04:23.578]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.578]                     next
[18:04:23.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.578]                 }
[18:04:23.578]                 NAMES <- toupper(added)
[18:04:23.578]                 for (kk in seq_along(NAMES)) {
[18:04:23.578]                   name <- added[[kk]]
[18:04:23.578]                   NAME <- NAMES[[kk]]
[18:04:23.578]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.578]                     next
[18:04:23.578]                   args[[name]] <- ""
[18:04:23.578]                 }
[18:04:23.578]                 NAMES <- toupper(removed)
[18:04:23.578]                 for (kk in seq_along(NAMES)) {
[18:04:23.578]                   name <- removed[[kk]]
[18:04:23.578]                   NAME <- NAMES[[kk]]
[18:04:23.578]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.578]                     next
[18:04:23.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.578]                 }
[18:04:23.578]                 if (length(args) > 0) 
[18:04:23.578]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.578]             }
[18:04:23.578]             else {
[18:04:23.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.578]             }
[18:04:23.578]             {
[18:04:23.578]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.578]                   0L) {
[18:04:23.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.578]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.578]                   base::options(opts)
[18:04:23.578]                 }
[18:04:23.578]                 {
[18:04:23.578]                   {
[18:04:23.578]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.578]                     NULL
[18:04:23.578]                   }
[18:04:23.578]                   options(future.plan = NULL)
[18:04:23.578]                   if (is.na(NA_character_)) 
[18:04:23.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.578]                     .init = FALSE)
[18:04:23.578]                 }
[18:04:23.578]             }
[18:04:23.578]         }
[18:04:23.578]     })
[18:04:23.578]     if (TRUE) {
[18:04:23.578]         base::sink(type = "output", split = FALSE)
[18:04:23.578]         if (TRUE) {
[18:04:23.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.578]         }
[18:04:23.578]         else {
[18:04:23.578]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.578]         }
[18:04:23.578]         base::close(...future.stdout)
[18:04:23.578]         ...future.stdout <- NULL
[18:04:23.578]     }
[18:04:23.578]     ...future.result$conditions <- ...future.conditions
[18:04:23.578]     ...future.result$finished <- base::Sys.time()
[18:04:23.578]     ...future.result
[18:04:23.578] }
[18:04:23.585] MultisessionFuture started
[18:04:23.585] - Launch lazy future ... done
[18:04:23.586] run() for ‘MultisessionFuture’ ... done
[18:04:23.586] getGlobalsAndPackages() ...
[18:04:23.587] Searching for globals...
[18:04:23.588] - globals found: [1] ‘{’
[18:04:23.588] Searching for globals ... DONE
[18:04:23.588] Resolving globals: FALSE
[18:04:23.589] 
[18:04:23.589] 
[18:04:23.589] getGlobalsAndPackages() ... DONE
[18:04:23.590] run() for ‘Future’ ...
[18:04:23.590] - state: ‘created’
[18:04:23.590] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.614] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.615]   - Field: ‘node’
[18:04:23.615]   - Field: ‘label’
[18:04:23.615]   - Field: ‘local’
[18:04:23.615]   - Field: ‘owner’
[18:04:23.616]   - Field: ‘envir’
[18:04:23.616]   - Field: ‘workers’
[18:04:23.616]   - Field: ‘packages’
[18:04:23.616]   - Field: ‘gc’
[18:04:23.616]   - Field: ‘conditions’
[18:04:23.617]   - Field: ‘persistent’
[18:04:23.617]   - Field: ‘expr’
[18:04:23.617]   - Field: ‘uuid’
[18:04:23.617]   - Field: ‘seed’
[18:04:23.617]   - Field: ‘version’
[18:04:23.618]   - Field: ‘result’
[18:04:23.618]   - Field: ‘asynchronous’
[18:04:23.618]   - Field: ‘calls’
[18:04:23.618]   - Field: ‘globals’
[18:04:23.618]   - Field: ‘stdout’
[18:04:23.619]   - Field: ‘earlySignal’
[18:04:23.619]   - Field: ‘lazy’
[18:04:23.619]   - Field: ‘state’
[18:04:23.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.619] - Launch lazy future ...
[18:04:23.620] Packages needed by the future expression (n = 0): <none>
[18:04:23.620] Packages needed by future strategies (n = 0): <none>
[18:04:23.621] {
[18:04:23.621]     {
[18:04:23.621]         {
[18:04:23.621]             ...future.startTime <- base::Sys.time()
[18:04:23.621]             {
[18:04:23.621]                 {
[18:04:23.621]                   {
[18:04:23.621]                     {
[18:04:23.621]                       base::local({
[18:04:23.621]                         has_future <- base::requireNamespace("future", 
[18:04:23.621]                           quietly = TRUE)
[18:04:23.621]                         if (has_future) {
[18:04:23.621]                           ns <- base::getNamespace("future")
[18:04:23.621]                           version <- ns[[".package"]][["version"]]
[18:04:23.621]                           if (is.null(version)) 
[18:04:23.621]                             version <- utils::packageVersion("future")
[18:04:23.621]                         }
[18:04:23.621]                         else {
[18:04:23.621]                           version <- NULL
[18:04:23.621]                         }
[18:04:23.621]                         if (!has_future || version < "1.8.0") {
[18:04:23.621]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.621]                             "", base::R.version$version.string), 
[18:04:23.621]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.621]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.621]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.621]                               "release", "version")], collapse = " "), 
[18:04:23.621]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.621]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.621]                             info)
[18:04:23.621]                           info <- base::paste(info, collapse = "; ")
[18:04:23.621]                           if (!has_future) {
[18:04:23.621]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.621]                               info)
[18:04:23.621]                           }
[18:04:23.621]                           else {
[18:04:23.621]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.621]                               info, version)
[18:04:23.621]                           }
[18:04:23.621]                           base::stop(msg)
[18:04:23.621]                         }
[18:04:23.621]                       })
[18:04:23.621]                     }
[18:04:23.621]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.621]                     base::options(mc.cores = 1L)
[18:04:23.621]                   }
[18:04:23.621]                   ...future.strategy.old <- future::plan("list")
[18:04:23.621]                   options(future.plan = NULL)
[18:04:23.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.621]                 }
[18:04:23.621]                 ...future.workdir <- getwd()
[18:04:23.621]             }
[18:04:23.621]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.621]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.621]         }
[18:04:23.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.621]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.621]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.621]             base::names(...future.oldOptions))
[18:04:23.621]     }
[18:04:23.621]     if (FALSE) {
[18:04:23.621]     }
[18:04:23.621]     else {
[18:04:23.621]         if (TRUE) {
[18:04:23.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.621]                 open = "w")
[18:04:23.621]         }
[18:04:23.621]         else {
[18:04:23.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.621]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.621]         }
[18:04:23.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.621]             base::sink(type = "output", split = FALSE)
[18:04:23.621]             base::close(...future.stdout)
[18:04:23.621]         }, add = TRUE)
[18:04:23.621]     }
[18:04:23.621]     ...future.frame <- base::sys.nframe()
[18:04:23.621]     ...future.conditions <- base::list()
[18:04:23.621]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.621]     if (FALSE) {
[18:04:23.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.621]     }
[18:04:23.621]     ...future.result <- base::tryCatch({
[18:04:23.621]         base::withCallingHandlers({
[18:04:23.621]             ...future.value <- base::withVisible(base::local({
[18:04:23.621]                 ...future.makeSendCondition <- base::local({
[18:04:23.621]                   sendCondition <- NULL
[18:04:23.621]                   function(frame = 1L) {
[18:04:23.621]                     if (is.function(sendCondition)) 
[18:04:23.621]                       return(sendCondition)
[18:04:23.621]                     ns <- getNamespace("parallel")
[18:04:23.621]                     if (exists("sendData", mode = "function", 
[18:04:23.621]                       envir = ns)) {
[18:04:23.621]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.621]                         envir = ns)
[18:04:23.621]                       envir <- sys.frame(frame)
[18:04:23.621]                       master <- NULL
[18:04:23.621]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.621]                         !identical(envir, emptyenv())) {
[18:04:23.621]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.621]                           inherits = FALSE)) {
[18:04:23.621]                           master <- get("master", mode = "list", 
[18:04:23.621]                             envir = envir, inherits = FALSE)
[18:04:23.621]                           if (inherits(master, c("SOCKnode", 
[18:04:23.621]                             "SOCK0node"))) {
[18:04:23.621]                             sendCondition <<- function(cond) {
[18:04:23.621]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.621]                                 success = TRUE)
[18:04:23.621]                               parallel_sendData(master, data)
[18:04:23.621]                             }
[18:04:23.621]                             return(sendCondition)
[18:04:23.621]                           }
[18:04:23.621]                         }
[18:04:23.621]                         frame <- frame + 1L
[18:04:23.621]                         envir <- sys.frame(frame)
[18:04:23.621]                       }
[18:04:23.621]                     }
[18:04:23.621]                     sendCondition <<- function(cond) NULL
[18:04:23.621]                   }
[18:04:23.621]                 })
[18:04:23.621]                 withCallingHandlers({
[18:04:23.621]                   {
[18:04:23.621]                     4
[18:04:23.621]                   }
[18:04:23.621]                 }, immediateCondition = function(cond) {
[18:04:23.621]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.621]                   sendCondition(cond)
[18:04:23.621]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.621]                   {
[18:04:23.621]                     inherits <- base::inherits
[18:04:23.621]                     invokeRestart <- base::invokeRestart
[18:04:23.621]                     is.null <- base::is.null
[18:04:23.621]                     muffled <- FALSE
[18:04:23.621]                     if (inherits(cond, "message")) {
[18:04:23.621]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.621]                       if (muffled) 
[18:04:23.621]                         invokeRestart("muffleMessage")
[18:04:23.621]                     }
[18:04:23.621]                     else if (inherits(cond, "warning")) {
[18:04:23.621]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.621]                       if (muffled) 
[18:04:23.621]                         invokeRestart("muffleWarning")
[18:04:23.621]                     }
[18:04:23.621]                     else if (inherits(cond, "condition")) {
[18:04:23.621]                       if (!is.null(pattern)) {
[18:04:23.621]                         computeRestarts <- base::computeRestarts
[18:04:23.621]                         grepl <- base::grepl
[18:04:23.621]                         restarts <- computeRestarts(cond)
[18:04:23.621]                         for (restart in restarts) {
[18:04:23.621]                           name <- restart$name
[18:04:23.621]                           if (is.null(name)) 
[18:04:23.621]                             next
[18:04:23.621]                           if (!grepl(pattern, name)) 
[18:04:23.621]                             next
[18:04:23.621]                           invokeRestart(restart)
[18:04:23.621]                           muffled <- TRUE
[18:04:23.621]                           break
[18:04:23.621]                         }
[18:04:23.621]                       }
[18:04:23.621]                     }
[18:04:23.621]                     invisible(muffled)
[18:04:23.621]                   }
[18:04:23.621]                   muffleCondition(cond)
[18:04:23.621]                 })
[18:04:23.621]             }))
[18:04:23.621]             future::FutureResult(value = ...future.value$value, 
[18:04:23.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.621]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.621]                     ...future.globalenv.names))
[18:04:23.621]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.621]         }, condition = base::local({
[18:04:23.621]             c <- base::c
[18:04:23.621]             inherits <- base::inherits
[18:04:23.621]             invokeRestart <- base::invokeRestart
[18:04:23.621]             length <- base::length
[18:04:23.621]             list <- base::list
[18:04:23.621]             seq.int <- base::seq.int
[18:04:23.621]             signalCondition <- base::signalCondition
[18:04:23.621]             sys.calls <- base::sys.calls
[18:04:23.621]             `[[` <- base::`[[`
[18:04:23.621]             `+` <- base::`+`
[18:04:23.621]             `<<-` <- base::`<<-`
[18:04:23.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.621]                   3L)]
[18:04:23.621]             }
[18:04:23.621]             function(cond) {
[18:04:23.621]                 is_error <- inherits(cond, "error")
[18:04:23.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.621]                   NULL)
[18:04:23.621]                 if (is_error) {
[18:04:23.621]                   sessionInformation <- function() {
[18:04:23.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.621]                       search = base::search(), system = base::Sys.info())
[18:04:23.621]                   }
[18:04:23.621]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.621]                     cond$call), session = sessionInformation(), 
[18:04:23.621]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.621]                   signalCondition(cond)
[18:04:23.621]                 }
[18:04:23.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.621]                 "immediateCondition"))) {
[18:04:23.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.621]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.621]                   if (TRUE && !signal) {
[18:04:23.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.621]                     {
[18:04:23.621]                       inherits <- base::inherits
[18:04:23.621]                       invokeRestart <- base::invokeRestart
[18:04:23.621]                       is.null <- base::is.null
[18:04:23.621]                       muffled <- FALSE
[18:04:23.621]                       if (inherits(cond, "message")) {
[18:04:23.621]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.621]                         if (muffled) 
[18:04:23.621]                           invokeRestart("muffleMessage")
[18:04:23.621]                       }
[18:04:23.621]                       else if (inherits(cond, "warning")) {
[18:04:23.621]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.621]                         if (muffled) 
[18:04:23.621]                           invokeRestart("muffleWarning")
[18:04:23.621]                       }
[18:04:23.621]                       else if (inherits(cond, "condition")) {
[18:04:23.621]                         if (!is.null(pattern)) {
[18:04:23.621]                           computeRestarts <- base::computeRestarts
[18:04:23.621]                           grepl <- base::grepl
[18:04:23.621]                           restarts <- computeRestarts(cond)
[18:04:23.621]                           for (restart in restarts) {
[18:04:23.621]                             name <- restart$name
[18:04:23.621]                             if (is.null(name)) 
[18:04:23.621]                               next
[18:04:23.621]                             if (!grepl(pattern, name)) 
[18:04:23.621]                               next
[18:04:23.621]                             invokeRestart(restart)
[18:04:23.621]                             muffled <- TRUE
[18:04:23.621]                             break
[18:04:23.621]                           }
[18:04:23.621]                         }
[18:04:23.621]                       }
[18:04:23.621]                       invisible(muffled)
[18:04:23.621]                     }
[18:04:23.621]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.621]                   }
[18:04:23.621]                 }
[18:04:23.621]                 else {
[18:04:23.621]                   if (TRUE) {
[18:04:23.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.621]                     {
[18:04:23.621]                       inherits <- base::inherits
[18:04:23.621]                       invokeRestart <- base::invokeRestart
[18:04:23.621]                       is.null <- base::is.null
[18:04:23.621]                       muffled <- FALSE
[18:04:23.621]                       if (inherits(cond, "message")) {
[18:04:23.621]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.621]                         if (muffled) 
[18:04:23.621]                           invokeRestart("muffleMessage")
[18:04:23.621]                       }
[18:04:23.621]                       else if (inherits(cond, "warning")) {
[18:04:23.621]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.621]                         if (muffled) 
[18:04:23.621]                           invokeRestart("muffleWarning")
[18:04:23.621]                       }
[18:04:23.621]                       else if (inherits(cond, "condition")) {
[18:04:23.621]                         if (!is.null(pattern)) {
[18:04:23.621]                           computeRestarts <- base::computeRestarts
[18:04:23.621]                           grepl <- base::grepl
[18:04:23.621]                           restarts <- computeRestarts(cond)
[18:04:23.621]                           for (restart in restarts) {
[18:04:23.621]                             name <- restart$name
[18:04:23.621]                             if (is.null(name)) 
[18:04:23.621]                               next
[18:04:23.621]                             if (!grepl(pattern, name)) 
[18:04:23.621]                               next
[18:04:23.621]                             invokeRestart(restart)
[18:04:23.621]                             muffled <- TRUE
[18:04:23.621]                             break
[18:04:23.621]                           }
[18:04:23.621]                         }
[18:04:23.621]                       }
[18:04:23.621]                       invisible(muffled)
[18:04:23.621]                     }
[18:04:23.621]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.621]                   }
[18:04:23.621]                 }
[18:04:23.621]             }
[18:04:23.621]         }))
[18:04:23.621]     }, error = function(ex) {
[18:04:23.621]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.621]                 ...future.rng), started = ...future.startTime, 
[18:04:23.621]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.621]             version = "1.8"), class = "FutureResult")
[18:04:23.621]     }, finally = {
[18:04:23.621]         if (!identical(...future.workdir, getwd())) 
[18:04:23.621]             setwd(...future.workdir)
[18:04:23.621]         {
[18:04:23.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.621]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.621]             }
[18:04:23.621]             base::options(...future.oldOptions)
[18:04:23.621]             if (.Platform$OS.type == "windows") {
[18:04:23.621]                 old_names <- names(...future.oldEnvVars)
[18:04:23.621]                 envs <- base::Sys.getenv()
[18:04:23.621]                 names <- names(envs)
[18:04:23.621]                 common <- intersect(names, old_names)
[18:04:23.621]                 added <- setdiff(names, old_names)
[18:04:23.621]                 removed <- setdiff(old_names, names)
[18:04:23.621]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.621]                   envs[common]]
[18:04:23.621]                 NAMES <- toupper(changed)
[18:04:23.621]                 args <- list()
[18:04:23.621]                 for (kk in seq_along(NAMES)) {
[18:04:23.621]                   name <- changed[[kk]]
[18:04:23.621]                   NAME <- NAMES[[kk]]
[18:04:23.621]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.621]                     next
[18:04:23.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.621]                 }
[18:04:23.621]                 NAMES <- toupper(added)
[18:04:23.621]                 for (kk in seq_along(NAMES)) {
[18:04:23.621]                   name <- added[[kk]]
[18:04:23.621]                   NAME <- NAMES[[kk]]
[18:04:23.621]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.621]                     next
[18:04:23.621]                   args[[name]] <- ""
[18:04:23.621]                 }
[18:04:23.621]                 NAMES <- toupper(removed)
[18:04:23.621]                 for (kk in seq_along(NAMES)) {
[18:04:23.621]                   name <- removed[[kk]]
[18:04:23.621]                   NAME <- NAMES[[kk]]
[18:04:23.621]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.621]                     next
[18:04:23.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.621]                 }
[18:04:23.621]                 if (length(args) > 0) 
[18:04:23.621]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.621]             }
[18:04:23.621]             else {
[18:04:23.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.621]             }
[18:04:23.621]             {
[18:04:23.621]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.621]                   0L) {
[18:04:23.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.621]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.621]                   base::options(opts)
[18:04:23.621]                 }
[18:04:23.621]                 {
[18:04:23.621]                   {
[18:04:23.621]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.621]                     NULL
[18:04:23.621]                   }
[18:04:23.621]                   options(future.plan = NULL)
[18:04:23.621]                   if (is.na(NA_character_)) 
[18:04:23.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.621]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.621]                     .init = FALSE)
[18:04:23.621]                 }
[18:04:23.621]             }
[18:04:23.621]         }
[18:04:23.621]     })
[18:04:23.621]     if (TRUE) {
[18:04:23.621]         base::sink(type = "output", split = FALSE)
[18:04:23.621]         if (TRUE) {
[18:04:23.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.621]         }
[18:04:23.621]         else {
[18:04:23.621]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.621]         }
[18:04:23.621]         base::close(...future.stdout)
[18:04:23.621]         ...future.stdout <- NULL
[18:04:23.621]     }
[18:04:23.621]     ...future.result$conditions <- ...future.conditions
[18:04:23.621]     ...future.result$finished <- base::Sys.time()
[18:04:23.621]     ...future.result
[18:04:23.621] }
[18:04:23.625] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:23.637] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.637] - Validating connection of MultisessionFuture
[18:04:23.637] - received message: FutureResult
[18:04:23.637] - Received FutureResult
[18:04:23.638] - Erased future from FutureRegistry
[18:04:23.638] result() for ClusterFuture ...
[18:04:23.638] - result already collected: FutureResult
[18:04:23.638] result() for ClusterFuture ... done
[18:04:23.638] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:23.639] result() for ClusterFuture ...
[18:04:23.639] - result already collected: FutureResult
[18:04:23.639] result() for ClusterFuture ... done
[18:04:23.639] result() for ClusterFuture ...
[18:04:23.639] - result already collected: FutureResult
[18:04:23.640] result() for ClusterFuture ... done
[18:04:23.642] MultisessionFuture started
[18:04:23.642] - Launch lazy future ... done
[18:04:23.642] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2c3c91a0> 
Classes 'listenv', 'environment' <environment: 0x5e3c2d1f71d0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[18:04:23.654] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.654] - Validating connection of MultisessionFuture
[18:04:23.655] - received message: FutureResult
[18:04:23.655] - Received FutureResult
[18:04:23.655] - Erased future from FutureRegistry
[18:04:23.655] result() for ClusterFuture ...
[18:04:23.655] - result already collected: FutureResult
[18:04:23.656] result() for ClusterFuture ... done
[18:04:23.656] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:23.671] resolve() on list environment ...
[18:04:23.672]  recursive: 0
[18:04:23.674]  length: 6
[18:04:23.674]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:23.674] signalConditionsASAP(numeric, pos=1) ...
[18:04:23.674] - nx: 6
[18:04:23.674] - relay: TRUE
[18:04:23.675] - stdout: TRUE
[18:04:23.675] - signal: TRUE
[18:04:23.675] - resignal: FALSE
[18:04:23.675] - force: TRUE
[18:04:23.675] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.675] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.676]  - until=2
[18:04:23.676]  - relaying element #2
[18:04:23.676] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.676] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.676] signalConditionsASAP(NULL, pos=1) ... done
[18:04:23.677]  length: 5 (resolved future 1)
[18:04:23.677] Future #2
[18:04:23.677] result() for ClusterFuture ...
[18:04:23.677] - result already collected: FutureResult
[18:04:23.677] result() for ClusterFuture ... done
[18:04:23.678] result() for ClusterFuture ...
[18:04:23.678] - result already collected: FutureResult
[18:04:23.678] result() for ClusterFuture ... done
[18:04:23.678] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:23.678] - nx: 6
[18:04:23.679] - relay: TRUE
[18:04:23.679] - stdout: TRUE
[18:04:23.679] - signal: TRUE
[18:04:23.679] - resignal: FALSE
[18:04:23.679] - force: TRUE
[18:04:23.679] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.680] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.680]  - until=2
[18:04:23.680]  - relaying element #2
[18:04:23.680] result() for ClusterFuture ...
[18:04:23.680] - result already collected: FutureResult
[18:04:23.680] result() for ClusterFuture ... done
[18:04:23.681] result() for ClusterFuture ...
[18:04:23.681] - result already collected: FutureResult
[18:04:23.681] result() for ClusterFuture ... done
[18:04:23.681] result() for ClusterFuture ...
[18:04:23.681] - result already collected: FutureResult
[18:04:23.682] result() for ClusterFuture ... done
[18:04:23.682] result() for ClusterFuture ...
[18:04:23.682] - result already collected: FutureResult
[18:04:23.682] result() for ClusterFuture ... done
[18:04:23.682] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.683] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.683] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:23.683]  length: 4 (resolved future 2)
[18:04:23.683] Future #3
[18:04:23.683] result() for ClusterFuture ...
[18:04:23.684] - result already collected: FutureResult
[18:04:23.684] result() for ClusterFuture ... done
[18:04:23.684] result() for ClusterFuture ...
[18:04:23.684] - result already collected: FutureResult
[18:04:23.684] result() for ClusterFuture ... done
[18:04:23.685] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:23.685] - nx: 6
[18:04:23.685] - relay: TRUE
[18:04:23.685] - stdout: TRUE
[18:04:23.685] - signal: TRUE
[18:04:23.685] - resignal: FALSE
[18:04:23.686] - force: TRUE
[18:04:23.686] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.686] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.686]  - until=3
[18:04:23.686]  - relaying element #3
[18:04:23.687] result() for ClusterFuture ...
[18:04:23.687] - result already collected: FutureResult
[18:04:23.687] result() for ClusterFuture ... done
[18:04:23.687] result() for ClusterFuture ...
[18:04:23.687] - result already collected: FutureResult
[18:04:23.687] result() for ClusterFuture ... done
[18:04:23.688] result() for ClusterFuture ...
[18:04:23.688] - result already collected: FutureResult
[18:04:23.688] result() for ClusterFuture ... done
[18:04:23.688] result() for ClusterFuture ...
[18:04:23.688] - result already collected: FutureResult
[18:04:23.689] result() for ClusterFuture ... done
[18:04:23.689] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.689] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.689] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:23.689]  length: 3 (resolved future 3)
[18:04:23.690] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.691] - Validating connection of MultisessionFuture
[18:04:23.691] - received message: FutureResult
[18:04:23.691] - Received FutureResult
[18:04:23.691] - Erased future from FutureRegistry
[18:04:23.691] result() for ClusterFuture ...
[18:04:23.692] - result already collected: FutureResult
[18:04:23.692] result() for ClusterFuture ... done
[18:04:23.692] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:23.692] Future #4
[18:04:23.692] result() for ClusterFuture ...
[18:04:23.693] - result already collected: FutureResult
[18:04:23.693] result() for ClusterFuture ... done
[18:04:23.693] result() for ClusterFuture ...
[18:04:23.693] - result already collected: FutureResult
[18:04:23.693] result() for ClusterFuture ... done
[18:04:23.693] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:23.694] - nx: 6
[18:04:23.694] - relay: TRUE
[18:04:23.694] - stdout: TRUE
[18:04:23.694] - signal: TRUE
[18:04:23.694] - resignal: FALSE
[18:04:23.694] - force: TRUE
[18:04:23.695] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.695] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.695]  - until=4
[18:04:23.695]  - relaying element #4
[18:04:23.695] result() for ClusterFuture ...
[18:04:23.696] - result already collected: FutureResult
[18:04:23.696] result() for ClusterFuture ... done
[18:04:23.696] result() for ClusterFuture ...
[18:04:23.696] - result already collected: FutureResult
[18:04:23.696] result() for ClusterFuture ... done
[18:04:23.697] result() for ClusterFuture ...
[18:04:23.697] - result already collected: FutureResult
[18:04:23.697] result() for ClusterFuture ... done
[18:04:23.697] result() for ClusterFuture ...
[18:04:23.697] - result already collected: FutureResult
[18:04:23.697] result() for ClusterFuture ... done
[18:04:23.698] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.698] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.698] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:23.698]  length: 2 (resolved future 4)
[18:04:23.698] signalConditionsASAP(NULL, pos=5) ...
[18:04:23.699] - nx: 6
[18:04:23.699] - relay: TRUE
[18:04:23.699] - stdout: TRUE
[18:04:23.699] - signal: TRUE
[18:04:23.699] - resignal: FALSE
[18:04:23.699] - force: TRUE
[18:04:23.700] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.700] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.700]  - until=6
[18:04:23.700]  - relaying element #6
[18:04:23.700] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:23.700] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.701] signalConditionsASAP(NULL, pos=5) ... done
[18:04:23.701]  length: 1 (resolved future 5)
[18:04:23.701] signalConditionsASAP(numeric, pos=6) ...
[18:04:23.701] - nx: 6
[18:04:23.701] - relay: TRUE
[18:04:23.702] - stdout: TRUE
[18:04:23.702] - signal: TRUE
[18:04:23.702] - resignal: FALSE
[18:04:23.702] - force: TRUE
[18:04:23.702] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:23.702] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.703]  - until=6
[18:04:23.703] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:23.703] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.703] signalConditionsASAP(numeric, pos=6) ... done
[18:04:23.703]  length: 0 (resolved future 6)
[18:04:23.704] Relaying remaining futures
[18:04:23.704] signalConditionsASAP(NULL, pos=0) ...
[18:04:23.704] - nx: 6
[18:04:23.704] - relay: TRUE
[18:04:23.704] - stdout: TRUE
[18:04:23.704] - signal: TRUE
[18:04:23.705] - resignal: FALSE
[18:04:23.705] - force: TRUE
[18:04:23.705] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:23.705] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:23.705] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:23.706] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.706] signalConditionsASAP(NULL, pos=0) ... done
[18:04:23.706] resolve() on list environment ... DONE
[18:04:23.706] result() for ClusterFuture ...
[18:04:23.706] - result already collected: FutureResult
[18:04:23.707] result() for ClusterFuture ... done
[18:04:23.707] result() for ClusterFuture ...
[18:04:23.707] - result already collected: FutureResult
[18:04:23.707] result() for ClusterFuture ... done
[18:04:23.707] result() for ClusterFuture ...
[18:04:23.708] - result already collected: FutureResult
[18:04:23.708] result() for ClusterFuture ... done
[18:04:23.708] result() for ClusterFuture ...
[18:04:23.708] - result already collected: FutureResult
[18:04:23.708] result() for ClusterFuture ... done
[18:04:23.709] result() for ClusterFuture ...
[18:04:23.709] - result already collected: FutureResult
[18:04:23.709] result() for ClusterFuture ... done
[18:04:23.709] result() for ClusterFuture ...
[18:04:23.709] - result already collected: FutureResult
[18:04:23.710] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2ba2b240> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[18:04:23.713] getGlobalsAndPackages() ...
[18:04:23.713] Searching for globals...
[18:04:23.714] 
[18:04:23.714] Searching for globals ... DONE
[18:04:23.715] - globals: [0] <none>
[18:04:23.715] getGlobalsAndPackages() ... DONE
[18:04:23.715] run() for ‘Future’ ...
[18:04:23.715] - state: ‘created’
[18:04:23.716] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.740] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.740]   - Field: ‘node’
[18:04:23.741]   - Field: ‘label’
[18:04:23.741]   - Field: ‘local’
[18:04:23.741]   - Field: ‘owner’
[18:04:23.741]   - Field: ‘envir’
[18:04:23.742]   - Field: ‘workers’
[18:04:23.742]   - Field: ‘packages’
[18:04:23.742]   - Field: ‘gc’
[18:04:23.742]   - Field: ‘conditions’
[18:04:23.742]   - Field: ‘persistent’
[18:04:23.743]   - Field: ‘expr’
[18:04:23.743]   - Field: ‘uuid’
[18:04:23.743]   - Field: ‘seed’
[18:04:23.743]   - Field: ‘version’
[18:04:23.743]   - Field: ‘result’
[18:04:23.744]   - Field: ‘asynchronous’
[18:04:23.744]   - Field: ‘calls’
[18:04:23.744]   - Field: ‘globals’
[18:04:23.744]   - Field: ‘stdout’
[18:04:23.744]   - Field: ‘earlySignal’
[18:04:23.744]   - Field: ‘lazy’
[18:04:23.745]   - Field: ‘state’
[18:04:23.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.745] - Launch lazy future ...
[18:04:23.746] Packages needed by the future expression (n = 0): <none>
[18:04:23.746] Packages needed by future strategies (n = 0): <none>
[18:04:23.747] {
[18:04:23.747]     {
[18:04:23.747]         {
[18:04:23.747]             ...future.startTime <- base::Sys.time()
[18:04:23.747]             {
[18:04:23.747]                 {
[18:04:23.747]                   {
[18:04:23.747]                     {
[18:04:23.747]                       base::local({
[18:04:23.747]                         has_future <- base::requireNamespace("future", 
[18:04:23.747]                           quietly = TRUE)
[18:04:23.747]                         if (has_future) {
[18:04:23.747]                           ns <- base::getNamespace("future")
[18:04:23.747]                           version <- ns[[".package"]][["version"]]
[18:04:23.747]                           if (is.null(version)) 
[18:04:23.747]                             version <- utils::packageVersion("future")
[18:04:23.747]                         }
[18:04:23.747]                         else {
[18:04:23.747]                           version <- NULL
[18:04:23.747]                         }
[18:04:23.747]                         if (!has_future || version < "1.8.0") {
[18:04:23.747]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.747]                             "", base::R.version$version.string), 
[18:04:23.747]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.747]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.747]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.747]                               "release", "version")], collapse = " "), 
[18:04:23.747]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.747]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.747]                             info)
[18:04:23.747]                           info <- base::paste(info, collapse = "; ")
[18:04:23.747]                           if (!has_future) {
[18:04:23.747]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.747]                               info)
[18:04:23.747]                           }
[18:04:23.747]                           else {
[18:04:23.747]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.747]                               info, version)
[18:04:23.747]                           }
[18:04:23.747]                           base::stop(msg)
[18:04:23.747]                         }
[18:04:23.747]                       })
[18:04:23.747]                     }
[18:04:23.747]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.747]                     base::options(mc.cores = 1L)
[18:04:23.747]                   }
[18:04:23.747]                   ...future.strategy.old <- future::plan("list")
[18:04:23.747]                   options(future.plan = NULL)
[18:04:23.747]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.747]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.747]                 }
[18:04:23.747]                 ...future.workdir <- getwd()
[18:04:23.747]             }
[18:04:23.747]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.747]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.747]         }
[18:04:23.747]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.747]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.747]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.747]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.747]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.747]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.747]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.747]             base::names(...future.oldOptions))
[18:04:23.747]     }
[18:04:23.747]     if (FALSE) {
[18:04:23.747]     }
[18:04:23.747]     else {
[18:04:23.747]         if (TRUE) {
[18:04:23.747]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.747]                 open = "w")
[18:04:23.747]         }
[18:04:23.747]         else {
[18:04:23.747]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.747]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.747]         }
[18:04:23.747]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.747]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.747]             base::sink(type = "output", split = FALSE)
[18:04:23.747]             base::close(...future.stdout)
[18:04:23.747]         }, add = TRUE)
[18:04:23.747]     }
[18:04:23.747]     ...future.frame <- base::sys.nframe()
[18:04:23.747]     ...future.conditions <- base::list()
[18:04:23.747]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.747]     if (FALSE) {
[18:04:23.747]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.747]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.747]     }
[18:04:23.747]     ...future.result <- base::tryCatch({
[18:04:23.747]         base::withCallingHandlers({
[18:04:23.747]             ...future.value <- base::withVisible(base::local({
[18:04:23.747]                 ...future.makeSendCondition <- base::local({
[18:04:23.747]                   sendCondition <- NULL
[18:04:23.747]                   function(frame = 1L) {
[18:04:23.747]                     if (is.function(sendCondition)) 
[18:04:23.747]                       return(sendCondition)
[18:04:23.747]                     ns <- getNamespace("parallel")
[18:04:23.747]                     if (exists("sendData", mode = "function", 
[18:04:23.747]                       envir = ns)) {
[18:04:23.747]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.747]                         envir = ns)
[18:04:23.747]                       envir <- sys.frame(frame)
[18:04:23.747]                       master <- NULL
[18:04:23.747]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.747]                         !identical(envir, emptyenv())) {
[18:04:23.747]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.747]                           inherits = FALSE)) {
[18:04:23.747]                           master <- get("master", mode = "list", 
[18:04:23.747]                             envir = envir, inherits = FALSE)
[18:04:23.747]                           if (inherits(master, c("SOCKnode", 
[18:04:23.747]                             "SOCK0node"))) {
[18:04:23.747]                             sendCondition <<- function(cond) {
[18:04:23.747]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.747]                                 success = TRUE)
[18:04:23.747]                               parallel_sendData(master, data)
[18:04:23.747]                             }
[18:04:23.747]                             return(sendCondition)
[18:04:23.747]                           }
[18:04:23.747]                         }
[18:04:23.747]                         frame <- frame + 1L
[18:04:23.747]                         envir <- sys.frame(frame)
[18:04:23.747]                       }
[18:04:23.747]                     }
[18:04:23.747]                     sendCondition <<- function(cond) NULL
[18:04:23.747]                   }
[18:04:23.747]                 })
[18:04:23.747]                 withCallingHandlers({
[18:04:23.747]                   2
[18:04:23.747]                 }, immediateCondition = function(cond) {
[18:04:23.747]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.747]                   sendCondition(cond)
[18:04:23.747]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.747]                   {
[18:04:23.747]                     inherits <- base::inherits
[18:04:23.747]                     invokeRestart <- base::invokeRestart
[18:04:23.747]                     is.null <- base::is.null
[18:04:23.747]                     muffled <- FALSE
[18:04:23.747]                     if (inherits(cond, "message")) {
[18:04:23.747]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.747]                       if (muffled) 
[18:04:23.747]                         invokeRestart("muffleMessage")
[18:04:23.747]                     }
[18:04:23.747]                     else if (inherits(cond, "warning")) {
[18:04:23.747]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.747]                       if (muffled) 
[18:04:23.747]                         invokeRestart("muffleWarning")
[18:04:23.747]                     }
[18:04:23.747]                     else if (inherits(cond, "condition")) {
[18:04:23.747]                       if (!is.null(pattern)) {
[18:04:23.747]                         computeRestarts <- base::computeRestarts
[18:04:23.747]                         grepl <- base::grepl
[18:04:23.747]                         restarts <- computeRestarts(cond)
[18:04:23.747]                         for (restart in restarts) {
[18:04:23.747]                           name <- restart$name
[18:04:23.747]                           if (is.null(name)) 
[18:04:23.747]                             next
[18:04:23.747]                           if (!grepl(pattern, name)) 
[18:04:23.747]                             next
[18:04:23.747]                           invokeRestart(restart)
[18:04:23.747]                           muffled <- TRUE
[18:04:23.747]                           break
[18:04:23.747]                         }
[18:04:23.747]                       }
[18:04:23.747]                     }
[18:04:23.747]                     invisible(muffled)
[18:04:23.747]                   }
[18:04:23.747]                   muffleCondition(cond)
[18:04:23.747]                 })
[18:04:23.747]             }))
[18:04:23.747]             future::FutureResult(value = ...future.value$value, 
[18:04:23.747]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.747]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.747]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.747]                     ...future.globalenv.names))
[18:04:23.747]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.747]         }, condition = base::local({
[18:04:23.747]             c <- base::c
[18:04:23.747]             inherits <- base::inherits
[18:04:23.747]             invokeRestart <- base::invokeRestart
[18:04:23.747]             length <- base::length
[18:04:23.747]             list <- base::list
[18:04:23.747]             seq.int <- base::seq.int
[18:04:23.747]             signalCondition <- base::signalCondition
[18:04:23.747]             sys.calls <- base::sys.calls
[18:04:23.747]             `[[` <- base::`[[`
[18:04:23.747]             `+` <- base::`+`
[18:04:23.747]             `<<-` <- base::`<<-`
[18:04:23.747]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.747]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.747]                   3L)]
[18:04:23.747]             }
[18:04:23.747]             function(cond) {
[18:04:23.747]                 is_error <- inherits(cond, "error")
[18:04:23.747]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.747]                   NULL)
[18:04:23.747]                 if (is_error) {
[18:04:23.747]                   sessionInformation <- function() {
[18:04:23.747]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.747]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.747]                       search = base::search(), system = base::Sys.info())
[18:04:23.747]                   }
[18:04:23.747]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.747]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.747]                     cond$call), session = sessionInformation(), 
[18:04:23.747]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.747]                   signalCondition(cond)
[18:04:23.747]                 }
[18:04:23.747]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.747]                 "immediateCondition"))) {
[18:04:23.747]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.747]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.747]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.747]                   if (TRUE && !signal) {
[18:04:23.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.747]                     {
[18:04:23.747]                       inherits <- base::inherits
[18:04:23.747]                       invokeRestart <- base::invokeRestart
[18:04:23.747]                       is.null <- base::is.null
[18:04:23.747]                       muffled <- FALSE
[18:04:23.747]                       if (inherits(cond, "message")) {
[18:04:23.747]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.747]                         if (muffled) 
[18:04:23.747]                           invokeRestart("muffleMessage")
[18:04:23.747]                       }
[18:04:23.747]                       else if (inherits(cond, "warning")) {
[18:04:23.747]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.747]                         if (muffled) 
[18:04:23.747]                           invokeRestart("muffleWarning")
[18:04:23.747]                       }
[18:04:23.747]                       else if (inherits(cond, "condition")) {
[18:04:23.747]                         if (!is.null(pattern)) {
[18:04:23.747]                           computeRestarts <- base::computeRestarts
[18:04:23.747]                           grepl <- base::grepl
[18:04:23.747]                           restarts <- computeRestarts(cond)
[18:04:23.747]                           for (restart in restarts) {
[18:04:23.747]                             name <- restart$name
[18:04:23.747]                             if (is.null(name)) 
[18:04:23.747]                               next
[18:04:23.747]                             if (!grepl(pattern, name)) 
[18:04:23.747]                               next
[18:04:23.747]                             invokeRestart(restart)
[18:04:23.747]                             muffled <- TRUE
[18:04:23.747]                             break
[18:04:23.747]                           }
[18:04:23.747]                         }
[18:04:23.747]                       }
[18:04:23.747]                       invisible(muffled)
[18:04:23.747]                     }
[18:04:23.747]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.747]                   }
[18:04:23.747]                 }
[18:04:23.747]                 else {
[18:04:23.747]                   if (TRUE) {
[18:04:23.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.747]                     {
[18:04:23.747]                       inherits <- base::inherits
[18:04:23.747]                       invokeRestart <- base::invokeRestart
[18:04:23.747]                       is.null <- base::is.null
[18:04:23.747]                       muffled <- FALSE
[18:04:23.747]                       if (inherits(cond, "message")) {
[18:04:23.747]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.747]                         if (muffled) 
[18:04:23.747]                           invokeRestart("muffleMessage")
[18:04:23.747]                       }
[18:04:23.747]                       else if (inherits(cond, "warning")) {
[18:04:23.747]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.747]                         if (muffled) 
[18:04:23.747]                           invokeRestart("muffleWarning")
[18:04:23.747]                       }
[18:04:23.747]                       else if (inherits(cond, "condition")) {
[18:04:23.747]                         if (!is.null(pattern)) {
[18:04:23.747]                           computeRestarts <- base::computeRestarts
[18:04:23.747]                           grepl <- base::grepl
[18:04:23.747]                           restarts <- computeRestarts(cond)
[18:04:23.747]                           for (restart in restarts) {
[18:04:23.747]                             name <- restart$name
[18:04:23.747]                             if (is.null(name)) 
[18:04:23.747]                               next
[18:04:23.747]                             if (!grepl(pattern, name)) 
[18:04:23.747]                               next
[18:04:23.747]                             invokeRestart(restart)
[18:04:23.747]                             muffled <- TRUE
[18:04:23.747]                             break
[18:04:23.747]                           }
[18:04:23.747]                         }
[18:04:23.747]                       }
[18:04:23.747]                       invisible(muffled)
[18:04:23.747]                     }
[18:04:23.747]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.747]                   }
[18:04:23.747]                 }
[18:04:23.747]             }
[18:04:23.747]         }))
[18:04:23.747]     }, error = function(ex) {
[18:04:23.747]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.747]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.747]                 ...future.rng), started = ...future.startTime, 
[18:04:23.747]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.747]             version = "1.8"), class = "FutureResult")
[18:04:23.747]     }, finally = {
[18:04:23.747]         if (!identical(...future.workdir, getwd())) 
[18:04:23.747]             setwd(...future.workdir)
[18:04:23.747]         {
[18:04:23.747]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.747]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.747]             }
[18:04:23.747]             base::options(...future.oldOptions)
[18:04:23.747]             if (.Platform$OS.type == "windows") {
[18:04:23.747]                 old_names <- names(...future.oldEnvVars)
[18:04:23.747]                 envs <- base::Sys.getenv()
[18:04:23.747]                 names <- names(envs)
[18:04:23.747]                 common <- intersect(names, old_names)
[18:04:23.747]                 added <- setdiff(names, old_names)
[18:04:23.747]                 removed <- setdiff(old_names, names)
[18:04:23.747]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.747]                   envs[common]]
[18:04:23.747]                 NAMES <- toupper(changed)
[18:04:23.747]                 args <- list()
[18:04:23.747]                 for (kk in seq_along(NAMES)) {
[18:04:23.747]                   name <- changed[[kk]]
[18:04:23.747]                   NAME <- NAMES[[kk]]
[18:04:23.747]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.747]                     next
[18:04:23.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.747]                 }
[18:04:23.747]                 NAMES <- toupper(added)
[18:04:23.747]                 for (kk in seq_along(NAMES)) {
[18:04:23.747]                   name <- added[[kk]]
[18:04:23.747]                   NAME <- NAMES[[kk]]
[18:04:23.747]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.747]                     next
[18:04:23.747]                   args[[name]] <- ""
[18:04:23.747]                 }
[18:04:23.747]                 NAMES <- toupper(removed)
[18:04:23.747]                 for (kk in seq_along(NAMES)) {
[18:04:23.747]                   name <- removed[[kk]]
[18:04:23.747]                   NAME <- NAMES[[kk]]
[18:04:23.747]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.747]                     next
[18:04:23.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.747]                 }
[18:04:23.747]                 if (length(args) > 0) 
[18:04:23.747]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.747]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.747]             }
[18:04:23.747]             else {
[18:04:23.747]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.747]             }
[18:04:23.747]             {
[18:04:23.747]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.747]                   0L) {
[18:04:23.747]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.747]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.747]                   base::options(opts)
[18:04:23.747]                 }
[18:04:23.747]                 {
[18:04:23.747]                   {
[18:04:23.747]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.747]                     NULL
[18:04:23.747]                   }
[18:04:23.747]                   options(future.plan = NULL)
[18:04:23.747]                   if (is.na(NA_character_)) 
[18:04:23.747]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.747]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.747]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.747]                     .init = FALSE)
[18:04:23.747]                 }
[18:04:23.747]             }
[18:04:23.747]         }
[18:04:23.747]     })
[18:04:23.747]     if (TRUE) {
[18:04:23.747]         base::sink(type = "output", split = FALSE)
[18:04:23.747]         if (TRUE) {
[18:04:23.747]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.747]         }
[18:04:23.747]         else {
[18:04:23.747]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.747]         }
[18:04:23.747]         base::close(...future.stdout)
[18:04:23.747]         ...future.stdout <- NULL
[18:04:23.747]     }
[18:04:23.747]     ...future.result$conditions <- ...future.conditions
[18:04:23.747]     ...future.result$finished <- base::Sys.time()
[18:04:23.747]     ...future.result
[18:04:23.747] }
[18:04:23.752] MultisessionFuture started
[18:04:23.753] - Launch lazy future ... done
[18:04:23.753] run() for ‘MultisessionFuture’ ... done
[18:04:23.753] getGlobalsAndPackages() ...
[18:04:23.753] Searching for globals...
[18:04:23.754] 
[18:04:23.754] Searching for globals ... DONE
[18:04:23.754] - globals: [0] <none>
[18:04:23.755] getGlobalsAndPackages() ... DONE
[18:04:23.755] run() for ‘Future’ ...
[18:04:23.755] - state: ‘created’
[18:04:23.756] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.781] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.781] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.782]   - Field: ‘node’
[18:04:23.782]   - Field: ‘label’
[18:04:23.782]   - Field: ‘local’
[18:04:23.782]   - Field: ‘owner’
[18:04:23.782]   - Field: ‘envir’
[18:04:23.783]   - Field: ‘workers’
[18:04:23.783]   - Field: ‘packages’
[18:04:23.783]   - Field: ‘gc’
[18:04:23.783]   - Field: ‘conditions’
[18:04:23.784]   - Field: ‘persistent’
[18:04:23.784]   - Field: ‘expr’
[18:04:23.784]   - Field: ‘uuid’
[18:04:23.784]   - Field: ‘seed’
[18:04:23.784]   - Field: ‘version’
[18:04:23.785]   - Field: ‘result’
[18:04:23.785]   - Field: ‘asynchronous’
[18:04:23.785]   - Field: ‘calls’
[18:04:23.785]   - Field: ‘globals’
[18:04:23.785]   - Field: ‘stdout’
[18:04:23.786]   - Field: ‘earlySignal’
[18:04:23.786]   - Field: ‘lazy’
[18:04:23.786]   - Field: ‘state’
[18:04:23.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.787] - Launch lazy future ...
[18:04:23.787] Packages needed by the future expression (n = 0): <none>
[18:04:23.787] Packages needed by future strategies (n = 0): <none>
[18:04:23.788] {
[18:04:23.788]     {
[18:04:23.788]         {
[18:04:23.788]             ...future.startTime <- base::Sys.time()
[18:04:23.788]             {
[18:04:23.788]                 {
[18:04:23.788]                   {
[18:04:23.788]                     {
[18:04:23.788]                       base::local({
[18:04:23.788]                         has_future <- base::requireNamespace("future", 
[18:04:23.788]                           quietly = TRUE)
[18:04:23.788]                         if (has_future) {
[18:04:23.788]                           ns <- base::getNamespace("future")
[18:04:23.788]                           version <- ns[[".package"]][["version"]]
[18:04:23.788]                           if (is.null(version)) 
[18:04:23.788]                             version <- utils::packageVersion("future")
[18:04:23.788]                         }
[18:04:23.788]                         else {
[18:04:23.788]                           version <- NULL
[18:04:23.788]                         }
[18:04:23.788]                         if (!has_future || version < "1.8.0") {
[18:04:23.788]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.788]                             "", base::R.version$version.string), 
[18:04:23.788]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.788]                               "release", "version")], collapse = " "), 
[18:04:23.788]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.788]                             info)
[18:04:23.788]                           info <- base::paste(info, collapse = "; ")
[18:04:23.788]                           if (!has_future) {
[18:04:23.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.788]                               info)
[18:04:23.788]                           }
[18:04:23.788]                           else {
[18:04:23.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.788]                               info, version)
[18:04:23.788]                           }
[18:04:23.788]                           base::stop(msg)
[18:04:23.788]                         }
[18:04:23.788]                       })
[18:04:23.788]                     }
[18:04:23.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.788]                     base::options(mc.cores = 1L)
[18:04:23.788]                   }
[18:04:23.788]                   ...future.strategy.old <- future::plan("list")
[18:04:23.788]                   options(future.plan = NULL)
[18:04:23.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.788]                 }
[18:04:23.788]                 ...future.workdir <- getwd()
[18:04:23.788]             }
[18:04:23.788]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.788]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.788]         }
[18:04:23.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.788]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.788]             base::names(...future.oldOptions))
[18:04:23.788]     }
[18:04:23.788]     if (FALSE) {
[18:04:23.788]     }
[18:04:23.788]     else {
[18:04:23.788]         if (TRUE) {
[18:04:23.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.788]                 open = "w")
[18:04:23.788]         }
[18:04:23.788]         else {
[18:04:23.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.788]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.788]         }
[18:04:23.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.788]             base::sink(type = "output", split = FALSE)
[18:04:23.788]             base::close(...future.stdout)
[18:04:23.788]         }, add = TRUE)
[18:04:23.788]     }
[18:04:23.788]     ...future.frame <- base::sys.nframe()
[18:04:23.788]     ...future.conditions <- base::list()
[18:04:23.788]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.788]     if (FALSE) {
[18:04:23.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.788]     }
[18:04:23.788]     ...future.result <- base::tryCatch({
[18:04:23.788]         base::withCallingHandlers({
[18:04:23.788]             ...future.value <- base::withVisible(base::local({
[18:04:23.788]                 ...future.makeSendCondition <- base::local({
[18:04:23.788]                   sendCondition <- NULL
[18:04:23.788]                   function(frame = 1L) {
[18:04:23.788]                     if (is.function(sendCondition)) 
[18:04:23.788]                       return(sendCondition)
[18:04:23.788]                     ns <- getNamespace("parallel")
[18:04:23.788]                     if (exists("sendData", mode = "function", 
[18:04:23.788]                       envir = ns)) {
[18:04:23.788]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.788]                         envir = ns)
[18:04:23.788]                       envir <- sys.frame(frame)
[18:04:23.788]                       master <- NULL
[18:04:23.788]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.788]                         !identical(envir, emptyenv())) {
[18:04:23.788]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.788]                           inherits = FALSE)) {
[18:04:23.788]                           master <- get("master", mode = "list", 
[18:04:23.788]                             envir = envir, inherits = FALSE)
[18:04:23.788]                           if (inherits(master, c("SOCKnode", 
[18:04:23.788]                             "SOCK0node"))) {
[18:04:23.788]                             sendCondition <<- function(cond) {
[18:04:23.788]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.788]                                 success = TRUE)
[18:04:23.788]                               parallel_sendData(master, data)
[18:04:23.788]                             }
[18:04:23.788]                             return(sendCondition)
[18:04:23.788]                           }
[18:04:23.788]                         }
[18:04:23.788]                         frame <- frame + 1L
[18:04:23.788]                         envir <- sys.frame(frame)
[18:04:23.788]                       }
[18:04:23.788]                     }
[18:04:23.788]                     sendCondition <<- function(cond) NULL
[18:04:23.788]                   }
[18:04:23.788]                 })
[18:04:23.788]                 withCallingHandlers({
[18:04:23.788]                   NULL
[18:04:23.788]                 }, immediateCondition = function(cond) {
[18:04:23.788]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.788]                   sendCondition(cond)
[18:04:23.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.788]                   {
[18:04:23.788]                     inherits <- base::inherits
[18:04:23.788]                     invokeRestart <- base::invokeRestart
[18:04:23.788]                     is.null <- base::is.null
[18:04:23.788]                     muffled <- FALSE
[18:04:23.788]                     if (inherits(cond, "message")) {
[18:04:23.788]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.788]                       if (muffled) 
[18:04:23.788]                         invokeRestart("muffleMessage")
[18:04:23.788]                     }
[18:04:23.788]                     else if (inherits(cond, "warning")) {
[18:04:23.788]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.788]                       if (muffled) 
[18:04:23.788]                         invokeRestart("muffleWarning")
[18:04:23.788]                     }
[18:04:23.788]                     else if (inherits(cond, "condition")) {
[18:04:23.788]                       if (!is.null(pattern)) {
[18:04:23.788]                         computeRestarts <- base::computeRestarts
[18:04:23.788]                         grepl <- base::grepl
[18:04:23.788]                         restarts <- computeRestarts(cond)
[18:04:23.788]                         for (restart in restarts) {
[18:04:23.788]                           name <- restart$name
[18:04:23.788]                           if (is.null(name)) 
[18:04:23.788]                             next
[18:04:23.788]                           if (!grepl(pattern, name)) 
[18:04:23.788]                             next
[18:04:23.788]                           invokeRestart(restart)
[18:04:23.788]                           muffled <- TRUE
[18:04:23.788]                           break
[18:04:23.788]                         }
[18:04:23.788]                       }
[18:04:23.788]                     }
[18:04:23.788]                     invisible(muffled)
[18:04:23.788]                   }
[18:04:23.788]                   muffleCondition(cond)
[18:04:23.788]                 })
[18:04:23.788]             }))
[18:04:23.788]             future::FutureResult(value = ...future.value$value, 
[18:04:23.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.788]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.788]                     ...future.globalenv.names))
[18:04:23.788]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.788]         }, condition = base::local({
[18:04:23.788]             c <- base::c
[18:04:23.788]             inherits <- base::inherits
[18:04:23.788]             invokeRestart <- base::invokeRestart
[18:04:23.788]             length <- base::length
[18:04:23.788]             list <- base::list
[18:04:23.788]             seq.int <- base::seq.int
[18:04:23.788]             signalCondition <- base::signalCondition
[18:04:23.788]             sys.calls <- base::sys.calls
[18:04:23.788]             `[[` <- base::`[[`
[18:04:23.788]             `+` <- base::`+`
[18:04:23.788]             `<<-` <- base::`<<-`
[18:04:23.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.788]                   3L)]
[18:04:23.788]             }
[18:04:23.788]             function(cond) {
[18:04:23.788]                 is_error <- inherits(cond, "error")
[18:04:23.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.788]                   NULL)
[18:04:23.788]                 if (is_error) {
[18:04:23.788]                   sessionInformation <- function() {
[18:04:23.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.788]                       search = base::search(), system = base::Sys.info())
[18:04:23.788]                   }
[18:04:23.788]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.788]                     cond$call), session = sessionInformation(), 
[18:04:23.788]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.788]                   signalCondition(cond)
[18:04:23.788]                 }
[18:04:23.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.788]                 "immediateCondition"))) {
[18:04:23.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.788]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.788]                   if (TRUE && !signal) {
[18:04:23.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.788]                     {
[18:04:23.788]                       inherits <- base::inherits
[18:04:23.788]                       invokeRestart <- base::invokeRestart
[18:04:23.788]                       is.null <- base::is.null
[18:04:23.788]                       muffled <- FALSE
[18:04:23.788]                       if (inherits(cond, "message")) {
[18:04:23.788]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.788]                         if (muffled) 
[18:04:23.788]                           invokeRestart("muffleMessage")
[18:04:23.788]                       }
[18:04:23.788]                       else if (inherits(cond, "warning")) {
[18:04:23.788]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.788]                         if (muffled) 
[18:04:23.788]                           invokeRestart("muffleWarning")
[18:04:23.788]                       }
[18:04:23.788]                       else if (inherits(cond, "condition")) {
[18:04:23.788]                         if (!is.null(pattern)) {
[18:04:23.788]                           computeRestarts <- base::computeRestarts
[18:04:23.788]                           grepl <- base::grepl
[18:04:23.788]                           restarts <- computeRestarts(cond)
[18:04:23.788]                           for (restart in restarts) {
[18:04:23.788]                             name <- restart$name
[18:04:23.788]                             if (is.null(name)) 
[18:04:23.788]                               next
[18:04:23.788]                             if (!grepl(pattern, name)) 
[18:04:23.788]                               next
[18:04:23.788]                             invokeRestart(restart)
[18:04:23.788]                             muffled <- TRUE
[18:04:23.788]                             break
[18:04:23.788]                           }
[18:04:23.788]                         }
[18:04:23.788]                       }
[18:04:23.788]                       invisible(muffled)
[18:04:23.788]                     }
[18:04:23.788]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.788]                   }
[18:04:23.788]                 }
[18:04:23.788]                 else {
[18:04:23.788]                   if (TRUE) {
[18:04:23.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.788]                     {
[18:04:23.788]                       inherits <- base::inherits
[18:04:23.788]                       invokeRestart <- base::invokeRestart
[18:04:23.788]                       is.null <- base::is.null
[18:04:23.788]                       muffled <- FALSE
[18:04:23.788]                       if (inherits(cond, "message")) {
[18:04:23.788]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.788]                         if (muffled) 
[18:04:23.788]                           invokeRestart("muffleMessage")
[18:04:23.788]                       }
[18:04:23.788]                       else if (inherits(cond, "warning")) {
[18:04:23.788]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.788]                         if (muffled) 
[18:04:23.788]                           invokeRestart("muffleWarning")
[18:04:23.788]                       }
[18:04:23.788]                       else if (inherits(cond, "condition")) {
[18:04:23.788]                         if (!is.null(pattern)) {
[18:04:23.788]                           computeRestarts <- base::computeRestarts
[18:04:23.788]                           grepl <- base::grepl
[18:04:23.788]                           restarts <- computeRestarts(cond)
[18:04:23.788]                           for (restart in restarts) {
[18:04:23.788]                             name <- restart$name
[18:04:23.788]                             if (is.null(name)) 
[18:04:23.788]                               next
[18:04:23.788]                             if (!grepl(pattern, name)) 
[18:04:23.788]                               next
[18:04:23.788]                             invokeRestart(restart)
[18:04:23.788]                             muffled <- TRUE
[18:04:23.788]                             break
[18:04:23.788]                           }
[18:04:23.788]                         }
[18:04:23.788]                       }
[18:04:23.788]                       invisible(muffled)
[18:04:23.788]                     }
[18:04:23.788]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.788]                   }
[18:04:23.788]                 }
[18:04:23.788]             }
[18:04:23.788]         }))
[18:04:23.788]     }, error = function(ex) {
[18:04:23.788]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.788]                 ...future.rng), started = ...future.startTime, 
[18:04:23.788]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.788]             version = "1.8"), class = "FutureResult")
[18:04:23.788]     }, finally = {
[18:04:23.788]         if (!identical(...future.workdir, getwd())) 
[18:04:23.788]             setwd(...future.workdir)
[18:04:23.788]         {
[18:04:23.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.788]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.788]             }
[18:04:23.788]             base::options(...future.oldOptions)
[18:04:23.788]             if (.Platform$OS.type == "windows") {
[18:04:23.788]                 old_names <- names(...future.oldEnvVars)
[18:04:23.788]                 envs <- base::Sys.getenv()
[18:04:23.788]                 names <- names(envs)
[18:04:23.788]                 common <- intersect(names, old_names)
[18:04:23.788]                 added <- setdiff(names, old_names)
[18:04:23.788]                 removed <- setdiff(old_names, names)
[18:04:23.788]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.788]                   envs[common]]
[18:04:23.788]                 NAMES <- toupper(changed)
[18:04:23.788]                 args <- list()
[18:04:23.788]                 for (kk in seq_along(NAMES)) {
[18:04:23.788]                   name <- changed[[kk]]
[18:04:23.788]                   NAME <- NAMES[[kk]]
[18:04:23.788]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.788]                     next
[18:04:23.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.788]                 }
[18:04:23.788]                 NAMES <- toupper(added)
[18:04:23.788]                 for (kk in seq_along(NAMES)) {
[18:04:23.788]                   name <- added[[kk]]
[18:04:23.788]                   NAME <- NAMES[[kk]]
[18:04:23.788]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.788]                     next
[18:04:23.788]                   args[[name]] <- ""
[18:04:23.788]                 }
[18:04:23.788]                 NAMES <- toupper(removed)
[18:04:23.788]                 for (kk in seq_along(NAMES)) {
[18:04:23.788]                   name <- removed[[kk]]
[18:04:23.788]                   NAME <- NAMES[[kk]]
[18:04:23.788]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.788]                     next
[18:04:23.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.788]                 }
[18:04:23.788]                 if (length(args) > 0) 
[18:04:23.788]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.788]             }
[18:04:23.788]             else {
[18:04:23.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.788]             }
[18:04:23.788]             {
[18:04:23.788]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.788]                   0L) {
[18:04:23.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.788]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.788]                   base::options(opts)
[18:04:23.788]                 }
[18:04:23.788]                 {
[18:04:23.788]                   {
[18:04:23.788]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.788]                     NULL
[18:04:23.788]                   }
[18:04:23.788]                   options(future.plan = NULL)
[18:04:23.788]                   if (is.na(NA_character_)) 
[18:04:23.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.788]                     .init = FALSE)
[18:04:23.788]                 }
[18:04:23.788]             }
[18:04:23.788]         }
[18:04:23.788]     })
[18:04:23.788]     if (TRUE) {
[18:04:23.788]         base::sink(type = "output", split = FALSE)
[18:04:23.788]         if (TRUE) {
[18:04:23.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.788]         }
[18:04:23.788]         else {
[18:04:23.788]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.788]         }
[18:04:23.788]         base::close(...future.stdout)
[18:04:23.788]         ...future.stdout <- NULL
[18:04:23.788]     }
[18:04:23.788]     ...future.result$conditions <- ...future.conditions
[18:04:23.788]     ...future.result$finished <- base::Sys.time()
[18:04:23.788]     ...future.result
[18:04:23.788] }
[18:04:23.797] MultisessionFuture started
[18:04:23.797] - Launch lazy future ... done
[18:04:23.797] run() for ‘MultisessionFuture’ ... done
[18:04:23.800] getGlobalsAndPackages() ...
[18:04:23.800] Searching for globals...
[18:04:23.801] - globals found: [1] ‘{’
[18:04:23.801] Searching for globals ... DONE
[18:04:23.802] Resolving globals: FALSE
[18:04:23.802] 
[18:04:23.802] 
[18:04:23.803] getGlobalsAndPackages() ... DONE
[18:04:23.803] run() for ‘Future’ ...
[18:04:23.803] - state: ‘created’
[18:04:23.804] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.828] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.829]   - Field: ‘node’
[18:04:23.829]   - Field: ‘label’
[18:04:23.829]   - Field: ‘local’
[18:04:23.829]   - Field: ‘owner’
[18:04:23.830]   - Field: ‘envir’
[18:04:23.830]   - Field: ‘workers’
[18:04:23.830]   - Field: ‘packages’
[18:04:23.830]   - Field: ‘gc’
[18:04:23.830]   - Field: ‘conditions’
[18:04:23.830]   - Field: ‘persistent’
[18:04:23.831]   - Field: ‘expr’
[18:04:23.831]   - Field: ‘uuid’
[18:04:23.831]   - Field: ‘seed’
[18:04:23.831]   - Field: ‘version’
[18:04:23.831]   - Field: ‘result’
[18:04:23.832]   - Field: ‘asynchronous’
[18:04:23.832]   - Field: ‘calls’
[18:04:23.832]   - Field: ‘globals’
[18:04:23.832]   - Field: ‘stdout’
[18:04:23.832]   - Field: ‘earlySignal’
[18:04:23.833]   - Field: ‘lazy’
[18:04:23.833]   - Field: ‘state’
[18:04:23.833] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.833] - Launch lazy future ...
[18:04:23.834] Packages needed by the future expression (n = 0): <none>
[18:04:23.834] Packages needed by future strategies (n = 0): <none>
[18:04:23.835] {
[18:04:23.835]     {
[18:04:23.835]         {
[18:04:23.835]             ...future.startTime <- base::Sys.time()
[18:04:23.835]             {
[18:04:23.835]                 {
[18:04:23.835]                   {
[18:04:23.835]                     {
[18:04:23.835]                       base::local({
[18:04:23.835]                         has_future <- base::requireNamespace("future", 
[18:04:23.835]                           quietly = TRUE)
[18:04:23.835]                         if (has_future) {
[18:04:23.835]                           ns <- base::getNamespace("future")
[18:04:23.835]                           version <- ns[[".package"]][["version"]]
[18:04:23.835]                           if (is.null(version)) 
[18:04:23.835]                             version <- utils::packageVersion("future")
[18:04:23.835]                         }
[18:04:23.835]                         else {
[18:04:23.835]                           version <- NULL
[18:04:23.835]                         }
[18:04:23.835]                         if (!has_future || version < "1.8.0") {
[18:04:23.835]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.835]                             "", base::R.version$version.string), 
[18:04:23.835]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.835]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.835]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.835]                               "release", "version")], collapse = " "), 
[18:04:23.835]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.835]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.835]                             info)
[18:04:23.835]                           info <- base::paste(info, collapse = "; ")
[18:04:23.835]                           if (!has_future) {
[18:04:23.835]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.835]                               info)
[18:04:23.835]                           }
[18:04:23.835]                           else {
[18:04:23.835]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.835]                               info, version)
[18:04:23.835]                           }
[18:04:23.835]                           base::stop(msg)
[18:04:23.835]                         }
[18:04:23.835]                       })
[18:04:23.835]                     }
[18:04:23.835]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.835]                     base::options(mc.cores = 1L)
[18:04:23.835]                   }
[18:04:23.835]                   ...future.strategy.old <- future::plan("list")
[18:04:23.835]                   options(future.plan = NULL)
[18:04:23.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.835]                 }
[18:04:23.835]                 ...future.workdir <- getwd()
[18:04:23.835]             }
[18:04:23.835]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.835]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.835]         }
[18:04:23.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.835]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.835]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.835]             base::names(...future.oldOptions))
[18:04:23.835]     }
[18:04:23.835]     if (FALSE) {
[18:04:23.835]     }
[18:04:23.835]     else {
[18:04:23.835]         if (TRUE) {
[18:04:23.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.835]                 open = "w")
[18:04:23.835]         }
[18:04:23.835]         else {
[18:04:23.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.835]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.835]         }
[18:04:23.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.835]             base::sink(type = "output", split = FALSE)
[18:04:23.835]             base::close(...future.stdout)
[18:04:23.835]         }, add = TRUE)
[18:04:23.835]     }
[18:04:23.835]     ...future.frame <- base::sys.nframe()
[18:04:23.835]     ...future.conditions <- base::list()
[18:04:23.835]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.835]     if (FALSE) {
[18:04:23.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.835]     }
[18:04:23.835]     ...future.result <- base::tryCatch({
[18:04:23.835]         base::withCallingHandlers({
[18:04:23.835]             ...future.value <- base::withVisible(base::local({
[18:04:23.835]                 ...future.makeSendCondition <- base::local({
[18:04:23.835]                   sendCondition <- NULL
[18:04:23.835]                   function(frame = 1L) {
[18:04:23.835]                     if (is.function(sendCondition)) 
[18:04:23.835]                       return(sendCondition)
[18:04:23.835]                     ns <- getNamespace("parallel")
[18:04:23.835]                     if (exists("sendData", mode = "function", 
[18:04:23.835]                       envir = ns)) {
[18:04:23.835]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.835]                         envir = ns)
[18:04:23.835]                       envir <- sys.frame(frame)
[18:04:23.835]                       master <- NULL
[18:04:23.835]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.835]                         !identical(envir, emptyenv())) {
[18:04:23.835]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.835]                           inherits = FALSE)) {
[18:04:23.835]                           master <- get("master", mode = "list", 
[18:04:23.835]                             envir = envir, inherits = FALSE)
[18:04:23.835]                           if (inherits(master, c("SOCKnode", 
[18:04:23.835]                             "SOCK0node"))) {
[18:04:23.835]                             sendCondition <<- function(cond) {
[18:04:23.835]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.835]                                 success = TRUE)
[18:04:23.835]                               parallel_sendData(master, data)
[18:04:23.835]                             }
[18:04:23.835]                             return(sendCondition)
[18:04:23.835]                           }
[18:04:23.835]                         }
[18:04:23.835]                         frame <- frame + 1L
[18:04:23.835]                         envir <- sys.frame(frame)
[18:04:23.835]                       }
[18:04:23.835]                     }
[18:04:23.835]                     sendCondition <<- function(cond) NULL
[18:04:23.835]                   }
[18:04:23.835]                 })
[18:04:23.835]                 withCallingHandlers({
[18:04:23.835]                   {
[18:04:23.835]                     4
[18:04:23.835]                   }
[18:04:23.835]                 }, immediateCondition = function(cond) {
[18:04:23.835]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.835]                   sendCondition(cond)
[18:04:23.835]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.835]                   {
[18:04:23.835]                     inherits <- base::inherits
[18:04:23.835]                     invokeRestart <- base::invokeRestart
[18:04:23.835]                     is.null <- base::is.null
[18:04:23.835]                     muffled <- FALSE
[18:04:23.835]                     if (inherits(cond, "message")) {
[18:04:23.835]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.835]                       if (muffled) 
[18:04:23.835]                         invokeRestart("muffleMessage")
[18:04:23.835]                     }
[18:04:23.835]                     else if (inherits(cond, "warning")) {
[18:04:23.835]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.835]                       if (muffled) 
[18:04:23.835]                         invokeRestart("muffleWarning")
[18:04:23.835]                     }
[18:04:23.835]                     else if (inherits(cond, "condition")) {
[18:04:23.835]                       if (!is.null(pattern)) {
[18:04:23.835]                         computeRestarts <- base::computeRestarts
[18:04:23.835]                         grepl <- base::grepl
[18:04:23.835]                         restarts <- computeRestarts(cond)
[18:04:23.835]                         for (restart in restarts) {
[18:04:23.835]                           name <- restart$name
[18:04:23.835]                           if (is.null(name)) 
[18:04:23.835]                             next
[18:04:23.835]                           if (!grepl(pattern, name)) 
[18:04:23.835]                             next
[18:04:23.835]                           invokeRestart(restart)
[18:04:23.835]                           muffled <- TRUE
[18:04:23.835]                           break
[18:04:23.835]                         }
[18:04:23.835]                       }
[18:04:23.835]                     }
[18:04:23.835]                     invisible(muffled)
[18:04:23.835]                   }
[18:04:23.835]                   muffleCondition(cond)
[18:04:23.835]                 })
[18:04:23.835]             }))
[18:04:23.835]             future::FutureResult(value = ...future.value$value, 
[18:04:23.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.835]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.835]                     ...future.globalenv.names))
[18:04:23.835]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.835]         }, condition = base::local({
[18:04:23.835]             c <- base::c
[18:04:23.835]             inherits <- base::inherits
[18:04:23.835]             invokeRestart <- base::invokeRestart
[18:04:23.835]             length <- base::length
[18:04:23.835]             list <- base::list
[18:04:23.835]             seq.int <- base::seq.int
[18:04:23.835]             signalCondition <- base::signalCondition
[18:04:23.835]             sys.calls <- base::sys.calls
[18:04:23.835]             `[[` <- base::`[[`
[18:04:23.835]             `+` <- base::`+`
[18:04:23.835]             `<<-` <- base::`<<-`
[18:04:23.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.835]                   3L)]
[18:04:23.835]             }
[18:04:23.835]             function(cond) {
[18:04:23.835]                 is_error <- inherits(cond, "error")
[18:04:23.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.835]                   NULL)
[18:04:23.835]                 if (is_error) {
[18:04:23.835]                   sessionInformation <- function() {
[18:04:23.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.835]                       search = base::search(), system = base::Sys.info())
[18:04:23.835]                   }
[18:04:23.835]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.835]                     cond$call), session = sessionInformation(), 
[18:04:23.835]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.835]                   signalCondition(cond)
[18:04:23.835]                 }
[18:04:23.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.835]                 "immediateCondition"))) {
[18:04:23.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.835]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.835]                   if (TRUE && !signal) {
[18:04:23.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.835]                     {
[18:04:23.835]                       inherits <- base::inherits
[18:04:23.835]                       invokeRestart <- base::invokeRestart
[18:04:23.835]                       is.null <- base::is.null
[18:04:23.835]                       muffled <- FALSE
[18:04:23.835]                       if (inherits(cond, "message")) {
[18:04:23.835]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.835]                         if (muffled) 
[18:04:23.835]                           invokeRestart("muffleMessage")
[18:04:23.835]                       }
[18:04:23.835]                       else if (inherits(cond, "warning")) {
[18:04:23.835]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.835]                         if (muffled) 
[18:04:23.835]                           invokeRestart("muffleWarning")
[18:04:23.835]                       }
[18:04:23.835]                       else if (inherits(cond, "condition")) {
[18:04:23.835]                         if (!is.null(pattern)) {
[18:04:23.835]                           computeRestarts <- base::computeRestarts
[18:04:23.835]                           grepl <- base::grepl
[18:04:23.835]                           restarts <- computeRestarts(cond)
[18:04:23.835]                           for (restart in restarts) {
[18:04:23.835]                             name <- restart$name
[18:04:23.835]                             if (is.null(name)) 
[18:04:23.835]                               next
[18:04:23.835]                             if (!grepl(pattern, name)) 
[18:04:23.835]                               next
[18:04:23.835]                             invokeRestart(restart)
[18:04:23.835]                             muffled <- TRUE
[18:04:23.835]                             break
[18:04:23.835]                           }
[18:04:23.835]                         }
[18:04:23.835]                       }
[18:04:23.835]                       invisible(muffled)
[18:04:23.835]                     }
[18:04:23.835]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.835]                   }
[18:04:23.835]                 }
[18:04:23.835]                 else {
[18:04:23.835]                   if (TRUE) {
[18:04:23.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.835]                     {
[18:04:23.835]                       inherits <- base::inherits
[18:04:23.835]                       invokeRestart <- base::invokeRestart
[18:04:23.835]                       is.null <- base::is.null
[18:04:23.835]                       muffled <- FALSE
[18:04:23.835]                       if (inherits(cond, "message")) {
[18:04:23.835]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.835]                         if (muffled) 
[18:04:23.835]                           invokeRestart("muffleMessage")
[18:04:23.835]                       }
[18:04:23.835]                       else if (inherits(cond, "warning")) {
[18:04:23.835]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.835]                         if (muffled) 
[18:04:23.835]                           invokeRestart("muffleWarning")
[18:04:23.835]                       }
[18:04:23.835]                       else if (inherits(cond, "condition")) {
[18:04:23.835]                         if (!is.null(pattern)) {
[18:04:23.835]                           computeRestarts <- base::computeRestarts
[18:04:23.835]                           grepl <- base::grepl
[18:04:23.835]                           restarts <- computeRestarts(cond)
[18:04:23.835]                           for (restart in restarts) {
[18:04:23.835]                             name <- restart$name
[18:04:23.835]                             if (is.null(name)) 
[18:04:23.835]                               next
[18:04:23.835]                             if (!grepl(pattern, name)) 
[18:04:23.835]                               next
[18:04:23.835]                             invokeRestart(restart)
[18:04:23.835]                             muffled <- TRUE
[18:04:23.835]                             break
[18:04:23.835]                           }
[18:04:23.835]                         }
[18:04:23.835]                       }
[18:04:23.835]                       invisible(muffled)
[18:04:23.835]                     }
[18:04:23.835]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.835]                   }
[18:04:23.835]                 }
[18:04:23.835]             }
[18:04:23.835]         }))
[18:04:23.835]     }, error = function(ex) {
[18:04:23.835]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.835]                 ...future.rng), started = ...future.startTime, 
[18:04:23.835]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.835]             version = "1.8"), class = "FutureResult")
[18:04:23.835]     }, finally = {
[18:04:23.835]         if (!identical(...future.workdir, getwd())) 
[18:04:23.835]             setwd(...future.workdir)
[18:04:23.835]         {
[18:04:23.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.835]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.835]             }
[18:04:23.835]             base::options(...future.oldOptions)
[18:04:23.835]             if (.Platform$OS.type == "windows") {
[18:04:23.835]                 old_names <- names(...future.oldEnvVars)
[18:04:23.835]                 envs <- base::Sys.getenv()
[18:04:23.835]                 names <- names(envs)
[18:04:23.835]                 common <- intersect(names, old_names)
[18:04:23.835]                 added <- setdiff(names, old_names)
[18:04:23.835]                 removed <- setdiff(old_names, names)
[18:04:23.835]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.835]                   envs[common]]
[18:04:23.835]                 NAMES <- toupper(changed)
[18:04:23.835]                 args <- list()
[18:04:23.835]                 for (kk in seq_along(NAMES)) {
[18:04:23.835]                   name <- changed[[kk]]
[18:04:23.835]                   NAME <- NAMES[[kk]]
[18:04:23.835]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.835]                     next
[18:04:23.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.835]                 }
[18:04:23.835]                 NAMES <- toupper(added)
[18:04:23.835]                 for (kk in seq_along(NAMES)) {
[18:04:23.835]                   name <- added[[kk]]
[18:04:23.835]                   NAME <- NAMES[[kk]]
[18:04:23.835]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.835]                     next
[18:04:23.835]                   args[[name]] <- ""
[18:04:23.835]                 }
[18:04:23.835]                 NAMES <- toupper(removed)
[18:04:23.835]                 for (kk in seq_along(NAMES)) {
[18:04:23.835]                   name <- removed[[kk]]
[18:04:23.835]                   NAME <- NAMES[[kk]]
[18:04:23.835]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.835]                     next
[18:04:23.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.835]                 }
[18:04:23.835]                 if (length(args) > 0) 
[18:04:23.835]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.835]             }
[18:04:23.835]             else {
[18:04:23.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.835]             }
[18:04:23.835]             {
[18:04:23.835]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.835]                   0L) {
[18:04:23.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.835]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.835]                   base::options(opts)
[18:04:23.835]                 }
[18:04:23.835]                 {
[18:04:23.835]                   {
[18:04:23.835]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.835]                     NULL
[18:04:23.835]                   }
[18:04:23.835]                   options(future.plan = NULL)
[18:04:23.835]                   if (is.na(NA_character_)) 
[18:04:23.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.835]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.835]                     .init = FALSE)
[18:04:23.835]                 }
[18:04:23.835]             }
[18:04:23.835]         }
[18:04:23.835]     })
[18:04:23.835]     if (TRUE) {
[18:04:23.835]         base::sink(type = "output", split = FALSE)
[18:04:23.835]         if (TRUE) {
[18:04:23.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.835]         }
[18:04:23.835]         else {
[18:04:23.835]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.835]         }
[18:04:23.835]         base::close(...future.stdout)
[18:04:23.835]         ...future.stdout <- NULL
[18:04:23.835]     }
[18:04:23.835]     ...future.result$conditions <- ...future.conditions
[18:04:23.835]     ...future.result$finished <- base::Sys.time()
[18:04:23.835]     ...future.result
[18:04:23.835] }
[18:04:23.839] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:23.850] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.851] - Validating connection of MultisessionFuture
[18:04:23.851] - received message: FutureResult
[18:04:23.851] - Received FutureResult
[18:04:23.852] - Erased future from FutureRegistry
[18:04:23.852] result() for ClusterFuture ...
[18:04:23.852] - result already collected: FutureResult
[18:04:23.852] result() for ClusterFuture ... done
[18:04:23.852] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:23.853] result() for ClusterFuture ...
[18:04:23.853] - result already collected: FutureResult
[18:04:23.853] result() for ClusterFuture ... done
[18:04:23.853] result() for ClusterFuture ...
[18:04:23.853] - result already collected: FutureResult
[18:04:23.854] result() for ClusterFuture ... done
[18:04:23.856] MultisessionFuture started
[18:04:23.856] - Launch lazy future ... done
[18:04:23.856] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c28d9e950> 
Classes 'listenv', 'environment' <environment: 0x5e3c2ce510d0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[18:04:23.864] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.864] - Validating connection of MultisessionFuture
[18:04:23.865] - received message: FutureResult
[18:04:23.865] - Received FutureResult
[18:04:23.865] - Erased future from FutureRegistry
[18:04:23.865] result() for ClusterFuture ...
[18:04:23.865] - result already collected: FutureResult
[18:04:23.866] result() for ClusterFuture ... done
[18:04:23.866] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:23.881] resolve() on list environment ...
[18:04:23.882]  recursive: 0
[18:04:23.884]  length: 6
[18:04:23.884]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:23.884] signalConditionsASAP(numeric, pos=1) ...
[18:04:23.884] - nx: 6
[18:04:23.884] - relay: TRUE
[18:04:23.885] - stdout: TRUE
[18:04:23.885] - signal: TRUE
[18:04:23.885] - resignal: FALSE
[18:04:23.885] - force: TRUE
[18:04:23.885] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.885] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.886]  - until=2
[18:04:23.886]  - relaying element #2
[18:04:23.886] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.886] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.886] signalConditionsASAP(NULL, pos=1) ... done
[18:04:23.887]  length: 5 (resolved future 1)
[18:04:23.887] Future #2
[18:04:23.887] result() for ClusterFuture ...
[18:04:23.887] - result already collected: FutureResult
[18:04:23.888] result() for ClusterFuture ... done
[18:04:23.888] result() for ClusterFuture ...
[18:04:23.888] - result already collected: FutureResult
[18:04:23.888] result() for ClusterFuture ... done
[18:04:23.888] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:23.889] - nx: 6
[18:04:23.889] - relay: TRUE
[18:04:23.889] - stdout: TRUE
[18:04:23.889] - signal: TRUE
[18:04:23.889] - resignal: FALSE
[18:04:23.889] - force: TRUE
[18:04:23.890] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.890] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:23.890]  - until=2
[18:04:23.890]  - relaying element #2
[18:04:23.894] result() for ClusterFuture ...
[18:04:23.894] - result already collected: FutureResult
[18:04:23.894] result() for ClusterFuture ... done
[18:04:23.895] result() for ClusterFuture ...
[18:04:23.895] - result already collected: FutureResult
[18:04:23.895] result() for ClusterFuture ... done
[18:04:23.895] result() for ClusterFuture ...
[18:04:23.895] - result already collected: FutureResult
[18:04:23.896] result() for ClusterFuture ... done
[18:04:23.896] result() for ClusterFuture ...
[18:04:23.896] - result already collected: FutureResult
[18:04:23.896] result() for ClusterFuture ... done
[18:04:23.896] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.897] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.897] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:23.897]  length: 4 (resolved future 2)
[18:04:23.897] Future #3
[18:04:23.898] result() for ClusterFuture ...
[18:04:23.898] - result already collected: FutureResult
[18:04:23.898] result() for ClusterFuture ... done
[18:04:23.898] result() for ClusterFuture ...
[18:04:23.898] - result already collected: FutureResult
[18:04:23.898] result() for ClusterFuture ... done
[18:04:23.899] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:23.899] - nx: 6
[18:04:23.899] - relay: TRUE
[18:04:23.899] - stdout: TRUE
[18:04:23.899] - signal: TRUE
[18:04:23.900] - resignal: FALSE
[18:04:23.900] - force: TRUE
[18:04:23.900] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.900] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:23.900]  - until=3
[18:04:23.900]  - relaying element #3
[18:04:23.901] result() for ClusterFuture ...
[18:04:23.901] - result already collected: FutureResult
[18:04:23.901] result() for ClusterFuture ... done
[18:04:23.901] result() for ClusterFuture ...
[18:04:23.901] - result already collected: FutureResult
[18:04:23.902] result() for ClusterFuture ... done
[18:04:23.902] result() for ClusterFuture ...
[18:04:23.902] - result already collected: FutureResult
[18:04:23.903] result() for ClusterFuture ... done
[18:04:23.903] result() for ClusterFuture ...
[18:04:23.903] - result already collected: FutureResult
[18:04:23.903] result() for ClusterFuture ... done
[18:04:23.903] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.903] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.904] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:23.904]  length: 3 (resolved future 3)
[18:04:23.905] receiveMessageFromWorker() for ClusterFuture ...
[18:04:23.905] - Validating connection of MultisessionFuture
[18:04:23.906] - received message: FutureResult
[18:04:23.906] - Received FutureResult
[18:04:23.906] - Erased future from FutureRegistry
[18:04:23.906] result() for ClusterFuture ...
[18:04:23.906] - result already collected: FutureResult
[18:04:23.907] result() for ClusterFuture ... done
[18:04:23.907] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:23.907] Future #4
[18:04:23.907] result() for ClusterFuture ...
[18:04:23.907] - result already collected: FutureResult
[18:04:23.907] result() for ClusterFuture ... done
[18:04:23.908] result() for ClusterFuture ...
[18:04:23.908] - result already collected: FutureResult
[18:04:23.908] result() for ClusterFuture ... done
[18:04:23.908] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:23.908] - nx: 6
[18:04:23.909] - relay: TRUE
[18:04:23.909] - stdout: TRUE
[18:04:23.909] - signal: TRUE
[18:04:23.909] - resignal: FALSE
[18:04:23.909] - force: TRUE
[18:04:23.909] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.910] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:23.910]  - until=4
[18:04:23.910]  - relaying element #4
[18:04:23.910] result() for ClusterFuture ...
[18:04:23.910] - result already collected: FutureResult
[18:04:23.911] result() for ClusterFuture ... done
[18:04:23.911] result() for ClusterFuture ...
[18:04:23.911] - result already collected: FutureResult
[18:04:23.911] result() for ClusterFuture ... done
[18:04:23.911] result() for ClusterFuture ...
[18:04:23.911] - result already collected: FutureResult
[18:04:23.912] result() for ClusterFuture ... done
[18:04:23.912] result() for ClusterFuture ...
[18:04:23.912] - result already collected: FutureResult
[18:04:23.912] result() for ClusterFuture ... done
[18:04:23.912] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.913] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.913] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:23.913]  length: 2 (resolved future 4)
[18:04:23.913] signalConditionsASAP(NULL, pos=5) ...
[18:04:23.913] - nx: 6
[18:04:23.913] - relay: TRUE
[18:04:23.914] - stdout: TRUE
[18:04:23.914] - signal: TRUE
[18:04:23.914] - resignal: FALSE
[18:04:23.914] - force: TRUE
[18:04:23.914] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.914] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.915]  - until=6
[18:04:23.915]  - relaying element #6
[18:04:23.915] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:23.915] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.915] signalConditionsASAP(NULL, pos=5) ... done
[18:04:23.916]  length: 1 (resolved future 5)
[18:04:23.916] signalConditionsASAP(numeric, pos=6) ...
[18:04:23.916] - nx: 6
[18:04:23.916] - relay: TRUE
[18:04:23.916] - stdout: TRUE
[18:04:23.917] - signal: TRUE
[18:04:23.917] - resignal: FALSE
[18:04:23.917] - force: TRUE
[18:04:23.917] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:23.917] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.917]  - until=6
[18:04:23.918] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:23.918] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.918] signalConditionsASAP(numeric, pos=6) ... done
[18:04:23.918]  length: 0 (resolved future 6)
[18:04:23.918] Relaying remaining futures
[18:04:23.918] signalConditionsASAP(NULL, pos=0) ...
[18:04:23.919] - nx: 6
[18:04:23.919] - relay: TRUE
[18:04:23.919] - stdout: TRUE
[18:04:23.919] - signal: TRUE
[18:04:23.919] - resignal: FALSE
[18:04:23.919] - force: TRUE
[18:04:23.920] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:23.920] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:23.920] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:23.920] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:23.920] signalConditionsASAP(NULL, pos=0) ... done
[18:04:23.921] resolve() on list environment ... DONE
[18:04:23.921] result() for ClusterFuture ...
[18:04:23.921] - result already collected: FutureResult
[18:04:23.921] result() for ClusterFuture ... done
[18:04:23.921] result() for ClusterFuture ...
[18:04:23.922] - result already collected: FutureResult
[18:04:23.922] result() for ClusterFuture ... done
[18:04:23.922] result() for ClusterFuture ...
[18:04:23.922] - result already collected: FutureResult
[18:04:23.922] result() for ClusterFuture ... done
[18:04:23.923] result() for ClusterFuture ...
[18:04:23.923] - result already collected: FutureResult
[18:04:23.923] result() for ClusterFuture ... done
[18:04:23.923] result() for ClusterFuture ...
[18:04:23.924] - result already collected: FutureResult
[18:04:23.924] result() for ClusterFuture ... done
[18:04:23.924] result() for ClusterFuture ...
[18:04:23.924] - result already collected: FutureResult
[18:04:23.924] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2d12d2f0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[18:04:23.927] getGlobalsAndPackages() ...
[18:04:23.928] Searching for globals...
[18:04:23.928] 
[18:04:23.929] Searching for globals ... DONE
[18:04:23.929] - globals: [0] <none>
[18:04:23.929] getGlobalsAndPackages() ... DONE
[18:04:23.929] run() for ‘Future’ ...
[18:04:23.930] - state: ‘created’
[18:04:23.930] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.953] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.953]   - Field: ‘node’
[18:04:23.953]   - Field: ‘label’
[18:04:23.954]   - Field: ‘local’
[18:04:23.954]   - Field: ‘owner’
[18:04:23.954]   - Field: ‘envir’
[18:04:23.954]   - Field: ‘workers’
[18:04:23.954]   - Field: ‘packages’
[18:04:23.955]   - Field: ‘gc’
[18:04:23.955]   - Field: ‘conditions’
[18:04:23.955]   - Field: ‘persistent’
[18:04:23.955]   - Field: ‘expr’
[18:04:23.955]   - Field: ‘uuid’
[18:04:23.956]   - Field: ‘seed’
[18:04:23.956]   - Field: ‘version’
[18:04:23.956]   - Field: ‘result’
[18:04:23.956]   - Field: ‘asynchronous’
[18:04:23.956]   - Field: ‘calls’
[18:04:23.957]   - Field: ‘globals’
[18:04:23.957]   - Field: ‘stdout’
[18:04:23.957]   - Field: ‘earlySignal’
[18:04:23.957]   - Field: ‘lazy’
[18:04:23.957]   - Field: ‘state’
[18:04:23.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.958] - Launch lazy future ...
[18:04:23.958] Packages needed by the future expression (n = 0): <none>
[18:04:23.959] Packages needed by future strategies (n = 0): <none>
[18:04:23.959] {
[18:04:23.959]     {
[18:04:23.959]         {
[18:04:23.959]             ...future.startTime <- base::Sys.time()
[18:04:23.959]             {
[18:04:23.959]                 {
[18:04:23.959]                   {
[18:04:23.959]                     {
[18:04:23.959]                       base::local({
[18:04:23.959]                         has_future <- base::requireNamespace("future", 
[18:04:23.959]                           quietly = TRUE)
[18:04:23.959]                         if (has_future) {
[18:04:23.959]                           ns <- base::getNamespace("future")
[18:04:23.959]                           version <- ns[[".package"]][["version"]]
[18:04:23.959]                           if (is.null(version)) 
[18:04:23.959]                             version <- utils::packageVersion("future")
[18:04:23.959]                         }
[18:04:23.959]                         else {
[18:04:23.959]                           version <- NULL
[18:04:23.959]                         }
[18:04:23.959]                         if (!has_future || version < "1.8.0") {
[18:04:23.959]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:23.959]                             "", base::R.version$version.string), 
[18:04:23.959]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:23.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:23.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:23.959]                               "release", "version")], collapse = " "), 
[18:04:23.959]                             hostname = base::Sys.info()[["nodename"]])
[18:04:23.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:23.959]                             info)
[18:04:23.959]                           info <- base::paste(info, collapse = "; ")
[18:04:23.959]                           if (!has_future) {
[18:04:23.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:23.959]                               info)
[18:04:23.959]                           }
[18:04:23.959]                           else {
[18:04:23.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:23.959]                               info, version)
[18:04:23.959]                           }
[18:04:23.959]                           base::stop(msg)
[18:04:23.959]                         }
[18:04:23.959]                       })
[18:04:23.959]                     }
[18:04:23.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:23.959]                     base::options(mc.cores = 1L)
[18:04:23.959]                   }
[18:04:23.959]                   ...future.strategy.old <- future::plan("list")
[18:04:23.959]                   options(future.plan = NULL)
[18:04:23.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:23.959]                 }
[18:04:23.959]                 ...future.workdir <- getwd()
[18:04:23.959]             }
[18:04:23.959]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:23.959]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:23.959]         }
[18:04:23.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:23.959]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:23.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:23.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:23.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:23.959]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:23.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:23.959]             base::names(...future.oldOptions))
[18:04:23.959]     }
[18:04:23.959]     if (FALSE) {
[18:04:23.959]     }
[18:04:23.959]     else {
[18:04:23.959]         if (TRUE) {
[18:04:23.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:23.959]                 open = "w")
[18:04:23.959]         }
[18:04:23.959]         else {
[18:04:23.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:23.959]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:23.959]         }
[18:04:23.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:23.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:23.959]             base::sink(type = "output", split = FALSE)
[18:04:23.959]             base::close(...future.stdout)
[18:04:23.959]         }, add = TRUE)
[18:04:23.959]     }
[18:04:23.959]     ...future.frame <- base::sys.nframe()
[18:04:23.959]     ...future.conditions <- base::list()
[18:04:23.959]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:23.959]     if (FALSE) {
[18:04:23.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:23.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:23.959]     }
[18:04:23.959]     ...future.result <- base::tryCatch({
[18:04:23.959]         base::withCallingHandlers({
[18:04:23.959]             ...future.value <- base::withVisible(base::local({
[18:04:23.959]                 ...future.makeSendCondition <- base::local({
[18:04:23.959]                   sendCondition <- NULL
[18:04:23.959]                   function(frame = 1L) {
[18:04:23.959]                     if (is.function(sendCondition)) 
[18:04:23.959]                       return(sendCondition)
[18:04:23.959]                     ns <- getNamespace("parallel")
[18:04:23.959]                     if (exists("sendData", mode = "function", 
[18:04:23.959]                       envir = ns)) {
[18:04:23.959]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:23.959]                         envir = ns)
[18:04:23.959]                       envir <- sys.frame(frame)
[18:04:23.959]                       master <- NULL
[18:04:23.959]                       while (!identical(envir, .GlobalEnv) && 
[18:04:23.959]                         !identical(envir, emptyenv())) {
[18:04:23.959]                         if (exists("master", mode = "list", envir = envir, 
[18:04:23.959]                           inherits = FALSE)) {
[18:04:23.959]                           master <- get("master", mode = "list", 
[18:04:23.959]                             envir = envir, inherits = FALSE)
[18:04:23.959]                           if (inherits(master, c("SOCKnode", 
[18:04:23.959]                             "SOCK0node"))) {
[18:04:23.959]                             sendCondition <<- function(cond) {
[18:04:23.959]                               data <- list(type = "VALUE", value = cond, 
[18:04:23.959]                                 success = TRUE)
[18:04:23.959]                               parallel_sendData(master, data)
[18:04:23.959]                             }
[18:04:23.959]                             return(sendCondition)
[18:04:23.959]                           }
[18:04:23.959]                         }
[18:04:23.959]                         frame <- frame + 1L
[18:04:23.959]                         envir <- sys.frame(frame)
[18:04:23.959]                       }
[18:04:23.959]                     }
[18:04:23.959]                     sendCondition <<- function(cond) NULL
[18:04:23.959]                   }
[18:04:23.959]                 })
[18:04:23.959]                 withCallingHandlers({
[18:04:23.959]                   2
[18:04:23.959]                 }, immediateCondition = function(cond) {
[18:04:23.959]                   sendCondition <- ...future.makeSendCondition()
[18:04:23.959]                   sendCondition(cond)
[18:04:23.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.959]                   {
[18:04:23.959]                     inherits <- base::inherits
[18:04:23.959]                     invokeRestart <- base::invokeRestart
[18:04:23.959]                     is.null <- base::is.null
[18:04:23.959]                     muffled <- FALSE
[18:04:23.959]                     if (inherits(cond, "message")) {
[18:04:23.959]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:23.959]                       if (muffled) 
[18:04:23.959]                         invokeRestart("muffleMessage")
[18:04:23.959]                     }
[18:04:23.959]                     else if (inherits(cond, "warning")) {
[18:04:23.959]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:23.959]                       if (muffled) 
[18:04:23.959]                         invokeRestart("muffleWarning")
[18:04:23.959]                     }
[18:04:23.959]                     else if (inherits(cond, "condition")) {
[18:04:23.959]                       if (!is.null(pattern)) {
[18:04:23.959]                         computeRestarts <- base::computeRestarts
[18:04:23.959]                         grepl <- base::grepl
[18:04:23.959]                         restarts <- computeRestarts(cond)
[18:04:23.959]                         for (restart in restarts) {
[18:04:23.959]                           name <- restart$name
[18:04:23.959]                           if (is.null(name)) 
[18:04:23.959]                             next
[18:04:23.959]                           if (!grepl(pattern, name)) 
[18:04:23.959]                             next
[18:04:23.959]                           invokeRestart(restart)
[18:04:23.959]                           muffled <- TRUE
[18:04:23.959]                           break
[18:04:23.959]                         }
[18:04:23.959]                       }
[18:04:23.959]                     }
[18:04:23.959]                     invisible(muffled)
[18:04:23.959]                   }
[18:04:23.959]                   muffleCondition(cond)
[18:04:23.959]                 })
[18:04:23.959]             }))
[18:04:23.959]             future::FutureResult(value = ...future.value$value, 
[18:04:23.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.959]                   ...future.rng), globalenv = if (FALSE) 
[18:04:23.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:23.959]                     ...future.globalenv.names))
[18:04:23.959]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:23.959]         }, condition = base::local({
[18:04:23.959]             c <- base::c
[18:04:23.959]             inherits <- base::inherits
[18:04:23.959]             invokeRestart <- base::invokeRestart
[18:04:23.959]             length <- base::length
[18:04:23.959]             list <- base::list
[18:04:23.959]             seq.int <- base::seq.int
[18:04:23.959]             signalCondition <- base::signalCondition
[18:04:23.959]             sys.calls <- base::sys.calls
[18:04:23.959]             `[[` <- base::`[[`
[18:04:23.959]             `+` <- base::`+`
[18:04:23.959]             `<<-` <- base::`<<-`
[18:04:23.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:23.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:23.959]                   3L)]
[18:04:23.959]             }
[18:04:23.959]             function(cond) {
[18:04:23.959]                 is_error <- inherits(cond, "error")
[18:04:23.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:23.959]                   NULL)
[18:04:23.959]                 if (is_error) {
[18:04:23.959]                   sessionInformation <- function() {
[18:04:23.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:23.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:23.959]                       search = base::search(), system = base::Sys.info())
[18:04:23.959]                   }
[18:04:23.959]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:23.959]                     cond$call), session = sessionInformation(), 
[18:04:23.959]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:23.959]                   signalCondition(cond)
[18:04:23.959]                 }
[18:04:23.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:23.959]                 "immediateCondition"))) {
[18:04:23.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:23.959]                   ...future.conditions[[length(...future.conditions) + 
[18:04:23.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:23.959]                   if (TRUE && !signal) {
[18:04:23.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.959]                     {
[18:04:23.959]                       inherits <- base::inherits
[18:04:23.959]                       invokeRestart <- base::invokeRestart
[18:04:23.959]                       is.null <- base::is.null
[18:04:23.959]                       muffled <- FALSE
[18:04:23.959]                       if (inherits(cond, "message")) {
[18:04:23.959]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.959]                         if (muffled) 
[18:04:23.959]                           invokeRestart("muffleMessage")
[18:04:23.959]                       }
[18:04:23.959]                       else if (inherits(cond, "warning")) {
[18:04:23.959]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.959]                         if (muffled) 
[18:04:23.959]                           invokeRestart("muffleWarning")
[18:04:23.959]                       }
[18:04:23.959]                       else if (inherits(cond, "condition")) {
[18:04:23.959]                         if (!is.null(pattern)) {
[18:04:23.959]                           computeRestarts <- base::computeRestarts
[18:04:23.959]                           grepl <- base::grepl
[18:04:23.959]                           restarts <- computeRestarts(cond)
[18:04:23.959]                           for (restart in restarts) {
[18:04:23.959]                             name <- restart$name
[18:04:23.959]                             if (is.null(name)) 
[18:04:23.959]                               next
[18:04:23.959]                             if (!grepl(pattern, name)) 
[18:04:23.959]                               next
[18:04:23.959]                             invokeRestart(restart)
[18:04:23.959]                             muffled <- TRUE
[18:04:23.959]                             break
[18:04:23.959]                           }
[18:04:23.959]                         }
[18:04:23.959]                       }
[18:04:23.959]                       invisible(muffled)
[18:04:23.959]                     }
[18:04:23.959]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.959]                   }
[18:04:23.959]                 }
[18:04:23.959]                 else {
[18:04:23.959]                   if (TRUE) {
[18:04:23.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:23.959]                     {
[18:04:23.959]                       inherits <- base::inherits
[18:04:23.959]                       invokeRestart <- base::invokeRestart
[18:04:23.959]                       is.null <- base::is.null
[18:04:23.959]                       muffled <- FALSE
[18:04:23.959]                       if (inherits(cond, "message")) {
[18:04:23.959]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:23.959]                         if (muffled) 
[18:04:23.959]                           invokeRestart("muffleMessage")
[18:04:23.959]                       }
[18:04:23.959]                       else if (inherits(cond, "warning")) {
[18:04:23.959]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:23.959]                         if (muffled) 
[18:04:23.959]                           invokeRestart("muffleWarning")
[18:04:23.959]                       }
[18:04:23.959]                       else if (inherits(cond, "condition")) {
[18:04:23.959]                         if (!is.null(pattern)) {
[18:04:23.959]                           computeRestarts <- base::computeRestarts
[18:04:23.959]                           grepl <- base::grepl
[18:04:23.959]                           restarts <- computeRestarts(cond)
[18:04:23.959]                           for (restart in restarts) {
[18:04:23.959]                             name <- restart$name
[18:04:23.959]                             if (is.null(name)) 
[18:04:23.959]                               next
[18:04:23.959]                             if (!grepl(pattern, name)) 
[18:04:23.959]                               next
[18:04:23.959]                             invokeRestart(restart)
[18:04:23.959]                             muffled <- TRUE
[18:04:23.959]                             break
[18:04:23.959]                           }
[18:04:23.959]                         }
[18:04:23.959]                       }
[18:04:23.959]                       invisible(muffled)
[18:04:23.959]                     }
[18:04:23.959]                     muffleCondition(cond, pattern = "^muffle")
[18:04:23.959]                   }
[18:04:23.959]                 }
[18:04:23.959]             }
[18:04:23.959]         }))
[18:04:23.959]     }, error = function(ex) {
[18:04:23.959]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:23.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:23.959]                 ...future.rng), started = ...future.startTime, 
[18:04:23.959]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:23.959]             version = "1.8"), class = "FutureResult")
[18:04:23.959]     }, finally = {
[18:04:23.959]         if (!identical(...future.workdir, getwd())) 
[18:04:23.959]             setwd(...future.workdir)
[18:04:23.959]         {
[18:04:23.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:23.959]                 ...future.oldOptions$nwarnings <- NULL
[18:04:23.959]             }
[18:04:23.959]             base::options(...future.oldOptions)
[18:04:23.959]             if (.Platform$OS.type == "windows") {
[18:04:23.959]                 old_names <- names(...future.oldEnvVars)
[18:04:23.959]                 envs <- base::Sys.getenv()
[18:04:23.959]                 names <- names(envs)
[18:04:23.959]                 common <- intersect(names, old_names)
[18:04:23.959]                 added <- setdiff(names, old_names)
[18:04:23.959]                 removed <- setdiff(old_names, names)
[18:04:23.959]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:23.959]                   envs[common]]
[18:04:23.959]                 NAMES <- toupper(changed)
[18:04:23.959]                 args <- list()
[18:04:23.959]                 for (kk in seq_along(NAMES)) {
[18:04:23.959]                   name <- changed[[kk]]
[18:04:23.959]                   NAME <- NAMES[[kk]]
[18:04:23.959]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.959]                     next
[18:04:23.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.959]                 }
[18:04:23.959]                 NAMES <- toupper(added)
[18:04:23.959]                 for (kk in seq_along(NAMES)) {
[18:04:23.959]                   name <- added[[kk]]
[18:04:23.959]                   NAME <- NAMES[[kk]]
[18:04:23.959]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.959]                     next
[18:04:23.959]                   args[[name]] <- ""
[18:04:23.959]                 }
[18:04:23.959]                 NAMES <- toupper(removed)
[18:04:23.959]                 for (kk in seq_along(NAMES)) {
[18:04:23.959]                   name <- removed[[kk]]
[18:04:23.959]                   NAME <- NAMES[[kk]]
[18:04:23.959]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:23.959]                     next
[18:04:23.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:23.959]                 }
[18:04:23.959]                 if (length(args) > 0) 
[18:04:23.959]                   base::do.call(base::Sys.setenv, args = args)
[18:04:23.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:23.959]             }
[18:04:23.959]             else {
[18:04:23.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:23.959]             }
[18:04:23.959]             {
[18:04:23.959]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:23.959]                   0L) {
[18:04:23.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:23.959]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:23.959]                   base::options(opts)
[18:04:23.959]                 }
[18:04:23.959]                 {
[18:04:23.959]                   {
[18:04:23.959]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:23.959]                     NULL
[18:04:23.959]                   }
[18:04:23.959]                   options(future.plan = NULL)
[18:04:23.959]                   if (is.na(NA_character_)) 
[18:04:23.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:23.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:23.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:23.959]                     .init = FALSE)
[18:04:23.959]                 }
[18:04:23.959]             }
[18:04:23.959]         }
[18:04:23.959]     })
[18:04:23.959]     if (TRUE) {
[18:04:23.959]         base::sink(type = "output", split = FALSE)
[18:04:23.959]         if (TRUE) {
[18:04:23.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:23.959]         }
[18:04:23.959]         else {
[18:04:23.959]             ...future.result["stdout"] <- base::list(NULL)
[18:04:23.959]         }
[18:04:23.959]         base::close(...future.stdout)
[18:04:23.959]         ...future.stdout <- NULL
[18:04:23.959]     }
[18:04:23.959]     ...future.result$conditions <- ...future.conditions
[18:04:23.959]     ...future.result$finished <- base::Sys.time()
[18:04:23.959]     ...future.result
[18:04:23.959] }
[18:04:23.965] MultisessionFuture started
[18:04:23.966] - Launch lazy future ... done
[18:04:23.966] run() for ‘MultisessionFuture’ ... done
[18:04:23.966] getGlobalsAndPackages() ...
[18:04:23.967] Searching for globals...
[18:04:23.967] 
[18:04:23.967] Searching for globals ... DONE
[18:04:23.968] - globals: [0] <none>
[18:04:23.968] getGlobalsAndPackages() ... DONE
[18:04:23.968] run() for ‘Future’ ...
[18:04:23.968] - state: ‘created’
[18:04:23.969] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:23.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:23.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:23.994]   - Field: ‘node’
[18:04:23.994]   - Field: ‘label’
[18:04:23.994]   - Field: ‘local’
[18:04:23.995]   - Field: ‘owner’
[18:04:23.995]   - Field: ‘envir’
[18:04:23.995]   - Field: ‘workers’
[18:04:23.995]   - Field: ‘packages’
[18:04:23.995]   - Field: ‘gc’
[18:04:23.996]   - Field: ‘conditions’
[18:04:23.996]   - Field: ‘persistent’
[18:04:23.996]   - Field: ‘expr’
[18:04:23.996]   - Field: ‘uuid’
[18:04:23.996]   - Field: ‘seed’
[18:04:23.997]   - Field: ‘version’
[18:04:23.997]   - Field: ‘result’
[18:04:23.997]   - Field: ‘asynchronous’
[18:04:23.997]   - Field: ‘calls’
[18:04:23.997]   - Field: ‘globals’
[18:04:23.998]   - Field: ‘stdout’
[18:04:23.998]   - Field: ‘earlySignal’
[18:04:23.998]   - Field: ‘lazy’
[18:04:23.998]   - Field: ‘state’
[18:04:23.998] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:23.999] - Launch lazy future ...
[18:04:23.999] Packages needed by the future expression (n = 0): <none>
[18:04:23.999] Packages needed by future strategies (n = 0): <none>
[18:04:24.000] {
[18:04:24.000]     {
[18:04:24.000]         {
[18:04:24.000]             ...future.startTime <- base::Sys.time()
[18:04:24.000]             {
[18:04:24.000]                 {
[18:04:24.000]                   {
[18:04:24.000]                     {
[18:04:24.000]                       base::local({
[18:04:24.000]                         has_future <- base::requireNamespace("future", 
[18:04:24.000]                           quietly = TRUE)
[18:04:24.000]                         if (has_future) {
[18:04:24.000]                           ns <- base::getNamespace("future")
[18:04:24.000]                           version <- ns[[".package"]][["version"]]
[18:04:24.000]                           if (is.null(version)) 
[18:04:24.000]                             version <- utils::packageVersion("future")
[18:04:24.000]                         }
[18:04:24.000]                         else {
[18:04:24.000]                           version <- NULL
[18:04:24.000]                         }
[18:04:24.000]                         if (!has_future || version < "1.8.0") {
[18:04:24.000]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:24.000]                             "", base::R.version$version.string), 
[18:04:24.000]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:24.000]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:24.000]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:24.000]                               "release", "version")], collapse = " "), 
[18:04:24.000]                             hostname = base::Sys.info()[["nodename"]])
[18:04:24.000]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:24.000]                             info)
[18:04:24.000]                           info <- base::paste(info, collapse = "; ")
[18:04:24.000]                           if (!has_future) {
[18:04:24.000]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:24.000]                               info)
[18:04:24.000]                           }
[18:04:24.000]                           else {
[18:04:24.000]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:24.000]                               info, version)
[18:04:24.000]                           }
[18:04:24.000]                           base::stop(msg)
[18:04:24.000]                         }
[18:04:24.000]                       })
[18:04:24.000]                     }
[18:04:24.000]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:24.000]                     base::options(mc.cores = 1L)
[18:04:24.000]                   }
[18:04:24.000]                   ...future.strategy.old <- future::plan("list")
[18:04:24.000]                   options(future.plan = NULL)
[18:04:24.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:24.000]                 }
[18:04:24.000]                 ...future.workdir <- getwd()
[18:04:24.000]             }
[18:04:24.000]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:24.000]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:24.000]         }
[18:04:24.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:24.000]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:24.000]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:24.000]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:24.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:24.000]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:24.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:24.000]             base::names(...future.oldOptions))
[18:04:24.000]     }
[18:04:24.000]     if (FALSE) {
[18:04:24.000]     }
[18:04:24.000]     else {
[18:04:24.000]         if (TRUE) {
[18:04:24.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:24.000]                 open = "w")
[18:04:24.000]         }
[18:04:24.000]         else {
[18:04:24.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:24.000]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:24.000]         }
[18:04:24.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:24.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:24.000]             base::sink(type = "output", split = FALSE)
[18:04:24.000]             base::close(...future.stdout)
[18:04:24.000]         }, add = TRUE)
[18:04:24.000]     }
[18:04:24.000]     ...future.frame <- base::sys.nframe()
[18:04:24.000]     ...future.conditions <- base::list()
[18:04:24.000]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:24.000]     if (FALSE) {
[18:04:24.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:24.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:24.000]     }
[18:04:24.000]     ...future.result <- base::tryCatch({
[18:04:24.000]         base::withCallingHandlers({
[18:04:24.000]             ...future.value <- base::withVisible(base::local({
[18:04:24.000]                 ...future.makeSendCondition <- base::local({
[18:04:24.000]                   sendCondition <- NULL
[18:04:24.000]                   function(frame = 1L) {
[18:04:24.000]                     if (is.function(sendCondition)) 
[18:04:24.000]                       return(sendCondition)
[18:04:24.000]                     ns <- getNamespace("parallel")
[18:04:24.000]                     if (exists("sendData", mode = "function", 
[18:04:24.000]                       envir = ns)) {
[18:04:24.000]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:24.000]                         envir = ns)
[18:04:24.000]                       envir <- sys.frame(frame)
[18:04:24.000]                       master <- NULL
[18:04:24.000]                       while (!identical(envir, .GlobalEnv) && 
[18:04:24.000]                         !identical(envir, emptyenv())) {
[18:04:24.000]                         if (exists("master", mode = "list", envir = envir, 
[18:04:24.000]                           inherits = FALSE)) {
[18:04:24.000]                           master <- get("master", mode = "list", 
[18:04:24.000]                             envir = envir, inherits = FALSE)
[18:04:24.000]                           if (inherits(master, c("SOCKnode", 
[18:04:24.000]                             "SOCK0node"))) {
[18:04:24.000]                             sendCondition <<- function(cond) {
[18:04:24.000]                               data <- list(type = "VALUE", value = cond, 
[18:04:24.000]                                 success = TRUE)
[18:04:24.000]                               parallel_sendData(master, data)
[18:04:24.000]                             }
[18:04:24.000]                             return(sendCondition)
[18:04:24.000]                           }
[18:04:24.000]                         }
[18:04:24.000]                         frame <- frame + 1L
[18:04:24.000]                         envir <- sys.frame(frame)
[18:04:24.000]                       }
[18:04:24.000]                     }
[18:04:24.000]                     sendCondition <<- function(cond) NULL
[18:04:24.000]                   }
[18:04:24.000]                 })
[18:04:24.000]                 withCallingHandlers({
[18:04:24.000]                   NULL
[18:04:24.000]                 }, immediateCondition = function(cond) {
[18:04:24.000]                   sendCondition <- ...future.makeSendCondition()
[18:04:24.000]                   sendCondition(cond)
[18:04:24.000]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.000]                   {
[18:04:24.000]                     inherits <- base::inherits
[18:04:24.000]                     invokeRestart <- base::invokeRestart
[18:04:24.000]                     is.null <- base::is.null
[18:04:24.000]                     muffled <- FALSE
[18:04:24.000]                     if (inherits(cond, "message")) {
[18:04:24.000]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:24.000]                       if (muffled) 
[18:04:24.000]                         invokeRestart("muffleMessage")
[18:04:24.000]                     }
[18:04:24.000]                     else if (inherits(cond, "warning")) {
[18:04:24.000]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:24.000]                       if (muffled) 
[18:04:24.000]                         invokeRestart("muffleWarning")
[18:04:24.000]                     }
[18:04:24.000]                     else if (inherits(cond, "condition")) {
[18:04:24.000]                       if (!is.null(pattern)) {
[18:04:24.000]                         computeRestarts <- base::computeRestarts
[18:04:24.000]                         grepl <- base::grepl
[18:04:24.000]                         restarts <- computeRestarts(cond)
[18:04:24.000]                         for (restart in restarts) {
[18:04:24.000]                           name <- restart$name
[18:04:24.000]                           if (is.null(name)) 
[18:04:24.000]                             next
[18:04:24.000]                           if (!grepl(pattern, name)) 
[18:04:24.000]                             next
[18:04:24.000]                           invokeRestart(restart)
[18:04:24.000]                           muffled <- TRUE
[18:04:24.000]                           break
[18:04:24.000]                         }
[18:04:24.000]                       }
[18:04:24.000]                     }
[18:04:24.000]                     invisible(muffled)
[18:04:24.000]                   }
[18:04:24.000]                   muffleCondition(cond)
[18:04:24.000]                 })
[18:04:24.000]             }))
[18:04:24.000]             future::FutureResult(value = ...future.value$value, 
[18:04:24.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.000]                   ...future.rng), globalenv = if (FALSE) 
[18:04:24.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:24.000]                     ...future.globalenv.names))
[18:04:24.000]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:24.000]         }, condition = base::local({
[18:04:24.000]             c <- base::c
[18:04:24.000]             inherits <- base::inherits
[18:04:24.000]             invokeRestart <- base::invokeRestart
[18:04:24.000]             length <- base::length
[18:04:24.000]             list <- base::list
[18:04:24.000]             seq.int <- base::seq.int
[18:04:24.000]             signalCondition <- base::signalCondition
[18:04:24.000]             sys.calls <- base::sys.calls
[18:04:24.000]             `[[` <- base::`[[`
[18:04:24.000]             `+` <- base::`+`
[18:04:24.000]             `<<-` <- base::`<<-`
[18:04:24.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:24.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:24.000]                   3L)]
[18:04:24.000]             }
[18:04:24.000]             function(cond) {
[18:04:24.000]                 is_error <- inherits(cond, "error")
[18:04:24.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:24.000]                   NULL)
[18:04:24.000]                 if (is_error) {
[18:04:24.000]                   sessionInformation <- function() {
[18:04:24.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:24.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:24.000]                       search = base::search(), system = base::Sys.info())
[18:04:24.000]                   }
[18:04:24.000]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:24.000]                     cond$call), session = sessionInformation(), 
[18:04:24.000]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:24.000]                   signalCondition(cond)
[18:04:24.000]                 }
[18:04:24.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:24.000]                 "immediateCondition"))) {
[18:04:24.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:24.000]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:24.000]                   if (TRUE && !signal) {
[18:04:24.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.000]                     {
[18:04:24.000]                       inherits <- base::inherits
[18:04:24.000]                       invokeRestart <- base::invokeRestart
[18:04:24.000]                       is.null <- base::is.null
[18:04:24.000]                       muffled <- FALSE
[18:04:24.000]                       if (inherits(cond, "message")) {
[18:04:24.000]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.000]                         if (muffled) 
[18:04:24.000]                           invokeRestart("muffleMessage")
[18:04:24.000]                       }
[18:04:24.000]                       else if (inherits(cond, "warning")) {
[18:04:24.000]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.000]                         if (muffled) 
[18:04:24.000]                           invokeRestart("muffleWarning")
[18:04:24.000]                       }
[18:04:24.000]                       else if (inherits(cond, "condition")) {
[18:04:24.000]                         if (!is.null(pattern)) {
[18:04:24.000]                           computeRestarts <- base::computeRestarts
[18:04:24.000]                           grepl <- base::grepl
[18:04:24.000]                           restarts <- computeRestarts(cond)
[18:04:24.000]                           for (restart in restarts) {
[18:04:24.000]                             name <- restart$name
[18:04:24.000]                             if (is.null(name)) 
[18:04:24.000]                               next
[18:04:24.000]                             if (!grepl(pattern, name)) 
[18:04:24.000]                               next
[18:04:24.000]                             invokeRestart(restart)
[18:04:24.000]                             muffled <- TRUE
[18:04:24.000]                             break
[18:04:24.000]                           }
[18:04:24.000]                         }
[18:04:24.000]                       }
[18:04:24.000]                       invisible(muffled)
[18:04:24.000]                     }
[18:04:24.000]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.000]                   }
[18:04:24.000]                 }
[18:04:24.000]                 else {
[18:04:24.000]                   if (TRUE) {
[18:04:24.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.000]                     {
[18:04:24.000]                       inherits <- base::inherits
[18:04:24.000]                       invokeRestart <- base::invokeRestart
[18:04:24.000]                       is.null <- base::is.null
[18:04:24.000]                       muffled <- FALSE
[18:04:24.000]                       if (inherits(cond, "message")) {
[18:04:24.000]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.000]                         if (muffled) 
[18:04:24.000]                           invokeRestart("muffleMessage")
[18:04:24.000]                       }
[18:04:24.000]                       else if (inherits(cond, "warning")) {
[18:04:24.000]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.000]                         if (muffled) 
[18:04:24.000]                           invokeRestart("muffleWarning")
[18:04:24.000]                       }
[18:04:24.000]                       else if (inherits(cond, "condition")) {
[18:04:24.000]                         if (!is.null(pattern)) {
[18:04:24.000]                           computeRestarts <- base::computeRestarts
[18:04:24.000]                           grepl <- base::grepl
[18:04:24.000]                           restarts <- computeRestarts(cond)
[18:04:24.000]                           for (restart in restarts) {
[18:04:24.000]                             name <- restart$name
[18:04:24.000]                             if (is.null(name)) 
[18:04:24.000]                               next
[18:04:24.000]                             if (!grepl(pattern, name)) 
[18:04:24.000]                               next
[18:04:24.000]                             invokeRestart(restart)
[18:04:24.000]                             muffled <- TRUE
[18:04:24.000]                             break
[18:04:24.000]                           }
[18:04:24.000]                         }
[18:04:24.000]                       }
[18:04:24.000]                       invisible(muffled)
[18:04:24.000]                     }
[18:04:24.000]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.000]                   }
[18:04:24.000]                 }
[18:04:24.000]             }
[18:04:24.000]         }))
[18:04:24.000]     }, error = function(ex) {
[18:04:24.000]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:24.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.000]                 ...future.rng), started = ...future.startTime, 
[18:04:24.000]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:24.000]             version = "1.8"), class = "FutureResult")
[18:04:24.000]     }, finally = {
[18:04:24.000]         if (!identical(...future.workdir, getwd())) 
[18:04:24.000]             setwd(...future.workdir)
[18:04:24.000]         {
[18:04:24.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:24.000]                 ...future.oldOptions$nwarnings <- NULL
[18:04:24.000]             }
[18:04:24.000]             base::options(...future.oldOptions)
[18:04:24.000]             if (.Platform$OS.type == "windows") {
[18:04:24.000]                 old_names <- names(...future.oldEnvVars)
[18:04:24.000]                 envs <- base::Sys.getenv()
[18:04:24.000]                 names <- names(envs)
[18:04:24.000]                 common <- intersect(names, old_names)
[18:04:24.000]                 added <- setdiff(names, old_names)
[18:04:24.000]                 removed <- setdiff(old_names, names)
[18:04:24.000]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:24.000]                   envs[common]]
[18:04:24.000]                 NAMES <- toupper(changed)
[18:04:24.000]                 args <- list()
[18:04:24.000]                 for (kk in seq_along(NAMES)) {
[18:04:24.000]                   name <- changed[[kk]]
[18:04:24.000]                   NAME <- NAMES[[kk]]
[18:04:24.000]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.000]                     next
[18:04:24.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.000]                 }
[18:04:24.000]                 NAMES <- toupper(added)
[18:04:24.000]                 for (kk in seq_along(NAMES)) {
[18:04:24.000]                   name <- added[[kk]]
[18:04:24.000]                   NAME <- NAMES[[kk]]
[18:04:24.000]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.000]                     next
[18:04:24.000]                   args[[name]] <- ""
[18:04:24.000]                 }
[18:04:24.000]                 NAMES <- toupper(removed)
[18:04:24.000]                 for (kk in seq_along(NAMES)) {
[18:04:24.000]                   name <- removed[[kk]]
[18:04:24.000]                   NAME <- NAMES[[kk]]
[18:04:24.000]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.000]                     next
[18:04:24.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.000]                 }
[18:04:24.000]                 if (length(args) > 0) 
[18:04:24.000]                   base::do.call(base::Sys.setenv, args = args)
[18:04:24.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:24.000]             }
[18:04:24.000]             else {
[18:04:24.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:24.000]             }
[18:04:24.000]             {
[18:04:24.000]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:24.000]                   0L) {
[18:04:24.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:24.000]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:24.000]                   base::options(opts)
[18:04:24.000]                 }
[18:04:24.000]                 {
[18:04:24.000]                   {
[18:04:24.000]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:24.000]                     NULL
[18:04:24.000]                   }
[18:04:24.000]                   options(future.plan = NULL)
[18:04:24.000]                   if (is.na(NA_character_)) 
[18:04:24.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:24.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:24.000]                     .init = FALSE)
[18:04:24.000]                 }
[18:04:24.000]             }
[18:04:24.000]         }
[18:04:24.000]     })
[18:04:24.000]     if (TRUE) {
[18:04:24.000]         base::sink(type = "output", split = FALSE)
[18:04:24.000]         if (TRUE) {
[18:04:24.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:24.000]         }
[18:04:24.000]         else {
[18:04:24.000]             ...future.result["stdout"] <- base::list(NULL)
[18:04:24.000]         }
[18:04:24.000]         base::close(...future.stdout)
[18:04:24.000]         ...future.stdout <- NULL
[18:04:24.000]     }
[18:04:24.000]     ...future.result$conditions <- ...future.conditions
[18:04:24.000]     ...future.result$finished <- base::Sys.time()
[18:04:24.000]     ...future.result
[18:04:24.000] }
[18:04:24.006] MultisessionFuture started
[18:04:24.006] - Launch lazy future ... done
[18:04:24.007] run() for ‘MultisessionFuture’ ... done
[18:04:24.008] getGlobalsAndPackages() ...
[18:04:24.008] Searching for globals...
[18:04:24.009] - globals found: [1] ‘{’
[18:04:24.010] Searching for globals ... DONE
[18:04:24.010] Resolving globals: FALSE
[18:04:24.010] 
[18:04:24.011] 
[18:04:24.011] getGlobalsAndPackages() ... DONE
[18:04:24.011] run() for ‘Future’ ...
[18:04:24.011] - state: ‘created’
[18:04:24.012] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:24.037] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:24.037] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:24.037]   - Field: ‘node’
[18:04:24.037]   - Field: ‘label’
[18:04:24.038]   - Field: ‘local’
[18:04:24.038]   - Field: ‘owner’
[18:04:24.038]   - Field: ‘envir’
[18:04:24.038]   - Field: ‘workers’
[18:04:24.038]   - Field: ‘packages’
[18:04:24.039]   - Field: ‘gc’
[18:04:24.039]   - Field: ‘conditions’
[18:04:24.039]   - Field: ‘persistent’
[18:04:24.039]   - Field: ‘expr’
[18:04:24.039]   - Field: ‘uuid’
[18:04:24.040]   - Field: ‘seed’
[18:04:24.040]   - Field: ‘version’
[18:04:24.040]   - Field: ‘result’
[18:04:24.040]   - Field: ‘asynchronous’
[18:04:24.040]   - Field: ‘calls’
[18:04:24.041]   - Field: ‘globals’
[18:04:24.041]   - Field: ‘stdout’
[18:04:24.041]   - Field: ‘earlySignal’
[18:04:24.041]   - Field: ‘lazy’
[18:04:24.041]   - Field: ‘state’
[18:04:24.041] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:24.042] - Launch lazy future ...
[18:04:24.042] Packages needed by the future expression (n = 0): <none>
[18:04:24.042] Packages needed by future strategies (n = 0): <none>
[18:04:24.043] {
[18:04:24.043]     {
[18:04:24.043]         {
[18:04:24.043]             ...future.startTime <- base::Sys.time()
[18:04:24.043]             {
[18:04:24.043]                 {
[18:04:24.043]                   {
[18:04:24.043]                     {
[18:04:24.043]                       base::local({
[18:04:24.043]                         has_future <- base::requireNamespace("future", 
[18:04:24.043]                           quietly = TRUE)
[18:04:24.043]                         if (has_future) {
[18:04:24.043]                           ns <- base::getNamespace("future")
[18:04:24.043]                           version <- ns[[".package"]][["version"]]
[18:04:24.043]                           if (is.null(version)) 
[18:04:24.043]                             version <- utils::packageVersion("future")
[18:04:24.043]                         }
[18:04:24.043]                         else {
[18:04:24.043]                           version <- NULL
[18:04:24.043]                         }
[18:04:24.043]                         if (!has_future || version < "1.8.0") {
[18:04:24.043]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:24.043]                             "", base::R.version$version.string), 
[18:04:24.043]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:24.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:24.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:24.043]                               "release", "version")], collapse = " "), 
[18:04:24.043]                             hostname = base::Sys.info()[["nodename"]])
[18:04:24.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:24.043]                             info)
[18:04:24.043]                           info <- base::paste(info, collapse = "; ")
[18:04:24.043]                           if (!has_future) {
[18:04:24.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:24.043]                               info)
[18:04:24.043]                           }
[18:04:24.043]                           else {
[18:04:24.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:24.043]                               info, version)
[18:04:24.043]                           }
[18:04:24.043]                           base::stop(msg)
[18:04:24.043]                         }
[18:04:24.043]                       })
[18:04:24.043]                     }
[18:04:24.043]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:24.043]                     base::options(mc.cores = 1L)
[18:04:24.043]                   }
[18:04:24.043]                   ...future.strategy.old <- future::plan("list")
[18:04:24.043]                   options(future.plan = NULL)
[18:04:24.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:24.043]                 }
[18:04:24.043]                 ...future.workdir <- getwd()
[18:04:24.043]             }
[18:04:24.043]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:24.043]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:24.043]         }
[18:04:24.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:24.043]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:24.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:24.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:24.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:24.043]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:24.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:24.043]             base::names(...future.oldOptions))
[18:04:24.043]     }
[18:04:24.043]     if (FALSE) {
[18:04:24.043]     }
[18:04:24.043]     else {
[18:04:24.043]         if (TRUE) {
[18:04:24.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:24.043]                 open = "w")
[18:04:24.043]         }
[18:04:24.043]         else {
[18:04:24.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:24.043]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:24.043]         }
[18:04:24.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:24.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:24.043]             base::sink(type = "output", split = FALSE)
[18:04:24.043]             base::close(...future.stdout)
[18:04:24.043]         }, add = TRUE)
[18:04:24.043]     }
[18:04:24.043]     ...future.frame <- base::sys.nframe()
[18:04:24.043]     ...future.conditions <- base::list()
[18:04:24.043]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:24.043]     if (FALSE) {
[18:04:24.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:24.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:24.043]     }
[18:04:24.043]     ...future.result <- base::tryCatch({
[18:04:24.043]         base::withCallingHandlers({
[18:04:24.043]             ...future.value <- base::withVisible(base::local({
[18:04:24.043]                 ...future.makeSendCondition <- base::local({
[18:04:24.043]                   sendCondition <- NULL
[18:04:24.043]                   function(frame = 1L) {
[18:04:24.043]                     if (is.function(sendCondition)) 
[18:04:24.043]                       return(sendCondition)
[18:04:24.043]                     ns <- getNamespace("parallel")
[18:04:24.043]                     if (exists("sendData", mode = "function", 
[18:04:24.043]                       envir = ns)) {
[18:04:24.043]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:24.043]                         envir = ns)
[18:04:24.043]                       envir <- sys.frame(frame)
[18:04:24.043]                       master <- NULL
[18:04:24.043]                       while (!identical(envir, .GlobalEnv) && 
[18:04:24.043]                         !identical(envir, emptyenv())) {
[18:04:24.043]                         if (exists("master", mode = "list", envir = envir, 
[18:04:24.043]                           inherits = FALSE)) {
[18:04:24.043]                           master <- get("master", mode = "list", 
[18:04:24.043]                             envir = envir, inherits = FALSE)
[18:04:24.043]                           if (inherits(master, c("SOCKnode", 
[18:04:24.043]                             "SOCK0node"))) {
[18:04:24.043]                             sendCondition <<- function(cond) {
[18:04:24.043]                               data <- list(type = "VALUE", value = cond, 
[18:04:24.043]                                 success = TRUE)
[18:04:24.043]                               parallel_sendData(master, data)
[18:04:24.043]                             }
[18:04:24.043]                             return(sendCondition)
[18:04:24.043]                           }
[18:04:24.043]                         }
[18:04:24.043]                         frame <- frame + 1L
[18:04:24.043]                         envir <- sys.frame(frame)
[18:04:24.043]                       }
[18:04:24.043]                     }
[18:04:24.043]                     sendCondition <<- function(cond) NULL
[18:04:24.043]                   }
[18:04:24.043]                 })
[18:04:24.043]                 withCallingHandlers({
[18:04:24.043]                   {
[18:04:24.043]                     4
[18:04:24.043]                   }
[18:04:24.043]                 }, immediateCondition = function(cond) {
[18:04:24.043]                   sendCondition <- ...future.makeSendCondition()
[18:04:24.043]                   sendCondition(cond)
[18:04:24.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.043]                   {
[18:04:24.043]                     inherits <- base::inherits
[18:04:24.043]                     invokeRestart <- base::invokeRestart
[18:04:24.043]                     is.null <- base::is.null
[18:04:24.043]                     muffled <- FALSE
[18:04:24.043]                     if (inherits(cond, "message")) {
[18:04:24.043]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:24.043]                       if (muffled) 
[18:04:24.043]                         invokeRestart("muffleMessage")
[18:04:24.043]                     }
[18:04:24.043]                     else if (inherits(cond, "warning")) {
[18:04:24.043]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:24.043]                       if (muffled) 
[18:04:24.043]                         invokeRestart("muffleWarning")
[18:04:24.043]                     }
[18:04:24.043]                     else if (inherits(cond, "condition")) {
[18:04:24.043]                       if (!is.null(pattern)) {
[18:04:24.043]                         computeRestarts <- base::computeRestarts
[18:04:24.043]                         grepl <- base::grepl
[18:04:24.043]                         restarts <- computeRestarts(cond)
[18:04:24.043]                         for (restart in restarts) {
[18:04:24.043]                           name <- restart$name
[18:04:24.043]                           if (is.null(name)) 
[18:04:24.043]                             next
[18:04:24.043]                           if (!grepl(pattern, name)) 
[18:04:24.043]                             next
[18:04:24.043]                           invokeRestart(restart)
[18:04:24.043]                           muffled <- TRUE
[18:04:24.043]                           break
[18:04:24.043]                         }
[18:04:24.043]                       }
[18:04:24.043]                     }
[18:04:24.043]                     invisible(muffled)
[18:04:24.043]                   }
[18:04:24.043]                   muffleCondition(cond)
[18:04:24.043]                 })
[18:04:24.043]             }))
[18:04:24.043]             future::FutureResult(value = ...future.value$value, 
[18:04:24.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.043]                   ...future.rng), globalenv = if (FALSE) 
[18:04:24.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:24.043]                     ...future.globalenv.names))
[18:04:24.043]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:24.043]         }, condition = base::local({
[18:04:24.043]             c <- base::c
[18:04:24.043]             inherits <- base::inherits
[18:04:24.043]             invokeRestart <- base::invokeRestart
[18:04:24.043]             length <- base::length
[18:04:24.043]             list <- base::list
[18:04:24.043]             seq.int <- base::seq.int
[18:04:24.043]             signalCondition <- base::signalCondition
[18:04:24.043]             sys.calls <- base::sys.calls
[18:04:24.043]             `[[` <- base::`[[`
[18:04:24.043]             `+` <- base::`+`
[18:04:24.043]             `<<-` <- base::`<<-`
[18:04:24.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:24.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:24.043]                   3L)]
[18:04:24.043]             }
[18:04:24.043]             function(cond) {
[18:04:24.043]                 is_error <- inherits(cond, "error")
[18:04:24.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:24.043]                   NULL)
[18:04:24.043]                 if (is_error) {
[18:04:24.043]                   sessionInformation <- function() {
[18:04:24.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:24.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:24.043]                       search = base::search(), system = base::Sys.info())
[18:04:24.043]                   }
[18:04:24.043]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:24.043]                     cond$call), session = sessionInformation(), 
[18:04:24.043]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:24.043]                   signalCondition(cond)
[18:04:24.043]                 }
[18:04:24.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:24.043]                 "immediateCondition"))) {
[18:04:24.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:24.043]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:24.043]                   if (TRUE && !signal) {
[18:04:24.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.043]                     {
[18:04:24.043]                       inherits <- base::inherits
[18:04:24.043]                       invokeRestart <- base::invokeRestart
[18:04:24.043]                       is.null <- base::is.null
[18:04:24.043]                       muffled <- FALSE
[18:04:24.043]                       if (inherits(cond, "message")) {
[18:04:24.043]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.043]                         if (muffled) 
[18:04:24.043]                           invokeRestart("muffleMessage")
[18:04:24.043]                       }
[18:04:24.043]                       else if (inherits(cond, "warning")) {
[18:04:24.043]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.043]                         if (muffled) 
[18:04:24.043]                           invokeRestart("muffleWarning")
[18:04:24.043]                       }
[18:04:24.043]                       else if (inherits(cond, "condition")) {
[18:04:24.043]                         if (!is.null(pattern)) {
[18:04:24.043]                           computeRestarts <- base::computeRestarts
[18:04:24.043]                           grepl <- base::grepl
[18:04:24.043]                           restarts <- computeRestarts(cond)
[18:04:24.043]                           for (restart in restarts) {
[18:04:24.043]                             name <- restart$name
[18:04:24.043]                             if (is.null(name)) 
[18:04:24.043]                               next
[18:04:24.043]                             if (!grepl(pattern, name)) 
[18:04:24.043]                               next
[18:04:24.043]                             invokeRestart(restart)
[18:04:24.043]                             muffled <- TRUE
[18:04:24.043]                             break
[18:04:24.043]                           }
[18:04:24.043]                         }
[18:04:24.043]                       }
[18:04:24.043]                       invisible(muffled)
[18:04:24.043]                     }
[18:04:24.043]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.043]                   }
[18:04:24.043]                 }
[18:04:24.043]                 else {
[18:04:24.043]                   if (TRUE) {
[18:04:24.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.043]                     {
[18:04:24.043]                       inherits <- base::inherits
[18:04:24.043]                       invokeRestart <- base::invokeRestart
[18:04:24.043]                       is.null <- base::is.null
[18:04:24.043]                       muffled <- FALSE
[18:04:24.043]                       if (inherits(cond, "message")) {
[18:04:24.043]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.043]                         if (muffled) 
[18:04:24.043]                           invokeRestart("muffleMessage")
[18:04:24.043]                       }
[18:04:24.043]                       else if (inherits(cond, "warning")) {
[18:04:24.043]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.043]                         if (muffled) 
[18:04:24.043]                           invokeRestart("muffleWarning")
[18:04:24.043]                       }
[18:04:24.043]                       else if (inherits(cond, "condition")) {
[18:04:24.043]                         if (!is.null(pattern)) {
[18:04:24.043]                           computeRestarts <- base::computeRestarts
[18:04:24.043]                           grepl <- base::grepl
[18:04:24.043]                           restarts <- computeRestarts(cond)
[18:04:24.043]                           for (restart in restarts) {
[18:04:24.043]                             name <- restart$name
[18:04:24.043]                             if (is.null(name)) 
[18:04:24.043]                               next
[18:04:24.043]                             if (!grepl(pattern, name)) 
[18:04:24.043]                               next
[18:04:24.043]                             invokeRestart(restart)
[18:04:24.043]                             muffled <- TRUE
[18:04:24.043]                             break
[18:04:24.043]                           }
[18:04:24.043]                         }
[18:04:24.043]                       }
[18:04:24.043]                       invisible(muffled)
[18:04:24.043]                     }
[18:04:24.043]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.043]                   }
[18:04:24.043]                 }
[18:04:24.043]             }
[18:04:24.043]         }))
[18:04:24.043]     }, error = function(ex) {
[18:04:24.043]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:24.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.043]                 ...future.rng), started = ...future.startTime, 
[18:04:24.043]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:24.043]             version = "1.8"), class = "FutureResult")
[18:04:24.043]     }, finally = {
[18:04:24.043]         if (!identical(...future.workdir, getwd())) 
[18:04:24.043]             setwd(...future.workdir)
[18:04:24.043]         {
[18:04:24.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:24.043]                 ...future.oldOptions$nwarnings <- NULL
[18:04:24.043]             }
[18:04:24.043]             base::options(...future.oldOptions)
[18:04:24.043]             if (.Platform$OS.type == "windows") {
[18:04:24.043]                 old_names <- names(...future.oldEnvVars)
[18:04:24.043]                 envs <- base::Sys.getenv()
[18:04:24.043]                 names <- names(envs)
[18:04:24.043]                 common <- intersect(names, old_names)
[18:04:24.043]                 added <- setdiff(names, old_names)
[18:04:24.043]                 removed <- setdiff(old_names, names)
[18:04:24.043]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:24.043]                   envs[common]]
[18:04:24.043]                 NAMES <- toupper(changed)
[18:04:24.043]                 args <- list()
[18:04:24.043]                 for (kk in seq_along(NAMES)) {
[18:04:24.043]                   name <- changed[[kk]]
[18:04:24.043]                   NAME <- NAMES[[kk]]
[18:04:24.043]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.043]                     next
[18:04:24.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.043]                 }
[18:04:24.043]                 NAMES <- toupper(added)
[18:04:24.043]                 for (kk in seq_along(NAMES)) {
[18:04:24.043]                   name <- added[[kk]]
[18:04:24.043]                   NAME <- NAMES[[kk]]
[18:04:24.043]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.043]                     next
[18:04:24.043]                   args[[name]] <- ""
[18:04:24.043]                 }
[18:04:24.043]                 NAMES <- toupper(removed)
[18:04:24.043]                 for (kk in seq_along(NAMES)) {
[18:04:24.043]                   name <- removed[[kk]]
[18:04:24.043]                   NAME <- NAMES[[kk]]
[18:04:24.043]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.043]                     next
[18:04:24.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.043]                 }
[18:04:24.043]                 if (length(args) > 0) 
[18:04:24.043]                   base::do.call(base::Sys.setenv, args = args)
[18:04:24.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:24.043]             }
[18:04:24.043]             else {
[18:04:24.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:24.043]             }
[18:04:24.043]             {
[18:04:24.043]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:24.043]                   0L) {
[18:04:24.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:24.043]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:24.043]                   base::options(opts)
[18:04:24.043]                 }
[18:04:24.043]                 {
[18:04:24.043]                   {
[18:04:24.043]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:24.043]                     NULL
[18:04:24.043]                   }
[18:04:24.043]                   options(future.plan = NULL)
[18:04:24.043]                   if (is.na(NA_character_)) 
[18:04:24.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:24.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:24.043]                     .init = FALSE)
[18:04:24.043]                 }
[18:04:24.043]             }
[18:04:24.043]         }
[18:04:24.043]     })
[18:04:24.043]     if (TRUE) {
[18:04:24.043]         base::sink(type = "output", split = FALSE)
[18:04:24.043]         if (TRUE) {
[18:04:24.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:24.043]         }
[18:04:24.043]         else {
[18:04:24.043]             ...future.result["stdout"] <- base::list(NULL)
[18:04:24.043]         }
[18:04:24.043]         base::close(...future.stdout)
[18:04:24.043]         ...future.stdout <- NULL
[18:04:24.043]     }
[18:04:24.043]     ...future.result$conditions <- ...future.conditions
[18:04:24.043]     ...future.result$finished <- base::Sys.time()
[18:04:24.043]     ...future.result
[18:04:24.043] }
[18:04:24.047] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:24.059] receiveMessageFromWorker() for ClusterFuture ...
[18:04:24.059] - Validating connection of MultisessionFuture
[18:04:24.060] - received message: FutureResult
[18:04:24.060] - Received FutureResult
[18:04:24.060] - Erased future from FutureRegistry
[18:04:24.060] result() for ClusterFuture ...
[18:04:24.060] - result already collected: FutureResult
[18:04:24.061] result() for ClusterFuture ... done
[18:04:24.061] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:24.061] result() for ClusterFuture ...
[18:04:24.061] - result already collected: FutureResult
[18:04:24.062] result() for ClusterFuture ... done
[18:04:24.062] result() for ClusterFuture ...
[18:04:24.062] - result already collected: FutureResult
[18:04:24.062] result() for ClusterFuture ... done
[18:04:24.064] MultisessionFuture started
[18:04:24.065] - Launch lazy future ... done
[18:04:24.065] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2ac35940> 
Classes 'listenv', 'environment' <environment: 0x5e3c2c9c8888> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[18:04:24.075] receiveMessageFromWorker() for ClusterFuture ...
[18:04:24.075] - Validating connection of MultisessionFuture
[18:04:24.075] - received message: FutureResult
[18:04:24.076] - Received FutureResult
[18:04:24.076] - Erased future from FutureRegistry
[18:04:24.076] result() for ClusterFuture ...
[18:04:24.076] - result already collected: FutureResult
[18:04:24.077] result() for ClusterFuture ... done
[18:04:24.077] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:24.093] resolve() on list environment ...
[18:04:24.093]  recursive: 0
[18:04:24.095]  length: 6
[18:04:24.096]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:24.096] signalConditionsASAP(numeric, pos=1) ...
[18:04:24.096] - nx: 6
[18:04:24.096] - relay: TRUE
[18:04:24.096] - stdout: TRUE
[18:04:24.097] - signal: TRUE
[18:04:24.097] - resignal: FALSE
[18:04:24.097] - force: TRUE
[18:04:24.097] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.097] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.098]  - until=2
[18:04:24.098]  - relaying element #2
[18:04:24.098] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.098] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.098] signalConditionsASAP(NULL, pos=1) ... done
[18:04:24.099]  length: 5 (resolved future 1)
[18:04:24.099] Future #2
[18:04:24.099] result() for ClusterFuture ...
[18:04:24.099] - result already collected: FutureResult
[18:04:24.099] result() for ClusterFuture ... done
[18:04:24.100] result() for ClusterFuture ...
[18:04:24.100] - result already collected: FutureResult
[18:04:24.100] result() for ClusterFuture ... done
[18:04:24.100] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:24.100] - nx: 6
[18:04:24.100] - relay: TRUE
[18:04:24.101] - stdout: TRUE
[18:04:24.101] - signal: TRUE
[18:04:24.101] - resignal: FALSE
[18:04:24.101] - force: TRUE
[18:04:24.101] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.102] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.102]  - until=2
[18:04:24.102]  - relaying element #2
[18:04:24.102] result() for ClusterFuture ...
[18:04:24.102] - result already collected: FutureResult
[18:04:24.102] result() for ClusterFuture ... done
[18:04:24.103] result() for ClusterFuture ...
[18:04:24.103] - result already collected: FutureResult
[18:04:24.103] result() for ClusterFuture ... done
[18:04:24.103] result() for ClusterFuture ...
[18:04:24.103] - result already collected: FutureResult
[18:04:24.104] result() for ClusterFuture ... done
[18:04:24.104] result() for ClusterFuture ...
[18:04:24.104] - result already collected: FutureResult
[18:04:24.104] result() for ClusterFuture ... done
[18:04:24.104] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:24.104] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:24.105] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:24.105]  length: 4 (resolved future 2)
[18:04:24.105] Future #3
[18:04:24.105] result() for ClusterFuture ...
[18:04:24.106] - result already collected: FutureResult
[18:04:24.106] result() for ClusterFuture ... done
[18:04:24.106] result() for ClusterFuture ...
[18:04:24.106] - result already collected: FutureResult
[18:04:24.106] result() for ClusterFuture ... done
[18:04:24.107] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:24.107] - nx: 6
[18:04:24.107] - relay: TRUE
[18:04:24.107] - stdout: TRUE
[18:04:24.107] - signal: TRUE
[18:04:24.108] - resignal: FALSE
[18:04:24.108] - force: TRUE
[18:04:24.108] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:24.108] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:24.108]  - until=3
[18:04:24.108]  - relaying element #3
[18:04:24.109] result() for ClusterFuture ...
[18:04:24.109] - result already collected: FutureResult
[18:04:24.109] result() for ClusterFuture ... done
[18:04:24.109] result() for ClusterFuture ...
[18:04:24.109] - result already collected: FutureResult
[18:04:24.110] result() for ClusterFuture ... done
[18:04:24.110] result() for ClusterFuture ...
[18:04:24.110] - result already collected: FutureResult
[18:04:24.110] result() for ClusterFuture ... done
[18:04:24.110] result() for ClusterFuture ...
[18:04:24.111] - result already collected: FutureResult
[18:04:24.111] result() for ClusterFuture ... done
[18:04:24.111] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:24.111] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:24.111] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:24.111]  length: 3 (resolved future 3)
[18:04:24.112] receiveMessageFromWorker() for ClusterFuture ...
[18:04:24.113] - Validating connection of MultisessionFuture
[18:04:24.113] - received message: FutureResult
[18:04:24.113] - Received FutureResult
[18:04:24.114] - Erased future from FutureRegistry
[18:04:24.114] result() for ClusterFuture ...
[18:04:24.114] - result already collected: FutureResult
[18:04:24.114] result() for ClusterFuture ... done
[18:04:24.114] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:24.114] Future #4
[18:04:24.115] result() for ClusterFuture ...
[18:04:24.115] - result already collected: FutureResult
[18:04:24.115] result() for ClusterFuture ... done
[18:04:24.115] result() for ClusterFuture ...
[18:04:24.115] - result already collected: FutureResult
[18:04:24.116] result() for ClusterFuture ... done
[18:04:24.116] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:24.116] - nx: 6
[18:04:24.116] - relay: TRUE
[18:04:24.116] - stdout: TRUE
[18:04:24.116] - signal: TRUE
[18:04:24.117] - resignal: FALSE
[18:04:24.120] - force: TRUE
[18:04:24.121] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:24.121] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:24.121]  - until=4
[18:04:24.121]  - relaying element #4
[18:04:24.122] result() for ClusterFuture ...
[18:04:24.122] - result already collected: FutureResult
[18:04:24.122] result() for ClusterFuture ... done
[18:04:24.122] result() for ClusterFuture ...
[18:04:24.122] - result already collected: FutureResult
[18:04:24.123] result() for ClusterFuture ... done
[18:04:24.123] result() for ClusterFuture ...
[18:04:24.123] - result already collected: FutureResult
[18:04:24.123] result() for ClusterFuture ... done
[18:04:24.123] result() for ClusterFuture ...
[18:04:24.123] - result already collected: FutureResult
[18:04:24.124] result() for ClusterFuture ... done
[18:04:24.124] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.124] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.124] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:24.124]  length: 2 (resolved future 4)
[18:04:24.125] signalConditionsASAP(NULL, pos=5) ...
[18:04:24.125] - nx: 6
[18:04:24.125] - relay: TRUE
[18:04:24.125] - stdout: TRUE
[18:04:24.125] - signal: TRUE
[18:04:24.125] - resignal: FALSE
[18:04:24.126] - force: TRUE
[18:04:24.126] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.126] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.126]  - until=6
[18:04:24.126]  - relaying element #6
[18:04:24.127] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:24.127] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.127] signalConditionsASAP(NULL, pos=5) ... done
[18:04:24.127]  length: 1 (resolved future 5)
[18:04:24.127] signalConditionsASAP(numeric, pos=6) ...
[18:04:24.128] - nx: 6
[18:04:24.128] - relay: TRUE
[18:04:24.128] - stdout: TRUE
[18:04:24.128] - signal: TRUE
[18:04:24.128] - resignal: FALSE
[18:04:24.128] - force: TRUE
[18:04:24.129] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:24.129] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.129]  - until=6
[18:04:24.129] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:24.129] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.129] signalConditionsASAP(numeric, pos=6) ... done
[18:04:24.130]  length: 0 (resolved future 6)
[18:04:24.130] Relaying remaining futures
[18:04:24.130] signalConditionsASAP(NULL, pos=0) ...
[18:04:24.130] - nx: 6
[18:04:24.130] - relay: TRUE
[18:04:24.130] - stdout: TRUE
[18:04:24.131] - signal: TRUE
[18:04:24.131] - resignal: FALSE
[18:04:24.131] - force: TRUE
[18:04:24.131] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:24.131] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:24.132] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:24.132] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.132] signalConditionsASAP(NULL, pos=0) ... done
[18:04:24.132] resolve() on list environment ... DONE
[18:04:24.132] result() for ClusterFuture ...
[18:04:24.133] - result already collected: FutureResult
[18:04:24.133] result() for ClusterFuture ... done
[18:04:24.133] result() for ClusterFuture ...
[18:04:24.133] - result already collected: FutureResult
[18:04:24.133] result() for ClusterFuture ... done
[18:04:24.134] result() for ClusterFuture ...
[18:04:24.134] - result already collected: FutureResult
[18:04:24.134] result() for ClusterFuture ... done
[18:04:24.134] result() for ClusterFuture ...
[18:04:24.134] - result already collected: FutureResult
[18:04:24.135] result() for ClusterFuture ... done
[18:04:24.135] result() for ClusterFuture ...
[18:04:24.135] - result already collected: FutureResult
[18:04:24.135] result() for ClusterFuture ... done
[18:04:24.135] result() for ClusterFuture ...
[18:04:24.136] - result already collected: FutureResult
[18:04:24.136] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2cdb4c48> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[18:04:24.140] getGlobalsAndPackages() ...
[18:04:24.140] Searching for globals...
[18:04:24.140] 
[18:04:24.141] Searching for globals ... DONE
[18:04:24.141] - globals: [0] <none>
[18:04:24.141] getGlobalsAndPackages() ... DONE
[18:04:24.142] run() for ‘Future’ ...
[18:04:24.142] - state: ‘created’
[18:04:24.142] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:24.164] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:24.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:24.165]   - Field: ‘node’
[18:04:24.165]   - Field: ‘label’
[18:04:24.165]   - Field: ‘local’
[18:04:24.166]   - Field: ‘owner’
[18:04:24.166]   - Field: ‘envir’
[18:04:24.166]   - Field: ‘workers’
[18:04:24.166]   - Field: ‘packages’
[18:04:24.166]   - Field: ‘gc’
[18:04:24.167]   - Field: ‘conditions’
[18:04:24.167]   - Field: ‘persistent’
[18:04:24.167]   - Field: ‘expr’
[18:04:24.167]   - Field: ‘uuid’
[18:04:24.167]   - Field: ‘seed’
[18:04:24.168]   - Field: ‘version’
[18:04:24.168]   - Field: ‘result’
[18:04:24.168]   - Field: ‘asynchronous’
[18:04:24.168]   - Field: ‘calls’
[18:04:24.168]   - Field: ‘globals’
[18:04:24.169]   - Field: ‘stdout’
[18:04:24.169]   - Field: ‘earlySignal’
[18:04:24.169]   - Field: ‘lazy’
[18:04:24.169]   - Field: ‘state’
[18:04:24.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:24.170] - Launch lazy future ...
[18:04:24.170] Packages needed by the future expression (n = 0): <none>
[18:04:24.170] Packages needed by future strategies (n = 0): <none>
[18:04:24.171] {
[18:04:24.171]     {
[18:04:24.171]         {
[18:04:24.171]             ...future.startTime <- base::Sys.time()
[18:04:24.171]             {
[18:04:24.171]                 {
[18:04:24.171]                   {
[18:04:24.171]                     {
[18:04:24.171]                       base::local({
[18:04:24.171]                         has_future <- base::requireNamespace("future", 
[18:04:24.171]                           quietly = TRUE)
[18:04:24.171]                         if (has_future) {
[18:04:24.171]                           ns <- base::getNamespace("future")
[18:04:24.171]                           version <- ns[[".package"]][["version"]]
[18:04:24.171]                           if (is.null(version)) 
[18:04:24.171]                             version <- utils::packageVersion("future")
[18:04:24.171]                         }
[18:04:24.171]                         else {
[18:04:24.171]                           version <- NULL
[18:04:24.171]                         }
[18:04:24.171]                         if (!has_future || version < "1.8.0") {
[18:04:24.171]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:24.171]                             "", base::R.version$version.string), 
[18:04:24.171]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:24.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:24.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:24.171]                               "release", "version")], collapse = " "), 
[18:04:24.171]                             hostname = base::Sys.info()[["nodename"]])
[18:04:24.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:24.171]                             info)
[18:04:24.171]                           info <- base::paste(info, collapse = "; ")
[18:04:24.171]                           if (!has_future) {
[18:04:24.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:24.171]                               info)
[18:04:24.171]                           }
[18:04:24.171]                           else {
[18:04:24.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:24.171]                               info, version)
[18:04:24.171]                           }
[18:04:24.171]                           base::stop(msg)
[18:04:24.171]                         }
[18:04:24.171]                       })
[18:04:24.171]                     }
[18:04:24.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:24.171]                     base::options(mc.cores = 1L)
[18:04:24.171]                   }
[18:04:24.171]                   ...future.strategy.old <- future::plan("list")
[18:04:24.171]                   options(future.plan = NULL)
[18:04:24.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:24.171]                 }
[18:04:24.171]                 ...future.workdir <- getwd()
[18:04:24.171]             }
[18:04:24.171]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:24.171]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:24.171]         }
[18:04:24.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:24.171]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:24.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:24.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:24.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:24.171]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:24.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:24.171]             base::names(...future.oldOptions))
[18:04:24.171]     }
[18:04:24.171]     if (FALSE) {
[18:04:24.171]     }
[18:04:24.171]     else {
[18:04:24.171]         if (TRUE) {
[18:04:24.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:24.171]                 open = "w")
[18:04:24.171]         }
[18:04:24.171]         else {
[18:04:24.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:24.171]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:24.171]         }
[18:04:24.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:24.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:24.171]             base::sink(type = "output", split = FALSE)
[18:04:24.171]             base::close(...future.stdout)
[18:04:24.171]         }, add = TRUE)
[18:04:24.171]     }
[18:04:24.171]     ...future.frame <- base::sys.nframe()
[18:04:24.171]     ...future.conditions <- base::list()
[18:04:24.171]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:24.171]     if (FALSE) {
[18:04:24.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:24.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:24.171]     }
[18:04:24.171]     ...future.result <- base::tryCatch({
[18:04:24.171]         base::withCallingHandlers({
[18:04:24.171]             ...future.value <- base::withVisible(base::local({
[18:04:24.171]                 ...future.makeSendCondition <- base::local({
[18:04:24.171]                   sendCondition <- NULL
[18:04:24.171]                   function(frame = 1L) {
[18:04:24.171]                     if (is.function(sendCondition)) 
[18:04:24.171]                       return(sendCondition)
[18:04:24.171]                     ns <- getNamespace("parallel")
[18:04:24.171]                     if (exists("sendData", mode = "function", 
[18:04:24.171]                       envir = ns)) {
[18:04:24.171]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:24.171]                         envir = ns)
[18:04:24.171]                       envir <- sys.frame(frame)
[18:04:24.171]                       master <- NULL
[18:04:24.171]                       while (!identical(envir, .GlobalEnv) && 
[18:04:24.171]                         !identical(envir, emptyenv())) {
[18:04:24.171]                         if (exists("master", mode = "list", envir = envir, 
[18:04:24.171]                           inherits = FALSE)) {
[18:04:24.171]                           master <- get("master", mode = "list", 
[18:04:24.171]                             envir = envir, inherits = FALSE)
[18:04:24.171]                           if (inherits(master, c("SOCKnode", 
[18:04:24.171]                             "SOCK0node"))) {
[18:04:24.171]                             sendCondition <<- function(cond) {
[18:04:24.171]                               data <- list(type = "VALUE", value = cond, 
[18:04:24.171]                                 success = TRUE)
[18:04:24.171]                               parallel_sendData(master, data)
[18:04:24.171]                             }
[18:04:24.171]                             return(sendCondition)
[18:04:24.171]                           }
[18:04:24.171]                         }
[18:04:24.171]                         frame <- frame + 1L
[18:04:24.171]                         envir <- sys.frame(frame)
[18:04:24.171]                       }
[18:04:24.171]                     }
[18:04:24.171]                     sendCondition <<- function(cond) NULL
[18:04:24.171]                   }
[18:04:24.171]                 })
[18:04:24.171]                 withCallingHandlers({
[18:04:24.171]                   2
[18:04:24.171]                 }, immediateCondition = function(cond) {
[18:04:24.171]                   sendCondition <- ...future.makeSendCondition()
[18:04:24.171]                   sendCondition(cond)
[18:04:24.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.171]                   {
[18:04:24.171]                     inherits <- base::inherits
[18:04:24.171]                     invokeRestart <- base::invokeRestart
[18:04:24.171]                     is.null <- base::is.null
[18:04:24.171]                     muffled <- FALSE
[18:04:24.171]                     if (inherits(cond, "message")) {
[18:04:24.171]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:24.171]                       if (muffled) 
[18:04:24.171]                         invokeRestart("muffleMessage")
[18:04:24.171]                     }
[18:04:24.171]                     else if (inherits(cond, "warning")) {
[18:04:24.171]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:24.171]                       if (muffled) 
[18:04:24.171]                         invokeRestart("muffleWarning")
[18:04:24.171]                     }
[18:04:24.171]                     else if (inherits(cond, "condition")) {
[18:04:24.171]                       if (!is.null(pattern)) {
[18:04:24.171]                         computeRestarts <- base::computeRestarts
[18:04:24.171]                         grepl <- base::grepl
[18:04:24.171]                         restarts <- computeRestarts(cond)
[18:04:24.171]                         for (restart in restarts) {
[18:04:24.171]                           name <- restart$name
[18:04:24.171]                           if (is.null(name)) 
[18:04:24.171]                             next
[18:04:24.171]                           if (!grepl(pattern, name)) 
[18:04:24.171]                             next
[18:04:24.171]                           invokeRestart(restart)
[18:04:24.171]                           muffled <- TRUE
[18:04:24.171]                           break
[18:04:24.171]                         }
[18:04:24.171]                       }
[18:04:24.171]                     }
[18:04:24.171]                     invisible(muffled)
[18:04:24.171]                   }
[18:04:24.171]                   muffleCondition(cond)
[18:04:24.171]                 })
[18:04:24.171]             }))
[18:04:24.171]             future::FutureResult(value = ...future.value$value, 
[18:04:24.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.171]                   ...future.rng), globalenv = if (FALSE) 
[18:04:24.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:24.171]                     ...future.globalenv.names))
[18:04:24.171]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:24.171]         }, condition = base::local({
[18:04:24.171]             c <- base::c
[18:04:24.171]             inherits <- base::inherits
[18:04:24.171]             invokeRestart <- base::invokeRestart
[18:04:24.171]             length <- base::length
[18:04:24.171]             list <- base::list
[18:04:24.171]             seq.int <- base::seq.int
[18:04:24.171]             signalCondition <- base::signalCondition
[18:04:24.171]             sys.calls <- base::sys.calls
[18:04:24.171]             `[[` <- base::`[[`
[18:04:24.171]             `+` <- base::`+`
[18:04:24.171]             `<<-` <- base::`<<-`
[18:04:24.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:24.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:24.171]                   3L)]
[18:04:24.171]             }
[18:04:24.171]             function(cond) {
[18:04:24.171]                 is_error <- inherits(cond, "error")
[18:04:24.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:24.171]                   NULL)
[18:04:24.171]                 if (is_error) {
[18:04:24.171]                   sessionInformation <- function() {
[18:04:24.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:24.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:24.171]                       search = base::search(), system = base::Sys.info())
[18:04:24.171]                   }
[18:04:24.171]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:24.171]                     cond$call), session = sessionInformation(), 
[18:04:24.171]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:24.171]                   signalCondition(cond)
[18:04:24.171]                 }
[18:04:24.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:24.171]                 "immediateCondition"))) {
[18:04:24.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:24.171]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:24.171]                   if (TRUE && !signal) {
[18:04:24.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.171]                     {
[18:04:24.171]                       inherits <- base::inherits
[18:04:24.171]                       invokeRestart <- base::invokeRestart
[18:04:24.171]                       is.null <- base::is.null
[18:04:24.171]                       muffled <- FALSE
[18:04:24.171]                       if (inherits(cond, "message")) {
[18:04:24.171]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.171]                         if (muffled) 
[18:04:24.171]                           invokeRestart("muffleMessage")
[18:04:24.171]                       }
[18:04:24.171]                       else if (inherits(cond, "warning")) {
[18:04:24.171]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.171]                         if (muffled) 
[18:04:24.171]                           invokeRestart("muffleWarning")
[18:04:24.171]                       }
[18:04:24.171]                       else if (inherits(cond, "condition")) {
[18:04:24.171]                         if (!is.null(pattern)) {
[18:04:24.171]                           computeRestarts <- base::computeRestarts
[18:04:24.171]                           grepl <- base::grepl
[18:04:24.171]                           restarts <- computeRestarts(cond)
[18:04:24.171]                           for (restart in restarts) {
[18:04:24.171]                             name <- restart$name
[18:04:24.171]                             if (is.null(name)) 
[18:04:24.171]                               next
[18:04:24.171]                             if (!grepl(pattern, name)) 
[18:04:24.171]                               next
[18:04:24.171]                             invokeRestart(restart)
[18:04:24.171]                             muffled <- TRUE
[18:04:24.171]                             break
[18:04:24.171]                           }
[18:04:24.171]                         }
[18:04:24.171]                       }
[18:04:24.171]                       invisible(muffled)
[18:04:24.171]                     }
[18:04:24.171]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.171]                   }
[18:04:24.171]                 }
[18:04:24.171]                 else {
[18:04:24.171]                   if (TRUE) {
[18:04:24.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.171]                     {
[18:04:24.171]                       inherits <- base::inherits
[18:04:24.171]                       invokeRestart <- base::invokeRestart
[18:04:24.171]                       is.null <- base::is.null
[18:04:24.171]                       muffled <- FALSE
[18:04:24.171]                       if (inherits(cond, "message")) {
[18:04:24.171]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.171]                         if (muffled) 
[18:04:24.171]                           invokeRestart("muffleMessage")
[18:04:24.171]                       }
[18:04:24.171]                       else if (inherits(cond, "warning")) {
[18:04:24.171]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.171]                         if (muffled) 
[18:04:24.171]                           invokeRestart("muffleWarning")
[18:04:24.171]                       }
[18:04:24.171]                       else if (inherits(cond, "condition")) {
[18:04:24.171]                         if (!is.null(pattern)) {
[18:04:24.171]                           computeRestarts <- base::computeRestarts
[18:04:24.171]                           grepl <- base::grepl
[18:04:24.171]                           restarts <- computeRestarts(cond)
[18:04:24.171]                           for (restart in restarts) {
[18:04:24.171]                             name <- restart$name
[18:04:24.171]                             if (is.null(name)) 
[18:04:24.171]                               next
[18:04:24.171]                             if (!grepl(pattern, name)) 
[18:04:24.171]                               next
[18:04:24.171]                             invokeRestart(restart)
[18:04:24.171]                             muffled <- TRUE
[18:04:24.171]                             break
[18:04:24.171]                           }
[18:04:24.171]                         }
[18:04:24.171]                       }
[18:04:24.171]                       invisible(muffled)
[18:04:24.171]                     }
[18:04:24.171]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.171]                   }
[18:04:24.171]                 }
[18:04:24.171]             }
[18:04:24.171]         }))
[18:04:24.171]     }, error = function(ex) {
[18:04:24.171]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:24.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.171]                 ...future.rng), started = ...future.startTime, 
[18:04:24.171]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:24.171]             version = "1.8"), class = "FutureResult")
[18:04:24.171]     }, finally = {
[18:04:24.171]         if (!identical(...future.workdir, getwd())) 
[18:04:24.171]             setwd(...future.workdir)
[18:04:24.171]         {
[18:04:24.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:24.171]                 ...future.oldOptions$nwarnings <- NULL
[18:04:24.171]             }
[18:04:24.171]             base::options(...future.oldOptions)
[18:04:24.171]             if (.Platform$OS.type == "windows") {
[18:04:24.171]                 old_names <- names(...future.oldEnvVars)
[18:04:24.171]                 envs <- base::Sys.getenv()
[18:04:24.171]                 names <- names(envs)
[18:04:24.171]                 common <- intersect(names, old_names)
[18:04:24.171]                 added <- setdiff(names, old_names)
[18:04:24.171]                 removed <- setdiff(old_names, names)
[18:04:24.171]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:24.171]                   envs[common]]
[18:04:24.171]                 NAMES <- toupper(changed)
[18:04:24.171]                 args <- list()
[18:04:24.171]                 for (kk in seq_along(NAMES)) {
[18:04:24.171]                   name <- changed[[kk]]
[18:04:24.171]                   NAME <- NAMES[[kk]]
[18:04:24.171]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.171]                     next
[18:04:24.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.171]                 }
[18:04:24.171]                 NAMES <- toupper(added)
[18:04:24.171]                 for (kk in seq_along(NAMES)) {
[18:04:24.171]                   name <- added[[kk]]
[18:04:24.171]                   NAME <- NAMES[[kk]]
[18:04:24.171]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.171]                     next
[18:04:24.171]                   args[[name]] <- ""
[18:04:24.171]                 }
[18:04:24.171]                 NAMES <- toupper(removed)
[18:04:24.171]                 for (kk in seq_along(NAMES)) {
[18:04:24.171]                   name <- removed[[kk]]
[18:04:24.171]                   NAME <- NAMES[[kk]]
[18:04:24.171]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.171]                     next
[18:04:24.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.171]                 }
[18:04:24.171]                 if (length(args) > 0) 
[18:04:24.171]                   base::do.call(base::Sys.setenv, args = args)
[18:04:24.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:24.171]             }
[18:04:24.171]             else {
[18:04:24.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:24.171]             }
[18:04:24.171]             {
[18:04:24.171]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:24.171]                   0L) {
[18:04:24.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:24.171]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:24.171]                   base::options(opts)
[18:04:24.171]                 }
[18:04:24.171]                 {
[18:04:24.171]                   {
[18:04:24.171]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:24.171]                     NULL
[18:04:24.171]                   }
[18:04:24.171]                   options(future.plan = NULL)
[18:04:24.171]                   if (is.na(NA_character_)) 
[18:04:24.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:24.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:24.171]                     .init = FALSE)
[18:04:24.171]                 }
[18:04:24.171]             }
[18:04:24.171]         }
[18:04:24.171]     })
[18:04:24.171]     if (TRUE) {
[18:04:24.171]         base::sink(type = "output", split = FALSE)
[18:04:24.171]         if (TRUE) {
[18:04:24.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:24.171]         }
[18:04:24.171]         else {
[18:04:24.171]             ...future.result["stdout"] <- base::list(NULL)
[18:04:24.171]         }
[18:04:24.171]         base::close(...future.stdout)
[18:04:24.171]         ...future.stdout <- NULL
[18:04:24.171]     }
[18:04:24.171]     ...future.result$conditions <- ...future.conditions
[18:04:24.171]     ...future.result$finished <- base::Sys.time()
[18:04:24.171]     ...future.result
[18:04:24.171] }
[18:04:24.177] MultisessionFuture started
[18:04:24.177] - Launch lazy future ... done
[18:04:24.177] run() for ‘MultisessionFuture’ ... done
[18:04:24.178] getGlobalsAndPackages() ...
[18:04:24.178] Searching for globals...
[18:04:24.178] 
[18:04:24.179] Searching for globals ... DONE
[18:04:24.179] - globals: [0] <none>
[18:04:24.179] getGlobalsAndPackages() ... DONE
[18:04:24.180] run() for ‘Future’ ...
[18:04:24.180] - state: ‘created’
[18:04:24.180] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:24.203] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:24.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:24.204]   - Field: ‘node’
[18:04:24.204]   - Field: ‘label’
[18:04:24.204]   - Field: ‘local’
[18:04:24.204]   - Field: ‘owner’
[18:04:24.205]   - Field: ‘envir’
[18:04:24.205]   - Field: ‘workers’
[18:04:24.205]   - Field: ‘packages’
[18:04:24.205]   - Field: ‘gc’
[18:04:24.205]   - Field: ‘conditions’
[18:04:24.206]   - Field: ‘persistent’
[18:04:24.206]   - Field: ‘expr’
[18:04:24.206]   - Field: ‘uuid’
[18:04:24.206]   - Field: ‘seed’
[18:04:24.206]   - Field: ‘version’
[18:04:24.207]   - Field: ‘result’
[18:04:24.207]   - Field: ‘asynchronous’
[18:04:24.207]   - Field: ‘calls’
[18:04:24.207]   - Field: ‘globals’
[18:04:24.207]   - Field: ‘stdout’
[18:04:24.208]   - Field: ‘earlySignal’
[18:04:24.208]   - Field: ‘lazy’
[18:04:24.208]   - Field: ‘state’
[18:04:24.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:24.208] - Launch lazy future ...
[18:04:24.209] Packages needed by the future expression (n = 0): <none>
[18:04:24.209] Packages needed by future strategies (n = 0): <none>
[18:04:24.210] {
[18:04:24.210]     {
[18:04:24.210]         {
[18:04:24.210]             ...future.startTime <- base::Sys.time()
[18:04:24.210]             {
[18:04:24.210]                 {
[18:04:24.210]                   {
[18:04:24.210]                     {
[18:04:24.210]                       base::local({
[18:04:24.210]                         has_future <- base::requireNamespace("future", 
[18:04:24.210]                           quietly = TRUE)
[18:04:24.210]                         if (has_future) {
[18:04:24.210]                           ns <- base::getNamespace("future")
[18:04:24.210]                           version <- ns[[".package"]][["version"]]
[18:04:24.210]                           if (is.null(version)) 
[18:04:24.210]                             version <- utils::packageVersion("future")
[18:04:24.210]                         }
[18:04:24.210]                         else {
[18:04:24.210]                           version <- NULL
[18:04:24.210]                         }
[18:04:24.210]                         if (!has_future || version < "1.8.0") {
[18:04:24.210]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:24.210]                             "", base::R.version$version.string), 
[18:04:24.210]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:24.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:24.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:24.210]                               "release", "version")], collapse = " "), 
[18:04:24.210]                             hostname = base::Sys.info()[["nodename"]])
[18:04:24.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:24.210]                             info)
[18:04:24.210]                           info <- base::paste(info, collapse = "; ")
[18:04:24.210]                           if (!has_future) {
[18:04:24.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:24.210]                               info)
[18:04:24.210]                           }
[18:04:24.210]                           else {
[18:04:24.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:24.210]                               info, version)
[18:04:24.210]                           }
[18:04:24.210]                           base::stop(msg)
[18:04:24.210]                         }
[18:04:24.210]                       })
[18:04:24.210]                     }
[18:04:24.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:24.210]                     base::options(mc.cores = 1L)
[18:04:24.210]                   }
[18:04:24.210]                   ...future.strategy.old <- future::plan("list")
[18:04:24.210]                   options(future.plan = NULL)
[18:04:24.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:24.210]                 }
[18:04:24.210]                 ...future.workdir <- getwd()
[18:04:24.210]             }
[18:04:24.210]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:24.210]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:24.210]         }
[18:04:24.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:24.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:24.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:24.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:24.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:24.210]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:24.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:24.210]             base::names(...future.oldOptions))
[18:04:24.210]     }
[18:04:24.210]     if (FALSE) {
[18:04:24.210]     }
[18:04:24.210]     else {
[18:04:24.210]         if (TRUE) {
[18:04:24.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:24.210]                 open = "w")
[18:04:24.210]         }
[18:04:24.210]         else {
[18:04:24.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:24.210]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:24.210]         }
[18:04:24.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:24.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:24.210]             base::sink(type = "output", split = FALSE)
[18:04:24.210]             base::close(...future.stdout)
[18:04:24.210]         }, add = TRUE)
[18:04:24.210]     }
[18:04:24.210]     ...future.frame <- base::sys.nframe()
[18:04:24.210]     ...future.conditions <- base::list()
[18:04:24.210]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:24.210]     if (FALSE) {
[18:04:24.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:24.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:24.210]     }
[18:04:24.210]     ...future.result <- base::tryCatch({
[18:04:24.210]         base::withCallingHandlers({
[18:04:24.210]             ...future.value <- base::withVisible(base::local({
[18:04:24.210]                 ...future.makeSendCondition <- base::local({
[18:04:24.210]                   sendCondition <- NULL
[18:04:24.210]                   function(frame = 1L) {
[18:04:24.210]                     if (is.function(sendCondition)) 
[18:04:24.210]                       return(sendCondition)
[18:04:24.210]                     ns <- getNamespace("parallel")
[18:04:24.210]                     if (exists("sendData", mode = "function", 
[18:04:24.210]                       envir = ns)) {
[18:04:24.210]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:24.210]                         envir = ns)
[18:04:24.210]                       envir <- sys.frame(frame)
[18:04:24.210]                       master <- NULL
[18:04:24.210]                       while (!identical(envir, .GlobalEnv) && 
[18:04:24.210]                         !identical(envir, emptyenv())) {
[18:04:24.210]                         if (exists("master", mode = "list", envir = envir, 
[18:04:24.210]                           inherits = FALSE)) {
[18:04:24.210]                           master <- get("master", mode = "list", 
[18:04:24.210]                             envir = envir, inherits = FALSE)
[18:04:24.210]                           if (inherits(master, c("SOCKnode", 
[18:04:24.210]                             "SOCK0node"))) {
[18:04:24.210]                             sendCondition <<- function(cond) {
[18:04:24.210]                               data <- list(type = "VALUE", value = cond, 
[18:04:24.210]                                 success = TRUE)
[18:04:24.210]                               parallel_sendData(master, data)
[18:04:24.210]                             }
[18:04:24.210]                             return(sendCondition)
[18:04:24.210]                           }
[18:04:24.210]                         }
[18:04:24.210]                         frame <- frame + 1L
[18:04:24.210]                         envir <- sys.frame(frame)
[18:04:24.210]                       }
[18:04:24.210]                     }
[18:04:24.210]                     sendCondition <<- function(cond) NULL
[18:04:24.210]                   }
[18:04:24.210]                 })
[18:04:24.210]                 withCallingHandlers({
[18:04:24.210]                   NULL
[18:04:24.210]                 }, immediateCondition = function(cond) {
[18:04:24.210]                   sendCondition <- ...future.makeSendCondition()
[18:04:24.210]                   sendCondition(cond)
[18:04:24.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.210]                   {
[18:04:24.210]                     inherits <- base::inherits
[18:04:24.210]                     invokeRestart <- base::invokeRestart
[18:04:24.210]                     is.null <- base::is.null
[18:04:24.210]                     muffled <- FALSE
[18:04:24.210]                     if (inherits(cond, "message")) {
[18:04:24.210]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:24.210]                       if (muffled) 
[18:04:24.210]                         invokeRestart("muffleMessage")
[18:04:24.210]                     }
[18:04:24.210]                     else if (inherits(cond, "warning")) {
[18:04:24.210]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:24.210]                       if (muffled) 
[18:04:24.210]                         invokeRestart("muffleWarning")
[18:04:24.210]                     }
[18:04:24.210]                     else if (inherits(cond, "condition")) {
[18:04:24.210]                       if (!is.null(pattern)) {
[18:04:24.210]                         computeRestarts <- base::computeRestarts
[18:04:24.210]                         grepl <- base::grepl
[18:04:24.210]                         restarts <- computeRestarts(cond)
[18:04:24.210]                         for (restart in restarts) {
[18:04:24.210]                           name <- restart$name
[18:04:24.210]                           if (is.null(name)) 
[18:04:24.210]                             next
[18:04:24.210]                           if (!grepl(pattern, name)) 
[18:04:24.210]                             next
[18:04:24.210]                           invokeRestart(restart)
[18:04:24.210]                           muffled <- TRUE
[18:04:24.210]                           break
[18:04:24.210]                         }
[18:04:24.210]                       }
[18:04:24.210]                     }
[18:04:24.210]                     invisible(muffled)
[18:04:24.210]                   }
[18:04:24.210]                   muffleCondition(cond)
[18:04:24.210]                 })
[18:04:24.210]             }))
[18:04:24.210]             future::FutureResult(value = ...future.value$value, 
[18:04:24.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.210]                   ...future.rng), globalenv = if (FALSE) 
[18:04:24.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:24.210]                     ...future.globalenv.names))
[18:04:24.210]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:24.210]         }, condition = base::local({
[18:04:24.210]             c <- base::c
[18:04:24.210]             inherits <- base::inherits
[18:04:24.210]             invokeRestart <- base::invokeRestart
[18:04:24.210]             length <- base::length
[18:04:24.210]             list <- base::list
[18:04:24.210]             seq.int <- base::seq.int
[18:04:24.210]             signalCondition <- base::signalCondition
[18:04:24.210]             sys.calls <- base::sys.calls
[18:04:24.210]             `[[` <- base::`[[`
[18:04:24.210]             `+` <- base::`+`
[18:04:24.210]             `<<-` <- base::`<<-`
[18:04:24.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:24.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:24.210]                   3L)]
[18:04:24.210]             }
[18:04:24.210]             function(cond) {
[18:04:24.210]                 is_error <- inherits(cond, "error")
[18:04:24.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:24.210]                   NULL)
[18:04:24.210]                 if (is_error) {
[18:04:24.210]                   sessionInformation <- function() {
[18:04:24.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:24.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:24.210]                       search = base::search(), system = base::Sys.info())
[18:04:24.210]                   }
[18:04:24.210]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:24.210]                     cond$call), session = sessionInformation(), 
[18:04:24.210]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:24.210]                   signalCondition(cond)
[18:04:24.210]                 }
[18:04:24.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:24.210]                 "immediateCondition"))) {
[18:04:24.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:24.210]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:24.210]                   if (TRUE && !signal) {
[18:04:24.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.210]                     {
[18:04:24.210]                       inherits <- base::inherits
[18:04:24.210]                       invokeRestart <- base::invokeRestart
[18:04:24.210]                       is.null <- base::is.null
[18:04:24.210]                       muffled <- FALSE
[18:04:24.210]                       if (inherits(cond, "message")) {
[18:04:24.210]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.210]                         if (muffled) 
[18:04:24.210]                           invokeRestart("muffleMessage")
[18:04:24.210]                       }
[18:04:24.210]                       else if (inherits(cond, "warning")) {
[18:04:24.210]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.210]                         if (muffled) 
[18:04:24.210]                           invokeRestart("muffleWarning")
[18:04:24.210]                       }
[18:04:24.210]                       else if (inherits(cond, "condition")) {
[18:04:24.210]                         if (!is.null(pattern)) {
[18:04:24.210]                           computeRestarts <- base::computeRestarts
[18:04:24.210]                           grepl <- base::grepl
[18:04:24.210]                           restarts <- computeRestarts(cond)
[18:04:24.210]                           for (restart in restarts) {
[18:04:24.210]                             name <- restart$name
[18:04:24.210]                             if (is.null(name)) 
[18:04:24.210]                               next
[18:04:24.210]                             if (!grepl(pattern, name)) 
[18:04:24.210]                               next
[18:04:24.210]                             invokeRestart(restart)
[18:04:24.210]                             muffled <- TRUE
[18:04:24.210]                             break
[18:04:24.210]                           }
[18:04:24.210]                         }
[18:04:24.210]                       }
[18:04:24.210]                       invisible(muffled)
[18:04:24.210]                     }
[18:04:24.210]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.210]                   }
[18:04:24.210]                 }
[18:04:24.210]                 else {
[18:04:24.210]                   if (TRUE) {
[18:04:24.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.210]                     {
[18:04:24.210]                       inherits <- base::inherits
[18:04:24.210]                       invokeRestart <- base::invokeRestart
[18:04:24.210]                       is.null <- base::is.null
[18:04:24.210]                       muffled <- FALSE
[18:04:24.210]                       if (inherits(cond, "message")) {
[18:04:24.210]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.210]                         if (muffled) 
[18:04:24.210]                           invokeRestart("muffleMessage")
[18:04:24.210]                       }
[18:04:24.210]                       else if (inherits(cond, "warning")) {
[18:04:24.210]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.210]                         if (muffled) 
[18:04:24.210]                           invokeRestart("muffleWarning")
[18:04:24.210]                       }
[18:04:24.210]                       else if (inherits(cond, "condition")) {
[18:04:24.210]                         if (!is.null(pattern)) {
[18:04:24.210]                           computeRestarts <- base::computeRestarts
[18:04:24.210]                           grepl <- base::grepl
[18:04:24.210]                           restarts <- computeRestarts(cond)
[18:04:24.210]                           for (restart in restarts) {
[18:04:24.210]                             name <- restart$name
[18:04:24.210]                             if (is.null(name)) 
[18:04:24.210]                               next
[18:04:24.210]                             if (!grepl(pattern, name)) 
[18:04:24.210]                               next
[18:04:24.210]                             invokeRestart(restart)
[18:04:24.210]                             muffled <- TRUE
[18:04:24.210]                             break
[18:04:24.210]                           }
[18:04:24.210]                         }
[18:04:24.210]                       }
[18:04:24.210]                       invisible(muffled)
[18:04:24.210]                     }
[18:04:24.210]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.210]                   }
[18:04:24.210]                 }
[18:04:24.210]             }
[18:04:24.210]         }))
[18:04:24.210]     }, error = function(ex) {
[18:04:24.210]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:24.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.210]                 ...future.rng), started = ...future.startTime, 
[18:04:24.210]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:24.210]             version = "1.8"), class = "FutureResult")
[18:04:24.210]     }, finally = {
[18:04:24.210]         if (!identical(...future.workdir, getwd())) 
[18:04:24.210]             setwd(...future.workdir)
[18:04:24.210]         {
[18:04:24.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:24.210]                 ...future.oldOptions$nwarnings <- NULL
[18:04:24.210]             }
[18:04:24.210]             base::options(...future.oldOptions)
[18:04:24.210]             if (.Platform$OS.type == "windows") {
[18:04:24.210]                 old_names <- names(...future.oldEnvVars)
[18:04:24.210]                 envs <- base::Sys.getenv()
[18:04:24.210]                 names <- names(envs)
[18:04:24.210]                 common <- intersect(names, old_names)
[18:04:24.210]                 added <- setdiff(names, old_names)
[18:04:24.210]                 removed <- setdiff(old_names, names)
[18:04:24.210]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:24.210]                   envs[common]]
[18:04:24.210]                 NAMES <- toupper(changed)
[18:04:24.210]                 args <- list()
[18:04:24.210]                 for (kk in seq_along(NAMES)) {
[18:04:24.210]                   name <- changed[[kk]]
[18:04:24.210]                   NAME <- NAMES[[kk]]
[18:04:24.210]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.210]                     next
[18:04:24.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.210]                 }
[18:04:24.210]                 NAMES <- toupper(added)
[18:04:24.210]                 for (kk in seq_along(NAMES)) {
[18:04:24.210]                   name <- added[[kk]]
[18:04:24.210]                   NAME <- NAMES[[kk]]
[18:04:24.210]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.210]                     next
[18:04:24.210]                   args[[name]] <- ""
[18:04:24.210]                 }
[18:04:24.210]                 NAMES <- toupper(removed)
[18:04:24.210]                 for (kk in seq_along(NAMES)) {
[18:04:24.210]                   name <- removed[[kk]]
[18:04:24.210]                   NAME <- NAMES[[kk]]
[18:04:24.210]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.210]                     next
[18:04:24.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.210]                 }
[18:04:24.210]                 if (length(args) > 0) 
[18:04:24.210]                   base::do.call(base::Sys.setenv, args = args)
[18:04:24.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:24.210]             }
[18:04:24.210]             else {
[18:04:24.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:24.210]             }
[18:04:24.210]             {
[18:04:24.210]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:24.210]                   0L) {
[18:04:24.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:24.210]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:24.210]                   base::options(opts)
[18:04:24.210]                 }
[18:04:24.210]                 {
[18:04:24.210]                   {
[18:04:24.210]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:24.210]                     NULL
[18:04:24.210]                   }
[18:04:24.210]                   options(future.plan = NULL)
[18:04:24.210]                   if (is.na(NA_character_)) 
[18:04:24.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:24.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:24.210]                     .init = FALSE)
[18:04:24.210]                 }
[18:04:24.210]             }
[18:04:24.210]         }
[18:04:24.210]     })
[18:04:24.210]     if (TRUE) {
[18:04:24.210]         base::sink(type = "output", split = FALSE)
[18:04:24.210]         if (TRUE) {
[18:04:24.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:24.210]         }
[18:04:24.210]         else {
[18:04:24.210]             ...future.result["stdout"] <- base::list(NULL)
[18:04:24.210]         }
[18:04:24.210]         base::close(...future.stdout)
[18:04:24.210]         ...future.stdout <- NULL
[18:04:24.210]     }
[18:04:24.210]     ...future.result$conditions <- ...future.conditions
[18:04:24.210]     ...future.result$finished <- base::Sys.time()
[18:04:24.210]     ...future.result
[18:04:24.210] }
[18:04:24.216] MultisessionFuture started
[18:04:24.216] - Launch lazy future ... done
[18:04:24.216] run() for ‘MultisessionFuture’ ... done
[18:04:24.217] getGlobalsAndPackages() ...
[18:04:24.217] Searching for globals...
[18:04:24.218] - globals found: [1] ‘{’
[18:04:24.219] Searching for globals ... DONE
[18:04:24.219] Resolving globals: FALSE
[18:04:24.219] 
[18:04:24.220] 
[18:04:24.220] getGlobalsAndPackages() ... DONE
[18:04:24.220] run() for ‘Future’ ...
[18:04:24.220] - state: ‘created’
[18:04:24.221] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:24.245] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:24.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:24.246]   - Field: ‘node’
[18:04:24.246]   - Field: ‘label’
[18:04:24.246]   - Field: ‘local’
[18:04:24.246]   - Field: ‘owner’
[18:04:24.247]   - Field: ‘envir’
[18:04:24.247]   - Field: ‘workers’
[18:04:24.247]   - Field: ‘packages’
[18:04:24.247]   - Field: ‘gc’
[18:04:24.247]   - Field: ‘conditions’
[18:04:24.248]   - Field: ‘persistent’
[18:04:24.248]   - Field: ‘expr’
[18:04:24.248]   - Field: ‘uuid’
[18:04:24.248]   - Field: ‘seed’
[18:04:24.248]   - Field: ‘version’
[18:04:24.249]   - Field: ‘result’
[18:04:24.249]   - Field: ‘asynchronous’
[18:04:24.249]   - Field: ‘calls’
[18:04:24.249]   - Field: ‘globals’
[18:04:24.249]   - Field: ‘stdout’
[18:04:24.250]   - Field: ‘earlySignal’
[18:04:24.250]   - Field: ‘lazy’
[18:04:24.250]   - Field: ‘state’
[18:04:24.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:24.250] - Launch lazy future ...
[18:04:24.251] Packages needed by the future expression (n = 0): <none>
[18:04:24.251] Packages needed by future strategies (n = 0): <none>
[18:04:24.252] {
[18:04:24.252]     {
[18:04:24.252]         {
[18:04:24.252]             ...future.startTime <- base::Sys.time()
[18:04:24.252]             {
[18:04:24.252]                 {
[18:04:24.252]                   {
[18:04:24.252]                     {
[18:04:24.252]                       base::local({
[18:04:24.252]                         has_future <- base::requireNamespace("future", 
[18:04:24.252]                           quietly = TRUE)
[18:04:24.252]                         if (has_future) {
[18:04:24.252]                           ns <- base::getNamespace("future")
[18:04:24.252]                           version <- ns[[".package"]][["version"]]
[18:04:24.252]                           if (is.null(version)) 
[18:04:24.252]                             version <- utils::packageVersion("future")
[18:04:24.252]                         }
[18:04:24.252]                         else {
[18:04:24.252]                           version <- NULL
[18:04:24.252]                         }
[18:04:24.252]                         if (!has_future || version < "1.8.0") {
[18:04:24.252]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:24.252]                             "", base::R.version$version.string), 
[18:04:24.252]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:24.252]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:24.252]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:24.252]                               "release", "version")], collapse = " "), 
[18:04:24.252]                             hostname = base::Sys.info()[["nodename"]])
[18:04:24.252]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:24.252]                             info)
[18:04:24.252]                           info <- base::paste(info, collapse = "; ")
[18:04:24.252]                           if (!has_future) {
[18:04:24.252]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:24.252]                               info)
[18:04:24.252]                           }
[18:04:24.252]                           else {
[18:04:24.252]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:24.252]                               info, version)
[18:04:24.252]                           }
[18:04:24.252]                           base::stop(msg)
[18:04:24.252]                         }
[18:04:24.252]                       })
[18:04:24.252]                     }
[18:04:24.252]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:24.252]                     base::options(mc.cores = 1L)
[18:04:24.252]                   }
[18:04:24.252]                   ...future.strategy.old <- future::plan("list")
[18:04:24.252]                   options(future.plan = NULL)
[18:04:24.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:24.252]                 }
[18:04:24.252]                 ...future.workdir <- getwd()
[18:04:24.252]             }
[18:04:24.252]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:24.252]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:24.252]         }
[18:04:24.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:04:24.252]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:24.252]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:04:24.252]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:24.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:24.252]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:24.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:24.252]             base::names(...future.oldOptions))
[18:04:24.252]     }
[18:04:24.252]     if (FALSE) {
[18:04:24.252]     }
[18:04:24.252]     else {
[18:04:24.252]         if (TRUE) {
[18:04:24.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:24.252]                 open = "w")
[18:04:24.252]         }
[18:04:24.252]         else {
[18:04:24.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:24.252]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:24.252]         }
[18:04:24.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:24.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:24.252]             base::sink(type = "output", split = FALSE)
[18:04:24.252]             base::close(...future.stdout)
[18:04:24.252]         }, add = TRUE)
[18:04:24.252]     }
[18:04:24.252]     ...future.frame <- base::sys.nframe()
[18:04:24.252]     ...future.conditions <- base::list()
[18:04:24.252]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:24.252]     if (FALSE) {
[18:04:24.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:24.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:24.252]     }
[18:04:24.252]     ...future.result <- base::tryCatch({
[18:04:24.252]         base::withCallingHandlers({
[18:04:24.252]             ...future.value <- base::withVisible(base::local({
[18:04:24.252]                 ...future.makeSendCondition <- base::local({
[18:04:24.252]                   sendCondition <- NULL
[18:04:24.252]                   function(frame = 1L) {
[18:04:24.252]                     if (is.function(sendCondition)) 
[18:04:24.252]                       return(sendCondition)
[18:04:24.252]                     ns <- getNamespace("parallel")
[18:04:24.252]                     if (exists("sendData", mode = "function", 
[18:04:24.252]                       envir = ns)) {
[18:04:24.252]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:24.252]                         envir = ns)
[18:04:24.252]                       envir <- sys.frame(frame)
[18:04:24.252]                       master <- NULL
[18:04:24.252]                       while (!identical(envir, .GlobalEnv) && 
[18:04:24.252]                         !identical(envir, emptyenv())) {
[18:04:24.252]                         if (exists("master", mode = "list", envir = envir, 
[18:04:24.252]                           inherits = FALSE)) {
[18:04:24.252]                           master <- get("master", mode = "list", 
[18:04:24.252]                             envir = envir, inherits = FALSE)
[18:04:24.252]                           if (inherits(master, c("SOCKnode", 
[18:04:24.252]                             "SOCK0node"))) {
[18:04:24.252]                             sendCondition <<- function(cond) {
[18:04:24.252]                               data <- list(type = "VALUE", value = cond, 
[18:04:24.252]                                 success = TRUE)
[18:04:24.252]                               parallel_sendData(master, data)
[18:04:24.252]                             }
[18:04:24.252]                             return(sendCondition)
[18:04:24.252]                           }
[18:04:24.252]                         }
[18:04:24.252]                         frame <- frame + 1L
[18:04:24.252]                         envir <- sys.frame(frame)
[18:04:24.252]                       }
[18:04:24.252]                     }
[18:04:24.252]                     sendCondition <<- function(cond) NULL
[18:04:24.252]                   }
[18:04:24.252]                 })
[18:04:24.252]                 withCallingHandlers({
[18:04:24.252]                   {
[18:04:24.252]                     4
[18:04:24.252]                   }
[18:04:24.252]                 }, immediateCondition = function(cond) {
[18:04:24.252]                   sendCondition <- ...future.makeSendCondition()
[18:04:24.252]                   sendCondition(cond)
[18:04:24.252]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.252]                   {
[18:04:24.252]                     inherits <- base::inherits
[18:04:24.252]                     invokeRestart <- base::invokeRestart
[18:04:24.252]                     is.null <- base::is.null
[18:04:24.252]                     muffled <- FALSE
[18:04:24.252]                     if (inherits(cond, "message")) {
[18:04:24.252]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:24.252]                       if (muffled) 
[18:04:24.252]                         invokeRestart("muffleMessage")
[18:04:24.252]                     }
[18:04:24.252]                     else if (inherits(cond, "warning")) {
[18:04:24.252]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:24.252]                       if (muffled) 
[18:04:24.252]                         invokeRestart("muffleWarning")
[18:04:24.252]                     }
[18:04:24.252]                     else if (inherits(cond, "condition")) {
[18:04:24.252]                       if (!is.null(pattern)) {
[18:04:24.252]                         computeRestarts <- base::computeRestarts
[18:04:24.252]                         grepl <- base::grepl
[18:04:24.252]                         restarts <- computeRestarts(cond)
[18:04:24.252]                         for (restart in restarts) {
[18:04:24.252]                           name <- restart$name
[18:04:24.252]                           if (is.null(name)) 
[18:04:24.252]                             next
[18:04:24.252]                           if (!grepl(pattern, name)) 
[18:04:24.252]                             next
[18:04:24.252]                           invokeRestart(restart)
[18:04:24.252]                           muffled <- TRUE
[18:04:24.252]                           break
[18:04:24.252]                         }
[18:04:24.252]                       }
[18:04:24.252]                     }
[18:04:24.252]                     invisible(muffled)
[18:04:24.252]                   }
[18:04:24.252]                   muffleCondition(cond)
[18:04:24.252]                 })
[18:04:24.252]             }))
[18:04:24.252]             future::FutureResult(value = ...future.value$value, 
[18:04:24.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.252]                   ...future.rng), globalenv = if (FALSE) 
[18:04:24.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:24.252]                     ...future.globalenv.names))
[18:04:24.252]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:24.252]         }, condition = base::local({
[18:04:24.252]             c <- base::c
[18:04:24.252]             inherits <- base::inherits
[18:04:24.252]             invokeRestart <- base::invokeRestart
[18:04:24.252]             length <- base::length
[18:04:24.252]             list <- base::list
[18:04:24.252]             seq.int <- base::seq.int
[18:04:24.252]             signalCondition <- base::signalCondition
[18:04:24.252]             sys.calls <- base::sys.calls
[18:04:24.252]             `[[` <- base::`[[`
[18:04:24.252]             `+` <- base::`+`
[18:04:24.252]             `<<-` <- base::`<<-`
[18:04:24.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:24.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:24.252]                   3L)]
[18:04:24.252]             }
[18:04:24.252]             function(cond) {
[18:04:24.252]                 is_error <- inherits(cond, "error")
[18:04:24.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:24.252]                   NULL)
[18:04:24.252]                 if (is_error) {
[18:04:24.252]                   sessionInformation <- function() {
[18:04:24.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:24.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:24.252]                       search = base::search(), system = base::Sys.info())
[18:04:24.252]                   }
[18:04:24.252]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:24.252]                     cond$call), session = sessionInformation(), 
[18:04:24.252]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:24.252]                   signalCondition(cond)
[18:04:24.252]                 }
[18:04:24.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:24.252]                 "immediateCondition"))) {
[18:04:24.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:24.252]                   ...future.conditions[[length(...future.conditions) + 
[18:04:24.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:24.252]                   if (TRUE && !signal) {
[18:04:24.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.252]                     {
[18:04:24.252]                       inherits <- base::inherits
[18:04:24.252]                       invokeRestart <- base::invokeRestart
[18:04:24.252]                       is.null <- base::is.null
[18:04:24.252]                       muffled <- FALSE
[18:04:24.252]                       if (inherits(cond, "message")) {
[18:04:24.252]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.252]                         if (muffled) 
[18:04:24.252]                           invokeRestart("muffleMessage")
[18:04:24.252]                       }
[18:04:24.252]                       else if (inherits(cond, "warning")) {
[18:04:24.252]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.252]                         if (muffled) 
[18:04:24.252]                           invokeRestart("muffleWarning")
[18:04:24.252]                       }
[18:04:24.252]                       else if (inherits(cond, "condition")) {
[18:04:24.252]                         if (!is.null(pattern)) {
[18:04:24.252]                           computeRestarts <- base::computeRestarts
[18:04:24.252]                           grepl <- base::grepl
[18:04:24.252]                           restarts <- computeRestarts(cond)
[18:04:24.252]                           for (restart in restarts) {
[18:04:24.252]                             name <- restart$name
[18:04:24.252]                             if (is.null(name)) 
[18:04:24.252]                               next
[18:04:24.252]                             if (!grepl(pattern, name)) 
[18:04:24.252]                               next
[18:04:24.252]                             invokeRestart(restart)
[18:04:24.252]                             muffled <- TRUE
[18:04:24.252]                             break
[18:04:24.252]                           }
[18:04:24.252]                         }
[18:04:24.252]                       }
[18:04:24.252]                       invisible(muffled)
[18:04:24.252]                     }
[18:04:24.252]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.252]                   }
[18:04:24.252]                 }
[18:04:24.252]                 else {
[18:04:24.252]                   if (TRUE) {
[18:04:24.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:24.252]                     {
[18:04:24.252]                       inherits <- base::inherits
[18:04:24.252]                       invokeRestart <- base::invokeRestart
[18:04:24.252]                       is.null <- base::is.null
[18:04:24.252]                       muffled <- FALSE
[18:04:24.252]                       if (inherits(cond, "message")) {
[18:04:24.252]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:24.252]                         if (muffled) 
[18:04:24.252]                           invokeRestart("muffleMessage")
[18:04:24.252]                       }
[18:04:24.252]                       else if (inherits(cond, "warning")) {
[18:04:24.252]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:24.252]                         if (muffled) 
[18:04:24.252]                           invokeRestart("muffleWarning")
[18:04:24.252]                       }
[18:04:24.252]                       else if (inherits(cond, "condition")) {
[18:04:24.252]                         if (!is.null(pattern)) {
[18:04:24.252]                           computeRestarts <- base::computeRestarts
[18:04:24.252]                           grepl <- base::grepl
[18:04:24.252]                           restarts <- computeRestarts(cond)
[18:04:24.252]                           for (restart in restarts) {
[18:04:24.252]                             name <- restart$name
[18:04:24.252]                             if (is.null(name)) 
[18:04:24.252]                               next
[18:04:24.252]                             if (!grepl(pattern, name)) 
[18:04:24.252]                               next
[18:04:24.252]                             invokeRestart(restart)
[18:04:24.252]                             muffled <- TRUE
[18:04:24.252]                             break
[18:04:24.252]                           }
[18:04:24.252]                         }
[18:04:24.252]                       }
[18:04:24.252]                       invisible(muffled)
[18:04:24.252]                     }
[18:04:24.252]                     muffleCondition(cond, pattern = "^muffle")
[18:04:24.252]                   }
[18:04:24.252]                 }
[18:04:24.252]             }
[18:04:24.252]         }))
[18:04:24.252]     }, error = function(ex) {
[18:04:24.252]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:24.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:24.252]                 ...future.rng), started = ...future.startTime, 
[18:04:24.252]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:24.252]             version = "1.8"), class = "FutureResult")
[18:04:24.252]     }, finally = {
[18:04:24.252]         if (!identical(...future.workdir, getwd())) 
[18:04:24.252]             setwd(...future.workdir)
[18:04:24.252]         {
[18:04:24.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:24.252]                 ...future.oldOptions$nwarnings <- NULL
[18:04:24.252]             }
[18:04:24.252]             base::options(...future.oldOptions)
[18:04:24.252]             if (.Platform$OS.type == "windows") {
[18:04:24.252]                 old_names <- names(...future.oldEnvVars)
[18:04:24.252]                 envs <- base::Sys.getenv()
[18:04:24.252]                 names <- names(envs)
[18:04:24.252]                 common <- intersect(names, old_names)
[18:04:24.252]                 added <- setdiff(names, old_names)
[18:04:24.252]                 removed <- setdiff(old_names, names)
[18:04:24.252]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:24.252]                   envs[common]]
[18:04:24.252]                 NAMES <- toupper(changed)
[18:04:24.252]                 args <- list()
[18:04:24.252]                 for (kk in seq_along(NAMES)) {
[18:04:24.252]                   name <- changed[[kk]]
[18:04:24.252]                   NAME <- NAMES[[kk]]
[18:04:24.252]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.252]                     next
[18:04:24.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.252]                 }
[18:04:24.252]                 NAMES <- toupper(added)
[18:04:24.252]                 for (kk in seq_along(NAMES)) {
[18:04:24.252]                   name <- added[[kk]]
[18:04:24.252]                   NAME <- NAMES[[kk]]
[18:04:24.252]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.252]                     next
[18:04:24.252]                   args[[name]] <- ""
[18:04:24.252]                 }
[18:04:24.252]                 NAMES <- toupper(removed)
[18:04:24.252]                 for (kk in seq_along(NAMES)) {
[18:04:24.252]                   name <- removed[[kk]]
[18:04:24.252]                   NAME <- NAMES[[kk]]
[18:04:24.252]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:24.252]                     next
[18:04:24.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:24.252]                 }
[18:04:24.252]                 if (length(args) > 0) 
[18:04:24.252]                   base::do.call(base::Sys.setenv, args = args)
[18:04:24.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:24.252]             }
[18:04:24.252]             else {
[18:04:24.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:24.252]             }
[18:04:24.252]             {
[18:04:24.252]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:24.252]                   0L) {
[18:04:24.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:24.252]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:24.252]                   base::options(opts)
[18:04:24.252]                 }
[18:04:24.252]                 {
[18:04:24.252]                   {
[18:04:24.252]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:24.252]                     NULL
[18:04:24.252]                   }
[18:04:24.252]                   options(future.plan = NULL)
[18:04:24.252]                   if (is.na(NA_character_)) 
[18:04:24.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:24.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:24.252]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:24.252]                     .init = FALSE)
[18:04:24.252]                 }
[18:04:24.252]             }
[18:04:24.252]         }
[18:04:24.252]     })
[18:04:24.252]     if (TRUE) {
[18:04:24.252]         base::sink(type = "output", split = FALSE)
[18:04:24.252]         if (TRUE) {
[18:04:24.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:24.252]         }
[18:04:24.252]         else {
[18:04:24.252]             ...future.result["stdout"] <- base::list(NULL)
[18:04:24.252]         }
[18:04:24.252]         base::close(...future.stdout)
[18:04:24.252]         ...future.stdout <- NULL
[18:04:24.252]     }
[18:04:24.252]     ...future.result$conditions <- ...future.conditions
[18:04:24.252]     ...future.result$finished <- base::Sys.time()
[18:04:24.252]     ...future.result
[18:04:24.252] }
[18:04:24.256] Poll #1 (0): usedNodes() = 2, workers = 2
[18:04:24.267] receiveMessageFromWorker() for ClusterFuture ...
[18:04:24.268] - Validating connection of MultisessionFuture
[18:04:24.268] - received message: FutureResult
[18:04:24.268] - Received FutureResult
[18:04:24.269] - Erased future from FutureRegistry
[18:04:24.269] result() for ClusterFuture ...
[18:04:24.269] - result already collected: FutureResult
[18:04:24.269] result() for ClusterFuture ... done
[18:04:24.269] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:24.270] result() for ClusterFuture ...
[18:04:24.270] - result already collected: FutureResult
[18:04:24.270] result() for ClusterFuture ... done
[18:04:24.270] result() for ClusterFuture ...
[18:04:24.270] - result already collected: FutureResult
[18:04:24.270] result() for ClusterFuture ... done
[18:04:24.272] MultisessionFuture started
[18:04:24.273] - Launch lazy future ... done
[18:04:24.273] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2b284510> 
Classes 'listenv', 'environment' <environment: 0x5e3c2c585708> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[18:04:24.282] receiveMessageFromWorker() for ClusterFuture ...
[18:04:24.283] - Validating connection of MultisessionFuture
[18:04:24.283] - received message: FutureResult
[18:04:24.283] - Received FutureResult
[18:04:24.283] - Erased future from FutureRegistry
[18:04:24.284] result() for ClusterFuture ...
[18:04:24.284] - result already collected: FutureResult
[18:04:24.284] result() for ClusterFuture ... done
[18:04:24.284] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[18:04:24.302] resolve() on list environment ...
[18:04:24.302]  recursive: 0
[18:04:24.304]  length: 6
[18:04:24.304]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[18:04:24.305] signalConditionsASAP(numeric, pos=1) ...
[18:04:24.305] - nx: 6
[18:04:24.305] - relay: TRUE
[18:04:24.305] - stdout: TRUE
[18:04:24.306] - signal: TRUE
[18:04:24.306] - resignal: FALSE
[18:04:24.306] - force: TRUE
[18:04:24.306] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.306] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.307]  - until=2
[18:04:24.307]  - relaying element #2
[18:04:24.307] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.307] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.307] signalConditionsASAP(NULL, pos=1) ... done
[18:04:24.307]  length: 5 (resolved future 1)
[18:04:24.308] Future #2
[18:04:24.308] result() for ClusterFuture ...
[18:04:24.308] - result already collected: FutureResult
[18:04:24.308] result() for ClusterFuture ... done
[18:04:24.309] result() for ClusterFuture ...
[18:04:24.309] - result already collected: FutureResult
[18:04:24.309] result() for ClusterFuture ... done
[18:04:24.309] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:04:24.309] - nx: 6
[18:04:24.310] - relay: TRUE
[18:04:24.310] - stdout: TRUE
[18:04:24.310] - signal: TRUE
[18:04:24.310] - resignal: FALSE
[18:04:24.310] - force: TRUE
[18:04:24.311] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.311] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[18:04:24.311]  - until=2
[18:04:24.311]  - relaying element #2
[18:04:24.311] result() for ClusterFuture ...
[18:04:24.312] - result already collected: FutureResult
[18:04:24.312] result() for ClusterFuture ... done
[18:04:24.312] result() for ClusterFuture ...
[18:04:24.312] - result already collected: FutureResult
[18:04:24.312] result() for ClusterFuture ... done
[18:04:24.313] result() for ClusterFuture ...
[18:04:24.313] - result already collected: FutureResult
[18:04:24.313] result() for ClusterFuture ... done
[18:04:24.313] result() for ClusterFuture ...
[18:04:24.313] - result already collected: FutureResult
[18:04:24.314] result() for ClusterFuture ... done
[18:04:24.316] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:24.316] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:24.316] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:04:24.317]  length: 4 (resolved future 2)
[18:04:24.317] Future #3
[18:04:24.317] result() for ClusterFuture ...
[18:04:24.317] - result already collected: FutureResult
[18:04:24.318] result() for ClusterFuture ... done
[18:04:24.319] result() for ClusterFuture ...
[18:04:24.319] - result already collected: FutureResult
[18:04:24.319] result() for ClusterFuture ... done
[18:04:24.319] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:04:24.319] - nx: 6
[18:04:24.320] - relay: TRUE
[18:04:24.320] - stdout: TRUE
[18:04:24.320] - signal: TRUE
[18:04:24.320] - resignal: FALSE
[18:04:24.320] - force: TRUE
[18:04:24.320] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:24.321] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[18:04:24.321]  - until=3
[18:04:24.321]  - relaying element #3
[18:04:24.321] result() for ClusterFuture ...
[18:04:24.322] - result already collected: FutureResult
[18:04:24.322] result() for ClusterFuture ... done
[18:04:24.322] result() for ClusterFuture ...
[18:04:24.322] - result already collected: FutureResult
[18:04:24.322] result() for ClusterFuture ... done
[18:04:24.323] result() for ClusterFuture ...
[18:04:24.323] - result already collected: FutureResult
[18:04:24.323] result() for ClusterFuture ... done
[18:04:24.323] result() for ClusterFuture ...
[18:04:24.323] - result already collected: FutureResult
[18:04:24.323] result() for ClusterFuture ... done
[18:04:24.324] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:24.324] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:24.324] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:04:24.324]  length: 3 (resolved future 3)
[18:04:24.325] receiveMessageFromWorker() for ClusterFuture ...
[18:04:24.326] - Validating connection of MultisessionFuture
[18:04:24.326] - received message: FutureResult
[18:04:24.326] - Received FutureResult
[18:04:24.327] - Erased future from FutureRegistry
[18:04:24.327] result() for ClusterFuture ...
[18:04:24.327] - result already collected: FutureResult
[18:04:24.327] result() for ClusterFuture ... done
[18:04:24.328] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:24.328] Future #4
[18:04:24.328] result() for ClusterFuture ...
[18:04:24.328] - result already collected: FutureResult
[18:04:24.328] result() for ClusterFuture ... done
[18:04:24.328] result() for ClusterFuture ...
[18:04:24.329] - result already collected: FutureResult
[18:04:24.329] result() for ClusterFuture ... done
[18:04:24.329] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:04:24.329] - nx: 6
[18:04:24.329] - relay: TRUE
[18:04:24.330] - stdout: TRUE
[18:04:24.330] - signal: TRUE
[18:04:24.330] - resignal: FALSE
[18:04:24.330] - force: TRUE
[18:04:24.330] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:24.331] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[18:04:24.331]  - until=4
[18:04:24.331]  - relaying element #4
[18:04:24.331] result() for ClusterFuture ...
[18:04:24.331] - result already collected: FutureResult
[18:04:24.332] result() for ClusterFuture ... done
[18:04:24.332] result() for ClusterFuture ...
[18:04:24.332] - result already collected: FutureResult
[18:04:24.332] result() for ClusterFuture ... done
[18:04:24.332] result() for ClusterFuture ...
[18:04:24.333] - result already collected: FutureResult
[18:04:24.333] result() for ClusterFuture ... done
[18:04:24.333] result() for ClusterFuture ...
[18:04:24.333] - result already collected: FutureResult
[18:04:24.333] result() for ClusterFuture ... done
[18:04:24.334] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.334] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.334] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:04:24.334]  length: 2 (resolved future 4)
[18:04:24.334] signalConditionsASAP(NULL, pos=5) ...
[18:04:24.335] - nx: 6
[18:04:24.335] - relay: TRUE
[18:04:24.335] - stdout: TRUE
[18:04:24.335] - signal: TRUE
[18:04:24.335] - resignal: FALSE
[18:04:24.336] - force: TRUE
[18:04:24.336] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.336] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.336]  - until=6
[18:04:24.336]  - relaying element #6
[18:04:24.337] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:24.337] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.337] signalConditionsASAP(NULL, pos=5) ... done
[18:04:24.337]  length: 1 (resolved future 5)
[18:04:24.337] signalConditionsASAP(numeric, pos=6) ...
[18:04:24.338] - nx: 6
[18:04:24.338] - relay: TRUE
[18:04:24.338] - stdout: TRUE
[18:04:24.338] - signal: TRUE
[18:04:24.338] - resignal: FALSE
[18:04:24.339] - force: TRUE
[18:04:24.339] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[18:04:24.339] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.339]  - until=6
[18:04:24.339] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:24.340] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.340] signalConditionsASAP(numeric, pos=6) ... done
[18:04:24.340]  length: 0 (resolved future 6)
[18:04:24.340] Relaying remaining futures
[18:04:24.340] signalConditionsASAP(NULL, pos=0) ...
[18:04:24.341] - nx: 6
[18:04:24.341] - relay: TRUE
[18:04:24.341] - stdout: TRUE
[18:04:24.341] - signal: TRUE
[18:04:24.341] - resignal: FALSE
[18:04:24.341] - force: TRUE
[18:04:24.342] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:24.343] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[18:04:24.345] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[18:04:24.345] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[18:04:24.345] signalConditionsASAP(NULL, pos=0) ... done
[18:04:24.346] resolve() on list environment ... DONE
[18:04:24.350] result() for ClusterFuture ...
[18:04:24.350] - result already collected: FutureResult
[18:04:24.350] result() for ClusterFuture ... done
[18:04:24.351] result() for ClusterFuture ...
[18:04:24.351] - result already collected: FutureResult
[18:04:24.351] result() for ClusterFuture ... done
[18:04:24.351] result() for ClusterFuture ...
[18:04:24.352] - result already collected: FutureResult
[18:04:24.352] result() for ClusterFuture ... done
[18:04:24.352] result() for ClusterFuture ...
[18:04:24.352] - result already collected: FutureResult
[18:04:24.352] result() for ClusterFuture ... done
[18:04:24.353] result() for ClusterFuture ...
[18:04:24.353] - result already collected: FutureResult
[18:04:24.353] result() for ClusterFuture ... done
[18:04:24.354] result() for ClusterFuture ...
[18:04:24.354] - result already collected: FutureResult
[18:04:24.354] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5e3c2c9fee88> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[18:04:24.360] plan(): Setting new future strategy stack:
[18:04:24.360] List of future strategies:
[18:04:24.360] 1. FutureStrategy:
[18:04:24.360]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:24.360]    - tweaked: FALSE
[18:04:24.360]    - call: future::plan(oplan)
[18:04:24.362] plan(): nbrOfWorkers() = 1
> 
